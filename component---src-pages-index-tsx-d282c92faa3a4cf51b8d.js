(self.webpackChunkjustice40_tool=self.webpackChunkjustice40_tool||[]).push([[245],{75645:function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function (window, document, exportName, undefined) {\n  'use strict';\n\n  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n  var TEST_ELEMENT = document.createElement('div');\n  var TYPE_FUNCTION = 'function';\n  var round = Math.round;\n  var abs = Math.abs;\n  var now = Date.now;\n\n  /**\n   * set a timeout with a given scope\n   * @param {Function} fn\n   * @param {Number} timeout\n   * @param {Object} context\n   * @returns {number}\n   */\n  function setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n  }\n\n  /**\n   * if the argument is an array, we want to execute the fn on each entry\n   * if it aint an array we don't want to do a thing.\n   * this is used by all the methods that accept a single and array argument.\n   * @param {*|Array} arg\n   * @param {String} fn\n   * @param {Object} [context]\n   * @returns {Boolean}\n   */\n  function invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n      each(arg, context[fn], context);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * walk objects and arrays\n   * @param {Object} obj\n   * @param {Function} iterator\n   * @param {Object} context\n   */\n  function each(obj, iterator, context) {\n    var i;\n    if (!obj) {\n      return;\n    }\n    if (obj.forEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n      i = 0;\n      while (i < obj.length) {\n        iterator.call(context, obj[i], i, obj);\n        i++;\n      }\n    } else {\n      for (i in obj) {\n        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n      }\n    }\n  }\n\n  /**\n   * wrap a method with a deprecation warning and stack trace\n   * @param {Function} method\n   * @param {String} name\n   * @param {String} message\n   * @returns {Function} A new function wrapping the supplied method.\n   */\n  function deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function () {\n      var e = new Error('get-stack-trace');\n      var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n      var log = window.console && (window.console.warn || window.console.log);\n      if (log) {\n        log.call(window.console, deprecationMessage, stack);\n      }\n      return method.apply(this, arguments);\n    };\n  }\n\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} target\n   * @param {...Object} objects_to_assign\n   * @returns {Object} target\n   */\n  var assign;\n  if (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n      var output = Object(target);\n      for (var index = 1; index < arguments.length; index++) {\n        var source = arguments[index];\n        if (source !== undefined && source !== null) {\n          for (var nextKey in source) {\n            if (source.hasOwnProperty(nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n      return output;\n    };\n  } else {\n    assign = Object.assign;\n  }\n\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} dest\n   * @param {Object} src\n   * @param {Boolean} [merge=false]\n   * @returns {Object} dest\n   */\n  var extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n      if (!merge || merge && dest[keys[i]] === undefined) {\n        dest[keys[i]] = src[keys[i]];\n      }\n      i++;\n    }\n    return dest;\n  }, 'extend', 'Use `assign`.');\n\n  /**\n   * merge the values from src in the dest.\n   * means that properties that exist in dest will not be overwritten by src\n   * @param {Object} dest\n   * @param {Object} src\n   * @returns {Object} dest\n   */\n  var merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n  }, 'merge', 'Use `assign`.');\n\n  /**\n   * simple class inheritance\n   * @param {Function} child\n   * @param {Function} base\n   * @param {Object} [properties]\n   */\n  function inherit(child, base, properties) {\n    var baseP = base.prototype,\n      childP;\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n    if (properties) {\n      assign(childP, properties);\n    }\n  }\n\n  /**\n   * simple function bind\n   * @param {Function} fn\n   * @param {Object} context\n   * @returns {Function}\n   */\n  function bindFn(fn, context) {\n    return function boundFn() {\n      return fn.apply(context, arguments);\n    };\n  }\n\n  /**\n   * let a boolean value also be a function that must return a boolean\n   * this first item in args will be used as the context\n   * @param {Boolean|Function} val\n   * @param {Array} [args]\n   * @returns {Boolean}\n   */\n  function boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n      return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n  }\n\n  /**\n   * use the val2 when val1 is undefined\n   * @param {*} val1\n   * @param {*} val2\n   * @returns {*}\n   */\n  function ifUndefined(val1, val2) {\n    return val1 === undefined ? val2 : val1;\n  }\n\n  /**\n   * addEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n  function addEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.addEventListener(type, handler, false);\n    });\n  }\n\n  /**\n   * removeEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n  function removeEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.removeEventListener(type, handler, false);\n    });\n  }\n\n  /**\n   * find if a node is in the given parent\n   * @method hasParent\n   * @param {HTMLElement} node\n   * @param {HTMLElement} parent\n   * @return {Boolean} found\n   */\n  function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n      node = node.parentNode;\n    }\n    return false;\n  }\n\n  /**\n   * small indexOf wrapper\n   * @param {String} str\n   * @param {String} find\n   * @returns {Boolean} found\n   */\n  function inStr(str, find) {\n    return str.indexOf(find) > -1;\n  }\n\n  /**\n   * split string on whitespace\n   * @param {String} str\n   * @returns {Array} words\n   */\n  function splitStr(str) {\n    return str.trim().split(/\\s+/g);\n  }\n\n  /**\n   * find if a array contains the object using indexOf or a simple polyFill\n   * @param {Array} src\n   * @param {String} find\n   * @param {String} [findByKey]\n   * @return {Boolean|Number} false when not found, or the index\n   */\n  function inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n      return src.indexOf(find);\n    } else {\n      var i = 0;\n      while (i < src.length) {\n        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n          return i;\n        }\n        i++;\n      }\n      return -1;\n    }\n  }\n\n  /**\n   * convert array-like objects to real arrays\n   * @param {Object} obj\n   * @returns {Array}\n   */\n  function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  }\n\n  /**\n   * unique array with objects based on a key (like 'id') or just by the array's value\n   * @param {Array} src [{id:1},{id:2},{id:1}]\n   * @param {String} [key]\n   * @param {Boolean} [sort=False]\n   * @returns {Array} [{id:1},{id:2}]\n   */\n  function uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n    while (i < src.length) {\n      var val = key ? src[i][key] : src[i];\n      if (inArray(values, val) < 0) {\n        results.push(src[i]);\n      }\n      values[i] = val;\n      i++;\n    }\n    if (sort) {\n      if (!key) {\n        results = results.sort();\n      } else {\n        results = results.sort(function sortUniqueArray(a, b) {\n          return a[key] > b[key];\n        });\n      }\n    }\n    return results;\n  }\n\n  /**\n   * get the prefixed property\n   * @param {Object} obj\n   * @param {String} property\n   * @returns {String|Undefined} prefixed\n   */\n  function prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n      prefix = VENDOR_PREFIXES[i];\n      prop = prefix ? prefix + camelProp : property;\n      if (prop in obj) {\n        return prop;\n      }\n      i++;\n    }\n    return undefined;\n  }\n\n  /**\n   * get a unique id\n   * @returns {number} uniqueId\n   */\n  var _uniqueId = 1;\n  function uniqueId() {\n    return _uniqueId++;\n  }\n\n  /**\n   * get the window object of an element\n   * @param {HTMLElement} element\n   * @returns {DocumentView|Window}\n   */\n  function getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return doc.defaultView || doc.parentWindow || window;\n  }\n  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n  var SUPPORT_TOUCH = 'ontouchstart' in window;\n  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n  var INPUT_TYPE_TOUCH = 'touch';\n  var INPUT_TYPE_PEN = 'pen';\n  var INPUT_TYPE_MOUSE = 'mouse';\n  var INPUT_TYPE_KINECT = 'kinect';\n  var COMPUTE_INTERVAL = 25;\n  var INPUT_START = 1;\n  var INPUT_MOVE = 2;\n  var INPUT_END = 4;\n  var INPUT_CANCEL = 8;\n  var DIRECTION_NONE = 1;\n  var DIRECTION_LEFT = 2;\n  var DIRECTION_RIGHT = 4;\n  var DIRECTION_UP = 8;\n  var DIRECTION_DOWN = 16;\n  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n  var PROPS_XY = ['x', 'y'];\n  var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n  /**\n   * create new input type manager\n   * @param {Manager} manager\n   * @param {Function} callback\n   * @returns {Input}\n   * @constructor\n   */\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n    this.init();\n  }\n  Input.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function () {},\n    /**\n     * bind the events\n     */\n    init: function () {\n      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n    /**\n     * unbind the events\n     */\n    destroy: function () {\n      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n  };\n\n  /**\n   * create new input type manager\n   * called by the Manager constructor\n   * @param {Hammer} manager\n   * @returns {Input}\n   */\n  function createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n    if (inputClass) {\n      Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n      Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n      Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n      Type = MouseInput;\n    } else {\n      Type = TouchMouseInput;\n    }\n    return new Type(manager, inputHandler);\n  }\n\n  /**\n   * handle input events\n   * @param {Manager} manager\n   * @param {String} eventType\n   * @param {Object} input\n   */\n  function inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n    if (isFirst) {\n      manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n    manager.recognize(input);\n    manager.session.prevInput = input;\n  }\n\n  /**\n   * extend the data with some usable properties like scale, rotate, velocity etc\n   * @param {Object} manager\n   * @param {Object} input\n   */\n  function computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n      session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n      session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n      session.firstMultiple = false;\n    }\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n    input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n      target = input.srcEvent.target;\n    }\n    input.target = target;\n  }\n  function computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n      prevDelta = session.prevDelta = {\n        x: prevInput.deltaX || 0,\n        y: prevInput.deltaY || 0\n      };\n      offset = session.offsetDelta = {\n        x: center.x,\n        y: center.y\n      };\n    }\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n  }\n\n  /**\n   * velocity is calculated every x ms\n   * @param {Object} session\n   * @param {Object} input\n   */\n  function computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n      deltaTime = input.timeStamp - last.timeStamp,\n      velocity,\n      velocityX,\n      velocityY,\n      direction;\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n      var deltaX = input.deltaX - last.deltaX;\n      var deltaY = input.deltaY - last.deltaY;\n      var v = getVelocity(deltaTime, deltaX, deltaY);\n      velocityX = v.x;\n      velocityY = v.y;\n      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n      direction = getDirection(deltaX, deltaY);\n      session.lastInterval = input;\n    } else {\n      // use latest velocity info if it doesn't overtake a minimum period\n      velocity = last.velocity;\n      velocityX = last.velocityX;\n      velocityY = last.velocityY;\n      direction = last.direction;\n    }\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n  }\n\n  /**\n   * create a simple clone from the input used for storage of firstInput and firstMultiple\n   * @param {Object} input\n   * @returns {Object} clonedInputData\n   */\n  function simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n      pointers[i] = {\n        clientX: round(input.pointers[i].clientX),\n        clientY: round(input.pointers[i].clientY)\n      };\n      i++;\n    }\n    return {\n      timeStamp: now(),\n      pointers: pointers,\n      center: getCenter(pointers),\n      deltaX: input.deltaX,\n      deltaY: input.deltaY\n    };\n  }\n\n  /**\n   * get the center of all the pointers\n   * @param {Array} pointers\n   * @return {Object} center contains `x` and `y` properties\n   */\n  function getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n      return {\n        x: round(pointers[0].clientX),\n        y: round(pointers[0].clientY)\n      };\n    }\n    var x = 0,\n      y = 0,\n      i = 0;\n    while (i < pointersLength) {\n      x += pointers[i].clientX;\n      y += pointers[i].clientY;\n      i++;\n    }\n    return {\n      x: round(x / pointersLength),\n      y: round(y / pointersLength)\n    };\n  }\n\n  /**\n   * calculate the velocity between two points. unit is in px per ms.\n   * @param {Number} deltaTime\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Object} velocity `x` and `y`\n   */\n  function getVelocity(deltaTime, x, y) {\n    return {\n      x: x / deltaTime || 0,\n      y: y / deltaTime || 0\n    };\n  }\n\n  /**\n   * get the direction between two points\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Number} direction\n   */\n  function getDirection(x, y) {\n    if (x === y) {\n      return DIRECTION_NONE;\n    }\n    if (abs(x) >= abs(y)) {\n      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  }\n\n  /**\n   * calculate the absolute distance between two points\n   * @param {Object} p1 {x, y}\n   * @param {Object} p2 {x, y}\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} distance\n   */\n  function getDistance(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n      y = p2[props[1]] - p1[props[1]];\n    return Math.sqrt(x * x + y * y);\n  }\n\n  /**\n   * calculate the angle between two coordinates\n   * @param {Object} p1\n   * @param {Object} p2\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} angle\n   */\n  function getAngle(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n      y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n  }\n\n  /**\n   * calculate the rotation degrees between two pointersets\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} rotation\n   */\n  function getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n  }\n\n  /**\n   * calculate the scale factor between two pointersets\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} scale\n   */\n  function getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n  }\n  var MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n  };\n  var MOUSE_ELEMENT_EVENTS = 'mousedown';\n  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n  /**\n   * Mouse events input\n   * @constructor\n   * @extends Input\n   */\n  function MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n  }\n  inherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n      var eventType = MOUSE_INPUT_MAP[ev.type];\n\n      // on start we want to have the left mouse button down\n      if (eventType & INPUT_START && ev.button === 0) {\n        this.pressed = true;\n      }\n      if (eventType & INPUT_MOVE && ev.which !== 1) {\n        eventType = INPUT_END;\n      }\n\n      // mouse must be down\n      if (!this.pressed) {\n        return;\n      }\n      if (eventType & INPUT_END) {\n        this.pressed = false;\n      }\n      this.callback(this.manager, eventType, {\n        pointers: [ev],\n        changedPointers: [ev],\n        pointerType: INPUT_TYPE_MOUSE,\n        srcEvent: ev\n      });\n    }\n  });\n  var POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n  };\n\n  // in IE10 the pointer types is defined as an enum\n  var IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n  };\n  var POINTER_ELEMENT_EVENTS = 'pointerdown';\n  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n  // IE10 has prefixed support, and case-sensitive\n  if (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n  }\n\n  /**\n   * Pointer events input\n   * @constructor\n   * @extends Input\n   */\n  function PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n    Input.apply(this, arguments);\n    this.store = this.manager.session.pointerEvents = [];\n  }\n  inherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n      var store = this.store;\n      var removePointer = false;\n      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n      var isTouch = pointerType == INPUT_TYPE_TOUCH;\n\n      // get index of the event in the store\n      var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n      // start and mouse must be down\n      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n        if (storeIndex < 0) {\n          store.push(ev);\n          storeIndex = store.length - 1;\n        }\n      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        removePointer = true;\n      }\n\n      // it not found, so the pointer hasn't been down (so it's probably a hover)\n      if (storeIndex < 0) {\n        return;\n      }\n\n      // update the event in the store\n      store[storeIndex] = ev;\n      this.callback(this.manager, eventType, {\n        pointers: store,\n        changedPointers: [ev],\n        pointerType: pointerType,\n        srcEvent: ev\n      });\n      if (removePointer) {\n        // remove from the store\n        store.splice(storeIndex, 1);\n      }\n    }\n  });\n  var SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n  /**\n   * Touch events input\n   * @constructor\n   * @extends Input\n   */\n  function SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n    Input.apply(this, arguments);\n  }\n  inherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n      var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n      // should we handle the touch events?\n      if (type === INPUT_START) {\n        this.started = true;\n      }\n      if (!this.started) {\n        return;\n      }\n      var touches = normalizeSingleTouches.call(this, ev, type);\n\n      // when done, reset the started state\n      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n        this.started = false;\n      }\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n  function normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n    return [all, changed];\n  }\n  var TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n  /**\n   * Multi-user touch events input\n   * @constructor\n   * @extends Input\n   */\n  function TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n    Input.apply(this, arguments);\n  }\n  inherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n      var type = TOUCH_INPUT_MAP[ev.type];\n      var touches = getTouches.call(this, ev, type);\n      if (!touches) {\n        return;\n      }\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n  function getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n      targetIds[allTouches[0].identifier] = true;\n      return [allTouches, allTouches];\n    }\n    var i,\n      targetTouches,\n      changedTouches = toArray(ev.changedTouches),\n      changedTargetTouches = [],\n      target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function (touch) {\n      return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n      i = 0;\n      while (i < targetTouches.length) {\n        targetIds[targetTouches[i].identifier] = true;\n        i++;\n      }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n      if (targetIds[changedTouches[i].identifier]) {\n        changedTargetTouches.push(changedTouches[i]);\n      }\n\n      // cleanup removed touches\n      if (type & (INPUT_END | INPUT_CANCEL)) {\n        delete targetIds[changedTouches[i].identifier];\n      }\n      i++;\n    }\n    if (!changedTargetTouches.length) {\n      return;\n    }\n    return [\n    // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n  }\n\n  /**\n   * Combined touch and mouse input\n   *\n   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n   * This because touch devices also emit mouse events while doing a touch.\n   *\n   * @constructor\n   * @extends Input\n   */\n\n  var DEDUP_TIMEOUT = 2500;\n  var DEDUP_DISTANCE = 25;\n  function TouchMouseInput() {\n    Input.apply(this, arguments);\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n    this.primaryTouch = null;\n    this.lastTouches = [];\n  }\n  inherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n      var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,\n        isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;\n      if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n        return;\n      }\n\n      // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n      if (isTouch) {\n        recordTouches.call(this, inputEvent, inputData);\n      } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n        return;\n      }\n      this.callback(manager, inputEvent, inputData);\n    },\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    }\n  });\n  function recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n      this.primaryTouch = eventData.changedPointers[0].identifier;\n      setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      setLastTouch.call(this, eventData);\n    }\n  }\n  function setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n    if (touch.identifier === this.primaryTouch) {\n      var lastTouch = {\n        x: touch.clientX,\n        y: touch.clientY\n      };\n      this.lastTouches.push(lastTouch);\n      var lts = this.lastTouches;\n      var removeLastTouch = function () {\n        var i = lts.indexOf(lastTouch);\n        if (i > -1) {\n          lts.splice(i, 1);\n        }\n      };\n      setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n  }\n  function isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX,\n      y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n      var t = this.lastTouches[i];\n      var dx = Math.abs(x - t.x),\n        dy = Math.abs(y - t.y);\n      if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n  // magical touchAction value\n  var TOUCH_ACTION_COMPUTE = 'compute';\n  var TOUCH_ACTION_AUTO = 'auto';\n  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n  var TOUCH_ACTION_NONE = 'none';\n  var TOUCH_ACTION_PAN_X = 'pan-x';\n  var TOUCH_ACTION_PAN_Y = 'pan-y';\n  var TOUCH_ACTION_MAP = getTouchActionProps();\n\n  /**\n   * Touch Action\n   * sets the touchAction property or uses the js alternative\n   * @param {Manager} manager\n   * @param {String} value\n   * @constructor\n   */\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  TouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function (value) {\n      // find out the touch-action by the event handlers\n      if (value == TOUCH_ACTION_COMPUTE) {\n        value = this.compute();\n      }\n      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n      }\n      this.actions = value.toLowerCase().trim();\n    },\n    /**\n     * just re-set the touchAction value\n     */\n    update: function () {\n      this.set(this.manager.options.touchAction);\n    },\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function () {\n      var actions = [];\n      each(this.manager.recognizers, function (recognizer) {\n        if (boolOrFn(recognizer.options.enable, [recognizer])) {\n          actions = actions.concat(recognizer.getTouchAction());\n        }\n      });\n      return cleanTouchActions(actions.join(' '));\n    },\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function (input) {\n      var srcEvent = input.srcEvent;\n      var direction = input.offsetDirection;\n\n      // if the touch action did prevented once this session\n      if (this.manager.session.prevented) {\n        srcEvent.preventDefault();\n        return;\n      }\n      var actions = this.actions;\n      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n      if (hasNone) {\n        //do not prevent defaults if this is a tap gesture\n\n        var isTapPointer = input.pointers.length === 1;\n        var isTapMovement = input.distance < 2;\n        var isTapTouchTime = input.deltaTime < 250;\n        if (isTapPointer && isTapMovement && isTapTouchTime) {\n          return;\n        }\n      }\n      if (hasPanX && hasPanY) {\n        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n        return;\n      }\n      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n        return this.preventSrc(srcEvent);\n      }\n    },\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function (srcEvent) {\n      this.manager.session.prevented = true;\n      srcEvent.preventDefault();\n    }\n  };\n\n  /**\n   * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n   * @param {String} actions\n   * @returns {*}\n   */\n  function cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n      return TOUCH_ACTION_NONE;\n    }\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n      return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n      return TOUCH_ACTION_MANIPULATION;\n    }\n    return TOUCH_ACTION_AUTO;\n  }\n  function getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n      return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n      // If css.supports is not supported but there is native touch-action assume it supports\n      // all values. This is the case for IE 10 and 11.\n      touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n  }\n\n  /**\n   * Recognizer flow explained; *\n   * All recognizers have the initial state of POSSIBLE when a input session starts.\n   * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n   * Example session for mouse-input: mousedown -> mousemove -> mouseup\n   *\n   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n   * which determines with state it should be.\n   *\n   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n   * POSSIBLE to give it another change on the next cycle.\n   *\n   *               Possible\n   *                  |\n   *            +-----+---------------+\n   *            |                     |\n   *      +-----+-----+               |\n   *      |           |               |\n   *   Failed      Cancelled          |\n   *                          +-------+------+\n   *                          |              |\n   *                      Recognized       Began\n   *                                         |\n   *                                      Changed\n   *                                         |\n   *                                  Ended/Recognized\n   */\n  var STATE_POSSIBLE = 1;\n  var STATE_BEGAN = 2;\n  var STATE_CHANGED = 4;\n  var STATE_ENDED = 8;\n  var STATE_RECOGNIZED = STATE_ENDED;\n  var STATE_CANCELLED = 16;\n  var STATE_FAILED = 32;\n\n  /**\n   * Recognizer\n   * Every recognizer needs to extend from this class.\n   * @constructor\n   * @param {Object} options\n   */\n  function Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n    this.id = uniqueId();\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  Recognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function (options) {\n      assign(this.options, options);\n\n      // also update the touchAction, in case something changed about the directions/enabled state\n      this.manager && this.manager.touchAction.update();\n      return this;\n    },\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n        return this;\n      }\n      var simultaneous = this.simultaneous;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      if (!simultaneous[otherRecognizer.id]) {\n        simultaneous[otherRecognizer.id] = otherRecognizer;\n        otherRecognizer.recognizeWith(this);\n      }\n      return this;\n    },\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n        return this;\n      }\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      delete this.simultaneous[otherRecognizer.id];\n      return this;\n    },\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n        return this;\n      }\n      var requireFail = this.requireFail;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      if (inArray(requireFail, otherRecognizer) === -1) {\n        requireFail.push(otherRecognizer);\n        otherRecognizer.requireFailure(this);\n      }\n      return this;\n    },\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n        return this;\n      }\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      var index = inArray(this.requireFail, otherRecognizer);\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n      return this;\n    },\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function () {\n      return this.requireFail.length > 0;\n    },\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function (otherRecognizer) {\n      return !!this.simultaneous[otherRecognizer.id];\n    },\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function (input) {\n      var self = this;\n      var state = this.state;\n      function emit(event) {\n        self.manager.emit(event, input);\n      }\n\n      // 'panstart' and 'panmove'\n      if (state < STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n      emit(self.options.event); // simple 'eventName' events\n\n      if (input.additionalEvent) {\n        // additional event(panleft, panright, pinchin, pinchout...)\n        emit(input.additionalEvent);\n      }\n\n      // panend and pancancel\n      if (state >= STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n    },\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function (input) {\n      if (this.canEmit()) {\n        return this.emit(input);\n      }\n      // it's failing anyway\n      this.state = STATE_FAILED;\n    },\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function () {\n      var i = 0;\n      while (i < this.requireFail.length) {\n        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n          return false;\n        }\n        i++;\n      }\n      return true;\n    },\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function (inputData) {\n      // make a new copy of the inputData\n      // so we can change the inputData without messing up the other recognizers\n      var inputDataClone = assign({}, inputData);\n\n      // is is enabled and allow recognizing?\n      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n        this.reset();\n        this.state = STATE_FAILED;\n        return;\n      }\n\n      // reset when we've reached the end\n      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n        this.state = STATE_POSSIBLE;\n      }\n      this.state = this.process(inputDataClone);\n\n      // the recognizer has recognized a gesture\n      // so trigger an event\n      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n        this.tryEmit(inputDataClone);\n      }\n    },\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function (inputData) {},\n    // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function () {},\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function () {}\n  };\n\n  /**\n   * get a usable string, used as event postfix\n   * @param {Const} state\n   * @returns {String} state\n   */\n  function stateStr(state) {\n    if (state & STATE_CANCELLED) {\n      return 'cancel';\n    } else if (state & STATE_ENDED) {\n      return 'end';\n    } else if (state & STATE_CHANGED) {\n      return 'move';\n    } else if (state & STATE_BEGAN) {\n      return 'start';\n    }\n    return '';\n  }\n\n  /**\n   * direction cons to string\n   * @param {Const} direction\n   * @returns {String}\n   */\n  function directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n      return 'down';\n    } else if (direction == DIRECTION_UP) {\n      return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n      return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n      return 'right';\n    }\n    return '';\n  }\n\n  /**\n   * get a recognizer by name if it is bound to a manager\n   * @param {Recognizer|String} otherRecognizer\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer}\n   */\n  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n      return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n  }\n\n  /**\n   * This recognizer is just used as a base for the simple attribute recognizers.\n   * @constructor\n   * @extends Recognizer\n   */\n  function AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n  }\n  inherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n      /**\n       * @type {Number}\n       * @default 1\n       */\n      pointers: 1\n    },\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function (input) {\n      var optionPointers = this.options.pointers;\n      return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function (input) {\n      var state = this.state;\n      var eventType = input.eventType;\n      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n      var isValid = this.attrTest(input);\n\n      // on cancel input and we've recognized before, return STATE_CANCELLED\n      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n        return state | STATE_CANCELLED;\n      } else if (isRecognized || isValid) {\n        if (eventType & INPUT_END) {\n          return state | STATE_ENDED;\n        } else if (!(state & STATE_BEGAN)) {\n          return STATE_BEGAN;\n        }\n        return state | STATE_CHANGED;\n      }\n      return STATE_FAILED;\n    }\n  });\n\n  /**\n   * Pan\n   * Recognized when the pointer is down and moved in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n    this.pX = null;\n    this.pY = null;\n  }\n  inherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    },\n    getTouchAction: function () {\n      var direction = this.options.direction;\n      var actions = [];\n      if (direction & DIRECTION_HORIZONTAL) {\n        actions.push(TOUCH_ACTION_PAN_Y);\n      }\n      if (direction & DIRECTION_VERTICAL) {\n        actions.push(TOUCH_ACTION_PAN_X);\n      }\n      return actions;\n    },\n    directionTest: function (input) {\n      var options = this.options;\n      var hasMoved = true;\n      var distance = input.distance;\n      var direction = input.direction;\n      var x = input.deltaX;\n      var y = input.deltaY;\n\n      // lock to axis?\n      if (!(direction & options.direction)) {\n        if (options.direction & DIRECTION_HORIZONTAL) {\n          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          hasMoved = x != this.pX;\n          distance = Math.abs(input.deltaX);\n        } else {\n          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n          hasMoved = y != this.pY;\n          distance = Math.abs(input.deltaY);\n        }\n      }\n      input.direction = direction;\n      return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n    attrTest: function (input) {\n      return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n    },\n    emit: function (input) {\n      this.pX = input.deltaX;\n      this.pY = input.deltaY;\n      var direction = directionStr(input.direction);\n      if (direction) {\n        input.additionalEvent = this.options.event + direction;\n      }\n      this._super.emit.call(this, input);\n    }\n  });\n\n  /**\n   * Pinch\n   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n  inherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function () {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function (input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n    emit: function (input) {\n      if (input.scale !== 1) {\n        var inOut = input.scale < 1 ? 'in' : 'out';\n        input.additionalEvent = this.options.event + inOut;\n      }\n      this._super.emit.call(this, input);\n    }\n  });\n\n  /**\n   * Press\n   * Recognized when the pointer is down for x ms without any movement.\n   * @constructor\n   * @extends Recognizer\n   */\n  function PressRecognizer() {\n    Recognizer.apply(this, arguments);\n    this._timer = null;\n    this._input = null;\n  }\n  inherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9 // a minimal movement is ok, but keep it low\n    },\n    getTouchAction: function () {\n      return [TOUCH_ACTION_AUTO];\n    },\n    process: function (input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTime = input.deltaTime > options.time;\n      this._input = input;\n\n      // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n        this.reset();\n      } else if (input.eventType & INPUT_START) {\n        this.reset();\n        this._timer = setTimeoutContext(function () {\n          this.state = STATE_RECOGNIZED;\n          this.tryEmit();\n        }, options.time, this);\n      } else if (input.eventType & INPUT_END) {\n        return STATE_RECOGNIZED;\n      }\n      return STATE_FAILED;\n    },\n    reset: function () {\n      clearTimeout(this._timer);\n    },\n    emit: function (input) {\n      if (this.state !== STATE_RECOGNIZED) {\n        return;\n      }\n      if (input && input.eventType & INPUT_END) {\n        this.manager.emit(this.options.event + 'up', input);\n      } else {\n        this._input.timeStamp = now();\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n\n  /**\n   * Rotate\n   * Recognized when two or more pointer are moving in a circular motion.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n  inherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function () {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function (input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n  });\n\n  /**\n   * Swipe\n   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n  inherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    },\n    getTouchAction: function () {\n      return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n    attrTest: function (input) {\n      var direction = this.options.direction;\n      var velocity;\n      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n        velocity = input.overallVelocity;\n      } else if (direction & DIRECTION_HORIZONTAL) {\n        velocity = input.overallVelocityX;\n      } else if (direction & DIRECTION_VERTICAL) {\n        velocity = input.overallVelocityY;\n      }\n      return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n    emit: function (input) {\n      var direction = directionStr(input.offsetDirection);\n      if (direction) {\n        this.manager.emit(this.options.event + direction, input);\n      }\n      this.manager.emit(this.options.event, input);\n    }\n  });\n\n  /**\n   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n   * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n   * a single tap.\n   *\n   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n   * multi-taps being recognized.\n   * @constructor\n   * @extends Recognizer\n   */\n  function TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n  inherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n    getTouchAction: function () {\n      return [TOUCH_ACTION_MANIPULATION];\n    },\n    process: function (input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTouchTime = input.deltaTime < options.time;\n      this.reset();\n      if (input.eventType & INPUT_START && this.count === 0) {\n        return this.failTimeout();\n      }\n\n      // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n      if (validMovement && validTouchTime && validPointers) {\n        if (input.eventType != INPUT_END) {\n          return this.failTimeout();\n        }\n        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n        this.pTime = input.timeStamp;\n        this.pCenter = input.center;\n        if (!validMultiTap || !validInterval) {\n          this.count = 1;\n        } else {\n          this.count += 1;\n        }\n        this._input = input;\n\n        // if tap count matches we have recognized it,\n        // else it has began recognizing...\n        var tapCount = this.count % options.taps;\n        if (tapCount === 0) {\n          // no failing requirements, immediately trigger the tap event\n          // or wait as long as the multitap interval to trigger\n          if (!this.hasRequireFailures()) {\n            return STATE_RECOGNIZED;\n          } else {\n            this._timer = setTimeoutContext(function () {\n              this.state = STATE_RECOGNIZED;\n              this.tryEmit();\n            }, options.interval, this);\n            return STATE_BEGAN;\n          }\n        }\n      }\n      return STATE_FAILED;\n    },\n    failTimeout: function () {\n      this._timer = setTimeoutContext(function () {\n        this.state = STATE_FAILED;\n      }, this.options.interval, this);\n      return STATE_FAILED;\n    },\n    reset: function () {\n      clearTimeout(this._timer);\n    },\n    emit: function () {\n      if (this.state == STATE_RECOGNIZED) {\n        this._input.tapCount = this.count;\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n\n  /**\n   * Simple way to create a manager with a default set of recognizers.\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n  function Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n  }\n\n  /**\n   * @const {string}\n   */\n  Hammer.VERSION = '2.0.7';\n\n  /**\n   * default settings\n   * @namespace\n   */\n  Hammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n    // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n    [RotateRecognizer, {\n      enable: false\n    }], [PinchRecognizer, {\n      enable: false\n    }, ['rotate']], [SwipeRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }], [PanRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }, ['swipe']], [TapRecognizer], [TapRecognizer, {\n      event: 'doubletap',\n      taps: 2\n    }, ['tap']], [PressRecognizer]],\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n      /**\n       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userSelect: 'none',\n      /**\n       * Disable the Windows Phone grippers when pressing an element.\n       * @type {String}\n       * @default 'none'\n       */\n      touchSelect: 'none',\n      /**\n       * Disables the default callout shown when you touch and hold a touch target.\n       * On iOS, when you touch and hold a touch target such as a link, Safari displays\n       * a callout containing information about the link. This property allows you to disable that callout.\n       * @type {String}\n       * @default 'none'\n       */\n      touchCallout: 'none',\n      /**\n       * Specifies whether zooming is enabled. Used by IE10>\n       * @type {String}\n       * @default 'none'\n       */\n      contentZooming: 'none',\n      /**\n       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userDrag: 'none',\n      /**\n       * Overrides the highlight color shown when the user taps a link or a JavaScript\n       * clickable element in iOS. This property obeys the alpha value, if specified.\n       * @type {String}\n       * @default 'rgba(0,0,0,0)'\n       */\n      tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n  };\n  var STOP = 1;\n  var FORCED_STOP = 2;\n\n  /**\n   * Manager\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n  function Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = this.add(new item[0](item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  Manager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function (options) {\n      assign(this.options, options);\n\n      // Options that need a little more setup\n      if (options.touchAction) {\n        this.touchAction.update();\n      }\n      if (options.inputTarget) {\n        // Clean up existing event listeners and reinitialize\n        this.input.destroy();\n        this.input.target = options.inputTarget;\n        this.input.init();\n      }\n      return this;\n    },\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function (force) {\n      this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function (inputData) {\n      var session = this.session;\n      if (session.stopped) {\n        return;\n      }\n\n      // run the touch-action polyfill\n      this.touchAction.preventDefaults(inputData);\n      var recognizer;\n      var recognizers = this.recognizers;\n\n      // this holds the recognizer that is being recognized.\n      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n      // if no recognizer is detecting a thing, it is set to `null`\n      var curRecognizer = session.curRecognizer;\n\n      // reset when the last recognizer is recognized\n      // or when we're in a new session\n      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n        curRecognizer = session.curRecognizer = null;\n      }\n      var i = 0;\n      while (i < recognizers.length) {\n        recognizer = recognizers[i];\n\n        // find out if we are allowed try to recognize the input for this one.\n        // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n        //      that is being recognized.\n        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n        //      this can be setup with the `recognizeWith()` method on the recognizer.\n        if (session.stopped !== FORCED_STOP && (\n        // 1\n        !curRecognizer || recognizer == curRecognizer ||\n        // 2\n        recognizer.canRecognizeWith(curRecognizer))) {\n          // 3\n          recognizer.recognize(inputData);\n        } else {\n          recognizer.reset();\n        }\n\n        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n        // current active recognizer. but only if we don't already have an active recognizer\n        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n          curRecognizer = session.curRecognizer = recognizer;\n        }\n        i++;\n      }\n    },\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function (recognizer) {\n      if (recognizer instanceof Recognizer) {\n        return recognizer;\n      }\n      var recognizers = this.recognizers;\n      for (var i = 0; i < recognizers.length; i++) {\n        if (recognizers[i].options.event == recognizer) {\n          return recognizers[i];\n        }\n      }\n      return null;\n    },\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function (recognizer) {\n      if (invokeArrayArg(recognizer, 'add', this)) {\n        return this;\n      }\n\n      // remove existing\n      var existing = this.get(recognizer.options.event);\n      if (existing) {\n        this.remove(existing);\n      }\n      this.recognizers.push(recognizer);\n      recognizer.manager = this;\n      this.touchAction.update();\n      return recognizer;\n    },\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function (recognizer) {\n      if (invokeArrayArg(recognizer, 'remove', this)) {\n        return this;\n      }\n      recognizer = this.get(recognizer);\n\n      // let's make sure this recognizer exists\n      if (recognizer) {\n        var recognizers = this.recognizers;\n        var index = inArray(recognizers, recognizer);\n        if (index !== -1) {\n          recognizers.splice(index, 1);\n          this.touchAction.update();\n        }\n      }\n      return this;\n    },\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function (events, handler) {\n      if (events === undefined) {\n        return;\n      }\n      if (handler === undefined) {\n        return;\n      }\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        handlers[event] = handlers[event] || [];\n        handlers[event].push(handler);\n      });\n      return this;\n    },\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function (events, handler) {\n      if (events === undefined) {\n        return;\n      }\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        if (!handler) {\n          delete handlers[event];\n        } else {\n          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n        }\n      });\n      return this;\n    },\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function (event, data) {\n      // we also want to trigger dom events\n      if (this.options.domEvents) {\n        triggerDomEvent(event, data);\n      }\n\n      // no handlers, so skip it all\n      var handlers = this.handlers[event] && this.handlers[event].slice();\n      if (!handlers || !handlers.length) {\n        return;\n      }\n      data.type = event;\n      data.preventDefault = function () {\n        data.srcEvent.preventDefault();\n      };\n      var i = 0;\n      while (i < handlers.length) {\n        handlers[i](data);\n        i++;\n      }\n    },\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function () {\n      this.element && toggleCssProps(this, false);\n      this.handlers = {};\n      this.session = {};\n      this.input.destroy();\n      this.element = null;\n    }\n  };\n\n  /**\n   * add/remove the css properties as defined in manager.options.cssProps\n   * @param {Manager} manager\n   * @param {Boolean} add\n   */\n  function toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n      return;\n    }\n    var prop;\n    each(manager.options.cssProps, function (value, name) {\n      prop = prefixed(element.style, name);\n      if (add) {\n        manager.oldCssProps[prop] = element.style[prop];\n        element.style[prop] = value;\n      } else {\n        element.style[prop] = manager.oldCssProps[prop] || '';\n      }\n    });\n    if (!add) {\n      manager.oldCssProps = {};\n    }\n  }\n\n  /**\n   * trigger dom event\n   * @param {String} event\n   * @param {Object} data\n   */\n  function triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n  }\n  assign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n  });\n\n  // this prevents errors when Hammer is loaded in the presence of an AMD\n  //  style loader but by script tag, not by the loader.\n  var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line\n  freeGlobal.Hammer = Hammer;\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return Hammer;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, document, 'Hammer');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUSxJQUFJO0FBQ3pCLGFBQWEsUUFBUSxJQUFJO0FBQ3pCLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0NBQWdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxxR0FBcUc7QUFDckc7QUFDQSxNQUFNLElBQTBDO0FBQ2hELElBQUksbUNBQU87QUFDWDtBQUNBLEtBQUs7QUFBQSxrR0FBQztBQUNOLElBQUksS0FBSyxFQUlOO0FBQ0gsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL2hhbW1lcmpzL2hhbW1lci5qcz9lYmZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBIYW1tZXIuSlMgLSB2Mi4wLjcgLSAyMDE2LTA0LTIyXG4gKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNiBKb3JpayBUYW5nZWxkZXI7XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cbihmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgZXhwb3J0TmFtZSwgdW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgVkVORE9SX1BSRUZJWEVTID0gWycnLCAnd2Via2l0JywgJ01veicsICdNUycsICdtcycsICdvJ107XG4gIHZhciBURVNUX0VMRU1FTlQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIFRZUEVfRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xuICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICB2YXIgYWJzID0gTWF0aC5hYnM7XG4gIHZhciBub3cgPSBEYXRlLm5vdztcblxuICAvKipcbiAgICogc2V0IGEgdGltZW91dCB3aXRoIGEgZ2l2ZW4gc2NvcGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRpbWVvdXRDb250ZXh0KGZuLCB0aW1lb3V0LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoYmluZEZuKGZuLCBjb250ZXh0KSwgdGltZW91dCk7XG4gIH1cblxuICAvKipcbiAgICogaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5LCB3ZSB3YW50IHRvIGV4ZWN1dGUgdGhlIGZuIG9uIGVhY2ggZW50cnlcbiAgICogaWYgaXQgYWludCBhbiBhcnJheSB3ZSBkb24ndCB3YW50IHRvIGRvIGEgdGhpbmcuXG4gICAqIHRoaXMgaXMgdXNlZCBieSBhbGwgdGhlIG1ldGhvZHMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYW5kIGFycmF5IGFyZ3VtZW50LlxuICAgKiBAcGFyYW0geyp8QXJyYXl9IGFyZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZm5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiB3YWxrIG9iamVjdHMgYW5kIGFycmF5c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICBmdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgaTtcbiAgICBpZiAoIW9iaikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcbiAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoaSkgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHdyYXAgYSBtZXRob2Qgd2l0aCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgYW5kIHN0YWNrIHRyYWNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHdyYXBwaW5nIHRoZSBzdXBwbGllZCBtZXRob2QuXG4gICAqL1xuICBmdW5jdGlvbiBkZXByZWNhdGUobWV0aG9kLCBuYW1lLCBtZXNzYWdlKSB7XG4gICAgdmFyIGRlcHJlY2F0aW9uTWVzc2FnZSA9ICdERVBSRUNBVEVEIE1FVEhPRDogJyArIG5hbWUgKyAnXFxuJyArIG1lc3NhZ2UgKyAnIEFUIFxcbic7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdnZXQtc3RhY2stdHJhY2UnKTtcbiAgICAgIHZhciBzdGFjayA9IGUgJiYgZS5zdGFjayA/IGUuc3RhY2sucmVwbGFjZSgvXlteXFwoXSs/W1xcbiRdL2dtLCAnJykucmVwbGFjZSgvXlxccythdFxccysvZ20sICcnKS5yZXBsYWNlKC9eT2JqZWN0Ljxhbm9ueW1vdXM+XFxzKlxcKC9nbSwgJ3thbm9ueW1vdXN9KClAJykgOiAnVW5rbm93biBTdGFjayBUcmFjZSc7XG4gICAgICB2YXIgbG9nID0gd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLndhcm4gfHwgd2luZG93LmNvbnNvbGUubG9nKTtcbiAgICAgIGlmIChsb2cpIHtcbiAgICAgICAgbG9nLmNhbGwod2luZG93LmNvbnNvbGUsIGRlcHJlY2F0aW9uTWVzc2FnZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogZXh0ZW5kIG9iamVjdC5cbiAgICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IG9iamVjdHNfdG9fYXNzaWduXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHRhcmdldFxuICAgKi9cbiAgdmFyIGFzc2lnbjtcbiAgaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICAgIH1cbiAgICAgIHZhciBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG4gIH1cblxuICAvKipcbiAgICogZXh0ZW5kIG9iamVjdC5cbiAgICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAgICovXG4gIHZhciBleHRlbmQgPSBkZXByZWNhdGUoZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHtcbiAgICAgIGlmICghbWVyZ2UgfHwgbWVyZ2UgJiYgZGVzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9LCAnZXh0ZW5kJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuICAvKipcbiAgICogbWVyZ2UgdGhlIHZhbHVlcyBmcm9tIHNyYyBpbiB0aGUgZGVzdC5cbiAgICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIHRoYXQgZXhpc3QgaW4gZGVzdCB3aWxsIG5vdCBiZSBvdmVyd3JpdHRlbiBieSBzcmNcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gICAqL1xuICB2YXIgbWVyZ2UgPSBkZXByZWNhdGUoZnVuY3Rpb24gbWVyZ2UoZGVzdCwgc3JjKSB7XG4gICAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xuICB9LCAnbWVyZ2UnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG4gIC8qKlxuICAgKiBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXG4gICAqL1xuICBmdW5jdGlvbiBpbmhlcml0KGNoaWxkLCBiYXNlLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGJhc2VQID0gYmFzZS5wcm90b3R5cGUsXG4gICAgICBjaGlsZFA7XG4gICAgY2hpbGRQID0gY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUCk7XG4gICAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgY2hpbGRQLl9zdXBlciA9IGJhc2VQO1xuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICBhc3NpZ24oY2hpbGRQLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIGxldCBhIGJvb2xlYW4gdmFsdWUgYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgbXVzdCByZXR1cm4gYSBib29sZWFuXG4gICAqIHRoaXMgZmlyc3QgaXRlbSBpbiBhcmdzIHdpbGwgYmUgdXNlZCBhcyB0aGUgY29udGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHZhbFxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnc11cbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBib29sT3JGbih2YWwsIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PSBUWVBFX0ZVTkNUSU9OKSB7XG4gICAgICByZXR1cm4gdmFsLmFwcGx5KGFyZ3MgPyBhcmdzWzBdIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICAvKipcbiAgICogdXNlIHRoZSB2YWwyIHdoZW4gdmFsMSBpcyB1bmRlZmluZWRcbiAgICogQHBhcmFtIHsqfSB2YWwxXG4gICAqIEBwYXJhbSB7Kn0gdmFsMlxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGZ1bmN0aW9uIGlmVW5kZWZpbmVkKHZhbDEsIHZhbDIpIHtcbiAgICByZXR1cm4gdmFsMSA9PT0gdW5kZWZpbmVkID8gdmFsMiA6IHZhbDE7XG4gIH1cblxuICAvKipcbiAgICogYWRkRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlbW92ZUV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGEgbm9kZSBpcyBpbiB0aGUgZ2l2ZW4gcGFyZW50XG4gICAqIEBtZXRob2QgaGFzUGFyZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gICAqL1xuICBmdW5jdGlvbiBoYXNQYXJlbnQobm9kZSwgcGFyZW50KSB7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGlmIChub2RlID09IHBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzbWFsbCBpbmRleE9mIHdyYXBwZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gZm91bmRcbiAgICovXG4gIGZ1bmN0aW9uIGluU3RyKHN0ciwgZmluZCkge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihmaW5kKSA+IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIHNwbGl0IHN0cmluZyBvbiB3aGl0ZXNwYWNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICogQHJldHVybnMge0FycmF5fSB3b3Jkc1xuICAgKi9cbiAgZnVuY3Rpb24gc3BsaXRTdHIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCkuc3BsaXQoL1xccysvZyk7XG4gIH1cblxuICAvKipcbiAgICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxuICAgKiBAcGFyYW0ge0FycmF5fSBzcmNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXG4gICAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gICAqL1xuICBmdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XG4gICAgaWYgKHNyYy5pbmRleE9mICYmICFmaW5kQnlLZXkpIHtcbiAgICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChmaW5kQnlLZXkgJiYgc3JjW2ldW2ZpbmRCeUtleV0gPT0gZmluZCB8fCAhZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogY29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gcmVhbCBhcnJheXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBmdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIHVuaXF1ZSBhcnJheSB3aXRoIG9iamVjdHMgYmFzZWQgb24gYSBrZXkgKGxpa2UgJ2lkJykgb3IganVzdCBieSB0aGUgYXJyYXkncyB2YWx1ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzcmMgW3tpZDoxfSx7aWQ6Mn0se2lkOjF9XVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc29ydD1GYWxzZV1cbiAgICogQHJldHVybnMge0FycmF5fSBbe2lkOjF9LHtpZDoyfV1cbiAgICovXG4gIGZ1bmN0aW9uIHVuaXF1ZUFycmF5KHNyYywga2V5LCBzb3J0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgdmFyIHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xuICAgICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xuICAgICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlc1tpXSA9IHZhbDtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgaWYgKHNvcnQpIHtcbiAgICAgIGlmICgha2V5KSB7XG4gICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoZnVuY3Rpb24gc29ydFVuaXF1ZUFycmF5KGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYVtrZXldID4gYltrZXldO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSBwcmVmaXhlZCBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfFVuZGVmaW5lZH0gcHJlZml4ZWRcbiAgICovXG4gIGZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcbiAgICB2YXIgcHJlZml4LCBwcm9wO1xuICAgIHZhciBjYW1lbFByb3AgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xuICAgICAgcHJlZml4ID0gVkVORE9SX1BSRUZJWEVTW2ldO1xuICAgICAgcHJvcCA9IHByZWZpeCA/IHByZWZpeCArIGNhbWVsUHJvcCA6IHByb3BlcnR5O1xuICAgICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBhIHVuaXF1ZSBpZFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSB1bmlxdWVJZFxuICAgKi9cbiAgdmFyIF91bmlxdWVJZCA9IDE7XG4gIGZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICAgIHJldHVybiBfdW5pcXVlSWQrKztcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0V2luZG93Rm9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgdmFyIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBlbGVtZW50O1xuICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyB8fCB3aW5kb3c7XG4gIH1cbiAgdmFyIE1PQklMRV9SRUdFWCA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWQvaTtcbiAgdmFyIFNVUFBPUlRfVE9VQ0ggPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XG4gIHZhciBTVVBQT1JUX1BPSU5URVJfRVZFTlRTID0gcHJlZml4ZWQod2luZG93LCAnUG9pbnRlckV2ZW50JykgIT09IHVuZGVmaW5lZDtcbiAgdmFyIFNVUFBPUlRfT05MWV9UT1VDSCA9IFNVUFBPUlRfVE9VQ0ggJiYgTU9CSUxFX1JFR0VYLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBJTlBVVF9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbiAgdmFyIElOUFVUX1RZUEVfUEVOID0gJ3Blbic7XG4gIHZhciBJTlBVVF9UWVBFX01PVVNFID0gJ21vdXNlJztcbiAgdmFyIElOUFVUX1RZUEVfS0lORUNUID0gJ2tpbmVjdCc7XG4gIHZhciBDT01QVVRFX0lOVEVSVkFMID0gMjU7XG4gIHZhciBJTlBVVF9TVEFSVCA9IDE7XG4gIHZhciBJTlBVVF9NT1ZFID0gMjtcbiAgdmFyIElOUFVUX0VORCA9IDQ7XG4gIHZhciBJTlBVVF9DQU5DRUwgPSA4O1xuICB2YXIgRElSRUNUSU9OX05PTkUgPSAxO1xuICB2YXIgRElSRUNUSU9OX0xFRlQgPSAyO1xuICB2YXIgRElSRUNUSU9OX1JJR0hUID0gNDtcbiAgdmFyIERJUkVDVElPTl9VUCA9IDg7XG4gIHZhciBESVJFQ1RJT05fRE9XTiA9IDE2O1xuICB2YXIgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fTEVGVCB8IERJUkVDVElPTl9SSUdIVDtcbiAgdmFyIERJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9VUCB8IERJUkVDVElPTl9ET1dOO1xuICB2YXIgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMO1xuICB2YXIgUFJPUFNfWFkgPSBbJ3gnLCAneSddO1xuICB2YXIgUFJPUFNfQ0xJRU5UX1hZID0gWydjbGllbnRYJywgJ2NsaWVudFknXTtcblxuICAvKipcbiAgICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtJbnB1dH1cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBJbnB1dChtYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRUYXJnZXQ7XG5cbiAgICAvLyBzbWFsbGVyIHdyYXBwZXIgYXJvdW5kIHRoZSBoYW5kbGVyLCBmb3IgdGhlIHNjb3BlIGFuZCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbWFuYWdlcixcbiAgICAvLyBzbyB3aGVuIGRpc2FibGVkIHRoZSBpbnB1dCBldmVudHMgYXJlIGNvbXBsZXRlbHkgYnlwYXNzZWQuXG4gICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xuICAgICAgICBzZWxmLmhhbmRsZXIoZXYpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cbiAgSW5wdXQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNob3VsZCBoYW5kbGUgdGhlIGlucHV0RXZlbnQgZGF0YSBhbmQgdHJpZ2dlciB0aGUgY2FsbGJhY2tcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uICgpIHt9LFxuICAgIC8qKlxuICAgICAqIGJpbmQgdGhlIGV2ZW50c1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZXZFbCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgIHRoaXMuZXZUYXJnZXQgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICB0aGlzLmV2V2luICYmIGFkZEV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHVuYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5ldkVsICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgdGhpcy5ldlRhcmdldCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgIHRoaXMuZXZXaW4gJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAgICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gICAqIEByZXR1cm5zIHtJbnB1dH1cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUlucHV0SW5zdGFuY2UobWFuYWdlcikge1xuICAgIHZhciBUeXBlO1xuICAgIHZhciBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG4gICAgaWYgKGlucHV0Q2xhc3MpIHtcbiAgICAgIFR5cGUgPSBpbnB1dENsYXNzO1xuICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9QT0lOVEVSX0VWRU5UUykge1xuICAgICAgVHlwZSA9IFBvaW50ZXJFdmVudElucHV0O1xuICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9PTkxZX1RPVUNIKSB7XG4gICAgICBUeXBlID0gVG91Y2hJbnB1dDtcbiAgICB9IGVsc2UgaWYgKCFTVVBQT1JUX1RPVUNIKSB7XG4gICAgICBUeXBlID0gTW91c2VJbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgVHlwZSA9IFRvdWNoTW91c2VJbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUeXBlKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogaGFuZGxlIGlucHV0IGV2ZW50c1xuICAgKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG4gIGZ1bmN0aW9uIGlucHV0SGFuZGxlcihtYW5hZ2VyLCBldmVudFR5cGUsIGlucHV0KSB7XG4gICAgdmFyIHBvaW50ZXJzTGVuID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoO1xuICAgIHZhciBjaGFuZ2VkUG9pbnRlcnNMZW4gPSBpbnB1dC5jaGFuZ2VkUG9pbnRlcnMubGVuZ3RoO1xuICAgIHZhciBpc0ZpcnN0ID0gZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgcG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDA7XG4gICAgdmFyIGlzRmluYWwgPSBldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiBwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMDtcbiAgICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xuICAgIGlucHV0LmlzRmluYWwgPSAhIWlzRmluYWw7XG4gICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xuICAgIH1cblxuICAgIC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gICAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG4gICAgaW5wdXQuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuXG4gICAgLy8gY29tcHV0ZSBzY2FsZSwgcm90YXRpb24gZXRjXG4gICAgY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCk7XG5cbiAgICAvLyBlbWl0IHNlY3JldCBldmVudFxuICAgIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuICAgIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcbiAgICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XG4gIH1cblxuICAvKipcbiAgICogZXh0ZW5kIHRoZSBkYXRhIHdpdGggc29tZSB1c2FibGUgcHJvcGVydGllcyBsaWtlIHNjYWxlLCByb3RhdGUsIHZlbG9jaXR5IGV0Y1xuICAgKiBAcGFyYW0ge09iamVjdH0gbWFuYWdlclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpIHtcbiAgICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcbiAgICB2YXIgcG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycztcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXG4gICAgaWYgKCFzZXNzaW9uLmZpcnN0SW5wdXQpIHtcbiAgICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9XG5cbiAgICAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID4gMSAmJiAhc2Vzc2lvbi5maXJzdE11bHRpcGxlKSB7XG4gICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gICAgfSBlbHNlIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBmaXJzdElucHV0ID0gc2Vzc2lvbi5maXJzdElucHV0O1xuICAgIHZhciBmaXJzdE11bHRpcGxlID0gc2Vzc2lvbi5maXJzdE11bHRpcGxlO1xuICAgIHZhciBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyID0gZ2V0Q2VudGVyKHBvaW50ZXJzKTtcbiAgICBpbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICBpbnB1dC5kZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBmaXJzdElucHV0LnRpbWVTdGFtcDtcbiAgICBpbnB1dC5hbmdsZSA9IGdldEFuZ2xlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XG4gICAgaW5wdXQub2Zmc2V0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcbiAgICB2YXIgb3ZlcmFsbFZlbG9jaXR5ID0gZ2V0VmVsb2NpdHkoaW5wdXQuZGVsdGFUaW1lLCBpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WCA9IG92ZXJhbGxWZWxvY2l0eS54O1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVkgPSBvdmVyYWxsVmVsb2NpdHkueTtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHkgPSBhYnMob3ZlcmFsbFZlbG9jaXR5LngpID4gYWJzKG92ZXJhbGxWZWxvY2l0eS55KSA/IG92ZXJhbGxWZWxvY2l0eS54IDogb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gICAgaW5wdXQuc2NhbGUgPSBmaXJzdE11bHRpcGxlID8gZ2V0U2NhbGUoZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMTtcbiAgICBpbnB1dC5yb3RhdGlvbiA9IGZpcnN0TXVsdGlwbGUgPyBnZXRSb3RhdGlvbihmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAwO1xuICAgIGlucHV0Lm1heFBvaW50ZXJzID0gIXNlc3Npb24ucHJldklucHV0ID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogaW5wdXQucG9pbnRlcnMubGVuZ3RoID4gc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycztcbiAgICBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpO1xuXG4gICAgLy8gZmluZCB0aGUgY29ycmVjdCB0YXJnZXRcbiAgICB2YXIgdGFyZ2V0ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIGlmIChoYXNQYXJlbnQoaW5wdXQuc3JjRXZlbnQudGFyZ2V0LCB0YXJnZXQpKSB7XG4gICAgICB0YXJnZXQgPSBpbnB1dC5zcmNFdmVudC50YXJnZXQ7XG4gICAgfVxuICAgIGlucHV0LnRhcmdldCA9IHRhcmdldDtcbiAgfVxuICBmdW5jdGlvbiBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCkge1xuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG4gICAgdmFyIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgfHwge307XG4gICAgdmFyIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhIHx8IHt9O1xuICAgIHZhciBwcmV2SW5wdXQgPSBzZXNzaW9uLnByZXZJbnB1dCB8fCB7fTtcbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9TVEFSVCB8fCBwcmV2SW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9FTkQpIHtcbiAgICAgIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhID0ge1xuICAgICAgICB4OiBwcmV2SW5wdXQuZGVsdGFYIHx8IDAsXG4gICAgICAgIHk6IHByZXZJbnB1dC5kZWx0YVkgfHwgMFxuICAgICAgfTtcbiAgICAgIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgPSB7XG4gICAgICAgIHg6IGNlbnRlci54LFxuICAgICAgICB5OiBjZW50ZXIueVxuICAgICAgfTtcbiAgICB9XG4gICAgaW5wdXQuZGVsdGFYID0gcHJldkRlbHRhLnggKyAoY2VudGVyLnggLSBvZmZzZXQueCk7XG4gICAgaW5wdXQuZGVsdGFZID0gcHJldkRlbHRhLnkgKyAoY2VudGVyLnkgLSBvZmZzZXQueSk7XG4gIH1cblxuICAvKipcbiAgICogdmVsb2NpdHkgaXMgY2FsY3VsYXRlZCBldmVyeSB4IG1zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKi9cbiAgZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGxhc3QgPSBzZXNzaW9uLmxhc3RJbnRlcnZhbCB8fCBpbnB1dCxcbiAgICAgIGRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGxhc3QudGltZVN0YW1wLFxuICAgICAgdmVsb2NpdHksXG4gICAgICB2ZWxvY2l0eVgsXG4gICAgICB2ZWxvY2l0eVksXG4gICAgICBkaXJlY3Rpb247XG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgdmFyIGRlbHRhWCA9IGlucHV0LmRlbHRhWCAtIGxhc3QuZGVsdGFYO1xuICAgICAgdmFyIGRlbHRhWSA9IGlucHV0LmRlbHRhWSAtIGxhc3QuZGVsdGFZO1xuICAgICAgdmFyIHYgPSBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICAgIHZlbG9jaXR5WSA9IHYueTtcbiAgICAgIHZlbG9jaXR5ID0gYWJzKHYueCkgPiBhYnModi55KSA/IHYueCA6IHYueTtcbiAgICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG4gICAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXG4gICAgICB2ZWxvY2l0eSA9IGxhc3QudmVsb2NpdHk7XG4gICAgICB2ZWxvY2l0eVggPSBsYXN0LnZlbG9jaXR5WDtcbiAgICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xuICAgICAgZGlyZWN0aW9uID0gbGFzdC5kaXJlY3Rpb247XG4gICAgfVxuICAgIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgaW5wdXQudmVsb2NpdHlYID0gdmVsb2NpdHlYO1xuICAgIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogY3JlYXRlIGEgc2ltcGxlIGNsb25lIGZyb20gdGhlIGlucHV0IHVzZWQgZm9yIHN0b3JhZ2Ugb2YgZmlyc3RJbnB1dCBhbmQgZmlyc3RNdWx0aXBsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICogQHJldHVybnMge09iamVjdH0gY2xvbmVkSW5wdXREYXRhXG4gICAqL1xuICBmdW5jdGlvbiBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCkge1xuICAgIC8vIG1ha2UgYSBzaW1wbGUgY29weSBvZiB0aGUgcG9pbnRlcnMgYmVjYXVzZSB3ZSB3aWxsIGdldCBhIHJlZmVyZW5jZSBpZiB3ZSBkb24ndFxuICAgIC8vIHdlIG9ubHkgbmVlZCBjbGllbnRYWSBmb3IgdGhlIGNhbGN1bGF0aW9uc1xuICAgIHZhciBwb2ludGVycyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCkge1xuICAgICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICAgIGNsaWVudFg6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFgpLFxuICAgICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgICAgfTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRpbWVTdGFtcDogbm93KCksXG4gICAgICBwb2ludGVyczogcG9pbnRlcnMsXG4gICAgICBjZW50ZXI6IGdldENlbnRlcihwb2ludGVycyksXG4gICAgICBkZWx0YVg6IGlucHV0LmRlbHRhWCxcbiAgICAgIGRlbHRhWTogaW5wdXQuZGVsdGFZXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50ZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGB4YCBhbmQgYHlgIHByb3BlcnRpZXNcbiAgICovXG4gIGZ1bmN0aW9uIGdldENlbnRlcihwb2ludGVycykge1xuICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcblxuICAgIC8vIG5vIG5lZWQgdG8gbG9vcCB3aGVuIG9ubHkgb25lIHRvdWNoXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRYKSxcbiAgICAgICAgeTogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WSlcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciB4ID0gMCxcbiAgICAgIHkgPSAwLFxuICAgICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBwb2ludGVyc0xlbmd0aCkge1xuICAgICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xuICAgICAgeSArPSBwb2ludGVyc1tpXS5jbGllbnRZO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeDogcm91bmQoeCAvIHBvaW50ZXJzTGVuZ3RoKSxcbiAgICAgIHk6IHJvdW5kKHkgLyBwb2ludGVyc0xlbmd0aClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gICAqL1xuICBmdW5jdGlvbiBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCAvIGRlbHRhVGltZSB8fCAwLFxuICAgICAgeTogeSAvIGRlbHRhVGltZSB8fCAwXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cbiAgICovXG4gIGZ1bmN0aW9uIGdldERpcmVjdGlvbih4LCB5KSB7XG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcbiAgICB9XG4gICAgaWYgKGFicyh4KSA+PSBhYnMoeSkpIHtcbiAgICAgIHJldHVybiB4IDwgMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgIH1cbiAgICByZXR1cm4geSA8IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIGFic29sdXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcDFcbiAgICogQHBhcmFtIHtPYmplY3R9IHAyXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAgICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QW5nbGUocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgfVxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxuICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdLCBQUk9QU19DTElFTlRfWFkpICsgZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdLCBQUk9QU19DTElFTlRfWFkpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gICAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAgICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSwgUFJPUFNfQ0xJRU5UX1hZKSAvIGdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbiAgfVxuICB2YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xuICAgIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gICAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIG1vdXNldXA6IElOUFVUX0VORFxuICB9O1xuICB2YXIgTU9VU0VfRUxFTUVOVF9FVkVOVFMgPSAnbW91c2Vkb3duJztcbiAgdmFyIE1PVVNFX1dJTkRPV19FVkVOVFMgPSAnbW91c2Vtb3ZlIG1vdXNldXAnO1xuXG4gIC8qKlxuICAgKiBNb3VzZSBldmVudHMgaW5wdXRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIElucHV0XG4gICAqL1xuICBmdW5jdGlvbiBNb3VzZUlucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IE1PVVNFX0VMRU1FTlRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBNT1VTRV9XSU5ET1dfRVZFTlRTO1xuICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlOyAvLyBtb3VzZWRvd24gc3RhdGVcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgaW5oZXJpdChNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNRWhhbmRsZXIoZXYpIHtcbiAgICAgIHZhciBldmVudFR5cGUgPSBNT1VTRV9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgIC8vIG9uIHN0YXJ0IHdlIHdhbnQgdG8gaGF2ZSB0aGUgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggIT09IDEpIHtcbiAgICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xuICAgICAgfVxuXG4gICAgICAvLyBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICAgIGlmICghdGhpcy5wcmVzc2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgIHBvaW50ZXJzOiBbZXZdLFxuICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX01PVVNFLFxuICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHZhciBQT0lOVEVSX0lOUFVUX01BUCA9IHtcbiAgICBwb2ludGVyZG93bjogSU5QVVRfU1RBUlQsXG4gICAgcG9pbnRlcm1vdmU6IElOUFVUX01PVkUsXG4gICAgcG9pbnRlcnVwOiBJTlBVVF9FTkQsXG4gICAgcG9pbnRlcmNhbmNlbDogSU5QVVRfQ0FOQ0VMLFxuICAgIHBvaW50ZXJvdXQ6IElOUFVUX0NBTkNFTFxuICB9O1xuXG4gIC8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXG4gIHZhciBJRTEwX1BPSU5URVJfVFlQRV9FTlVNID0ge1xuICAgIDI6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgMzogSU5QVVRfVFlQRV9QRU4sXG4gICAgNDogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICA1OiBJTlBVVF9UWVBFX0tJTkVDVCAvLyBzZWUgaHR0cHM6Ly90d2l0dGVyLmNvbS9qYWNvYnJvc3NpL3N0YXR1cy80ODA1OTY0Mzg0ODk4OTA4MTZcbiAgfTtcbiAgdmFyIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAncG9pbnRlcmRvd24nO1xuICB2YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJztcblxuICAvLyBJRTEwIGhhcyBwcmVmaXhlZCBzdXBwb3J0LCBhbmQgY2FzZS1zZW5zaXRpdmVcbiAgaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCAmJiAhd2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAnTVNQb2ludGVyRG93bic7XG4gICAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2ludGVyIGV2ZW50cyBpbnB1dFxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgSW5wdXRcbiAgICovXG4gIGZ1bmN0aW9uIFBvaW50ZXJFdmVudElucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IFBPSU5URVJfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuc3RvcmUgPSB0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wb2ludGVyRXZlbnRzID0gW107XG4gIH1cbiAgaW5oZXJpdChQb2ludGVyRXZlbnRJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gUEVoYW5kbGVyKGV2KSB7XG4gICAgICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmYWxzZTtcbiAgICAgIHZhciBldmVudFR5cGVOb3JtYWxpemVkID0gZXYudHlwZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ21zJywgJycpO1xuICAgICAgdmFyIGV2ZW50VHlwZSA9IFBPSU5URVJfSU5QVVRfTUFQW2V2ZW50VHlwZU5vcm1hbGl6ZWRdO1xuICAgICAgdmFyIHBvaW50ZXJUeXBlID0gSUUxMF9QT0lOVEVSX1RZUEVfRU5VTVtldi5wb2ludGVyVHlwZV0gfHwgZXYucG9pbnRlclR5cGU7XG4gICAgICB2YXIgaXNUb3VjaCA9IHBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0g7XG5cbiAgICAgIC8vIGdldCBpbmRleCBvZiB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICB2YXIgc3RvcmVJbmRleCA9IGluQXJyYXkoc3RvcmUsIGV2LnBvaW50ZXJJZCwgJ3BvaW50ZXJJZCcpO1xuXG4gICAgICAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXG4gICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKGV2LmJ1dHRvbiA9PT0gMCB8fCBpc1RvdWNoKSkge1xuICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgICBzdG9yZS5wdXNoKGV2KTtcbiAgICAgICAgICBzdG9yZUluZGV4ID0gc3RvcmUubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICByZW1vdmVQb2ludGVyID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaXQgbm90IGZvdW5kLCBzbyB0aGUgcG9pbnRlciBoYXNuJ3QgYmVlbiBkb3duIChzbyBpdCdzIHByb2JhYmx5IGEgaG92ZXIpXG4gICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB1cGRhdGUgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgICAgc3RvcmVbc3RvcmVJbmRleF0gPSBldjtcbiAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgcG9pbnRlcnM6IHN0b3JlLFxuICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICB9KTtcbiAgICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XG4gICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxuICAgICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxuICB9O1xuICB2YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XG4gIHZhciBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbiAgLyoqXG4gICAqIFRvdWNoIGV2ZW50cyBpbnB1dFxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgSW5wdXRcbiAgICovXG4gIGZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIGluaGVyaXQoU2luZ2xlVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBURWhhbmRsZXIoZXYpIHtcbiAgICAgIHZhciB0eXBlID0gU0lOR0xFX1RPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgICAgLy8gc2hvdWxkIHdlIGhhbmRsZSB0aGUgdG91Y2ggZXZlbnRzP1xuICAgICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdG91Y2hlcyA9IG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG5cbiAgICAgIC8vIHdoZW4gZG9uZSwgcmVzZXQgdGhlIHN0YXJ0ZWQgc3RhdGVcbiAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgdG91Y2hlc1swXS5sZW5ndGggLSB0b3VjaGVzWzFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtUb3VjaElucHV0fVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICAgKi9cbiAgZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGwgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgYWxsID0gdW5pcXVlQXJyYXkoYWxsLmNvbmNhdChjaGFuZ2VkKSwgJ2lkZW50aWZpZXInLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIFthbGwsIGNoYW5nZWRdO1xuICB9XG4gIHZhciBUT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxuICB9O1xuICB2YXIgVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbiAgLyoqXG4gICAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBJbnB1dFxuICAgKi9cbiAgZnVuY3Rpb24gVG91Y2hJbnB1dCgpIHtcbiAgICB0aGlzLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICB0aGlzLnRhcmdldElkcyA9IHt9O1xuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgaW5oZXJpdChUb3VjaElucHV0LCBJbnB1dCwge1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1URWhhbmRsZXIoZXYpIHtcbiAgICAgIHZhciB0eXBlID0gVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuICAgICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtUb3VjaElucHV0fVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGxUb3VjaGVzID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICB2YXIgdGFyZ2V0SWRzID0gdGhpcy50YXJnZXRJZHM7XG5cbiAgICAvLyB3aGVuIHRoZXJlIGlzIG9ubHkgb25lIHRvdWNoLCB0aGUgcHJvY2VzcyBjYW4gYmUgc2ltcGxpZmllZFxuICAgIGlmICh0eXBlICYgKElOUFVUX1NUQVJUIHwgSU5QVVRfTU9WRSkgJiYgYWxsVG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRhcmdldElkc1thbGxUb3VjaGVzWzBdLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBbYWxsVG91Y2hlcywgYWxsVG91Y2hlc107XG4gICAgfVxuICAgIHZhciBpLFxuICAgICAgdGFyZ2V0VG91Y2hlcyxcbiAgICAgIGNoYW5nZWRUb3VjaGVzID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyksXG4gICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyA9IFtdLFxuICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG5cbiAgICAvLyBnZXQgdGFyZ2V0IHRvdWNoZXMgZnJvbSB0b3VjaGVzXG4gICAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XG4gICAgfSk7XG5cbiAgICAvLyBjb2xsZWN0IHRvdWNoZXNcbiAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgY2hhbmdlZCB0b3VjaGVzIHRvIG9ubHkgY29udGFpbiB0b3VjaGVzIHRoYXQgZXhpc3QgaW4gdGhlIGNvbGxlY3RlZCB0YXJnZXQgaWRzXG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgIGlmICh0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMucHVzaChjaGFuZ2VkVG91Y2hlc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNsZWFudXAgcmVtb3ZlZCB0b3VjaGVzXG4gICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIGlmICghY2hhbmdlZFRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXG4gICAgdW5pcXVlQXJyYXkodGFyZ2V0VG91Y2hlcy5jb25jYXQoY2hhbmdlZFRhcmdldFRvdWNoZXMpLCAnaWRlbnRpZmllcicsIHRydWUpLCBjaGFuZ2VkVGFyZ2V0VG91Y2hlc107XG4gIH1cblxuICAvKipcbiAgICogQ29tYmluZWQgdG91Y2ggYW5kIG1vdXNlIGlucHV0XG4gICAqXG4gICAqIFRvdWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGVuIG1vdXNlLCBhbmQgd2hpbGUgdG91Y2hpbmcgbm8gbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkLlxuICAgKiBUaGlzIGJlY2F1c2UgdG91Y2ggZGV2aWNlcyBhbHNvIGVtaXQgbW91c2UgZXZlbnRzIHdoaWxlIGRvaW5nIGEgdG91Y2guXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBJbnB1dFxuICAgKi9cblxuICB2YXIgREVEVVBfVElNRU9VVCA9IDI1MDA7XG4gIHZhciBERURVUF9ESVNUQU5DRSA9IDI1O1xuICBmdW5jdGlvbiBUb3VjaE1vdXNlSW5wdXQoKSB7XG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgaGFuZGxlciA9IGJpbmRGbih0aGlzLmhhbmRsZXIsIHRoaXMpO1xuICAgIHRoaXMudG91Y2ggPSBuZXcgVG91Y2hJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuICAgIHRoaXMubW91c2UgPSBuZXcgTW91c2VJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuICAgIHRoaXMucHJpbWFyeVRvdWNoID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb3VjaGVzID0gW107XG4gIH1cbiAgaW5oZXJpdChUb3VjaE1vdXNlSW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGFuZCB0b3VjaCBldmVudHNcbiAgICAgKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dEV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRNRWhhbmRsZXIobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKSB7XG4gICAgICB2YXIgaXNUb3VjaCA9IGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICBpc01vdXNlID0gaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfTU9VU0U7XG4gICAgICBpZiAoaXNNb3VzZSAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHdoZW4gd2UncmUgaW4gYSB0b3VjaCBldmVudCwgcmVjb3JkIHRvdWNoZXMgdG8gIGRlLWR1cGUgc3ludGhldGljIG1vdXNlIGV2ZW50XG4gICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICByZWNvcmRUb3VjaGVzLmNhbGwodGhpcywgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZSAmJiBpc1N5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgaW5wdXREYXRhKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxiYWNrKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubW91c2UuZGVzdHJveSgpO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIHJlY29yZFRvdWNoZXMoZXZlbnRUeXBlLCBldmVudERhdGEpIHtcbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgIHRoaXMucHJpbWFyeVRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXS5pZGVudGlmaWVyO1xuICAgICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRMYXN0VG91Y2goZXZlbnREYXRhKSB7XG4gICAgdmFyIHRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXTtcbiAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5wcmltYXJ5VG91Y2gpIHtcbiAgICAgIHZhciBsYXN0VG91Y2ggPSB7XG4gICAgICAgIHg6IHRvdWNoLmNsaWVudFgsXG4gICAgICAgIHk6IHRvdWNoLmNsaWVudFlcbiAgICAgIH07XG4gICAgICB0aGlzLmxhc3RUb3VjaGVzLnB1c2gobGFzdFRvdWNoKTtcbiAgICAgIHZhciBsdHMgPSB0aGlzLmxhc3RUb3VjaGVzO1xuICAgICAgdmFyIHJlbW92ZUxhc3RUb3VjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGkgPSBsdHMuaW5kZXhPZihsYXN0VG91Y2gpO1xuICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgbHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNldFRpbWVvdXQocmVtb3ZlTGFzdFRvdWNoLCBERURVUF9USU1FT1VUKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNTeW50aGV0aWNFdmVudChldmVudERhdGEpIHtcbiAgICB2YXIgeCA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRYLFxuICAgICAgeSA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRZO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sYXN0VG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHQgPSB0aGlzLmxhc3RUb3VjaGVzW2ldO1xuICAgICAgdmFyIGR4ID0gTWF0aC5hYnMoeCAtIHQueCksXG4gICAgICAgIGR5ID0gTWF0aC5hYnMoeSAtIHQueSk7XG4gICAgICBpZiAoZHggPD0gREVEVVBfRElTVEFOQ0UgJiYgZHkgPD0gREVEVVBfRElTVEFOQ0UpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcbiAgdmFyIE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDtcblxuICAvLyBtYWdpY2FsIHRvdWNoQWN0aW9uIHZhbHVlXG4gIHZhciBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcbiAgdmFyIFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xuICB2YXIgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiA9ICdtYW5pcHVsYXRpb24nOyAvLyBub3QgaW1wbGVtZW50ZWRcbiAgdmFyIFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xuICB2YXIgVE9VQ0hfQUNUSU9OX1BBTl9YID0gJ3Bhbi14JztcbiAgdmFyIFRPVUNIX0FDVElPTl9QQU5fWSA9ICdwYW4teSc7XG4gIHZhciBUT1VDSF9BQ1RJT05fTUFQID0gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpO1xuXG4gIC8qKlxuICAgKiBUb3VjaCBBY3Rpb25cbiAgICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFRvdWNoQWN0aW9uKG1hbmFnZXIsIHZhbHVlKSB7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLnNldCh2YWx1ZSk7XG4gIH1cbiAgVG91Y2hBY3Rpb24ucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWUgb24gdGhlIGVsZW1lbnQgb3IgZW5hYmxlIHRoZSBwb2x5ZmlsbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAvLyBmaW5kIG91dCB0aGUgdG91Y2gtYWN0aW9uIGJ5IHRoZSBldmVudCBoYW5kbGVyc1xuICAgICAgaWYgKHZhbHVlID09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5jb21wdXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoTkFUSVZFX1RPVUNIX0FDVElPTiAmJiB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZSAmJiBUT1VDSF9BQ1RJT05fTUFQW3ZhbHVlXSkge1xuICAgICAgICB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZVtQUkVGSVhFRF9UT1VDSF9BQ1RJT05dID0gdmFsdWU7XG4gICAgICB9XG4gICAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGp1c3QgcmUtc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZVxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcmVjb2duaXplcidzIHNldHRpbmdzXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBjb21wdXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgZWFjaCh0aGlzLm1hbmFnZXIucmVjb2duaXplcnMsIGZ1bmN0aW9uIChyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChib29sT3JGbihyZWNvZ25pemVyLm9wdGlvbnMuZW5hYmxlLCBbcmVjb2duaXplcl0pKSB7XG4gICAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMuam9pbignICcpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0czogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICB2YXIgc3JjRXZlbnQgPSBpbnB1dC5zcmNFdmVudDtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247XG5cbiAgICAgIC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxuICAgICAgaWYgKHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCkge1xuICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgIHZhciBoYXNOb25lID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1ldO1xuICAgICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWF07XG4gICAgICBpZiAoaGFzTm9uZSkge1xuICAgICAgICAvL2RvIG5vdCBwcmV2ZW50IGRlZmF1bHRzIGlmIHRoaXMgaXMgYSB0YXAgZ2VzdHVyZVxuXG4gICAgICAgIHZhciBpc1RhcFBvaW50ZXIgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IDE7XG4gICAgICAgIHZhciBpc1RhcE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCAyO1xuICAgICAgICB2YXIgaXNUYXBUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCAyNTA7XG4gICAgICAgIGlmIChpc1RhcFBvaW50ZXIgJiYgaXNUYXBNb3ZlbWVudCAmJiBpc1RhcFRvdWNoVGltZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgICAvLyBgcGFuLXggcGFuLXlgIG1lYW5zIGJyb3dzZXIgaGFuZGxlcyBhbGwgc2Nyb2xsaW5nL3Bhbm5pbmcsIGRvIG5vdCBwcmV2ZW50XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNOb25lIHx8IGhhc1BhblkgJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwgfHwgaGFzUGFuWCAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yIChzY3JvbGxpbmcgaW4gbW9zdCBjYXNlcylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjRXZlbnRcbiAgICAgKi9cbiAgICBwcmV2ZW50U3JjOiBmdW5jdGlvbiAoc3JjRXZlbnQpIHtcbiAgICAgIHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCA9IHRydWU7XG4gICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogd2hlbiB0aGUgdG91Y2hBY3Rpb25zIGFyZSBjb2xsZWN0ZWQgdGhleSBhcmUgbm90IGEgdmFsaWQgdmFsdWUsIHNvIHdlIG5lZWQgdG8gY2xlYW4gdGhpbmdzIHVwLiAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZnVuY3Rpb24gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucykge1xuICAgIC8vIG5vbmVcbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpKSB7XG4gICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgfVxuICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XG5cbiAgICAvLyBpZiBib3RoIHBhbi14IGFuZCBwYW4teSBhcmUgc2V0IChkaWZmZXJlbnQgcmVjb2duaXplcnNcbiAgICAvLyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMsIGUuZy4gaG9yaXpvbnRhbCBwYW4gYnV0IHZlcnRpY2FsIHN3aXBlPylcbiAgICAvLyB3ZSBuZWVkIG5vbmUgKGFzIG90aGVyd2lzZSB3aXRoIHBhbi14IHBhbi15IGNvbWJpbmVkIG5vbmUgb2YgdGhlc2VcbiAgICAvLyByZWNvZ25pemVycyB3aWxsIHdvcmssIHNpbmNlIHRoZSBicm93c2VyIHdvdWxkIGhhbmRsZSBhbGwgcGFubmluZ1xuICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICAvLyBwYW4teCBPUiBwYW4teVxuICAgIGlmIChoYXNQYW5YIHx8IGhhc1BhblkpIHtcbiAgICAgIHJldHVybiBoYXNQYW5YID8gVE9VQ0hfQUNUSU9OX1BBTl9YIDogVE9VQ0hfQUNUSU9OX1BBTl9ZO1xuICAgIH1cblxuICAgIC8vIG1hbmlwdWxhdGlvblxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OKSkge1xuICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT047XG4gICAgfVxuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fQVVUTztcbiAgfVxuICBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvblByb3BzKCkge1xuICAgIGlmICghTkFUSVZFX1RPVUNIX0FDVElPTikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdG91Y2hNYXAgPSB7fTtcbiAgICB2YXIgY3NzU3VwcG9ydHMgPSB3aW5kb3cuQ1NTICYmIHdpbmRvdy5DU1Muc3VwcG9ydHM7XG4gICAgWydhdXRvJywgJ21hbmlwdWxhdGlvbicsICdwYW4teScsICdwYW4teCcsICdwYW4teCBwYW4teScsICdub25lJ10uZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAvLyBJZiBjc3Muc3VwcG9ydHMgaXMgbm90IHN1cHBvcnRlZCBidXQgdGhlcmUgaXMgbmF0aXZlIHRvdWNoLWFjdGlvbiBhc3N1bWUgaXQgc3VwcG9ydHNcbiAgICAgIC8vIGFsbCB2YWx1ZXMuIFRoaXMgaXMgdGhlIGNhc2UgZm9yIElFIDEwIGFuZCAxMS5cbiAgICAgIHRvdWNoTWFwW3ZhbF0gPSBjc3NTdXBwb3J0cyA/IHdpbmRvdy5DU1Muc3VwcG9ydHMoJ3RvdWNoLWFjdGlvbicsIHZhbCkgOiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiB0b3VjaE1hcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvZ25pemVyIGZsb3cgZXhwbGFpbmVkOyAqXG4gICAqIEFsbCByZWNvZ25pemVycyBoYXZlIHRoZSBpbml0aWFsIHN0YXRlIG9mIFBPU1NJQkxFIHdoZW4gYSBpbnB1dCBzZXNzaW9uIHN0YXJ0cy5cbiAgICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXG4gICAqIEV4YW1wbGUgc2Vzc2lvbiBmb3IgbW91c2UtaW5wdXQ6IG1vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cFxuICAgKlxuICAgKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXG4gICAqIHdoaWNoIGRldGVybWluZXMgd2l0aCBzdGF0ZSBpdCBzaG91bGQgYmUuXG4gICAqXG4gICAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cbiAgICogUE9TU0lCTEUgdG8gZ2l2ZSBpdCBhbm90aGVyIGNoYW5nZSBvbiB0aGUgbmV4dCBjeWNsZS5cbiAgICpcbiAgICogICAgICAgICAgICAgICBQb3NzaWJsZVxuICAgKiAgICAgICAgICAgICAgICAgIHxcbiAgICogICAgICAgICAgICArLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICAgKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XG4gICAqICAgICAgKy0tLS0tKy0tLS0tKyAgICAgICAgICAgICAgIHxcbiAgICogICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgfFxuICAgKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLSstLS0tLS0rXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG4gICAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENoYW5nZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kZWQvUmVjb2duaXplZFxuICAgKi9cbiAgdmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcbiAgdmFyIFNUQVRFX0JFR0FOID0gMjtcbiAgdmFyIFNUQVRFX0NIQU5HRUQgPSA0O1xuICB2YXIgU1RBVEVfRU5ERUQgPSA4O1xuICB2YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xuICB2YXIgU1RBVEVfQ0FOQ0VMTEVEID0gMTY7XG4gIHZhciBTVEFURV9GQUlMRUQgPSAzMjtcblxuICAvKipcbiAgICogUmVjb2duaXplclxuICAgKiBFdmVyeSByZWNvZ25pemVyIG5lZWRzIHRvIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcbiAgICB0aGlzLmlkID0gdW5pcXVlSWQoKTtcbiAgICB0aGlzLm1hbmFnZXIgPSBudWxsO1xuXG4gICAgLy8gZGVmYXVsdCBpcyBlbmFibGUgdHJ1ZVxuICAgIHRoaXMub3B0aW9ucy5lbmFibGUgPSBpZlVuZGVmaW5lZCh0aGlzLm9wdGlvbnMuZW5hYmxlLCB0cnVlKTtcbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgdGhpcy5zaW11bHRhbmVvdXMgPSB7fTtcbiAgICB0aGlzLnJlcXVpcmVGYWlsID0gW107XG4gIH1cbiAgUmVjb2duaXplci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7fSxcbiAgICAvKipcbiAgICAgKiBzZXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UmVjb2duaXplcn1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgLy8gYWxzbyB1cGRhdGUgdGhlIHRvdWNoQWN0aW9uLCBpbiBjYXNlIHNvbWV0aGluZyBjaGFuZ2VkIGFib3V0IHRoZSBkaXJlY3Rpb25zL2VuYWJsZWQgc3RhdGVcbiAgICAgIHRoaXMubWFuYWdlciAmJiB0aGlzLm1hbmFnZXIudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICByZWNvZ25pemVXaXRoOiBmdW5jdGlvbiAob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIHNpbXVsdGFuZW91cyA9IHRoaXMuc2ltdWx0YW5lb3VzO1xuICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgaWYgKCFzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSkge1xuICAgICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlY29nbml6ZVdpdGgodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGRyb3AgdGhlIHNpbXVsdGFuZW91cyBsaW5rLiBpdCBkb2VzbnQgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVjb2duaXplV2l0aDogZnVuY3Rpb24gKG90aGVyUmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICBkZWxldGUgdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbiAob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciByZXF1aXJlRmFpbCA9IHRoaXMucmVxdWlyZUZhaWw7XG4gICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcbiAgICAgICAgcmVxdWlyZUZhaWwucHVzaChvdGhlclJlY29nbml6ZXIpO1xuICAgICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGRyb3AgdGhlIHJlcXVpcmVGYWlsdXJlIGxpbmsuIGl0IGRvZXMgbm90IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgZHJvcFJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbiAob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGhhcyByZXF1aXJlIGZhaWx1cmVzIGJvb2xlYW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSZXF1aXJlRmFpbHVyZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCA+IDA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNhblJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uIChvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcbiAgICAgKiB0aGF0IGFsbCB0aGUgbmVlZGVkIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQgYmVmb3JlIGVtaXR0aW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcbiAgICAgICAgc2VsZi5tYW5hZ2VyLmVtaXQoZXZlbnQsIGlucHV0KTtcbiAgICAgIH1cblxuICAgICAgLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXG4gICAgICBpZiAoc3RhdGUgPCBTVEFURV9FTkRFRCkge1xuICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICB9XG4gICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCk7IC8vIHNpbXBsZSAnZXZlbnROYW1lJyBldmVudHNcblxuICAgICAgaWYgKGlucHV0LmFkZGl0aW9uYWxFdmVudCkge1xuICAgICAgICAvLyBhZGRpdGlvbmFsIGV2ZW50KHBhbmxlZnQsIHBhbnJpZ2h0LCBwaW5jaGluLCBwaW5jaG91dC4uLilcbiAgICAgICAgZW1pdChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBwYW5lbmQgYW5kIHBhbmNhbmNlbFxuICAgICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XG4gICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgYWxsIHRoZSByZXF1aXJlIGZhaWx1cmUgcmVjb2duaXplcnMgaGFzIGZhaWxlZCxcbiAgICAgKiBpZiB0cnVlLCBpdCBlbWl0cyBhIGdlc3R1cmUgZXZlbnQsXG4gICAgICogb3RoZXJ3aXNlLCBzZXR1cCB0aGUgc3RhdGUgdG8gRkFJTEVELlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHRyeUVtaXQ6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgaWYgKHRoaXMuY2FuRW1pdCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgLy8gaXQncyBmYWlsaW5nIGFueXdheVxuICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGNhbiB3ZSBlbWl0P1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNhbkVtaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCEodGhpcy5yZXF1aXJlRmFpbFtpXS5zdGF0ZSAmIChTVEFURV9GQUlMRUQgfCBTVEFURV9QT1NTSUJMRSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24gKGlucHV0RGF0YSkge1xuICAgICAgLy8gbWFrZSBhIG5ldyBjb3B5IG9mIHRoZSBpbnB1dERhdGFcbiAgICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXG4gICAgICB2YXIgaW5wdXREYXRhQ2xvbmUgPSBhc3NpZ24oe30sIGlucHV0RGF0YSk7XG5cbiAgICAgIC8vIGlzIGlzIGVuYWJsZWQgYW5kIGFsbG93IHJlY29nbml6aW5nP1xuICAgICAgaWYgKCFib29sT3JGbih0aGlzLm9wdGlvbnMuZW5hYmxlLCBbdGhpcywgaW5wdXREYXRhQ2xvbmVdKSkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gcmVzZXQgd2hlbiB3ZSd2ZSByZWFjaGVkIHRoZSBlbmRcbiAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX1JFQ09HTklaRUQgfCBTVEFURV9DQU5DRUxMRUQgfCBTVEFURV9GQUlMRUQpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnByb2Nlc3MoaW5wdXREYXRhQ2xvbmUpO1xuXG4gICAgICAvLyB0aGUgcmVjb2duaXplciBoYXMgcmVjb2duaXplZCBhIGdlc3R1cmVcbiAgICAgIC8vIHNvIHRyaWdnZXIgYW4gZXZlbnRcbiAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEIHwgU1RBVEVfQ0FOQ0VMTEVEKSkge1xuICAgICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxuICAgICAqIHRoZSBhY3R1YWwgcmVjb2duaXppbmcgaGFwcGVucyBpbiB0aGlzIG1ldGhvZFxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqIEByZXR1cm5zIHtDb25zdH0gU1RBVEVcbiAgICAgKi9cbiAgICBwcm9jZXNzOiBmdW5jdGlvbiAoaW5wdXREYXRhKSB7fSxcbiAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgcHJlZmVycmVkIHRvdWNoLWFjdGlvblxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAvKipcbiAgICAgKiBjYWxsZWQgd2hlbiB0aGUgZ2VzdHVyZSBpc24ndCBhbGxvd2VkIHRvIHJlY29nbml6ZVxuICAgICAqIGxpa2Ugd2hlbiBhbm90aGVyIGlzIGJlaW5nIHJlY29nbml6ZWQgb3IgaXQgaXMgZGlzYWJsZWRcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7fVxuICB9O1xuXG4gIC8qKlxuICAgKiBnZXQgYSB1c2FibGUgc3RyaW5nLCB1c2VkIGFzIGV2ZW50IHBvc3RmaXhcbiAgICogQHBhcmFtIHtDb25zdH0gc3RhdGVcbiAgICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHN0YXRlU3RyKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlICYgU1RBVEVfQ0FOQ0VMTEVEKSB7XG4gICAgICByZXR1cm4gJ2NhbmNlbCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgICByZXR1cm4gJ2VuZCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0NIQU5HRUQpIHtcbiAgICAgIHJldHVybiAnbW92ZSc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0JFR0FOKSB7XG4gICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xuICAgKiBAcGFyYW0ge0NvbnN0fSBkaXJlY3Rpb25cbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIGRpcmVjdGlvblN0cihkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9ET1dOKSB7XG4gICAgICByZXR1cm4gJ2Rvd24nO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9VUCkge1xuICAgICAgcmV0dXJuICd1cCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0xFRlQpIHtcbiAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1JJR0hUKSB7XG4gICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gb3RoZXJSZWNvZ25pemVyXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XG4gICAgdmFyIG1hbmFnZXIgPSByZWNvZ25pemVyLm1hbmFnZXI7XG4gICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgIHJldHVybiBtYW5hZ2VyLmdldChvdGhlclJlY29nbml6ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb3RoZXJSZWNvZ25pemVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgcmVjb2duaXplciBpcyBqdXN0IHVzZWQgYXMgYSBiYXNlIGZvciB0aGUgc2ltcGxlIGF0dHJpYnV0ZSByZWNvZ25pemVycy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAgICovXG4gIGZ1bmN0aW9uIEF0dHJSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBpbmhlcml0KEF0dHJSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgKi9cbiAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICAgKi9cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICB2YXIgb3B0aW9uUG9pbnRlcnMgPSB0aGlzLm9wdGlvbnMucG9pbnRlcnM7XG4gICAgICByZXR1cm4gb3B0aW9uUG9pbnRlcnMgPT09IDAgfHwgaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25Qb2ludGVycztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIGlucHV0IGFuZCByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgcmVjb2duaXplclxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHsqfSBTdGF0ZVxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIHZhciBldmVudFR5cGUgPSBpbnB1dC5ldmVudFR5cGU7XG4gICAgICB2YXIgaXNSZWNvZ25pemVkID0gc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEKTtcbiAgICAgIHZhciBpc1ZhbGlkID0gdGhpcy5hdHRyVGVzdChpbnB1dCk7XG5cbiAgICAgIC8vIG9uIGNhbmNlbCBpbnB1dCBhbmQgd2UndmUgcmVjb2duaXplZCBiZWZvcmUsIHJldHVybiBTVEFURV9DQU5DRUxMRURcbiAgICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0FOQ0VMTEVEO1xuICAgICAgfSBlbHNlIGlmIChpc1JlY29nbml6ZWQgfHwgaXNWYWxpZCkge1xuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfRU5ERUQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIShzdGF0ZSAmIFNUQVRFX0JFR0FOKSkge1xuICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DSEFOR0VEO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQYW5cbiAgICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gICAqL1xuICBmdW5jdGlvbiBQYW5SZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5wWCA9IG51bGw7XG4gICAgdGhpcy5wWSA9IG51bGw7XG4gIH1cbiAgaW5oZXJpdChQYW5SZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGFuUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICBldmVudDogJ3BhbicsXG4gICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcbiAgICB9LFxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgICB9XG4gICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfSxcbiAgICBkaXJlY3Rpb25UZXN0OiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIGhhc01vdmVkID0gdHJ1ZTtcbiAgICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcbiAgICAgIHZhciB4ID0gaW5wdXQuZGVsdGFYO1xuICAgICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgIC8vIGxvY2sgdG8gYXhpcz9cbiAgICAgIGlmICghKGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uKSkge1xuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgIGRpcmVjdGlvbiA9IHggPT09IDAgPyBESVJFQ1RJT05fTk9ORSA6IHggPCAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgaGFzTW92ZWQgPSB4ICE9IHRoaXMucFg7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpcmVjdGlvbiA9IHkgPT09IDAgPyBESVJFQ1RJT05fTk9ORSA6IHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgaGFzTW92ZWQgPSB5ICE9IHRoaXMucFk7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcbiAgICB9LFxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBBdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTiB8fCAhKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSk7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIHRoaXMucFggPSBpbnB1dC5kZWx0YVg7XG4gICAgICB0aGlzLnBZID0gaW5wdXQuZGVsdGFZO1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xuICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb247XG4gICAgICB9XG4gICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFBpbmNoXG4gICAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVycyBhcmUgbW92aW5nIHRvd2FyZCAoem9vbS1pbikgb3IgYXdheSBmcm9tIGVhY2ggb3RoZXIgKHpvb20tb3V0KS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gICAqL1xuICBmdW5jdGlvbiBQaW5jaFJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBpbmhlcml0KFBpbmNoUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICBldmVudDogJ3BpbmNoJyxcbiAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSxcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfSxcbiAgICBhdHRyVGVzdDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dC5zY2FsZSAhPT0gMSkge1xuICAgICAgICB2YXIgaW5PdXQgPSBpbnB1dC5zY2FsZSA8IDEgPyAnaW4nIDogJ291dCc7XG4gICAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGluT3V0O1xuICAgICAgfVxuICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQcmVzc1xuICAgKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBmb3IgeCBtcyB3aXRob3V0IGFueSBtb3ZlbWVudC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAgICovXG4gIGZ1bmN0aW9uIFByZXNzUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgfVxuICBpbmhlcml0KFByZXNzUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUHJlc3NSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIGV2ZW50OiAncHJlc3MnLFxuICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICB0aW1lOiAyNTEsXG4gICAgICAvLyBtaW5pbWFsIHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgcHJlc3NlZFxuICAgICAgdGhyZXNob2xkOiA5IC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgfSxcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gICAgfSxcbiAgICBwcm9jZXNzOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICB2YXIgdmFsaWRUaW1lID0gaW5wdXQuZGVsdGFUaW1lID4gb3B0aW9ucy50aW1lO1xuICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICAgIGlmICghdmFsaWRNb3ZlbWVudCB8fCAhdmFsaWRQb2ludGVycyB8fCBpbnB1dC5ldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAhdmFsaWRUaW1lKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgICAgfSwgb3B0aW9ucy50aW1lLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaW5wdXQgJiYgaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArICd1cCcsIGlucHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSb3RhdGVcbiAgICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXIgYXJlIG1vdmluZyBpbiBhIGNpcmN1bGFyIG1vdGlvbi5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gICAqL1xuICBmdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgaW5oZXJpdChSb3RhdGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUm90YXRlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICBwb2ludGVyczogMlxuICAgIH0sXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgIH0sXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmIChNYXRoLmFicyhpbnB1dC5yb3RhdGlvbikgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogU3dpcGVcbiAgICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gICAqL1xuICBmdW5jdGlvbiBTd2lwZVJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBpbmhlcml0KFN3aXBlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFN3aXBlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICBldmVudDogJ3N3aXBlJyxcbiAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICB2ZWxvY2l0eTogMC4zLFxuICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XG4gICAgfSxcbiAgICBhdHRyVGVzdDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgIHZhciB2ZWxvY2l0eTtcbiAgICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5O1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVg7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgZGlyZWN0aW9uICYgaW5wdXQub2Zmc2V0RGlyZWN0aW9uICYmIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJiBpbnB1dC5tYXhQb2ludGVycyA9PSB0aGlzLm9wdGlvbnMucG9pbnRlcnMgJiYgYWJzKHZlbG9jaXR5KSA+IHRoaXMub3B0aW9ucy52ZWxvY2l0eSAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQ7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQub2Zmc2V0RGlyZWN0aW9uKTtcbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIGlucHV0KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBIHRhcCBpcyBlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb2luZyBhIHNtYWxsIHRhcC9jbGljay4gTXVsdGlwbGUgdGFwcyBhcmUgcmVjb2duaXplZCBpZiB0aGV5IG9jY3VyXG4gICAqIGJldHdlZW4gdGhlIGdpdmVuIGludGVydmFsIGFuZCBwb3NpdGlvbi4gVGhlIGRlbGF5IG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZWNvZ25pemUgbXVsdGktdGFwcyB3aXRob3V0IGZpcmluZ1xuICAgKiBhIHNpbmdsZSB0YXAuXG4gICAqXG4gICAqIFRoZSBldmVudERhdGEgZnJvbSB0aGUgZW1pdHRlZCBldmVudCBjb250YWlucyB0aGUgcHJvcGVydHkgYHRhcENvdW50YCwgd2hpY2ggY29udGFpbnMgdGhlIGFtb3VudCBvZlxuICAgKiBtdWx0aS10YXBzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gICAqL1xuICBmdW5jdGlvbiBUYXBSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIHByZXZpb3VzIHRpbWUgYW5kIGNlbnRlcixcbiAgICAvLyB1c2VkIGZvciB0YXAgY291bnRpbmdcbiAgICB0aGlzLnBUaW1lID0gZmFsc2U7XG4gICAgdGhpcy5wQ2VudGVyID0gZmFsc2U7XG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgfVxuICBpbmhlcml0KFRhcFJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICBldmVudDogJ3RhcCcsXG4gICAgICBwb2ludGVyczogMSxcbiAgICAgIHRhcHM6IDEsXG4gICAgICBpbnRlcnZhbDogMzAwLFxuICAgICAgLy8gbWF4IHRpbWUgYmV0d2VlbiB0aGUgbXVsdGktdGFwIHRhcHNcbiAgICAgIHRpbWU6IDI1MCxcbiAgICAgIC8vIG1heCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIGRvd24gKGxpa2UgZmluZ2VyIG9uIHRoZSBzY3JlZW4pXG4gICAgICB0aHJlc2hvbGQ6IDksXG4gICAgICAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgICAgcG9zVGhyZXNob2xkOiAxMCAvLyBhIG11bHRpLXRhcCBjYW4gYmUgYSBiaXQgb2ZmIHRoZSBpbml0aWFsIHBvc2l0aW9uXG4gICAgfSxcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OXTtcbiAgICB9LFxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgIHZhciB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiB0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG4gICAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XG4gICAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfRU5EKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsaWRJbnRlcnZhbCA9IHRoaXMucFRpbWUgPyBpbnB1dC50aW1lU3RhbXAgLSB0aGlzLnBUaW1lIDwgb3B0aW9ucy5pbnRlcnZhbCA6IHRydWU7XG4gICAgICAgIHZhciB2YWxpZE11bHRpVGFwID0gIXRoaXMucENlbnRlciB8fCBnZXREaXN0YW5jZSh0aGlzLnBDZW50ZXIsIGlucHV0LmNlbnRlcikgPCBvcHRpb25zLnBvc1RocmVzaG9sZDtcbiAgICAgICAgdGhpcy5wVGltZSA9IGlucHV0LnRpbWVTdGFtcDtcbiAgICAgICAgdGhpcy5wQ2VudGVyID0gaW5wdXQuY2VudGVyO1xuICAgICAgICBpZiAoIXZhbGlkTXVsdGlUYXAgfHwgIXZhbGlkSW50ZXJ2YWwpIHtcbiAgICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgICAvLyBpZiB0YXAgY291bnQgbWF0Y2hlcyB3ZSBoYXZlIHJlY29nbml6ZWQgaXQsXG4gICAgICAgIC8vIGVsc2UgaXQgaGFzIGJlZ2FuIHJlY29nbml6aW5nLi4uXG4gICAgICAgIHZhciB0YXBDb3VudCA9IHRoaXMuY291bnQgJSBvcHRpb25zLnRhcHM7XG4gICAgICAgIGlmICh0YXBDb3VudCA9PT0gMCkge1xuICAgICAgICAgIC8vIG5vIGZhaWxpbmcgcmVxdWlyZW1lbnRzLCBpbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSB0YXAgZXZlbnRcbiAgICAgICAgICAvLyBvciB3YWl0IGFzIGxvbmcgYXMgdGhlIG11bHRpdGFwIGludGVydmFsIHRvIHRyaWdnZXJcbiAgICAgICAgICBpZiAoIXRoaXMuaGFzUmVxdWlyZUZhaWx1cmVzKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG4gICAgZmFpbFRpbWVvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcbiAgICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgdGhpcy5faW5wdXQudGFwQ291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTaW1wbGUgd2F5IHRvIGNyZWF0ZSBhIG1hbmFnZXIgd2l0aCBhIGRlZmF1bHQgc2V0IG9mIHJlY29nbml6ZXJzLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucmVjb2duaXplcnMgPSBpZlVuZGVmaW5lZChvcHRpb25zLnJlY29nbml6ZXJzLCBIYW1tZXIuZGVmYXVsdHMucHJlc2V0KTtcbiAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQGNvbnN0IHtzdHJpbmd9XG4gICAqL1xuICBIYW1tZXIuVkVSU0lPTiA9ICcyLjAuNyc7XG5cbiAgLyoqXG4gICAqIGRlZmF1bHQgc2V0dGluZ3NcbiAgICogQG5hbWVzcGFjZVxuICAgKi9cbiAgSGFtbWVyLmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIHNldCBpZiBET00gZXZlbnRzIGFyZSBiZWluZyB0cmlnZ2VyZWQuXG4gICAgICogQnV0IHRoaXMgaXMgc2xvd2VyIGFuZCB1bnVzZWQgYnkgc2ltcGxlIGltcGxlbWVudGF0aW9ucywgc28gZGlzYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGRvbUV2ZW50czogZmFsc2UsXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkvZmFsbGJhY2suXG4gICAgICogV2hlbiBzZXQgdG8gYGNvbXB1dGVgIGl0IHdpbGwgbWFnaWNhbGx5IHNldCB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiB0aGUgYWRkZWQgcmVjb2duaXplcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBjb21wdXRlXG4gICAgICovXG4gICAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBlbmFibGU6IHRydWUsXG4gICAgLyoqXG4gICAgICogRVhQRVJJTUVOVEFMIEZFQVRVUkUgLS0gY2FuIGJlIHJlbW92ZWQvY2hhbmdlZFxuICAgICAqIENoYW5nZSB0aGUgcGFyZW50IGlucHV0IHRhcmdldCBlbGVtZW50LlxuICAgICAqIElmIE51bGwsIHRoZW4gaXQgaXMgYmVpbmcgc2V0IHRoZSB0byBtYWluIGVsZW1lbnQuXG4gICAgICogQHR5cGUge051bGx8RXZlbnRUYXJnZXR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGlucHV0VGFyZ2V0OiBudWxsLFxuICAgIC8qKlxuICAgICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXG4gICAgICogQHR5cGUge051bGx8RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGlucHV0Q2xhc3M6IG51bGwsXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCByZWNvZ25pemVyIHNldHVwIHdoZW4gY2FsbGluZyBgSGFtbWVyKClgXG4gICAgICogV2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyIHRoZXNlIHdpbGwgYmUgc2tpcHBlZC5cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgcHJlc2V0OiBbXG4gICAgLy8gUmVjb2duaXplckNsYXNzLCBvcHRpb25zLCBbcmVjb2duaXplV2l0aCwgLi4uXSwgW3JlcXVpcmVGYWlsdXJlLCAuLi5dXG4gICAgW1JvdGF0ZVJlY29nbml6ZXIsIHtcbiAgICAgIGVuYWJsZTogZmFsc2VcbiAgICB9XSwgW1BpbmNoUmVjb2duaXplciwge1xuICAgICAgZW5hYmxlOiBmYWxzZVxuICAgIH0sIFsncm90YXRlJ11dLCBbU3dpcGVSZWNvZ25pemVyLCB7XG4gICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMXG4gICAgfV0sIFtQYW5SZWNvZ25pemVyLCB7XG4gICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMXG4gICAgfSwgWydzd2lwZSddXSwgW1RhcFJlY29nbml6ZXJdLCBbVGFwUmVjb2duaXplciwge1xuICAgICAgZXZlbnQ6ICdkb3VibGV0YXAnLFxuICAgICAgdGFwczogMlxuICAgIH0sIFsndGFwJ11dLCBbUHJlc3NSZWNvZ25pemVyXV0sXG4gICAgLyoqXG4gICAgICogU29tZSBDU1MgcHJvcGVydGllcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHRoZSB3b3JraW5nIG9mIEhhbW1lci5cbiAgICAgKiBBZGQgdGhlbSB0byB0aGlzIG1ldGhvZCBhbmQgdGhleSB3aWxsIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIuXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqL1xuICAgIGNzc1Byb3BzOiB7XG4gICAgICAvKipcbiAgICAgICAqIERpc2FibGVzIHRleHQgc2VsZWN0aW9uIHRvIGltcHJvdmUgdGhlIGRyYWdnaW5nIGdlc3R1cmUuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAqL1xuICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXNhYmxlIHRoZSBXaW5kb3dzIFBob25lIGdyaXBwZXJzIHdoZW4gcHJlc3NpbmcgYW4gZWxlbWVudC5cbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAqL1xuICAgICAgdG91Y2hTZWxlY3Q6ICdub25lJyxcbiAgICAgIC8qKlxuICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuICAgICAgICogYSBjYWxsb3V0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxpbmsuIFRoaXMgcHJvcGVydHkgYWxsb3dzIHlvdSB0byBkaXNhYmxlIHRoYXQgY2FsbG91dC5cbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAqL1xuICAgICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICovXG4gICAgICBjb250ZW50Wm9vbWluZzogJ25vbmUnLFxuICAgICAgLyoqXG4gICAgICAgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgKi9cbiAgICAgIHVzZXJEcmFnOiAnbm9uZScsXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyB0aGUgaGlnaGxpZ2h0IGNvbG9yIHNob3duIHdoZW4gdGhlIHVzZXIgdGFwcyBhIGxpbmsgb3IgYSBKYXZhU2NyaXB0XG4gICAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICogQGRlZmF1bHQgJ3JnYmEoMCwwLDAsMCknXG4gICAgICAgKi9cbiAgICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgICB9XG4gIH07XG4gIHZhciBTVE9QID0gMTtcbiAgdmFyIEZPUkNFRF9TVE9QID0gMjtcblxuICAvKipcbiAgICogTWFuYWdlclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIEhhbW1lci5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG4gICAgdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0ID0gdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0IHx8IGVsZW1lbnQ7XG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcbiAgICB0aGlzLm9sZENzc1Byb3BzID0ge307XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcbiAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XG4gICAgdG9nZ2xlQ3NzUHJvcHModGhpcywgdHJ1ZSk7XG4gICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgcmVjb2duaXplciA9IHRoaXMuYWRkKG5ldyBpdGVtWzBdKGl0ZW1bMV0pKTtcbiAgICAgIGl0ZW1bMl0gJiYgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW1bMl0pO1xuICAgICAgaXRlbVszXSAmJiByZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKGl0ZW1bM10pO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIE1hbmFnZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgLy8gT3B0aW9ucyB0aGF0IG5lZWQgYSBsaXR0bGUgbW9yZSBzZXR1cFxuICAgICAgaWYgKG9wdGlvbnMudG91Y2hBY3Rpb24pIHtcbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmlucHV0VGFyZ2V0KSB7XG4gICAgICAgIC8vIENsZWFuIHVwIGV4aXN0aW5nIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVpbml0aWFsaXplXG4gICAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlucHV0LnRhcmdldCA9IG9wdGlvbnMuaW5wdXRUYXJnZXQ7XG4gICAgICAgIHRoaXMuaW5wdXQuaW5pdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzdG9wIHJlY29nbml6aW5nIGZvciB0aGlzIHNlc3Npb24uXG4gICAgICogVGhpcyBzZXNzaW9uIHdpbGwgYmUgZGlzY2FyZGVkLCB3aGVuIGEgbmV3IFtpbnB1dF1zdGFydCBldmVudCBpcyBmaXJlZC5cbiAgICAgKiBXaGVuIGZvcmNlZCwgdGhlIHJlY29nbml6ZXIgY3ljbGUgaXMgc3RvcHBlZCBpbW1lZGlhdGVseS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAgICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgIHRoaXMuc2Vzc2lvbi5zdG9wcGVkID0gZm9yY2UgPyBGT1JDRURfU1RPUCA6IFNUT1A7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBydW4gdGhlIHJlY29nbml6ZXJzIVxuICAgICAqIGNhbGxlZCBieSB0aGUgaW5wdXRIYW5kbGVyIGZ1bmN0aW9uIG9uIGV2ZXJ5IG1vdmVtZW50IG9mIHRoZSBwb2ludGVycyAodG91Y2hlcylcbiAgICAgKiBpdCB3YWxrcyB0aHJvdWdoIGFsbCB0aGUgcmVjb2duaXplcnMgYW5kIHRyaWVzIHRvIGRldGVjdCB0aGUgZ2VzdHVyZSB0aGF0IGlzIGJlaW5nIG1hZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgcmVjb2duaXplOiBmdW5jdGlvbiAoaW5wdXREYXRhKSB7XG4gICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuICAgICAgdGhpcy50b3VjaEFjdGlvbi5wcmV2ZW50RGVmYXVsdHMoaW5wdXREYXRhKTtcbiAgICAgIHZhciByZWNvZ25pemVyO1xuICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcblxuICAgICAgLy8gdGhpcyBob2xkcyB0aGUgcmVjb2duaXplciB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXG4gICAgICAvLyBpZiBubyByZWNvZ25pemVyIGlzIGRldGVjdGluZyBhIHRoaW5nLCBpdCBpcyBzZXQgdG8gYG51bGxgXG4gICAgICB2YXIgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplcjtcblxuICAgICAgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAgIC8vIG9yIHdoZW4gd2UncmUgaW4gYSBuZXcgc2Vzc2lvblxuICAgICAgaWYgKCFjdXJSZWNvZ25pemVyIHx8IGN1clJlY29nbml6ZXIgJiYgY3VyUmVjb2duaXplci5zdGF0ZSAmIFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xuICAgICAgICByZWNvZ25pemVyID0gcmVjb2duaXplcnNbaV07XG5cbiAgICAgICAgLy8gZmluZCBvdXQgaWYgd2UgYXJlIGFsbG93ZWQgdHJ5IHRvIHJlY29nbml6ZSB0aGUgaW5wdXQgZm9yIHRoaXMgb25lLlxuICAgICAgICAvLyAxLiAgIGFsbG93IGlmIHRoZSBzZXNzaW9uIGlzIE5PVCBmb3JjZWQgc3RvcHBlZCAoc2VlIHRoZSAuc3RvcCgpIG1ldGhvZClcbiAgICAgICAgLy8gMi4gICBhbGxvdyBpZiB3ZSBzdGlsbCBoYXZlbid0IHJlY29nbml6ZWQgYSBnZXN0dXJlIGluIHRoaXMgc2Vzc2lvbiwgb3IgdGhlIHRoaXMgcmVjb2duaXplciBpcyB0aGUgb25lXG4gICAgICAgIC8vICAgICAgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAvLyAzLiAgIGFsbG93IGlmIHRoZSByZWNvZ25pemVyIGlzIGFsbG93ZWQgdG8gcnVuIHNpbXVsdGFuZW91cyB3aXRoIHRoZSBjdXJyZW50IHJlY29nbml6ZWQgcmVjb2duaXplci5cbiAgICAgICAgLy8gICAgICB0aGlzIGNhbiBiZSBzZXR1cCB3aXRoIHRoZSBgcmVjb2duaXplV2l0aCgpYCBtZXRob2Qgb24gdGhlIHJlY29nbml6ZXIuXG4gICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQgIT09IEZPUkNFRF9TVE9QICYmIChcbiAgICAgICAgLy8gMVxuICAgICAgICAhY3VyUmVjb2duaXplciB8fCByZWNvZ25pemVyID09IGN1clJlY29nbml6ZXIgfHxcbiAgICAgICAgLy8gMlxuICAgICAgICByZWNvZ25pemVyLmNhblJlY29nbml6ZVdpdGgoY3VyUmVjb2duaXplcikpKSB7XG4gICAgICAgICAgLy8gM1xuICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHJlY29nbml6ZXIgaGFzIGJlZW4gcmVjb2duaXppbmcgdGhlIGlucHV0IGFzIGEgdmFsaWQgZ2VzdHVyZSwgd2Ugd2FudCB0byBzdG9yZSB0aGlzIG9uZSBhcyB0aGVcbiAgICAgICAgLy8gY3VycmVudCBhY3RpdmUgcmVjb2duaXplci4gYnV0IG9ubHkgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGFuIGFjdGl2ZSByZWNvZ25pemVyXG4gICAgICAgIGlmICghY3VyUmVjb2duaXplciAmJiByZWNvZ25pemVyLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEKSkge1xuICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBhIHJlY29nbml6ZXIgYnkgaXRzIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE51bGx9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAocmVjb2duaXplcikge1xuICAgICAgaWYgKHJlY29nbml6ZXIgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSB7XG4gICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgICAgfVxuICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlY29nbml6ZXJzW2ldLm9wdGlvbnMuZXZlbnQgPT0gcmVjb2duaXplcikge1xuICAgICAgICAgIHJldHVybiByZWNvZ25pemVyc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBhZGQgYSByZWNvZ25pemVyIHRvIHRoZSBtYW5hZ2VyXG4gICAgICogZXhpc3RpbmcgcmVjb2duaXplcnMgd2l0aCB0aGUgc2FtZSBldmVudCBuYW1lIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE1hbmFnZXJ9XG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbiAocmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdhZGQnLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXG4gICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLmdldChyZWNvZ25pemVyLm9wdGlvbnMuZXZlbnQpO1xuICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVjb2duaXplcnMucHVzaChyZWNvZ25pemVyKTtcbiAgICAgIHJlY29nbml6ZXIubWFuYWdlciA9IHRoaXM7XG4gICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZW1vdmUgYSByZWNvZ25pemVyIGJ5IG5hbWUgb3IgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAocmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdyZW1vdmUnLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJlY29nbml6ZXIgPSB0aGlzLmdldChyZWNvZ25pemVyKTtcblxuICAgICAgLy8gbGV0J3MgbWFrZSBzdXJlIHRoaXMgcmVjb2duaXplciBleGlzdHNcbiAgICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgIHZhciBpbmRleCA9IGluQXJyYXkocmVjb2duaXplcnMsIHJlY29nbml6ZXIpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgcmVjb2duaXplcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGJpbmQgZXZlbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24gKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXJzW2V2ZW50XSB8fCBbXTtcbiAgICAgICAgaGFuZGxlcnNbZXZlbnRdLnB1c2goaGFuZGxlcik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24gKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICBkZWxldGUgaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XSAmJiBoYW5kbGVyc1tldmVudF0uc3BsaWNlKGluQXJyYXkoaGFuZGxlcnNbZXZlbnRdLCBoYW5kbGVyKSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBlbWl0IGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kb21FdmVudHMpIHtcbiAgICAgICAgdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKTtcbiAgICAgIH1cblxuICAgICAgLy8gbm8gaGFuZGxlcnMsIHNvIHNraXAgaXQgYWxsXG4gICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xuICAgICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRhdGEudHlwZSA9IGV2ZW50O1xuICAgICAgZGF0YS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgIGhhbmRsZXJzW2ldKGRhdGEpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBkZXN0cm95IHRoZSBtYW5hZ2VyIGFuZCB1bmJpbmRzIGFsbCBldmVudHNcbiAgICAgKiBpdCBkb2Vzbid0IHVuYmluZCBkb20gZXZlbnRzLCB0aGF0IGlzIHRoZSB1c2VyIG93biByZXNwb25zaWJpbGl0eVxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZWxlbWVudCAmJiB0b2dnbGVDc3NQcm9wcyh0aGlzLCBmYWxzZSk7XG4gICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGFkZC9yZW1vdmUgdGhlIGNzcyBwcm9wZXJ0aWVzIGFzIGRlZmluZWQgaW4gbWFuYWdlci5vcHRpb25zLmNzc1Byb3BzXG4gICAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFkZFxuICAgKi9cbiAgZnVuY3Rpb24gdG9nZ2xlQ3NzUHJvcHMobWFuYWdlciwgYWRkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwcm9wO1xuICAgIGVhY2gobWFuYWdlci5vcHRpb25zLmNzc1Byb3BzLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICAgIHByb3AgPSBwcmVmaXhlZChlbGVtZW50LnN0eWxlLCBuYW1lKTtcbiAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSA9IGVsZW1lbnQuc3R5bGVbcHJvcF07XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdIHx8ICcnO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghYWRkKSB7XG4gICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzID0ge307XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHRyaWdnZXIgZG9tIGV2ZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cbiAgZnVuY3Rpb24gdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGdlc3R1cmVFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGdlc3R1cmVFdmVudC5pbml0RXZlbnQoZXZlbnQsIHRydWUsIHRydWUpO1xuICAgIGdlc3R1cmVFdmVudC5nZXN0dXJlID0gZGF0YTtcbiAgICBkYXRhLnRhcmdldC5kaXNwYXRjaEV2ZW50KGdlc3R1cmVFdmVudCk7XG4gIH1cbiAgYXNzaWduKEhhbW1lciwge1xuICAgIElOUFVUX1NUQVJUOiBJTlBVVF9TVEFSVCxcbiAgICBJTlBVVF9NT1ZFOiBJTlBVVF9NT1ZFLFxuICAgIElOUFVUX0VORDogSU5QVVRfRU5ELFxuICAgIElOUFVUX0NBTkNFTDogSU5QVVRfQ0FOQ0VMLFxuICAgIFNUQVRFX1BPU1NJQkxFOiBTVEFURV9QT1NTSUJMRSxcbiAgICBTVEFURV9CRUdBTjogU1RBVEVfQkVHQU4sXG4gICAgU1RBVEVfQ0hBTkdFRDogU1RBVEVfQ0hBTkdFRCxcbiAgICBTVEFURV9FTkRFRDogU1RBVEVfRU5ERUQsXG4gICAgU1RBVEVfUkVDT0dOSVpFRDogU1RBVEVfUkVDT0dOSVpFRCxcbiAgICBTVEFURV9DQU5DRUxMRUQ6IFNUQVRFX0NBTkNFTExFRCxcbiAgICBTVEFURV9GQUlMRUQ6IFNUQVRFX0ZBSUxFRCxcbiAgICBESVJFQ1RJT05fTk9ORTogRElSRUNUSU9OX05PTkUsXG4gICAgRElSRUNUSU9OX0xFRlQ6IERJUkVDVElPTl9MRUZULFxuICAgIERJUkVDVElPTl9SSUdIVDogRElSRUNUSU9OX1JJR0hULFxuICAgIERJUkVDVElPTl9VUDogRElSRUNUSU9OX1VQLFxuICAgIERJUkVDVElPTl9ET1dOOiBESVJFQ1RJT05fRE9XTixcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTDogRElSRUNUSU9OX0hPUklaT05UQUwsXG4gICAgRElSRUNUSU9OX1ZFUlRJQ0FMOiBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgRElSRUNUSU9OX0FMTDogRElSRUNUSU9OX0FMTCxcbiAgICBNYW5hZ2VyOiBNYW5hZ2VyLFxuICAgIElucHV0OiBJbnB1dCxcbiAgICBUb3VjaEFjdGlvbjogVG91Y2hBY3Rpb24sXG4gICAgVG91Y2hJbnB1dDogVG91Y2hJbnB1dCxcbiAgICBNb3VzZUlucHV0OiBNb3VzZUlucHV0LFxuICAgIFBvaW50ZXJFdmVudElucHV0OiBQb2ludGVyRXZlbnRJbnB1dCxcbiAgICBUb3VjaE1vdXNlSW5wdXQ6IFRvdWNoTW91c2VJbnB1dCxcbiAgICBTaW5nbGVUb3VjaElucHV0OiBTaW5nbGVUb3VjaElucHV0LFxuICAgIFJlY29nbml6ZXI6IFJlY29nbml6ZXIsXG4gICAgQXR0clJlY29nbml6ZXI6IEF0dHJSZWNvZ25pemVyLFxuICAgIFRhcDogVGFwUmVjb2duaXplcixcbiAgICBQYW46IFBhblJlY29nbml6ZXIsXG4gICAgU3dpcGU6IFN3aXBlUmVjb2duaXplcixcbiAgICBQaW5jaDogUGluY2hSZWNvZ25pemVyLFxuICAgIFJvdGF0ZTogUm90YXRlUmVjb2duaXplcixcbiAgICBQcmVzczogUHJlc3NSZWNvZ25pemVyLFxuICAgIG9uOiBhZGRFdmVudExpc3RlbmVycyxcbiAgICBvZmY6IHJlbW92ZUV2ZW50TGlzdGVuZXJzLFxuICAgIGVhY2g6IGVhY2gsXG4gICAgbWVyZ2U6IG1lcmdlLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIGFzc2lnbjogYXNzaWduLFxuICAgIGluaGVyaXQ6IGluaGVyaXQsXG4gICAgYmluZEZuOiBiaW5kRm4sXG4gICAgcHJlZml4ZWQ6IHByZWZpeGVkXG4gIH0pO1xuXG4gIC8vIHRoaXMgcHJldmVudHMgZXJyb3JzIHdoZW4gSGFtbWVyIGlzIGxvYWRlZCBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EXG4gIC8vICBzdHlsZSBsb2FkZXIgYnV0IGJ5IHNjcmlwdCB0YWcsIG5vdCBieSB0aGUgbG9hZGVyLlxuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9OyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgZnJlZUdsb2JhbC5IYW1tZXIgPSBIYW1tZXI7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEhhbW1lcjtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIYW1tZXI7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93W2V4cG9ydE5hbWVdID0gSGFtbWVyO1xuICB9XG59KSh3aW5kb3csIGRvY3VtZW50LCAnSGFtbWVyJyk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///75645\n")},31254:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": function() { return /* binding */ pages; }\n});\n\n// NAMESPACE OBJECT: ./src/components/MapSearch/MapSearch.module.scss\nvar MapSearch_module_namespaceObject = {};\n__webpack_require__.r(MapSearch_module_namespaceObject);\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(96540);\n// EXTERNAL MODULE: ./node_modules/gatsby-plugin-intl/index.js\nvar gatsby_plugin_intl = __webpack_require__(23218);\n// EXTERNAL MODULE: ./node_modules/@trussworks/react-uswds/lib/index.js\nvar lib = __webpack_require__(17292);\n// EXTERNAL MODULE: ./src/data/copy/explore.tsx\nvar explore = __webpack_require__(9284);\n;// ./src/components/ExploreDataBox/ExploreDataBox.module.scss\n// extracted by mini-css-extract-plugin\nvar fileDownIcon = \"ExploreDataBox-module--fileDownIcon--ELpRf\";\nvar summaryBoxContainer = \"ExploreDataBox-module--summaryBoxContainer--7DnTC\";\n// EXTERNAL MODULE: ./node_modules/uswds/dist/img/usa-icons/file_download.svg\nvar file_download = __webpack_require__(96168);\n;// ./src/components/ExploreDataBox/ExploreDataBox.tsx\n// @ts-ignore\nconst ExploreDataBox=_ref=>{let{}=_ref;const intl=(0,gatsby_plugin_intl.useIntl)();return/*#__PURE__*/react.createElement(lib.SummaryBox,{className:summaryBoxContainer},/*#__PURE__*/react.createElement(lib.SummaryBoxHeading,{headingLevel:\"h2\"},intl.formatMessage(explore/* EXPLORE_DATA_BOX */.jU.TITLE),/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:fileDownIcon,src:file_download/* default */.A,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.PLUS)})),/*#__PURE__*/react.createElement(lib.SummaryBoxContent,null,explore/* EXPLORE_DATA_BOX_BODY */.U5));};/* harmony default export */ var ExploreDataBox_ExploreDataBox = (ExploreDataBox);\n;// ./src/components/ExploreDataBox/index.ts\n/* harmony default export */ var components_ExploreDataBox = (ExploreDataBox_ExploreDataBox);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 3 modules\nvar toConsumableArray = __webpack_require__(45458);\n;// ./node_modules/@babel/runtime/helpers/esm/extends.js\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/typeof.js\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\n\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\n\n\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\n\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(5556);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n;// ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js\nvar unsupportedIterableToArray = __webpack_require__(27800);\n;// ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\n\n\n\n\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || (0,unsupportedIterableToArray/* default */.A)(r, e) || _nonIterableRest();\n}\n\n;// ./node_modules/gl-matrix/esm/common.js\n/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nvar EPSILON = 0.000001;\nvar ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nvar RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nfunction setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nfunction toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n    i = arguments.length;\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n  return Math.sqrt(y);\n};\n;// ./node_modules/gl-matrix/esm/vec4.js\n\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\n\nfunction create() {\n  var out = new ARRAY_TYPE(4);\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n  return out;\n}\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {ReadonlyVec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\n\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\n\nfunction fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the source vector\n * @returns {vec4} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\n\nfunction set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to ceil\n * @returns {vec4} out\n */\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to floor\n * @returns {vec4} out\n */\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to round\n * @returns {vec4} out\n */\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} distance between a and b\n */\n\nfunction distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Calculates the length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction vec4_length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nfunction squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to negate\n * @returns {vec4} out\n */\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to invert\n * @returns {vec4} out\n */\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to normalize\n * @returns {vec4} out\n */\n\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param {ReadonlyVec4} result the receiving vector\n * @param {ReadonlyVec4} U the first vector\n * @param {ReadonlyVec4} V the second vector\n * @param {ReadonlyVec4} W the third vector\n * @returns {vec4} result\n */\n\nfunction cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n    B = v[0] * w[2] - v[2] * w[0],\n    C = v[0] * w[3] - v[3] * w[0],\n    D = v[1] * w[2] - v[2] * w[1],\n    E = v[1] * w[3] - v[3] * w[1],\n    F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\n\nfunction random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n  do {\n    v1 = glMatrix.RANDOM() * 2 - 1;\n    v2 = glMatrix.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n  do {\n    v3 = glMatrix.RANDOM() * 2 - 1;\n    v4 = glMatrix.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec4} out\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n    y = a[1],\n    z = a[2],\n    w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec4} out\n */\n\nfunction transformQuat(out, a, q) {\n  var x = a[0],\n    y = a[1],\n    z = a[2];\n  var qx = q[0],\n    qy = q[1],\n    qz = q[2],\n    qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to zero\n *\n * @param {vec4} out the receiving vector\n * @returns {vec4} out\n */\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nfunction str(a) {\n  return \"vec4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction vec4_equals(a, b) {\n  var a0 = a[0],\n    a1 = a[1],\n    a2 = a[2],\n    a3 = a[3];\n  var b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\n\nvar sub = (/* unused pure expression or super */ null && (subtract));\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\n\nvar mul = (/* unused pure expression or super */ null && (multiply));\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\n\nvar div = (/* unused pure expression or super */ null && (divide));\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\n\nvar dist = (/* unused pure expression or super */ null && (distance));\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\n\nvar sqrDist = (/* unused pure expression or super */ null && (squaredDistance));\n/**\n * Alias for {@link vec4.length}\n * @function\n */\n\nvar len = (/* unused pure expression or super */ null && (vec4_length));\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\n\nvar sqrLen = (/* unused pure expression or super */ null && (squaredLength));\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nvar forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n    if (!stride) {\n      stride = 4;\n    }\n    if (!offset) {\n      offset = 0;\n    }\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n    return a;\n  };\n}();\n;// ./node_modules/@math.gl/web-mercator/dist/esm/math-utils.js\n\nfunction createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nfunction transformVector(matrix, vector) {\n  const result = transformMat4([], vector, matrix);\n  scale(result, result, 1 / result[3]);\n  return result;\n}\nfunction mod(value, divisor) {\n  const modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\nfunction math_utils_lerp(start, end, step) {\n  return step * end + (1 - step) * start;\n}\nfunction clamp(x, min, max) {\n  return x < min ? min : x > max ? max : x;\n}\nfunction ieLog2(x) {\n  return Math.log(x) * Math.LOG2E;\n}\nconst log2 = Math.log2 || ieLog2;\n;// ./node_modules/gl-matrix/esm/mat4.js\n\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\n\nfunction mat4_create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\n\nfunction mat4_clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction mat4_copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\n\nfunction mat4_fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\n\nfunction mat4_set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n    var a12 = a[6],\n      a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction invert(out, a) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a03 = a[3];\n  var a10 = a[4],\n    a11 = a[5],\n    a12 = a[6],\n    a13 = a[7];\n  var a20 = a[8],\n    a21 = a[9],\n    a22 = a[10],\n    a23 = a[11];\n  var a30 = a[12],\n    a31 = a[13],\n    a32 = a[14],\n    a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction adjoint(out, a) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a03 = a[3];\n  var a10 = a[4],\n    a11 = a[5],\n    a12 = a[6],\n    a13 = a[7];\n  var a20 = a[8],\n    a21 = a[9],\n    a22 = a[10],\n    a23 = a[11];\n  var a30 = a[12],\n    a31 = a[13],\n    a32 = a[14],\n    a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nfunction determinant(a) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a03 = a[3];\n  var a10 = a[4],\n    a11 = a[5],\n    a12 = a[6],\n    a13 = a[7];\n  var a20 = a[8],\n    a21 = a[9],\n    a22 = a[10],\n    a23 = a[11];\n  var a30 = a[12],\n    a31 = a[13],\n    a32 = a[14],\n    a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction mat4_multiply(out, a, b) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a03 = a[3];\n  var a10 = a[4],\n    a11 = a[5],\n    a12 = a[6],\n    a13 = a[7];\n  var a20 = a[8],\n    a21 = a[9],\n    a22 = a[10],\n    a23 = a[11];\n  var a30 = a[12],\n    a31 = a[13],\n    a32 = a[14],\n    a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\n\nfunction translate(out, a, v) {\n  var x = v[0],\n    y = v[1],\n    z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nfunction mat4_scale(out, a, v) {\n  var x = v[0],\n    y = v[1],\n    z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nfunction rotate(out, a, rad, axis) {\n  var x = axis[0],\n    y = axis[1],\n    z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nfunction fromRotation(out, rad, axis) {\n  var x = axis[0],\n    y = axis[1],\n    z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n    y = q[1],\n    z = q[2],\n    w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\n\nfunction fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n    by = -a[1],\n    bz = -a[2],\n    bw = a[3],\n    ax = a[4],\n    ay = a[5],\n    az = a[6],\n    aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nfunction getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nfunction getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nfunction getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n    y = q[1],\n    z = q[2],\n    w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n    y = q[1],\n    z = q[2],\n    w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nfunction fromQuat(out, q) {\n  var x = q[0],\n    y = q[1],\n    z = q[2],\n    w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nfunction perspectiveNO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n    nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n  return out;\n}\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\n\nvar perspective = perspectiveNO;\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nfunction perspectiveZO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n    nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction orthoNO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\n\nvar ortho = (/* unused pure expression or super */ null && (orthoNO));\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction orthoZO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = near * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nfunction lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nfunction targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n    eyey = eye[1],\n    eyez = eye[2],\n    upx = up[0],\n    upy = up[1],\n    upz = up[2];\n  var z0 = eyex - target[0],\n    z1 = eyey - target[1],\n    z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n  var x0 = upy * z2 - upz * z1,\n    x1 = upz * z0 - upx * z2,\n    x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nfunction mat4_str(a) {\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nfunction frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction mat4_add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction mat4_subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction mat4_exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction mat4_equals(a, b) {\n  var a0 = a[0],\n    a1 = a[1],\n    a2 = a[2],\n    a3 = a[3];\n  var a4 = a[4],\n    a5 = a[5],\n    a6 = a[6],\n    a7 = a[7];\n  var a8 = a[8],\n    a9 = a[9],\n    a10 = a[10],\n    a11 = a[11];\n  var a12 = a[12],\n    a13 = a[13],\n    a14 = a[14],\n    a15 = a[15];\n  var b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3];\n  var b4 = b[4],\n    b5 = b[5],\n    b6 = b[6],\n    b7 = b[7];\n  var b8 = b[8],\n    b9 = b[9],\n    b10 = b[10],\n    b11 = b[11];\n  var b12 = b[12],\n    b13 = b[13],\n    b14 = b[14],\n    b15 = b[15];\n  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\n\nvar mat4_mul = (/* unused pure expression or super */ null && (mat4_multiply));\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\n\nvar mat4_sub = (/* unused pure expression or super */ null && (mat4_subtract));\n;// ./node_modules/gl-matrix/esm/vec2.js\n\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\n\nfunction vec2_create() {\n  var out = new ARRAY_TYPE(2);\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n  return out;\n}\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {ReadonlyVec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\n\nfunction vec2_clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\n\nfunction vec2_fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the source vector\n * @returns {vec2} out\n */\n\nfunction vec2_copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\n\nfunction vec2_set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction vec2_add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction vec2_subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction vec2_multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction vec2_divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to ceil\n * @returns {vec2} out\n */\n\nfunction vec2_ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to floor\n * @returns {vec2} out\n */\n\nfunction vec2_floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction vec2_min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction vec2_max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to round\n * @returns {vec2} out\n */\n\nfunction vec2_round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\n\nfunction vec2_scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\n\nfunction vec2_scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} distance between a and b\n */\n\nfunction vec2_distance(a, b) {\n  var x = b[0] - a[0],\n    y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nfunction vec2_squaredDistance(a, b) {\n  var x = b[0] - a[0],\n    y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\n * Calculates the length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction vec2_length(a) {\n  var x = a[0],\n    y = a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nfunction vec2_squaredLength(a) {\n  var x = a[0],\n    y = a[1];\n  return x * x + y * y;\n}\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to negate\n * @returns {vec2} out\n */\n\nfunction vec2_negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to invert\n * @returns {vec2} out\n */\n\nfunction vec2_inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to normalize\n * @returns {vec2} out\n */\n\nfunction vec2_normalize(out, a) {\n  var x = a[0],\n    y = a[1];\n  var len = x * x + y * y;\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction vec2_dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec2_cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\n\nfunction vec2_lerp(out, a, b, t) {\n  var ax = a[0],\n    ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\n\nfunction vec2_random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction transformMat2(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2d} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction transformMat2d(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat3} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction vec2_transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {ReadonlyVec2} a The vec2 point to rotate\n * @param {ReadonlyVec2} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec2} out\n */\n\nfunction vec2_rotate(out, a, b, rad) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n    p1 = a[1] - b[1],\n    sinC = Math.sin(rad),\n    cosC = Math.cos(rad); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\n * Get the angle between two 2D vectors\n * @param {ReadonlyVec2} a The first operand\n * @param {ReadonlyVec2} b The second operand\n * @returns {Number} The angle in radians\n */\n\nfunction angle(a, b) {\n  var x1 = a[0],\n    y1 = a[1],\n    x2 = b[0],\n    y2 = b[1],\n    // mag is the product of the magnitudes of a and b\n    mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),\n    // mag &&.. short circuits if mag == 0\n    cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1\n\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec2 to zero\n *\n * @param {vec2} out the receiving vector\n * @returns {vec2} out\n */\n\nfunction vec2_zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nfunction vec2_str(a) {\n  return \"vec2(\" + a[0] + \", \" + a[1] + \")\";\n}\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction vec2_exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction vec2_equals(a, b) {\n  var a0 = a[0],\n    a1 = a[1];\n  var b0 = b[0],\n    b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\n * Alias for {@link vec2.length}\n * @function\n */\n\nvar vec2_len = (/* unused pure expression or super */ null && (vec2_length));\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\n\nvar vec2_sub = vec2_subtract;\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\n\nvar vec2_mul = (/* unused pure expression or super */ null && (vec2_multiply));\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\n\nvar vec2_div = (/* unused pure expression or super */ null && (vec2_divide));\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\n\nvar vec2_dist = (/* unused pure expression or super */ null && (vec2_distance));\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\n\nvar vec2_sqrDist = (/* unused pure expression or super */ null && (vec2_squaredDistance));\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\n\nvar vec2_sqrLen = (/* unused pure expression or super */ null && (vec2_squaredLength));\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nvar vec2_forEach = function () {\n  var vec = vec2_create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n    if (!stride) {\n      stride = 2;\n    }\n    if (!offset) {\n      offset = 0;\n    }\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n    return a;\n  };\n}();\n;// ./node_modules/gl-matrix/esm/vec3.js\n\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nfunction vec3_create() {\n  var out = new ARRAY_TYPE(3);\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nfunction vec3_clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction vec3_length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nfunction vec3_fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nfunction vec3_copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nfunction vec3_set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec3_add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec3_subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec3_multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec3_divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nfunction vec3_ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nfunction vec3_floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec3_min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec3_max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nfunction vec3_round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nfunction vec3_scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nfunction vec3_scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nfunction vec3_distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nfunction vec3_squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nfunction vec3_squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nfunction vec3_negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nfunction vec3_inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nfunction vec3_normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction vec3_dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec3_cross(out, a, b) {\n  var ax = a[0],\n    ay = a[1],\n    az = a[2];\n  var bx = b[0],\n    by = b[1],\n    bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nfunction vec3_lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nfunction hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nfunction bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nfunction vec3_random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nfunction vec3_transformMat4(out, a, m) {\n  var x = a[0],\n    y = a[1],\n    z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nfunction vec3_transformMat3(out, a, m) {\n  var x = a[0],\n    y = a[1],\n    z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nfunction vec3_transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n    qy = q[1],\n    qz = q[2],\n    qw = q[3];\n  var x = a[0],\n    y = a[1],\n    z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n    uvy = qz * x - qx * z,\n    uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n    uuvy = qz * uvx - qx * uvz,\n    uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nfunction vec3_rotateX(out, a, b, rad) {\n  var p = [],\n    r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nfunction vec3_rotateY(out, a, b, rad) {\n  var p = [],\n    r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nfunction vec3_rotateZ(out, a, b, rad) {\n  var p = [],\n    r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nfunction vec3_angle(a, b) {\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    bx = b[0],\n    by = b[1],\n    bz = b[2],\n    mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n    mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n    mag = mag1 * mag2,\n    cosine = mag && vec3_dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nfunction vec3_zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nfunction vec3_str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction vec3_exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction vec3_equals(a, b) {\n  var a0 = a[0],\n    a1 = a[1],\n    a2 = a[2];\n  var b0 = b[0],\n    b1 = b[1],\n    b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nvar vec3_sub = (/* unused pure expression or super */ null && (vec3_subtract));\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nvar vec3_mul = vec3_multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nvar vec3_div = (/* unused pure expression or super */ null && (vec3_divide));\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nvar vec3_dist = (/* unused pure expression or super */ null && (vec3_distance));\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nvar vec3_sqrDist = (/* unused pure expression or super */ null && (vec3_squaredDistance));\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nvar vec3_len = (/* unused pure expression or super */ null && (vec3_length));\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nvar vec3_sqrLen = (/* unused pure expression or super */ null && (vec3_squaredLength));\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nvar vec3_forEach = function () {\n  var vec = vec3_create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n    if (!stride) {\n      stride = 3;\n    }\n    if (!offset) {\n      offset = 0;\n    }\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n    return a;\n  };\n}();\n;// ./node_modules/@math.gl/web-mercator/dist/esm/assert.js\nfunction assert_assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || '@math.gl/web-mercator: assertion failed.');\n  }\n}\n;// ./node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js\n\n\n\n\n\nconst PI = Math.PI;\nconst PI_4 = PI / 4;\nconst DEGREES_TO_RADIANS = PI / 180;\nconst RADIANS_TO_DEGREES = 180 / PI;\nconst TILE_SIZE = 512;\nconst EARTH_CIRCUMFERENCE = 40.03e6;\nconst MAX_LATITUDE = 85.051129;\nconst DEFAULT_ALTITUDE = 1.5;\nfunction zoomToScale(zoom) {\n  return Math.pow(2, zoom);\n}\nfunction scaleToZoom(scale) {\n  return log2(scale);\n}\nfunction lngLatToWorld(lngLat) {\n  const [lng, lat] = lngLat;\n  assert_assert(Number.isFinite(lng));\n  assert_assert(Number.isFinite(lat) && lat >= -90 && lat <= 90, 'invalid latitude');\n  const lambda2 = lng * DEGREES_TO_RADIANS;\n  const phi2 = lat * DEGREES_TO_RADIANS;\n  const x = TILE_SIZE * (lambda2 + PI) / (2 * PI);\n  const y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);\n  return [x, y];\n}\nfunction worldToLngLat(xy) {\n  const [x, y] = xy;\n  const lambda2 = x / TILE_SIZE * (2 * PI) - PI;\n  const phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);\n  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];\n}\nfunction getMeterZoom(options) {\n  const {\n    latitude\n  } = options;\n  assert(Number.isFinite(latitude));\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;\n}\nfunction unitsPerMeter(latitude) {\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;\n}\nfunction getDistanceScales(options) {\n  const {\n    latitude,\n    longitude,\n    highPrecision = false\n  } = options;\n  assert_assert(Number.isFinite(latitude) && Number.isFinite(longitude));\n  const worldSize = TILE_SIZE;\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  const unitsPerDegreeX = worldSize / 360;\n  const unitsPerDegreeY = unitsPerDegreeX / latCosine;\n  const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;\n  const result = {\n    unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],\n    metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],\n    unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],\n    degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]\n  };\n  if (highPrecision) {\n    const latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;\n    const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;\n    const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;\n    const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;\n    result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];\n    result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];\n  }\n  return result;\n}\nfunction addMetersToLngLat(lngLatZ, xyz) {\n  const [longitude, latitude, z0] = lngLatZ;\n  const [x, y, z] = xyz;\n  const {\n    unitsPerMeter,\n    unitsPerMeter2\n  } = getDistanceScales({\n    longitude,\n    latitude,\n    highPrecision: true\n  });\n  const worldspace = lngLatToWorld(lngLatZ);\n  worldspace[0] += x * (unitsPerMeter[0] + unitsPerMeter2[0] * y);\n  worldspace[1] += y * (unitsPerMeter[1] + unitsPerMeter2[1] * y);\n  const newLngLat = worldToLngLat(worldspace);\n  const newZ = (z0 || 0) + (z || 0);\n  return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;\n}\nfunction getViewMatrix(options) {\n  const {\n    height,\n    pitch,\n    bearing,\n    altitude,\n    scale,\n    center\n  } = options;\n  const vm = createMat4();\n  translate(vm, vm, [0, 0, -altitude]);\n  rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);\n  rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);\n  const relativeScale = scale / height;\n  mat4_scale(vm, vm, [relativeScale, relativeScale, relativeScale]);\n  if (center) {\n    translate(vm, vm, vec3_negate([], center));\n  }\n  return vm;\n}\nfunction getProjectionParameters(options) {\n  const {\n    width,\n    height,\n    altitude,\n    pitch = 0,\n    offset,\n    center,\n    scale,\n    nearZMultiplier = 1,\n    farZMultiplier = 1\n  } = options;\n  let {\n    fovy = altitudeToFovy(DEFAULT_ALTITUDE)\n  } = options;\n  if (altitude !== undefined) {\n    fovy = altitudeToFovy(altitude);\n  }\n  const fovRadians = fovy * DEGREES_TO_RADIANS;\n  const pitchRadians = pitch * DEGREES_TO_RADIANS;\n  const focalDistance = fovyToAltitude(fovy);\n  let cameraToSeaLevelDistance = focalDistance;\n  if (center) {\n    cameraToSeaLevelDistance += center[2] * scale / Math.cos(pitchRadians) / height;\n  }\n  const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);\n  const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(clamp(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));\n  const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;\n  const horizonDistance = cameraToSeaLevelDistance * 10;\n  const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);\n  return {\n    fov: fovRadians,\n    aspect: width / height,\n    focalDistance,\n    near: nearZMultiplier,\n    far: farZ\n  };\n}\nfunction getProjectionMatrix(options) {\n  const {\n    fov,\n    aspect,\n    near,\n    far\n  } = getProjectionParameters(options);\n  const projectionMatrix = perspective([], fov, aspect, near, far);\n  return projectionMatrix;\n}\nfunction altitudeToFovy(altitude) {\n  return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES;\n}\nfunction fovyToAltitude(fovy) {\n  return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS);\n}\nfunction worldToPixels(xyz, pixelProjectionMatrix) {\n  const [x, y, z = 0] = xyz;\n  assert_assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));\n  return transformVector(pixelProjectionMatrix, [x, y, z, 1]);\n}\nfunction pixelsToWorld(xyz, pixelUnprojectionMatrix) {\n  let targetZ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const [x, y, z] = xyz;\n  assert_assert(Number.isFinite(x) && Number.isFinite(y), 'invalid pixel coordinate');\n  if (Number.isFinite(z)) {\n    const coord = transformVector(pixelUnprojectionMatrix, [x, y, z, 1]);\n    return coord;\n  }\n  const coord0 = transformVector(pixelUnprojectionMatrix, [x, y, 0, 1]);\n  const coord1 = transformVector(pixelUnprojectionMatrix, [x, y, 1, 1]);\n  const z0 = coord0[2];\n  const z1 = coord1[2];\n  const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);\n  return vec2_lerp([], coord0, coord1, t);\n}\n;// ./node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js\n\n\n\nfunction fitBounds(options) {\n  const {\n    width,\n    height,\n    bounds,\n    minExtent = 0,\n    maxZoom = 24,\n    offset = [0, 0]\n  } = options;\n  const [[west, south], [east, north]] = bounds;\n  const padding = getPaddingObject(options.padding);\n  const nw = lngLatToWorld([west, clamp(north, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const se = lngLatToWorld([east, clamp(south, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];\n  const targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];\n  assert_assert(targetSize[0] > 0 && targetSize[1] > 0);\n  const scaleX = targetSize[0] / size[0];\n  const scaleY = targetSize[1] / size[1];\n  const offsetX = (padding.right - padding.left) / 2 / scaleX;\n  const offsetY = (padding.top - padding.bottom) / 2 / scaleY;\n  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n  const centerLngLat = worldToLngLat(center);\n  const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));\n  assert_assert(Number.isFinite(zoom));\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom\n  };\n}\nfunction getPaddingObject() {\n  let padding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  if (typeof padding === 'number') {\n    return {\n      top: padding,\n      bottom: padding,\n      left: padding,\n      right: padding\n    };\n  }\n  assert_assert(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));\n  return padding;\n}\n;// ./node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js\n\n\n\nconst get_bounds_DEGREES_TO_RADIANS = Math.PI / 180;\nfunction getBounds(viewport) {\n  let z = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const {\n    width,\n    height,\n    unproject\n  } = viewport;\n  const unprojectOps = {\n    targetZ: z\n  };\n  const bottomLeft = unproject([0, height], unprojectOps);\n  const bottomRight = unproject([width, height], unprojectOps);\n  let topLeft;\n  let topRight;\n  const halfFov = viewport.fovy ? 0.5 * viewport.fovy * get_bounds_DEGREES_TO_RADIANS : Math.atan(0.5 / viewport.altitude);\n  const angleToGround = (90 - viewport.pitch) * get_bounds_DEGREES_TO_RADIANS;\n  if (halfFov > angleToGround - 0.01) {\n    topLeft = unprojectOnFarPlane(viewport, 0, z);\n    topRight = unprojectOnFarPlane(viewport, width, z);\n  } else {\n    topLeft = unproject([0, 0], unprojectOps);\n    topRight = unproject([width, 0], unprojectOps);\n  }\n  return [bottomLeft, bottomRight, topRight, topLeft];\n}\nfunction unprojectOnFarPlane(viewport, x, targetZ) {\n  const {\n    pixelUnprojectionMatrix\n  } = viewport;\n  const coord0 = transformVector(pixelUnprojectionMatrix, [x, 0, 1, 1]);\n  const coord1 = transformVector(pixelUnprojectionMatrix, [x, viewport.height, 1, 1]);\n  const z = targetZ * viewport.distanceScales.unitsPerMeter[2];\n  const t = (z - coord0[2]) / (coord1[2] - coord0[2]);\n  const coord = vec2_lerp([], coord0, coord1, t);\n  const result = worldToLngLat(coord);\n  result.push(targetZ);\n  return result;\n}\n;// ./node_modules/@math.gl/web-mercator/dist/esm/web-mercator-viewport.js\n\n\n\n\n\n\n\n\nclass WebMercatorViewport {\n  constructor() {\n    var _this = this;\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      width: 1,\n      height: 1\n    };\n    _defineProperty(this, \"latitude\", void 0);\n    _defineProperty(this, \"longitude\", void 0);\n    _defineProperty(this, \"zoom\", void 0);\n    _defineProperty(this, \"pitch\", void 0);\n    _defineProperty(this, \"bearing\", void 0);\n    _defineProperty(this, \"altitude\", void 0);\n    _defineProperty(this, \"fovy\", void 0);\n    _defineProperty(this, \"meterOffset\", void 0);\n    _defineProperty(this, \"center\", void 0);\n    _defineProperty(this, \"width\", void 0);\n    _defineProperty(this, \"height\", void 0);\n    _defineProperty(this, \"scale\", void 0);\n    _defineProperty(this, \"distanceScales\", void 0);\n    _defineProperty(this, \"viewMatrix\", void 0);\n    _defineProperty(this, \"projectionMatrix\", void 0);\n    _defineProperty(this, \"viewProjectionMatrix\", void 0);\n    _defineProperty(this, \"pixelProjectionMatrix\", void 0);\n    _defineProperty(this, \"pixelUnprojectionMatrix\", void 0);\n    _defineProperty(this, \"equals\", viewport => {\n      if (!(viewport instanceof WebMercatorViewport)) {\n        return false;\n      }\n      return viewport.width === this.width && viewport.height === this.height && mat4_equals(viewport.projectionMatrix, this.projectionMatrix) && mat4_equals(viewport.viewMatrix, this.viewMatrix);\n    });\n    _defineProperty(this, \"project\", function (lngLatZ) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        topLeft = true\n      } = options;\n      const worldPosition = _this.projectPosition(lngLatZ);\n      const coord = worldToPixels(worldPosition, _this.pixelProjectionMatrix);\n      const [x, y] = coord;\n      const y2 = topLeft ? y : _this.height - y;\n      return lngLatZ.length === 2 ? [x, y2] : [x, y2, coord[2]];\n    });\n    _defineProperty(this, \"unproject\", function (xyz) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        topLeft = true,\n        targetZ = undefined\n      } = options;\n      const [x, y, z] = xyz;\n      const y2 = topLeft ? y : _this.height - y;\n      const targetZWorld = targetZ && targetZ * _this.distanceScales.unitsPerMeter[2];\n      const coord = pixelsToWorld([x, y2, z], _this.pixelUnprojectionMatrix, targetZWorld);\n      const [X, Y, Z] = _this.unprojectPosition(coord);\n      if (Number.isFinite(z)) {\n        return [X, Y, Z];\n      }\n      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n    });\n    _defineProperty(this, \"projectPosition\", xyz => {\n      const [X, Y] = lngLatToWorld(xyz);\n      const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n      return [X, Y, Z];\n    });\n    _defineProperty(this, \"unprojectPosition\", xyz => {\n      const [X, Y] = worldToLngLat(xyz);\n      const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n      return [X, Y, Z];\n    });\n    let {\n      width,\n      height,\n      altitude = null,\n      fovy = null\n    } = props;\n    const {\n      latitude = 0,\n      longitude = 0,\n      zoom = 0,\n      pitch = 0,\n      bearing = 0,\n      position = null,\n      nearZMultiplier = 0.02,\n      farZMultiplier = 1.01\n    } = props;\n    width = width || 1;\n    height = height || 1;\n    if (fovy === null && altitude === null) {\n      altitude = DEFAULT_ALTITUDE;\n      fovy = altitudeToFovy(altitude);\n    } else if (fovy === null) {\n      fovy = altitudeToFovy(altitude);\n    } else if (altitude === null) {\n      altitude = fovyToAltitude(fovy);\n    }\n    const scale = zoomToScale(zoom);\n    altitude = Math.max(0.75, altitude);\n    const distanceScales = getDistanceScales({\n      longitude,\n      latitude\n    });\n    const center = lngLatToWorld([longitude, latitude]);\n    center.push(0);\n    if (position) {\n      vec3_add(center, center, vec3_mul([], position, distanceScales.unitsPerMeter));\n    }\n    this.projectionMatrix = getProjectionMatrix({\n      width,\n      height,\n      scale,\n      center,\n      pitch,\n      fovy,\n      nearZMultiplier,\n      farZMultiplier\n    });\n    this.viewMatrix = getViewMatrix({\n      height,\n      scale,\n      center,\n      pitch,\n      bearing,\n      altitude\n    });\n    this.width = width;\n    this.height = height;\n    this.scale = scale;\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.zoom = zoom;\n    this.pitch = pitch;\n    this.bearing = bearing;\n    this.altitude = altitude;\n    this.fovy = fovy;\n    this.center = center;\n    this.meterOffset = position || [0, 0, 0];\n    this.distanceScales = distanceScales;\n    this._initMatrices();\n    Object.freeze(this);\n  }\n  _initMatrices() {\n    const {\n      width,\n      height,\n      projectionMatrix,\n      viewMatrix\n    } = this;\n    const vpm = createMat4();\n    mat4_multiply(vpm, vpm, projectionMatrix);\n    mat4_multiply(vpm, vpm, viewMatrix);\n    this.viewProjectionMatrix = vpm;\n    const m = createMat4();\n    mat4_scale(m, m, [width / 2, -height / 2, 1]);\n    translate(m, m, [1, -1, 0]);\n    mat4_multiply(m, m, vpm);\n    const mInverse = invert(createMat4(), m);\n    if (!mInverse) {\n      throw new Error('Pixel project matrix not invertible');\n    }\n    this.pixelProjectionMatrix = m;\n    this.pixelUnprojectionMatrix = mInverse;\n  }\n  projectFlat(lngLat) {\n    return lngLatToWorld(lngLat);\n  }\n  unprojectFlat(xy) {\n    return worldToLngLat(xy);\n  }\n  getMapCenterByLngLatPosition(_ref) {\n    let {\n      lngLat,\n      pos\n    } = _ref;\n    const fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);\n    const toLocation = lngLatToWorld(lngLat);\n    const translate = vec2_add([], toLocation, vec2_negate([], fromLocation));\n    const newCenter = vec2_add([], this.center, translate);\n    return worldToLngLat(newCenter);\n  }\n  fitBounds(bounds) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      width,\n      height\n    } = this;\n    const {\n      longitude,\n      latitude,\n      zoom\n    } = fitBounds(Object.assign({\n      width,\n      height,\n      bounds\n    }, options));\n    return new WebMercatorViewport({\n      width,\n      height,\n      longitude,\n      latitude,\n      zoom\n    });\n  }\n  getBounds(options) {\n    const corners = this.getBoundingRegion(options);\n    const west = Math.min(...corners.map(p => p[0]));\n    const east = Math.max(...corners.map(p => p[0]));\n    const south = Math.min(...corners.map(p => p[1]));\n    const north = Math.max(...corners.map(p => p[1]));\n    return [[west, south], [east, north]];\n  }\n  getBoundingRegion() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return getBounds(this, options.z || 0);\n  }\n  getLocationAtPoint(_ref2) {\n    let {\n      lngLat,\n      pos\n    } = _ref2;\n    return this.getMapCenterByLngLatPosition({\n      lngLat,\n      pos\n    });\n  }\n}\n;// ./node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js\n\n\nconst normalize_viewport_props_TILE_SIZE = 512;\nfunction normalizeViewportProps(props) {\n  const {\n    width,\n    height,\n    pitch = 0\n  } = props;\n  let {\n    longitude,\n    latitude,\n    zoom,\n    bearing = 0\n  } = props;\n  if (longitude < -180 || longitude > 180) {\n    longitude = mod(longitude + 180, 360) - 180;\n  }\n  if (bearing < -180 || bearing > 180) {\n    bearing = mod(bearing + 180, 360) - 180;\n  }\n  const minZoom = log2(height / normalize_viewport_props_TILE_SIZE);\n  if (zoom <= minZoom) {\n    zoom = minZoom;\n    latitude = 0;\n  } else {\n    const halfHeightPixels = height / 2 / Math.pow(2, zoom);\n    const minLatitude = worldToLngLat([0, halfHeightPixels])[1];\n    if (latitude < minLatitude) {\n      latitude = minLatitude;\n    } else {\n      const maxLatitude = worldToLngLat([0, normalize_viewport_props_TILE_SIZE - halfHeightPixels])[1];\n      if (latitude > maxLatitude) {\n        latitude = maxLatitude;\n      }\n    }\n  }\n  return {\n    width,\n    height,\n    longitude,\n    latitude,\n    zoom,\n    pitch,\n    bearing\n  };\n}\n;// ./node_modules/@math.gl/web-mercator/dist/esm/fly-to-viewport.js\n\n\n\nconst fly_to_viewport_EPSILON = 0.01;\nconst VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];\nconst DEFAULT_OPTS = {\n  curve: 1.414,\n  speed: 1.2\n};\nfunction flyToViewport(startProps, endProps, t, options) {\n  const {\n    startZoom,\n    startCenterXY,\n    uDelta,\n    w0,\n    u1,\n    S,\n    rho,\n    rho2,\n    r0\n  } = getFlyToTransitionParams(startProps, endProps, options);\n  if (u1 < fly_to_viewport_EPSILON) {\n    const viewport = {};\n    for (const key of VIEWPORT_TRANSITION_PROPS) {\n      const startValue = startProps[key];\n      const endValue = endProps[key];\n      viewport[key] = math_utils_lerp(startValue, endValue, t);\n    }\n    return viewport;\n  }\n  const s = t * S;\n  const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n  const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;\n  const scaleIncrement = 1 / w;\n  const newZoom = startZoom + scaleToZoom(scaleIncrement);\n  const newCenterWorld = vec2_scale([], uDelta, u);\n  vec2_add(newCenterWorld, newCenterWorld, startCenterXY);\n  const newCenter = worldToLngLat(newCenterWorld);\n  return {\n    longitude: newCenter[0],\n    latitude: newCenter[1],\n    zoom: newZoom\n  };\n}\nfunction getFlyToDuration(startProps, endProps, options) {\n  const opts = {\n    ...DEFAULT_OPTS,\n    ...options\n  };\n  const {\n    screenSpeed,\n    speed,\n    maxDuration\n  } = opts;\n  const {\n    S,\n    rho\n  } = getFlyToTransitionParams(startProps, endProps, opts);\n  const length = 1000 * S;\n  let duration;\n  if (Number.isFinite(screenSpeed)) {\n    duration = length / (screenSpeed / rho);\n  } else {\n    duration = length / speed;\n  }\n  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;\n}\nfunction getFlyToTransitionParams(startProps, endProps, opts) {\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  const rho = opts.curve;\n  const startZoom = startProps.zoom;\n  const startCenter = [startProps.longitude, startProps.latitude];\n  const startScale = zoomToScale(startZoom);\n  const endZoom = endProps.zoom;\n  const endCenter = [endProps.longitude, endProps.latitude];\n  const scale = zoomToScale(endZoom - startZoom);\n  const startCenterXY = lngLatToWorld(startCenter);\n  const endCenterXY = lngLatToWorld(endCenter);\n  const uDelta = vec2_sub([], endCenterXY, startCenterXY);\n  const w0 = Math.max(startProps.width, startProps.height);\n  const w1 = w0 / scale;\n  const u1 = vec2_length(uDelta) * startScale;\n  const _u1 = Math.max(u1, fly_to_viewport_EPSILON);\n  const rho2 = rho * rho;\n  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);\n  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);\n  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  const S = (r1 - r0) / rho;\n  return {\n    startZoom,\n    startCenterXY,\n    uDelta,\n    w0,\n    u1,\n    S,\n    rho,\n    rho2,\n    r0,\n    r1\n  };\n}\n;// ./node_modules/@math.gl/web-mercator/dist/esm/index.js\n\n\n\n\n\n\n\n;// ./node_modules/viewport-mercator-project/module.js\n\n\n;// ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\n/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\n/* eslint-disable require-jsdoc, valid-jsdoc */\nvar MapShim = function () {\n  if (typeof Map !== 'undefined') {\n    return Map;\n  }\n  /**\r\n   * Returns index in provided array that matches the specified key.\r\n   *\r\n   * @param {Array<Array>} arr\r\n   * @param {*} key\r\n   * @returns {number}\r\n   */\n  function getIndex(arr, key) {\n    var result = -1;\n    arr.some(function (entry, index) {\n      if (entry[0] === key) {\n        result = index;\n        return true;\n      }\n      return false;\n    });\n    return result;\n  }\n  return /** @class */function () {\n    function class_1() {\n      this.__entries__ = [];\n    }\n    Object.defineProperty(class_1.prototype, \"size\", {\n      /**\r\n       * @returns {boolean}\r\n       */\n      get: function () {\n        return this.__entries__.length;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    /**\r\n     * @param {*} key\r\n     * @returns {*}\r\n     */\n    class_1.prototype.get = function (key) {\n      var index = getIndex(this.__entries__, key);\n      var entry = this.__entries__[index];\n      return entry && entry[1];\n    };\n    /**\r\n     * @param {*} key\r\n     * @param {*} value\r\n     * @returns {void}\r\n     */\n    class_1.prototype.set = function (key, value) {\n      var index = getIndex(this.__entries__, key);\n      if (~index) {\n        this.__entries__[index][1] = value;\n      } else {\n        this.__entries__.push([key, value]);\n      }\n    };\n    /**\r\n     * @param {*} key\r\n     * @returns {void}\r\n     */\n    class_1.prototype.delete = function (key) {\n      var entries = this.__entries__;\n      var index = getIndex(entries, key);\n      if (~index) {\n        entries.splice(index, 1);\n      }\n    };\n    /**\r\n     * @param {*} key\r\n     * @returns {void}\r\n     */\n    class_1.prototype.has = function (key) {\n      return !!~getIndex(this.__entries__, key);\n    };\n    /**\r\n     * @returns {void}\r\n     */\n    class_1.prototype.clear = function () {\n      this.__entries__.splice(0);\n    };\n    /**\r\n     * @param {Function} callback\r\n     * @param {*} [ctx=null]\r\n     * @returns {void}\r\n     */\n    class_1.prototype.forEach = function (callback, ctx) {\n      if (ctx === void 0) {\n        ctx = null;\n      }\n      for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\n        var entry = _a[_i];\n        callback.call(ctx, entry[1], entry[0]);\n      }\n    };\n    return class_1;\n  }();\n}();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\nvar global$1 = function () {\n  if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.Math === Math) {\n    return __webpack_require__.g;\n  }\n  if (typeof self !== 'undefined' && self.Math === Math) {\n    return self;\n  }\n  if (typeof window !== 'undefined' && window.Math === Math) {\n    return window;\n  }\n  // eslint-disable-next-line no-new-func\n  return Function('return this')();\n}();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\nvar requestAnimationFrame$1 = function () {\n  if (typeof requestAnimationFrame === 'function') {\n    // It's required to use a bounded function because IE sometimes throws\n    // an \"Invalid calling object\" error if rAF is invoked without the global\n    // object on the left hand side.\n    return requestAnimationFrame.bind(global$1);\n  }\n  return function (callback) {\n    return setTimeout(function () {\n      return callback(Date.now());\n    }, 1000 / 60);\n  };\n}();\n\n// Defines minimum timeout before adding a trailing call.\nvar trailingTimeout = 2;\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\nfunction throttle(callback, delay) {\n  var leadingCall = false,\n    trailingCall = false,\n    lastCallTime = 0;\n  /**\r\n   * Invokes the original callback function and schedules new invocation if\r\n   * the \"proxy\" was called during current request.\r\n   *\r\n   * @returns {void}\r\n   */\n  function resolvePending() {\n    if (leadingCall) {\n      leadingCall = false;\n      callback();\n    }\n    if (trailingCall) {\n      proxy();\n    }\n  }\n  /**\r\n   * Callback invoked after the specified delay. It will further postpone\r\n   * invocation of the original function delegating it to the\r\n   * requestAnimationFrame.\r\n   *\r\n   * @returns {void}\r\n   */\n  function timeoutCallback() {\n    requestAnimationFrame$1(resolvePending);\n  }\n  /**\r\n   * Schedules invocation of the original function.\r\n   *\r\n   * @returns {void}\r\n   */\n  function proxy() {\n    var timeStamp = Date.now();\n    if (leadingCall) {\n      // Reject immediately following calls.\n      if (timeStamp - lastCallTime < trailingTimeout) {\n        return;\n      }\n      // Schedule new call to be in invoked when the pending one is resolved.\n      // This is important for \"transitions\" which never actually start\n      // immediately so there is a chance that we might miss one if change\n      // happens amids the pending invocation.\n      trailingCall = true;\n    } else {\n      leadingCall = true;\n      trailingCall = false;\n      setTimeout(timeoutCallback, delay);\n    }\n    lastCallTime = timeStamp;\n  }\n  return proxy;\n}\n\n// Minimum delay before invoking the update of observers.\nvar REFRESH_DELAY = 20;\n// A list of substrings of CSS properties used to find transition events that\n// might affect dimensions of observed elements.\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\n// Check if MutationObserver is available.\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\nvar ResizeObserverController = /** @class */function () {\n  /**\r\n   * Creates a new instance of ResizeObserverController.\r\n   *\r\n   * @private\r\n   */\n  function ResizeObserverController() {\n    /**\r\n     * Indicates whether DOM listeners have been added.\r\n     *\r\n     * @private {boolean}\r\n     */\n    this.connected_ = false;\n    /**\r\n     * Tells that controller has subscribed for Mutation Events.\r\n     *\r\n     * @private {boolean}\r\n     */\n    this.mutationEventsAdded_ = false;\n    /**\r\n     * Keeps reference to the instance of MutationObserver.\r\n     *\r\n     * @private {MutationObserver}\r\n     */\n    this.mutationsObserver_ = null;\n    /**\r\n     * A list of connected observers.\r\n     *\r\n     * @private {Array<ResizeObserverSPI>}\r\n     */\n    this.observers_ = [];\n    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\n    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\n  }\n  /**\r\n   * Adds observer to observers list.\r\n   *\r\n   * @param {ResizeObserverSPI} observer - Observer to be added.\r\n   * @returns {void}\r\n   */\n  ResizeObserverController.prototype.addObserver = function (observer) {\n    if (!~this.observers_.indexOf(observer)) {\n      this.observers_.push(observer);\n    }\n    // Add listeners if they haven't been added yet.\n    if (!this.connected_) {\n      this.connect_();\n    }\n  };\n  /**\r\n   * Removes observer from observers list.\r\n   *\r\n   * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n   * @returns {void}\r\n   */\n  ResizeObserverController.prototype.removeObserver = function (observer) {\n    var observers = this.observers_;\n    var index = observers.indexOf(observer);\n    // Remove observer if it's present in registry.\n    if (~index) {\n      observers.splice(index, 1);\n    }\n    // Remove listeners if controller has no connected observers.\n    if (!observers.length && this.connected_) {\n      this.disconnect_();\n    }\n  };\n  /**\r\n   * Invokes the update of observers. It will continue running updates insofar\r\n   * it detects changes.\r\n   *\r\n   * @returns {void}\r\n   */\n  ResizeObserverController.prototype.refresh = function () {\n    var changesDetected = this.updateObservers_();\n    // Continue running updates if changes have been detected as there might\n    // be future ones caused by CSS transitions.\n    if (changesDetected) {\n      this.refresh();\n    }\n  };\n  /**\r\n   * Updates every observer from observers list and notifies them of queued\r\n   * entries.\r\n   *\r\n   * @private\r\n   * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n   *      dimensions of it's elements.\r\n   */\n  ResizeObserverController.prototype.updateObservers_ = function () {\n    // Collect observers that have active observations.\n    var activeObservers = this.observers_.filter(function (observer) {\n      return observer.gatherActive(), observer.hasActive();\n    });\n    // Deliver notifications in a separate cycle in order to avoid any\n    // collisions between observers, e.g. when multiple instances of\n    // ResizeObserver are tracking the same element and the callback of one\n    // of them changes content dimensions of the observed target. Sometimes\n    // this may result in notifications being blocked for the rest of observers.\n    activeObservers.forEach(function (observer) {\n      return observer.broadcastActive();\n    });\n    return activeObservers.length > 0;\n  };\n  /**\r\n   * Initializes DOM listeners.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\n  ResizeObserverController.prototype.connect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already added.\n    if (!isBrowser || this.connected_) {\n      return;\n    }\n    // Subscription to the \"Transitionend\" event is used as a workaround for\n    // delayed transitions. This way it's possible to capture at least the\n    // final state of an element.\n    document.addEventListener('transitionend', this.onTransitionEnd_);\n    window.addEventListener('resize', this.refresh);\n    if (mutationObserverSupported) {\n      this.mutationsObserver_ = new MutationObserver(this.refresh);\n      this.mutationsObserver_.observe(document, {\n        attributes: true,\n        childList: true,\n        characterData: true,\n        subtree: true\n      });\n    } else {\n      document.addEventListener('DOMSubtreeModified', this.refresh);\n      this.mutationEventsAdded_ = true;\n    }\n    this.connected_ = true;\n  };\n  /**\r\n   * Removes DOM listeners.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\n  ResizeObserverController.prototype.disconnect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already removed.\n    if (!isBrowser || !this.connected_) {\n      return;\n    }\n    document.removeEventListener('transitionend', this.onTransitionEnd_);\n    window.removeEventListener('resize', this.refresh);\n    if (this.mutationsObserver_) {\n      this.mutationsObserver_.disconnect();\n    }\n    if (this.mutationEventsAdded_) {\n      document.removeEventListener('DOMSubtreeModified', this.refresh);\n    }\n    this.mutationsObserver_ = null;\n    this.mutationEventsAdded_ = false;\n    this.connected_ = false;\n  };\n  /**\r\n   * \"Transitionend\" event handler.\r\n   *\r\n   * @private\r\n   * @param {TransitionEvent} event\r\n   * @returns {void}\r\n   */\n  ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\n    var _b = _a.propertyName,\n      propertyName = _b === void 0 ? '' : _b;\n    // Detect whether transition may affect dimensions of an element.\n    var isReflowProperty = transitionKeys.some(function (key) {\n      return !!~propertyName.indexOf(key);\n    });\n    if (isReflowProperty) {\n      this.refresh();\n    }\n  };\n  /**\r\n   * Returns instance of the ResizeObserverController.\r\n   *\r\n   * @returns {ResizeObserverController}\r\n   */\n  ResizeObserverController.getInstance = function () {\n    if (!this.instance_) {\n      this.instance_ = new ResizeObserverController();\n    }\n    return this.instance_;\n  };\n  /**\r\n   * Holds reference to the controller's instance.\r\n   *\r\n   * @private {ResizeObserverController}\r\n   */\n  ResizeObserverController.instance_ = null;\n  return ResizeObserverController;\n}();\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\nvar defineConfigurable = function (target, props) {\n  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\n    var key = _a[_i];\n    Object.defineProperty(target, key, {\n      value: props[key],\n      enumerable: false,\n      writable: false,\n      configurable: true\n    });\n  }\n  return target;\n};\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\nvar getWindowOf = function (target) {\n  // Assume that the element is an instance of Node, which means that it\n  // has the \"ownerDocument\" property from which we can retrieve a\n  // corresponding global object.\n  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\n  // Return the local global object if it's not possible extract one from\n  // provided element.\n  return ownerGlobal || global$1;\n};\n\n// Placeholder of an empty content rectangle.\nvar emptyRect = createRectInit(0, 0, 0, 0);\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\nfunction toFloat(value) {\n  return parseFloat(value) || 0;\n}\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\nfunction getBordersSize(styles) {\n  var positions = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    positions[_i - 1] = arguments[_i];\n  }\n  return positions.reduce(function (size, position) {\n    var value = styles['border-' + position + '-width'];\n    return size + toFloat(value);\n  }, 0);\n}\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\nfunction getPaddings(styles) {\n  var positions = ['top', 'right', 'bottom', 'left'];\n  var paddings = {};\n  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\n    var position = positions_1[_i];\n    var value = styles['padding-' + position];\n    paddings[position] = toFloat(value);\n  }\n  return paddings;\n}\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\nfunction getSVGContentRect(target) {\n  var bbox = target.getBBox();\n  return createRectInit(0, 0, bbox.width, bbox.height);\n}\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\nfunction getHTMLElementContentRect(target) {\n  // Client width & height properties can't be\n  // used exclusively as they provide rounded values.\n  var clientWidth = target.clientWidth,\n    clientHeight = target.clientHeight;\n  // By this condition we can catch all non-replaced inline, hidden and\n  // detached elements. Though elements with width & height properties less\n  // than 0.5 will be discarded as well.\n  //\n  // Without it we would need to implement separate methods for each of\n  // those cases and it's not possible to perform a precise and performance\n  // effective test for hidden elements. E.g. even jQuery's ':visible' filter\n  // gives wrong results for elements with width & height less than 0.5.\n  if (!clientWidth && !clientHeight) {\n    return emptyRect;\n  }\n  var styles = getWindowOf(target).getComputedStyle(target);\n  var paddings = getPaddings(styles);\n  var horizPad = paddings.left + paddings.right;\n  var vertPad = paddings.top + paddings.bottom;\n  // Computed styles of width & height are being used because they are the\n  // only dimensions available to JS that contain non-rounded values. It could\n  // be possible to utilize the getBoundingClientRect if only it's data wasn't\n  // affected by CSS transformations let alone paddings, borders and scroll bars.\n  var width = toFloat(styles.width),\n    height = toFloat(styles.height);\n  // Width & height include paddings and borders when the 'border-box' box\n  // model is applied (except for IE).\n  if (styles.boxSizing === 'border-box') {\n    // Following conditions are required to handle Internet Explorer which\n    // doesn't include paddings and borders to computed CSS dimensions.\n    //\n    // We can say that if CSS dimensions + paddings are equal to the \"client\"\n    // properties then it's either IE, and thus we don't need to subtract\n    // anything, or an element merely doesn't have paddings/borders styles.\n    if (Math.round(width + horizPad) !== clientWidth) {\n      width -= getBordersSize(styles, 'left', 'right') + horizPad;\n    }\n    if (Math.round(height + vertPad) !== clientHeight) {\n      height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\n    }\n  }\n  // Following steps can't be applied to the document's root element as its\n  // client[Width/Height] properties represent viewport area of the window.\n  // Besides, it's as well not necessary as the <html> itself neither has\n  // rendered scroll bars nor it can be clipped.\n  if (!isDocumentElement(target)) {\n    // In some browsers (only in Firefox, actually) CSS width & height\n    // include scroll bars size which can be removed at this step as scroll\n    // bars are the only difference between rounded dimensions + paddings\n    // and \"client\" properties, though that is not always true in Chrome.\n    var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n    var horizScrollbar = Math.round(height + vertPad) - clientHeight;\n    // Chrome has a rather weird rounding of \"client\" properties.\n    // E.g. for an element with content width of 314.2px it sometimes gives\n    // the client width of 315px and for the width of 314.7px it may give\n    // 314px. And it doesn't happen all the time. So just ignore this delta\n    // as a non-relevant.\n    if (Math.abs(vertScrollbar) !== 1) {\n      width -= vertScrollbar;\n    }\n    if (Math.abs(horizScrollbar) !== 1) {\n      height -= horizScrollbar;\n    }\n  }\n  return createRectInit(paddings.left, paddings.top, width, height);\n}\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\nvar isSVGGraphicsElement = function () {\n  // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\n  // interface.\n  if (typeof SVGGraphicsElement !== 'undefined') {\n    return function (target) {\n      return target instanceof getWindowOf(target).SVGGraphicsElement;\n    };\n  }\n  // If it's so, then check that element is at least an instance of the\n  // SVGElement and that it has the \"getBBox\" method.\n  // eslint-disable-next-line no-extra-parens\n  return function (target) {\n    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';\n  };\n}();\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\nfunction isDocumentElement(target) {\n  return target === getWindowOf(target).document.documentElement;\n}\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\nfunction getContentRect(target) {\n  if (!isBrowser) {\n    return emptyRect;\n  }\n  if (isSVGGraphicsElement(target)) {\n    return getSVGContentRect(target);\n  }\n  return getHTMLElementContentRect(target);\n}\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\nfunction createReadOnlyRect(_a) {\n  var x = _a.x,\n    y = _a.y,\n    width = _a.width,\n    height = _a.height;\n  // If DOMRectReadOnly is available use it as a prototype for the rectangle.\n  var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\n  var rect = Object.create(Constr.prototype);\n  // Rectangle's properties are not writable and non-enumerable.\n  defineConfigurable(rect, {\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    top: y,\n    right: x + width,\n    bottom: height + y,\n    left: x\n  });\n  return rect;\n}\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\nfunction createRectInit(x, y, width, height) {\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height\n  };\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\nvar ResizeObservation = /** @class */function () {\n  /**\r\n   * Creates an instance of ResizeObservation.\r\n   *\r\n   * @param {Element} target - Element to be observed.\r\n   */\n  function ResizeObservation(target) {\n    /**\r\n     * Broadcasted width of content rectangle.\r\n     *\r\n     * @type {number}\r\n     */\n    this.broadcastWidth = 0;\n    /**\r\n     * Broadcasted height of content rectangle.\r\n     *\r\n     * @type {number}\r\n     */\n    this.broadcastHeight = 0;\n    /**\r\n     * Reference to the last observed content rectangle.\r\n     *\r\n     * @private {DOMRectInit}\r\n     */\n    this.contentRect_ = createRectInit(0, 0, 0, 0);\n    this.target = target;\n  }\n  /**\r\n   * Updates content rectangle and tells whether it's width or height properties\r\n   * have changed since the last broadcast.\r\n   *\r\n   * @returns {boolean}\r\n   */\n  ResizeObservation.prototype.isActive = function () {\n    var rect = getContentRect(this.target);\n    this.contentRect_ = rect;\n    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\n  };\n  /**\r\n   * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n   * from the corresponding properties of the last observed content rectangle.\r\n   *\r\n   * @returns {DOMRectInit} Last observed content rectangle.\r\n   */\n  ResizeObservation.prototype.broadcastRect = function () {\n    var rect = this.contentRect_;\n    this.broadcastWidth = rect.width;\n    this.broadcastHeight = rect.height;\n    return rect;\n  };\n  return ResizeObservation;\n}();\nvar ResizeObserverEntry = /** @class */function () {\n  /**\r\n   * Creates an instance of ResizeObserverEntry.\r\n   *\r\n   * @param {Element} target - Element that is being observed.\r\n   * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n   */\n  function ResizeObserverEntry(target, rectInit) {\n    var contentRect = createReadOnlyRect(rectInit);\n    // According to the specification following properties are not writable\n    // and are also not enumerable in the native implementation.\n    //\n    // Property accessors are not being used as they'd require to define a\n    // private WeakMap storage which may cause memory leaks in browsers that\n    // don't support this type of collections.\n    defineConfigurable(this, {\n      target: target,\n      contentRect: contentRect\n    });\n  }\n  return ResizeObserverEntry;\n}();\nvar ResizeObserverSPI = /** @class */function () {\n  /**\r\n   * Creates a new instance of ResizeObserver.\r\n   *\r\n   * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n   *      when one of the observed elements changes it's content dimensions.\r\n   * @param {ResizeObserverController} controller - Controller instance which\r\n   *      is responsible for the updates of observer.\r\n   * @param {ResizeObserver} callbackCtx - Reference to the public\r\n   *      ResizeObserver instance which will be passed to callback function.\r\n   */\n  function ResizeObserverSPI(callback, controller, callbackCtx) {\n    /**\r\n     * Collection of resize observations that have detected changes in dimensions\r\n     * of elements.\r\n     *\r\n     * @private {Array<ResizeObservation>}\r\n     */\n    this.activeObservations_ = [];\n    /**\r\n     * Registry of the ResizeObservation instances.\r\n     *\r\n     * @private {Map<Element, ResizeObservation>}\r\n     */\n    this.observations_ = new MapShim();\n    if (typeof callback !== 'function') {\n      throw new TypeError('The callback provided as parameter 1 is not a function.');\n    }\n    this.callback_ = callback;\n    this.controller_ = controller;\n    this.callbackCtx_ = callbackCtx;\n  }\n  /**\r\n   * Starts observing provided element.\r\n   *\r\n   * @param {Element} target - Element to be observed.\r\n   * @returns {void}\r\n   */\n  ResizeObserverSPI.prototype.observe = function (target) {\n    if (!arguments.length) {\n      throw new TypeError('1 argument required, but only 0 present.');\n    }\n    // Do nothing if current environment doesn't have the Element interface.\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n      return;\n    }\n    if (!(target instanceof getWindowOf(target).Element)) {\n      throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n    var observations = this.observations_;\n    // Do nothing if element is already being observed.\n    if (observations.has(target)) {\n      return;\n    }\n    observations.set(target, new ResizeObservation(target));\n    this.controller_.addObserver(this);\n    // Force the update of observations.\n    this.controller_.refresh();\n  };\n  /**\r\n   * Stops observing provided element.\r\n   *\r\n   * @param {Element} target - Element to stop observing.\r\n   * @returns {void}\r\n   */\n  ResizeObserverSPI.prototype.unobserve = function (target) {\n    if (!arguments.length) {\n      throw new TypeError('1 argument required, but only 0 present.');\n    }\n    // Do nothing if current environment doesn't have the Element interface.\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n      return;\n    }\n    if (!(target instanceof getWindowOf(target).Element)) {\n      throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n    var observations = this.observations_;\n    // Do nothing if element is not being observed.\n    if (!observations.has(target)) {\n      return;\n    }\n    observations.delete(target);\n    if (!observations.size) {\n      this.controller_.removeObserver(this);\n    }\n  };\n  /**\r\n   * Stops observing all elements.\r\n   *\r\n   * @returns {void}\r\n   */\n  ResizeObserverSPI.prototype.disconnect = function () {\n    this.clearActive();\n    this.observations_.clear();\n    this.controller_.removeObserver(this);\n  };\n  /**\r\n   * Collects observation instances the associated element of which has changed\r\n   * it's content rectangle.\r\n   *\r\n   * @returns {void}\r\n   */\n  ResizeObserverSPI.prototype.gatherActive = function () {\n    var _this = this;\n    this.clearActive();\n    this.observations_.forEach(function (observation) {\n      if (observation.isActive()) {\n        _this.activeObservations_.push(observation);\n      }\n    });\n  };\n  /**\r\n   * Invokes initial callback function with a list of ResizeObserverEntry\r\n   * instances collected from active resize observations.\r\n   *\r\n   * @returns {void}\r\n   */\n  ResizeObserverSPI.prototype.broadcastActive = function () {\n    // Do nothing if observer doesn't have active observations.\n    if (!this.hasActive()) {\n      return;\n    }\n    var ctx = this.callbackCtx_;\n    // Create ResizeObserverEntry instance for every active observation.\n    var entries = this.activeObservations_.map(function (observation) {\n      return new ResizeObserverEntry(observation.target, observation.broadcastRect());\n    });\n    this.callback_.call(ctx, entries, ctx);\n    this.clearActive();\n  };\n  /**\r\n   * Clears the collection of active observations.\r\n   *\r\n   * @returns {void}\r\n   */\n  ResizeObserverSPI.prototype.clearActive = function () {\n    this.activeObservations_.splice(0);\n  };\n  /**\r\n   * Tells whether observer has active observations.\r\n   *\r\n   * @returns {boolean}\r\n   */\n  ResizeObserverSPI.prototype.hasActive = function () {\n    return this.activeObservations_.length > 0;\n  };\n  return ResizeObserverSPI;\n}();\n\n// Registry of internal observers. If WeakMap is not available use current shim\n// for the Map collection as it has all required methods and because WeakMap\n// can't be fully polyfilled anyway.\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\nvar ResizeObserver = /** @class */function () {\n  /**\r\n   * Creates a new instance of ResizeObserver.\r\n   *\r\n   * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n   *      dimensions of the observed elements change.\r\n   */\n  function ResizeObserver(callback) {\n    if (!(this instanceof ResizeObserver)) {\n      throw new TypeError('Cannot call a class as a function.');\n    }\n    if (!arguments.length) {\n      throw new TypeError('1 argument required, but only 0 present.');\n    }\n    var controller = ResizeObserverController.getInstance();\n    var observer = new ResizeObserverSPI(callback, controller, this);\n    observers.set(this, observer);\n  }\n  return ResizeObserver;\n}();\n// Expose public methods of ResizeObserver.\n['observe', 'unobserve', 'disconnect'].forEach(function (method) {\n  ResizeObserver.prototype[method] = function () {\n    var _a;\n    return (_a = observers.get(this))[method].apply(_a, arguments);\n  };\n});\nvar index = function () {\n  // Export existing implementation if available.\n  if (typeof global$1.ResizeObserver !== 'undefined') {\n    return global$1.ResizeObserver;\n  }\n  return ResizeObserver;\n}();\n/* harmony default export */ var ResizeObserver_es = (index);\n;// ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/createClass.js\n\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\n\n;// ./node_modules/react-map-gl/dist/esm/utils/globals.js\nvar window_ = typeof window !== 'undefined' ? window : __webpack_require__.g;\nvar global_ = typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : window;\nvar document_ = typeof document !== 'undefined' ? document : {};\n\n;// ./node_modules/react-map-gl/dist/esm/utils/style-utils.js\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar refProps = ['type', 'source', 'source-layer', 'minzoom', 'maxzoom', 'filter', 'layout'];\nfunction normalizeStyle(style) {\n  if (!style) {\n    return null;\n  }\n  if (typeof style === 'string') {\n    return style;\n  }\n  if (style.toJS) {\n    style = style.toJS();\n  }\n  var layerIndex = {};\n  var _iterator = _createForOfIteratorHelper(style.layers),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var layer = _step.value;\n      layerIndex[layer.id] = layer;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var layers = style.layers.map(function (layer) {\n    var layerRef = layerIndex[layer.ref];\n    var normalizedLayer = null;\n    if ('interactive' in layer) {\n      normalizedLayer = _objectSpread({}, layer);\n      delete normalizedLayer.interactive;\n    }\n    if (layerRef) {\n      normalizedLayer = normalizedLayer || _objectSpread({}, layer);\n      delete normalizedLayer.ref;\n      var _iterator2 = _createForOfIteratorHelper(refProps),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var propName = _step2.value;\n          if (propName in layerRef) {\n            normalizedLayer[propName] = layerRef[propName];\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    return normalizedLayer || layer;\n  });\n  return _objectSpread(_objectSpread({}, style), {}, {\n    layers: layers\n  });\n}\n;// ./node_modules/react-map-gl/dist/esm/mapbox/mapbox.js\n\n\n\n\n\n\nfunction noop() {}\nfunction defaultOnError(event) {\n  if (event) {\n    console.error(event.error);\n  }\n}\nvar propTypes = {\n  container: prop_types.object,\n  gl: prop_types.object,\n  mapboxApiAccessToken: prop_types.string,\n  mapboxApiUrl: prop_types.string,\n  attributionControl: prop_types.bool,\n  preserveDrawingBuffer: prop_types.bool,\n  reuseMaps: prop_types.bool,\n  transformRequest: prop_types.func,\n  mapOptions: prop_types.object,\n  mapStyle: prop_types.oneOfType([prop_types.string, prop_types.object]),\n  preventStyleDiffing: prop_types.bool,\n  visible: prop_types.bool,\n  asyncRender: prop_types.bool,\n  onLoad: prop_types.func,\n  onError: prop_types.func,\n  width: prop_types.number,\n  height: prop_types.number,\n  viewState: prop_types.object,\n  longitude: prop_types.number,\n  latitude: prop_types.number,\n  zoom: prop_types.number,\n  bearing: prop_types.number,\n  pitch: prop_types.number,\n  altitude: prop_types.number\n};\nvar defaultProps = {\n  container: document_.body,\n  mapboxApiAccessToken: getAccessToken(),\n  mapboxApiUrl: 'https://api.mapbox.com',\n  preserveDrawingBuffer: false,\n  attributionControl: true,\n  reuseMaps: false,\n  mapOptions: {},\n  mapStyle: 'mapbox://styles/mapbox/light-v8',\n  preventStyleDiffing: false,\n  visible: true,\n  asyncRender: false,\n  onLoad: noop,\n  onError: defaultOnError,\n  width: 0,\n  height: 0,\n  longitude: 0,\n  latitude: 0,\n  zoom: 0,\n  bearing: 0,\n  pitch: 0,\n  altitude: 1.5\n};\nfunction getAccessToken() {\n  var accessToken = null;\n  if (typeof window !== 'undefined' && window.location) {\n    var match = window.location.search.match(/access_token=([^&\\/]*)/);\n    accessToken = match && match[1];\n  }\n  if (!accessToken && typeof process !== 'undefined') {\n    accessToken = accessToken || ({}).MapboxAccessToken || ({}).REACT_APP_MAPBOX_ACCESS_TOKEN;\n  }\n  return accessToken || 'no-token';\n}\nfunction checkPropTypes(props) {\n  var component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'component';\n  if (props.debug) {\n    prop_types.checkPropTypes(propTypes, props, 'prop', component);\n  }\n}\nvar Mapbox = function () {\n  function Mapbox(props) {\n    var _this = this;\n    _classCallCheck(this, Mapbox);\n    _defineProperty(this, \"props\", defaultProps);\n    _defineProperty(this, \"width\", 0);\n    _defineProperty(this, \"height\", 0);\n    _defineProperty(this, \"_fireLoadEvent\", function () {\n      _this.props.onLoad({\n        type: 'load',\n        target: _this._map\n      });\n    });\n    _defineProperty(this, \"_handleError\", function (event) {\n      _this.props.onError(event);\n    });\n    if (!props.mapboxgl) {\n      throw new Error('Mapbox not available');\n    }\n    this.mapboxgl = props.mapboxgl;\n    if (!Mapbox.initialized) {\n      Mapbox.initialized = true;\n      this._checkStyleSheet(this.mapboxgl.version);\n    }\n    this._initialize(props);\n  }\n  _createClass(Mapbox, [{\n    key: \"finalize\",\n    value: function finalize() {\n      this._destroy();\n      return this;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      this._update(this.props, props);\n      return this;\n    }\n  }, {\n    key: \"redraw\",\n    value: function redraw() {\n      var map = this._map;\n      if (map.style) {\n        if (map._frame) {\n          map._frame.cancel();\n          map._frame = null;\n        }\n        map._render();\n      }\n    }\n  }, {\n    key: \"getMap\",\n    value: function getMap() {\n      return this._map;\n    }\n  }, {\n    key: \"_reuse\",\n    value: function _reuse(props) {\n      this._map = Mapbox.savedMap;\n      var oldContainer = this._map.getContainer();\n      var newContainer = props.container;\n      newContainer.classList.add('mapboxgl-map');\n      while (oldContainer.childNodes.length > 0) {\n        newContainer.appendChild(oldContainer.childNodes[0]);\n      }\n      this._map._container = newContainer;\n      Mapbox.savedMap = null;\n      if (props.mapStyle) {\n        this._map.setStyle(normalizeStyle(props.mapStyle), {\n          diff: false\n        });\n      }\n      if (this._map.isStyleLoaded()) {\n        this._fireLoadEvent();\n      } else {\n        this._map.once('styledata', this._fireLoadEvent);\n      }\n    }\n  }, {\n    key: \"_create\",\n    value: function _create(props) {\n      if (props.reuseMaps && Mapbox.savedMap) {\n        this._reuse(props);\n      } else {\n        if (props.gl) {\n          var getContext = HTMLCanvasElement.prototype.getContext;\n          HTMLCanvasElement.prototype.getContext = function () {\n            HTMLCanvasElement.prototype.getContext = getContext;\n            return props.gl;\n          };\n        }\n        var mapOptions = {\n          container: props.container,\n          center: [0, 0],\n          zoom: 8,\n          pitch: 0,\n          bearing: 0,\n          maxZoom: 24,\n          style: normalizeStyle(props.mapStyle),\n          interactive: false,\n          trackResize: false,\n          attributionControl: props.attributionControl,\n          preserveDrawingBuffer: props.preserveDrawingBuffer\n        };\n        if (props.transformRequest) {\n          mapOptions.transformRequest = props.transformRequest;\n        }\n        this._map = new this.mapboxgl.Map(Object.assign({}, mapOptions, props.mapOptions));\n        this._map.once('load', this._fireLoadEvent);\n        this._map.on('error', this._handleError);\n      }\n      return this;\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      if (!this._map) {\n        return;\n      }\n      if (this.props.reuseMaps && !Mapbox.savedMap) {\n        Mapbox.savedMap = this._map;\n        this._map.off('load', this._fireLoadEvent);\n        this._map.off('error', this._handleError);\n        this._map.off('styledata', this._fireLoadEvent);\n      } else {\n        this._map.remove();\n      }\n      this._map = null;\n    }\n  }, {\n    key: \"_initialize\",\n    value: function _initialize(props) {\n      var _this2 = this;\n      props = Object.assign({}, defaultProps, props);\n      checkPropTypes(props, 'Mapbox');\n      this.mapboxgl.accessToken = props.mapboxApiAccessToken || defaultProps.mapboxApiAccessToken;\n      this.mapboxgl.baseApiUrl = props.mapboxApiUrl;\n      this._create(props);\n      var _props = props,\n        container = _props.container;\n      Object.defineProperty(container, 'offsetWidth', {\n        configurable: true,\n        get: function get() {\n          return _this2.width;\n        }\n      });\n      Object.defineProperty(container, 'clientWidth', {\n        configurable: true,\n        get: function get() {\n          return _this2.width;\n        }\n      });\n      Object.defineProperty(container, 'offsetHeight', {\n        configurable: true,\n        get: function get() {\n          return _this2.height;\n        }\n      });\n      Object.defineProperty(container, 'clientHeight', {\n        configurable: true,\n        get: function get() {\n          return _this2.height;\n        }\n      });\n      var canvas = this._map.getCanvas();\n      if (canvas) {\n        canvas.style.outline = 'none';\n      }\n      this._updateMapViewport({}, props);\n      this._updateMapSize({}, props);\n      this.props = props;\n    }\n  }, {\n    key: \"_update\",\n    value: function _update(oldProps, newProps) {\n      if (!this._map) {\n        return;\n      }\n      newProps = Object.assign({}, this.props, newProps);\n      checkPropTypes(newProps, 'Mapbox');\n      var viewportChanged = this._updateMapViewport(oldProps, newProps);\n      var sizeChanged = this._updateMapSize(oldProps, newProps);\n      this._updateMapStyle(oldProps, newProps);\n      if (!newProps.asyncRender && (viewportChanged || sizeChanged)) {\n        this.redraw();\n      }\n      this.props = newProps;\n    }\n  }, {\n    key: \"_updateMapStyle\",\n    value: function _updateMapStyle(oldProps, newProps) {\n      var styleChanged = oldProps.mapStyle !== newProps.mapStyle;\n      if (styleChanged) {\n        this._map.setStyle(normalizeStyle(newProps.mapStyle), {\n          diff: !newProps.preventStyleDiffing\n        });\n      }\n    }\n  }, {\n    key: \"_updateMapSize\",\n    value: function _updateMapSize(oldProps, newProps) {\n      var sizeChanged = oldProps.width !== newProps.width || oldProps.height !== newProps.height;\n      if (sizeChanged) {\n        this.width = newProps.width;\n        this.height = newProps.height;\n        this._map.resize();\n      }\n      return sizeChanged;\n    }\n  }, {\n    key: \"_updateMapViewport\",\n    value: function _updateMapViewport(oldProps, newProps) {\n      var oldViewState = this._getViewState(oldProps);\n      var newViewState = this._getViewState(newProps);\n      var viewportChanged = newViewState.latitude !== oldViewState.latitude || newViewState.longitude !== oldViewState.longitude || newViewState.zoom !== oldViewState.zoom || newViewState.pitch !== oldViewState.pitch || newViewState.bearing !== oldViewState.bearing || newViewState.altitude !== oldViewState.altitude;\n      if (viewportChanged) {\n        this._map.jumpTo(this._viewStateToMapboxProps(newViewState));\n        if (newViewState.altitude !== oldViewState.altitude) {\n          this._map.transform.altitude = newViewState.altitude;\n        }\n      }\n      return viewportChanged;\n    }\n  }, {\n    key: \"_getViewState\",\n    value: function _getViewState(props) {\n      var _ref = props.viewState || props,\n        longitude = _ref.longitude,\n        latitude = _ref.latitude,\n        zoom = _ref.zoom,\n        _ref$pitch = _ref.pitch,\n        pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,\n        _ref$bearing = _ref.bearing,\n        bearing = _ref$bearing === void 0 ? 0 : _ref$bearing,\n        _ref$altitude = _ref.altitude,\n        altitude = _ref$altitude === void 0 ? 1.5 : _ref$altitude;\n      return {\n        longitude: longitude,\n        latitude: latitude,\n        zoom: zoom,\n        pitch: pitch,\n        bearing: bearing,\n        altitude: altitude\n      };\n    }\n  }, {\n    key: \"_checkStyleSheet\",\n    value: function _checkStyleSheet() {\n      var mapboxVersion = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '0.47.0';\n      if (typeof document_ === 'undefined') {\n        return;\n      }\n      try {\n        var testElement = document_.createElement('div');\n        testElement.className = 'mapboxgl-map';\n        testElement.style.display = 'none';\n        document_.body.appendChild(testElement);\n        var isCssLoaded = window.getComputedStyle(testElement).position !== 'static';\n        if (!isCssLoaded) {\n          var link = document_.createElement('link');\n          link.setAttribute('rel', 'stylesheet');\n          link.setAttribute('type', 'text/css');\n          link.setAttribute('href', \"https://api.tiles.mapbox.com/mapbox-gl-js/v\".concat(mapboxVersion, \"/mapbox-gl.css\"));\n          document_.head.appendChild(link);\n        }\n      } catch (error) {}\n    }\n  }, {\n    key: \"_viewStateToMapboxProps\",\n    value: function _viewStateToMapboxProps(viewState) {\n      return {\n        center: [viewState.longitude, viewState.latitude],\n        zoom: viewState.zoom,\n        bearing: viewState.bearing,\n        pitch: viewState.pitch\n      };\n    }\n  }]);\n  return Mapbox;\n}();\n_defineProperty(Mapbox, \"initialized\", false);\n_defineProperty(Mapbox, \"propTypes\", propTypes);\n_defineProperty(Mapbox, \"defaultProps\", defaultProps);\n_defineProperty(Mapbox, \"savedMap\", null);\n\n// EXTERNAL MODULE: ./node_modules/maplibre-gl/dist/maplibre-gl.js\nvar maplibre_gl = __webpack_require__(40111);\nvar maplibre_gl_default = /*#__PURE__*/__webpack_require__.n(maplibre_gl);\n;// ./node_modules/react-map-gl/dist/esm/utils/mapboxgl.browser.js\n\n;// ./node_modules/react-map-gl/dist/esm/utils/math-utils.js\nvar math_utils_EPSILON = 1e-7;\nfunction isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value);\n}\nfunction math_utils_equals(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (isArray(a) && isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (var i = 0; i < a.length; ++i) {\n      if (!math_utils_equals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return Math.abs(a - b) <= math_utils_EPSILON;\n}\nfunction math_utils_clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nfunction utils_math_utils_lerp(a, b, t) {\n  if (isArray(a)) {\n    return a.map(function (ai, i) {\n      return utils_math_utils_lerp(ai, b[i], t);\n    });\n  }\n  return t * b + (1 - t) * a;\n}\n;// ./node_modules/react-map-gl/dist/esm/utils/assert.js\nfunction utils_assert_assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'react-map-gl: assertion failed.');\n  }\n}\n;// ./node_modules/react-map-gl/dist/esm/utils/map-state.js\n\n\n\n\nfunction map_state_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction map_state_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      map_state_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      map_state_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\nvar MAPBOX_LIMITS = {\n  minZoom: 0,\n  maxZoom: 24,\n  minPitch: 0,\n  maxPitch: 85\n};\nvar DEFAULT_STATE = {\n  pitch: 0,\n  bearing: 0,\n  altitude: 1.5\n};\nvar PITCH_MOUSE_THRESHOLD = 5;\nvar PITCH_ACCEL = 1.2;\nvar MapState = function () {\n  function MapState(_ref) {\n    var width = _ref.width,\n      height = _ref.height,\n      latitude = _ref.latitude,\n      longitude = _ref.longitude,\n      zoom = _ref.zoom,\n      _ref$bearing = _ref.bearing,\n      bearing = _ref$bearing === void 0 ? DEFAULT_STATE.bearing : _ref$bearing,\n      _ref$pitch = _ref.pitch,\n      pitch = _ref$pitch === void 0 ? DEFAULT_STATE.pitch : _ref$pitch,\n      _ref$altitude = _ref.altitude,\n      altitude = _ref$altitude === void 0 ? DEFAULT_STATE.altitude : _ref$altitude,\n      _ref$maxZoom = _ref.maxZoom,\n      maxZoom = _ref$maxZoom === void 0 ? MAPBOX_LIMITS.maxZoom : _ref$maxZoom,\n      _ref$minZoom = _ref.minZoom,\n      minZoom = _ref$minZoom === void 0 ? MAPBOX_LIMITS.minZoom : _ref$minZoom,\n      _ref$maxPitch = _ref.maxPitch,\n      maxPitch = _ref$maxPitch === void 0 ? MAPBOX_LIMITS.maxPitch : _ref$maxPitch,\n      _ref$minPitch = _ref.minPitch,\n      minPitch = _ref$minPitch === void 0 ? MAPBOX_LIMITS.minPitch : _ref$minPitch,\n      transitionDuration = _ref.transitionDuration,\n      transitionEasing = _ref.transitionEasing,\n      transitionInterpolator = _ref.transitionInterpolator,\n      transitionInterruption = _ref.transitionInterruption,\n      startPanLngLat = _ref.startPanLngLat,\n      startZoomLngLat = _ref.startZoomLngLat,\n      startRotatePos = _ref.startRotatePos,\n      startBearing = _ref.startBearing,\n      startPitch = _ref.startPitch,\n      startZoom = _ref.startZoom;\n    _classCallCheck(this, MapState);\n    utils_assert_assert(Number.isFinite(width), '`width` must be supplied');\n    utils_assert_assert(Number.isFinite(height), '`height` must be supplied');\n    utils_assert_assert(Number.isFinite(longitude), '`longitude` must be supplied');\n    utils_assert_assert(Number.isFinite(latitude), '`latitude` must be supplied');\n    utils_assert_assert(Number.isFinite(zoom), '`zoom` must be supplied');\n    this._viewportProps = this._applyConstraints({\n      width: width,\n      height: height,\n      latitude: latitude,\n      longitude: longitude,\n      zoom: zoom,\n      bearing: bearing,\n      pitch: pitch,\n      altitude: altitude,\n      maxZoom: maxZoom,\n      minZoom: minZoom,\n      maxPitch: maxPitch,\n      minPitch: minPitch,\n      transitionDuration: transitionDuration,\n      transitionEasing: transitionEasing,\n      transitionInterpolator: transitionInterpolator,\n      transitionInterruption: transitionInterruption\n    });\n    this._state = {\n      startPanLngLat: startPanLngLat,\n      startZoomLngLat: startZoomLngLat,\n      startRotatePos: startRotatePos,\n      startBearing: startBearing,\n      startPitch: startPitch,\n      startZoom: startZoom\n    };\n  }\n  _createClass(MapState, [{\n    key: \"getViewportProps\",\n    value: function getViewportProps() {\n      return this._viewportProps;\n    }\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return this._state;\n    }\n  }, {\n    key: \"panStart\",\n    value: function panStart(_ref2) {\n      var pos = _ref2.pos;\n      return this._getUpdatedMapState({\n        startPanLngLat: this._unproject(pos)\n      });\n    }\n  }, {\n    key: \"pan\",\n    value: function pan(_ref3) {\n      var pos = _ref3.pos,\n        startPos = _ref3.startPos;\n      var startPanLngLat = this._state.startPanLngLat || this._unproject(startPos);\n      if (!startPanLngLat) {\n        return this;\n      }\n      var _this$_calculateNewLn = this._calculateNewLngLat({\n          startPanLngLat: startPanLngLat,\n          pos: pos\n        }),\n        _this$_calculateNewLn2 = _slicedToArray(_this$_calculateNewLn, 2),\n        longitude = _this$_calculateNewLn2[0],\n        latitude = _this$_calculateNewLn2[1];\n      return this._getUpdatedMapState({\n        longitude: longitude,\n        latitude: latitude\n      });\n    }\n  }, {\n    key: \"panEnd\",\n    value: function panEnd() {\n      return this._getUpdatedMapState({\n        startPanLngLat: null\n      });\n    }\n  }, {\n    key: \"rotateStart\",\n    value: function rotateStart(_ref4) {\n      var pos = _ref4.pos;\n      return this._getUpdatedMapState({\n        startRotatePos: pos,\n        startBearing: this._viewportProps.bearing,\n        startPitch: this._viewportProps.pitch\n      });\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(_ref5) {\n      var pos = _ref5.pos,\n        _ref5$deltaAngleX = _ref5.deltaAngleX,\n        deltaAngleX = _ref5$deltaAngleX === void 0 ? 0 : _ref5$deltaAngleX,\n        _ref5$deltaAngleY = _ref5.deltaAngleY,\n        deltaAngleY = _ref5$deltaAngleY === void 0 ? 0 : _ref5$deltaAngleY;\n      var _this$_state = this._state,\n        startRotatePos = _this$_state.startRotatePos,\n        startBearing = _this$_state.startBearing,\n        startPitch = _this$_state.startPitch;\n      if (!Number.isFinite(startBearing) || !Number.isFinite(startPitch)) {\n        return this;\n      }\n      var newRotation;\n      if (pos) {\n        newRotation = this._calculateNewPitchAndBearing(map_state_objectSpread(map_state_objectSpread({}, this._getRotationParams(pos, startRotatePos)), {}, {\n          startBearing: startBearing,\n          startPitch: startPitch\n        }));\n      } else {\n        newRotation = {\n          bearing: startBearing + deltaAngleX,\n          pitch: startPitch + deltaAngleY\n        };\n      }\n      return this._getUpdatedMapState(newRotation);\n    }\n  }, {\n    key: \"rotateEnd\",\n    value: function rotateEnd() {\n      return this._getUpdatedMapState({\n        startBearing: null,\n        startPitch: null\n      });\n    }\n  }, {\n    key: \"zoomStart\",\n    value: function zoomStart(_ref6) {\n      var pos = _ref6.pos;\n      return this._getUpdatedMapState({\n        startZoomLngLat: this._unproject(pos),\n        startZoom: this._viewportProps.zoom\n      });\n    }\n  }, {\n    key: \"zoom\",\n    value: function zoom(_ref7) {\n      var pos = _ref7.pos,\n        startPos = _ref7.startPos,\n        scale = _ref7.scale;\n      utils_assert_assert(scale > 0, '`scale` must be a positive number');\n      var _this$_state2 = this._state,\n        startZoom = _this$_state2.startZoom,\n        startZoomLngLat = _this$_state2.startZoomLngLat;\n      if (!Number.isFinite(startZoom)) {\n        startZoom = this._viewportProps.zoom;\n        startZoomLngLat = this._unproject(startPos) || this._unproject(pos);\n      }\n      utils_assert_assert(startZoomLngLat, '`startZoomLngLat` prop is required ' + 'for zoom behavior to calculate where to position the map.');\n      var zoom = this._calculateNewZoom({\n        scale: scale,\n        startZoom: startZoom || 0\n      });\n      var zoomedViewport = new WebMercatorViewport(Object.assign({}, this._viewportProps, {\n        zoom: zoom\n      }));\n      var _zoomedViewport$getMa = zoomedViewport.getMapCenterByLngLatPosition({\n          lngLat: startZoomLngLat,\n          pos: pos\n        }),\n        _zoomedViewport$getMa2 = _slicedToArray(_zoomedViewport$getMa, 2),\n        longitude = _zoomedViewport$getMa2[0],\n        latitude = _zoomedViewport$getMa2[1];\n      return this._getUpdatedMapState({\n        zoom: zoom,\n        longitude: longitude,\n        latitude: latitude\n      });\n    }\n  }, {\n    key: \"zoomEnd\",\n    value: function zoomEnd() {\n      return this._getUpdatedMapState({\n        startZoomLngLat: null,\n        startZoom: null\n      });\n    }\n  }, {\n    key: \"_getUpdatedMapState\",\n    value: function _getUpdatedMapState(newProps) {\n      return new MapState(Object.assign({}, this._viewportProps, this._state, newProps));\n    }\n  }, {\n    key: \"_applyConstraints\",\n    value: function _applyConstraints(props) {\n      var maxZoom = props.maxZoom,\n        minZoom = props.minZoom,\n        zoom = props.zoom;\n      props.zoom = math_utils_clamp(zoom, minZoom, maxZoom);\n      var maxPitch = props.maxPitch,\n        minPitch = props.minPitch,\n        pitch = props.pitch;\n      props.pitch = math_utils_clamp(pitch, minPitch, maxPitch);\n      Object.assign(props, normalizeViewportProps(props));\n      return props;\n    }\n  }, {\n    key: \"_unproject\",\n    value: function _unproject(pos) {\n      var viewport = new WebMercatorViewport(this._viewportProps);\n      return pos && viewport.unproject(pos);\n    }\n  }, {\n    key: \"_calculateNewLngLat\",\n    value: function _calculateNewLngLat(_ref8) {\n      var startPanLngLat = _ref8.startPanLngLat,\n        pos = _ref8.pos;\n      var viewport = new WebMercatorViewport(this._viewportProps);\n      return viewport.getMapCenterByLngLatPosition({\n        lngLat: startPanLngLat,\n        pos: pos\n      });\n    }\n  }, {\n    key: \"_calculateNewZoom\",\n    value: function _calculateNewZoom(_ref9) {\n      var scale = _ref9.scale,\n        startZoom = _ref9.startZoom;\n      var _this$_viewportProps = this._viewportProps,\n        maxZoom = _this$_viewportProps.maxZoom,\n        minZoom = _this$_viewportProps.minZoom;\n      var zoom = startZoom + Math.log2(scale);\n      return math_utils_clamp(zoom, minZoom, maxZoom);\n    }\n  }, {\n    key: \"_calculateNewPitchAndBearing\",\n    value: function _calculateNewPitchAndBearing(_ref10) {\n      var deltaScaleX = _ref10.deltaScaleX,\n        deltaScaleY = _ref10.deltaScaleY,\n        startBearing = _ref10.startBearing,\n        startPitch = _ref10.startPitch;\n      deltaScaleY = math_utils_clamp(deltaScaleY, -1, 1);\n      var _this$_viewportProps2 = this._viewportProps,\n        minPitch = _this$_viewportProps2.minPitch,\n        maxPitch = _this$_viewportProps2.maxPitch;\n      var bearing = startBearing + 180 * deltaScaleX;\n      var pitch = startPitch;\n      if (deltaScaleY > 0) {\n        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);\n      } else if (deltaScaleY < 0) {\n        pitch = startPitch - deltaScaleY * (minPitch - startPitch);\n      }\n      return {\n        pitch: pitch,\n        bearing: bearing\n      };\n    }\n  }, {\n    key: \"_getRotationParams\",\n    value: function _getRotationParams(pos, startPos) {\n      var deltaX = pos[0] - startPos[0];\n      var deltaY = pos[1] - startPos[1];\n      var centerY = pos[1];\n      var startY = startPos[1];\n      var _this$_viewportProps3 = this._viewportProps,\n        width = _this$_viewportProps3.width,\n        height = _this$_viewportProps3.height;\n      var deltaScaleX = deltaX / width;\n      var deltaScaleY = 0;\n      if (deltaY > 0) {\n        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {\n          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;\n        }\n      } else if (deltaY < 0) {\n        if (startY > PITCH_MOUSE_THRESHOLD) {\n          deltaScaleY = 1 - centerY / startY;\n        }\n      }\n      deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));\n      return {\n        deltaScaleX: deltaScaleX,\n        deltaScaleY: deltaScaleY\n      };\n    }\n  }]);\n  return MapState;\n}();\n\n;// ./node_modules/react-map-gl/dist/esm/utils/map-constraints.js\n\nfunction decapitalize(s) {\n  return s[0].toLowerCase() + s.slice(1);\n}\nfunction checkVisibilityConstraints(props) {\n  var constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAPBOX_LIMITS;\n  for (var constraintName in constraints) {\n    var type = constraintName.slice(0, 3);\n    var propName = decapitalize(constraintName.slice(3));\n    if (type === 'min' && props[propName] < constraints[constraintName]) {\n      return false;\n    }\n    if (type === 'max' && props[propName] > constraints[constraintName]) {\n      return false;\n    }\n  }\n  return true;\n}\n;// ./node_modules/react-map-gl/dist/esm/components/map-context.js\n\n\nfunction map_context_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction map_context_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      map_context_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      map_context_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\nvar MapContext = (0,react.createContext)({\n  viewport: null,\n  map: null,\n  container: null,\n  onViewportChange: null,\n  onViewStateChange: null,\n  eventManager: null\n});\nvar MapContextProvider = MapContext.Provider;\nfunction WrappedProvider(_ref) {\n  var value = _ref.value,\n    children = _ref.children;\n  var _useState = (0,react.useState)(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    map = _useState2[0],\n    setMap = _useState2[1];\n  var context = (0,react.useContext)(MapContext);\n  value = map_context_objectSpread(map_context_objectSpread({\n    setMap: setMap\n  }, context), {}, {\n    map: context && context.map || map\n  }, value);\n  return react.createElement(MapContextProvider, {\n    value: value\n  }, children);\n}\nMapContext.Provider = WrappedProvider;\n/* harmony default export */ var map_context = (MapContext);\n;// ./node_modules/react-map-gl/dist/esm/utils/use-isomorphic-layout-effect.js\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react.useLayoutEffect : react.useEffect;\n/* harmony default export */ var use_isomorphic_layout_effect = (useIsomorphicLayoutEffect);\n;// ./node_modules/react-map-gl/dist/esm/utils/terrain.js\nfunction getTerrainElevation(map, _ref) {\n  var longitude = _ref.longitude,\n    latitude = _ref.latitude;\n  if (map && map.queryTerrainElevation) {\n    return map.queryTerrainElevation([longitude, latitude]) || 0;\n  }\n  return 0;\n}\n;// ./node_modules/react-map-gl/dist/esm/components/static-map.js\n\n\nfunction static_map_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction static_map_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      static_map_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      static_map_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\n\n\n\n\n\n\n\nvar TOKEN_DOC_URL = 'https://visgl.github.io/react-map-gl/docs/get-started/mapbox-tokens';\nvar NO_TOKEN_WARNING = 'A valid API access token is required to use Mapbox data';\nfunction static_map_noop() {}\nfunction getViewport(_ref) {\n  var map = _ref.map,\n    props = _ref.props,\n    width = _ref.width,\n    height = _ref.height;\n  var viewportProps = static_map_objectSpread(static_map_objectSpread(static_map_objectSpread({}, props), props.viewState), {}, {\n    width: width,\n    height: height\n  });\n  viewportProps.position = [0, 0, getTerrainElevation(map, viewportProps)];\n  return new WebMercatorViewport(viewportProps);\n}\nvar UNAUTHORIZED_ERROR_CODE = 401;\nvar CONTAINER_STYLE = {\n  position: 'absolute',\n  width: '100%',\n  height: '100%',\n  overflow: 'hidden'\n};\nvar static_map_defaultProps = Object.assign({}, Mapbox.defaultProps, {\n  disableTokenWarning: false,\n  visible: true,\n  onResize: static_map_noop,\n  className: '',\n  style: null,\n  visibilityConstraints: MAPBOX_LIMITS\n});\nfunction NoTokenWarning() {\n  var style = {\n    position: 'absolute',\n    left: 0,\n    top: 0\n  };\n  return react.createElement(\"div\", {\n    key: \"warning\",\n    id: \"no-token-warning\",\n    style: style\n  }, react.createElement(\"h3\", {\n    key: \"header\"\n  }, NO_TOKEN_WARNING), react.createElement(\"div\", {\n    key: \"text\"\n  }, \"For information on setting up your basemap, read\"), react.createElement(\"a\", {\n    key: \"link\",\n    href: TOKEN_DOC_URL\n  }, \"Note on Map Tokens\"));\n}\nfunction getRefHandles(mapboxRef) {\n  return {\n    getMap: function getMap() {\n      return mapboxRef.current && mapboxRef.current.getMap();\n    },\n    queryRenderedFeatures: function queryRenderedFeatures(geometry) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var map = mapboxRef.current && mapboxRef.current.getMap();\n      return map && map.queryRenderedFeatures(geometry, options);\n    }\n  };\n}\nvar StaticMap = (0,react.forwardRef)(function (props, ref) {\n  var _useState = (0,react.useState)(true),\n    _useState2 = _slicedToArray(_useState, 2),\n    accessTokenValid = _useState2[0],\n    setTokenState = _useState2[1];\n  var _useState3 = (0,react.useState)({\n      width: 0,\n      height: 0\n    }),\n    _useState4 = _slicedToArray(_useState3, 2),\n    size = _useState4[0],\n    setSize = _useState4[1];\n  var mapboxRef = (0,react.useRef)(null);\n  var mapDivRef = (0,react.useRef)(null);\n  var containerRef = (0,react.useRef)(null);\n  var overlayRef = (0,react.useRef)(null);\n  var context = (0,react.useContext)(map_context);\n  use_isomorphic_layout_effect(function () {\n    if (!StaticMap.supported()) {\n      return undefined;\n    }\n    var mapbox = new Mapbox(static_map_objectSpread(static_map_objectSpread(static_map_objectSpread({}, props), size), {}, {\n      mapboxgl: (maplibre_gl_default()),\n      container: mapDivRef.current,\n      onError: function onError(evt) {\n        var statusCode = evt.error && evt.error.status || evt.status;\n        if (statusCode === UNAUTHORIZED_ERROR_CODE && accessTokenValid) {\n          console.error(NO_TOKEN_WARNING);\n          setTokenState(false);\n        }\n        props.onError(evt);\n      }\n    }));\n    mapboxRef.current = mapbox;\n    if (context && context.setMap) {\n      context.setMap(mapbox.getMap());\n    }\n    var resizeObserver = new ResizeObserver_es(function (entries) {\n      if (entries[0].contentRect) {\n        var _entries$0$contentRec = entries[0].contentRect,\n          _width = _entries$0$contentRec.width,\n          _height = _entries$0$contentRec.height;\n        setSize({\n          width: _width,\n          height: _height\n        });\n        props.onResize({\n          width: _width,\n          height: _height\n        });\n      }\n    });\n    resizeObserver.observe(containerRef.current);\n    return function () {\n      mapbox.finalize();\n      mapboxRef.current = null;\n      resizeObserver.disconnect();\n    };\n  }, []);\n  use_isomorphic_layout_effect(function () {\n    if (mapboxRef.current) {\n      mapboxRef.current.setProps(static_map_objectSpread(static_map_objectSpread({}, props), size));\n    }\n  });\n  var map = mapboxRef.current && mapboxRef.current.getMap();\n  (0,react.useImperativeHandle)(ref, function () {\n    return getRefHandles(mapboxRef);\n  }, []);\n  var preventScroll = (0,react.useCallback)(function (_ref2) {\n    var target = _ref2.target;\n    if (target === overlayRef.current) {\n      target.scrollTo(0, 0);\n    }\n  }, []);\n  var overlays = map && react.createElement(MapContextProvider, {\n    value: static_map_objectSpread(static_map_objectSpread({}, context), {}, {\n      viewport: context.viewport || getViewport(static_map_objectSpread({\n        map: map,\n        props: props\n      }, size)),\n      map: map,\n      container: context.container || containerRef.current\n    })\n  }, react.createElement(\"div\", {\n    key: \"map-overlays\",\n    className: \"overlays\",\n    ref: overlayRef,\n    style: CONTAINER_STYLE,\n    onScroll: preventScroll\n  }, props.children));\n  var className = props.className,\n    width = props.width,\n    height = props.height,\n    style = props.style,\n    visibilityConstraints = props.visibilityConstraints;\n  var mapContainerStyle = Object.assign({\n    position: 'relative'\n  }, style, {\n    width: width,\n    height: height\n  });\n  var visible = props.visible && checkVisibilityConstraints(props.viewState || props, visibilityConstraints);\n  var mapStyle = Object.assign({}, CONTAINER_STYLE, {\n    visibility: visible ? 'inherit' : 'hidden'\n  });\n  return react.createElement(\"div\", {\n    key: \"map-container\",\n    ref: containerRef,\n    style: mapContainerStyle\n  }, react.createElement(\"div\", {\n    key: \"map-mapbox\",\n    ref: mapDivRef,\n    style: mapStyle,\n    className: className\n  }), overlays, !accessTokenValid && !props.disableTokenWarning && react.createElement(NoTokenWarning, null));\n});\nStaticMap.supported = function () {\n  return (maplibre_gl_default()) && maplibre_gl_default().supported();\n};\nStaticMap.defaultProps = static_map_defaultProps;\n/* harmony default export */ var static_map = (StaticMap);\n;// ./node_modules/react-map-gl/dist/esm/utils/transition/transition-interpolator.js\n\n\n\nfunction transition_interpolator_createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = transition_interpolator_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction transition_interpolator_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return transition_interpolator_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return transition_interpolator_arrayLikeToArray(o, minLen);\n}\nfunction transition_interpolator_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\n\n\nvar TransitionInterpolator = function () {\n  function TransitionInterpolator() {\n    _classCallCheck(this, TransitionInterpolator);\n    _defineProperty(this, \"propNames\", []);\n  }\n  _createClass(TransitionInterpolator, [{\n    key: \"arePropsEqual\",\n    value: function arePropsEqual(currentProps, nextProps) {\n      var _iterator = transition_interpolator_createForOfIteratorHelper(this.propNames || []),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          if (!math_utils_equals(currentProps[key], nextProps[key])) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return true;\n    }\n  }, {\n    key: \"initializeProps\",\n    value: function initializeProps(startProps, endProps) {\n      return {\n        start: startProps,\n        end: endProps\n      };\n    }\n  }, {\n    key: \"interpolateProps\",\n    value: function interpolateProps(startProps, endProps, t) {\n      utils_assert_assert(false, 'interpolateProps is not implemented');\n    }\n  }, {\n    key: \"getDuration\",\n    value: function getDuration(startProps, endProps) {\n      return endProps.transitionDuration;\n    }\n  }]);\n  return TransitionInterpolator;\n}();\n\n;// ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\nfunction _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\nvar setPrototypeOf = __webpack_require__(63662);\n;// ./node_modules/@babel/runtime/helpers/esm/inherits.js\n\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && (0,setPrototypeOf/* default */.A)(t, e);\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\n\n\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\n\n;// ./node_modules/react-map-gl/dist/esm/utils/transition/transition-utils.js\nvar WRAPPED_ANGULAR_PROPS = {\n  longitude: 1,\n  bearing: 1\n};\nfunction transition_utils_mod(value, divisor) {\n  var modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\nfunction isValid(prop) {\n  return Number.isFinite(prop) || Array.isArray(prop);\n}\nfunction isWrappedAngularProp(propName) {\n  return propName in WRAPPED_ANGULAR_PROPS;\n}\nfunction getEndValueByShortestPath(propName, startValue, endValue) {\n  if (isWrappedAngularProp(propName) && Math.abs(endValue - startValue) > 180) {\n    endValue = endValue < 0 ? endValue + 360 : endValue - 360;\n  }\n  return endValue;\n}\n;// ./node_modules/react-map-gl/dist/esm/utils/transition/viewport-fly-to-interpolator.js\n\n\n\n\n\n\n\nfunction viewport_fly_to_interpolator_createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = viewport_fly_to_interpolator_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction viewport_fly_to_interpolator_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return viewport_fly_to_interpolator_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return viewport_fly_to_interpolator_arrayLikeToArray(o, minLen);\n}\nfunction viewport_fly_to_interpolator_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n\n\n\n\nvar viewport_fly_to_interpolator_VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'];\nvar REQUIRED_PROPS = ['latitude', 'longitude', 'zoom', 'width', 'height'];\nvar LINEARLY_INTERPOLATED_PROPS = ['bearing', 'pitch'];\nvar viewport_fly_to_interpolator_DEFAULT_OPTS = {\n  speed: 1.2,\n  curve: 1.414\n};\nvar ViewportFlyToInterpolator = function (_TransitionInterpolat) {\n  _inherits(ViewportFlyToInterpolator, _TransitionInterpolat);\n  var _super = _createSuper(ViewportFlyToInterpolator);\n  function ViewportFlyToInterpolator() {\n    var _this;\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, ViewportFlyToInterpolator);\n    _this = _super.call(this);\n    _defineProperty(_assertThisInitialized(_this), \"propNames\", viewport_fly_to_interpolator_VIEWPORT_TRANSITION_PROPS);\n    _this.props = Object.assign({}, viewport_fly_to_interpolator_DEFAULT_OPTS, props);\n    return _this;\n  }\n  _createClass(ViewportFlyToInterpolator, [{\n    key: \"initializeProps\",\n    value: function initializeProps(startProps, endProps) {\n      var startViewportProps = {};\n      var endViewportProps = {};\n      var _iterator = viewport_fly_to_interpolator_createForOfIteratorHelper(REQUIRED_PROPS),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          var startValue = startProps[key];\n          var endValue = endProps[key];\n          utils_assert_assert(isValid(startValue) && isValid(endValue), \"\".concat(key, \" must be supplied for transition\"));\n          startViewportProps[key] = startValue;\n          endViewportProps[key] = getEndValueByShortestPath(key, startValue, endValue);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var _iterator2 = viewport_fly_to_interpolator_createForOfIteratorHelper(LINEARLY_INTERPOLATED_PROPS),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _key = _step2.value;\n          var _startValue = startProps[_key] || 0;\n          var _endValue = endProps[_key] || 0;\n          startViewportProps[_key] = _startValue;\n          endViewportProps[_key] = getEndValueByShortestPath(_key, _startValue, _endValue);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return {\n        start: startViewportProps,\n        end: endViewportProps\n      };\n    }\n  }, {\n    key: \"interpolateProps\",\n    value: function interpolateProps(startProps, endProps, t) {\n      var viewport = flyToViewport(startProps, endProps, t, this.props);\n      var _iterator3 = viewport_fly_to_interpolator_createForOfIteratorHelper(LINEARLY_INTERPOLATED_PROPS),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var key = _step3.value;\n          viewport[key] = utils_math_utils_lerp(startProps[key], endProps[key], t);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return viewport;\n    }\n  }, {\n    key: \"getDuration\",\n    value: function getDuration(startProps, endProps) {\n      var transitionDuration = endProps.transitionDuration;\n      if (transitionDuration === 'auto') {\n        transitionDuration = getFlyToDuration(startProps, endProps, this.props);\n      }\n      return transitionDuration;\n    }\n  }]);\n  return ViewportFlyToInterpolator;\n}(TransitionInterpolator);\n\n;// ./node_modules/react-map-gl/dist/esm/utils/transition/linear-interpolator.js\n\n\n\n\n\n\nfunction linear_interpolator_createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = linear_interpolator_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction linear_interpolator_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return linear_interpolator_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return linear_interpolator_arrayLikeToArray(o, minLen);\n}\nfunction linear_interpolator_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction linear_interpolator_createSuper(Derived) {\n  var hasNativeReflectConstruct = linear_interpolator_isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction linear_interpolator_isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n\n\n\n\nvar linear_interpolator_VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'];\nvar LinearInterpolator = function (_TransitionInterpolat) {\n  _inherits(LinearInterpolator, _TransitionInterpolat);\n  var _super = linear_interpolator_createSuper(LinearInterpolator);\n  function LinearInterpolator() {\n    var _this;\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, LinearInterpolator);\n    _this = _super.call(this);\n    if (Array.isArray(opts)) {\n      opts = {\n        transitionProps: opts\n      };\n    }\n    _this.propNames = opts.transitionProps || linear_interpolator_VIEWPORT_TRANSITION_PROPS;\n    if (opts.around) {\n      _this.around = opts.around;\n    }\n    return _this;\n  }\n  _createClass(LinearInterpolator, [{\n    key: \"initializeProps\",\n    value: function initializeProps(startProps, endProps) {\n      var startViewportProps = {};\n      var endViewportProps = {};\n      if (this.around) {\n        startViewportProps.around = this.around;\n        var aroundLngLat = new WebMercatorViewport(startProps).unproject(this.around);\n        Object.assign(endViewportProps, endProps, {\n          around: new WebMercatorViewport(endProps).project(aroundLngLat),\n          aroundLngLat: aroundLngLat\n        });\n      }\n      var _iterator = linear_interpolator_createForOfIteratorHelper(this.propNames),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          var startValue = startProps[key];\n          var endValue = endProps[key];\n          utils_assert_assert(isValid(startValue) && isValid(endValue), \"\".concat(key, \" must be supplied for transition\"));\n          startViewportProps[key] = startValue;\n          endViewportProps[key] = getEndValueByShortestPath(key, startValue, endValue);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return {\n        start: startViewportProps,\n        end: endViewportProps\n      };\n    }\n  }, {\n    key: \"interpolateProps\",\n    value: function interpolateProps(startProps, endProps, t) {\n      var viewport = {};\n      var _iterator2 = linear_interpolator_createForOfIteratorHelper(this.propNames),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var key = _step2.value;\n          viewport[key] = utils_math_utils_lerp(startProps[key], endProps[key], t);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      if (endProps.around) {\n        var _WebMercatorViewport$ = new WebMercatorViewport(Object.assign({}, endProps, viewport)).getMapCenterByLngLatPosition({\n            lngLat: endProps.aroundLngLat,\n            pos: utils_math_utils_lerp(startProps.around, endProps.around, t)\n          }),\n          _WebMercatorViewport$2 = _slicedToArray(_WebMercatorViewport$, 2),\n          longitude = _WebMercatorViewport$2[0],\n          latitude = _WebMercatorViewport$2[1];\n        viewport.longitude = longitude;\n        viewport.latitude = latitude;\n      }\n      return viewport;\n    }\n  }]);\n  return LinearInterpolator;\n}(TransitionInterpolator);\n\n;// ./node_modules/react-map-gl/dist/esm/utils/transition/index.js\n\n\n\n;// ./node_modules/react-map-gl/dist/esm/utils/transition-manager.js\n\n\n\n\n\n\nvar transition_manager_noop = function noop() {};\nfunction cropEasingFunction(easing, x0) {\n  var y0 = easing(x0);\n  return function (t) {\n    return 1 / (1 - y0) * (easing(t * (1 - x0) + x0) - y0);\n  };\n}\nvar TRANSITION_EVENTS = {\n  BREAK: 1,\n  SNAP_TO_END: 2,\n  IGNORE: 3,\n  UPDATE: 4\n};\nvar DEFAULT_PROPS = {\n  transitionDuration: 0,\n  transitionEasing: function transitionEasing(t) {\n    return t;\n  },\n  transitionInterpolator: new LinearInterpolator(),\n  transitionInterruption: TRANSITION_EVENTS.BREAK,\n  onTransitionStart: transition_manager_noop,\n  onTransitionInterrupt: transition_manager_noop,\n  onTransitionEnd: transition_manager_noop\n};\nvar TransitionManager = function () {\n  function TransitionManager() {\n    var _this = this;\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, TransitionManager);\n    _defineProperty(this, \"_animationFrame\", null);\n    _defineProperty(this, \"_onTransitionFrame\", function () {\n      _this._animationFrame = requestAnimationFrame(_this._onTransitionFrame);\n      _this._updateViewport();\n    });\n    this.props = null;\n    this.onViewportChange = opts.onViewportChange || transition_manager_noop;\n    this.onStateChange = opts.onStateChange || transition_manager_noop;\n    this.time = opts.getTime || Date.now;\n  }\n  _createClass(TransitionManager, [{\n    key: \"getViewportInTransition\",\n    value: function getViewportInTransition() {\n      return this._animationFrame ? this.state.propsInTransition : null;\n    }\n  }, {\n    key: \"processViewportChange\",\n    value: function processViewportChange(nextProps) {\n      var currentProps = this.props;\n      this.props = nextProps;\n      if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n        return false;\n      }\n      if (this._isTransitionEnabled(nextProps)) {\n        var startProps = Object.assign({}, currentProps);\n        var endProps = Object.assign({}, nextProps);\n        if (this._isTransitionInProgress()) {\n          currentProps.onTransitionInterrupt();\n          if (this.state.interruption === TRANSITION_EVENTS.SNAP_TO_END) {\n            Object.assign(startProps, this.state.endProps);\n          } else {\n            Object.assign(startProps, this.state.propsInTransition);\n          }\n          if (this.state.interruption === TRANSITION_EVENTS.UPDATE) {\n            var currentTime = this.time();\n            var x0 = (currentTime - this.state.startTime) / this.state.duration;\n            endProps.transitionDuration = this.state.duration - (currentTime - this.state.startTime);\n            endProps.transitionEasing = cropEasingFunction(this.state.easing, x0);\n            endProps.transitionInterpolator = startProps.transitionInterpolator;\n          }\n        }\n        endProps.onTransitionStart();\n        this._triggerTransition(startProps, endProps);\n        return true;\n      }\n      if (this._isTransitionInProgress()) {\n        currentProps.onTransitionInterrupt();\n        this._endTransition();\n      }\n      return false;\n    }\n  }, {\n    key: \"_isTransitionInProgress\",\n    value: function _isTransitionInProgress() {\n      return Boolean(this._animationFrame);\n    }\n  }, {\n    key: \"_isTransitionEnabled\",\n    value: function _isTransitionEnabled(props) {\n      var transitionDuration = props.transitionDuration,\n        transitionInterpolator = props.transitionInterpolator;\n      return (transitionDuration > 0 || transitionDuration === 'auto') && Boolean(transitionInterpolator);\n    }\n  }, {\n    key: \"_isUpdateDueToCurrentTransition\",\n    value: function _isUpdateDueToCurrentTransition(props) {\n      if (this.state.propsInTransition) {\n        return this.state.interpolator.arePropsEqual(props, this.state.propsInTransition);\n      }\n      return false;\n    }\n  }, {\n    key: \"_shouldIgnoreViewportChange\",\n    value: function _shouldIgnoreViewportChange(currentProps, nextProps) {\n      if (!currentProps) {\n        return true;\n      }\n      if (this._isTransitionInProgress()) {\n        return this.state.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);\n      }\n      if (this._isTransitionEnabled(nextProps)) {\n        return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);\n      }\n      return true;\n    }\n  }, {\n    key: \"_triggerTransition\",\n    value: function _triggerTransition(startProps, endProps) {\n      utils_assert_assert(this._isTransitionEnabled(endProps));\n      if (this._animationFrame) {\n        cancelAnimationFrame(this._animationFrame);\n      }\n      var transitionInterpolator = endProps.transitionInterpolator;\n      var duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;\n      if (duration === 0) {\n        return;\n      }\n      var initialProps = endProps.transitionInterpolator.initializeProps(startProps, endProps);\n      var interactionState = {\n        inTransition: true,\n        isZooming: startProps.zoom !== endProps.zoom,\n        isPanning: startProps.longitude !== endProps.longitude || startProps.latitude !== endProps.latitude,\n        isRotating: startProps.bearing !== endProps.bearing || startProps.pitch !== endProps.pitch\n      };\n      this.state = {\n        duration: duration,\n        easing: endProps.transitionEasing,\n        interpolator: endProps.transitionInterpolator,\n        interruption: endProps.transitionInterruption,\n        startTime: this.time(),\n        startProps: initialProps.start,\n        endProps: initialProps.end,\n        animation: null,\n        propsInTransition: {}\n      };\n      this._onTransitionFrame();\n      this.onStateChange(interactionState);\n    }\n  }, {\n    key: \"_endTransition\",\n    value: function _endTransition() {\n      if (this._animationFrame) {\n        cancelAnimationFrame(this._animationFrame);\n        this._animationFrame = null;\n      }\n      this.onStateChange({\n        inTransition: false,\n        isZooming: false,\n        isPanning: false,\n        isRotating: false\n      });\n    }\n  }, {\n    key: \"_updateViewport\",\n    value: function _updateViewport() {\n      var currentTime = this.time();\n      var _this$state = this.state,\n        startTime = _this$state.startTime,\n        duration = _this$state.duration,\n        easing = _this$state.easing,\n        interpolator = _this$state.interpolator,\n        startProps = _this$state.startProps,\n        endProps = _this$state.endProps;\n      var shouldEnd = false;\n      var t = (currentTime - startTime) / duration;\n      if (t >= 1) {\n        t = 1;\n        shouldEnd = true;\n      }\n      t = easing(t);\n      var viewport = interpolator.interpolateProps(startProps, endProps, t);\n      var mapState = new MapState(Object.assign({}, this.props, viewport));\n      this.state.propsInTransition = mapState.getViewportProps();\n      this.onViewportChange(this.state.propsInTransition, this.props);\n      if (shouldEnd) {\n        this._endTransition();\n        this.props.onTransitionEnd();\n      }\n    }\n  }]);\n  return TransitionManager;\n}();\n_defineProperty(TransitionManager, \"defaultProps\", DEFAULT_PROPS);\n\n// EXTERNAL MODULE: ./node_modules/hammerjs/hammer.js\nvar hammer = __webpack_require__(75645);\n;// ./node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js\n/**\n * This file contains overrides the default\n * hammer.js functions to add our own utility\n */\n/* eslint-disable */\n/* Hammer.js constants */\nconst INPUT_START = 1;\nconst INPUT_MOVE = 2;\nconst INPUT_END = 4;\nconst MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\n/**\n * Helper function that returns true if any element in an array meets given criteria.\n * Because older browsers do not support `Array.prototype.some`\n * @params array {Array}\n * @params predict {Function}\n */\nfunction some(array, predict) {\n  for (let i = 0; i < array.length; i++) {\n    if (predict(array[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n/* eslint-disable no-invalid-this */\nfunction enhancePointerEventInput(PointerEventInput) {\n  const oldHandler = PointerEventInput.prototype.handler;\n  // overrides PointerEventInput.handler to accept right mouse button\n  PointerEventInput.prototype.handler = function handler(ev) {\n    const store = this.store;\n    // Allow non-left mouse buttons through\n    if (ev.button > 0 && ev.type === 'pointerdown') {\n      if (!some(store, e => e.pointerId === ev.pointerId)) {\n        store.push(ev);\n      }\n    }\n    oldHandler.call(this, ev);\n  };\n}\n// overrides MouseInput.handler to accept right mouse button\nfunction enhanceMouseInput(MouseInput) {\n  MouseInput.prototype.handler = function handler(ev) {\n    let eventType = MOUSE_INPUT_MAP[ev.type];\n    // on start we want to have the mouse button down\n    if (eventType & INPUT_START && ev.button >= 0) {\n      this.pressed = true;\n    }\n    if (eventType & INPUT_MOVE && ev.buttons === 0) {\n      eventType = INPUT_END;\n    }\n    // mouse must be down\n    if (!this.pressed) {\n      return;\n    }\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: 'mouse',\n      srcEvent: ev\n    });\n  };\n}\n;// ./node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js\n\n\nenhancePointerEventInput(hammer.PointerEventInput);\nenhanceMouseInput(hammer.MouseInput);\nconst Manager = hammer.Manager;\n/* harmony default export */ var hammer_browser = (hammer);\n;// ./node_modules/mjolnir.js/dist/esm/inputs/input.js\nclass Input {\n  constructor(element, callback, options) {\n    this.element = element;\n    this.callback = callback;\n    this.options = {\n      enable: true,\n      ...options\n    };\n  }\n}\n;// ./node_modules/mjolnir.js/dist/esm/constants.js\n\n// This module contains constants that must be conditionally required\n// due to `window`/`document` references downstream.\nconst RECOGNIZERS = hammer_browser ? [[hammer_browser.Pan, {\n  event: 'tripan',\n  pointers: 3,\n  threshold: 0,\n  enable: false\n}], [hammer_browser.Rotate, {\n  enable: false\n}], [hammer_browser.Pinch, {\n  enable: false\n}], [hammer_browser.Swipe, {\n  enable: false\n}], [hammer_browser.Pan, {\n  threshold: 0,\n  enable: false\n}], [hammer_browser.Press, {\n  enable: false\n}], [hammer_browser.Tap, {\n  event: 'doubletap',\n  taps: 2,\n  enable: false\n}],\n// TODO - rename to 'tap' and 'singletap' in the next major release\n[hammer_browser.Tap, {\n  event: 'anytap',\n  enable: false\n}], [hammer_browser.Tap, {\n  enable: false\n}]] : null;\n// Recognize the following gestures even if a given recognizer succeeds\nconst RECOGNIZER_COMPATIBLE_MAP = {\n  tripan: ['rotate', 'pinch', 'pan'],\n  rotate: ['pinch'],\n  pinch: ['pan'],\n  pan: ['press', 'doubletap', 'anytap', 'tap'],\n  doubletap: ['anytap'],\n  anytap: ['tap']\n};\n// Recognize the folling gestures only if a given recognizer fails\nconst RECOGNIZER_FALLBACK_MAP = {\n  doubletap: ['tap']\n};\n/**\n * Only one set of basic input events will be fired by Hammer.js:\n * either pointer, touch, or mouse, depending on system support.\n * In order to enable an application to be agnostic of system support,\n * alias basic input events into \"classes\" of events: down, move, and up.\n * See `_onBasicInput()` for usage of these aliases.\n */\nconst BASIC_EVENT_ALIASES = {\n  pointerdown: 'pointerdown',\n  pointermove: 'pointermove',\n  pointerup: 'pointerup',\n  touchstart: 'pointerdown',\n  touchmove: 'pointermove',\n  touchend: 'pointerup',\n  mousedown: 'pointerdown',\n  mousemove: 'pointermove',\n  mouseup: 'pointerup'\n};\nconst INPUT_EVENT_TYPES = {\n  KEY_EVENTS: ['keydown', 'keyup'],\n  MOUSE_EVENTS: ['mousedown', 'mousemove', 'mouseup', 'mouseover', 'mouseout', 'mouseleave'],\n  WHEEL_EVENTS: [\n  // Chrome, Safari\n  'wheel',\n  // IE\n  'mousewheel']\n};\n/**\n * \"Gestural\" events are those that have semantic meaning beyond the basic input event,\n * e.g. a click or tap is a sequence of `down` and `up` events with no `move` event in between.\n * Hammer.js handles these with its Recognizer system;\n * this block maps event names to the Recognizers required to detect the events.\n */\nconst EVENT_RECOGNIZER_MAP = {\n  tap: 'tap',\n  anytap: 'anytap',\n  doubletap: 'doubletap',\n  press: 'press',\n  pinch: 'pinch',\n  pinchin: 'pinch',\n  pinchout: 'pinch',\n  pinchstart: 'pinch',\n  pinchmove: 'pinch',\n  pinchend: 'pinch',\n  pinchcancel: 'pinch',\n  rotate: 'rotate',\n  rotatestart: 'rotate',\n  rotatemove: 'rotate',\n  rotateend: 'rotate',\n  rotatecancel: 'rotate',\n  tripan: 'tripan',\n  tripanstart: 'tripan',\n  tripanmove: 'tripan',\n  tripanup: 'tripan',\n  tripandown: 'tripan',\n  tripanleft: 'tripan',\n  tripanright: 'tripan',\n  tripanend: 'tripan',\n  tripancancel: 'tripan',\n  pan: 'pan',\n  panstart: 'pan',\n  panmove: 'pan',\n  panup: 'pan',\n  pandown: 'pan',\n  panleft: 'pan',\n  panright: 'pan',\n  panend: 'pan',\n  pancancel: 'pan',\n  swipe: 'swipe',\n  swipeleft: 'swipe',\n  swiperight: 'swipe',\n  swipeup: 'swipe',\n  swipedown: 'swipe'\n};\n/**\n * Map gestural events typically provided by browsers\n * that are not reported in 'hammer.input' events\n * to corresponding Hammer.js gestures.\n */\nconst GESTURE_EVENT_ALIASES = {\n  click: 'tap',\n  anyclick: 'anytap',\n  dblclick: 'doubletap',\n  mousedown: 'pointerdown',\n  mousemove: 'pointermove',\n  mouseup: 'pointerup',\n  mouseover: 'pointerover',\n  mouseout: 'pointerout',\n  mouseleave: 'pointerleave'\n};\n;// ./node_modules/mjolnir.js/dist/esm/utils/globals.js\n// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global'\n/* global window, global, document, navigator */\nconst userAgent = typeof navigator !== 'undefined' && navigator.userAgent ? navigator.userAgent.toLowerCase() : '';\nconst globals_window_ = typeof window !== 'undefined' ? window : __webpack_require__.g;\nconst globals_global_ = typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : window;\nconst globals_document_ = typeof document !== 'undefined' ? document : {};\n\n/*\n * Detect whether passive option is supported by the current browser.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n   #Safely_detecting_option_support\n */\nlet passiveSupported = false;\n/* eslint-disable accessor-pairs, no-empty */\ntry {\n  const options = {\n    // This function will be called when the browser\n    // attempts to access the passive property.\n    get passive() {\n      passiveSupported = true;\n      return true;\n    }\n  };\n  globals_window_.addEventListener('test', null, options);\n  globals_window_.removeEventListener('test', null);\n} catch (err) {\n  passiveSupported = false;\n}\n\n;// ./node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js\n\n\n\nconst firefox = userAgent.indexOf('firefox') !== -1;\nconst {\n  WHEEL_EVENTS\n} = INPUT_EVENT_TYPES;\nconst EVENT_TYPE = 'wheel';\n// Constants for normalizing input delta\nconst WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;\nconst WHEEL_DELTA_PER_LINE = 40;\n// Slow down zoom if shift key is held for more precise zooming\nconst SHIFT_MULTIPLIER = 0.25;\nclass WheelInput extends Input {\n  constructor(element, callback, options) {\n    super(element, callback, options);\n    /* eslint-disable complexity, max-statements */\n    this.handleEvent = event => {\n      if (!this.options.enable) {\n        return;\n      }\n      let value = event.deltaY;\n      if (globals_window_.WheelEvent) {\n        // Firefox doubles the values on retina screens...\n        if (firefox && event.deltaMode === globals_window_.WheelEvent.DOM_DELTA_PIXEL) {\n          value /= globals_window_.devicePixelRatio;\n        }\n        if (event.deltaMode === globals_window_.WheelEvent.DOM_DELTA_LINE) {\n          value *= WHEEL_DELTA_PER_LINE;\n        }\n      }\n      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {\n        // This one is definitely a mouse wheel event.\n        // Normalize this value to match trackpad.\n        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);\n      }\n      if (event.shiftKey && value) {\n        value = value * SHIFT_MULTIPLIER;\n      }\n      this.callback({\n        type: EVENT_TYPE,\n        center: {\n          x: event.clientX,\n          y: event.clientY\n        },\n        delta: -value,\n        srcEvent: event,\n        pointerType: 'mouse',\n        target: event.target\n      });\n    };\n    this.events = (this.options.events || []).concat(WHEEL_EVENTS);\n    this.events.forEach(event => element.addEventListener(event, this.handleEvent, passiveSupported ? {\n      passive: false\n    } : false));\n  }\n  destroy() {\n    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n  }\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType, enabled) {\n    if (eventType === EVENT_TYPE) {\n      this.options.enable = enabled;\n    }\n  }\n}\n;// ./node_modules/mjolnir.js/dist/esm/inputs/move-input.js\n\n\nconst {\n  MOUSE_EVENTS\n} = INPUT_EVENT_TYPES;\nconst MOVE_EVENT_TYPE = 'pointermove';\nconst OVER_EVENT_TYPE = 'pointerover';\nconst OUT_EVENT_TYPE = 'pointerout';\nconst ENTER_EVENT_TYPE = 'pointerenter';\nconst LEAVE_EVENT_TYPE = 'pointerleave';\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\nclass MoveInput extends Input {\n  constructor(element, callback, options) {\n    super(element, callback, options);\n    this.handleEvent = event => {\n      this.handleOverEvent(event);\n      this.handleOutEvent(event);\n      this.handleEnterEvent(event);\n      this.handleLeaveEvent(event);\n      this.handleMoveEvent(event);\n    };\n    this.pressed = false;\n    const {\n      enable\n    } = this.options;\n    this.enableMoveEvent = enable;\n    this.enableLeaveEvent = enable;\n    this.enableEnterEvent = enable;\n    this.enableOutEvent = enable;\n    this.enableOverEvent = enable;\n    this.events = (this.options.events || []).concat(MOUSE_EVENTS);\n    this.events.forEach(event => element.addEventListener(event, this.handleEvent));\n  }\n  destroy() {\n    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n  }\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType, enabled) {\n    if (eventType === MOVE_EVENT_TYPE) {\n      this.enableMoveEvent = enabled;\n    }\n    if (eventType === OVER_EVENT_TYPE) {\n      this.enableOverEvent = enabled;\n    }\n    if (eventType === OUT_EVENT_TYPE) {\n      this.enableOutEvent = enabled;\n    }\n    if (eventType === ENTER_EVENT_TYPE) {\n      this.enableEnterEvent = enabled;\n    }\n    if (eventType === LEAVE_EVENT_TYPE) {\n      this.enableLeaveEvent = enabled;\n    }\n  }\n  handleOverEvent(event) {\n    if (this.enableOverEvent) {\n      if (event.type === 'mouseover') {\n        this._emit(OVER_EVENT_TYPE, event);\n      }\n    }\n  }\n  handleOutEvent(event) {\n    if (this.enableOutEvent) {\n      if (event.type === 'mouseout') {\n        this._emit(OUT_EVENT_TYPE, event);\n      }\n    }\n  }\n  handleEnterEvent(event) {\n    if (this.enableEnterEvent) {\n      if (event.type === 'mouseenter') {\n        this._emit(ENTER_EVENT_TYPE, event);\n      }\n    }\n  }\n  handleLeaveEvent(event) {\n    if (this.enableLeaveEvent) {\n      if (event.type === 'mouseleave') {\n        this._emit(LEAVE_EVENT_TYPE, event);\n      }\n    }\n  }\n  handleMoveEvent(event) {\n    if (this.enableMoveEvent) {\n      switch (event.type) {\n        case 'mousedown':\n          if (event.button >= 0) {\n            // Button is down\n            this.pressed = true;\n          }\n          break;\n        case 'mousemove':\n          // Move events use `bottons` to track the button being pressed\n          if (event.buttons === 0) {\n            // Button is not down\n            this.pressed = false;\n          }\n          if (!this.pressed) {\n            // Drag events are emitted by hammer already\n            // we just need to emit the move event on hover\n            this._emit(MOVE_EVENT_TYPE, event);\n          }\n          break;\n        case 'mouseup':\n          this.pressed = false;\n          break;\n        default:\n      }\n    }\n  }\n  _emit(type, event) {\n    this.callback({\n      type,\n      center: {\n        x: event.clientX,\n        y: event.clientY\n      },\n      srcEvent: event,\n      pointerType: 'mouse',\n      target: event.target\n    });\n  }\n}\n;// ./node_modules/mjolnir.js/dist/esm/inputs/key-input.js\n\n\nconst {\n  KEY_EVENTS\n} = INPUT_EVENT_TYPES;\nconst DOWN_EVENT_TYPE = 'keydown';\nconst UP_EVENT_TYPE = 'keyup';\nclass KeyInput extends Input {\n  constructor(element, callback, options) {\n    super(element, callback, options);\n    this.handleEvent = event => {\n      // Ignore if focused on text input\n      const targetElement = event.target || event.srcElement;\n      if (targetElement.tagName === 'INPUT' && targetElement.type === 'text' || targetElement.tagName === 'TEXTAREA') {\n        return;\n      }\n      if (this.enableDownEvent && event.type === 'keydown') {\n        this.callback({\n          type: DOWN_EVENT_TYPE,\n          srcEvent: event,\n          key: event.key,\n          target: event.target\n        });\n      }\n      if (this.enableUpEvent && event.type === 'keyup') {\n        this.callback({\n          type: UP_EVENT_TYPE,\n          srcEvent: event,\n          key: event.key,\n          target: event.target\n        });\n      }\n    };\n    this.enableDownEvent = this.options.enable;\n    this.enableUpEvent = this.options.enable;\n    this.events = (this.options.events || []).concat(KEY_EVENTS);\n    element.tabIndex = this.options.tabIndex || 0;\n    element.style.outline = 'none';\n    this.events.forEach(event => element.addEventListener(event, this.handleEvent));\n  }\n  destroy() {\n    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n  }\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType, enabled) {\n    if (eventType === DOWN_EVENT_TYPE) {\n      this.enableDownEvent = enabled;\n    }\n    if (eventType === UP_EVENT_TYPE) {\n      this.enableUpEvent = enabled;\n    }\n  }\n}\n;// ./node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js\n\nconst contextmenu_input_EVENT_TYPE = 'contextmenu';\nclass ContextmenuInput extends Input {\n  constructor(element, callback, options) {\n    super(element, callback, options);\n    this.handleEvent = event => {\n      if (!this.options.enable) {\n        return;\n      }\n      this.callback({\n        type: contextmenu_input_EVENT_TYPE,\n        center: {\n          x: event.clientX,\n          y: event.clientY\n        },\n        srcEvent: event,\n        pointerType: 'mouse',\n        target: event.target\n      });\n    };\n    element.addEventListener('contextmenu', this.handleEvent);\n  }\n  destroy() {\n    this.element.removeEventListener('contextmenu', this.handleEvent);\n  }\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType, enabled) {\n    if (eventType === contextmenu_input_EVENT_TYPE) {\n      this.options.enable = enabled;\n    }\n  }\n}\n;// ./node_modules/mjolnir.js/dist/esm/utils/event-utils.js\n/* Constants */\nconst DOWN_EVENT = 1;\nconst MOVE_EVENT = 2;\nconst UP_EVENT = 4;\nconst event_utils_MOUSE_EVENTS = {\n  pointerdown: DOWN_EVENT,\n  pointermove: MOVE_EVENT,\n  pointerup: UP_EVENT,\n  mousedown: DOWN_EVENT,\n  mousemove: MOVE_EVENT,\n  mouseup: UP_EVENT\n};\n// MouseEvent.button https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\nconst MOUSE_EVENT_BUTTON_LEFT = 0;\nconst MOUSE_EVENT_BUTTON_MIDDLE = 1;\nconst MOUSE_EVENT_BUTTON_RIGHT = 2;\n// MouseEvent.buttons https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\nconst MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;\nconst MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;\nconst MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;\n/**\n * Extract the involved mouse button\n */\nfunction whichButtons(event) {\n  const eventType = event_utils_MOUSE_EVENTS[event.srcEvent.type];\n  if (!eventType) {\n    // Not a mouse evet\n    return null;\n  }\n  const {\n    buttons,\n    button\n  } = event.srcEvent;\n  let leftButton = false;\n  let middleButton = false;\n  let rightButton = false;\n  if (eventType === MOVE_EVENT) {\n    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);\n    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);\n    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);\n  } else {\n    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;\n    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;\n    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;\n  }\n  return {\n    leftButton,\n    middleButton,\n    rightButton\n  };\n}\n/**\n * Calculate event position relative to the root element\n */\nfunction getOffsetPosition(event, rootElement) {\n  const center = event.center;\n  // `center` is a hammer.js event property\n  if (!center) {\n    // Not a gestural event\n    return null;\n  }\n  const rect = rootElement.getBoundingClientRect();\n  // Fix scale for map affected by a CSS transform.\n  // See https://stackoverflow.com/a/26893663/3528533\n  const scaleX = rect.width / rootElement.offsetWidth || 1;\n  const scaleY = rect.height / rootElement.offsetHeight || 1;\n  // Calculate center relative to the root element\n  const offsetCenter = {\n    x: (center.x - rect.left - rootElement.clientLeft) / scaleX,\n    y: (center.y - rect.top - rootElement.clientTop) / scaleY\n  };\n  return {\n    center,\n    offsetCenter\n  };\n}\n;// ./node_modules/mjolnir.js/dist/esm/utils/event-registrar.js\n\nconst DEFAULT_OPTIONS = {\n  srcElement: 'root',\n  priority: 0\n};\nclass EventRegistrar {\n  constructor(eventManager) {\n    /**\n     * Handles hammerjs event\n     */\n    this.handleEvent = event => {\n      if (this.isEmpty()) {\n        return;\n      }\n      const mjolnirEvent = this._normalizeEvent(event);\n      let target = event.srcEvent.target;\n      while (target && target !== mjolnirEvent.rootElement) {\n        this._emit(mjolnirEvent, target);\n        if (mjolnirEvent.handled) {\n          return;\n        }\n        target = target.parentNode;\n      }\n      this._emit(mjolnirEvent, 'root');\n    };\n    this.eventManager = eventManager;\n    this.handlers = [];\n    // Element -> handler map\n    this.handlersByElement = new Map();\n    this._active = false;\n  }\n  // Returns true if there are no non-passive handlers\n  isEmpty() {\n    return !this._active;\n  }\n  add(type, handler, options) {\n    let once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let passive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const {\n      handlers,\n      handlersByElement\n    } = this;\n    let opts = DEFAULT_OPTIONS;\n    if (typeof options === 'string' || options && options.addEventListener) {\n      // is DOM element, backward compatibility\n      // @ts-ignore\n      opts = {\n        ...DEFAULT_OPTIONS,\n        srcElement: options\n      };\n    } else if (options) {\n      opts = {\n        ...DEFAULT_OPTIONS,\n        ...options\n      };\n    }\n    let entries = handlersByElement.get(opts.srcElement);\n    if (!entries) {\n      entries = [];\n      handlersByElement.set(opts.srcElement, entries);\n    }\n    const entry = {\n      type,\n      handler,\n      srcElement: opts.srcElement,\n      priority: opts.priority\n    };\n    if (once) {\n      entry.once = true;\n    }\n    if (passive) {\n      entry.passive = true;\n    }\n    handlers.push(entry);\n    this._active = this._active || !entry.passive;\n    // Sort handlers by descending priority\n    // Handlers with the same priority are excuted in the order of registration\n    let insertPosition = entries.length - 1;\n    while (insertPosition >= 0) {\n      if (entries[insertPosition].priority >= entry.priority) {\n        break;\n      }\n      insertPosition--;\n    }\n    entries.splice(insertPosition + 1, 0, entry);\n  }\n  remove(type, handler) {\n    const {\n      handlers,\n      handlersByElement\n    } = this;\n    for (let i = handlers.length - 1; i >= 0; i--) {\n      const entry = handlers[i];\n      if (entry.type === type && entry.handler === handler) {\n        handlers.splice(i, 1);\n        const entries = handlersByElement.get(entry.srcElement);\n        entries.splice(entries.indexOf(entry), 1);\n        if (entries.length === 0) {\n          handlersByElement.delete(entry.srcElement);\n        }\n      }\n    }\n    this._active = handlers.some(entry => !entry.passive);\n  }\n  /**\n   * Invoke handlers on a particular element\n   */\n  _emit(event, srcElement) {\n    const entries = this.handlersByElement.get(srcElement);\n    if (entries) {\n      let immediatePropagationStopped = false;\n      // Prevents the current event from bubbling up\n      const stopPropagation = () => {\n        event.handled = true;\n      };\n      // Prevent any remaining listeners from being called\n      const stopImmediatePropagation = () => {\n        event.handled = true;\n        immediatePropagationStopped = true;\n      };\n      const entriesToRemove = [];\n      for (let i = 0; i < entries.length; i++) {\n        const {\n          type,\n          handler,\n          once\n        } = entries[i];\n        handler({\n          ...event,\n          // @ts-ignore\n          type,\n          stopPropagation,\n          stopImmediatePropagation\n        });\n        if (once) {\n          entriesToRemove.push(entries[i]);\n        }\n        if (immediatePropagationStopped) {\n          break;\n        }\n      }\n      for (let i = 0; i < entriesToRemove.length; i++) {\n        const {\n          type,\n          handler\n        } = entriesToRemove[i];\n        this.remove(type, handler);\n      }\n    }\n  }\n  /**\n   * Normalizes hammerjs and custom events to have predictable fields.\n   */\n  _normalizeEvent(event) {\n    const rootElement = this.eventManager.getElement();\n    return {\n      ...event,\n      ...whichButtons(event),\n      ...getOffsetPosition(event, rootElement),\n      preventDefault: () => {\n        event.srcEvent.preventDefault();\n      },\n      stopImmediatePropagation: null,\n      stopPropagation: null,\n      handled: false,\n      rootElement\n    };\n  }\n}\n;// ./node_modules/mjolnir.js/dist/esm/event-manager.js\n\n\n\n\n\n\n\nconst event_manager_DEFAULT_OPTIONS = {\n  // event handlers\n  events: null,\n  // custom recognizers\n  recognizers: null,\n  recognizerOptions: {},\n  // Manager class\n  Manager: Manager,\n  // allow browser default touch action\n  // https://github.com/uber/react-map-gl/issues/506\n  touchAction: 'none',\n  tabIndex: 0\n};\n// Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\nclass EventManager {\n  constructor() {\n    let element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n    /**\n     * Handle basic events using the 'hammer.input' Hammer.js API:\n     * Before running Recognizers, Hammer emits a 'hammer.input' event\n     * with the basic event info. This function emits all basic events\n     * aliased to the \"class\" of event received.\n     * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n     */\n    this._onBasicInput = event => {\n      const {\n        srcEvent\n      } = event;\n      const alias = BASIC_EVENT_ALIASES[srcEvent.type];\n      if (alias) {\n        // fire all events aliased to srcEvent.type\n        this.manager.emit(alias, event);\n      }\n    };\n    /**\n     * Handle events not supported by Hammer.js,\n     * and pipe back out through same (Hammer) channel used by other events.\n     */\n    this._onOtherEvent = event => {\n      // console.log('onotherevent', event.type, event)\n      this.manager.emit(event.type, event);\n    };\n    this.options = {\n      ...event_manager_DEFAULT_OPTIONS,\n      ...options\n    };\n    this.events = new Map();\n    this.setElement(element);\n    // Register all passed events.\n    const {\n      events\n    } = this.options;\n    if (events) {\n      this.on(events);\n    }\n  }\n  getElement() {\n    return this.element;\n  }\n  setElement(element) {\n    if (this.element) {\n      // unregister all events\n      this.destroy();\n    }\n    this.element = element;\n    if (!element) {\n      return;\n    }\n    const {\n      options\n    } = this;\n    const ManagerClass = options.Manager;\n    this.manager = new ManagerClass(element, {\n      touchAction: options.touchAction,\n      recognizers: options.recognizers || RECOGNIZERS\n    }).on('hammer.input', this._onBasicInput);\n    if (!options.recognizers) {\n      // Set default recognize withs\n      // http://hammerjs.github.io/recognize-with/\n      Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(name => {\n        const recognizer = this.manager.get(name);\n        if (recognizer) {\n          RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {\n            recognizer.recognizeWith(otherName);\n          });\n        }\n      });\n    }\n    // Set recognizer options\n    for (const recognizerName in options.recognizerOptions) {\n      const recognizer = this.manager.get(recognizerName);\n      if (recognizer) {\n        const recognizerOption = options.recognizerOptions[recognizerName];\n        // `enable` is managed by the event registrations\n        delete recognizerOption.enable;\n        recognizer.set(recognizerOption);\n      }\n    }\n    // Handle events not handled by Hammer.js:\n    // - mouse wheel\n    // - pointer/touch/mouse move\n    this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.moveInput = new MoveInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.keyInput = new KeyInput(element, this._onOtherEvent, {\n      enable: false,\n      tabIndex: options.tabIndex\n    });\n    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    // Register all existing events\n    for (const [eventAlias, eventRegistrar] of this.events) {\n      if (!eventRegistrar.isEmpty()) {\n        // Enable recognizer for this event.\n        this._toggleRecognizer(eventRegistrar.recognizerName, true);\n        this.manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n  }\n  // Tear down internal event management implementations.\n  destroy() {\n    if (this.element) {\n      // wheelInput etc. are created in setElement() and therefore\n      // cannot exist if there is no element\n      this.wheelInput.destroy();\n      this.moveInput.destroy();\n      this.keyInput.destroy();\n      this.contextmenuInput.destroy();\n      this.manager.destroy();\n      this.wheelInput = null;\n      this.moveInput = null;\n      this.keyInput = null;\n      this.contextmenuInput = null;\n      this.manager = null;\n      this.element = null;\n    }\n  }\n  /** Register an event handler function to be called on `event` */\n  on(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false);\n  }\n  once(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, true);\n  }\n  watch(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false, true);\n  }\n  off(event, handler) {\n    this._removeEventHandler(event, handler);\n  }\n  /*\n   * Enable/disable recognizer for the given event\n   */\n  _toggleRecognizer(name, enabled) {\n    const {\n      manager\n    } = this;\n    if (!manager) {\n      return;\n    }\n    const recognizer = manager.get(name);\n    // @ts-ignore\n    if (recognizer && recognizer.options.enable !== enabled) {\n      recognizer.set({\n        enable: enabled\n      });\n      const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];\n      if (fallbackRecognizers && !this.options.recognizers) {\n        // Set default require failures\n        // http://hammerjs.github.io/require-failure/\n        fallbackRecognizers.forEach(otherName => {\n          const otherRecognizer = manager.get(otherName);\n          if (enabled) {\n            // Wait for this recognizer to fail\n            otherRecognizer.requireFailure(name);\n            /**\n             * This seems to be a bug in hammerjs:\n             * requireFailure() adds both ways\n             * dropRequireFailure() only drops one way\n             * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/\n               recognizer-constructor.js#L136\n             */\n            recognizer.dropRequireFailure(otherName);\n          } else {\n            // Do not wait for this recognizer to fail\n            otherRecognizer.dropRequireFailure(name);\n          }\n        });\n      }\n    }\n    this.wheelInput.enableEventType(name, enabled);\n    this.moveInput.enableEventType(name, enabled);\n    this.keyInput.enableEventType(name, enabled);\n    this.contextmenuInput.enableEventType(name, enabled);\n  }\n  /**\n   * Process the event registration for a single event + handler.\n   */\n  _addEventHandler(event, handler, opts, once, passive) {\n    if (typeof event !== 'string') {\n      // @ts-ignore\n      opts = handler;\n      // If `event` is a map, call `on()` for each entry.\n      for (const eventName in event) {\n        this._addEventHandler(eventName, event[eventName], opts, once, passive);\n      }\n      return;\n    }\n    const {\n      manager,\n      events\n    } = this;\n    // Alias to a recognized gesture as necessary.\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n    let eventRegistrar = events.get(eventAlias);\n    if (!eventRegistrar) {\n      eventRegistrar = new EventRegistrar(this);\n      events.set(eventAlias, eventRegistrar);\n      // Enable recognizer for this event.\n      eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;\n      // Listen to the event\n      if (manager) {\n        manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n    eventRegistrar.add(event, handler, opts, once, passive);\n    if (!eventRegistrar.isEmpty()) {\n      this._toggleRecognizer(eventRegistrar.recognizerName, true);\n    }\n  }\n  /**\n   * Process the event deregistration for a single event + handler.\n   */\n  _removeEventHandler(event, handler) {\n    if (typeof event !== 'string') {\n      // If `event` is a map, call `off()` for each entry.\n      for (const eventName in event) {\n        this._removeEventHandler(eventName, event[eventName]);\n      }\n      return;\n    }\n    const {\n      events\n    } = this;\n    // Alias to a recognized gesture as necessary.\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n    const eventRegistrar = events.get(eventAlias);\n    if (!eventRegistrar) {\n      return;\n    }\n    eventRegistrar.remove(event, handler);\n    if (eventRegistrar.isEmpty()) {\n      const {\n        recognizerName\n      } = eventRegistrar;\n      // Disable recognizer if no more handlers are attached to its events\n      let isRecognizerUsed = false;\n      for (const eh of events.values()) {\n        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n          isRecognizerUsed = true;\n          break;\n        }\n      }\n      if (!isRecognizerUsed) {\n        this._toggleRecognizer(recognizerName, false);\n      }\n    }\n  }\n}\n;// ./node_modules/mjolnir.js/dist/esm/index.js\n\n;// ./node_modules/react-map-gl/dist/esm/utils/map-controller.js\n\n\n\nfunction map_controller_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction map_controller_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      map_controller_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      map_controller_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\nvar NO_TRANSITION_PROPS = {\n  transitionDuration: 0\n};\nvar LINEAR_TRANSITION_PROPS = {\n  transitionDuration: 300,\n  transitionEasing: function transitionEasing(t) {\n    return t;\n  },\n  transitionInterpolator: new LinearInterpolator(),\n  transitionInterruption: TRANSITION_EVENTS.BREAK\n};\nvar DEFAULT_INERTIA = 300;\nvar INERTIA_EASING = function INERTIA_EASING(t) {\n  return 1 - (1 - t) * (1 - t);\n};\nvar EVENT_TYPES = {\n  WHEEL: ['wheel'],\n  PAN: ['panstart', 'panmove', 'panend'],\n  PINCH: ['pinchstart', 'pinchmove', 'pinchend'],\n  TRIPLE_PAN: ['tripanstart', 'tripanmove', 'tripanend'],\n  DOUBLE_TAP: ['doubletap'],\n  KEYBOARD: ['keydown']\n};\nvar MapController = function () {\n  function MapController() {\n    var _this = this;\n    _classCallCheck(this, MapController);\n    _defineProperty(this, \"events\", []);\n    _defineProperty(this, \"scrollZoom\", true);\n    _defineProperty(this, \"dragPan\", true);\n    _defineProperty(this, \"dragRotate\", true);\n    _defineProperty(this, \"doubleClickZoom\", true);\n    _defineProperty(this, \"touchZoom\", true);\n    _defineProperty(this, \"touchRotate\", false);\n    _defineProperty(this, \"keyboard\", true);\n    _defineProperty(this, \"_interactionState\", {\n      isDragging: false\n    });\n    _defineProperty(this, \"_events\", {});\n    _defineProperty(this, \"_setInteractionState\", function (newState) {\n      Object.assign(_this._interactionState, newState);\n      if (_this.onStateChange) {\n        _this.onStateChange(_this._interactionState);\n      }\n    });\n    _defineProperty(this, \"_onTransition\", function (newViewport, oldViewport) {\n      _this.onViewportChange(newViewport, _this._interactionState, oldViewport);\n    });\n    this.handleEvent = this.handleEvent.bind(this);\n    this._transitionManager = new TransitionManager({\n      onViewportChange: this._onTransition,\n      onStateChange: this._setInteractionState\n    });\n  }\n  _createClass(MapController, [{\n    key: \"handleEvent\",\n    value: function handleEvent(event) {\n      this.mapState = this.getMapState();\n      var eventStartBlocked = this._eventStartBlocked;\n      switch (event.type) {\n        case 'panstart':\n          return eventStartBlocked ? false : this._onPanStart(event);\n        case 'panmove':\n          return this._onPan(event);\n        case 'panend':\n          return this._onPanEnd(event);\n        case 'pinchstart':\n          return eventStartBlocked ? false : this._onPinchStart(event);\n        case 'pinchmove':\n          return this._onPinch(event);\n        case 'pinchend':\n          return this._onPinchEnd(event);\n        case 'tripanstart':\n          return eventStartBlocked ? false : this._onTriplePanStart(event);\n        case 'tripanmove':\n          return this._onTriplePan(event);\n        case 'tripanend':\n          return this._onTriplePanEnd(event);\n        case 'doubletap':\n          return this._onDoubleTap(event);\n        case 'wheel':\n          return this._onWheel(event);\n        case 'keydown':\n          return this._onKeyDown(event);\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: \"getCenter\",\n    value: function getCenter(event) {\n      var _event$offsetCenter = event.offsetCenter,\n        x = _event$offsetCenter.x,\n        y = _event$offsetCenter.y;\n      return [x, y];\n    }\n  }, {\n    key: \"isFunctionKeyPressed\",\n    value: function isFunctionKeyPressed(event) {\n      var srcEvent = event.srcEvent;\n      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);\n    }\n  }, {\n    key: \"blockEvents\",\n    value: function blockEvents(timeout) {\n      var _this2 = this;\n      var timer = setTimeout(function () {\n        if (_this2._eventStartBlocked === timer) {\n          _this2._eventStartBlocked = null;\n        }\n      }, timeout);\n      this._eventStartBlocked = timer;\n    }\n  }, {\n    key: \"updateViewport\",\n    value: function updateViewport(newMapState, extraProps, interactionState) {\n      var oldViewport = this.mapState instanceof MapState ? this.mapState.getViewportProps() : this.mapState;\n      var newViewport = map_controller_objectSpread(map_controller_objectSpread({}, newMapState.getViewportProps()), extraProps);\n      var viewStateChanged = Object.keys(newViewport).some(function (key) {\n        return oldViewport[key] !== newViewport[key];\n      });\n      this._state = newMapState.getState();\n      this._setInteractionState(interactionState);\n      if (viewStateChanged) {\n        this.onViewportChange(newViewport, this._interactionState, oldViewport);\n      }\n    }\n  }, {\n    key: \"getMapState\",\n    value: function getMapState(overrides) {\n      return new MapState(map_controller_objectSpread(map_controller_objectSpread(map_controller_objectSpread({}, this.mapStateProps), this._state), overrides));\n    }\n  }, {\n    key: \"isDragging\",\n    value: function isDragging() {\n      return this._interactionState.isDragging;\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var onViewportChange = options.onViewportChange,\n        onStateChange = options.onStateChange,\n        _options$eventManager = options.eventManager,\n        eventManager = _options$eventManager === void 0 ? this.eventManager : _options$eventManager,\n        _options$isInteractiv = options.isInteractive,\n        isInteractive = _options$isInteractiv === void 0 ? true : _options$isInteractiv,\n        _options$scrollZoom = options.scrollZoom,\n        scrollZoom = _options$scrollZoom === void 0 ? this.scrollZoom : _options$scrollZoom,\n        _options$dragPan = options.dragPan,\n        dragPan = _options$dragPan === void 0 ? this.dragPan : _options$dragPan,\n        _options$dragRotate = options.dragRotate,\n        dragRotate = _options$dragRotate === void 0 ? this.dragRotate : _options$dragRotate,\n        _options$doubleClickZ = options.doubleClickZoom,\n        doubleClickZoom = _options$doubleClickZ === void 0 ? this.doubleClickZoom : _options$doubleClickZ,\n        _options$touchZoom = options.touchZoom,\n        touchZoom = _options$touchZoom === void 0 ? this.touchZoom : _options$touchZoom,\n        _options$touchRotate = options.touchRotate,\n        touchRotate = _options$touchRotate === void 0 ? this.touchRotate : _options$touchRotate,\n        _options$keyboard = options.keyboard,\n        keyboard = _options$keyboard === void 0 ? this.keyboard : _options$keyboard;\n      this.onViewportChange = onViewportChange;\n      this.onStateChange = onStateChange;\n      var prevOptions = this.mapStateProps || {};\n      var dimensionChanged = prevOptions.height !== options.height || prevOptions.width !== options.width;\n      this.mapStateProps = options;\n      if (dimensionChanged) {\n        this.mapState = prevOptions;\n        this.updateViewport(new MapState(options));\n      }\n      this._transitionManager.processViewportChange(options);\n      if (this.eventManager !== eventManager) {\n        this.eventManager = eventManager;\n        this._events = {};\n        this.toggleEvents(this.events, true);\n      }\n      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && Boolean(scrollZoom));\n      this.toggleEvents(EVENT_TYPES.PAN, isInteractive && Boolean(dragPan || dragRotate));\n      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && Boolean(touchZoom || touchRotate));\n      this.toggleEvents(EVENT_TYPES.TRIPLE_PAN, isInteractive && Boolean(touchRotate));\n      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && Boolean(doubleClickZoom));\n      this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && Boolean(keyboard));\n      this.scrollZoom = scrollZoom;\n      this.dragPan = dragPan;\n      this.dragRotate = dragRotate;\n      this.doubleClickZoom = doubleClickZoom;\n      this.touchZoom = touchZoom;\n      this.touchRotate = touchRotate;\n      this.keyboard = keyboard;\n    }\n  }, {\n    key: \"toggleEvents\",\n    value: function toggleEvents(eventNames, enabled) {\n      var _this3 = this;\n      if (this.eventManager) {\n        eventNames.forEach(function (eventName) {\n          if (_this3._events[eventName] !== enabled) {\n            _this3._events[eventName] = enabled;\n            if (enabled) {\n              _this3.eventManager.on(eventName, _this3.handleEvent);\n            } else {\n              _this3.eventManager.off(eventName, _this3.handleEvent);\n            }\n          }\n        });\n      }\n    }\n  }, {\n    key: \"_onPanStart\",\n    value: function _onPanStart(event) {\n      var pos = this.getCenter(event);\n      this._panRotate = this.isFunctionKeyPressed(event) || event.rightButton;\n      var newMapState = this._panRotate ? this.mapState.rotateStart({\n        pos: pos\n      }) : this.mapState.panStart({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isDragging: true\n      });\n      return true;\n    }\n  }, {\n    key: \"_onPan\",\n    value: function _onPan(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n      return this._panRotate ? this._onPanRotate(event) : this._onPanMove(event);\n    }\n  }, {\n    key: \"_onPanEnd\",\n    value: function _onPanEnd(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n      return this._panRotate ? this._onPanRotateEnd(event) : this._onPanMoveEnd(event);\n    }\n  }, {\n    key: \"_onPanMove\",\n    value: function _onPanMove(event) {\n      if (!this.dragPan) {\n        return false;\n      }\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.pan({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isPanning: true\n      });\n      return true;\n    }\n  }, {\n    key: \"_onPanMoveEnd\",\n    value: function _onPanMoveEnd(event) {\n      if (this.dragPan) {\n        var _this$dragPan$inertia = this.dragPan.inertia,\n          inertia = _this$dragPan$inertia === void 0 ? DEFAULT_INERTIA : _this$dragPan$inertia;\n        if (inertia && event.velocity) {\n          var pos = this.getCenter(event);\n          var endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];\n          var newControllerState = this.mapState.pan({\n            pos: endPos\n          }).panEnd();\n          this.updateViewport(newControllerState, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n            transitionDuration: inertia,\n            transitionEasing: INERTIA_EASING\n          }), {\n            isDragging: false,\n            isPanning: true\n          });\n          return true;\n        }\n      }\n      var newMapState = this.mapState.panEnd();\n      this.updateViewport(newMapState, null, {\n        isDragging: false,\n        isPanning: false\n      });\n      return true;\n    }\n  }, {\n    key: \"_onPanRotate\",\n    value: function _onPanRotate(event) {\n      if (!this.dragRotate) {\n        return false;\n      }\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.rotate({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isRotating: true\n      });\n      return true;\n    }\n  }, {\n    key: \"_onPanRotateEnd\",\n    value: function _onPanRotateEnd(event) {\n      if (this.dragRotate) {\n        var _this$dragRotate$iner = this.dragRotate.inertia,\n          inertia = _this$dragRotate$iner === void 0 ? DEFAULT_INERTIA : _this$dragRotate$iner;\n        if (inertia && event.velocity) {\n          var pos = this.getCenter(event);\n          var endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];\n          var newControllerState = this.mapState.rotate({\n            pos: endPos\n          }).rotateEnd();\n          this.updateViewport(newControllerState, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n            transitionDuration: inertia,\n            transitionEasing: INERTIA_EASING\n          }), {\n            isDragging: false,\n            isRotating: true\n          });\n          return true;\n        }\n      }\n      var newMapState = this.mapState.panEnd();\n      this.updateViewport(newMapState, null, {\n        isDragging: false,\n        isRotating: false\n      });\n      return true;\n    }\n  }, {\n    key: \"_onWheel\",\n    value: function _onWheel(event) {\n      if (!this.scrollZoom) {\n        return false;\n      }\n      var _this$scrollZoom = this.scrollZoom,\n        _this$scrollZoom$spee = _this$scrollZoom.speed,\n        speed = _this$scrollZoom$spee === void 0 ? 0.01 : _this$scrollZoom$spee,\n        _this$scrollZoom$smoo = _this$scrollZoom.smooth,\n        smooth = _this$scrollZoom$smoo === void 0 ? false : _this$scrollZoom$smoo;\n      event.preventDefault();\n      var pos = this.getCenter(event);\n      var delta = event.delta;\n      var scale = 2 / (1 + Math.exp(-Math.abs(delta * speed)));\n      if (delta < 0 && scale !== 0) {\n        scale = 1 / scale;\n      }\n      var newMapState = this.mapState.zoom({\n        pos: pos,\n        scale: scale\n      });\n      if (newMapState.getViewportProps().zoom === this.mapStateProps.zoom) {\n        return false;\n      }\n      this.updateViewport(newMapState, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n        transitionInterpolator: new LinearInterpolator({\n          around: pos\n        }),\n        transitionDuration: smooth ? 250 : 1\n      }), {\n        isPanning: true,\n        isZooming: true\n      });\n      return true;\n    }\n  }, {\n    key: \"_onPinchStart\",\n    value: function _onPinchStart(event) {\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.zoomStart({\n        pos: pos\n      }).rotateStart({\n        pos: pos\n      });\n      this._startPinchRotation = event.rotation;\n      this._lastPinchEvent = event;\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isDragging: true\n      });\n      return true;\n    }\n  }, {\n    key: \"_onPinch\",\n    value: function _onPinch(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n      if (!this.touchZoom && !this.touchRotate) {\n        return false;\n      }\n      var newMapState = this.mapState;\n      if (this.touchZoom) {\n        var scale = event.scale;\n        var pos = this.getCenter(event);\n        newMapState = newMapState.zoom({\n          pos: pos,\n          scale: scale\n        });\n      }\n      if (this.touchRotate) {\n        var rotation = event.rotation;\n        newMapState = newMapState.rotate({\n          deltaAngleX: this._startPinchRotation - rotation\n        });\n      }\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isDragging: true,\n        isPanning: Boolean(this.touchZoom),\n        isZooming: Boolean(this.touchZoom),\n        isRotating: Boolean(this.touchRotate)\n      });\n      this._lastPinchEvent = event;\n      return true;\n    }\n  }, {\n    key: \"_onPinchEnd\",\n    value: function _onPinchEnd(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n      if (this.touchZoom) {\n        var _this$touchZoom$inert = this.touchZoom.inertia,\n          inertia = _this$touchZoom$inert === void 0 ? DEFAULT_INERTIA : _this$touchZoom$inert;\n        var _lastPinchEvent = this._lastPinchEvent;\n        if (inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {\n          var pos = this.getCenter(event);\n          var _newMapState = this.mapState.rotateEnd();\n          var z = Math.log2(event.scale);\n          var velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);\n          var endScale = Math.pow(2, z + velocityZ * inertia / 2);\n          _newMapState = _newMapState.zoom({\n            pos: pos,\n            scale: endScale\n          }).zoomEnd();\n          this.updateViewport(_newMapState, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n            transitionInterpolator: new LinearInterpolator({\n              around: pos\n            }),\n            transitionDuration: inertia,\n            transitionEasing: INERTIA_EASING\n          }), {\n            isDragging: false,\n            isPanning: Boolean(this.touchZoom),\n            isZooming: Boolean(this.touchZoom),\n            isRotating: false\n          });\n          this.blockEvents(inertia);\n          return true;\n        }\n      }\n      var newMapState = this.mapState.zoomEnd().rotateEnd();\n      this._state.startPinchRotation = 0;\n      this.updateViewport(newMapState, null, {\n        isDragging: false,\n        isPanning: false,\n        isZooming: false,\n        isRotating: false\n      });\n      this._startPinchRotation = null;\n      this._lastPinchEvent = null;\n      return true;\n    }\n  }, {\n    key: \"_onTriplePanStart\",\n    value: function _onTriplePanStart(event) {\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.rotateStart({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isDragging: true\n      });\n      return true;\n    }\n  }, {\n    key: \"_onTriplePan\",\n    value: function _onTriplePan(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n      if (!this.touchRotate) {\n        return false;\n      }\n      var pos = this.getCenter(event);\n      pos[0] -= event.deltaX;\n      var newMapState = this.mapState.rotate({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isRotating: true\n      });\n      return true;\n    }\n  }, {\n    key: \"_onTriplePanEnd\",\n    value: function _onTriplePanEnd(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n      if (this.touchRotate) {\n        var _this$touchRotate$ine = this.touchRotate.inertia,\n          inertia = _this$touchRotate$ine === void 0 ? DEFAULT_INERTIA : _this$touchRotate$ine;\n        if (inertia && event.velocityY) {\n          var pos = this.getCenter(event);\n          var endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];\n          var _newMapState2 = this.mapState.rotate({\n            pos: endPos\n          });\n          this.updateViewport(_newMapState2, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n            transitionDuration: inertia,\n            transitionEasing: INERTIA_EASING\n          }), {\n            isDragging: false,\n            isRotating: true\n          });\n          this.blockEvents(inertia);\n          return false;\n        }\n      }\n      var newMapState = this.mapState.rotateEnd();\n      this.updateViewport(newMapState, null, {\n        isDragging: false,\n        isRotating: false\n      });\n      return true;\n    }\n  }, {\n    key: \"_onDoubleTap\",\n    value: function _onDoubleTap(event) {\n      if (!this.doubleClickZoom) {\n        return false;\n      }\n      var pos = this.getCenter(event);\n      var isZoomOut = this.isFunctionKeyPressed(event);\n      var newMapState = this.mapState.zoom({\n        pos: pos,\n        scale: isZoomOut ? 0.5 : 2\n      });\n      this.updateViewport(newMapState, Object.assign({}, LINEAR_TRANSITION_PROPS, {\n        transitionInterpolator: new LinearInterpolator({\n          around: pos\n        })\n      }), {\n        isZooming: true\n      });\n      return true;\n    }\n  }, {\n    key: \"_onKeyDown\",\n    value: function _onKeyDown(event) {\n      if (!this.keyboard) {\n        return false;\n      }\n      var funcKey = this.isFunctionKeyPressed(event);\n      var _this$keyboard = this.keyboard,\n        _this$keyboard$zoomSp = _this$keyboard.zoomSpeed,\n        zoomSpeed = _this$keyboard$zoomSp === void 0 ? 2 : _this$keyboard$zoomSp,\n        _this$keyboard$moveSp = _this$keyboard.moveSpeed,\n        moveSpeed = _this$keyboard$moveSp === void 0 ? 100 : _this$keyboard$moveSp,\n        _this$keyboard$rotate = _this$keyboard.rotateSpeedX,\n        rotateSpeedX = _this$keyboard$rotate === void 0 ? 15 : _this$keyboard$rotate,\n        _this$keyboard$rotate2 = _this$keyboard.rotateSpeedY,\n        rotateSpeedY = _this$keyboard$rotate2 === void 0 ? 10 : _this$keyboard$rotate2;\n      var mapStateProps = this.mapStateProps;\n      var newMapState;\n      switch (event.srcEvent.keyCode) {\n        case 189:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              zoom: mapStateProps.zoom - Math.log2(zoomSpeed) - 1\n            });\n          } else {\n            newMapState = this.getMapState({\n              zoom: mapStateProps.zoom - Math.log2(zoomSpeed)\n            });\n          }\n          break;\n        case 187:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              zoom: mapStateProps.zoom + Math.log2(zoomSpeed) + 1\n            });\n          } else {\n            newMapState = this.getMapState({\n              zoom: mapStateProps.zoom + Math.log2(zoomSpeed)\n            });\n          }\n          break;\n        case 37:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              bearing: mapStateProps.bearing - rotateSpeedX\n            });\n          } else {\n            newMapState = this.mapState.pan({\n              pos: [moveSpeed, 0],\n              startPos: [0, 0]\n            });\n          }\n          break;\n        case 39:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              bearing: mapStateProps.bearing + rotateSpeedX\n            });\n          } else {\n            newMapState = this.mapState.pan({\n              pos: [-moveSpeed, 0],\n              startPos: [0, 0]\n            });\n          }\n          break;\n        case 38:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              pitch: mapStateProps.pitch + rotateSpeedY\n            });\n          } else {\n            newMapState = this.mapState.pan({\n              pos: [0, moveSpeed],\n              startPos: [0, 0]\n            });\n          }\n          break;\n        case 40:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              pitch: mapStateProps.pitch - rotateSpeedY\n            });\n          } else {\n            newMapState = this.mapState.pan({\n              pos: [0, -moveSpeed],\n              startPos: [0, 0]\n            });\n          }\n          break;\n        default:\n          return false;\n      }\n      return this.updateViewport(newMapState, LINEAR_TRANSITION_PROPS);\n    }\n  }]);\n  return MapController;\n}();\n\n;// ./node_modules/react-map-gl/dist/esm/components/interactive-map.js\n\n\n\nfunction interactive_map_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction interactive_map_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      interactive_map_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      interactive_map_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\n\n\n\n\n\n\n\nvar interactive_map_propTypes = Object.assign({}, static_map.propTypes, {\n  maxZoom: prop_types.number,\n  minZoom: prop_types.number,\n  maxPitch: prop_types.number,\n  minPitch: prop_types.number,\n  onViewStateChange: prop_types.func,\n  onViewportChange: prop_types.func,\n  onInteractionStateChange: prop_types.func,\n  transitionDuration: prop_types.oneOfType([prop_types.number, prop_types.string]),\n  transitionInterpolator: prop_types.object,\n  transitionInterruption: prop_types.number,\n  transitionEasing: prop_types.func,\n  onTransitionStart: prop_types.func,\n  onTransitionInterrupt: prop_types.func,\n  onTransitionEnd: prop_types.func,\n  scrollZoom: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  dragPan: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  dragRotate: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  doubleClickZoom: prop_types.bool,\n  touchZoom: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  touchRotate: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  keyboard: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  onHover: prop_types.func,\n  onClick: prop_types.func,\n  onDblClick: prop_types.func,\n  onContextMenu: prop_types.func,\n  onMouseDown: prop_types.func,\n  onMouseMove: prop_types.func,\n  onMouseUp: prop_types.func,\n  onTouchStart: prop_types.func,\n  onTouchMove: prop_types.func,\n  onTouchEnd: prop_types.func,\n  onMouseEnter: prop_types.func,\n  onMouseLeave: prop_types.func,\n  onMouseOut: prop_types.func,\n  onWheel: prop_types.func,\n  touchAction: prop_types.string,\n  eventRecognizerOptions: prop_types.object,\n  clickRadius: prop_types.number,\n  interactiveLayerIds: prop_types.array,\n  getCursor: prop_types.func,\n  controller: prop_types.instanceOf(MapController)\n});\nvar getDefaultCursor = function getDefaultCursor(_ref) {\n  var isDragging = _ref.isDragging,\n    isHovering = _ref.isHovering;\n  return isDragging ? 'grabbing' : isHovering ? 'pointer' : 'grab';\n};\nvar interactive_map_defaultProps = Object.assign({}, static_map.defaultProps, MAPBOX_LIMITS, TransitionManager.defaultProps, {\n  onViewStateChange: null,\n  onViewportChange: null,\n  onClick: null,\n  onNativeClick: null,\n  onHover: null,\n  onContextMenu: function onContextMenu(event) {\n    return event.preventDefault();\n  },\n  scrollZoom: true,\n  dragPan: true,\n  dragRotate: true,\n  doubleClickZoom: true,\n  touchZoom: true,\n  touchRotate: false,\n  keyboard: true,\n  touchAction: 'none',\n  eventRecognizerOptions: {},\n  clickRadius: 0,\n  getCursor: getDefaultCursor\n});\nfunction normalizeEvent(event) {\n  if (event.lngLat || !event.offsetCenter) {\n    return event;\n  }\n  var _event$offsetCenter = event.offsetCenter,\n    x = _event$offsetCenter.x,\n    y = _event$offsetCenter.y;\n  if (!Number.isFinite(x) || !Number.isFinite(y)) {\n    return event;\n  }\n  var pos = [x, y];\n  event.point = pos;\n  if (this.map) {\n    var location = this.map.unproject(pos);\n    event.lngLat = [location.lng, location.lat];\n  }\n  return event;\n}\nfunction getFeatures(pos) {\n  var map = this.map;\n  if (!map || !pos) {\n    return null;\n  }\n  var queryParams = {};\n  var size = this.props.clickRadius;\n  if (this.props.interactiveLayerIds) {\n    queryParams.layers = this.props.interactiveLayerIds;\n  }\n  try {\n    return map.queryRenderedFeatures(size ? [[pos[0] - size, pos[1] + size], [pos[0] + size, pos[1] - size]] : pos, queryParams);\n  } catch (_unused) {\n    return null;\n  }\n}\nfunction onEvent(callbackName, event) {\n  var func = this.props[callbackName];\n  if (func) {\n    func(normalizeEvent.call(this, event));\n  }\n}\nfunction onPointerDown(event) {\n  onEvent.call(this, event.pointerType === 'touch' ? 'onTouchStart' : 'onMouseDown', event);\n}\nfunction onPointerUp(event) {\n  onEvent.call(this, event.pointerType === 'touch' ? 'onTouchEnd' : 'onMouseUp', event);\n}\nfunction onPointerMove(event) {\n  onEvent.call(this, event.pointerType === 'touch' ? 'onTouchMove' : 'onMouseMove', event);\n  if (!this.state.isDragging) {\n    var _this$props = this.props,\n      onHover = _this$props.onHover,\n      interactiveLayerIds = _this$props.interactiveLayerIds;\n    var features;\n    event = normalizeEvent.call(this, event);\n    if (interactiveLayerIds || onHover) {\n      features = getFeatures.call(this, event.point);\n    }\n    var isHovering = Boolean(interactiveLayerIds && features && features.length > 0);\n    var isEntering = isHovering && !this.state.isHovering;\n    var isExiting = !isHovering && this.state.isHovering;\n    if (onHover || isEntering) {\n      event.features = features;\n      if (onHover) {\n        onHover(event);\n      }\n    }\n    if (isEntering) {\n      onEvent.call(this, 'onMouseEnter', event);\n    }\n    if (isExiting) {\n      onEvent.call(this, 'onMouseLeave', event);\n    }\n    if (isEntering || isExiting) {\n      this.setState({\n        isHovering: isHovering\n      });\n    }\n  }\n}\nfunction onPointerClick(event) {\n  var _this$props2 = this.props,\n    onClick = _this$props2.onClick,\n    onNativeClick = _this$props2.onNativeClick,\n    onDblClick = _this$props2.onDblClick,\n    doubleClickZoom = _this$props2.doubleClickZoom;\n  var callbacks = [];\n  var isDoubleClickEnabled = onDblClick || doubleClickZoom;\n  switch (event.type) {\n    case 'anyclick':\n      callbacks.push(onNativeClick);\n      if (!isDoubleClickEnabled) {\n        callbacks.push(onClick);\n      }\n      break;\n    case 'click':\n      if (isDoubleClickEnabled) {\n        callbacks.push(onClick);\n      }\n      break;\n    default:\n  }\n  callbacks = callbacks.filter(Boolean);\n  if (callbacks.length) {\n    event = normalizeEvent.call(this, event);\n    event.features = getFeatures.call(this, event.point);\n    callbacks.forEach(function (cb) {\n      return cb(event);\n    });\n  }\n}\nfunction interactive_map_getRefHandles(staticMapRef) {\n  return {\n    getMap: staticMapRef.current && staticMapRef.current.getMap,\n    queryRenderedFeatures: staticMapRef.current && staticMapRef.current.queryRenderedFeatures\n  };\n}\nvar InteractiveMap = (0,react.forwardRef)(function (props, ref) {\n  var parentContext = (0,react.useContext)(map_context);\n  var controller = (0,react.useMemo)(function () {\n    return props.controller || new MapController();\n  }, []);\n  var eventManager = (0,react.useMemo)(function () {\n    return new EventManager(null, {\n      touchAction: props.touchAction,\n      recognizerOptions: props.eventRecognizerOptions\n    });\n  }, []);\n  var eventCanvasRef = (0,react.useRef)(null);\n  var staticMapRef = (0,react.useRef)(null);\n  var _thisRef = (0,react.useRef)({\n    width: 0,\n    height: 0,\n    state: {\n      isHovering: false,\n      isDragging: false\n    }\n  });\n  var thisRef = _thisRef.current;\n  thisRef.props = props;\n  thisRef.map = staticMapRef.current && staticMapRef.current.getMap();\n  thisRef.setState = function (newState) {\n    thisRef.state = interactive_map_objectSpread(interactive_map_objectSpread({}, thisRef.state), newState);\n    eventCanvasRef.current.style.cursor = props.getCursor(thisRef.state);\n  };\n  var inRender = true;\n  var viewportUpdateRequested;\n  var stateUpdateRequested;\n  var handleViewportChange = function handleViewportChange(viewState, interactionState, oldViewState) {\n    if (inRender) {\n      viewportUpdateRequested = [viewState, interactionState, oldViewState];\n      return;\n    }\n    var _thisRef$props = thisRef.props,\n      onViewStateChange = _thisRef$props.onViewStateChange,\n      onViewportChange = _thisRef$props.onViewportChange;\n    Object.defineProperty(viewState, 'position', {\n      get: function get() {\n        return [0, 0, getTerrainElevation(thisRef.map, viewState)];\n      }\n    });\n    if (onViewStateChange) {\n      onViewStateChange({\n        viewState: viewState,\n        interactionState: interactionState,\n        oldViewState: oldViewState\n      });\n    }\n    if (onViewportChange) {\n      onViewportChange(viewState, interactionState, oldViewState);\n    }\n  };\n  (0,react.useImperativeHandle)(ref, function () {\n    return interactive_map_getRefHandles(staticMapRef);\n  }, []);\n  var context = (0,react.useMemo)(function () {\n    return interactive_map_objectSpread(interactive_map_objectSpread({}, parentContext), {}, {\n      eventManager: eventManager,\n      container: parentContext.container || eventCanvasRef.current\n    });\n  }, [parentContext, eventCanvasRef.current]);\n  context.onViewportChange = handleViewportChange;\n  context.viewport = parentContext.viewport || getViewport(thisRef);\n  thisRef.viewport = context.viewport;\n  var handleInteractionStateChange = function handleInteractionStateChange(interactionState) {\n    var _interactionState$isD = interactionState.isDragging,\n      isDragging = _interactionState$isD === void 0 ? false : _interactionState$isD;\n    if (isDragging !== thisRef.state.isDragging) {\n      thisRef.setState({\n        isDragging: isDragging\n      });\n    }\n    if (inRender) {\n      stateUpdateRequested = interactionState;\n      return;\n    }\n    var onInteractionStateChange = thisRef.props.onInteractionStateChange;\n    if (onInteractionStateChange) {\n      onInteractionStateChange(interactionState);\n    }\n  };\n  var updateControllerOpts = function updateControllerOpts() {\n    if (thisRef.width && thisRef.height) {\n      controller.setOptions(interactive_map_objectSpread(interactive_map_objectSpread(interactive_map_objectSpread({}, thisRef.props), thisRef.props.viewState), {}, {\n        isInteractive: Boolean(thisRef.props.onViewStateChange || thisRef.props.onViewportChange),\n        onViewportChange: handleViewportChange,\n        onStateChange: handleInteractionStateChange,\n        eventManager: eventManager,\n        width: thisRef.width,\n        height: thisRef.height\n      }));\n    }\n  };\n  var onResize = function onResize(_ref2) {\n    var width = _ref2.width,\n      height = _ref2.height;\n    thisRef.width = width;\n    thisRef.height = height;\n    updateControllerOpts();\n    thisRef.props.onResize({\n      width: width,\n      height: height\n    });\n  };\n  (0,react.useEffect)(function () {\n    eventManager.setElement(eventCanvasRef.current);\n    eventManager.on({\n      pointerdown: onPointerDown.bind(thisRef),\n      pointermove: onPointerMove.bind(thisRef),\n      pointerup: onPointerUp.bind(thisRef),\n      pointerleave: onEvent.bind(thisRef, 'onMouseOut'),\n      click: onPointerClick.bind(thisRef),\n      anyclick: onPointerClick.bind(thisRef),\n      dblclick: onEvent.bind(thisRef, 'onDblClick'),\n      wheel: onEvent.bind(thisRef, 'onWheel'),\n      contextmenu: onEvent.bind(thisRef, 'onContextMenu')\n    });\n    return function () {\n      eventManager.destroy();\n    };\n  }, []);\n  use_isomorphic_layout_effect(function () {\n    if (viewportUpdateRequested) {\n      handleViewportChange.apply(void 0, (0,toConsumableArray/* default */.A)(viewportUpdateRequested));\n    }\n    if (stateUpdateRequested) {\n      handleInteractionStateChange(stateUpdateRequested);\n    }\n  });\n  updateControllerOpts();\n  var width = props.width,\n    height = props.height,\n    style = props.style,\n    getCursor = props.getCursor;\n  var eventCanvasStyle = (0,react.useMemo)(function () {\n    return interactive_map_objectSpread(interactive_map_objectSpread({\n      position: 'relative'\n    }, style), {}, {\n      width: width,\n      height: height,\n      cursor: getCursor(thisRef.state)\n    });\n  }, [style, width, height, getCursor, thisRef.state]);\n  if (!viewportUpdateRequested || !thisRef._child) {\n    thisRef._child = react.createElement(MapContextProvider, {\n      value: context\n    }, react.createElement(\"div\", {\n      key: \"event-canvas\",\n      ref: eventCanvasRef,\n      style: eventCanvasStyle\n    }, react.createElement(static_map, _extends({}, props, {\n      width: \"100%\",\n      height: \"100%\",\n      style: null,\n      onResize: onResize,\n      ref: staticMapRef\n    }))));\n  }\n  inRender = false;\n  return thisRef._child;\n});\nInteractiveMap.supported = static_map.supported;\nInteractiveMap.propTypes = interactive_map_propTypes;\nInteractiveMap.defaultProps = interactive_map_defaultProps;\n/* harmony default export */ var interactive_map = (InteractiveMap);\n;// ./node_modules/react-map-gl/dist/esm/utils/deep-equal.js\n\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (!a || !b) {\n    return false;\n  }\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b) || a.length !== b.length) {\n      return false;\n    }\n    for (var i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  } else if (Array.isArray(b)) {\n    return false;\n  }\n  if (_typeof(a) === 'object' && _typeof(b) === 'object') {\n    var aKeys = Object.keys(a);\n    var bKeys = Object.keys(b);\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n    for (var _i = 0, _aKeys = aKeys; _i < _aKeys.length; _i++) {\n      var key = _aKeys[_i];\n      if (!b.hasOwnProperty(key)) {\n        return false;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n;// ./node_modules/react-map-gl/dist/esm/components/source.js\n\n\nfunction source_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction source_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      source_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      source_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\n\n\nvar sourceCounter = 0;\nfunction createSource(map, id, props) {\n  if (map && map.style && map.style._loaded) {\n    var options = source_objectSpread({}, props);\n    delete options.id;\n    delete options.children;\n    map.addSource(id, options);\n    return map.getSource(id);\n  }\n  return null;\n}\nfunction updateSource(source, props, prevProps) {\n  utils_assert_assert(props.id === prevProps.id, 'source id changed');\n  utils_assert_assert(props.type === prevProps.type, 'source type changed');\n  var changedKey = '';\n  var changedKeyCount = 0;\n  for (var key in props) {\n    if (key !== 'children' && key !== 'id' && !deepEqual(prevProps[key], props[key])) {\n      changedKey = key;\n      changedKeyCount++;\n    }\n  }\n  if (!changedKeyCount) {\n    return;\n  }\n  var type = props.type;\n  if (type === 'geojson') {\n    source.setData(props.data);\n  } else if (type === 'image') {\n    source.updateImage({\n      url: props.url,\n      coordinates: props.coordinates\n    });\n  } else if ((type === 'canvas' || type === 'video') && changedKeyCount === 1 && changedKey === 'coordinates') {\n    source.setCoordinates(props.coordinates);\n  } else if (type === 'vector' && source.setUrl) {\n    switch (changedKey) {\n      case 'url':\n        source.setUrl(props.url);\n        break;\n      case 'tiles':\n        source.setTiles(props.tiles);\n        break;\n      default:\n    }\n  } else {\n    console.warn(\"Unable to update <Source> prop: \".concat(changedKey));\n  }\n}\nfunction Source(props) {\n  var context = (0,react.useContext)(map_context);\n  var propsRef = (0,react.useRef)({\n    id: props.id,\n    type: props.type\n  });\n  var _useState = (0,react.useState)(0),\n    _useState2 = _slicedToArray(_useState, 2),\n    setStyleLoaded = _useState2[1];\n  var id = (0,react.useMemo)(function () {\n    return props.id || \"jsx-source-\".concat(sourceCounter++);\n  }, []);\n  var map = context.map;\n  (0,react.useEffect)(function () {\n    if (map) {\n      var forceUpdate = function forceUpdate() {\n        return setStyleLoaded(function (version) {\n          return version + 1;\n        });\n      };\n      map.on('styledata', forceUpdate);\n      return function () {\n        map.off('styledata', forceUpdate);\n        requestAnimationFrame(function () {\n          if (map.style && map.style._loaded && map.getSource(id)) {\n            map.removeSource(id);\n          }\n        });\n      };\n    }\n    return undefined;\n  }, [map, id]);\n  var source = map && map.style && map.getSource(id);\n  if (source) {\n    updateSource(source, props, propsRef.current);\n  } else {\n    source = createSource(map, id, props);\n  }\n  propsRef.current = props;\n  return source && react.Children.map(props.children, function (child) {\n    return child && (0,react.cloneElement)(child, {\n      source: id\n    });\n  }) || null;\n}\n/* harmony default export */ var source = (Source);\n;// ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (e.includes(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\n\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var s = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\n\n;// ./node_modules/react-map-gl/dist/esm/components/layer.js\n\n\n\nfunction layer_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction layer_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      layer_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      layer_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\n\nvar LAYER_TYPES = ['fill', 'line', 'symbol', 'circle', 'fill-extrusion', 'raster', 'background', 'heatmap', 'hillshade', 'sky'];\nvar layer_propTypes = {\n  type: prop_types.oneOf(LAYER_TYPES).isRequired,\n  id: prop_types.string,\n  source: prop_types.string,\n  beforeId: prop_types.string\n};\nfunction diffLayerStyles(map, id, props, prevProps) {\n  var _props$layout = props.layout,\n    layout = _props$layout === void 0 ? {} : _props$layout,\n    _props$paint = props.paint,\n    paint = _props$paint === void 0 ? {} : _props$paint,\n    filter = props.filter,\n    minzoom = props.minzoom,\n    maxzoom = props.maxzoom,\n    beforeId = props.beforeId,\n    otherProps = _objectWithoutProperties(props, [\"layout\", \"paint\", \"filter\", \"minzoom\", \"maxzoom\", \"beforeId\"]);\n  if (beforeId !== prevProps.beforeId) {\n    map.moveLayer(id, beforeId);\n  }\n  if (layout !== prevProps.layout) {\n    var prevLayout = prevProps.layout || {};\n    for (var key in layout) {\n      if (!deepEqual(layout[key], prevLayout[key])) {\n        map.setLayoutProperty(id, key, layout[key]);\n      }\n    }\n    for (var _key in prevLayout) {\n      if (!layout.hasOwnProperty(_key)) {\n        map.setLayoutProperty(id, _key, undefined);\n      }\n    }\n  }\n  if (paint !== prevProps.paint) {\n    var prevPaint = prevProps.paint || {};\n    for (var _key2 in paint) {\n      if (!deepEqual(paint[_key2], prevPaint[_key2])) {\n        map.setPaintProperty(id, _key2, paint[_key2]);\n      }\n    }\n    for (var _key3 in prevPaint) {\n      if (!paint.hasOwnProperty(_key3)) {\n        map.setPaintProperty(id, _key3, undefined);\n      }\n    }\n  }\n  if (!deepEqual(filter, prevProps.filter)) {\n    map.setFilter(id, filter);\n  }\n  if (minzoom !== prevProps.minzoom || maxzoom !== prevProps.maxzoom) {\n    map.setLayerZoomRange(id, minzoom, maxzoom);\n  }\n  for (var _key4 in otherProps) {\n    if (!deepEqual(otherProps[_key4], prevProps[_key4])) {\n      map.setLayerProperty(id, _key4, otherProps[_key4]);\n    }\n  }\n}\nfunction createLayer(map, id, props) {\n  if (map.style && map.style._loaded) {\n    var options = layer_objectSpread(layer_objectSpread({}, props), {}, {\n      id: id\n    });\n    delete options.beforeId;\n    map.addLayer(options, props.beforeId);\n  }\n}\nfunction updateLayer(map, id, props, prevProps) {\n  utils_assert_assert(props.id === prevProps.id, 'layer id changed');\n  utils_assert_assert(props.type === prevProps.type, 'layer type changed');\n  try {\n    diffLayerStyles(map, id, props, prevProps);\n  } catch (error) {\n    console.warn(error);\n  }\n}\nvar layerCounter = 0;\nfunction Layer(props) {\n  var context = (0,react.useContext)(map_context);\n  var propsRef = (0,react.useRef)({\n    id: props.id,\n    type: props.type\n  });\n  var _useState = (0,react.useState)(0),\n    _useState2 = _slicedToArray(_useState, 2),\n    setStyleLoaded = _useState2[1];\n  var id = (0,react.useMemo)(function () {\n    return props.id || \"jsx-layer-\".concat(layerCounter++);\n  }, []);\n  var map = context.map;\n  (0,react.useEffect)(function () {\n    if (map) {\n      var forceUpdate = function forceUpdate() {\n        return setStyleLoaded(function (version) {\n          return version + 1;\n        });\n      };\n      map.on('styledata', forceUpdate);\n      return function () {\n        map.off('styledata', forceUpdate);\n        if (map.style && map.style._loaded) {\n          map.removeLayer(id);\n        }\n      };\n    }\n    return undefined;\n  }, [map]);\n  var layer = map && map.style && map.getLayer(id);\n  if (layer) {\n    updateLayer(map, id, props, propsRef.current);\n  } else {\n    createLayer(map, id, props);\n  }\n  propsRef.current = props;\n  return null;\n}\nLayer.propTypes = layer_propTypes;\n/* harmony default export */ var components_layer = (Layer);\n;// ./node_modules/react-map-gl/dist/esm/components/use-map-control.js\n\n\n\nvar mapControlDefaultProps = {\n  captureScroll: false,\n  captureDrag: true,\n  captureClick: true,\n  captureDoubleClick: true,\n  capturePointerMove: false\n};\nvar mapControlPropTypes = {\n  captureScroll: prop_types.bool,\n  captureDrag: prop_types.bool,\n  captureClick: prop_types.bool,\n  captureDoubleClick: prop_types.bool,\n  capturePointerMove: prop_types.bool\n};\nfunction onMount(thisRef) {\n  var ref = thisRef.containerRef.current;\n  var eventManager = thisRef.context.eventManager;\n  if (!ref || !eventManager) {\n    return undefined;\n  }\n  var events = {\n    wheel: function wheel(evt) {\n      var props = thisRef.props;\n      if (props.captureScroll) {\n        evt.stopPropagation();\n      }\n      if (props.onScroll) {\n        props.onScroll(evt, thisRef);\n      }\n    },\n    panstart: function panstart(evt) {\n      var props = thisRef.props;\n      if (props.captureDrag) {\n        evt.stopPropagation();\n      }\n      if (props.onDragStart) {\n        props.onDragStart(evt, thisRef);\n      }\n    },\n    anyclick: function anyclick(evt) {\n      var props = thisRef.props;\n      if (props.captureClick) {\n        evt.stopPropagation();\n      }\n      if (props.onNativeClick) {\n        props.onNativeClick(evt, thisRef);\n      }\n    },\n    click: function click(evt) {\n      var props = thisRef.props;\n      if (props.captureClick) {\n        evt.stopPropagation();\n      }\n      if (props.onClick) {\n        props.onClick(evt, thisRef);\n      }\n    },\n    dblclick: function dblclick(evt) {\n      var props = thisRef.props;\n      if (props.captureDoubleClick) {\n        evt.stopPropagation();\n      }\n      if (props.onDoubleClick) {\n        props.onDoubleClick(evt, thisRef);\n      }\n    },\n    pointermove: function pointermove(evt) {\n      var props = thisRef.props;\n      if (props.capturePointerMove) {\n        evt.stopPropagation();\n      }\n      if (props.onPointerMove) {\n        props.onPointerMove(evt, thisRef);\n      }\n    }\n  };\n  eventManager.watch(events, ref);\n  return function () {\n    eventManager.off(events);\n  };\n}\nfunction useMapControl() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var context = (0,react.useContext)(map_context);\n  var containerRef = (0,react.useRef)(null);\n  var _thisRef = (0,react.useRef)({\n    props: props,\n    state: {},\n    context: context,\n    containerRef: containerRef\n  });\n  var thisRef = _thisRef.current;\n  thisRef.props = props;\n  thisRef.context = context;\n  (0,react.useEffect)(function () {\n    return onMount(thisRef);\n  }, [context.eventManager]);\n  return thisRef;\n}\n;// ./node_modules/react-map-gl/dist/esm/components/base-control.js\n\n\n\n\n\n\n\n\nfunction base_control_createSuper(Derived) {\n  var hasNativeReflectConstruct = base_control_isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction base_control_isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n\n\nfunction Control(props) {\n  var instance = props.instance;\n  var _useMapControl = useMapControl(props),\n    context = _useMapControl.context,\n    containerRef = _useMapControl.containerRef;\n  instance._context = context;\n  instance._containerRef = containerRef;\n  return instance._render();\n}\nvar BaseControl = function (_PureComponent) {\n  _inherits(BaseControl, _PureComponent);\n  var _super = base_control_createSuper(BaseControl);\n  function BaseControl() {\n    var _this;\n    _classCallCheck(this, BaseControl);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"_context\", {});\n    _defineProperty(_assertThisInitialized(_this), \"_containerRef\", (0,react.createRef)());\n    _defineProperty(_assertThisInitialized(_this), \"_onScroll\", function (evt) {});\n    _defineProperty(_assertThisInitialized(_this), \"_onDragStart\", function (evt) {});\n    _defineProperty(_assertThisInitialized(_this), \"_onDblClick\", function (evt) {});\n    _defineProperty(_assertThisInitialized(_this), \"_onClick\", function (evt) {});\n    _defineProperty(_assertThisInitialized(_this), \"_onPointerMove\", function (evt) {});\n    return _this;\n  }\n  _createClass(BaseControl, [{\n    key: \"_render\",\n    value: function _render() {\n      throw new Error('_render() not implemented');\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react.createElement(Control, _extends({\n        instance: this\n      }, this.props, {\n        onScroll: this._onScroll,\n        onDragStart: this._onDragStart,\n        onDblClick: this._onDblClick,\n        onClick: this._onClick,\n        onPointerMove: this._onPointerMove\n      }));\n    }\n  }]);\n  return BaseControl;\n}(react.PureComponent);\n_defineProperty(BaseControl, \"propTypes\", mapControlPropTypes);\n_defineProperty(BaseControl, \"defaultProps\", mapControlDefaultProps);\n\n;// ./node_modules/react-map-gl/dist/esm/components/draggable-control.js\n\n\nfunction draggable_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction draggable_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      draggable_control_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      draggable_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\nvar draggableControlPropTypes = Object.assign({}, mapControlPropTypes, {\n  draggable: prop_types.bool,\n  onDrag: prop_types.func,\n  onDragEnd: prop_types.func,\n  onDragStart: prop_types.func,\n  offsetLeft: prop_types.number,\n  offsetTop: prop_types.number\n});\nvar draggableControlDefaultProps = Object.assign({}, mapControlDefaultProps, {\n  draggable: false,\n  offsetLeft: 0,\n  offsetTop: 0\n});\nfunction getDragEventPosition(event) {\n  var _event$offsetCenter = event.offsetCenter,\n    x = _event$offsetCenter.x,\n    y = _event$offsetCenter.y;\n  return [x, y];\n}\nfunction getDragEventOffset(event, container) {\n  var _event$center = event.center,\n    x = _event$center.x,\n    y = _event$center.y;\n  if (container) {\n    var rect = container.getBoundingClientRect();\n    return [rect.left - x, rect.top - y];\n  }\n  return null;\n}\nfunction getDragLngLat(dragPos, dragOffset, props, context) {\n  var x = dragPos[0] + dragOffset[0] - props.offsetLeft;\n  var y = dragPos[1] + dragOffset[1] - props.offsetTop;\n  return context.viewport.unproject([x, y]);\n}\nfunction onDragStart(event, _ref) {\n  var props = _ref.props,\n    callbacks = _ref.callbacks,\n    state = _ref.state,\n    context = _ref.context,\n    containerRef = _ref.containerRef;\n  var draggable = props.draggable;\n  if (!draggable) {\n    return;\n  }\n  event.stopPropagation();\n  var dragPos = getDragEventPosition(event);\n  var dragOffset = getDragEventOffset(event, containerRef.current);\n  state.setDragPos(dragPos);\n  state.setDragOffset(dragOffset);\n  if (callbacks.onDragStart && dragOffset) {\n    var callbackEvent = Object.assign({}, event);\n    callbackEvent.lngLat = getDragLngLat(dragPos, dragOffset, props, context);\n    callbacks.onDragStart(callbackEvent);\n  }\n}\nfunction onDrag(event, _ref2) {\n  var props = _ref2.props,\n    callbacks = _ref2.callbacks,\n    state = _ref2.state,\n    context = _ref2.context;\n  event.stopPropagation();\n  var dragPos = getDragEventPosition(event);\n  state.setDragPos(dragPos);\n  var dragOffset = state.dragOffset;\n  if (callbacks.onDrag && dragOffset) {\n    var callbackEvent = Object.assign({}, event);\n    callbackEvent.lngLat = getDragLngLat(dragPos, dragOffset, props, context);\n    callbacks.onDrag(callbackEvent);\n  }\n}\nfunction onDragEnd(event, _ref3) {\n  var props = _ref3.props,\n    callbacks = _ref3.callbacks,\n    state = _ref3.state,\n    context = _ref3.context;\n  event.stopPropagation();\n  var dragPos = state.dragPos,\n    dragOffset = state.dragOffset;\n  state.setDragPos(null);\n  state.setDragOffset(null);\n  if (callbacks.onDragEnd && dragPos && dragOffset) {\n    var callbackEvent = Object.assign({}, event);\n    callbackEvent.lngLat = getDragLngLat(dragPos, dragOffset, props, context);\n    callbacks.onDragEnd(callbackEvent);\n  }\n}\nfunction onDragCancel(event, _ref4) {\n  var state = _ref4.state;\n  event.stopPropagation();\n  state.setDragPos(null);\n  state.setDragOffset(null);\n}\nfunction registerEvents(thisRef) {\n  var eventManager = thisRef.context.eventManager;\n  if (!eventManager || !thisRef.state.dragPos) {\n    return undefined;\n  }\n  var events = {\n    panmove: function panmove(evt) {\n      return onDrag(evt, thisRef);\n    },\n    panend: function panend(evt) {\n      return onDragEnd(evt, thisRef);\n    },\n    pancancel: function pancancel(evt) {\n      return onDragCancel(evt, thisRef);\n    }\n  };\n  eventManager.watch(events);\n  return function () {\n    eventManager.off(events);\n  };\n}\nfunction useDraggableControl(props) {\n  var _useState = (0,react.useState)(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    dragPos = _useState2[0],\n    setDragPos = _useState2[1];\n  var _useState3 = (0,react.useState)(null),\n    _useState4 = _slicedToArray(_useState3, 2),\n    dragOffset = _useState4[0],\n    setDragOffset = _useState4[1];\n  var thisRef = useMapControl(draggable_control_objectSpread(draggable_control_objectSpread({}, props), {}, {\n    onDragStart: onDragStart\n  }));\n  thisRef.callbacks = props;\n  thisRef.state.dragPos = dragPos;\n  thisRef.state.setDragPos = setDragPos;\n  thisRef.state.dragOffset = dragOffset;\n  thisRef.state.setDragOffset = setDragOffset;\n  (0,react.useEffect)(function () {\n    return registerEvents(thisRef);\n  }, [thisRef.context.eventManager, Boolean(dragPos)]);\n  return thisRef;\n}\n;// ./node_modules/react-map-gl/dist/esm/utils/crisp-pixel.js\nvar pixelRatio = typeof window !== 'undefined' && window.devicePixelRatio || 1;\nvar crispPixel = function crispPixel(size) {\n  return Math.round(size * pixelRatio) / pixelRatio;\n};\nvar crispPercentage = function crispPercentage(el, percentage) {\n  var dimension = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'x';\n  if (el === null) {\n    return percentage;\n  }\n  var origSize = dimension === 'x' ? el.offsetWidth : el.offsetHeight;\n  return crispPixel(percentage / 100 * origSize) / origSize * 100;\n};\n;// ./node_modules/react-map-gl/dist/esm/components/marker.js\n\n\nfunction marker_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction marker_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      marker_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      marker_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\n\nvar marker_defaultProps = Object.assign({}, draggableControlDefaultProps, {\n  className: ''\n});\nfunction getPosition(_ref) {\n  var props = _ref.props,\n    state = _ref.state,\n    context = _ref.context;\n  var longitude = props.longitude,\n    latitude = props.latitude,\n    offsetLeft = props.offsetLeft,\n    offsetTop = props.offsetTop;\n  var dragPos = state.dragPos,\n    dragOffset = state.dragOffset;\n  var viewport = context.viewport,\n    map = context.map;\n  if (dragPos && dragOffset) {\n    return [dragPos[0] + dragOffset[0], dragPos[1] + dragOffset[1]];\n  }\n  var altitude = getTerrainElevation(map, {\n    longitude: longitude,\n    latitude: latitude\n  });\n  var _viewport$project = viewport.project([longitude, latitude, altitude]),\n    _viewport$project2 = _slicedToArray(_viewport$project, 2),\n    x = _viewport$project2[0],\n    y = _viewport$project2[1];\n  x += offsetLeft;\n  y += offsetTop;\n  return [x, y];\n}\nfunction Marker(props) {\n  var thisRef = useDraggableControl(props);\n  var state = thisRef.state,\n    containerRef = thisRef.containerRef;\n  var children = props.children,\n    className = props.className,\n    draggable = props.draggable,\n    style = props.style;\n  var dragPos = state.dragPos;\n  var _getPosition = getPosition(thisRef),\n    _getPosition2 = _slicedToArray(_getPosition, 2),\n    x = _getPosition2[0],\n    y = _getPosition2[1];\n  var transform = \"translate(\".concat(crispPixel(x), \"px, \").concat(crispPixel(y), \"px)\");\n  var cursor = draggable ? dragPos ? 'grabbing' : 'grab' : 'auto';\n  var control = (0,react.useMemo)(function () {\n    var containerStyle = marker_objectSpread({\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      transform: transform,\n      cursor: cursor\n    }, style);\n    return react.createElement(\"div\", {\n      className: \"mapboxgl-marker \".concat(className),\n      ref: thisRef.containerRef,\n      style: containerStyle\n    }, children);\n  }, [children, className]);\n  var container = containerRef.current;\n  if (container) {\n    container.style.transform = transform;\n    container.style.cursor = cursor;\n  }\n  return control;\n}\nMarker.defaultProps = marker_defaultProps;\n/* harmony default export */ var marker = (react.memo(Marker));\n;// ./node_modules/react-map-gl/dist/esm/utils/dynamic-position.js\nvar ANCHOR_POSITION = {\n  top: {\n    x: 0.5,\n    y: 0\n  },\n  'top-left': {\n    x: 0,\n    y: 0\n  },\n  'top-right': {\n    x: 1,\n    y: 0\n  },\n  bottom: {\n    x: 0.5,\n    y: 1\n  },\n  'bottom-left': {\n    x: 0,\n    y: 1\n  },\n  'bottom-right': {\n    x: 1,\n    y: 1\n  },\n  left: {\n    x: 0,\n    y: 0.5\n  },\n  right: {\n    x: 1,\n    y: 0.5\n  }\n};\nvar ANCHOR_TYPES = Object.keys(ANCHOR_POSITION);\nfunction getDynamicPosition(_ref) {\n  var x = _ref.x,\n    y = _ref.y,\n    width = _ref.width,\n    height = _ref.height,\n    selfWidth = _ref.selfWidth,\n    selfHeight = _ref.selfHeight,\n    anchor = _ref.anchor,\n    _ref$padding = _ref.padding,\n    padding = _ref$padding === void 0 ? 0 : _ref$padding;\n  var _ANCHOR_POSITION$anch = ANCHOR_POSITION[anchor],\n    anchorX = _ANCHOR_POSITION$anch.x,\n    anchorY = _ANCHOR_POSITION$anch.y;\n  var top = y - anchorY * selfHeight;\n  var bottom = top + selfHeight;\n  var cutoffY = Math.max(0, padding - top) + Math.max(0, bottom - height + padding);\n  if (cutoffY > 0) {\n    var bestAnchorY = anchorY;\n    var minCutoff = cutoffY;\n    for (anchorY = 0; anchorY <= 1; anchorY += 0.5) {\n      top = y - anchorY * selfHeight;\n      bottom = top + selfHeight;\n      cutoffY = Math.max(0, padding - top) + Math.max(0, bottom - height + padding);\n      if (cutoffY < minCutoff) {\n        minCutoff = cutoffY;\n        bestAnchorY = anchorY;\n      }\n    }\n    anchorY = bestAnchorY;\n  }\n  var xStep = 0.5;\n  if (anchorY === 0.5) {\n    anchorX = Math.floor(anchorX);\n    xStep = 1;\n  }\n  var left = x - anchorX * selfWidth;\n  var right = left + selfWidth;\n  var cutoffX = Math.max(0, padding - left) + Math.max(0, right - width + padding);\n  if (cutoffX > 0) {\n    var bestAnchorX = anchorX;\n    var _minCutoff = cutoffX;\n    for (anchorX = 0; anchorX <= 1; anchorX += xStep) {\n      left = x - anchorX * selfWidth;\n      right = left + selfWidth;\n      cutoffX = Math.max(0, padding - left) + Math.max(0, right - width + padding);\n      if (cutoffX < _minCutoff) {\n        _minCutoff = cutoffX;\n        bestAnchorX = anchorX;\n      }\n    }\n    anchorX = bestAnchorX;\n  }\n  return ANCHOR_TYPES.find(function (positionType) {\n    var anchorPosition = ANCHOR_POSITION[positionType];\n    return anchorPosition.x === anchorX && anchorPosition.y === anchorY;\n  }) || anchor;\n}\n;// ./node_modules/react-map-gl/dist/esm/components/popup.js\n\n\n\n\n\n\n\nvar popup_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: '',\n  offsetLeft: 0,\n  offsetTop: 0,\n  tipSize: 10,\n  anchor: 'bottom',\n  dynamicPosition: true,\n  sortByDepth: false,\n  closeButton: true,\n  closeOnClick: true,\n  onClose: function onClose() {}\n});\nfunction popup_getPosition(props, viewport, el, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    x = _ref2[0],\n    y = _ref2[1];\n  var anchor = props.anchor,\n    dynamicPosition = props.dynamicPosition,\n    tipSize = props.tipSize;\n  if (el) {\n    return dynamicPosition ? getDynamicPosition({\n      x: x,\n      y: y,\n      anchor: anchor,\n      padding: tipSize,\n      width: viewport.width,\n      height: viewport.height,\n      selfWidth: el.clientWidth,\n      selfHeight: el.clientHeight\n    }) : anchor;\n  }\n  return anchor;\n}\nfunction getContainerStyle(props, viewport, el, _ref3, positionType) {\n  var _ref4 = _slicedToArray(_ref3, 3),\n    x = _ref4[0],\n    y = _ref4[1],\n    z = _ref4[2];\n  var offsetLeft = props.offsetLeft,\n    offsetTop = props.offsetTop,\n    sortByDepth = props.sortByDepth;\n  var anchorPosition = ANCHOR_POSITION[positionType];\n  var left = x + offsetLeft;\n  var top = y + offsetTop;\n  var xPercentage = crispPercentage(el, -anchorPosition.x * 100);\n  var yPercentage = crispPercentage(el, -anchorPosition.y * 100, 'y');\n  var style = {\n    position: 'absolute',\n    transform: \"\\n      translate(\".concat(xPercentage, \"%, \").concat(yPercentage, \"%)\\n      translate(\").concat(crispPixel(left), \"px, \").concat(crispPixel(top), \"px)\\n    \"),\n    display: undefined,\n    zIndex: undefined\n  };\n  if (!sortByDepth) {\n    return style;\n  }\n  if (z > 1 || z < -1 || x < 0 || x > viewport.width || y < 0 || y > viewport.height) {\n    style.display = 'none';\n  } else {\n    style.zIndex = Math.floor((1 - z) / 2 * 100000);\n  }\n  return style;\n}\nfunction Popup(props) {\n  var contentRef = (0,react.useRef)(null);\n  var thisRef = useMapControl(props);\n  var context = thisRef.context,\n    containerRef = thisRef.containerRef;\n  var _useState = (0,react.useState)(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    setLoaded = _useState2[1];\n  (0,react.useEffect)(function () {\n    setLoaded(true);\n  }, [contentRef.current]);\n  (0,react.useEffect)(function () {\n    if (context.eventManager && props.closeOnClick) {\n      var clickCallback = function clickCallback() {\n        return thisRef.props.onClose();\n      };\n      context.eventManager.on('anyclick', clickCallback);\n      return function () {\n        context.eventManager.off('anyclick', clickCallback);\n      };\n    }\n    return undefined;\n  }, [context.eventManager, props.closeOnClick]);\n  var viewport = context.viewport,\n    map = context.map;\n  var className = props.className,\n    longitude = props.longitude,\n    latitude = props.latitude,\n    tipSize = props.tipSize,\n    closeButton = props.closeButton,\n    children = props.children;\n  var altitude = props.altitude;\n  if (altitude === undefined) {\n    altitude = getTerrainElevation(map, {\n      longitude: longitude,\n      latitude: latitude\n    });\n  }\n  var position = viewport.project([longitude, latitude, altitude]);\n  var positionType = popup_getPosition(props, viewport, contentRef.current, position);\n  var containerStyle = getContainerStyle(props, viewport, containerRef.current, position, positionType);\n  var onClickCloseButton = (0,react.useCallback)(function (evt) {\n    thisRef.props.onClose();\n    var eventManager = thisRef.context.eventManager;\n    if (eventManager) {\n      eventManager.once('click', function (e) {\n        return e.stopPropagation();\n      }, evt.target);\n    }\n  }, []);\n  return react.createElement(\"div\", {\n    className: \"mapboxgl-popup mapboxgl-popup-anchor-\".concat(positionType, \" \").concat(className),\n    style: containerStyle,\n    ref: containerRef\n  }, react.createElement(\"div\", {\n    key: \"tip\",\n    className: \"mapboxgl-popup-tip\",\n    style: {\n      borderWidth: tipSize\n    }\n  }), react.createElement(\"div\", {\n    key: \"content\",\n    ref: contentRef,\n    className: \"mapboxgl-popup-content\"\n  }, closeButton && react.createElement(\"button\", {\n    key: \"close-button\",\n    className: \"mapboxgl-popup-close-button\",\n    type: \"button\",\n    onClick: onClickCloseButton\n  }, \"\\xD7\"), children));\n}\nPopup.defaultProps = popup_defaultProps;\n/* harmony default export */ var popup = (react.memo(Popup));\n;// ./node_modules/react-map-gl/dist/esm/components/attribution-control.js\n\n\nfunction attribution_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction attribution_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      attribution_control_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      attribution_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\nvar attribution_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: '',\n  toggleLabel: 'Toggle Attribution'\n});\nfunction setupAttributioncontrol(opts, map, container, attributionContainer) {\n  var control = new (maplibre_gl_default()).AttributionControl(opts);\n  control._map = map;\n  control._container = container;\n  control._innerContainer = attributionContainer;\n  control._updateAttributions();\n  control._updateEditLink();\n  map.on('styledata', control._updateData);\n  map.on('sourcedata', control._updateData);\n  return control;\n}\nfunction removeAttributionControl(control) {\n  control._map.off('styledata', control._updateData);\n  control._map.off('sourcedata', control._updateData);\n}\nfunction AttributionControl(props) {\n  var _useMapControl = useMapControl(props),\n    context = _useMapControl.context,\n    containerRef = _useMapControl.containerRef;\n  var innerContainerRef = (0,react.useRef)(null);\n  var _useState = (0,react.useState)(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    showCompact = _useState2[0],\n    setShowCompact = _useState2[1];\n  (0,react.useEffect)(function () {\n    var control;\n    if (context.map) {\n      control = setupAttributioncontrol({\n        customAttribution: props.customAttribution\n      }, context.map, containerRef.current, innerContainerRef.current);\n    }\n    return function () {\n      return control && removeAttributionControl(control);\n    };\n  }, [context.map]);\n  var compact = props.compact === undefined ? context.viewport.width <= 640 : props.compact;\n  (0,react.useEffect)(function () {\n    if (!compact && showCompact) {\n      setShowCompact(false);\n    }\n  }, [compact]);\n  var toggleAttribution = (0,react.useCallback)(function () {\n    return setShowCompact(function (value) {\n      return !value;\n    });\n  }, []);\n  var style = (0,react.useMemo)(function () {\n    return attribution_control_objectSpread({\n      position: 'absolute'\n    }, props.style);\n  }, [props.style]);\n  return react.createElement(\"div\", {\n    style: style,\n    className: props.className\n  }, react.createElement(\"div\", {\n    ref: containerRef,\n    \"aria-pressed\": showCompact,\n    className: \"mapboxgl-ctrl mapboxgl-ctrl-attrib \".concat(compact ? 'mapboxgl-compact' : '', \" \").concat(showCompact ? 'mapboxgl-compact-show' : '')\n  }, react.createElement(\"button\", {\n    type: \"button\",\n    className: \"mapboxgl-ctrl-attrib-button\",\n    title: props.toggleLabel,\n    onClick: toggleAttribution\n  }), react.createElement(\"div\", {\n    ref: innerContainerRef,\n    className: \"mapboxgl-ctrl-attrib-inner\",\n    role: \"list\"\n  })));\n}\nAttributionControl.defaultProps = attribution_control_defaultProps;\n/* harmony default export */ var attribution_control = (react.memo(AttributionControl));\n;// ./node_modules/react-map-gl/dist/esm/components/fullscreen-control.js\n\n\nfunction fullscreen_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction fullscreen_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      fullscreen_control_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      fullscreen_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\n\nvar fullscreen_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: '',\n  container: null,\n  label: 'Toggle fullscreen'\n});\nfunction FullscreenControl(props) {\n  var _useMapControl = useMapControl(props),\n    context = _useMapControl.context,\n    containerRef = _useMapControl.containerRef;\n  var _useState = (0,react.useState)(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    isFullscreen = _useState2[0],\n    setIsFullscreen = _useState2[1];\n  var _useState3 = (0,react.useState)(false),\n    _useState4 = _slicedToArray(_useState3, 2),\n    showButton = _useState4[0],\n    setShowButton = _useState4[1];\n  var _useState5 = (0,react.useState)(null),\n    _useState6 = _slicedToArray(_useState5, 2),\n    mapboxFullscreenControl = _useState6[0],\n    createMapboxFullscreenControl = _useState6[1];\n  (0,react.useEffect)(function () {\n    var control = new (maplibre_gl_default()).FullscreenControl();\n    createMapboxFullscreenControl(control);\n    setShowButton(control._checkFullscreenSupport());\n    var onFullscreenChange = function onFullscreenChange() {\n      var nextState = !control._fullscreen;\n      control._fullscreen = nextState;\n      setIsFullscreen(nextState);\n    };\n    document_.addEventListener(control._fullscreenchange, onFullscreenChange);\n    return function () {\n      document_.removeEventListener(control._fullscreenchange, onFullscreenChange);\n    };\n  }, []);\n  var onClickFullscreen = function onClickFullscreen() {\n    if (mapboxFullscreenControl) {\n      mapboxFullscreenControl._container = props.container || context.container;\n      mapboxFullscreenControl._onClickFullscreen();\n    }\n  };\n  var style = (0,react.useMemo)(function () {\n    return fullscreen_control_objectSpread({\n      position: 'absolute'\n    }, props.style);\n  }, [props.style]);\n  if (!showButton) {\n    return null;\n  }\n  var className = props.className,\n    label = props.label;\n  var type = isFullscreen ? 'shrink' : 'fullscreen';\n  return react.createElement(\"div\", {\n    style: style,\n    className: className\n  }, react.createElement(\"div\", {\n    className: \"mapboxgl-ctrl mapboxgl-ctrl-group\",\n    ref: containerRef\n  }, react.createElement(\"button\", {\n    key: type,\n    className: \"mapboxgl-ctrl-icon mapboxgl-ctrl-\".concat(type),\n    type: \"button\",\n    title: label,\n    onClick: onClickFullscreen\n  }, react.createElement(\"span\", {\n    className: \"mapboxgl-ctrl-icon\",\n    \"aria-hidden\": \"true\"\n  }))));\n}\nFullscreenControl.defaultProps = fullscreen_control_defaultProps;\n/* harmony default export */ var fullscreen_control = (react.memo(FullscreenControl));\n;// ./node_modules/react-map-gl/dist/esm/utils/geolocate-utils.js\nvar supported;\nfunction isGeolocationSupported() {\n  if (supported !== undefined) {\n    return Promise.resolve(supported);\n  }\n  if (window.navigator.permissions !== undefined) {\n    return window.navigator.permissions.query({\n      name: 'geolocation'\n    }).then(function (p) {\n      supported = p.state !== 'denied';\n      return supported;\n    });\n  }\n  supported = Boolean(window.navigator.geolocation);\n  return Promise.resolve(supported);\n}\n;// ./node_modules/react-map-gl/dist/esm/components/geolocate-control.js\n\n\nfunction geolocate_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction geolocate_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      geolocate_control_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      geolocate_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\n\n\n\n\nvar geolocate_control_noop = function noop() {};\nvar geolocate_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: '',\n  label: 'Find My Location',\n  disabledLabel: 'Location Not Available',\n  auto: false,\n  positionOptions: {\n    enableHighAccuracy: false,\n    timeout: 6000\n  },\n  fitBoundsOptions: {\n    maxZoom: 15\n  },\n  trackUserLocation: false,\n  showUserLocation: true,\n  showUserHeading: false,\n  showAccuracyCircle: true,\n  onGeolocate: function onGeolocate() {}\n});\nfunction geolocate_control_getBounds(position) {\n  var center = new (maplibre_gl_default()).LngLat(position.coords.longitude, position.coords.latitude);\n  var radius = position.coords.accuracy;\n  var bounds = center.toBounds(radius);\n  return [[bounds._ne.lng, bounds._ne.lat], [bounds._sw.lng, bounds._sw.lat]];\n}\nfunction setupMapboxGeolocateControl(context, props, geolocateButton) {\n  var control = new (maplibre_gl_default()).GeolocateControl(props);\n  control._container = document_.createElement('div');\n  control._map = {\n    on: function on() {},\n    _getUIString: function _getUIString() {\n      return '';\n    }\n  };\n  control._setupUI(true);\n  control._map = context.map;\n  control._geolocateButton = geolocateButton;\n  var eventManager = context.eventManager;\n  if (control.options.trackUserLocation && eventManager) {\n    eventManager.on('panstart', function () {\n      if (control._watchState === 'ACTIVE_LOCK') {\n        control._watchState = 'BACKGROUND';\n        geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background');\n        geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active');\n      }\n    });\n  }\n  control.on('geolocate', props.onGeolocate);\n  return control;\n}\nfunction updateCamera(position, _ref) {\n  var context = _ref.context,\n    props = _ref.props;\n  var bounds = geolocate_control_getBounds(position);\n  var _context$viewport$fit = context.viewport.fitBounds(bounds, props.fitBoundsOptions),\n    longitude = _context$viewport$fit.longitude,\n    latitude = _context$viewport$fit.latitude,\n    zoom = _context$viewport$fit.zoom;\n  var newViewState = Object.assign({}, context.viewport, {\n    longitude: longitude,\n    latitude: latitude,\n    zoom: zoom\n  });\n  var mapState = new MapState(newViewState);\n  var viewState = Object.assign({}, mapState.getViewportProps(), LINEAR_TRANSITION_PROPS);\n  var onViewportChange = props.onViewportChange || context.onViewportChange || geolocate_control_noop;\n  var onViewStateChange = props.onViewStateChange || context.onViewStateChange || geolocate_control_noop;\n  onViewStateChange({\n    viewState: viewState\n  });\n  onViewportChange(viewState);\n}\nfunction GeolocateControl(props) {\n  var thisRef = useMapControl(props);\n  var context = thisRef.context,\n    containerRef = thisRef.containerRef;\n  var geolocateButtonRef = (0,react.useRef)(null);\n  var _useState = (0,react.useState)(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    mapboxGeolocateControl = _useState2[0],\n    createMapboxGeolocateControl = _useState2[1];\n  var _useState3 = (0,react.useState)(false),\n    _useState4 = _slicedToArray(_useState3, 2),\n    supportsGeolocation = _useState4[0],\n    setSupportsGeolocation = _useState4[1];\n  (0,react.useEffect)(function () {\n    var control;\n    if (context.map) {\n      isGeolocationSupported().then(function (result) {\n        setSupportsGeolocation(result);\n        if (geolocateButtonRef.current) {\n          control = setupMapboxGeolocateControl(context, props, geolocateButtonRef.current);\n          control._updateCamera = function (position) {\n            return updateCamera(position, thisRef);\n          };\n          createMapboxGeolocateControl(control);\n        }\n      });\n    }\n    return function () {\n      if (control) {\n        control._clearWatch();\n      }\n    };\n  }, [context.map]);\n  var triggerGeolocate = (0,react.useCallback)(function () {\n    if (mapboxGeolocateControl) {\n      mapboxGeolocateControl.options = thisRef.props;\n      mapboxGeolocateControl.trigger();\n    }\n  }, [mapboxGeolocateControl]);\n  (0,react.useEffect)(function () {\n    if (props.auto) {\n      triggerGeolocate();\n    }\n  }, [mapboxGeolocateControl, props.auto]);\n  (0,react.useEffect)(function () {\n    if (mapboxGeolocateControl) {\n      mapboxGeolocateControl._onZoom();\n    }\n  }, [context.viewport.zoom]);\n  var className = props.className,\n    label = props.label,\n    disabledLabel = props.disabledLabel,\n    trackUserLocation = props.trackUserLocation;\n  var style = (0,react.useMemo)(function () {\n    return geolocate_control_objectSpread({\n      position: 'absolute'\n    }, props.style);\n  }, [props.style]);\n  return react.createElement(\"div\", {\n    style: style,\n    className: className\n  }, react.createElement(\"div\", {\n    key: \"geolocate-control\",\n    className: \"mapboxgl-ctrl mapboxgl-ctrl-group\",\n    ref: containerRef\n  }, react.createElement(\"button\", {\n    key: \"geolocate\",\n    className: \"mapboxgl-ctrl-icon mapboxgl-ctrl-geolocate\",\n    ref: geolocateButtonRef,\n    disabled: !supportsGeolocation,\n    \"aria-pressed\": !trackUserLocation,\n    type: \"button\",\n    title: supportsGeolocation ? label : disabledLabel,\n    \"aria-label\": supportsGeolocation ? label : disabledLabel,\n    onClick: triggerGeolocate\n  }, react.createElement(\"span\", {\n    className: \"mapboxgl-ctrl-icon\",\n    \"aria-hidden\": \"true\"\n  }))));\n}\nGeolocateControl.defaultProps = geolocate_control_defaultProps;\n/* harmony default export */ var geolocate_control = (react.memo(GeolocateControl));\n;// ./node_modules/react-map-gl/dist/esm/utils/version.js\nfunction compareVersions(version1, version2) {\n  var v1 = (version1 || '').split('.').map(Number);\n  var v2 = (version2 || '').split('.').map(Number);\n  for (var i = 0; i < 3; i++) {\n    var part1 = v1[i] || 0;\n    var part2 = v2[i] || 0;\n    if (part1 < part2) {\n      return -1;\n    }\n    if (part1 > part2) {\n      return 1;\n    }\n  }\n  return 0;\n}\n;// ./node_modules/react-map-gl/dist/esm/components/navigation-control.js\n\nfunction navigation_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction navigation_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      navigation_control_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      navigation_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\n\n\nvar navigation_control_noop = function noop() {};\nvar navigation_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: '',\n  showCompass: true,\n  showZoom: true,\n  zoomInLabel: 'Zoom In',\n  zoomOutLabel: 'Zoom Out',\n  compassLabel: 'Reset North'\n});\nvar VERSION_LEGACY = 1;\nvar VERSION_1_6 = 2;\nfunction getUIVersion(mapboxVersion) {\n  return compareVersions(mapboxVersion, '1.6.0') >= 0 ? VERSION_1_6 : VERSION_LEGACY;\n}\nfunction updateViewport(context, props, opts) {\n  var viewport = context.viewport;\n  var mapState = new MapState(Object.assign({}, viewport, opts));\n  var viewState = Object.assign({}, mapState.getViewportProps(), LINEAR_TRANSITION_PROPS);\n  var onViewportChange = props.onViewportChange || context.onViewportChange || navigation_control_noop;\n  var onViewStateChange = props.onViewStateChange || context.onViewStateChange || navigation_control_noop;\n  onViewStateChange({\n    viewState: viewState\n  });\n  onViewportChange(viewState);\n}\nfunction renderButton(type, label, callback, children) {\n  return react.createElement(\"button\", {\n    key: type,\n    className: \"mapboxgl-ctrl-icon mapboxgl-ctrl-\".concat(type),\n    type: \"button\",\n    title: label,\n    onClick: callback\n  }, children || react.createElement(\"span\", {\n    className: \"mapboxgl-ctrl-icon\",\n    \"aria-hidden\": \"true\"\n  }));\n}\nfunction renderCompass(context) {\n  var uiVersion = (0,react.useMemo)(function () {\n    return context.map ? getUIVersion(context.map.version) : VERSION_1_6;\n  }, [context.map]);\n  var bearing = context.viewport.bearing;\n  var style = {\n    transform: \"rotate(\".concat(-bearing, \"deg)\")\n  };\n  return uiVersion === VERSION_1_6 ? react.createElement(\"span\", {\n    className: \"mapboxgl-ctrl-icon\",\n    \"aria-hidden\": \"true\",\n    style: style\n  }) : react.createElement(\"span\", {\n    className: \"mapboxgl-ctrl-compass-arrow\",\n    style: style\n  });\n}\nfunction NavigationControl(props) {\n  var _useMapControl = useMapControl(props),\n    context = _useMapControl.context,\n    containerRef = _useMapControl.containerRef;\n  var onZoomIn = function onZoomIn() {\n    updateViewport(context, props, {\n      zoom: context.viewport.zoom + 1\n    });\n  };\n  var onZoomOut = function onZoomOut() {\n    updateViewport(context, props, {\n      zoom: context.viewport.zoom - 1\n    });\n  };\n  var onResetNorth = function onResetNorth() {\n    updateViewport(context, props, {\n      bearing: 0,\n      pitch: 0\n    });\n  };\n  var className = props.className,\n    showCompass = props.showCompass,\n    showZoom = props.showZoom,\n    zoomInLabel = props.zoomInLabel,\n    zoomOutLabel = props.zoomOutLabel,\n    compassLabel = props.compassLabel;\n  var style = (0,react.useMemo)(function () {\n    return navigation_control_objectSpread({\n      position: 'absolute'\n    }, props.style);\n  }, [props.style]);\n  return react.createElement(\"div\", {\n    style: style,\n    className: className\n  }, react.createElement(\"div\", {\n    className: \"mapboxgl-ctrl mapboxgl-ctrl-group\",\n    ref: containerRef\n  }, showZoom && renderButton('zoom-in', zoomInLabel, onZoomIn), showZoom && renderButton('zoom-out', zoomOutLabel, onZoomOut), showCompass && renderButton('compass', compassLabel, onResetNorth, renderCompass(context))));\n}\nNavigationControl.defaultProps = navigation_control_defaultProps;\n/* harmony default export */ var navigation_control = (react.memo(NavigationControl));\n;// ./node_modules/react-map-gl/dist/esm/components/scale-control.js\n\n\nfunction scale_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction scale_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      scale_control_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      scale_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\nvar scale_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: '',\n  maxWidth: 100,\n  unit: 'metric'\n});\nfunction ScaleControl(props) {\n  var _useMapControl = useMapControl(props),\n    context = _useMapControl.context,\n    containerRef = _useMapControl.containerRef;\n  var _useState = (0,react.useState)(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    mapboxScaleControl = _useState2[0],\n    createMapboxScaleControl = _useState2[1];\n  (0,react.useEffect)(function () {\n    if (context.map) {\n      var control = new (maplibre_gl_default()).ScaleControl();\n      control._map = context.map;\n      control._container = containerRef.current;\n      createMapboxScaleControl(control);\n    }\n  }, [context.map]);\n  if (mapboxScaleControl) {\n    mapboxScaleControl.options = props;\n    if (mapboxScaleControl._onMove) mapboxScaleControl._onMove();\n  }\n  var style = (0,react.useMemo)(function () {\n    return scale_control_objectSpread({\n      position: 'absolute'\n    }, props.style);\n  }, [props.style]);\n  return react.createElement(\"div\", {\n    style: style,\n    className: props.className\n  }, react.createElement(\"div\", {\n    ref: containerRef,\n    className: \"mapboxgl-ctrl mapboxgl-ctrl-scale\"\n  }));\n}\nScaleControl.defaultProps = scale_control_defaultProps;\n/* harmony default export */ var scale_control = (react.memo(ScaleControl));\n;// ./node_modules/react-map-gl/dist/esm/overlays/canvas-overlay.js\n\n\n\n\nvar canvas_overlay_pixelRatio = typeof window !== 'undefined' && window.devicePixelRatio || 1;\nvar canvas_overlay_defaultProps = {\n  captureScroll: false,\n  captureDrag: false,\n  captureClick: false,\n  captureDoubleClick: false,\n  capturePointerMove: false\n};\nfunction CanvasOverlay(props) {\n  var _useMapControl = useMapControl(props),\n    context = _useMapControl.context,\n    containerRef = _useMapControl.containerRef;\n  var _useState = (0,react.useState)(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    ctx = _useState2[0],\n    setDrawingContext = _useState2[1];\n  (0,react.useEffect)(function () {\n    setDrawingContext(containerRef.current.getContext('2d'));\n  }, []);\n  var viewport = context.viewport,\n    isDragging = context.isDragging;\n  if (ctx) {\n    ctx.save();\n    ctx.scale(canvas_overlay_pixelRatio, canvas_overlay_pixelRatio);\n    props.redraw({\n      width: viewport.width,\n      height: viewport.height,\n      ctx: ctx,\n      isDragging: isDragging,\n      project: viewport.project,\n      unproject: viewport.unproject\n    });\n    ctx.restore();\n  }\n  return react.createElement(\"canvas\", {\n    ref: containerRef,\n    width: viewport.width * canvas_overlay_pixelRatio,\n    height: viewport.height * canvas_overlay_pixelRatio,\n    style: {\n      width: \"\".concat(viewport.width, \"px\"),\n      height: \"\".concat(viewport.height, \"px\"),\n      position: 'absolute',\n      left: 0,\n      top: 0\n    }\n  });\n}\nCanvasOverlay.defaultProps = canvas_overlay_defaultProps;\n/* harmony default export */ var canvas_overlay = ((/* unused pure expression or super */ null && (CanvasOverlay)));\n;// ./node_modules/react-map-gl/dist/esm/overlays/html-overlay.js\n\nfunction html_overlay_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction html_overlay_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      html_overlay_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      html_overlay_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\nvar html_overlay_defaultProps = {\n  captureScroll: false,\n  captureDrag: false,\n  captureClick: false,\n  captureDoubleClick: false,\n  capturePointerMove: false\n};\nfunction HTMLOverlay(props) {\n  var _useMapControl = useMapControl(props),\n    context = _useMapControl.context,\n    containerRef = _useMapControl.containerRef;\n  var viewport = context.viewport,\n    isDragging = context.isDragging;\n  var style = html_overlay_objectSpread({\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    width: viewport.width,\n    height: viewport.height\n  }, props.style);\n  return react.createElement(\"div\", {\n    ref: containerRef,\n    style: style\n  }, props.redraw({\n    width: viewport.width,\n    height: viewport.height,\n    isDragging: isDragging,\n    project: viewport.project,\n    unproject: viewport.unproject\n  }));\n}\nHTMLOverlay.defaultProps = html_overlay_defaultProps;\n/* harmony default export */ var html_overlay = ((/* unused pure expression or super */ null && (HTMLOverlay)));\n;// ./node_modules/react-map-gl/dist/esm/overlays/svg-overlay.js\n\nfunction svg_overlay_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction svg_overlay_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      svg_overlay_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      svg_overlay_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\nvar svg_overlay_defaultProps = {\n  captureScroll: false,\n  captureDrag: false,\n  captureClick: false,\n  captureDoubleClick: false,\n  capturePointerMove: false\n};\nfunction SVGOverlay(props) {\n  var _useMapControl = useMapControl(props),\n    context = _useMapControl.context,\n    containerRef = _useMapControl.containerRef;\n  var viewport = context.viewport,\n    isDragging = context.isDragging;\n  var style = svg_overlay_objectSpread({\n    position: 'absolute',\n    left: 0,\n    top: 0\n  }, props.style);\n  return react.createElement(\"svg\", {\n    width: viewport.width,\n    height: viewport.height,\n    ref: containerRef,\n    style: style\n  }, props.redraw({\n    width: viewport.width,\n    height: viewport.height,\n    isDragging: isDragging,\n    project: viewport.project,\n    unproject: viewport.unproject\n  }));\n}\nSVGOverlay.defaultProps = svg_overlay_defaultProps;\n/* harmony default export */ var svg_overlay = ((/* unused pure expression or super */ null && (SVGOverlay)));\n;// ./node_modules/react-map-gl/dist/esm/utils/set-rtl-text-plugin.js\n\nvar setRTLTextPlugin = (maplibre_gl_default()) ? (maplibre_gl_default()).setRTLTextPlugin : function () {};\n/* harmony default export */ var set_rtl_text_plugin = ((/* unused pure expression or super */ null && (setRTLTextPlugin)));\n;// ./node_modules/react-map-gl/dist/esm/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;// ./node_modules/@turf/helpers/dist/es/index.js\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nvar earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nvar factors = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: earthRadius / 111325,\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1000,\n  kilometres: earthRadius / 1000,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1000,\n  millimetres: earthRadius * 1000,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nvar unitsFactors = {\n  centimeters: 100,\n  centimetres: 100,\n  degrees: 1 / 111325,\n  feet: 3.28084,\n  inches: 39.37,\n  kilometers: 1 / 1000,\n  kilometres: 1 / 1000,\n  meters: 1,\n  metres: 1,\n  miles: 1 / 1609.344,\n  millimeters: 1000,\n  millimetres: 1000,\n  nauticalmiles: 1 / 1852,\n  radians: 1 / earthRadius,\n  yards: 1.0936133\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nvar areaFactors = {\n  acres: 0.000247105,\n  centimeters: 10000,\n  centimetres: 10000,\n  feet: 10.763910417,\n  hectares: 0.0001,\n  inches: 1550.003100006,\n  kilometers: 0.000001,\n  kilometres: 0.000001,\n  meters: 1,\n  metres: 1,\n  miles: 3.86e-7,\n  millimeters: 1000000,\n  millimetres: 1000000,\n  yards: 1.195990046\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction es_feature(geom, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var feat = {\n    type: \"Feature\"\n  };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, _options) {\n  if (_options === void 0) {\n    _options = {};\n  }\n  switch (type) {\n    case \"Point\":\n      return es_point(coordinates).geometry;\n    case \"LineString\":\n      return es_lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction es_point(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n  var geom = {\n    type: \"Point\",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return featureCollection(coordinates.map(function (coords) {\n    return es_point(coords, properties);\n  }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n    var ring = coordinates_1[_i];\n    if (ring.length < 4) {\n      throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n    }\n    for (var j = 0; j < ring[ring.length - 1].length; j++) {\n      // Check if first point of Polygon contains two numbers\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  var geom = {\n    type: \"Polygon\",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return featureCollection(coordinates.map(function (coords) {\n    return polygon(coords, properties);\n  }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction es_lineString(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  var geom = {\n    type: \"LineString\",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return featureCollection(coordinates.map(function (coords) {\n    return es_lineString(coords, properties);\n  }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var fc = {\n    type: \"FeatureCollection\"\n  };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var geom = {\n    type: \"MultiLineString\",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var geom = {\n    type: \"MultiPoint\",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var geom = {\n    type: \"MultiPolygon\",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var geom = {\n    type: \"GeometryCollection\",\n    geometries: geometries\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction es_round(num, precision) {\n  if (precision === void 0) {\n    precision = 0;\n  }\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  var multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n  if (units === void 0) {\n    units = \"kilometers\";\n  }\n  var factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n  if (units === void 0) {\n    units = \"kilometers\";\n  }\n  var factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n  var angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n  var degrees = radians % (2 * Math.PI);\n  return degrees * 180 / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n  var radians = degrees % 360;\n  return radians * Math.PI / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n  if (originalUnit === void 0) {\n    originalUnit = \"kilometers\";\n  }\n  if (finalUnit === void 0) {\n    finalUnit = \"kilometers\";\n  }\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n  if (originalUnit === void 0) {\n    originalUnit = \"meters\";\n  }\n  if (finalUnit === void 0) {\n    finalUnit = \"kilometers\";\n  }\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n  var startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n  var finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n  return area / startFactor * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction es_isObject(input) {\n  return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach(function (num) {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\n;// ./node_modules/@turf/meta/dist/es/index.js\n\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++) if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n  }, excludeWrapCoord);\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;else previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n          {\n            if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n            break;\n          }\n        case \"GeometryCollection\":\n          {\n            for (j = 0; j < geometry.geometries.length; j++) {\n              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n            }\n            break;\n          }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(feature(geometry, properties, {\n          bbox: bbox,\n          id: id\n        }), featureIndex, 0) === false) return false;\n        return;\n    }\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n    if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n      // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n      if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n        previousCoords = currentCoord;\n        previousFeatureIndex = featureIndex;\n        previousMultiIndex = multiPartIndexCoord;\n        prevGeomIndex = geometryIndex;\n        segmentIndex = 0;\n        return;\n      }\n      var currentSegment = lineString([previousCoords, currentCoord], feature.properties);\n      if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n      segmentIndex++;\n      previousCoords = currentCoord;\n    }) === false) return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n    if (started === false && initialValue === undefined) previousValue = currentSegment;else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n    started = true;\n  });\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n        break;\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n;// ./node_modules/@turf/bbox/dist/es/index.js\n\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n  var result = [Infinity, Infinity, -Infinity, -Infinity];\n  coordEach(geojson, function (coord) {\n    if (result[0] > coord[0]) {\n      result[0] = coord[0];\n    }\n    if (result[1] > coord[1]) {\n      result[1] = coord[1];\n    }\n    if (result[2] < coord[0]) {\n      result[2] = coord[0];\n    }\n    if (result[3] < coord[1]) {\n      result[3] = coord[1];\n    }\n  });\n  return result;\n}\nbbox[\"default\"] = bbox;\n/* harmony default export */ var es = (bbox);\n;// ./node_modules/d3-ease/src/cubic.js\nfunction cubicIn(t) {\n  return t * t * t;\n}\nfunction cubicOut(t) {\n  return --t * t * t + 1;\n}\nfunction cubicInOut(t) {\n  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\n}\n// EXTERNAL MODULE: ./node_modules/react-device-detect/dist/lib.js\nvar dist_lib = __webpack_require__(8132);\n// EXTERNAL MODULE: ./node_modules/react-use/esm/useWindowSize.js + 3 modules\nvar useWindowSize = __webpack_require__(79835);\n// EXTERNAL MODULE: ./node_modules/react-use/esm/misc/util.js\nvar util = __webpack_require__(82466);\n;// ./node_modules/react-use/esm/useLocalStorage.js\n\n\nvar useLocalStorage = function (key, initialValue, options) {\n  if (!util/* isBrowser */.Bd) {\n    return [initialValue, util/* noop */.lQ, util/* noop */.lQ];\n  }\n  if (!key) {\n    throw new Error('useLocalStorage key may not be falsy');\n  }\n  var deserializer = options ? options.raw ? function (value) {\n    return value;\n  } : options.deserializer : JSON.parse;\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  var initializer = (0,react.useRef)(function (key) {\n    try {\n      var serializer = options ? options.raw ? String : options.serializer : JSON.stringify;\n      var localStorageValue = localStorage.getItem(key);\n      if (localStorageValue !== null) {\n        return deserializer(localStorageValue);\n      } else {\n        initialValue && localStorage.setItem(key, serializer(initialValue));\n        return initialValue;\n      }\n    } catch (_a) {\n      // If user is in private mode or has storage restriction\n      // localStorage can throw. JSON.parse and JSON.stringify\n      // can throw, too.\n      return initialValue;\n    }\n  });\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  var _a = (0,react.useState)(function () {\n      return initializer.current(key);\n    }),\n    state = _a[0],\n    setState = _a[1];\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  (0,react.useLayoutEffect)(function () {\n    return setState(initializer.current(key));\n  }, [key]);\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  var set = (0,react.useCallback)(function (valOrFunc) {\n    try {\n      var newState = typeof valOrFunc === 'function' ? valOrFunc(state) : valOrFunc;\n      if (typeof newState === 'undefined') return;\n      var value = void 0;\n      if (options) {\n        if (options.raw) {\n          if (typeof newState === 'string') value = newState;else value = JSON.stringify(newState);\n        } else if (options.serializer) value = options.serializer(newState);else value = JSON.stringify(newState);\n      } else value = JSON.stringify(newState);\n      localStorage.setItem(key, value);\n      setState(deserializer(value));\n    } catch (_a) {\n      // If user is in private mode or has storage restriction\n      // localStorage can throw. Also JSON.stringify can throw.\n    }\n  }, [key, setState]);\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  var remove = (0,react.useCallback)(function () {\n    try {\n      localStorage.removeItem(key);\n      setState(undefined);\n    } catch (_a) {\n      // If user is in private mode or has storage restriction\n      // localStorage can throw.\n    }\n  }, [key, setState]);\n  return [state, set, remove];\n};\n/* harmony default export */ var esm_useLocalStorage = (useLocalStorage);\n// EXTERNAL MODULE: ./src/contexts/FlagContext.tsx\nvar FlagContext = __webpack_require__(19576);\n;// ./src/components/DisadvantageDot/DisadvantageDot.module.scss\n// extracted by mini-css-extract-plugin\nvar disadvantagedDotBig = \"DisadvantageDot-module--disadvantagedDotBig--uEj+Y\";\nvar disadvantagedDotSmall = \"DisadvantageDot-module--disadvantagedDotSmall--75NmP\";\n;// ./src/components/DisadvantageDot/DisadvantageDot.tsx\nconst DisadvantageDot=_ref=>{let{isDisadvantaged=false,isBig}=_ref;let computedClass='';if(isBig){computedClass=disadvantagedDotBig;}else{computedClass=isDisadvantaged?disadvantagedDotSmall:'';}return/*#__PURE__*/react.createElement(\"div\",{className:computedClass});};/* harmony default export */ var DisadvantageDot_DisadvantageDot = (DisadvantageDot);\n;// ./src/components/DisadvantageDot/index.tsx\n/* harmony default export */ var components_DisadvantageDot = (DisadvantageDot_DisadvantageDot);\n;// ./src/components/Category/Category.module.scss\n// extracted by mini-css-extract-plugin\nvar category = \"Category-module--category--QiyGB\";\nvar categoryContainer = \"Category-module--categoryContainer--hJQyd\";\nvar disCategoryContainer = \"Category-module--disCategoryContainer--K7Ziw\";\n;// ./src/components/Category/Category.tsx\n/**\n * This component controls the Categories on the side panel.\n *\n * The category will be styled differently differently depending on\n * if the category is disadvantaged or not. The JSX in the return\n * statement is identical however in the global CSS file, we\n * override the disadvantaged case with a psuedo-selector (:has) that\n * is new. In order to fallback gracefully for browsers that do\n * not yet support the \":has\" psuedo selector, this redundant JSX\n * will allow the disadvantaged case show the older category styling\n * while browsers that do support the \":has\" psuedo selector will\n * render the newer category style.\n *\n * @param {string} name\n * @param {boolean} isDisadvagtaged\n * @return {JSX.Element}\n */const Category=_ref=>{let{name,isDisadvantaged}=_ref;return isDisadvantaged?/*#__PURE__*/react.createElement(\"div\",{className:disCategoryContainer},/*#__PURE__*/react.createElement(\"div\",{className:category},name),/*#__PURE__*/react.createElement(components_DisadvantageDot,{isDisadvantaged:isDisadvantaged})):/*#__PURE__*/react.createElement(\"div\",{className:categoryContainer},/*#__PURE__*/react.createElement(\"div\",{className:category},name),/*#__PURE__*/react.createElement(components_DisadvantageDot,{isDisadvantaged:isDisadvantaged}));};/* harmony default export */ var Category_Category = (Category);\n;// ./src/components/Category/index.tsx\n/* harmony default export */ var components_Category = (Category_Category);\n;// ./node_modules/react-tooltip/node_modules/uuid/dist/esm-browser/rng.js\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n// find the complete implementation of crypto (msCrypto) on IE11.\nvar getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);\nvar rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\nfunction rng() {\n  if (!getRandomValues) {\n    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n  }\n  return getRandomValues(rnds8);\n}\n;// ./node_modules/react-tooltip/node_modules/uuid/dist/esm-browser/bytesToUuid.js\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\n  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');\n}\n/* harmony default export */ var esm_browser_bytesToUuid = (bytesToUuid);\n;// ./node_modules/react-tooltip/node_modules/uuid/dist/esm-browser/v4.js\n\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n  if (typeof options == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n  return buf || esm_browser_bytesToUuid(rnds);\n}\n/* harmony default export */ var esm_browser_v4 = (v4);\n;// ./node_modules/react-tooltip/dist/index.es.js\n\n\n\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {\n      index_es_defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction index_es_classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction index_es_defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction index_es_createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) index_es_defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) index_es_defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction index_es_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction index_es_extends() {\n  index_es_extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return index_es_extends.apply(this, arguments);\n}\nfunction index_es_inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction index_es_getPrototypeOf(o) {\n  index_es_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return index_es_getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction index_es_isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction index_es_assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction index_es_possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return index_es_assertThisInitialized(self);\n}\nfunction index_es_createSuper(Derived) {\n  var hasNativeReflectConstruct = index_es_isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = index_es_getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = index_es_getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return index_es_possibleConstructorReturn(this, result);\n  };\n}\nfunction index_es_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return index_es_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return index_es_arrayLikeToArray(o, minLen);\n}\nfunction index_es_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction index_es_createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = index_es_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function () {};\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$a =\n// eslint-disable-next-line es/no-global-this -- safe\ncheck(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) ||\n// eslint-disable-next-line no-restricted-globals -- safe\ncheck(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n// eslint-disable-next-line no-new-func -- fallback\nfunction () {\n  return this;\n}() || Function('return this')();\nvar objectGetOwnPropertyDescriptor = {};\nvar fails$9 = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\nvar fails$8 = fails$9;\n\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$8(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, {\n    get: function () {\n      return 7;\n    }\n  })[1] != 7;\n});\nvar fails$7 = fails$9;\nvar functionBindNative = !fails$7(function () {\n  // eslint-disable-next-line es/no-function-prototype-bind -- safe\n  var test = function () {/* empty */}.bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\nvar NATIVE_BIND$2 = functionBindNative;\nvar call$4 = Function.prototype.call;\nvar functionCall = NATIVE_BIND$2 ? call$4.bind(call$4) : function () {\n  return call$4.apply(call$4, arguments);\n};\nvar objectPropertyIsEnumerable = {};\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({\n  1: 2\n}, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor$1(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\nvar createPropertyDescriptor$2 = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\nvar NATIVE_BIND$1 = functionBindNative;\nvar FunctionPrototype$1 = Function.prototype;\nvar call$3 = FunctionPrototype$1.call;\nvar uncurryThisWithBind = NATIVE_BIND$1 && FunctionPrototype$1.bind.bind(call$3, call$3);\nvar functionUncurryThisRaw = function (fn) {\n  return NATIVE_BIND$1 ? uncurryThisWithBind(fn) : function () {\n    return call$3.apply(fn, arguments);\n  };\n};\nvar uncurryThisRaw$1 = functionUncurryThisRaw;\nvar toString$1 = uncurryThisRaw$1({}.toString);\nvar stringSlice = uncurryThisRaw$1(''.slice);\nvar classofRaw$2 = function (it) {\n  return stringSlice(toString$1(it), 8, -1);\n};\nvar classofRaw$1 = classofRaw$2;\nvar uncurryThisRaw = functionUncurryThisRaw;\nvar functionUncurryThis = function (fn) {\n  // Nashorn bug:\n  //   https://github.com/zloirock/core-js/issues/1128\n  //   https://github.com/zloirock/core-js/issues/1130\n  if (classofRaw$1(fn) === 'Function') return uncurryThisRaw(fn);\n};\nvar uncurryThis$9 = functionUncurryThis;\nvar fails$6 = fails$9;\nvar classof$3 = classofRaw$2;\nvar $Object$3 = Object;\nvar split = uncurryThis$9(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$6(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object$3('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof$3(it) == 'String' ? split(it, '') : $Object$3(it);\n} : $Object$3;\n\n// we can't use just `it == null` since of `document.all` special case\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec\nvar isNullOrUndefined$2 = function (it) {\n  return it === null || it === undefined;\n};\nvar isNullOrUndefined$1 = isNullOrUndefined$2;\nvar $TypeError$5 = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$2 = function (it) {\n  if (isNullOrUndefined$1(it)) throw $TypeError$5(\"Can't call method on \" + it);\n  return it;\n};\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$1 = indexedObject;\nvar requireObjectCoercible$1 = requireObjectCoercible$2;\nvar toIndexedObject$4 = function (it) {\n  return IndexedObject$1(requireObjectCoercible$1(it));\n};\nvar documentAll$2 = typeof document == 'object' && document.all;\n\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\nvar IS_HTMLDDA = typeof documentAll$2 == 'undefined' && documentAll$2 !== undefined;\nvar documentAll_1 = {\n  all: documentAll$2,\n  IS_HTMLDDA: IS_HTMLDDA\n};\nvar $documentAll$1 = documentAll_1;\nvar documentAll$1 = $documentAll$1.all;\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$c = $documentAll$1.IS_HTMLDDA ? function (argument) {\n  return typeof argument == 'function' || argument === documentAll$1;\n} : function (argument) {\n  return typeof argument == 'function';\n};\nvar isCallable$b = isCallable$c;\nvar $documentAll = documentAll_1;\nvar documentAll = $documentAll.all;\nvar isObject$6 = $documentAll.IS_HTMLDDA ? function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$b(it) || it === documentAll;\n} : function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$b(it);\n};\nvar global$9 = global$a;\nvar isCallable$a = isCallable$c;\nvar aFunction = function (argument) {\n  return isCallable$a(argument) ? argument : undefined;\n};\nvar getBuiltIn$5 = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global$9[namespace]) : global$9[namespace] && global$9[namespace][method];\n};\nvar uncurryThis$8 = functionUncurryThis;\nvar objectIsPrototypeOf = uncurryThis$8({}.isPrototypeOf);\nvar getBuiltIn$4 = getBuiltIn$5;\nvar engineUserAgent = getBuiltIn$4('navigator', 'userAgent') || '';\nvar global$8 = global$a;\nvar index_es_userAgent = engineUserAgent;\nvar index_es_process = global$8.process;\nvar Deno = global$8.Deno;\nvar versions = index_es_process && index_es_process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && index_es_userAgent) {\n  match = index_es_userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = index_es_userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\nvar engineV8Version = version;\n\n/* eslint-disable es/no-symbol -- required for testing */\n\nvar V8_VERSION = engineV8Version;\nvar fails$5 = fails$9;\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\nvar symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$5(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n  // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n  !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n\n/* eslint-disable es/no-symbol -- required for testing */\n\nvar NATIVE_SYMBOL$1 = symbolConstructorDetection;\nvar useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == 'symbol';\nvar getBuiltIn$3 = getBuiltIn$5;\nvar isCallable$9 = isCallable$c;\nvar index_es_isPrototypeOf = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\nvar $Object$2 = Object;\nvar isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn$3('Symbol');\n  return isCallable$9($Symbol) && index_es_isPrototypeOf($Symbol.prototype, $Object$2(it));\n};\nvar $String$1 = String;\nvar tryToString$1 = function (argument) {\n  try {\n    return $String$1(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\nvar isCallable$8 = isCallable$c;\nvar tryToString = tryToString$1;\nvar $TypeError$4 = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nvar aCallable$2 = function (argument) {\n  if (isCallable$8(argument)) return argument;\n  throw $TypeError$4(tryToString(argument) + ' is not a function');\n};\nvar aCallable$1 = aCallable$2;\nvar isNullOrUndefined = isNullOrUndefined$2;\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$1 = function (V, P) {\n  var func = V[P];\n  return isNullOrUndefined(func) ? undefined : aCallable$1(func);\n};\nvar call$2 = functionCall;\nvar isCallable$7 = isCallable$c;\nvar isObject$5 = isObject$6;\nvar $TypeError$3 = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable$7(fn = input.toString) && !isObject$5(val = call$2(fn, input))) return val;\n  if (isCallable$7(fn = input.valueOf) && !isObject$5(val = call$2(fn, input))) return val;\n  if (pref !== 'string' && isCallable$7(fn = input.toString) && !isObject$5(val = call$2(fn, input))) return val;\n  throw $TypeError$3(\"Can't convert object to primitive value\");\n};\nvar shared$3 = {\n  exports: {}\n};\nvar global$7 = global$a;\n\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty$2 = Object.defineProperty;\nvar defineGlobalProperty$3 = function (key, value) {\n  try {\n    defineProperty$2(global$7, key, {\n      value: value,\n      configurable: true,\n      writable: true\n    });\n  } catch (error) {\n    global$7[key] = value;\n  }\n  return value;\n};\nvar global$6 = global$a;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\nvar SHARED = '__core-js_shared__';\nvar store$3 = global$6[SHARED] || defineGlobalProperty$2(SHARED, {});\nvar sharedStore = store$3;\nvar store$2 = sharedStore;\n(shared$3.exports = function (key, value) {\n  return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.25.5',\n  mode: 'global',\n  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.25.5/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\nvar requireObjectCoercible = requireObjectCoercible$2;\nvar $Object$1 = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$2 = function (argument) {\n  return $Object$1(requireObjectCoercible(argument));\n};\nvar uncurryThis$7 = functionUncurryThis;\nvar toObject$1 = toObject$2;\nvar index_es_hasOwnProperty = uncurryThis$7({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n  return index_es_hasOwnProperty(toObject$1(it), key);\n};\nvar uncurryThis$6 = functionUncurryThis;\nvar id = 0;\nvar postfix = Math.random();\nvar index_es_toString = uncurryThis$6(1.0.toString);\nvar uid$2 = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + index_es_toString(++id + postfix, 36);\n};\nvar global$5 = global$a;\nvar shared$2 = shared$3.exports;\nvar hasOwn$6 = hasOwnProperty_1;\nvar uid$1 = uid$2;\nvar NATIVE_SYMBOL = symbolConstructorDetection;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\nvar WellKnownSymbolsStore = shared$2('wks');\nvar Symbol$1 = global$5.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;\nvar wellKnownSymbol$5 = function (name) {\n  if (!hasOwn$6(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL && hasOwn$6(Symbol$1, name)) {\n      WellKnownSymbolsStore[name] = Symbol$1[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  }\n  return WellKnownSymbolsStore[name];\n};\nvar call$1 = functionCall;\nvar isObject$4 = isObject$6;\nvar isSymbol$1 = isSymbol$2;\nvar getMethod = getMethod$1;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$4 = wellKnownSymbol$5;\nvar $TypeError$2 = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$4('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$1 = function (input, pref) {\n  if (!isObject$4(input) || isSymbol$1(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call$1(exoticToPrim, input, pref);\n    if (!isObject$4(result) || isSymbol$1(result)) return result;\n    throw $TypeError$2(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\nvar index_es_toPrimitive = toPrimitive$1;\nvar isSymbol = isSymbol$2;\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$2 = function (argument) {\n  var key = index_es_toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\nvar global$4 = global$a;\nvar isObject$3 = isObject$6;\nvar document$1 = global$4.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$3(document$1) && isObject$3(document$1.createElement);\nvar documentCreateElement$1 = function (it) {\n  return EXISTS$1 ? document$1.createElement(it) : {};\n};\nvar DESCRIPTORS$7 = descriptors;\nvar fails$4 = fails$9;\nvar createElement = documentCreateElement$1;\n\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$7 && !fails$4(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () {\n      return 7;\n    }\n  }).a != 7;\n});\nvar DESCRIPTORS$6 = descriptors;\nvar call = functionCall;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$2;\nvar toIndexedObject$3 = toIndexedObject$4;\nvar toPropertyKey$1 = toPropertyKey$2;\nvar hasOwn$5 = hasOwnProperty_1;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$6 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject$3(O);\n  P = toPropertyKey$1(P);\n  if (IE8_DOM_DEFINE$1) try {\n    return $getOwnPropertyDescriptor$1(O, P);\n  } catch (error) {/* empty */}\n  if (hasOwn$5(O, P)) return createPropertyDescriptor$1(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n};\nvar objectDefineProperty = {};\nvar DESCRIPTORS$5 = descriptors;\nvar fails$3 = fails$9;\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$5 && fails$3(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () {/* empty */}, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\nvar isObject$2 = isObject$6;\nvar $String = String;\nvar $TypeError$1 = TypeError;\n\n// `Assert: Type(argument) is Object`\nvar anObject$4 = function (argument) {\n  if (isObject$2(argument)) return argument;\n  throw $TypeError$1($String(argument) + ' is not an object');\n};\nvar DESCRIPTORS$4 = descriptors;\nvar IE8_DOM_DEFINE = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$3 = anObject$4;\nvar index_es_toPropertyKey = toPropertyKey$2;\nvar $TypeError = TypeError;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE$1 = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$4 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n  anObject$3(O);\n  P = index_es_toPropertyKey(P);\n  anObject$3(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  }\n  return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject$3(O);\n  P = index_es_toPropertyKey(P);\n  anObject$3(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) {/* empty */}\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\nvar DESCRIPTORS$3 = descriptors;\nvar definePropertyModule$3 = objectDefineProperty;\nvar createPropertyDescriptor = createPropertyDescriptor$2;\nvar createNonEnumerableProperty$2 = DESCRIPTORS$3 ? function (object, key, value) {\n  return definePropertyModule$3.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\nvar makeBuiltIn$2 = {\n  exports: {}\n};\nvar DESCRIPTORS$2 = descriptors;\nvar hasOwn$4 = hasOwnProperty_1;\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$2 && Object.getOwnPropertyDescriptor;\nvar EXISTS = hasOwn$4(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && function something() {/* empty */}.name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$2 || DESCRIPTORS$2 && getDescriptor(FunctionPrototype, 'name').configurable);\nvar functionName = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\nvar uncurryThis$5 = functionUncurryThis;\nvar isCallable$6 = isCallable$c;\nvar store$1 = sharedStore;\nvar functionToString = uncurryThis$5(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$6(store$1.inspectSource)) {\n  store$1.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\nvar inspectSource$2 = store$1.inspectSource;\nvar global$3 = global$a;\nvar isCallable$5 = isCallable$c;\nvar WeakMap$1 = global$3.WeakMap;\nvar weakMapBasicDetection = isCallable$5(WeakMap$1) && /native code/.test(String(WeakMap$1));\nvar shared$1 = shared$3.exports;\nvar uid = uid$2;\nvar keys = shared$1('keys');\nvar sharedKey$2 = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\nvar hiddenKeys$4 = {};\nvar NATIVE_WEAK_MAP = weakMapBasicDetection;\nvar global$2 = global$a;\nvar isObject$1 = isObject$6;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$2;\nvar hasOwn$3 = hasOwnProperty_1;\nvar shared = sharedStore;\nvar sharedKey$1 = sharedKey$2;\nvar hiddenKeys$3 = hiddenKeys$4;\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError$1 = global$2.TypeError;\nvar index_es_WeakMap = global$2.WeakMap;\nvar index_es_set, get, has;\nvar enforce = function (it) {\n  return has(it) ? get(it) : index_es_set(it, {});\n};\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject$1(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError$1('Incompatible receiver, ' + TYPE + ' required');\n    }\n    return state;\n  };\n};\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new index_es_WeakMap());\n  /* eslint-disable no-self-assign -- prototype methods protection */\n  store.get = store.get;\n  store.has = store.has;\n  store.set = store.set;\n  /* eslint-enable no-self-assign -- prototype methods protection */\n  index_es_set = function (it, metadata) {\n    if (store.has(it)) throw TypeError$1(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    store.set(it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return store.get(it) || {};\n  };\n  has = function (it) {\n    return store.has(it);\n  };\n} else {\n  var STATE = sharedKey$1('state');\n  hiddenKeys$3[STATE] = true;\n  index_es_set = function (it, metadata) {\n    if (hasOwn$3(it, STATE)) throw TypeError$1(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty$1(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn$3(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn$3(it, STATE);\n  };\n}\nvar internalState = {\n  set: index_es_set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\nvar fails$2 = fails$9;\nvar isCallable$4 = isCallable$c;\nvar hasOwn$2 = hasOwnProperty_1;\nvar DESCRIPTORS$1 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;\nvar inspectSource$1 = inspectSource$2;\nvar InternalStateModule = internalState;\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty$1 = Object.defineProperty;\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$1 && !fails$2(function () {\n  return defineProperty$1(function () {/* empty */}, 'length', {\n    value: 8\n  }).length !== 8;\n});\nvar TEMPLATE = String(String).split('String');\nvar makeBuiltIn$1 = makeBuiltIn$2.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn$2(value, 'name') || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {\n    if (DESCRIPTORS$1) defineProperty$1(value, 'name', {\n      value: name,\n      configurable: true\n    });else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn$2(options, 'arity') && value.length !== options.arity) {\n    defineProperty$1(value, 'length', {\n      value: options.arity\n    });\n  }\n  try {\n    if (options && hasOwn$2(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS$1) defineProperty$1(value, 'prototype', {\n        writable: false\n      });\n      // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) {/* empty */}\n  var state = enforceInternalState(value);\n  if (!hasOwn$2(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  }\n  return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$1(function toString() {\n  return isCallable$4(this) && getInternalState(this).source || inspectSource$1(this);\n}, 'toString');\nvar isCallable$3 = isCallable$c;\nvar definePropertyModule$2 = objectDefineProperty;\nvar makeBuiltIn = makeBuiltIn$2.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\nvar defineBuiltIn$1 = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable$3(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;else defineGlobalProperty$1(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];else if (O[key]) simple = true;\n    } catch (error) {/* empty */}\n    if (simple) O[key] = value;else definePropertyModule$2.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  }\n  return O;\n};\nvar objectGetOwnPropertyNames = {};\nvar index_es_ceil = Math.ceil;\nvar index_es_floor = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? index_es_floor : index_es_ceil)(n);\n};\nvar trunc = mathTrunc;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$2 = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$2;\nvar index_es_max = Math.max;\nvar min$1 = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$1 = function (index, length) {\n  var integer = toIntegerOrInfinity$1(index);\n  return integer < 0 ? index_es_max(integer + length, 0) : min$1(integer, length);\n};\nvar toIntegerOrInfinity = toIntegerOrInfinity$2;\nvar index_es_min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$1 = function (argument) {\n  return argument > 0 ? index_es_min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\nvar toLength = toLength$1;\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$2 = function (obj) {\n  return toLength(obj.length);\n};\nvar toIndexedObject$2 = toIndexedObject$4;\nvar toAbsoluteIndex = toAbsoluteIndex$1;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$2;\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod$1 = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject$2($this);\n    var length = lengthOfArrayLike$1(O);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n      // Array#indexOf ignores holes, Array#includes - not\n    } else for (; length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    }\n    return !IS_INCLUDES && -1;\n  };\n};\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod$1(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod$1(false)\n};\nvar uncurryThis$4 = functionUncurryThis;\nvar hasOwn$1 = hasOwnProperty_1;\nvar toIndexedObject$1 = toIndexedObject$4;\nvar indexOf = arrayIncludes.indexOf;\nvar hiddenKeys$2 = hiddenKeys$4;\nvar push$1 = uncurryThis$4([].push);\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject$1(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn$1(hiddenKeys$2, key) && hasOwn$1(O, key) && push$1(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn$1(O, key = names[i++])) {\n    ~indexOf(result, key) || push$1(result, key);\n  }\n  return result;\n};\n\n// IE8- don't enum bug keys\nvar enumBugKeys$3 = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\nvar hiddenKeys$1 = enumBugKeys$2.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys$1(O, hiddenKeys$1);\n};\nvar objectGetOwnPropertySymbols = {};\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\nvar getBuiltIn$2 = getBuiltIn$5;\nvar uncurryThis$3 = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar anObject$2 = anObject$4;\nvar concat = uncurryThis$3([].concat);\n\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn$2('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject$2(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\nvar hasOwn = hasOwnProperty_1;\nvar index_es_ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar definePropertyModule$1 = objectDefineProperty;\nvar copyConstructorProperties$1 = function (target, source, exceptions) {\n  var keys = index_es_ownKeys(source);\n  var defineProperty = definePropertyModule$1.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\nvar fails$1 = fails$9;\nvar isCallable$2 = isCallable$c;\nvar replacement = /#|\\.prototype\\./;\nvar isForced$1 = function (feature, detection) {\n  var value = data[index_es_normalize(feature)];\n  return value == POLYFILL ? true : value == NATIVE ? false : isCallable$2(detection) ? fails$1(detection) : !!detection;\n};\nvar index_es_normalize = isForced$1.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\nvar data = isForced$1.data = {};\nvar NATIVE = isForced$1.NATIVE = 'N';\nvar POLYFILL = isForced$1.POLYFILL = 'P';\nvar isForced_1 = isForced$1;\nvar index_es_global$1 = global$a;\nvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty = createNonEnumerableProperty$2;\nvar defineBuiltIn = defineBuiltIn$1;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties = copyConstructorProperties$1;\nvar isForced = isForced_1;\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = index_es_global$1;\n  } else if (STATIC) {\n    target = index_es_global$1[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (index_es_global$1[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || targetProperty && targetProperty.sham) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn(target, key, sourceProperty, options);\n  }\n};\nvar uncurryThis$2 = functionUncurryThis;\nvar aCallable = aCallable$2;\nvar NATIVE_BIND = functionBindNative;\nvar bind$1 = uncurryThis$2(uncurryThis$2.bind);\n\n// optional / simple context binding\nvar functionBindContext = function (fn, that) {\n  aCallable(fn);\n  return that === undefined ? fn : NATIVE_BIND ? bind$1(fn, that) : function /* ...args */\n  () {\n    return fn.apply(that, arguments);\n  };\n};\nvar classof$2 = classofRaw$2;\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es/no-array-isarray -- safe\nvar isArray$1 = Array.isArray || function isArray(argument) {\n  return classof$2(argument) == 'Array';\n};\nvar wellKnownSymbol$3 = wellKnownSymbol$5;\nvar TO_STRING_TAG$1 = wellKnownSymbol$3('toStringTag');\nvar test = {};\ntest[TO_STRING_TAG$1] = 'z';\nvar toStringTagSupport = String(test) === '[object z]';\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable$1 = isCallable$c;\nvar classofRaw = classofRaw$2;\nvar wellKnownSymbol$2 = wellKnownSymbol$5;\nvar TO_STRING_TAG = wellKnownSymbol$2('toStringTag');\nvar $Object = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () {\n  return arguments;\n}()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) {/* empty */}\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$1 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n  // @@toStringTag case\n  : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag\n  // builtinTag case\n  : CORRECT_ARGUMENTS ? classofRaw(O)\n  // ES3 arguments fallback\n  : (result = classofRaw(O)) == 'Object' && isCallable$1(O.callee) ? 'Arguments' : result;\n};\nvar uncurryThis$1 = functionUncurryThis;\nvar fails = fails$9;\nvar isCallable = isCallable$c;\nvar classof = classof$1;\nvar getBuiltIn$1 = getBuiltIn$5;\nvar inspectSource = inspectSource$2;\nvar index_es_noop = function () {/* empty */};\nvar empty = [];\nvar construct = getBuiltIn$1('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec = uncurryThis$1(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(index_es_noop);\nvar isConstructorModern = function isConstructor(argument) {\n  if (!isCallable(argument)) return false;\n  try {\n    construct(index_es_noop, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\nvar isConstructorLegacy = function isConstructor(argument) {\n  if (!isCallable(argument)) return false;\n  switch (classof(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction':\n      return false;\n  }\n  try {\n    // we can't check .prototype since constructors produced by .bind haven't it\n    // `Function#toString` throws on some built-it function in some legacy engines\n    // (for example, `DOMQuad` and similar in FF41-)\n    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));\n  } catch (error) {\n    return true;\n  }\n};\nisConstructorLegacy.sham = true;\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nvar isConstructor$1 = !construct || fails(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function () {\n    called = true;\n  }) || called;\n}) ? isConstructorLegacy : isConstructorModern;\nvar index_es_isArray = isArray$1;\nvar isConstructor = isConstructor$1;\nvar index_es_isObject = isObject$6;\nvar wellKnownSymbol$1 = wellKnownSymbol$5;\nvar SPECIES = wellKnownSymbol$1('species');\nvar $Array = Array;\n\n// a part of `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nvar arraySpeciesConstructor$1 = function (originalArray) {\n  var C;\n  if (index_es_isArray(originalArray)) {\n    C = originalArray.constructor;\n    // cross-realm fallback\n    if (isConstructor(C) && (C === $Array || index_es_isArray(C.prototype))) C = undefined;else if (index_es_isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  }\n  return C === undefined ? $Array : C;\n};\nvar arraySpeciesConstructor = arraySpeciesConstructor$1;\n\n// `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nvar arraySpeciesCreate$1 = function (originalArray, length) {\n  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);\n};\nvar bind = functionBindContext;\nvar uncurryThis = functionUncurryThis;\nvar IndexedObject = indexedObject;\nvar toObject = toObject$2;\nvar lengthOfArrayLike = lengthOfArrayLike$2;\nvar arraySpeciesCreate = arraySpeciesCreate$1;\nvar push = uncurryThis([].push);\n\n// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation\nvar createMethod = function (TYPE) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var IS_FILTER_REJECT = TYPE == 7;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  return function ($this, callbackfn, that, specificCreate) {\n    var O = toObject($this);\n    var self = IndexedObject(O);\n    var boundFunction = bind(callbackfn, that);\n    var length = lengthOfArrayLike(self);\n    var index = 0;\n    var create = specificCreate || arraySpeciesCreate;\n    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;\n    var value, result;\n    for (; length > index; index++) if (NO_HOLES || index in self) {\n      value = self[index];\n      result = boundFunction(value, index, O);\n      if (TYPE) {\n        if (IS_MAP) target[index] = result; // map\n        else if (result) switch (TYPE) {\n          case 3:\n            return true;\n          // some\n          case 5:\n            return value;\n          // find\n          case 6:\n            return index;\n          // findIndex\n          case 2:\n            push(target, value);\n          // filter\n        } else switch (TYPE) {\n          case 4:\n            return false;\n          // every\n          case 7:\n            push(target, value);\n          // filterReject\n        }\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\nvar arrayIteration = {\n  // `Array.prototype.forEach` method\n  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n  forEach: createMethod(0),\n  // `Array.prototype.map` method\n  // https://tc39.es/ecma262/#sec-array.prototype.map\n  map: createMethod(1),\n  // `Array.prototype.filter` method\n  // https://tc39.es/ecma262/#sec-array.prototype.filter\n  filter: createMethod(2),\n  // `Array.prototype.some` method\n  // https://tc39.es/ecma262/#sec-array.prototype.some\n  some: createMethod(3),\n  // `Array.prototype.every` method\n  // https://tc39.es/ecma262/#sec-array.prototype.every\n  every: createMethod(4),\n  // `Array.prototype.find` method\n  // https://tc39.es/ecma262/#sec-array.prototype.find\n  find: createMethod(5),\n  // `Array.prototype.findIndex` method\n  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n  findIndex: createMethod(6),\n  // `Array.prototype.filterReject` method\n  // https://github.com/tc39/proposal-array-filtering\n  filterReject: createMethod(7)\n};\nvar objectDefineProperties = {};\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys$1 = enumBugKeys$3;\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es/no-object-keys -- safe\nvar objectKeys$1 = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys$1);\n};\nvar DESCRIPTORS = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule = objectDefineProperty;\nvar anObject$1 = anObject$4;\nvar toIndexedObject = toIndexedObject$4;\nvar objectKeys = objectKeys$1;\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es/no-object-defineproperties -- safe\nobjectDefineProperties.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject$1(O);\n  var props = toIndexedObject(Properties);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);\n  return O;\n};\nvar getBuiltIn = getBuiltIn$5;\nvar html$1 = getBuiltIn('document', 'documentElement');\n\n/* global ActiveXObject -- old IE, WSH */\n\nvar anObject = anObject$4;\nvar definePropertiesModule = objectDefineProperties;\nvar enumBugKeys = enumBugKeys$3;\nvar hiddenKeys = hiddenKeys$4;\nvar html = html$1;\nvar documentCreateElement = documentCreateElement$1;\nvar sharedKey = sharedKey$2;\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar EmptyConstructor = function () {/* empty */};\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) {/* ignore */}\n  NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n  : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys.length;\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n  return NullProtoObject();\n};\nhiddenKeys[IE_PROTO] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es/no-object-create -- safe\nvar objectCreate = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\nvar wellKnownSymbol = wellKnownSymbol$5;\nvar index_es_create = objectCreate;\nvar defineProperty = objectDefineProperty.f;\nvar UNSCOPABLES = wellKnownSymbol('unscopables');\nvar ArrayPrototype = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n  defineProperty(ArrayPrototype, UNSCOPABLES, {\n    configurable: true,\n    value: index_es_create(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nvar addToUnscopables$1 = function (key) {\n  ArrayPrototype[UNSCOPABLES][key] = true;\n};\nvar $ = _export;\nvar $find = arrayIteration.find;\nvar addToUnscopables = addToUnscopables$1;\nvar FIND = 'find';\nvar SKIPS_HOLES = true;\n\n// Shouldn't skip holes\nif (FIND in []) Array(1)[FIND](function () {\n  SKIPS_HOLES = false;\n});\n\n// `Array.prototype.find` method\n// https://tc39.es/ecma262/#sec-array.prototype.find\n$({\n  target: 'Array',\n  proto: true,\n  forced: SKIPS_HOLES\n}, {\n  find: function find(callbackfn /* , that = undefined */) {\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables(FIND);\nvar CONSTANT = {\n  GLOBAL: {\n    HIDE: '__react_tooltip_hide_event',\n    REBUILD: '__react_tooltip_rebuild_event',\n    SHOW: '__react_tooltip_show_event'\n  }\n};\n\n/**\n * Static methods for react-tooltip\n */\nvar dispatchGlobalEvent = function dispatchGlobalEvent(eventName, opts) {\n  // Compatible with IE\n  // @see http://stackoverflow.com/questions/26596123/internet-explorer-9-10-11-event-constructor-doesnt-work\n  // @see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n  var event;\n  if (typeof window.CustomEvent === 'function') {\n    event = new window.CustomEvent(eventName, {\n      detail: opts\n    });\n  } else {\n    event = document.createEvent('Event');\n    event.initEvent(eventName, false, true, opts);\n  }\n  window.dispatchEvent(event);\n};\nfunction staticMethods(target) {\n  /**\n   * Hide all tooltip\n   * @trigger ReactTooltip.hide()\n   */\n  target.hide = function (target) {\n    dispatchGlobalEvent(CONSTANT.GLOBAL.HIDE, {\n      target: target\n    });\n  };\n\n  /**\n   * Rebuild all tooltip\n   * @trigger ReactTooltip.rebuild()\n   */\n  target.rebuild = function () {\n    dispatchGlobalEvent(CONSTANT.GLOBAL.REBUILD);\n  };\n\n  /**\n   * Show specific tooltip\n   * @trigger ReactTooltip.show()\n   */\n  target.show = function (target) {\n    dispatchGlobalEvent(CONSTANT.GLOBAL.SHOW, {\n      target: target\n    });\n  };\n  target.prototype.globalRebuild = function () {\n    if (this.mount) {\n      this.unbindListener();\n      this.bindListener();\n    }\n  };\n  target.prototype.globalShow = function (event) {\n    if (this.mount) {\n      var hasTarget = event && event.detail && event.detail.target && true || false;\n      // Create a fake event, specific show will limit the type to `solid`\n      // only `float` type cares e.clientX e.clientY\n      this.showTooltip({\n        currentTarget: hasTarget && event.detail.target\n      }, true);\n    }\n  };\n  target.prototype.globalHide = function (event) {\n    if (this.mount) {\n      var hasTarget = event && event.detail && event.detail.target && true || false;\n      this.hideTooltip({\n        currentTarget: hasTarget && event.detail.target\n      }, hasTarget);\n    }\n  };\n}\n\n/**\n * Events that should be bound to the window\n */\nfunction windowListener(target) {\n  target.prototype.bindWindowEvents = function (resizeHide) {\n    // ReactTooltip.hide\n    window.removeEventListener(CONSTANT.GLOBAL.HIDE, this.globalHide);\n    window.addEventListener(CONSTANT.GLOBAL.HIDE, this.globalHide, false);\n\n    // ReactTooltip.rebuild\n    window.removeEventListener(CONSTANT.GLOBAL.REBUILD, this.globalRebuild);\n    window.addEventListener(CONSTANT.GLOBAL.REBUILD, this.globalRebuild, false);\n\n    // ReactTooltip.show\n    window.removeEventListener(CONSTANT.GLOBAL.SHOW, this.globalShow);\n    window.addEventListener(CONSTANT.GLOBAL.SHOW, this.globalShow, false);\n\n    // Resize\n    if (resizeHide) {\n      window.removeEventListener('resize', this.onWindowResize);\n      window.addEventListener('resize', this.onWindowResize, false);\n    }\n  };\n  target.prototype.unbindWindowEvents = function () {\n    window.removeEventListener(CONSTANT.GLOBAL.HIDE, this.globalHide);\n    window.removeEventListener(CONSTANT.GLOBAL.REBUILD, this.globalRebuild);\n    window.removeEventListener(CONSTANT.GLOBAL.SHOW, this.globalShow);\n    window.removeEventListener('resize', this.onWindowResize);\n  };\n\n  /**\n   * invoked by resize event of window\n   */\n  target.prototype.onWindowResize = function () {\n    if (!this.mount) return;\n    this.hideTooltip();\n  };\n}\n\n/**\n * Custom events to control showing and hiding of tooltip\n *\n * @attributes\n * - `event` {String}\n * - `eventOff` {String}\n */\n\nvar checkStatus = function checkStatus(dataEventOff, e) {\n  var show = this.state.show;\n  var id = this.props.id;\n  var isCapture = this.isCapture(e.currentTarget);\n  var currentItem = e.currentTarget.getAttribute('currentItem');\n  if (!isCapture) e.stopPropagation();\n  if (show && currentItem === 'true') {\n    if (!dataEventOff) this.hideTooltip(e);\n  } else {\n    e.currentTarget.setAttribute('currentItem', 'true');\n    setUntargetItems(e.currentTarget, this.getTargetArray(id));\n    this.showTooltip(e);\n  }\n};\nvar setUntargetItems = function setUntargetItems(currentTarget, targetArray) {\n  for (var i = 0; i < targetArray.length; i++) {\n    if (currentTarget !== targetArray[i]) {\n      targetArray[i].setAttribute('currentItem', 'false');\n    } else {\n      targetArray[i].setAttribute('currentItem', 'true');\n    }\n  }\n};\nvar customListeners = {\n  id: '9b69f92e-d3fe-498b-b1b4-c5e63a51b0cf',\n  set: function set(target, event, listener) {\n    if (this.id in target) {\n      var map = target[this.id];\n      map[event] = listener;\n    } else {\n      // this is workaround for WeakMap, which is not supported in older browsers, such as IE\n      Object.defineProperty(target, this.id, {\n        configurable: true,\n        value: index_es_defineProperty({}, event, listener)\n      });\n    }\n  },\n  get: function get(target, event) {\n    var map = target[this.id];\n    if (map !== undefined) {\n      return map[event];\n    }\n  }\n};\nfunction customEvent(target) {\n  target.prototype.isCustomEvent = function (ele) {\n    var event = this.state.event;\n    return event || !!ele.getAttribute('data-event');\n  };\n\n  /* Bind listener for custom event */\n  target.prototype.customBindListener = function (ele) {\n    var _this = this;\n    var _this$state = this.state,\n      event = _this$state.event,\n      eventOff = _this$state.eventOff;\n    var dataEvent = ele.getAttribute('data-event') || event;\n    var dataEventOff = ele.getAttribute('data-event-off') || eventOff;\n    dataEvent.split(' ').forEach(function (event) {\n      ele.removeEventListener(event, customListeners.get(ele, event));\n      var customListener = checkStatus.bind(_this, dataEventOff);\n      customListeners.set(ele, event, customListener);\n      ele.addEventListener(event, customListener, false);\n    });\n    if (dataEventOff) {\n      dataEventOff.split(' ').forEach(function (event) {\n        ele.removeEventListener(event, _this.hideTooltip);\n        ele.addEventListener(event, _this.hideTooltip, false);\n      });\n    }\n  };\n\n  /* Unbind listener for custom event */\n  target.prototype.customUnbindListener = function (ele) {\n    var _this$state2 = this.state,\n      event = _this$state2.event,\n      eventOff = _this$state2.eventOff;\n    var dataEvent = event || ele.getAttribute('data-event');\n    var dataEventOff = eventOff || ele.getAttribute('data-event-off');\n    ele.removeEventListener(dataEvent, customListeners.get(ele, event));\n    if (dataEventOff) ele.removeEventListener(dataEventOff, this.hideTooltip);\n  };\n}\n\n/**\n * Util method to judge if it should follow capture model\n */\n\nfunction isCapture(target) {\n  target.prototype.isCapture = function (currentTarget) {\n    return currentTarget && currentTarget.getAttribute('data-iscapture') === 'true' || this.props.isCapture || false;\n  };\n}\n\n/**\n * Util method to get effect\n */\n\nfunction getEffect(target) {\n  target.prototype.getEffect = function (currentTarget) {\n    var dataEffect = currentTarget.getAttribute('data-effect');\n    return dataEffect || this.props.effect || 'float';\n  };\n}\n\n/**\n * Util method to get effect\n */\nvar makeProxy = function makeProxy(e) {\n  var proxy = {};\n  for (var key in e) {\n    if (typeof e[key] === 'function') {\n      proxy[key] = e[key].bind(e);\n    } else {\n      proxy[key] = e[key];\n    }\n  }\n  return proxy;\n};\nvar bodyListener = function bodyListener(callback, options, e) {\n  var _options$respectEffec = options.respectEffect,\n    respectEffect = _options$respectEffec === void 0 ? false : _options$respectEffec,\n    _options$customEvent = options.customEvent,\n    customEvent = _options$customEvent === void 0 ? false : _options$customEvent;\n  var id = this.props.id;\n  var tip = null;\n  var forId;\n  var target = e.target;\n  var lastTarget;\n  // walk up parent chain until tip is found\n  // there is no match if parent visible area is matched by mouse position, so some corner cases might not work as expected\n  while (tip === null && target !== null) {\n    lastTarget = target;\n    tip = target.getAttribute('data-tip') || null;\n    forId = target.getAttribute('data-for') || null;\n    target = target.parentElement;\n  }\n  target = lastTarget || e.target;\n  if (this.isCustomEvent(target) && !customEvent) {\n    return;\n  }\n  var isTargetBelongsToTooltip = id == null && forId == null || forId === id;\n  if (tip != null && (!respectEffect || this.getEffect(target) === 'float') && isTargetBelongsToTooltip) {\n    var proxy = makeProxy(e);\n    proxy.currentTarget = target;\n    callback(proxy);\n  }\n};\nvar findCustomEvents = function findCustomEvents(targetArray, dataAttribute) {\n  var events = {};\n  targetArray.forEach(function (target) {\n    var event = target.getAttribute(dataAttribute);\n    if (event) event.split(' ').forEach(function (event) {\n      return events[event] = true;\n    });\n  });\n  return events;\n};\nvar getBody = function getBody() {\n  return document.getElementsByTagName('body')[0];\n};\nfunction bodyMode(target) {\n  target.prototype.isBodyMode = function () {\n    return !!this.props.bodyMode;\n  };\n  target.prototype.bindBodyListener = function (targetArray) {\n    var _this = this;\n    var _this$state = this.state,\n      event = _this$state.event,\n      eventOff = _this$state.eventOff,\n      possibleCustomEvents = _this$state.possibleCustomEvents,\n      possibleCustomEventsOff = _this$state.possibleCustomEventsOff;\n    var body = getBody();\n    var customEvents = findCustomEvents(targetArray, 'data-event');\n    var customEventsOff = findCustomEvents(targetArray, 'data-event-off');\n    if (event != null) customEvents[event] = true;\n    if (eventOff != null) customEventsOff[eventOff] = true;\n    possibleCustomEvents.split(' ').forEach(function (event) {\n      return customEvents[event] = true;\n    });\n    possibleCustomEventsOff.split(' ').forEach(function (event) {\n      return customEventsOff[event] = true;\n    });\n    this.unbindBodyListener(body);\n    var listeners = this.bodyModeListeners = {};\n    if (event == null) {\n      listeners.mouseover = bodyListener.bind(this, this.showTooltip, {});\n      listeners.mousemove = bodyListener.bind(this, this.updateTooltip, {\n        respectEffect: true\n      });\n      listeners.mouseout = bodyListener.bind(this, this.hideTooltip, {});\n    }\n    for (var _event in customEvents) {\n      listeners[_event] = bodyListener.bind(this, function (e) {\n        var targetEventOff = e.currentTarget.getAttribute('data-event-off') || eventOff;\n        checkStatus.call(_this, targetEventOff, e);\n      }, {\n        customEvent: true\n      });\n    }\n    for (var _event2 in customEventsOff) {\n      listeners[_event2] = bodyListener.bind(this, this.hideTooltip, {\n        customEvent: true\n      });\n    }\n    for (var _event3 in listeners) {\n      body.addEventListener(_event3, listeners[_event3]);\n    }\n  };\n  target.prototype.unbindBodyListener = function (body) {\n    body = body || getBody();\n    var listeners = this.bodyModeListeners;\n    for (var event in listeners) {\n      body.removeEventListener(event, listeners[event]);\n    }\n  };\n}\n\n/**\n * Tracking target removing from DOM.\n * It's necessary to hide tooltip when it's target disappears.\n * Otherwise, the tooltip would be shown forever until another target\n * is triggered.\n *\n * If MutationObserver is not available, this feature just doesn't work.\n */\n\n// https://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/\nvar getMutationObserverClass = function getMutationObserverClass() {\n  return window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;\n};\nfunction trackRemoval(target) {\n  target.prototype.bindRemovalTracker = function () {\n    var _this = this;\n    var MutationObserver = getMutationObserverClass();\n    if (MutationObserver == null) return;\n    var observer = new MutationObserver(function (mutations) {\n      for (var m1 = 0; m1 < mutations.length; m1++) {\n        var mutation = mutations[m1];\n        for (var m2 = 0; m2 < mutation.removedNodes.length; m2++) {\n          var element = mutation.removedNodes[m2];\n          if (element === _this.state.currentTarget) {\n            _this.hideTooltip();\n            return;\n          }\n        }\n      }\n    });\n    observer.observe(window.document, {\n      childList: true,\n      subtree: true\n    });\n    this.removalTracker = observer;\n  };\n  target.prototype.unbindRemovalTracker = function () {\n    if (this.removalTracker) {\n      this.removalTracker.disconnect();\n      this.removalTracker = null;\n    }\n  };\n}\n\n/**\n * Calculate the position of tooltip\n *\n * @params\n * - `e` {Event} the event of current mouse\n * - `target` {Element} the currentTarget of the event\n * - `node` {DOM} the react-tooltip object\n * - `place` {String} top / right / bottom / left\n * - `effect` {String} float / solid\n * - `offset` {Object} the offset to default position\n *\n * @return {Object}\n * - `isNewState` {Bool} required\n * - `newState` {Object}\n * - `position` {Object} {left: {Number}, top: {Number}}\n */\nfunction index_es_getPosition(e, target, node, place, desiredPlace, effect, offset) {\n  var _getDimensions = getDimensions(node),\n    tipWidth = _getDimensions.width,\n    tipHeight = _getDimensions.height;\n  var _getDimensions2 = getDimensions(target),\n    targetWidth = _getDimensions2.width,\n    targetHeight = _getDimensions2.height;\n  var _getCurrentOffset = getCurrentOffset(e, target, effect),\n    mouseX = _getCurrentOffset.mouseX,\n    mouseY = _getCurrentOffset.mouseY;\n  var defaultOffset = getDefaultPosition(effect, targetWidth, targetHeight, tipWidth, tipHeight);\n  var _calculateOffset = calculateOffset(offset),\n    extraOffsetX = _calculateOffset.extraOffsetX,\n    extraOffsetY = _calculateOffset.extraOffsetY;\n  var windowWidth = window.innerWidth;\n  var windowHeight = window.innerHeight;\n  var _getParent = getParent(node),\n    parentTop = _getParent.parentTop,\n    parentLeft = _getParent.parentLeft;\n\n  // Get the edge offset of the tooltip\n  var getTipOffsetLeft = function getTipOffsetLeft(place) {\n    var offsetX = defaultOffset[place].l;\n    return mouseX + offsetX + extraOffsetX;\n  };\n  var getTipOffsetRight = function getTipOffsetRight(place) {\n    var offsetX = defaultOffset[place].r;\n    return mouseX + offsetX + extraOffsetX;\n  };\n  var getTipOffsetTop = function getTipOffsetTop(place) {\n    var offsetY = defaultOffset[place].t;\n    return mouseY + offsetY + extraOffsetY;\n  };\n  var getTipOffsetBottom = function getTipOffsetBottom(place) {\n    var offsetY = defaultOffset[place].b;\n    return mouseY + offsetY + extraOffsetY;\n  };\n\n  //\n  // Functions to test whether the tooltip's sides are inside\n  // the client window for a given orientation p\n  //\n  //  _____________\n  // |             | <-- Right side\n  // | p = 'left'  |\\\n  // |             |/  |\\\n  // |_____________|   |_\\  <-- Mouse\n  //      / \\           |\n  //       |\n  //       |\n  //  Bottom side\n  //\n  var outsideLeft = function outsideLeft(p) {\n    return getTipOffsetLeft(p) < 0;\n  };\n  var outsideRight = function outsideRight(p) {\n    return getTipOffsetRight(p) > windowWidth;\n  };\n  var outsideTop = function outsideTop(p) {\n    return getTipOffsetTop(p) < 0;\n  };\n  var outsideBottom = function outsideBottom(p) {\n    return getTipOffsetBottom(p) > windowHeight;\n  };\n\n  // Check whether the tooltip with orientation p is completely inside the client window\n  var outside = function outside(p) {\n    return outsideLeft(p) || outsideRight(p) || outsideTop(p) || outsideBottom(p);\n  };\n  var inside = function inside(p) {\n    return !outside(p);\n  };\n  var placeIsInside = {\n    top: inside('top'),\n    bottom: inside('bottom'),\n    left: inside('left'),\n    right: inside('right')\n  };\n  function choose() {\n    var allPlaces = desiredPlace.split(',').concat(place, ['top', 'bottom', 'left', 'right']);\n    var _iterator = index_es_createForOfIteratorHelper(allPlaces),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var d = _step.value;\n        if (placeIsInside[d]) return d;\n      }\n      // if nothing is inside, just use the old place.\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return place;\n  }\n  var chosen = choose();\n  var isNewState = false;\n  var newPlace;\n  if (chosen && chosen !== place) {\n    isNewState = true;\n    newPlace = chosen;\n  }\n  if (isNewState) {\n    return {\n      isNewState: true,\n      newState: {\n        place: newPlace\n      }\n    };\n  }\n  return {\n    isNewState: false,\n    position: {\n      left: parseInt(getTipOffsetLeft(place) - parentLeft, 10),\n      top: parseInt(getTipOffsetTop(place) - parentTop, 10)\n    }\n  };\n}\nvar getDimensions = function getDimensions(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n    height = _node$getBoundingClie.height,\n    width = _node$getBoundingClie.width;\n  return {\n    height: parseInt(height, 10),\n    width: parseInt(width, 10)\n  };\n};\n\n// Get current mouse offset\nvar getCurrentOffset = function getCurrentOffset(e, currentTarget, effect) {\n  var boundingClientRect = currentTarget.getBoundingClientRect();\n  var targetTop = boundingClientRect.top;\n  var targetLeft = boundingClientRect.left;\n  var _getDimensions3 = getDimensions(currentTarget),\n    targetWidth = _getDimensions3.width,\n    targetHeight = _getDimensions3.height;\n  if (effect === 'float') {\n    return {\n      mouseX: e.clientX,\n      mouseY: e.clientY\n    };\n  }\n  return {\n    mouseX: targetLeft + targetWidth / 2,\n    mouseY: targetTop + targetHeight / 2\n  };\n};\n\n// List all possibility of tooltip final offset\n// This is useful in judging if it is necessary for tooltip to switch position when out of window\nvar getDefaultPosition = function getDefaultPosition(effect, targetWidth, targetHeight, tipWidth, tipHeight) {\n  var top;\n  var right;\n  var bottom;\n  var left;\n  var disToMouse = 3;\n  var triangleHeight = 2;\n  var cursorHeight = 12; // Optimize for float bottom only, cause the cursor will hide the tooltip\n\n  if (effect === 'float') {\n    top = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: -(tipHeight + disToMouse + triangleHeight),\n      b: -disToMouse\n    };\n    bottom = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: disToMouse + cursorHeight,\n      b: tipHeight + disToMouse + triangleHeight + cursorHeight\n    };\n    left = {\n      l: -(tipWidth + disToMouse + triangleHeight),\n      r: -disToMouse,\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n    right = {\n      l: disToMouse,\n      r: tipWidth + disToMouse + triangleHeight,\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n  } else if (effect === 'solid') {\n    top = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: -(targetHeight / 2 + tipHeight + triangleHeight),\n      b: -(targetHeight / 2)\n    };\n    bottom = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: targetHeight / 2,\n      b: targetHeight / 2 + tipHeight + triangleHeight\n    };\n    left = {\n      l: -(tipWidth + targetWidth / 2 + triangleHeight),\n      r: -(targetWidth / 2),\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n    right = {\n      l: targetWidth / 2,\n      r: tipWidth + targetWidth / 2 + triangleHeight,\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n  }\n  return {\n    top: top,\n    bottom: bottom,\n    left: left,\n    right: right\n  };\n};\n\n// Consider additional offset into position calculation\nvar calculateOffset = function calculateOffset(offset) {\n  var extraOffsetX = 0;\n  var extraOffsetY = 0;\n  if (Object.prototype.toString.apply(offset) === '[object String]') {\n    offset = JSON.parse(offset.toString().replace(/'/g, '\"'));\n  }\n  for (var key in offset) {\n    if (key === 'top') {\n      extraOffsetY -= parseInt(offset[key], 10);\n    } else if (key === 'bottom') {\n      extraOffsetY += parseInt(offset[key], 10);\n    } else if (key === 'left') {\n      extraOffsetX -= parseInt(offset[key], 10);\n    } else if (key === 'right') {\n      extraOffsetX += parseInt(offset[key], 10);\n    }\n  }\n  return {\n    extraOffsetX: extraOffsetX,\n    extraOffsetY: extraOffsetY\n  };\n};\n\n// Get the offset of the parent elements\nvar getParent = function getParent(currentTarget) {\n  var currentParent = currentTarget;\n  while (currentParent) {\n    var computedStyle = window.getComputedStyle(currentParent);\n    // transform and will-change: transform change the containing block\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_Block\n    if (computedStyle.getPropertyValue('transform') !== 'none' || computedStyle.getPropertyValue('will-change') === 'transform') break;\n    currentParent = currentParent.parentElement;\n  }\n  var parentTop = currentParent && currentParent.getBoundingClientRect().top || 0;\n  var parentLeft = currentParent && currentParent.getBoundingClientRect().left || 0;\n  return {\n    parentTop: parentTop,\n    parentLeft: parentLeft\n  };\n};\n\n/**\n * To get the tooltip content\n * it may comes from data-tip or this.props.children\n * it should support multiline\n *\n * @params\n * - `tip` {String} value of data-tip\n * - `children` {ReactElement} this.props.children\n * - `multiline` {Any} could be Bool(true/false) or String('true'/'false')\n *\n * @return\n * - String or react component\n */\nfunction TipContent(tip, children, getContent, multiline) {\n  if (children) return children;\n  if (getContent !== undefined && getContent !== null) return getContent; // getContent can be 0, '', etc.\n  if (getContent === null) return null; // Tip not exist and children is null or undefined\n\n  var regexp = /<br\\s*\\/?>/;\n  if (!multiline || multiline === 'false' || !regexp.test(tip)) {\n    // No trim(), so that user can keep their input\n    return tip;\n  }\n\n  // Multiline tooltip content\n  return tip.split(regexp).map(function (d, i) {\n    return /*#__PURE__*/react.createElement(\"span\", {\n      key: i,\n      className: \"multi-line\"\n    }, d);\n  });\n}\n\n/**\n * Support aria- and role in ReactTooltip\n *\n * @params props {Object}\n * @return {Object}\n */\nfunction parseAria(props) {\n  var ariaObj = {};\n  Object.keys(props).filter(function (prop) {\n    // aria-xxx and role is acceptable\n    return /(^aria-\\w+$|^role$)/.test(prop);\n  }).forEach(function (prop) {\n    ariaObj[prop] = props[prop];\n  });\n  return ariaObj;\n}\n\n/**\n * Convert nodelist to array\n * @see https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/core/createArrayFromMixed.js#L24\n * NodeLists are functions in Safari\n */\n\nfunction nodeListToArray(nodeList) {\n  var length = nodeList.length;\n  if (nodeList.hasOwnProperty) {\n    return Array.prototype.slice.call(nodeList);\n  }\n  return new Array(length).fill().map(function (index) {\n    return nodeList[index];\n  });\n}\nfunction generateUUID() {\n  return 't' + esm_browser_v4();\n}\nvar baseCss = \".__react_component_tooltip {\\n  border-radius: 3px;\\n  display: inline-block;\\n  font-size: 13px;\\n  left: -999em;\\n  opacity: 0;\\n  position: fixed;\\n  pointer-events: none;\\n  transition: opacity 0.3s ease-out;\\n  top: -999em;\\n  visibility: hidden;\\n  z-index: 999;\\n}\\n.__react_component_tooltip.allow_hover, .__react_component_tooltip.allow_click {\\n  pointer-events: auto;\\n}\\n.__react_component_tooltip::before, .__react_component_tooltip::after {\\n  content: \\\"\\\";\\n  width: 0;\\n  height: 0;\\n  position: absolute;\\n}\\n.__react_component_tooltip.show {\\n  opacity: 0.9;\\n  margin-top: 0;\\n  margin-left: 0;\\n  visibility: visible;\\n}\\n.__react_component_tooltip.place-top::before {\\n  bottom: 0;\\n  left: 50%;\\n  margin-left: -11px;\\n}\\n.__react_component_tooltip.place-bottom::before {\\n  top: 0;\\n  left: 50%;\\n  margin-left: -11px;\\n}\\n.__react_component_tooltip.place-left::before {\\n  right: 0;\\n  top: 50%;\\n  margin-top: -9px;\\n}\\n.__react_component_tooltip.place-right::before {\\n  left: 0;\\n  top: 50%;\\n  margin-top: -9px;\\n}\\n.__react_component_tooltip .multi-line {\\n  display: block;\\n  padding: 2px 0;\\n  text-align: center;\\n}\";\n\n/**\n * Default pop-up style values (text color, background color).\n */\nvar defaultColors = {\n  dark: {\n    text: '#fff',\n    background: '#222',\n    border: 'transparent',\n    arrow: '#222'\n  },\n  success: {\n    text: '#fff',\n    background: '#8DC572',\n    border: 'transparent',\n    arrow: '#8DC572'\n  },\n  warning: {\n    text: '#fff',\n    background: '#F0AD4E',\n    border: 'transparent',\n    arrow: '#F0AD4E'\n  },\n  error: {\n    text: '#fff',\n    background: '#BE6464',\n    border: 'transparent',\n    arrow: '#BE6464'\n  },\n  info: {\n    text: '#fff',\n    background: '#337AB7',\n    border: 'transparent',\n    arrow: '#337AB7'\n  },\n  light: {\n    text: '#222',\n    background: '#fff',\n    border: 'transparent',\n    arrow: '#fff'\n  }\n};\nfunction getDefaultPopupColors(type) {\n  return defaultColors[type] ? _objectSpread2({}, defaultColors[type]) : undefined;\n}\nvar DEFAULT_PADDING = '8px 21px';\nvar DEFAULT_RADIUS = {\n  tooltip: 3,\n  arrow: 0\n};\n\n/**\n * Generates the specific tooltip style for use on render.\n */\nfunction generateTooltipStyle(uuid, customColors, type, hasBorder, padding, radius) {\n  return generateStyle(uuid, getPopupColors(customColors, type, hasBorder), padding, radius);\n}\n\n/**\n * Generates the tooltip style rules based on the element-specified \"data-type\" property.\n */\nfunction generateStyle(uuid, colors) {\n  var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_PADDING;\n  var radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_RADIUS;\n  var textColor = colors.text;\n  var backgroundColor = colors.background;\n  var borderColor = colors.border;\n  var arrowColor = colors.arrow;\n  var arrowRadius = radius.arrow;\n  var tooltipRadius = radius.tooltip;\n  return \"\\n  \\t.\".concat(uuid, \" {\\n\\t    color: \").concat(textColor, \";\\n\\t    background: \").concat(backgroundColor, \";\\n\\t    border: 1px solid \").concat(borderColor, \";\\n\\t    border-radius: \").concat(tooltipRadius, \"px;\\n\\t    padding: \").concat(padding, \";\\n  \\t}\\n\\n  \\t.\").concat(uuid, \".place-top {\\n        margin-top: -10px;\\n    }\\n    .\").concat(uuid, \".place-top::before {\\n        content: \\\"\\\";\\n        background-color: inherit;\\n        position: absolute;\\n        z-index: 2;\\n        width: 20px;\\n        height: 12px;\\n    }\\n    .\").concat(uuid, \".place-top::after {\\n        content: \\\"\\\";\\n        position: absolute;\\n        width: 10px;\\n        height: 10px;\\n        border-top-right-radius: \").concat(arrowRadius, \"px;\\n        border: 1px solid \").concat(borderColor, \";\\n        background-color: \").concat(arrowColor, \";\\n        z-index: -2;\\n        bottom: -6px;\\n        left: 50%;\\n        margin-left: -6px;\\n        transform: rotate(135deg);\\n    }\\n\\n    .\").concat(uuid, \".place-bottom {\\n        margin-top: 10px;\\n    }\\n    .\").concat(uuid, \".place-bottom::before {\\n        content: \\\"\\\";\\n        background-color: inherit;\\n        position: absolute;\\n        z-index: -1;\\n        width: 18px;\\n        height: 10px;\\n    }\\n    .\").concat(uuid, \".place-bottom::after {\\n        content: \\\"\\\";\\n        position: absolute;\\n        width: 10px;\\n        height: 10px;\\n        border-top-right-radius: \").concat(arrowRadius, \"px;\\n        border: 1px solid \").concat(borderColor, \";\\n        background-color: \").concat(arrowColor, \";\\n        z-index: -2;\\n        top: -6px;\\n        left: 50%;\\n        margin-left: -6px;\\n        transform: rotate(45deg);\\n    }\\n\\n    .\").concat(uuid, \".place-left {\\n        margin-left: -10px;\\n    }\\n    .\").concat(uuid, \".place-left::before {\\n        content: \\\"\\\";\\n        background-color: inherit;\\n        position: absolute;\\n        z-index: -1;\\n        width: 10px;\\n        height: 18px;\\n    }\\n    .\").concat(uuid, \".place-left::after {\\n        content: \\\"\\\";\\n        position: absolute;\\n        width: 10px;\\n        height: 10px;\\n        border-top-right-radius: \").concat(arrowRadius, \"px;\\n        border: 1px solid \").concat(borderColor, \";\\n        background-color: \").concat(arrowColor, \";\\n        z-index: -2;\\n        right: -6px;\\n        top: 50%;\\n        margin-top: -6px;\\n        transform: rotate(45deg);\\n    }\\n\\n    .\").concat(uuid, \".place-right {\\n        margin-left: 10px;\\n    }\\n    .\").concat(uuid, \".place-right::before {\\n        content: \\\"\\\";\\n        background-color: inherit;\\n        position: absolute;\\n        z-index: -1;\\n        width: 10px;\\n        height: 18px;\\n    }\\n    .\").concat(uuid, \".place-right::after {\\n        content: \\\"\\\";\\n        position: absolute;\\n        width: 10px;\\n        height: 10px;\\n        border-top-right-radius: \").concat(arrowRadius, \"px;\\n        border: 1px solid \").concat(borderColor, \";\\n        background-color: \").concat(arrowColor, \";\\n        z-index: -2;\\n        left: -6px;\\n        top: 50%;\\n        margin-top: -6px;\\n        transform: rotate(-135deg);\\n    }\\n  \");\n}\nfunction getPopupColors(customColors, type, hasBorder) {\n  var textColor = customColors.text;\n  var backgroundColor = customColors.background;\n  var borderColor = customColors.border;\n  var arrowColor = customColors.arrow ? customColors.arrow : customColors.background;\n  var colors = getDefaultPopupColors(type);\n  if (textColor) {\n    colors.text = textColor;\n  }\n  if (backgroundColor) {\n    colors.background = backgroundColor;\n  }\n  if (hasBorder) {\n    if (borderColor) {\n      colors.border = borderColor;\n    } else {\n      colors.border = type === 'light' ? 'black' : 'white';\n    }\n  }\n  if (arrowColor) {\n    colors.arrow = arrowColor;\n  }\n  return colors;\n}\nvar _class, _class2;\n\n/* Polyfill */\nvar ReactTooltip = staticMethods(_class = windowListener(_class = customEvent(_class = isCapture(_class = getEffect(_class = bodyMode(_class = trackRemoval(_class = (_class2 = /*#__PURE__*/function (_React$Component) {\n  index_es_inherits(ReactTooltip, _React$Component);\n  var _super = index_es_createSuper(ReactTooltip);\n  function ReactTooltip(props) {\n    var _this;\n    index_es_classCallCheck(this, ReactTooltip);\n    _this = _super.call(this, props);\n    _this.state = {\n      uuid: props.uuid || generateUUID(),\n      place: props.place || 'top',\n      // Direction of tooltip\n      desiredPlace: props.place || 'top',\n      type: props.type || 'dark',\n      // Color theme of tooltip\n      effect: props.effect || 'float',\n      // float or fixed\n      show: false,\n      border: false,\n      borderClass: 'border',\n      customColors: {},\n      customRadius: {},\n      offset: {},\n      padding: props.padding,\n      extraClass: '',\n      html: false,\n      delayHide: 0,\n      delayShow: 0,\n      event: props.event || null,\n      eventOff: props.eventOff || null,\n      currentEvent: null,\n      // Current mouse event\n      currentTarget: null,\n      // Current target of mouse event\n      ariaProps: parseAria(props),\n      // aria- and role attributes\n      isEmptyTip: false,\n      disable: false,\n      possibleCustomEvents: props.possibleCustomEvents || '',\n      possibleCustomEventsOff: props.possibleCustomEventsOff || '',\n      originTooltip: null,\n      isMultiline: false\n    };\n    _this.bind(['showTooltip', 'updateTooltip', 'hideTooltip', 'hideTooltipOnScroll', 'getTooltipContent', 'globalRebuild', 'globalShow', 'globalHide', 'onWindowResize', 'mouseOnToolTip']);\n    _this.mount = true;\n    _this.delayShowLoop = null;\n    _this.delayHideLoop = null;\n    _this.delayReshow = null;\n    _this.intervalUpdateContent = null;\n    return _this;\n  }\n\n  /**\n   * For unify the bind and unbind listener\n   */\n  index_es_createClass(ReactTooltip, [{\n    key: \"bind\",\n    value: function bind(methodArray) {\n      var _this2 = this;\n      methodArray.forEach(function (method) {\n        _this2[method] = _this2[method].bind(_this2);\n      });\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props = this.props;\n      _this$props.insecure;\n      var resizeHide = _this$props.resizeHide,\n        disableInternalStyle = _this$props.disableInternalStyle;\n      this.mount = true;\n      this.bindListener(); // Bind listener for tooltip\n      this.bindWindowEvents(resizeHide); // Bind global event for static method\n\n      if (!disableInternalStyle) {\n        this.injectStyles(); // Inject styles for each DOM root having tooltip.\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.mount = false;\n      this.clearTimer();\n      this.unbindListener();\n      this.removeScrollListener(this.state.currentTarget);\n      this.unbindWindowEvents();\n    }\n\n    /* Look for the closest DOM root having tooltip and inject styles. */\n  }, {\n    key: \"injectStyles\",\n    value: function injectStyles() {\n      var tooltipRef = this.tooltipRef;\n      if (!tooltipRef) {\n        return;\n      }\n      var parentNode = tooltipRef.parentNode;\n      while (parentNode.parentNode) {\n        parentNode = parentNode.parentNode;\n      }\n      var domRoot;\n      switch (parentNode.constructor.name) {\n        case 'Document':\n        case 'HTMLDocument':\n        case undefined:\n          domRoot = parentNode.head;\n          break;\n        case 'ShadowRoot':\n        default:\n          domRoot = parentNode;\n          break;\n      }\n\n      // Prevent styles duplication.\n      if (!domRoot.querySelector('style[data-react-tooltip]')) {\n        var style = document.createElement('style');\n        style.textContent = baseCss;\n        style.setAttribute('data-react-tooltip', 'true');\n        domRoot.appendChild(style);\n      }\n    }\n\n    /**\n     * Return if the mouse is on the tooltip.\n     * @returns {boolean} true - mouse is on the tooltip\n     */\n  }, {\n    key: \"mouseOnToolTip\",\n    value: function mouseOnToolTip() {\n      var show = this.state.show;\n      if (show && this.tooltipRef) {\n        /* old IE or Firefox work around */\n        if (!this.tooltipRef.matches) {\n          /* old IE work around */\n          if (this.tooltipRef.msMatchesSelector) {\n            this.tooltipRef.matches = this.tooltipRef.msMatchesSelector;\n          } else {\n            /* old Firefox work around */\n            this.tooltipRef.matches = this.tooltipRef.mozMatchesSelector;\n          }\n        }\n        return this.tooltipRef.matches(':hover');\n      }\n      return false;\n    }\n\n    /**\n     * Pick out corresponded target elements\n     */\n  }, {\n    key: \"getTargetArray\",\n    value: function getTargetArray(id) {\n      var targetArray = [];\n      var selector;\n      if (!id) {\n        selector = '[data-tip]:not([data-for])';\n      } else {\n        var escaped = id.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\n        selector = \"[data-tip][data-for=\\\"\".concat(escaped, \"\\\"]\");\n      }\n\n      // Scan document for shadow DOM elements\n      nodeListToArray(document.getElementsByTagName('*')).filter(function (element) {\n        return element.shadowRoot;\n      }).forEach(function (element) {\n        targetArray = targetArray.concat(nodeListToArray(element.shadowRoot.querySelectorAll(selector)));\n      });\n      return targetArray.concat(nodeListToArray(document.querySelectorAll(selector)));\n    }\n\n    /**\n     * Bind listener to the target elements\n     * These listeners used to trigger showing or hiding the tooltip\n     */\n  }, {\n    key: \"bindListener\",\n    value: function bindListener() {\n      var _this3 = this;\n      var _this$props2 = this.props,\n        id = _this$props2.id,\n        globalEventOff = _this$props2.globalEventOff,\n        isCapture = _this$props2.isCapture;\n      var targetArray = this.getTargetArray(id);\n      targetArray.forEach(function (target) {\n        if (target.getAttribute('currentItem') === null) {\n          target.setAttribute('currentItem', 'false');\n        }\n        _this3.unbindBasicListener(target);\n        if (_this3.isCustomEvent(target)) {\n          _this3.customUnbindListener(target);\n        }\n      });\n      if (this.isBodyMode()) {\n        this.bindBodyListener(targetArray);\n      } else {\n        targetArray.forEach(function (target) {\n          var isCaptureMode = _this3.isCapture(target);\n          var effect = _this3.getEffect(target);\n          if (_this3.isCustomEvent(target)) {\n            _this3.customBindListener(target);\n            return;\n          }\n          target.addEventListener('mouseenter', _this3.showTooltip, isCaptureMode);\n          target.addEventListener('focus', _this3.showTooltip, isCaptureMode);\n          if (effect === 'float') {\n            target.addEventListener('mousemove', _this3.updateTooltip, isCaptureMode);\n          }\n          target.addEventListener('mouseleave', _this3.hideTooltip, isCaptureMode);\n          target.addEventListener('blur', _this3.hideTooltip, isCaptureMode);\n        });\n      }\n\n      // Global event to hide tooltip\n      if (globalEventOff) {\n        window.removeEventListener(globalEventOff, this.hideTooltip);\n        window.addEventListener(globalEventOff, this.hideTooltip, isCapture);\n      }\n\n      // Track removal of targetArray elements from DOM\n      this.bindRemovalTracker();\n    }\n\n    /**\n     * Unbind listeners on target elements\n     */\n  }, {\n    key: \"unbindListener\",\n    value: function unbindListener() {\n      var _this4 = this;\n      var _this$props3 = this.props,\n        id = _this$props3.id,\n        globalEventOff = _this$props3.globalEventOff;\n      if (this.isBodyMode()) {\n        this.unbindBodyListener();\n      } else {\n        var targetArray = this.getTargetArray(id);\n        targetArray.forEach(function (target) {\n          _this4.unbindBasicListener(target);\n          if (_this4.isCustomEvent(target)) _this4.customUnbindListener(target);\n        });\n      }\n      if (globalEventOff) window.removeEventListener(globalEventOff, this.hideTooltip);\n      this.unbindRemovalTracker();\n    }\n\n    /**\n     * Invoke this before bind listener and unmount the component\n     * it is necessary to invoke this even when binding custom event\n     * so that the tooltip can switch between custom and default listener\n     */\n  }, {\n    key: \"unbindBasicListener\",\n    value: function unbindBasicListener(target) {\n      var isCaptureMode = this.isCapture(target);\n      target.removeEventListener('mouseenter', this.showTooltip, isCaptureMode);\n      target.removeEventListener('mousemove', this.updateTooltip, isCaptureMode);\n      target.removeEventListener('mouseleave', this.hideTooltip, isCaptureMode);\n    }\n  }, {\n    key: \"getTooltipContent\",\n    value: function getTooltipContent() {\n      var _this$props4 = this.props,\n        getContent = _this$props4.getContent,\n        children = _this$props4.children;\n\n      // Generate tooltip content\n      var content;\n      if (getContent) {\n        if (Array.isArray(getContent)) {\n          content = getContent[0] && getContent[0](this.state.originTooltip);\n        } else {\n          content = getContent(this.state.originTooltip);\n        }\n      }\n      return TipContent(this.state.originTooltip, children, content, this.state.isMultiline);\n    }\n  }, {\n    key: \"isEmptyTip\",\n    value: function isEmptyTip(placeholder) {\n      return typeof placeholder === 'string' && placeholder === '' || placeholder === null;\n    }\n\n    /**\n     * When mouse enter, show the tooltip\n     */\n  }, {\n    key: \"showTooltip\",\n    value: function showTooltip(e, isGlobalCall) {\n      if (!this.tooltipRef) {\n        return;\n      }\n      if (isGlobalCall) {\n        // Don't trigger other elements belongs to other ReactTooltip\n        var targetArray = this.getTargetArray(this.props.id);\n        var isMyElement = targetArray.some(function (ele) {\n          return ele === e.currentTarget;\n        });\n        if (!isMyElement) return;\n      }\n      // Get the tooltip content\n      // calculate in this phrase so that tip width height can be detected\n      var _this$props5 = this.props,\n        multiline = _this$props5.multiline,\n        getContent = _this$props5.getContent;\n      var originTooltip = e.currentTarget.getAttribute('data-tip');\n      var isMultiline = e.currentTarget.getAttribute('data-multiline') || multiline || false;\n\n      // If it is focus event or called by ReactTooltip.show, switch to `solid` effect\n      var switchToSolid = e instanceof window.FocusEvent || isGlobalCall;\n\n      // if it needs to skip adding hide listener to scroll\n      var scrollHide = true;\n      if (e.currentTarget.getAttribute('data-scroll-hide')) {\n        scrollHide = e.currentTarget.getAttribute('data-scroll-hide') === 'true';\n      } else if (this.props.scrollHide != null) {\n        scrollHide = this.props.scrollHide;\n      }\n\n      // adding aria-describedby to target to make tooltips read by screen readers\n      if (e && e.currentTarget && e.currentTarget.setAttribute) {\n        e.currentTarget.setAttribute('aria-describedby', this.props.id || this.state.uuid);\n      }\n\n      // Make sure the correct place is set\n      var desiredPlace = e.currentTarget.getAttribute('data-place') || this.props.place || 'top';\n      var effect = switchToSolid && 'solid' || this.getEffect(e.currentTarget);\n      var offset = e.currentTarget.getAttribute('data-offset') || this.props.offset || {};\n      var result = index_es_getPosition(e, e.currentTarget, this.tooltipRef, desiredPlace.split(',')[0], desiredPlace, effect, offset);\n      if (result.position && this.props.overridePosition) {\n        result.position = this.props.overridePosition(result.position, e, e.currentTarget, this.tooltipRef, desiredPlace, desiredPlace, effect, offset);\n      }\n      var place = result.isNewState ? result.newState.place : desiredPlace.split(',')[0];\n\n      // To prevent previously created timers from triggering\n      this.clearTimer();\n      var target = e.currentTarget;\n      var reshowDelay = this.state.show ? target.getAttribute('data-delay-update') || this.props.delayUpdate : 0;\n      var self = this;\n      var updateState = function updateState() {\n        self.setState({\n          originTooltip: originTooltip,\n          isMultiline: isMultiline,\n          desiredPlace: desiredPlace,\n          place: place,\n          type: target.getAttribute('data-type') || self.props.type || 'dark',\n          customColors: {\n            text: target.getAttribute('data-text-color') || self.props.textColor || null,\n            background: target.getAttribute('data-background-color') || self.props.backgroundColor || null,\n            border: target.getAttribute('data-border-color') || self.props.borderColor || null,\n            arrow: target.getAttribute('data-arrow-color') || self.props.arrowColor || null\n          },\n          customRadius: {\n            tooltip: target.getAttribute('data-tooltip-radius') || self.props.tooltipRadius || '3',\n            arrow: target.getAttribute('data-arrow-radius') || self.props.arrowRadius || '0'\n          },\n          effect: effect,\n          offset: offset,\n          padding: target.getAttribute('data-padding') || self.props.padding,\n          html: (target.getAttribute('data-html') ? target.getAttribute('data-html') === 'true' : self.props.html) || false,\n          delayShow: target.getAttribute('data-delay-show') || self.props.delayShow || 0,\n          delayHide: target.getAttribute('data-delay-hide') || self.props.delayHide || 0,\n          delayUpdate: target.getAttribute('data-delay-update') || self.props.delayUpdate || 0,\n          border: (target.getAttribute('data-border') ? target.getAttribute('data-border') === 'true' : self.props.border) || false,\n          borderClass: target.getAttribute('data-border-class') || self.props.borderClass || 'border',\n          extraClass: target.getAttribute('data-class') || self.props[\"class\"] || self.props.className || '',\n          disable: (target.getAttribute('data-tip-disable') ? target.getAttribute('data-tip-disable') === 'true' : self.props.disable) || false,\n          currentTarget: target\n        }, function () {\n          if (scrollHide) {\n            self.addScrollListener(self.state.currentTarget);\n          }\n          self.updateTooltip(e);\n          if (getContent && Array.isArray(getContent)) {\n            self.intervalUpdateContent = setInterval(function () {\n              if (self.mount) {\n                var _getContent = self.props.getContent;\n                var placeholder = TipContent(originTooltip, '', _getContent[0](), isMultiline);\n                var isEmptyTip = self.isEmptyTip(placeholder);\n                self.setState({\n                  isEmptyTip: isEmptyTip\n                });\n                self.updatePosition();\n              }\n            }, getContent[1]);\n          }\n        });\n      };\n\n      // If there is no delay call immediately, don't allow events to get in first.\n      if (reshowDelay) {\n        this.delayReshow = setTimeout(updateState, reshowDelay);\n      } else {\n        updateState();\n      }\n    }\n\n    /**\n     * When mouse hover, update tool tip\n     */\n  }, {\n    key: \"updateTooltip\",\n    value: function updateTooltip(e) {\n      var _this5 = this;\n      var _this$state = this.state,\n        delayShow = _this$state.delayShow,\n        disable = _this$state.disable;\n      var _this$props6 = this.props,\n        afterShow = _this$props6.afterShow,\n        disableProp = _this$props6.disable;\n      var placeholder = this.getTooltipContent();\n      var eventTarget = e.currentTarget || e.target;\n\n      // Check if the mouse is actually over the tooltip, if so don't hide the tooltip\n      if (this.mouseOnToolTip()) {\n        return;\n      }\n\n      // if the tooltip is empty, disable the tooltip\n      if (this.isEmptyTip(placeholder) || disable || disableProp) {\n        return;\n      }\n      var delayTime = !this.state.show ? parseInt(delayShow, 10) : 0;\n      var updateState = function updateState() {\n        if (Array.isArray(placeholder) && placeholder.length > 0 || placeholder) {\n          var isInvisible = !_this5.state.show;\n          _this5.setState({\n            currentEvent: e,\n            currentTarget: eventTarget,\n            show: true\n          }, function () {\n            _this5.updatePosition(function () {\n              if (isInvisible && afterShow) {\n                afterShow(e);\n              }\n            });\n          });\n        }\n      };\n      if (this.delayShowLoop) {\n        clearTimeout(this.delayShowLoop);\n      }\n      if (delayTime) {\n        this.delayShowLoop = setTimeout(updateState, delayTime);\n      } else {\n        this.delayShowLoop = null;\n        updateState();\n      }\n    }\n\n    /*\n     * If we're mousing over the tooltip remove it when we leave.\n     */\n  }, {\n    key: \"listenForTooltipExit\",\n    value: function listenForTooltipExit() {\n      var show = this.state.show;\n      if (show && this.tooltipRef) {\n        this.tooltipRef.addEventListener('mouseleave', this.hideTooltip);\n      }\n    }\n  }, {\n    key: \"removeListenerForTooltipExit\",\n    value: function removeListenerForTooltipExit() {\n      var show = this.state.show;\n      if (show && this.tooltipRef) {\n        this.tooltipRef.removeEventListener('mouseleave', this.hideTooltip);\n      }\n    }\n\n    /**\n     * When mouse leave, hide tooltip\n     */\n  }, {\n    key: \"hideTooltip\",\n    value: function hideTooltip(e, hasTarget) {\n      var _this6 = this;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n        isScroll: false\n      };\n      var disable = this.state.disable;\n      var isScroll = options.isScroll;\n      var delayHide = isScroll ? 0 : this.state.delayHide;\n      var _this$props7 = this.props,\n        afterHide = _this$props7.afterHide,\n        disableProp = _this$props7.disable;\n      var placeholder = this.getTooltipContent();\n      if (!this.mount) return;\n      if (this.isEmptyTip(placeholder) || disable || disableProp) return; // if the tooltip is empty, disable the tooltip\n      if (hasTarget) {\n        // Don't trigger other elements belongs to other ReactTooltip\n        var targetArray = this.getTargetArray(this.props.id);\n        var isMyElement = targetArray.some(function (ele) {\n          return ele === e.currentTarget;\n        });\n        if (!isMyElement || !this.state.show) return;\n      }\n\n      // clean up aria-describedby when hiding tooltip\n      if (e && e.currentTarget && e.currentTarget.removeAttribute) {\n        e.currentTarget.removeAttribute('aria-describedby');\n      }\n      var resetState = function resetState() {\n        var isVisible = _this6.state.show;\n        // Check if the mouse is actually over the tooltip, if so don't hide the tooltip\n        if (_this6.mouseOnToolTip()) {\n          _this6.listenForTooltipExit();\n          return;\n        }\n        _this6.removeListenerForTooltipExit();\n        _this6.setState({\n          show: false\n        }, function () {\n          _this6.removeScrollListener(_this6.state.currentTarget);\n          if (isVisible && afterHide) {\n            afterHide(e);\n          }\n        });\n      };\n      this.clearTimer();\n      if (delayHide) {\n        this.delayHideLoop = setTimeout(resetState, parseInt(delayHide, 10));\n      } else {\n        resetState();\n      }\n    }\n\n    /**\n     * When scroll, hide tooltip\n     */\n  }, {\n    key: \"hideTooltipOnScroll\",\n    value: function hideTooltipOnScroll(event, hasTarget) {\n      this.hideTooltip(event, hasTarget, {\n        isScroll: true\n      });\n    }\n\n    /**\n     * Add scroll event listener when tooltip show\n     * automatically hide the tooltip when scrolling\n     */\n  }, {\n    key: \"addScrollListener\",\n    value: function addScrollListener(currentTarget) {\n      var isCaptureMode = this.isCapture(currentTarget);\n      window.addEventListener('scroll', this.hideTooltipOnScroll, isCaptureMode);\n    }\n  }, {\n    key: \"removeScrollListener\",\n    value: function removeScrollListener(currentTarget) {\n      var isCaptureMode = this.isCapture(currentTarget);\n      window.removeEventListener('scroll', this.hideTooltipOnScroll, isCaptureMode);\n    }\n\n    // Calculation the position\n  }, {\n    key: \"updatePosition\",\n    value: function updatePosition(callbackAfter) {\n      var _this7 = this;\n      var _this$state2 = this.state,\n        currentEvent = _this$state2.currentEvent,\n        currentTarget = _this$state2.currentTarget,\n        place = _this$state2.place,\n        desiredPlace = _this$state2.desiredPlace,\n        effect = _this$state2.effect,\n        offset = _this$state2.offset;\n      var node = this.tooltipRef;\n      var result = index_es_getPosition(currentEvent, currentTarget, node, place, desiredPlace, effect, offset);\n      if (result.position && this.props.overridePosition) {\n        result.position = this.props.overridePosition(result.position, currentEvent, currentTarget, node, place, desiredPlace, effect, offset);\n      }\n      if (result.isNewState) {\n        // Switch to reverse placement\n        return this.setState(result.newState, function () {\n          _this7.updatePosition(callbackAfter);\n        });\n      }\n      if (callbackAfter && typeof callbackAfter === 'function') {\n        callbackAfter();\n      }\n\n      // Set tooltip position\n      node.style.left = result.position.left + 'px';\n      node.style.top = result.position.top + 'px';\n    }\n\n    /**\n     * CLear all kinds of timeout of interval\n     */\n  }, {\n    key: \"clearTimer\",\n    value: function clearTimer() {\n      if (this.delayShowLoop) {\n        clearTimeout(this.delayShowLoop);\n        this.delayShowLoop = null;\n      }\n      if (this.delayHideLoop) {\n        clearTimeout(this.delayHideLoop);\n        this.delayHideLoop = null;\n      }\n      if (this.delayReshow) {\n        clearTimeout(this.delayReshow);\n        this.delayReshow = null;\n      }\n      if (this.intervalUpdateContent) {\n        clearInterval(this.intervalUpdateContent);\n        this.intervalUpdateContent = null;\n      }\n    }\n  }, {\n    key: \"hasCustomColors\",\n    value: function hasCustomColors() {\n      var _this8 = this;\n      return Boolean(Object.keys(this.state.customColors).find(function (color) {\n        return color !== 'border' && _this8.state.customColors[color];\n      }) || this.state.border && this.state.customColors['border']);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this9 = this;\n      var _this$state3 = this.state,\n        extraClass = _this$state3.extraClass,\n        html = _this$state3.html,\n        ariaProps = _this$state3.ariaProps,\n        disable = _this$state3.disable,\n        uuid = _this$state3.uuid;\n      var content = this.getTooltipContent();\n      var isEmptyTip = this.isEmptyTip(content);\n      var style = this.props.disableInternalStyle ? '' : generateTooltipStyle(this.state.uuid, this.state.customColors, this.state.type, this.state.border, this.state.padding, this.state.customRadius);\n      var tooltipClass = '__react_component_tooltip' + \" \".concat(this.state.uuid) + (this.state.show && !disable && !isEmptyTip ? ' show' : '') + (this.state.border ? ' ' + this.state.borderClass : '') + \" place-\".concat(this.state.place) +\n      // top, bottom, left, right\n      \" type-\".concat(this.hasCustomColors() ? 'custom' : this.state.type) + (\n      // dark, success, warning, error, info, light, custom\n      this.props.delayUpdate ? ' allow_hover' : '') + (this.props.clickable ? ' allow_click' : '');\n      var Wrapper = this.props.wrapper;\n      if (ReactTooltip.supportedWrappers.indexOf(Wrapper) < 0) {\n        Wrapper = ReactTooltip.defaultProps.wrapper;\n      }\n      var wrapperClassName = [tooltipClass, extraClass].filter(Boolean).join(' ');\n      if (html) {\n        var htmlContent = \"\".concat(content).concat(style ? \"\\n<style aria-hidden=\\\"true\\\">\".concat(style, \"</style>\") : '');\n        return /*#__PURE__*/react.createElement(Wrapper, index_es_extends({\n          className: \"\".concat(wrapperClassName),\n          id: this.props.id || uuid,\n          ref: function ref(_ref) {\n            return _this9.tooltipRef = _ref;\n          }\n        }, ariaProps, {\n          \"data-id\": \"tooltip\",\n          dangerouslySetInnerHTML: {\n            __html: htmlContent\n          }\n        }));\n      } else {\n        return /*#__PURE__*/react.createElement(Wrapper, index_es_extends({\n          className: \"\".concat(wrapperClassName),\n          id: this.props.id || uuid\n        }, ariaProps, {\n          ref: function ref(_ref2) {\n            return _this9.tooltipRef = _ref2;\n          },\n          \"data-id\": \"tooltip\"\n        }), style && /*#__PURE__*/react.createElement(\"style\", {\n          dangerouslySetInnerHTML: {\n            __html: style\n          },\n          \"aria-hidden\": \"true\"\n        }), content);\n      }\n    }\n  }], [{\n    key: \"propTypes\",\n    get: function get() {\n      return {\n        uuid: (prop_types_default()).string,\n        children: (prop_types_default()).any,\n        place: (prop_types_default()).string,\n        type: (prop_types_default()).string,\n        effect: (prop_types_default()).string,\n        offset: (prop_types_default()).object,\n        padding: (prop_types_default()).string,\n        multiline: (prop_types_default()).bool,\n        border: (prop_types_default()).bool,\n        borderClass: (prop_types_default()).string,\n        textColor: (prop_types_default()).string,\n        backgroundColor: (prop_types_default()).string,\n        borderColor: (prop_types_default()).string,\n        arrowColor: (prop_types_default()).string,\n        arrowRadius: (prop_types_default()).string,\n        tooltipRadius: (prop_types_default()).string,\n        insecure: (prop_types_default()).bool,\n        \"class\": (prop_types_default()).string,\n        className: (prop_types_default()).string,\n        id: (prop_types_default()).string,\n        html: (prop_types_default()).bool,\n        delayHide: (prop_types_default()).number,\n        delayUpdate: (prop_types_default()).number,\n        delayShow: (prop_types_default()).number,\n        event: (prop_types_default()).string,\n        eventOff: (prop_types_default()).string,\n        isCapture: (prop_types_default()).bool,\n        globalEventOff: (prop_types_default()).string,\n        getContent: (prop_types_default()).any,\n        afterShow: (prop_types_default()).func,\n        afterHide: (prop_types_default()).func,\n        overridePosition: (prop_types_default()).func,\n        disable: (prop_types_default()).bool,\n        scrollHide: (prop_types_default()).bool,\n        resizeHide: (prop_types_default()).bool,\n        wrapper: (prop_types_default()).string,\n        bodyMode: (prop_types_default()).bool,\n        possibleCustomEvents: (prop_types_default()).string,\n        possibleCustomEventsOff: (prop_types_default()).string,\n        clickable: (prop_types_default()).bool,\n        disableInternalStyle: (prop_types_default()).bool\n      };\n    }\n  }, {\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var ariaProps = prevState.ariaProps;\n      var newAriaProps = parseAria(nextProps);\n      var isChanged = Object.keys(newAriaProps).some(function (props) {\n        return newAriaProps[props] !== ariaProps[props];\n      });\n      if (!isChanged) {\n        return null;\n      }\n      return _objectSpread2(_objectSpread2({}, prevState), {}, {\n        ariaProps: newAriaProps\n      });\n    }\n  }]);\n  return ReactTooltip;\n}(react.Component), index_es_defineProperty(_class2, \"defaultProps\", {\n  insecure: true,\n  resizeHide: true,\n  wrapper: 'div',\n  clickable: false\n}), index_es_defineProperty(_class2, \"supportedWrappers\", ['div', 'span']), index_es_defineProperty(_class2, \"displayName\", 'ReactTooltip'), _class2)) || _class) || _class) || _class) || _class) || _class) || _class) || _class;\n\n;// ./src/components/Indicator/Indicator.module.scss\n// extracted by mini-css-extract-plugin\nvar disIndicatorValue = \"Indicator-module--disIndicatorValue--DX0Ig\";\nvar indicatorBoxMain = \"Indicator-module--indicatorBoxMain--6T5Xt\";\nvar indicatorDesc = \"Indicator-module--indicatorDesc---ECTQ\";\nvar indicatorInfo = \"Indicator-module--indicatorInfo--p6lCu\";\nvar indicatorName = \"Indicator-module--indicatorName--lr3HM\";\nvar indicatorRow = \"Indicator-module--indicatorRow--dEaNg\";\nvar indicatorValue = \"Indicator-module--indicatorValue--PcUu3\";\nvar indicatorValueCol = \"Indicator-module--indicatorValueCol--cic1C\";\nvar indicatorValueRow = \"Indicator-module--indicatorValueRow--IchE8\";\nvar indicatorValueSubText = \"Indicator-module--indicatorValueSubText--w92wv\";\nvar info = \"Indicator-module--info--5wdv5\";\nvar infoTilde = \"Indicator-module--infoTilde--JSJWE\";\n// EXTERNAL MODULE: ./src/data/constants.tsx\nvar constants = __webpack_require__(4328);\n;// ./node_modules/uswds/dist/img/usa-icons/info.svg\n/* harmony default export */ var usa_icons_info = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTEyIDJDNi40OCAyIDIgNi40OCAyIDEyczQuNDggMTAgMTAgMTAgMTAtNC40OCAxMC0xMFMxNy41MiAyIDEyIDJ6bTEgMTVoLTJ2LTZoMnY2em0wLThoLTJWN2gydjJ6Ii8+PC9zdmc+\");\n;// ./src/components/Indicator/Indicator.tsx\n// @ts-ignore\n/**\n * This component will render an info icon in the indicator value\n *\n * @return {JSX.Element}\n */const IndicatorInfoIcon=_ref=>{let{isImpute,population}=_ref;const intl=(0,gatsby_plugin_intl.useIntl)();let showTilde=false;const getToolTipCopy=()=>{if(population===constants/* MISSING_DATA_STRING */.WiZ){return intl.formatMessage(explore/* LOW_INCOME_TOOLTIP */.L9.IMP_YES_POP_NULL);}else if(population!==constants/* MISSING_DATA_STRING */.WiZ&&isImpute){showTilde=true;return intl.formatMessage(explore/* LOW_INCOME_TOOLTIP */.L9.IMP_YES_POP_NOT_NULL);}else{return null;}};/**\n   * This library react-tooltip creates random DOM ID which will not allow for snapshot testing as\n   * the IDs change on each build. Due to time constraints, we simply removed the AreaDetails test.\n   * The AreaDetails component is made up of sub component and each sub component has tests so this\n   * is low risk.\n   *\n   * This is a temporary solution. Some longer terms solutions may be\n   * 1. Remove this library and get the USWDS tool tip to work\n   * 2. Re-factor the areaDetail.tests.tsx snapshot tests to do more DOM assertions rather than snapshots\n   * 3. Some combination of the two.\n   */return/*#__PURE__*/react.createElement(react.Fragment,null,/*#__PURE__*/react.createElement(ReactTooltip,{id:\"lowIncomeIcon\",multiline:true}),/*#__PURE__*/react.createElement(\"img\",{\"data-for\":\"lowIncomeIcon\",\"data-tip\":getToolTipCopy(),\"data-iscapture\":\"true\",className:info,src:usa_icons_info,alt:intl.formatMessage(explore/* SIDE_PANEL_VALUES */.M4.IMG_ALT_TEXT.INFO)}),showTilde&&/*#__PURE__*/react.createElement(\"span\",{className:infoTilde},` ~ `));};/**\n * This component will determine the sub-text of the indicator's value, some examples could be\n *   \"above 90th percentile\"\n *   \"below 20 percent\"\n *   \"data is not available\"\n *\n * @param {IIndicatorValueSubText} {}\n * @return {JSX.Element}\n */const IndicatorValueSubText=_ref2=>{let{type,value,isAboveThresh,threshold}=_ref2;if(value===null){return/*#__PURE__*/react.createElement(\"div\",null,explore/* SIDE_PANEL_VALUES */.M4.UNAVAILBLE_MSG);}else if(type==='percent'||type==='percentile'){return/*#__PURE__*/react.createElement(\"div\",null,isAboveThresh?explore/* SIDE_PANEL_VALUES */.M4.ABOVE:explore/* SIDE_PANEL_VALUES */.M4.BELOW,threshold?/*#__PURE__*/react.createElement(IndicatorValue,{type:type,displayStat:threshold}):/*#__PURE__*/react.createElement(IndicatorValue,{type:type,displayStat:90}),` `,type==='percent'?explore/* SIDE_PANEL_VALUES */.M4.PERCENT:explore/* SIDE_PANEL_VALUES */.M4.PERCENTILE);}else{return/*#__PURE__*/react.createElement(react.Fragment,null);}};/**\n * The react-i18n library allow to add ordinal suffix (st, nd, rd, th) to indicator values.\n * The number and the suffix is a single entity. We are looking to add styling to\n * just the suffix portion if the value is a percentile. This function will add\n * a superscript styling to just the suffix portion of percentile values.\n *\n * The i18n variable named i18nOrdinalSuffix, in the IndicatorValue function defines the\n * various prefixes. The Spanish version of the i18n variable works in a similar manner,\n * however has a difference. The superscripting is different for Spanish.\n * In Spanish, the suffix is a \".a\" and \".o\", where only the \"a\" and \"o\" are superscripted.\n * This function handles this case.\n *\n * Verbatim from translation team:\n * We suggest changing this to the Spanish ordinal number abbreviation, which is .o for masculine\n * and .a for feminine gendered words. ***Since this ranking applies to the communities of focus,\n * which use a feminine gender in Spanish, we recommend that the th ordinal abbreviation in English\n * be substituted with the feminine ordinal abbreviation in Spanish: .a  throughout the text.\n * E.g., 19th would be 19.a in Spanish and 65th would be 65.a\n *\n * @param {string} indicatorValueWithSuffix\n * @return {string}\n */const superscriptOrdinal=indicatorValueWithSuffix=>{// Spanish case:\nif(indicatorValueWithSuffix.indexOf('.')!==-1){const ordinalSuffix=indicatorValueWithSuffix.charAt(indicatorValueWithSuffix.length-1);const indicatorValue=indicatorValueWithSuffix.slice(0,-1);return/*#__PURE__*/react.createElement(react.Fragment,null,indicatorValue,/*#__PURE__*/react.createElement(\"sup\",{style:{top:'-0.2em'}},ordinalSuffix));}// English case:\nconst valueRegEx=/[0-9]{1,2}/;const suffixRegEx=/[a-z]{2}/;// ie, (st, nd, rd, th)\nconst indicatorValue=valueRegEx.exec(indicatorValueWithSuffix);const ordinalSuffix=suffixRegEx.exec(indicatorValueWithSuffix);return/*#__PURE__*/react.createElement(react.Fragment,null,indicatorValue,/*#__PURE__*/react.createElement(\"sup\",{style:{top:'-0.2em'}},ordinalSuffix));};/**\n * This component will return the indicators's value. The value depends on the\n * indicator type. Each type renders a different UI.\n *\n * @return {JSX.Element | null}\n */const IndicatorValue=_ref3=>{let{type,displayStat}=_ref3;const intl=(0,gatsby_plugin_intl.useIntl)();if(displayStat===null)return/*#__PURE__*/react.createElement(react.Fragment,null,constants/* MISSING_DATA_STRING */.WiZ);if(type==='percent'||type==='percentile'){// In this case we will show no value and an icon only\nif(type==='percent'){// If the type is percent, return the intl percent format\nreturn/*#__PURE__*/react.createElement(\"span\",null,intl.formatNumber(displayStat,{style:'unit',unit:'percent',unitDisplay:'short'}));}else{// If the type is percentile, create the intl ordinal and return it as a superscript\nconst i18nOrdinalSuffix=intl.formatMessage({id:'explore.map.page.side.panel.indicator.percentile.value.ordinal.suffix',// eslint-disable-next-line max-len\ndescription:`Navigate to the explore the tool page. Click on the map. The side panel will show categories. Open a category. This will define the indicator value's ordinal suffix. For example the st in 91st, the rd in 23rd, and the th in 26th, etc.`,defaultMessage:`\n        {indicatorValue, selectordinal, \n          one {#st} \n          two {#nd}\n          few {#rd} \n          other {#th}\n        }\n        `},{indicatorValue:displayStat});return superscriptOrdinal(i18nOrdinalSuffix);}}else{// when the type === boolean the display stat will be either 100 (true) or 0 (false)\nreturn displayStat===0?explore/* SIDE_PANEL_SPACERS */.zZ.NO:explore/* SIDE_PANEL_SPACERS */.zZ.YES;}};/**\n * This component will return the list element which will be the indicator row in the side panel\n *\n * @param {IIndicator} indicator\n * @return {JSX.Element}\n */const Indicator=_ref4=>{let{indicator,isImpute,population}=_ref4;/**\n   * The indicator value could be a number | boolean | null. In all cases we coerce to number\n   * before flooring.\n   *\n   * In the case where indicator.value is a boolean, the displayStat will be either 100 or 0, depending\n   * on if indicator.value is true or false respectively.\n   *\n   * Todo: The way the displayStat handles the boolean indicators should be refactored\n   */const displayStat=indicator.value!==null?Math.floor(Number(indicator.value)*100):null;// If the threshold exists, set it, otherwise set it to the default value\nconst threshold=indicator.threshold?indicator.threshold:constants/* DEFAULT_THRESHOLD_PERCENTILE */.QPF;// A boolean to represent if the indicator is above or below the threshold\nconst isAboveThresh=displayStat!==null&&displayStat>=threshold?true:false;// Show an info icon on the low icome indicator if:\nconst showLowIncomeInfoIcon=indicator.label==='Low income'&&isImpute||indicator.label==='Low income'&&population===constants/* MISSING_DATA_STRING */.WiZ&&!isImpute;return/*#__PURE__*/react.createElement(\"li\",{className:indicatorBoxMain,\"data-cy\":'indicatorBox',\"data-testid\":\"indicator-box\"},/*#__PURE__*/react.createElement(\"div\",{className:indicatorRow},/*#__PURE__*/react.createElement(\"div\",{className:indicatorName},indicator.label,/*#__PURE__*/react.createElement(\"div\",{className:indicatorDesc},indicator.description)),/*#__PURE__*/react.createElement(\"div\",{className:indicatorValueCol},/*#__PURE__*/react.createElement(\"div\",{className:indicatorValueRow},showLowIncomeInfoIcon&&/*#__PURE__*/react.createElement(\"div\",{className:indicatorInfo},/*#__PURE__*/react.createElement(IndicatorInfoIcon,{isImpute:isImpute,population:population})),/*#__PURE__*/react.createElement(\"div\",{className:indicator.isDisadvagtaged?disIndicatorValue:indicatorValue},/*#__PURE__*/react.createElement(IndicatorValue,{type:indicator.type,displayStat:displayStat}))),/*#__PURE__*/react.createElement(\"div\",{className:indicatorValueSubText},/*#__PURE__*/react.createElement(IndicatorValueSubText,{value:displayStat,isAboveThresh:isAboveThresh,threshold:threshold,type:indicator.type})))));};/* harmony default export */ var Indicator_Indicator = (Indicator);\n;// ./src/components/DonutCopy/DonutCopy.module.scss\n// extracted by mini-css-extract-plugin\nvar donutCopyContainer = \"DonutCopy-module--donutCopyContainer--rZc2n\";\nvar donutRow = \"DonutCopy-module--donutRow--uMGO+\";\nvar donutRowLabel = \"DonutCopy-module--donutRowLabel--H2Zix\";\nvar DonutCopy_module_invert = \"DonutCopy-module--invert--ItmCg\";\nvar noInvert = \"DonutCopy-module--noInvert--WfEDN\";\nvar subTextContainer = \"DonutCopy-module--subTextContainer--rOEhm\";\nvar valueSubTextContainer = \"DonutCopy-module--valueSubTextContainer---ntK0\";\n;// ./src/components/DonutCopy/DonutCopy.tsx\nconst DonutCopy=_ref=>{let{isAdjacent,povertyBelow200Percentile}=_ref;const intl=(0,gatsby_plugin_intl.useIntl)();const povBel200Percentile=povertyBelow200Percentile?parseFloat((povertyBelow200Percentile*100).toFixed()):null;const threshold=50;return/*#__PURE__*/react.createElement(\"div\",{className:donutCopyContainer},/*#__PURE__*/react.createElement(\"div\",{className:donutRow},/*#__PURE__*/react.createElement(\"div\",{className:donutRowLabel},intl.formatMessage(explore/* DONUT_COPY */.zf.COMP_SURR)),/*#__PURE__*/react.createElement(\"div\",{className:isAdjacent?DonutCopy_module_invert:''},isAdjacent?explore/* COMMUNITY */.GN.OF_FOCUS:explore/* COMMUNITY */.GN.NOT_OF_FOCUS)),/*#__PURE__*/react.createElement(\"div\",{className:donutRow},/*#__PURE__*/react.createElement(\"div\",{className:donutRowLabel},intl.formatMessage(explore/* DONUT_COPY */.zf.ADJ_LOW_INC)),/*#__PURE__*/react.createElement(\"div\",{className:valueSubTextContainer},/*#__PURE__*/react.createElement(\"div\",{className:isAdjacent&&povBel200Percentile&&povBel200Percentile>=threshold?DonutCopy_module_invert:noInvert},/*#__PURE__*/react.createElement(IndicatorValue,{type:'percentile',displayStat:povBel200Percentile})),/*#__PURE__*/react.createElement(\"div\",{className:subTextContainer},/*#__PURE__*/react.createElement(IndicatorValueSubText,{value:povBel200Percentile,isAboveThresh:povBel200Percentile&&povBel200Percentile>=threshold?true:false,threshold:threshold,type:'percentile'})))));};/* harmony default export */ var DonutCopy_DonutCopy = (DonutCopy);\n;// ./src/components/DonutCopy/index.ts\n/* harmony default export */ var components_DonutCopy = (DonutCopy_DonutCopy);\n;// ./src/components/Indicator/index.tsx\n/* harmony default export */ var components_Indicator = (Indicator_Indicator);\n;// ./src/components/PrioritizationCopy/PrioritizationCopy.tsx\n;/**\n * This component returns the prioritzation copy.\n *\n * The truth table that tracks all the states for this logic is captured in the shared doc\n * called \"Indicators for UI and BE Signals\". The Sheet is called \"Disadv Copy v4 p1\". This\n * spreadsheet is a giant truth table with all possible BE signal combinations and what the\n * approppriate copy should be.\n *\n * @param {number} totalCategoriesPrioritized\n * @param {number} totalBurdensPrioritized\n * @param {boolean} isAdjacencyThreshMet\n * @param {boolean} isAdjacencyLowIncome\n * @param {boolean} isIslandLowIncome\n * @param {number | null} tribalCountAK\n * @param {number | null} tribalCountUS\n * @param {number | null} percentTractTribal\n * @return {JSX}\n */const PrioritizationCopy=_ref=>{let{totalCategoriesPrioritized,totalBurdensPrioritized,isAdjacencyThreshMet,isAdjacencyLowIncome,isGrandfathered,isIslandLowIncome,tribalCountAK,tribalCountUS,percentTractTribal}=_ref;let prioCopyRendered=null;if(isGrandfathered){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.PRIO_GRANDFATHERED_LI;// if 1\n}else if(totalCategoriesPrioritized===0){// if 1-1\nif(isAdjacencyThreshMet&&isAdjacencyLowIncome){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.PRIO_SURR_LI;// if 1-2\n}else if(isIslandLowIncome){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.PRIO_ISLAND_LI;// if 1-3\n}else if(isAdjacencyThreshMet&&!isAdjacencyLowIncome){// if 1-2-1\nif(tribalCountAK===null&&tribalCountUS===null){// if 1-2-1-1\nif(percentTractTribal===null){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.NOT_PRIO_SURR_LI;// if 1-2-1-2\n}else if(percentTractTribal===0){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.PAR_PRIO_SURR_NO_LI;// if 1-2-1-3\n}else if(percentTractTribal>=1){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.PAR_PRIO_SURR_NO_LI;}// if 1-2-2\n}else if(tribalCountAK!==null&&tribalCountAK>=1){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.PAR_PRIO_SURR_NO_LI;}// if 1-3\n}else if(!(isAdjacencyThreshMet&&isAdjacencyLowIncome)&&tribalCountAK===null&&tribalCountUS===null&&percentTractTribal===null){// if 1-3-1\nif(totalBurdensPrioritized===0){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.NOT_PRIO;// if 1-3-2\n}else if(totalBurdensPrioritized===1){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.NOT_PRIO_1BUR;// if 1-3-3\n}else if(totalBurdensPrioritized>1){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.NOT_PRIO_NBUR;}// if 1-4\n}else if(!(isAdjacencyThreshMet&&isAdjacencyLowIncome)){// if 1-4-1\nif(tribalCountAK!==null&&tribalCountAK>=1&&tribalCountUS!==null&&tribalCountUS>=1){prioCopyRendered=explore/* getPrioAKUSCopy */.uG(tribalCountAK,tribalCountUS);// if 1-4-2\n}else if(tribalCountAK!==null&&tribalCountAK>=1&&tribalCountUS===null){prioCopyRendered=explore/* getPrioANVCopy */.vr(tribalCountAK);// if 1-4-3\n}else if(tribalCountUS!==null&&tribalCountUS>=1&&tribalCountAK===null){if(percentTractTribal===null){prioCopyRendered=explore/* getPrioFRTPointsCopy */.VO(`${tribalCountUS}`);}else if(percentTractTribal===0){prioCopyRendered=explore/* getPrioFRTCopy */.EW(`less than 1%`);}else if(percentTractTribal>=1){prioCopyRendered=explore/* getPrioFRTCopy */.EW(`${percentTractTribal}%`);}// 1-4-4\n}else if(tribalCountUS===null&&tribalCountAK===null){if(percentTractTribal===0){prioCopyRendered=explore/* getPrioFRTCopy */.EW(`less than 1%`);}else if(percentTractTribal!==null&&percentTractTribal>=1){prioCopyRendered=explore/* getPrioFRTCopy */.EW(`${percentTractTribal}%`);}}}// if 2\n}else if(totalCategoriesPrioritized>0){if(totalBurdensPrioritized===0){}else if(totalBurdensPrioritized===1){prioCopyRendered=explore/* getPrioNBurdenCopy */.M9(`1`);}else if(totalBurdensPrioritized>1){prioCopyRendered=explore/* getPrioNBurdenCopy */.M9(`more than 1`);}};return prioCopyRendered&&/*#__PURE__*/react.createElement(\"p\",null,prioCopyRendered);};/* harmony default export */ var PrioritizationCopy_PrioritizationCopy = (PrioritizationCopy);\n;// ./src/components/PrioritizationCopy/index.ts\n/* harmony default export */ var components_PrioritizationCopy = (PrioritizationCopy_PrioritizationCopy);\n;// ./src/components/PrioritizationCopy2/PrioritizationCopy2.tsx\n;/**\n * This component returns the prioritzation copy.\n *\n * The truth table for this logic is captured in the shared doc called \"Indicators for\n * UI and BE Signals\". The Sheet name is \"Disadv Copy p2 v5\". This sheet is a copy of the\n * the full table in Sheet \"Disadv Copy v4 p1\", which is the full truth table in logical order.\n * The p2 v4 sheet copies the full truth table and sorts by the column 'second paragraph' to\n * find the appropriate logical grouping for the second paragraph.\n *\n * @param {number} totalCategoriesPrioritized\n * @param {number} totalBurdensPrioritized\n * @param {boolean} isAdjacencyThreshMet\n * @param {boolean} isAdjacencyLowIncome\n * @param {number | null} tribalCountAK\n * @param {number | null} tribalCountUS\n * @param {number | null} percentTractTribal\n * @return {JSX}\n */const PrioritizationCopy2=_ref=>{let{totalCategoriesPrioritized,isAdjacencyThreshMet,isAdjacencyLowIncome,tribalCountAK,tribalCountUS,percentTractTribal}=_ref;let prioCopy2Rendered=null;// if 1\nif(totalCategoriesPrioritized===0&&isAdjacencyThreshMet&&isAdjacencyLowIncome||totalCategoriesPrioritized>=1){// if 1-1\nif(tribalCountAK===null&&tribalCountUS!==null&&tribalCountUS>=1&&percentTractTribal!==null&&percentTractTribal>=1){prioCopy2Rendered=explore/* getPrioPercAndNumPointsAlsoCopy */.Rh(`${percentTractTribal}%`,tribalCountUS);// if 1-2\n}else if(tribalCountAK===null&&tribalCountUS===null&&percentTractTribal!==null&&percentTractTribal>=1){prioCopy2Rendered=explore/* getPrioFRTCopy */.EW(`${percentTractTribal}%`,true);// if 1-3\n}else if(tribalCountAK===null&&tribalCountUS!==null&&tribalCountUS>=1&&percentTractTribal!==null&&percentTractTribal==0){prioCopy2Rendered=explore/* getPrioPercAndNumPointsAlsoCopy */.Rh(`less than 1%`,tribalCountUS);// if 1-4\n}else if(tribalCountAK===null&&tribalCountUS===null&&percentTractTribal!==null&&percentTractTribal==0){prioCopy2Rendered=explore/* getPrioFRTCopy */.EW(`less than 1%`,true);// if 1-5\n}else if(tribalCountAK!==null&&tribalCountAK>=1&&tribalCountUS===null&&percentTractTribal===null){prioCopy2Rendered=explore/* getPrioANVCopy */.vr(tribalCountAK,true);// if 1-6\n}else if(tribalCountAK!==null&&tribalCountAK>=1&&tribalCountUS!==null&&tribalCountUS>=1){prioCopy2Rendered=explore/* getPrioAKUSCopy */.uG(tribalCountAK,tribalCountUS,true);// if 1-7\n}else if(!isAdjacencyThreshMet&&isAdjacencyLowIncome&&tribalCountAK!==null&&tribalCountAK>=1&&percentTractTribal!==null&&percentTractTribal>=1){prioCopy2Rendered=explore/* getPrioFRTCopy */.EW(`${percentTractTribal}%`,true);// if 1-8\n}else if(totalCategoriesPrioritized>=1&&tribalCountAK==null&&tribalCountUS!==null&&tribalCountUS>=1&&percentTractTribal==null){prioCopy2Rendered=explore/* getPrioFRTPointsCopy */.VO(tribalCountUS,true);// if 1-9\n}else if(totalCategoriesPrioritized>=1&&tribalCountAK!==null&&tribalCountAK>=1&&percentTractTribal!==null&&percentTractTribal==0){prioCopy2Rendered=explore/* getPrioFRTCopy */.EW(`less than 1%`,true);// if 1-10\n}else if(totalCategoriesPrioritized>=1&&tribalCountAK!==null&&tribalCountAK>=1&&percentTractTribal!==null&&percentTractTribal>=1){prioCopy2Rendered=explore/* getPrioFRTCopy */.EW(`${percentTractTribal}%`,true);}// if 2\n}else if(totalCategoriesPrioritized===0&&isAdjacencyThreshMet&&!isAdjacencyLowIncome&&tribalCountAK===null&&tribalCountUS===null){// if 2-1\nif(percentTractTribal!==null&&percentTractTribal==0){prioCopy2Rendered=explore/* getPrioFRTCopy */.EW(`less than 1%`,false);// if 2-2\n}else if(percentTractTribal!==null&&percentTractTribal>=1){prioCopy2Rendered=explore/* getPrioFRTCopy */.EW(`${percentTractTribal}%`,false);}// if 3-1\n}else if(totalCategoriesPrioritized===0&&isAdjacencyThreshMet&&!isAdjacencyLowIncome&&tribalCountAK===null&&tribalCountUS!==null&&tribalCountUS>=1&&percentTractTribal!==null&&percentTractTribal==0){prioCopy2Rendered=explore/* getPrioFRTPointsCopy */.VO(tribalCountUS,false);// if 3-2\n}else if(totalCategoriesPrioritized===0&&isAdjacencyThreshMet&&!isAdjacencyLowIncome&&tribalCountAK===null&&tribalCountUS!==null&&tribalCountUS>=1&&percentTractTribal!==null&&percentTractTribal>=1){prioCopy2Rendered=explore/* getPrioFRTPointsCopy */.VO(tribalCountUS,false);// if 3-3\n}else if(totalCategoriesPrioritized===0&&!(isAdjacencyThreshMet&&isAdjacencyLowIncome)&&tribalCountAK===null&&tribalCountUS!==null&&tribalCountUS>=1&&percentTractTribal!==null&&percentTractTribal>=0){prioCopy2Rendered=explore/* getPrioFRTPointsCopy */.VO(tribalCountUS,true);// if 4\n}else if(totalCategoriesPrioritized===0&&isAdjacencyThreshMet&&!isAdjacencyLowIncome&&tribalCountAK!==null&&tribalCountAK>=1){prioCopy2Rendered=explore/* getPrioANVCopy */.vr(tribalCountAK,false);}return prioCopy2Rendered&&/*#__PURE__*/react.createElement(\"p\",null,prioCopy2Rendered);};/* harmony default export */ var PrioritizationCopy2_PrioritizationCopy2 = (PrioritizationCopy2);\n;// ./src/components/PrioritizationCopy2/index.ts\n/* harmony default export */ var components_PrioritizationCopy2 = (PrioritizationCopy2_PrioritizationCopy2);\n// EXTERNAL MODULE: ./node_modules/uswds/dist/img/usa-icons/expand_more.svg\nvar expand_more = __webpack_require__(17709);\n// EXTERNAL MODULE: ./node_modules/uswds/dist/img/usa-icons/expand_less.svg\nvar expand_less = __webpack_require__(95477);\n;// ./src/components/TractDemographics/TractDemographics.module.scss\n// extracted by mini-css-extract-plugin\nvar demographicHeading = \"TractDemographics-module--demographicHeading--ICYl+\";\nvar demographicItem = \"TractDemographics-module--demographicItem--16mYq\";\nvar demographicsContainer = \"TractDemographics-module--demographicsContainer--F8hLJ\";\nvar demographicsTitle = \"TractDemographics-module--demographicsTitle--FJtUA\";\nvar showHideIcon = \"TractDemographics-module--showHideIcon--YjMob\";\nvar showHideText = \"TractDemographics-module--showHideText--VRHvL\";\n;// ./src/components/TractDemographics/TractDemographics.tsx\n// @ts-ignore\n// @ts-ignore\n/**\n * This function will create the custom Accordion item. This will be used\n * for the race and age demographic UI elements\n *\n * @param {IJ40AccordionItem} props\n * @return {JSX.Element}\n */const J40AccordionItem=_ref=>{let{id,title,children}=_ref;const{0:isExpanded,1:setIsExpanded}=(0,react.useState)(false);return/*#__PURE__*/react.createElement(react.Fragment,null,/*#__PURE__*/react.createElement(\"h6\",{className:demographicHeading},title,/*#__PURE__*/react.createElement(\"span\",null,'(',/*#__PURE__*/react.createElement(\"a\",{className:showHideText?`usa-link ${showHideText}`:`usa-link`,id:`${id}-header`,\"aria-controls\":`${id}-panel`,\"aria-expanded\":isExpanded,onClick:()=>setIsExpanded(!isExpanded),tabIndex:0},isExpanded?explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.HIDE_DEMOGRAPHICS:explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.SHOW_DEMOGRAPHICS),isExpanded?/*#__PURE__*/react.createElement(\"img\",{className:showHideIcon,src:expand_less/* default */.A,alt:'collapse icon',onClick:()=>setIsExpanded(!isExpanded)}):/*#__PURE__*/react.createElement(\"img\",{className:showHideIcon,src:expand_more/* default */.A,alt:'expand icon',onClick:()=>setIsExpanded(!isExpanded)}),')')),/*#__PURE__*/react.createElement(\"section\",{id:`${id}-panel`,\"aria-labelledby\":`${id}-header`,hidden:!isExpanded},children));};/**\n * This function will create each line item on the list of demographics\n *\n * @param {[]} demographicData\n * @return {JSX.Element}\n */const demographicItemGen=demographicData=>{return demographicData.map((el,index)=>{return/*#__PURE__*/react.createElement(\"div\",{key:index,className:demographicItem},/*#__PURE__*/react.createElement(\"span\",null,el[0]),typeof el[1]==='number'?/*#__PURE__*/react.createElement(\"span\",null,`${el[1]}%`):/*#__PURE__*/react.createElement(\"span\",null,`${el[1]}`));});};/**\n * This function will return the numeric value of each demographic. Taking into\n * account cases when the data is undefined or is null\n *\n * @param {number} stat\n * @return {number}\n */const displayStat=stat=>{if(stat===undefined||stat===null){return'--';}else if(stat===0){return 0;}return Number(Math.floor(stat*100));};/**\n * This function will create the data structure for the demographics data\n *\n * @param {constants.J40Properties} properties\n * @return {IDemographicsData}\n */const getDemographicsData=properties=>({race:[[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_NON_HISPANIC_WHITE,displayStat(properties[constants/* DEMO_NON_HISPANIC_WHITE */.gaC])],[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_BLACK,displayStat(properties[constants/* DEMO_BLACK */.abY])],[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_AMERICAN_INDIAN,displayStat(properties[constants/* DEMO_AMERICAN_INDIAN */.Juu])],[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_ASIAN,displayStat(properties[constants/* DEMO_ASIAN */.lIl])],[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_HAWAIIAN,displayStat(properties[constants/* DEMO_HAWAIIAN */.fRK])],[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_OTHER_RACE,displayStat(properties[constants/* DEMO_OTHER_RACE */.xa4])],[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_TWO_OR_MORE_RACES,displayStat(properties[constants/* DEMO_TWO_OR_MORE_RACES */.CfZ])],[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_HISPANIC,displayStat(properties[constants/* DEMO_HISPANIC */.iqL])]],age:[[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_AGE_UNDER_10,displayStat(properties[constants/* DEMO_AGE_UNDER_10 */.XTj])],[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_AGE_MID,displayStat(properties[constants/* DEMO_AGE_MID */.ri])],[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_AGE_OVER_65,displayStat(properties[constants/* DEMO_AGE_OVER_64 */.UTf])]]});/**\n * This is the main component for this file. It accepts the selected feature\n * as a prop and return the demographics component.\n *\n * @param {ITractDemographicsProps} props\n * @return {JSX.Element}\n */const TractDemographics=_ref2=>{let{properties}=_ref2;const{race,age}=getDemographicsData(properties);return/*#__PURE__*/react.createElement(\"div\",{className:demographicsContainer},/*#__PURE__*/react.createElement(\"div\",{className:demographicsTitle},explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.TITLE),/*#__PURE__*/react.createElement(react.Fragment,null,/*#__PURE__*/react.createElement(J40AccordionItem,{id:'race',title:explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.RACE_TITLE},demographicItemGen(race)),/*#__PURE__*/react.createElement(J40AccordionItem,{id:'age',title:explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.AGE_TITLE},demographicItemGen(age))));};/* harmony default export */ var TractDemographics_TractDemographics = (TractDemographics);\n;// ./src/components/TractDemographics/index.ts\n/* harmony default export */ var components_TractDemographics = (TractDemographics_TractDemographics);\n;// ./src/components/TractInfo/TractInfo.module.scss\n// extracted by mini-css-extract-plugin\nvar tractInfoContainer = \"TractInfo-module--tractInfoContainer--uPhEW\";\nvar tractInfoLabel = \"TractInfo-module--tractInfoLabel--mY12q\";\n;// ./src/components/TractInfo/TractInfo.tsx\nconst TractInfo=_ref=>{let{blockGroup,countyName,stateName,population,sidePanelState}=_ref;const intl=(0,gatsby_plugin_intl.useIntl)();return/*#__PURE__*/react.createElement(\"ul\",{className:tractInfoContainer},/*#__PURE__*/react.createElement(\"li\",null,/*#__PURE__*/react.createElement(\"span\",{className:tractInfoLabel},intl.formatMessage(explore/* SIDE_PANEL_CBG_INFO */.Fr.CENSUS_INFO_TITLE))),/*#__PURE__*/react.createElement(\"li\",null,/*#__PURE__*/react.createElement(\"span\",null,intl.formatMessage(explore/* SIDE_PANEL_CBG_INFO */.Fr.CENSUS_BLOCK_GROUP)),/*#__PURE__*/react.createElement(\"span\",null,` ${blockGroup}`)),/*#__PURE__*/react.createElement(\"li\",null,/*#__PURE__*/react.createElement(\"span\",null,intl.formatMessage(explore/* SIDE_PANEL_CBG_INFO */.Fr.COUNTY)),/*#__PURE__*/react.createElement(\"span\",null,` ${countyName}`)),/*#__PURE__*/react.createElement(\"li\",null,/*#__PURE__*/react.createElement(\"span\",null,sidePanelState!==constants/* SIDE_PANEL_STATE_VALUES */.IfH.NATION?intl.formatMessage(explore/* SIDE_PANEL_CBG_INFO */.Fr.TERRITORY):intl.formatMessage(explore/* SIDE_PANEL_CBG_INFO */.Fr.STATE)),/*#__PURE__*/react.createElement(\"span\",null,` ${stateName}`)),/*#__PURE__*/react.createElement(\"li\",null,/*#__PURE__*/react.createElement(\"span\",null,intl.formatMessage(explore/* SIDE_PANEL_CBG_INFO */.Fr.POPULATION)),/*#__PURE__*/react.createElement(\"span\",null,` ${population.toLocaleString()}`)));};/* harmony default export */ var TractInfo_TractInfo = (TractInfo);\n;// ./src/components/TractInfo/index.ts\n/* harmony default export */ var components_TractInfo = (TractInfo_TractInfo);\n;// ./src/components/TractPrioritization/TractPrioritization.module.scss\n// extracted by mini-css-extract-plugin\nvar TractPrioritization_module_invert = \"TractPrioritization-module--invert--ouwFc\";\n;// ./src/components/TractPrioritization/TractPrioritization.tsx\n/**\n * This component will return the appropriate designation for the tract's prioritization\n *\n * @param {boolean} scoreNCommunities\n * @param {number | null} tribalCountAK\n * @param {number | null} tribalCountUS\n * @param {number | null} percentTractTribal\n * @return {JSX}\n */const TractPrioritization=_ref=>{let{scoreNCommunities,tribalCountAK,tribalCountUS,percentTractTribal}=_ref;if(scoreNCommunities===true){return/*#__PURE__*/react.createElement(\"h3\",{className:TractPrioritization_module_invert},explore/* COMMUNITY */.GN.OF_FOCUS);}else{if(percentTractTribal===null&&tribalCountAK===null&&tribalCountUS===null){return/*#__PURE__*/react.createElement(\"h3\",null,explore/* COMMUNITY */.GN.NOT_OF_FOCUS);}else{return/*#__PURE__*/react.createElement(\"h3\",{className:TractPrioritization_module_invert},explore/* COMMUNITY */.GN.PARTIAL);}}};/* harmony default export */ var TractPrioritization_TractPrioritization = (TractPrioritization);\n;// ./src/components/TractPrioritization/index.ts\n/* harmony default export */ var components_TractPrioritization = (TractPrioritization_TractPrioritization);\n;// ./src/components/AreaDetail/areaDetail.module.scss\n// extracted by mini-css-extract-plugin\nvar areaDetailContainer = \"areaDetail-module--areaDetailContainer--i8S4c\";\nvar buttonContainer = \"areaDetail-module--buttonContainer--1m7jg\";\nvar buttonText = \"areaDetail-module--buttonText--gKuX3\";\nvar categorization = \"areaDetail-module--categorization--IwyOG\";\nvar categoryHeader = \"areaDetail-module--categoryHeader--74Luo\";\nvar categorySpacer = \"areaDetail-module--categorySpacer--tt0d5\";\nvar censusLabel = \"areaDetail-module--censusLabel--JvpFV\";\nvar censusRow = \"areaDetail-module--censusRow--C9QPu\";\nvar censusText = \"areaDetail-module--censusText--DN7vv\";\nvar communityOfFocus = \"areaDetail-module--communityOfFocus--E2Y4z\";\nvar isInFocus = \"areaDetail-module--isInFocus--cMU9S\";\nvar prioCopy = \"areaDetail-module--prioCopy--8ozG5\";\nvar sendFeedbackBtn = \"areaDetail-module--sendFeedbackBtn--yzU7P\";\nvar sendFeedbackLink = \"areaDetail-module--sendFeedbackLink--w3Noj\";\nvar showCategoriesExceed = \"areaDetail-module--showCategoriesExceed--bumI1\";\nvar testSignals = \"areaDetail-module--testSignals--yYhqR\";\nvar versionInfo = \"areaDetail-module--versionInfo--HNH0O\";\n;// ./src/components/IslandCopy/IslandCopy.module.scss\n// extracted by mini-css-extract-plugin\nvar IslandCopy_module_invert = \"IslandCopy-module--invert--WabDT\";\nvar islandCopyContainer = \"IslandCopy-module--islandCopyContainer--rCBWo\";\nvar islandRow = \"IslandCopy-module--islandRow--U6fnR\";\nvar islandRowLabel = \"IslandCopy-module--islandRowLabel--0Wskg\";\nvar IslandCopy_module_noInvert = \"IslandCopy-module--noInvert--23WaS\";\nvar IslandCopy_module_subTextContainer = \"IslandCopy-module--subTextContainer--WAQ5I\";\nvar valueContainer = \"IslandCopy-module--valueContainer--XyvfT\";\nvar IslandCopy_module_valueSubTextContainer = \"IslandCopy-module--valueSubTextContainer--Y+DQ2\";\n;// ./src/components/IslandCopy/IslandCopy.tsx\nconst IslandCopy=_ref=>{let{povertyPercentile}=_ref;const intl=(0,gatsby_plugin_intl.useIntl)();const percentileWhole=povertyPercentile?parseFloat((povertyPercentile*100).toFixed()):null;const threshold=65;return/*#__PURE__*/react.createElement(\"div\",{className:islandCopyContainer},/*#__PURE__*/react.createElement(\"div\",{className:islandRow},/*#__PURE__*/react.createElement(\"div\",{className:islandRowLabel},intl.formatMessage(explore/* ISLAND_COPY */.cT.LOW_INC)),/*#__PURE__*/react.createElement(\"div\",{className:IslandCopy_module_valueSubTextContainer},/*#__PURE__*/react.createElement(\"div\",{className:`${valueContainer}\n            ${percentileWhole&&percentileWhole>=threshold?IslandCopy_module_invert:IslandCopy_module_noInvert}\n          `},/*#__PURE__*/react.createElement(IndicatorValue,{type:'percentile',displayStat:percentileWhole})),/*#__PURE__*/react.createElement(\"div\",{className:IslandCopy_module_subTextContainer},/*#__PURE__*/react.createElement(IndicatorValueSubText,{value:percentileWhole,isAboveThresh:percentileWhole&&percentileWhole>=threshold?true:false,threshold:threshold,type:'percentile'})))));};/* harmony default export */ var IslandCopy_IslandCopy = (IslandCopy);\n;// ./src/components/AreaDetail/AreaDetail.tsx\n/* eslint-disable quotes */// External Libs:\n// Components:\n// Styles and constants\n// @ts-ignore\n/**\n * There are a 4 different indicator types. Each indicator type will render in the UI differently.\n *\n * percentile - is the majority of indicators\n * percents - a few indicators fall into this type\n * boolean - 3 indicators are of boolean type\n *    - historic redlining\n *    - abandoned land mines\n *    - FUDS\n *\n *//**\n * This interface is used as define the various fields for each indicator in the side panel\n *  label: the indicator label or title\n *  description: the description of the indicator used in the side panel\n *  type: see indicatorType above\n *  value: the number from the geoJSON tile. If tile doesn't exist it get a null value. Could be boolean also\n *  isDisadvagtaged: the flag from the geoJSON tile\n *  threshold: a custom value of threshold for certain indicators\n *  *//**\n * This interface is used as define the various fields for category in the side panel\n * id: distict id\n * titleText: display text for the category title\n * indicators: an array of indicators\n * socioEcIndicators: an array of socioeconomic indicators\n * isDisadvagtaged: boolean to indicate if the category is disadvantaged\n * isExceed1MoreBurden: boolean to indicate if the category exceeds more than one burden\n * isExceedBothSocioBurdens: boolean to indicate if the category exceeds both socio-eco burdens\n *  *//**\n * This filter will remove indicators from appearing in the side panel by returning\n * the filter function (currying). There is 1 use case. It can accept any indicator name\n * as an input.\n *\n * 1. For Historic underinvestment if the value is null\n *\n * Recommendation is to use a separate filter for each indicator that needs filtering.\n *\n * @param {MessageDescriptor} label - allows to re-use this filter for any number of indicators\n * @return {indicatorInfo}\n */const indicatorFilter=label=>{const intl=useIntl();return indicator=>indicator.label!==intl.formatMessage(label)||indicator.label==intl.formatMessage(label)&&indicator.value!=null;};/**\n * Function to calculate the tribal area percentage value to display when a tract is selected\n *\n * @param {number} tribalPercentRaw\n * @return {string}\n */const getTribalPercentValue=tribalPercentRaw=>{if(tribalPercentRaw===undefined){return` none`;}if(tribalPercentRaw===0){// test tract = #9.03/42.9242/-98.8015\nreturn` less than 1%`;}if(tribalPercentRaw&&tribalPercentRaw>0){return` ${parseFloat((tribalPercentRaw*100).toFixed())} %`;}};/**\n * This is the main component. It will render the entire side panel and show the details\n * of the area/feature that is selected.\n *\n * @param {IAreaDetailProps} {}\n * @return {void}\n */const AreaDetail=_ref=>{let{properties}=_ref;const intl=(0,gatsby_plugin_intl.useIntl)();/**\n   * Set the indicators for a given category.\n   * @param {string} id the category ID\n   * @param {indicatorInfo[]} indicators the indicators to set for the category.\n   * @throws Error if the category ID does not exist\n   */const setCategoryIndicators=(id,indicators)=>{const cat=categories.find(category=>category.id===id);if(cat)cat.indicators=indicators;else throw new Error('Unknown side panel category ID '+id);};// console.log the properties of the census that is selected:\nconsole.log(\"BE signals for tract (last one is the tract currently selected): \",properties);// console.log around the donut, adjacency and tribal info:\nconsole.log(\"Income imputed? \",properties[constants/* IMPUTE_FLAG */.WDE]===\"0\"?\" NO\":\" YES\");console.log(\"Adjacency indicator? \",properties[constants/* ADJACENCY_EXCEEDS_THRESH */.axb]?\" YES\":\" NO\");console.log(\"% of tract tribal: \",getTribalPercentValue(properties[constants/* TRIBAL_AREAS_PERCENTAGE */.H3b]));console.log(\"Tribal count in AK: \",properties[constants/* TRIBAL_AREAS_COUNT_AK */.$RP]>=1?` ${properties[constants/* TRIBAL_AREAS_COUNT_AK */.$RP]}`:` null`);console.log(\"Tribal count in CONUS: \",properties[constants/* TRIBAL_AREAS_COUNT_CONUS */.drv]>=1?` ${properties[constants/* TRIBAL_AREAS_COUNT_CONUS */.drv]}`:` null`);// Fix constants.MISSING_DATA_STRING import\nconst blockGroup=properties[constants/* GEOID_PROPERTY */.TnO]?properties[constants/* GEOID_PROPERTY */.TnO]:constants/* MISSING_DATA_STRING */.WiZ;const population=properties[constants/* TOTAL_POPULATION */.tO9]?properties[constants/* TOTAL_POPULATION */.tO9]:constants/* MISSING_DATA_STRING */.WiZ;const countyName=properties[constants/* COUNTY_NAME */.LsS]?properties[constants/* COUNTY_NAME */.LsS]:constants/* MISSING_DATA_STRING */.WiZ;const stateName=properties[constants/* STATE_NAME */.sfg]?properties[constants/* STATE_NAME */.sfg]:constants/* MISSING_DATA_STRING */.WiZ;const sidePanelState=properties[constants/* SIDE_PANEL_STATE */.TPq];const percentTractTribal=properties[constants/* TRIBAL_AREAS_PERCENTAGE */.H3b]>=0?parseFloat((properties[constants/* TRIBAL_AREAS_PERCENTAGE */.H3b]*100).toFixed()):null;/**\n   * The workforce development category has some indicators who's source will vary depending on which\n   * territory is selected. This function allows us to change the source of workforce development indicators\n   * depending on which territory was selected\n   *\n   * @param {string} indicatorName\n   * @return {void}\n   */const getWorkForceIndicatorValue=indicatorName=>{if(sidePanelState===constants/* SIDE_PANEL_STATE_VALUES */.IfH.ISLAND_AREAS){if(indicatorName===\"lowMedInc\"){return properties.hasOwnProperty(constants/* ISLAND_AREAS_LOW_MEDIAN_INCOME_LOW_HS_EDU_PERCENTILE_FIELD */.e79)?properties[constants/* ISLAND_AREAS_LOW_MEDIAN_INCOME_LOW_HS_EDU_PERCENTILE_FIELD */.e79]:null;}if(indicatorName===\"unemploy\"){return properties.hasOwnProperty(constants/* ISLAND_AREAS_UNEMPLOYMENT_LOW_HS_EDU_PERCENTILE_FIELD */.urO)?properties[constants/* ISLAND_AREAS_UNEMPLOYMENT_LOW_HS_EDU_PERCENTILE_FIELD */.urO]:null;}if(indicatorName===\"poverty\"){return properties.hasOwnProperty(constants/* ISLAND_AREAS_POVERTY_LOW_HS_EDU_PERCENTILE_FIELD */.Isp)?properties[constants/* ISLAND_AREAS_POVERTY_LOW_HS_EDU_PERCENTILE_FIELD */.Isp]:null;}if(indicatorName===\"highSchool\"){return properties.hasOwnProperty(constants/* ISLAND_AREAS_HS_EDU_PERCENTAGE_FIELD */.s0s)?properties[constants/* ISLAND_AREAS_HS_EDU_PERCENTAGE_FIELD */.s0s]:null;}}if(indicatorName===\"lowMedInc\"){return properties.hasOwnProperty(constants/* LOW_MEDIAN_INCOME_PERCENTILE */.Ipt)?properties[constants/* LOW_MEDIAN_INCOME_PERCENTILE */.Ipt]:null;}if(indicatorName===\"unemploy\"){return properties.hasOwnProperty(constants/* UNEMPLOYMENT_PROPERTY_PERCENTILE */.Q_N)?properties[constants/* UNEMPLOYMENT_PROPERTY_PERCENTILE */.Q_N]:null;}if(indicatorName===\"poverty\"){return properties.hasOwnProperty(constants/* POVERTY_BELOW_100_PERCENTILE */.uZc)?properties[constants/* POVERTY_BELOW_100_PERCENTILE */.uZc]:null;}if(indicatorName===\"highSchool\"){return properties.hasOwnProperty(constants/* HIGH_SCHOOL_PROPERTY_PERCENTILE */.QTx)?properties[constants/* HIGH_SCHOOL_PROPERTY_PERCENTILE */.QTx]:null;}};/**\n   * The workforce development category has some indicators who's disadvantaged boolean\n   * will vary depending on which territory is selected. This function allows us to change\n   * the boolean of workforce development indicators depending on which territory was selected\n   *\n   * @param {string} indicatorName\n   * @return {void}\n   */const getWorkForceIndicatorIsDisadv=indicatorName=>{if(sidePanelState===constants/* SIDE_PANEL_STATE_VALUES */.IfH.ISLAND_AREAS){if(indicatorName===\"lowMedInc\"){return properties.hasOwnProperty(constants/* IS_EXCEEDS_THRESH_FOR_ISLAND_AREA_LOW_MEDIAN_INCOME */.WGo)?properties[constants/* IS_EXCEEDS_THRESH_FOR_ISLAND_AREA_LOW_MEDIAN_INCOME */.WGo]:null;}if(indicatorName===\"unemploy\"){return properties.hasOwnProperty(constants/* IS_EXCEEDS_THRESH_FOR_ISLAND_AREA_UNEMPLOYMENT */.md9)?properties[constants/* IS_EXCEEDS_THRESH_FOR_ISLAND_AREA_UNEMPLOYMENT */.md9]:null;}if(indicatorName===\"poverty\"){return properties.hasOwnProperty(constants/* IS_EXCEEDS_THRESH_FOR_ISLAND_AREA_BELOW_100_POVERTY */.mHs)?properties[constants/* IS_EXCEEDS_THRESH_FOR_ISLAND_AREA_BELOW_100_POVERTY */.mHs]:null;}if(indicatorName===\"highSchool\"){return properties.hasOwnProperty(constants/* ISLAND_AREA_LOW_HS_EDU */.A7Z)?properties[constants/* ISLAND_AREA_LOW_HS_EDU */.A7Z]:null;}}if(indicatorName===\"lowMedInc\"){return properties.hasOwnProperty(constants/* IS_EXCEEDS_THRESH_FOR_LOW_MEDIAN_INCOME */.SCG)?properties[constants/* IS_EXCEEDS_THRESH_FOR_LOW_MEDIAN_INCOME */.SCG]:null;}if(indicatorName===\"unemploy\"){return properties.hasOwnProperty(constants/* IS_EXCEEDS_THRESH_FOR_UNEMPLOYMENT */.Kvk)?properties[constants/* IS_EXCEEDS_THRESH_FOR_UNEMPLOYMENT */.Kvk]:null;}if(indicatorName===\"poverty\"){return properties.hasOwnProperty(constants/* IS_EXCEEDS_THRESH_FOR_BELOW_100_POVERTY */._FA)?properties[constants/* IS_EXCEEDS_THRESH_FOR_BELOW_100_POVERTY */._FA]:null;}if(indicatorName===\"highSchool\"){return properties.hasOwnProperty(constants/* IS_LOW_HS_EDUCATION_LOW_HIGHER_ED_PRIORITIZED */.mx8)?properties[constants/* IS_LOW_HS_EDUCATION_LOW_HIGHER_ED_PRIORITIZED */.mx8]:null;}};/**\n   * Define each indicator in the side panel with constants from copy file (for intl)\n   *\n   * Indicators are grouped by category\n   */// Climate category\nconst expAgLoss={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.EXP_AG_LOSS),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.EXP_AG_LOSS),type:\"percentile\",value:properties.hasOwnProperty(constants/* EXP_AGRICULTURE_LOSS_PERCENTILE */.eH1)?properties[constants/* EXP_AGRICULTURE_LOSS_PERCENTILE */.eH1]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_EXP_AGR_LOSS */.DaG]?properties[constants/* IS_EXCEEDS_THRESH_FOR_EXP_AGR_LOSS */.DaG]:null};const expBldLoss={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.EXP_BLD_LOSS),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.EXP_BLD_LOSS),type:\"percentile\",value:properties.hasOwnProperty(constants/* EXP_BUILDING_LOSS_PERCENTILE */.Ht4)?properties[constants/* EXP_BUILDING_LOSS_PERCENTILE */.Ht4]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_EXP_BLD_LOSS */.fuF]?properties[constants/* IS_EXCEEDS_THRESH_FOR_EXP_BLD_LOSS */.fuF]:null};const expPopLoss={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.EXP_POP_LOSS),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.EXP_POP_LOSS),type:\"percentile\",value:properties.hasOwnProperty(constants/* EXP_POPULATION_LOSS_PERCENTILE */.Cvf)?properties[constants/* EXP_POPULATION_LOSS_PERCENTILE */.Cvf]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_EXP_POP_LOSS */.O4u]?properties[constants/* IS_EXCEEDS_THRESH_FOR_EXP_POP_LOSS */.O4u]:null};const flooding={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.FLOODING),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.FLOODING),type:\"percentile\",value:properties.hasOwnProperty(constants/* FLOODING_PERCENTILE */.Tp5)?properties[constants/* FLOODING_PERCENTILE */.Tp5]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FLOODING */.HY7]?properties[constants/* IS_EXCEEDS_THRESH_FLOODING */.HY7]:null};const wildfire={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.WILDFIRE),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.WILDFIRE),type:\"percentile\",value:properties.hasOwnProperty(constants/* WILDFIRE_PERCENTILE */.n9g)?properties[constants/* WILDFIRE_PERCENTILE */.n9g]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_WILDFIRE */.TUJ]?properties[constants/* IS_EXCEEDS_THRESH_WILDFIRE */.TUJ]:null};const lowInc={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.LOW_INCOME),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.LOW_INCOME),type:\"percentile\",value:properties.hasOwnProperty(constants/* POVERTY_BELOW_200_PERCENTILE */.FSv)?properties[constants/* POVERTY_BELOW_200_PERCENTILE */.FSv]:null,isDisadvagtaged:properties[constants/* IS_FEDERAL_POVERTY_LEVEL_200 */.pyQ]?properties[constants/* IS_FEDERAL_POVERTY_LEVEL_200 */.pyQ]:null,threshold:65};// const higherEd: indicatorInfo = {\n//   label: intl.formatMessage(EXPLORE_COPY.SIDE_PANEL_INDICATORS.HIGH_ED),\n//   description: intl.formatMessage(EXPLORE_COPY.SIDE_PANEL_INDICATOR_DESCRIPTION.HIGH_ED),\n//   type: 'percent',\n//   value: properties.hasOwnProperty(constants.NON_HIGHER_ED_PERCENTILE) ?\n//     properties[constants.NON_HIGHER_ED_PERCENTILE] : null,\n//   isDisadvagtaged: properties[constants.IS_HIGHER_ED_PERCENTILE] ?\n//     properties[constants.IS_HIGHER_ED_PERCENTILE] : null,\n//   threshold: 80,\n// };\n// Energy category\nconst energyCost={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.ENERGY_COST),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.ENERGY_COST),type:\"percentile\",value:properties.hasOwnProperty(constants/* ENERGY_PERCENTILE */.$N3)?properties[constants/* ENERGY_PERCENTILE */.$N3]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_ENERGY_BURDEN */._Ad]?properties[constants/* IS_EXCEEDS_THRESH_FOR_ENERGY_BURDEN */._Ad]:null};const pm25={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.PM_2_5),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.PM_2_5),type:\"percentile\",value:properties.hasOwnProperty(constants/* PM25_PERCENTILE */.BNf)?properties[constants/* PM25_PERCENTILE */.BNf]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_PM25 */.NGc]?properties[constants/* IS_EXCEEDS_THRESH_FOR_PM25 */.NGc]:null};// Health category\nconst asthma={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.ASTHMA),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.ASTHMA),type:\"percentile\",value:properties.hasOwnProperty(constants/* ASTHMA_PERCENTILE */.dbq)?properties[constants/* ASTHMA_PERCENTILE */.dbq]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_ASTHMA */.Ptd]?properties[constants/* IS_EXCEEDS_THRESH_FOR_ASTHMA */.Ptd]:null};const diabetes={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.DIABETES),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.DIABETES),type:\"percentile\",value:properties.hasOwnProperty(constants/* DIABETES_PERCENTILE */.aJS)?properties[constants/* DIABETES_PERCENTILE */.aJS]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_DIABETES */.Ot]?properties[constants/* IS_EXCEEDS_THRESH_FOR_DIABETES */.Ot]:null};const heartDisease={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.HEART_DISEASE),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.HEART_DISEASE),type:\"percentile\",value:properties.hasOwnProperty(constants/* HEART_PERCENTILE */.Pgu)?properties[constants/* HEART_PERCENTILE */.Pgu]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_HEART_DISEASE */.i_2]?properties[constants/* IS_EXCEEDS_THRESH_FOR_HEART_DISEASE */.i_2]:null};const lifeExpect={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.LIFE_EXPECT),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.LOW_LIFE_EXPECT),type:\"percentile\",value:properties.hasOwnProperty(constants/* LIFE_PERCENTILE */.Zv0)?properties[constants/* LIFE_PERCENTILE */.Zv0]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_LOW_LIFE_EXP */.aD6]?properties[constants/* IS_EXCEEDS_THRESH_FOR_LOW_LIFE_EXP */.aD6]:null};// Housing category\nconst historicUnderinvest={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.HIST_UNDERINVEST),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.HIST_UNDERINVEST),type:\"boolean\",value:properties.hasOwnProperty(constants/* HISTORIC_UNDERINVESTMENT_EXCEED_THRESH */.yIR)?properties[constants/* HISTORIC_UNDERINVESTMENT_EXCEED_THRESH */.yIR]===constants/* HISTORIC_UNDERINVESTMENT_RAW_YES */.pas?true:false:null,isDisadvagtaged:properties.hasOwnProperty(constants/* HISTORIC_UNDERINVESTMENT_EXCEED_THRESH */.yIR)&&properties[constants/* HISTORIC_UNDERINVESTMENT_EXCEED_THRESH */.yIR]===constants/* HISTORIC_UNDERINVESTMENT_RAW_YES */.pas?true:false};const houseCost={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.HOUSE_COST),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.HOUSE_COST),type:\"percentile\",value:properties.hasOwnProperty(constants/* HOUSING_BURDEN_PROPERTY_PERCENTILE */.XCy)?properties[constants/* HOUSING_BURDEN_PROPERTY_PERCENTILE */.XCy]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_HOUSE_BURDEN */.arr]?properties[constants/* IS_EXCEEDS_THRESH_FOR_HOUSE_BURDEN */.arr]:null};const lackGreenSpace={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.LACK_GREEN_SPACE),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.LACK_GREEN_SPACE),type:\"percentile\",value:properties.hasOwnProperty(constants/* IMPERVIOUS_PERCENTILE */._lZ)?properties[constants/* IMPERVIOUS_PERCENTILE */._lZ]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_IMPERVIOUS */.SJ6]?properties[constants/* IS_EXCEEDS_THRESH_IMPERVIOUS */.SJ6]:null};const lackPlumbing={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.LACK_PLUMBING),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.LACK_PLUMBING),type:\"percentile\",value:properties.hasOwnProperty(constants/* KITCHEN_PLUMB_PERCENTILE */.M_z)?properties[constants/* KITCHEN_PLUMB_PERCENTILE */.M_z]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_KITCHEN_PLUMB */.GVB]?properties[constants/* IS_EXCEEDS_THRESH_KITCHEN_PLUMB */.GVB]:null};const leadPaint={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.LEAD_PAINT),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.LEAD_PAINT),type:\"percentile\",value:properties.hasOwnProperty(constants/* LEAD_PAINT_PERCENTILE */.ShH)?properties[constants/* LEAD_PAINT_PERCENTILE */.ShH]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_LEAD_PAINT_AND_MEDIAN_HOME_VAL */.fuy]?properties[constants/* IS_EXCEEDS_THRESH_FOR_LEAD_PAINT_AND_MEDIAN_HOME_VAL */.fuy]:null};// Pollution categeory\nconst abandonMines={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.ABANDON_MINES),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.ABANDON_MINES),type:\"boolean\",value:properties.hasOwnProperty(constants/* ABANDON_LAND_MINES_EXCEEDS_THRESH */.oa$)?properties[constants/* ABANDON_LAND_MINES_EXCEEDS_THRESH */.oa$]:null,isDisadvagtaged:properties.hasOwnProperty(constants/* ABANDON_LAND_MINES_EXCEEDS_THRESH */.oa$)?properties[constants/* ABANDON_LAND_MINES_EXCEEDS_THRESH */.oa$]:null};const formerDefSites={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.FORMER_DEF_SITES),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.FORMER_DEF_SITES),type:\"boolean\",// double equality is used in this instance as it seems that FUDS_RAW could be \"1\" or 1 from the BE\nvalue:properties.hasOwnProperty(constants/* FORMER_DEF_SITES_RAW_VALUE */.MdH)?properties[constants/* FORMER_DEF_SITES_RAW_VALUE */.MdH]==constants/* FUDS_RAW_YES */.wzj?true:false:null,isDisadvagtaged:properties.hasOwnProperty(constants/* FORMER_DEF_SITES_EXCEEDS_THRESH */.aU2)?properties[constants/* FORMER_DEF_SITES_EXCEEDS_THRESH */.aU2]:null};const proxHaz={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.PROX_HAZ),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.PROX_HAZ),type:\"percentile\",value:properties.hasOwnProperty(constants/* PROXIMITY_TSDF_SITES_PERCENTILE */.xJH)?properties[constants/* PROXIMITY_TSDF_SITES_PERCENTILE */.xJH]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_HAZARD_WASTE */.i3y]?properties[constants/* IS_EXCEEDS_THRESH_FOR_HAZARD_WASTE */.i3y]:null};const proxRMP={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.PROX_RMP),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.PROX_RMP),type:\"percentile\",value:properties.hasOwnProperty(constants/* PROXIMITY_RMP_SITES_PERCENTILE */.RAw)?properties[constants/* PROXIMITY_RMP_SITES_PERCENTILE */.RAw]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_RMP */.qh7]?properties[constants/* IS_EXCEEDS_THRESH_FOR_RMP */.qh7]:null};const proxNPL={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.PROX_NPL),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.PROX_NPL),type:\"percentile\",value:properties.hasOwnProperty(constants/* PROXIMITY_NPL_SITES_PERCENTILE */.eLl)?properties[constants/* PROXIMITY_NPL_SITES_PERCENTILE */.eLl]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_SUPERFUND */.pmG]?properties[constants/* IS_EXCEEDS_THRESH_FOR_SUPERFUND */.pmG]:null};// Transpotation category\nconst dieselPartMatter={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.DIESEL_PARTICULATE_MATTER),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.DIESEL_PARTICULATE_MATTER),type:\"percentile\",value:properties.hasOwnProperty(constants/* DIESEL_MATTER_PERCENTILE */.PHG)?properties[constants/* DIESEL_MATTER_PERCENTILE */.PHG]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_DIESEL_PM */.vDd]?properties[constants/* IS_EXCEEDS_THRESH_FOR_DIESEL_PM */.vDd]:null};const barrierTransport={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.BARRIER_TRANS),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.BARRIER_TRANS),type:\"percentile\",value:properties.hasOwnProperty(constants/* TRAVEL_DISADV_PERCENTILE */.pRw)?properties[constants/* TRAVEL_DISADV_PERCENTILE */.pRw]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_TRAVEL_DISADV */.TdA]?properties[constants/* IS_EXCEEDS_THRESH_TRAVEL_DISADV */.TdA]:null};const trafficVolume={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.TRAFFIC_VOLUME),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.TRAFFIC_VOLUME),type:\"percentile\",value:properties.hasOwnProperty(constants/* TRAFFIC_PERCENTILE */.SIY)?properties[constants/* TRAFFIC_PERCENTILE */.SIY]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_TRAFFIC_PROX */.eMp]?properties[constants/* IS_EXCEEDS_THRESH_FOR_TRAFFIC_PROX */.eMp]:null};// Water category\nconst leakyTanks={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.LEAKY_TANKS),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.LEAKY_TANKS),type:\"percentile\",value:properties.hasOwnProperty(constants/* LEAKY_UNDER_PERCENTILE */.qxA)?properties[constants/* LEAKY_UNDER_PERCENTILE */.qxA]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_LEAKY_UNDER */.YgP]?properties[constants/* IS_EXCEEDS_THRESH_LEAKY_UNDER */.YgP]:null};const wasteWater={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.WASTE_WATER),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.WASTE_WATER),type:\"percentile\",value:properties.hasOwnProperty(constants/* WASTEWATER_PERCENTILE */.Uo7)?properties[constants/* WASTEWATER_PERCENTILE */.Uo7]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_WASTEWATER */.Gle]?properties[constants/* IS_EXCEEDS_THRESH_FOR_WASTEWATER */.Gle]:null};// Workforce dev category\nconst lingIso={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.LING_ISO),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.LING_ISO),type:\"percentile\",value:properties.hasOwnProperty(constants/* LINGUISTIC_ISOLATION_PROPERTY_PERCENTILE */.b1X)?properties[constants/* LINGUISTIC_ISOLATION_PROPERTY_PERCENTILE */.b1X]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_LINGUISITIC_ISO */.pyI]?properties[constants/* IS_EXCEEDS_THRESH_FOR_LINGUISITIC_ISO */.pyI]:null};const lowMedInc={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.LOW_MED_INC),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.LOW_MED_INCOME),type:\"percentile\",value:getWorkForceIndicatorValue(\"lowMedInc\"),isDisadvagtaged:getWorkForceIndicatorIsDisadv(\"lowMedInc\")};const unemploy={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.UNEMPLOY),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.UNEMPLOY),type:\"percentile\",value:getWorkForceIndicatorValue(\"unemploy\"),isDisadvagtaged:getWorkForceIndicatorIsDisadv(\"unemploy\")};const poverty={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.POVERTY),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.POVERTY),type:\"percentile\",value:getWorkForceIndicatorValue(\"poverty\"),isDisadvagtaged:getWorkForceIndicatorIsDisadv(\"poverty\")};const highSchool={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.HIGH_SCL),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.HIGH_SKL),type:\"percent\",value:getWorkForceIndicatorValue(\"highSchool\"),isDisadvagtaged:getWorkForceIndicatorIsDisadv(\"highSchool\"),threshold:10};/**\n   * Aggregate indicators based on categories\n   *\n   * The indicators property must be an array with last two elements being the\n   * socioeconomic burdens.\n   */let categories=[{id:\"climate-change\",titleText:intl.formatMessage(explore/* SIDE_PANEL_CATEGORY */.wP.CLIMATE),indicators:[expAgLoss,expBldLoss,expPopLoss,flooding,wildfire],socioEcIndicators:[lowInc],isDisadvagtaged:properties[constants/* IS_CLIMATE_FACTOR_DISADVANTAGED */.z1Q]?properties[constants/* IS_CLIMATE_FACTOR_DISADVANTAGED */.z1Q]:null,isExceed1MoreBurden:properties[constants/* IS_CLIMATE_EXCEED_ONE_OR_MORE_INDICATORS */.gDg]?properties[constants/* IS_CLIMATE_EXCEED_ONE_OR_MORE_INDICATORS */.gDg]:null,isExceedBothSocioBurdens:properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]?properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]:null},{id:\"clean-energy\",titleText:intl.formatMessage(explore/* SIDE_PANEL_CATEGORY */.wP.CLEAN_ENERGY),indicators:[energyCost,pm25],socioEcIndicators:[lowInc],isDisadvagtaged:properties[constants/* IS_ENERGY_FACTOR_DISADVANTAGED */.QRn]?properties[constants/* IS_ENERGY_FACTOR_DISADVANTAGED */.QRn]:null,isExceed1MoreBurden:properties[constants/* IS_ENERGY_EXCEED_ONE_OR_MORE_INDICATORS */.F1p]?properties[constants/* IS_ENERGY_EXCEED_ONE_OR_MORE_INDICATORS */.F1p]:null,isExceedBothSocioBurdens:properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]?properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]:null},{id:\"health-burdens\",titleText:intl.formatMessage(explore/* SIDE_PANEL_CATEGORY */.wP.HEALTH_BURDEN),indicators:[asthma,diabetes,heartDisease,lifeExpect],socioEcIndicators:[lowInc],isDisadvagtaged:properties[constants/* IS_HEALTH_FACTOR_DISADVANTAGED */.sW6]?properties[constants/* IS_HEALTH_FACTOR_DISADVANTAGED */.sW6]:null,isExceed1MoreBurden:properties[constants/* IS_HEALTH_EXCEED_ONE_OR_MORE_INDICATORS */.fbb]?properties[constants/* IS_HEALTH_EXCEED_ONE_OR_MORE_INDICATORS */.fbb]:null,isExceedBothSocioBurdens:properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]?properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]:null},{id:\"sustain-house\",titleText:intl.formatMessage(explore/* SIDE_PANEL_CATEGORY */.wP.SUSTAIN_HOUSE),indicators:[historicUnderinvest,houseCost,lackGreenSpace,lackPlumbing,leadPaint],socioEcIndicators:[lowInc],isDisadvagtaged:properties[constants/* IS_HOUSING_FACTOR_DISADVANTAGED */.jtt]?properties[constants/* IS_HOUSING_FACTOR_DISADVANTAGED */.jtt]:null,isExceed1MoreBurden:properties[constants/* IS_HOUSING_EXCEED_ONE_OR_MORE_INDICATORS */.IXr]?properties[constants/* IS_HOUSING_EXCEED_ONE_OR_MORE_INDICATORS */.IXr]:null,isExceedBothSocioBurdens:properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]?properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]:null},{id:\"leg-pollute\",titleText:intl.formatMessage(explore/* SIDE_PANEL_CATEGORY */.wP.LEG_POLLUTE),indicators:[abandonMines,formerDefSites,proxHaz,proxRMP,proxNPL],socioEcIndicators:[lowInc],isDisadvagtaged:properties[constants/* IS_POLLUTION_FACTOR_DISADVANTAGED */.uxy]?properties[constants/* IS_POLLUTION_FACTOR_DISADVANTAGED */.uxy]:null,isExceed1MoreBurden:properties[constants/* IS_POLLUTION_EXCEED_ONE_OR_MORE_INDICATORS */.jD1]?properties[constants/* IS_POLLUTION_EXCEED_ONE_OR_MORE_INDICATORS */.jD1]:null,isExceedBothSocioBurdens:properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]?properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]:null},{id:\"clean-transport\",titleText:intl.formatMessage(explore/* SIDE_PANEL_CATEGORY */.wP.CLEAN_TRANSPORT),indicators:[dieselPartMatter,barrierTransport,trafficVolume],socioEcIndicators:[lowInc],isDisadvagtaged:properties[constants/* IS_TRANSPORT_FACTOR_DISADVANTAGED */.lJt]?properties[constants/* IS_TRANSPORT_FACTOR_DISADVANTAGED */.lJt]:null,isExceed1MoreBurden:properties[constants/* IS_TRANSPORT_EXCEED_ONE_OR_MORE_INDICATORS */.QqC]?properties[constants/* IS_TRANSPORT_EXCEED_ONE_OR_MORE_INDICATORS */.QqC]:null,isExceedBothSocioBurdens:properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]?properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]:null},{id:\"clean-water\",titleText:intl.formatMessage(explore/* SIDE_PANEL_CATEGORY */.wP.CLEAN_WATER),indicators:[leakyTanks,wasteWater],socioEcIndicators:[lowInc],isDisadvagtaged:properties[constants/* IS_WATER_FACTOR_DISADVANTAGED */.fPC]?properties[constants/* IS_WATER_FACTOR_DISADVANTAGED */.fPC]:null,isExceed1MoreBurden:properties[constants/* IS_WATER_EXCEED_ONE_OR_MORE_INDICATORS */.KUV]?properties[constants/* IS_WATER_EXCEED_ONE_OR_MORE_INDICATORS */.KUV]:null,isExceedBothSocioBurdens:properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]?properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]:null},{id:\"work-dev\",titleText:intl.formatMessage(explore/* SIDE_PANEL_CATEGORY */.wP.WORK_DEV),indicators:[lingIso,lowMedInc,poverty,unemploy],socioEcIndicators:[highSchool],isDisadvagtaged:properties[constants/* IS_WORKFORCE_FACTOR_DISADVANTAGED */.EPb]?properties[constants/* IS_WORKFORCE_FACTOR_DISADVANTAGED */.EPb]:null,isExceed1MoreBurden:properties[constants/* IS_WORKFORCE_EXCEED_ONE_OR_MORE_INDICATORS */.R35]?properties[constants/* IS_WORKFORCE_EXCEED_ONE_OR_MORE_INDICATORS */.R35]:null,isExceedBothSocioBurdens:properties[constants/* IS_WORKFORCE_EXCEED_BOTH_SOCIO_INDICATORS */.mVw]?properties[constants/* IS_WORKFORCE_EXCEED_BOTH_SOCIO_INDICATORS */.mVw]:null}];/**\n   * Modify the category array depending on the sidePanelState field. This field comes from the backend\n   * and is called UI_EXP.\n   *\n   * This sidePanelState has 3 values; namely, Nation, Puerto Rico and Island Areas.\n   */if(sidePanelState===constants/* SIDE_PANEL_STATE_VALUES */.IfH.PUERTO_RICO){// Re-define which burdens show up for each category:\nsetCategoryIndicators('climate-change',[flooding]);setCategoryIndicators('clean-energy',[energyCost]);setCategoryIndicators('sustain-house',[historicUnderinvest,houseCost,lackPlumbing,leadPaint]);setCategoryIndicators('leg-pollute',[proxHaz,proxRMP,proxNPL]);setCategoryIndicators('clean-transport',[dieselPartMatter,trafficVolume]);setCategoryIndicators('work-dev',[lowMedInc,poverty,unemploy]);}if(sidePanelState===constants/* SIDE_PANEL_STATE_VALUES */.IfH.ISLAND_AREAS){// For Island Areas - only show workforce dev category\ncategories=categories.filter(category=>category.id===\"work-dev\");// For Island Areas - remove the linguistic Isolation\ncategories[0].indicators=[lowMedInc,unemploy,poverty];}const isTerritory=constants/* TILES_ISLAND_AREA_FIPS_CODES */.STP.some(code=>{return properties[constants/* GEOID_PROPERTY */.TnO].startsWith(code);});const isGrandfathered=properties[constants/* IS_GRANDFATHERED */.fgy];// Show Donut information !isGrandfathered\nconst showDonutCopy=!isGrandfathered&&properties[constants/* ADJACENCY_EXCEEDS_THRESH */.axb]&&properties[constants/* TOTAL_NUMBER_OF_DISADVANTAGE_INDICATORS */.SfK]===0;const showIslandCopy=isTerritory&&!showDonutCopy;// For territories we use the poverty percentile from the census decennial data\nconst poveryPercentile=isTerritory?properties[constants/* CENSUS_DECENNIAL_POVERTY_LESS_THAN_200_FPL_PERCENTILE */.g1v]:properties[constants/* POVERTY_BELOW_200_PERCENTILE */.FSv]>0?properties[constants/* POVERTY_BELOW_200_PERCENTILE */.FSv]:null;/**\n   * Create the AccoridionItems by mapping over the categories array. In this array we define the\n   * various indicators for a specific category. This is an array which then maps over the\n   * <Indicator /> component to render the actual Indicator\n   */const categoryItems=categories.map(category=>({id:category.id,/*\n    As of trussworks 3.0.0, there were some breaking changes. This new prop of headingLevel\n    is required, however, the title prop is already defining the category styling, so this\n    is placed here to satisfy the requirement of the AccordionItems API, however it's not\n    being used.\n\n    Casting 'h4' as const because it needs to be a heading type as specified HeadingLevel.\n    */headingLevel:\"h4\",title:/*#__PURE__*/react.createElement(components_Category,{name:category.titleText,isDisadvantaged:category.isDisadvagtaged}),content:/*#__PURE__*/react.createElement(react.Fragment,null,category.indicators.map((indicator,index)=>{return/*#__PURE__*/react.createElement(components_Indicator,{key:`ind${index}`,indicator:indicator});}),/*#__PURE__*/react.createElement(\"div\",{className:categorySpacer},explore/* SIDE_PANEL_SPACERS */.zZ.AND),category.socioEcIndicators.map((indicator,index)=>{return/*#__PURE__*/react.createElement(components_Indicator,{key:`ind${index}`,indicator:indicator,isImpute:properties[constants/* IMPUTE_FLAG */.WDE]===\"0\"?false:true,population:population});})),expanded:false}));return/*#__PURE__*/react.createElement(\"aside\",{className:areaDetailContainer,\"data-cy\":\"aside\"},/*#__PURE__*/react.createElement(components_TractInfo,{blockGroup:blockGroup,countyName:countyName,stateName:stateName,population:population,sidePanelState:properties[constants/* SIDE_PANEL_STATE */.TPq]}),/*#__PURE__*/react.createElement(components_TractDemographics,{properties:properties}),/*#__PURE__*/react.createElement(\"div\",{className:categorization},/*#__PURE__*/react.createElement(\"div\",{className:isInFocus},explore/* COMMUNITY */.GN.IS_FOCUS),/*#__PURE__*/react.createElement(\"div\",{className:communityOfFocus},/*#__PURE__*/react.createElement(components_TractPrioritization,{scoreNCommunities:properties[constants/* SCORE_N_COMMUNITIES */.ylX]===true?properties[constants/* SCORE_N_COMMUNITIES */.ylX]:false,tribalCountAK:properties[constants/* TRIBAL_AREAS_COUNT_AK */.$RP]>=1?properties[constants/* TRIBAL_AREAS_COUNT_AK */.$RP]:null,tribalCountUS:properties[constants/* TRIBAL_AREAS_COUNT_CONUS */.drv]>=1?properties[constants/* TRIBAL_AREAS_COUNT_CONUS */.drv]:null,percentTractTribal:percentTractTribal})),/*#__PURE__*/react.createElement(\"div\",{className:prioCopy},/*#__PURE__*/react.createElement(components_PrioritizationCopy,{totalCategoriesPrioritized:properties[constants/* COUNT_OF_CATEGORIES_DISADV */.xLj],totalBurdensPrioritized:properties[constants/* TOTAL_NUMBER_OF_DISADVANTAGE_INDICATORS */.SfK],isAdjacencyThreshMet:properties[constants/* ADJACENCY_EXCEEDS_THRESH */.axb],isAdjacencyLowIncome:properties[constants/* ADJACENCY_LOW_INCOME_EXCEEDS_THRESH */.PAj],isIslandLowIncome:properties[constants/* IS_FEDERAL_POVERTY_LEVEL_200 */.pyQ]&&constants/* TILES_ISLAND_AREA_FIPS_CODES */.STP.some(code=>{return properties[constants/* GEOID_PROPERTY */.TnO].startsWith(code);}),tribalCountAK:properties[constants/* TRIBAL_AREAS_COUNT_AK */.$RP]>=1?properties[constants/* TRIBAL_AREAS_COUNT_AK */.$RP]:null,tribalCountUS:properties[constants/* TRIBAL_AREAS_COUNT_CONUS */.drv]>=1?properties[constants/* TRIBAL_AREAS_COUNT_CONUS */.drv]:null,percentTractTribal:percentTractTribal,isGrandfathered:properties[constants/* IS_GRANDFATHERED */.fgy]}),/*#__PURE__*/react.createElement(components_PrioritizationCopy2,{totalCategoriesPrioritized:properties[constants/* COUNT_OF_CATEGORIES_DISADV */.xLj],isAdjacencyThreshMet:properties[constants/* ADJACENCY_EXCEEDS_THRESH */.axb],isAdjacencyLowIncome:properties[constants/* ADJACENCY_LOW_INCOME_EXCEEDS_THRESH */.PAj],tribalCountAK:properties[constants/* TRIBAL_AREAS_COUNT_AK */.$RP]>=1?properties[constants/* TRIBAL_AREAS_COUNT_AK */.$RP]:null,tribalCountUS:properties[constants/* TRIBAL_AREAS_COUNT_CONUS */.drv]>=1?properties[constants/* TRIBAL_AREAS_COUNT_CONUS */.drv]:null,percentTractTribal:percentTractTribal}))),showIslandCopy&&/*#__PURE__*/react.createElement(IslandCopy_IslandCopy,{povertyPercentile:poveryPercentile}),showDonutCopy&&/*#__PURE__*/react.createElement(components_DonutCopy,{isAdjacent:properties[constants/* ADJACENCY_EXCEEDS_THRESH */.axb],povertyBelow200Percentile:poveryPercentile}),/*#__PURE__*/react.createElement(\"a\",{className:sendFeedbackLink,href:intl.locale===`es`?`${constants/* CENSUS_TRACT_SURVEY_LINKS */.GGW.ES}?tractid=${blockGroup}`:`${constants/* CENSUS_TRACT_SURVEY_LINKS */.GGW.EN}?tractid=${blockGroup}`,target:\"_blank\",rel:\"noreferrer\"},/*#__PURE__*/react.createElement(lib.Button,{type:\"button\",className:sendFeedbackBtn},/*#__PURE__*/react.createElement(\"div\",{className:buttonContainer},/*#__PURE__*/react.createElement(\"div\",{className:buttonText},explore/* COMMUNITY */.GN.SEND_FEEDBACK.TITLE),/*#__PURE__*/react.createElement(lib.Icon.Launch,{\"aria-label\":intl.formatMessage(explore/* COMMUNITY */.GN.SEND_FEEDBACK.IMG_ICON.ALT_TAG)})))),/*#__PURE__*/react.createElement(lib.Accordion,{multiselectable:true,items:categoryItems,className:\"-AreaDetail\"}),/*#__PURE__*/react.createElement(\"div\",{className:versionInfo},explore/* SIDE_PANEL_VERSION */.Co.TITLE));};/* harmony default export */ var AreaDetail_AreaDetail = (AreaDetail);\n;// ./src/components/AreaDetail/index.tsx\n/* harmony default export */ var components_AreaDetail = (AreaDetail_AreaDetail);\n;// ./node_modules/uswds/dist/img/usa-icons/add.svg\n/* harmony default export */ var usa_icons_add = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE5IDEzaC02djZoLTJ2LTZINXYtMmg2VjVoMnY2aDZ2MnoiLz48L3N2Zz4=\");\n;// ./node_modules/uswds/dist/img/usa-icons/search.svg\n/* harmony default export */ var search = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE1LjUgMTRoLS43OWwtLjI4LS4yN0MxNS40MSAxMi41OSAxNiAxMS4xMSAxNiA5LjUgMTYgNS45MSAxMy4wOSAzIDkuNSAzUzMgNS45MSAzIDkuNSA1LjkxIDE2IDkuNSAxNmMxLjYxIDAgMy4wOS0uNTkgNC4yMy0xLjU3bC4yNy4yOHYuNzlsNSA0Ljk5TDIwLjQ5IDE5bC00Ljk5LTV6bS02IDBDNy4wMSAxNCA1IDExLjk5IDUgOS41UzcuMDEgNSA5LjUgNSAxNCA3LjAxIDE0IDkuNSAxMS45OSAxNCA5LjUgMTR6Ii8+PC9zdmc+\");\n;// ./node_modules/uswds/dist/img/usa-icons/my_location.svg\n/* harmony default export */ var my_location = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTEyIDhjLTIuMjEgMC00IDEuNzktNCA0czEuNzkgNCA0IDQgNC0xLjc5IDQtNC0xLjc5LTQtNC00em04Ljk0IDNjLS40Ni00LjE3LTMuNzctNy40OC03Ljk0LTcuOTRWMWgtMnYyLjA2QzYuODMgMy41MiAzLjUyIDYuODMgMy4wNiAxMUgxdjJoMi4wNmMuNDYgNC4xNyAzLjc3IDcuNDggNy45NCA3Ljk0VjIzaDJ2LTIuMDZjNC4xNy0uNDYgNy40OC0zLjc3IDcuOTQtNy45NEgyM3YtMmgtMi4wNnpNMTIgMTljLTMuODcgMC03LTMuMTMtNy03czMuMTMtNyA3LTcgNyAzLjEzIDcgNy0zLjEzIDctNyA3eiIvPjwvc3ZnPg==\");\n;// ./node_modules/uswds/dist/img/usa-icons/people.svg\n/* harmony default export */ var people = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE2IDExYzEuNjYgMCAyLjk5LTEuMzQgMi45OS0zUzE3LjY2IDUgMTYgNWMtMS42NiAwLTMgMS4zNC0zIDNzMS4zNCAzIDMgM3ptLTggMGMxLjY2IDAgMi45OS0xLjM0IDIuOTktM1M5LjY2IDUgOCA1QzYuMzQgNSA1IDYuMzQgNSA4czEuMzQgMyAzIDN6bTAgMmMtMi4zMyAwLTcgMS4xNy03IDMuNVYxOWgxNHYtMi41YzAtMi4zMy00LjY3LTMuNS03LTMuNXptOCAwYy0uMjkgMC0uNjIuMDItLjk3LjA1IDEuMTYuODQgMS45NyAxLjk3IDEuOTcgMy40NVYxOWg2di0yLjVjMC0yLjMzLTQuNjctMy41LTctMy41eiIvPjwvc3ZnPg==\");\n;// ./node_modules/uswds/dist/img/usa-icons/file_upload.svg\n/* harmony default export */ var file_upload = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTkgMTZoNnYtNmg0bC03LTctNyA3aDR6bS00IDJoMTR2Mkg1eiIvPjwvc3ZnPg==\");\n;// ./node_modules/uswds/dist/img/usa-icons/check.svg\n/* harmony default export */ var usa_icons_check = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTkgMTYuMTdMNC44MyAxMmwtMS40MiAxLjQxTDkgMTkgMjEgN2wtMS40MS0xLjQxeiIvPjwvc3ZnPg==\");\n;// ./src/images/sidePanelIcons/puzzle.svg\n/* harmony default export */ var puzzle = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMzkuODcgMTQyLjc0Ij48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2ZmZjt9LmNscy0ye2ZpbGw6IzIzMWYyMDt9LmNscy0ze2ZpbGw6I2JjYmVjYTt9LmNscy00e2ZpbGw6IzBjMzU1Njt9PC9zdHlsZT48L2RlZnM+PGcgaWQ9IkxheWVyXzIiIGRhdGEtbmFtZT0iTGF5ZXIgMiI+PGcgaWQ9IkxheWVyXzEtMiIgZGF0YS1uYW1lPSJMYXllciAxIj48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0xMDkuMDksODguMjVoLTIuMjhsLTMyLjIxLjg0Yy0yLjE0LjA2LTMsLjg1LTMsMi45djQ3LjQ2YzAsMiwxLDIuOTQsMywyLjkzcTMxLjItLjEsNjIuMzgtLjI2YzIuMDYsMCwyLjg5LS44NiwyLjg5LTIuOTRWNzUuODVjMC0yLjEzLS44OC0zLTMtM0gxMTIuMDljLTIuMTgsMC0zLC44NC0zLDNaTTQ3LjE2LDI4Ljg3VjMuMTVjMC0yLjMyLS43Ny0zLjEzLTMtMy4xM0gzQzEsMCwuMDUuODYuMDYsMi43OVEuMTcsMzQsLjMxLDY1LjI5YzAsMi4xMS43OSwyLjgxLDMsMi44Nkg2Ny4wOWMyLjU1LDAsMy4yOS0uNjEsMy4zLTIuODJWMzEuNjdjMC0yLS44My0yLjc4LTIuODUtMi43OEg0Ny4xNlptNS4xNC0yNGg4Mi41MXY2M2g0Ljc1VjMuMzFjMC0yLjU4LS43My0zLjI5LTMuMzYtMy4yOUg1Mi4zWm0tNDcuMTYsMTMzdi02NkguMzV2NjcuM2MwLDIuODcuNzEsMy41NywzLjYsMy41N0g2Ni42MVYxMzhaIi8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMzkuNDQsNS4wNnYtNUgxMzYuMmMyLjYzLDAsMy4zNi43NCwzLjM2LDMuNDFWODMuNzJoLTQuNzVWNS4wNloiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik01LjE0LDEzNy45SDc2LjI1djQuNzlINGMtMi44OSwwLTMuNi0uNy0zLjYtMy41N1Y2NS40Mkg1LjE0WiIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTc2LjU0LDkzLjg5Yy42MywwLDEuMTUtLjA5LDEuNjctLjFsMzEuOTEtLjcxYzIuNDQsMCwyLjIyLS43NywyLjMzLTMuMjguMTQtMy40OS4yLTcsLjMtMTAuNDcsMC0uNTMsMS4xLTEsMS4xNS0xLjYzaDIxdjYwSDc2LjU0WiIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTY1LjUxLDMzLjY3VjYzLjQxSDYuNjZjLTEuNDcsMC0xLjc4LS41LTEuNzgtMS44NFY1LjQ4QTIuMTIsMi4xMiwwLDAsMSw1LDQuODlINDIuNDFWMzAuNDVjMCwyLjM4Ljc5LDMuMTgsMy4xNCwzLjE4aDIwWiIvPjxwYXRoIGNsYXNzPSJjbHMtNCIgZD0iTTEwOC45MSw4OC4zMlY3NS44M2MwLTIuMTUuODYtMywzLTNoMjQuNThjMi4xNCwwLDMsLjg4LDMsM3Y2My42MmMwLDIuMDktLjgyLDMtMi44OCwzcS0zMSwuMTUtNjIuMDkuMjVjLTIsMC0zLS45MS0zLTIuOTRWOTIuMDljMC0yLjA3LjgyLTIuODUsMy0yLjkxQzg1LjI3LDg4Ljg3LDEwNy44LDg4LjMyLDEwOC45MSw4OC4zMlptLTMyLjQsNS41OXY0My44aDU4LjE0di02MEgxMTMuNzFjMCwuNTgtLjEzLDEuMTEtLjE1LDEuNjMtLjEsMy40OS0uMTYsNy0uMywxMC40Ni0uMSwyLjUyLS44OCwzLjIzLTMuMzEsMy4yOWwtMzEuNzYuNy0xLjY4LjEyWiIvPjxwYXRoIGNsYXNzPSJjbHMtNCIgZD0iTTQ3LjE2LDI4Ljg3SDY3LjVjMiwwLDIuODQuNzgsMi44NSwyLjc4VjY1LjMxYzAsMi4yMS0uNzUsMi44Mi0zLjMsMi44MkgzLjI1Yy0yLjE2LDAtMi45NC0uNzUtMy0yLjg2US4xLDM0LDAsMi43N0MwLC44NC45MSwwLDIuOSwwSDQ0LjFjMi4yNSwwLDMsLjgxLDMsMy4xM1YyNi44NVptMTguMzUsNC44aC0yMGMtMi4zNSwwLTMuMTQtLjgtMy4xNC0zLjE4VjQuOTNINC45MWMwLC4yOC0uMDcuNDQtLjA3LjU5VjYxLjYxYzAsMS4zNC4zMSwxLjg0LDEuNzgsMS44NHEyOC42MS0uMDgsNTcuMjIsMGgxLjYzWiIvPjwvZz48L2c+PC9zdmc+\");\n;// ./src/images/sidePanelIcons/bell-curve.svg\n/* harmony default export */ var bell_curve = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxODcuODcgMTI5LjgiPjxkZWZzPjxzdHlsZT4uY2xzLTF7ZmlsbDojZmZmO308L3N0eWxlPjwvZGVmcz48ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIj48ZyBpZD0iTGF5ZXJfMS0yIiBkYXRhLW5hbWU9IkxheWVyIDEiPjxnIGlkPSJYTVBwMkoudGlmIj48cGF0aCBkPSJNMjAuODYsMTI1LjNhNC4xMSw0LjExLDAsMCwwLDMuNzUtMS44MSwxMzIuNiwxMzIuNiwwLDAsMCwyNC00OS42NEM1MS4xOCw2My41NSw1Myw1My4wNyw1NS4yNSw0Mi43YzItOS4yMiw0LjYtMTguMjgsMTAuNjQtMjUuNzlDNzQuMTksNi42LDg0LjY5LS4xNCw5OC4zLDBjMTYuMzYuMTgsMjguMTYsOC4zOSwzNS44MiwyMi41OCw0LjEzLDcuNjQsNS40MywxNi4xNiw2LjQ4LDI0LjY2LDIsMTUuOSwzLjY2LDMxLjg0LDkuNDEsNDdBMTI2LjE2LDEyNi4xNiwwLDAsMCwxNjYsMTIzLjQ2YTQsNCwwLDAsMCwzLjcxLDEuODZNMzUuMjMsMTI1LjFoMTIwLjVjLS4zMi0uNTgtLjQ4LS45NC0uNy0xLjI2YTEyNC42NiwxMjQuNjYsMCwwLDEtMTkuOS00OS41M2MtMS43OS0xMC40Ny0yLjkxLTIxLTQuNTEtMzEuNTUtMS4wNS02LjkzLTIuNzgtMTMuNjYtNi43NC0xOS42MkMxMTYuOTMsMTIuNywxMDMuNzksNyw5Mi4zLDkuOTRjLTExLjI1LDIuOS0xOS4xMiwxMC0yMy43LDIwLjY5QzY0LjYsNDAsNjMuMTksNTAuMSw2MS4zMSw2MCw1OCw3Ny42Nyw1Myw5NC43NCw0NC4xNywxMTAuNDgsNDEuMzcsMTE1LjM5LDM4LjIzLDEyMC4xLDM1LjIzLDEyNS4xWiIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTM1LjIzLDEyNS4xYzMuMDctNSw2LjE4LTkuNzEsOC45NC0xNC42MkM1Myw5NC43NCw1Ny45NCw3Ny42Nyw2MS4yMyw2MGMxLjg4LTkuOTQsMy4yNS0yMCw3LjI5LTI5LjQxQzczLjEsMjAsODEsMTIuODQsOTIuMjIsOS45NGMxMS40OS0zLDI0LjYzLDIuNzYsMzEuNTgsMTMuMiw0LDYsNS42OSwxMi42OSw2Ljc0LDE5LjYyLDEuNiwxMC41LDIuNzIsMjEuMDgsNC41MSwzMS41NUExMjQuNjYsMTI0LjY2LDAsMCwwLDE1NSwxMjMuODRjLjIyLjMyLjM4LjY4LjcsMS4yNloiLz48L2c+PHJlY3QgeT0iMTIwLjgiIHdpZHRoPSIxODcuODciIGhlaWdodD0iOSIvPjwvZz48L2c+PC9zdmc+\");\n// EXTERNAL MODULE: ./src/images/sidePanelIcons/census-tract.svg\nvar census_tract = __webpack_require__(6455);\n;// ./src/images/sidePanelIcons/pie-chart.svg\n/* harmony default export */ var pie_chart = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTcuMDMgMTU2LjkyIj48ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIj48ZyBpZD0iTGF5ZXJfMS0yIiBkYXRhLW5hbWU9IkxheWVyIDEiPjxwYXRoIGQ9Ik05NC40MSwxMjYuODVoLS45NGwtMy40NCwwVjc5YzAtNS45NC0zLjM2LTEwLjMxLTktMTEuNjlhMTguNCwxOC40LDAsMCwwLTQtLjM1SDM1Ljg5TDMwLjIsNjdsLS4wOC0zLjRDMjkuNDIsMzQuNTIsNTIuMjYsMiw5MC4zNi4wOWE2My4zOSw2My4zOSwwLDAsMSw2Ni41OSw2MCw2NCw2NCwwLDAsMSwwLDcuMDYsNjMuMjYsNjMuMjYsMCwwLDEtNjIuNTEsNTkuNzJaTTc3LjU3LDYwYTI0LjY5LDI0LjY5LDAsMCwxLDUsLjUxbC4xMSwwQzkxLjUxLDYyLjY0LDk3LDY5LjczLDk3LDc5djQwLjc4YTU2LjMyLDU2LjMyLDAsMCwwLDUyLjktNTMuMDcsNTcuMzgsNTcuMzgsMCwwLDAsMC02LjI5QTU2LjM4LDU2LjM4LDAsMCwwLDkwLjcyLDcuMDhDNTguMyw4LjcxLDM4LjMxLDM1LjE1LDM3LjE2LDYwSDc3LjU3WiIvPjxwYXRoIGQ9Ik02OCwxNTYuOTJoMEE2OC4yOSw2OC4yOSwwLDAsMSwxLjUyLDEwMi41LDgzLjI0LDgzLjI0LDAsMCwxLC4zNCw5Mi45Qy4yNSw5MS44LjE2LDkwLjY5LjA2LDg5LjZhOC41Miw4LjUyLDAsMCwxLDIuMTMtNi43OEE5LjI5LDkuMjksMCwwLDEsOS40MSw4MGMyLjc0LjA2LDUuNTQsMCw4LjI0LDBsNC4yLDBINjcuNjNjNC4wOSwwLDYuOTIsMS41NSw4LjM5LDQuNjJBMTAuNDksMTAuNDksMCwwLDEsNzcsODl2MTAuN2MwLDIuMTYsMCw0LjU1LDAsOC44OHYzOS4zN2E4LjQ0LDguNDQsMCwwLDEtOSw5Wm0tNTguNzgtNzBhMi40OCwyLjQ4LDAsMCwwLTEuODQuNjFBMS42MywxLjYzLDAsMCwwLDcsODguODhjLjExLDEuMTcuMjEsMi4zMS4zLDMuNDVhNzQuNDIsNzQuNDIsMCwwLDAsMS4wNiw4Ljc2QTYxLjYsNjEuNiwwLDAsMCw2OCwxNDkuOTJhMi40LDIuNCwwLDAsMCwxLjYzLS40LDIuNDMsMi40MywwLDAsMCwuNC0xLjZWMTA4LjU1YzAtNC4zMywwLTYuNzMsMC04Ljg5Vjg5YTMuMzEsMy4zMSwwLDAsMC0uMzItMS40MmMtLjExLS4yMy0uMjktLjYxLTIuMDYtLjYxSDE3LjdjLTIuNzUsMC01LjYsMC04LjQzLDBaIi8+PC9nPjwvZz48L3N2Zz4=\");\n;// ./src/components/SidePanelInfo/SidePanelInfo.module.scss\n// extracted by mini-css-extract-plugin\nvar sidePanelInfoContainer = \"SidePanelInfo-module--sidePanelInfoContainer--z0WO6\";\nvar sidePanelInfoHeading = \"SidePanelInfo-module--sidePanelInfoHeading--IqyD0\";\nvar sidePanelInfoIcon = \"SidePanelInfo-module--sidePanelInfoIcon--FvRrL\";\nvar sidePanelInfoTitle = \"SidePanelInfo-module--sidePanelInfoTitle--RozdZ\";\n;// ./src/components/SidePanelInfo/SidePanelInfo.tsx\n// @ts-ignore\n// @ts-ignore\n// @ts-ignore\n// @ts-ignore\n// @ts-ignore\n// @ts-ignore\n// @ts-ignore\n// @ts-ignore\n// @ts-ignore\n// @ts-ignore\n// import tribalDotIcon from '../../images/sidePanelIcons/tribal-tract.svg';\n// @ts-ignore\n// @ts-ignore\n// import handPointIcon from '../../images/sidePanelIcons/mouse-hand-point.svg';\nconst SidePanelInfo=()=>{const intl=(0,gatsby_plugin_intl.useIntl)();const{width:windowWidth}=(0,useWindowSize/* default */.A)();return/*#__PURE__*/react.createElement(\"aside\",{className:sidePanelInfoContainer},/*#__PURE__*/react.createElement(\"header\",{tabIndex:0,className:sidePanelInfoTitle},intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.HEADING1)),/*#__PURE__*/react.createElement(\"p\",{tabIndex:0},intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA1_PART1),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:usa_icons_add,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.PLUS)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA1_PART2),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:search,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.SEARCH)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA1_PART3),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:my_location,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.LOCATE)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA1_PART4),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA1_PART5)),/*#__PURE__*/react.createElement(\"p\",{tabIndex:0,className:sidePanelInfoHeading},intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.HEADING2)),/*#__PURE__*/react.createElement(\"p\",{tabIndex:0},intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA2_PART1),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:puzzle,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.TRACT)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA2_PART2),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:people,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.PEOPLE)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA2_PART3)),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(\"p\",{tabIndex:0},intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA3_PART1),/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:census_tract/* default */.A,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.DAC_CIRCLE)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA3_PART2)),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(\"p\",{tabIndex:0},intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA4_PART1),/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:bell_curve,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.BELL_CURVE)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA4_PART2)),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(\"p\",{tabIndex:0},intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA5_PART1),/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:file_upload,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.FILE_UP)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA5_PART2),/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:pie_chart,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.PIE_CHART)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA5_PART3),/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:usa_icons_check,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.CHECK)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA5_PART4)),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(\"p\",{tabIndex:0},intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA6_PART1),/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:census_tract/* default */.A,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.DAC_CIRCLE)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA6_PART2)));};/* harmony default export */ var SidePanelInfo_SidePanelInfo = (SidePanelInfo);\n;// ./src/components/SidePanelInfo/index.tsx\n/* harmony default export */ var components_SidePanelInfo = (SidePanelInfo_SidePanelInfo);\n;// ./src/components/mapInfoPanel.tsx\nconst MapInfoPanel=_ref=>{let{className,featureProperties,hash}=_ref;return/*#__PURE__*/react.createElement(\"div\",{className:className},featureProperties?/*#__PURE__*/react.createElement(components_AreaDetail,{properties:featureProperties,hash:hash}):/*#__PURE__*/react.createElement(components_SidePanelInfo,null));};/* harmony default export */ var mapInfoPanel = (MapInfoPanel);\n;// ./node_modules/js-search/dist/esm/js-search.js\n/**\n * Indexes for all substring searches (e.g. the term \"cat\" is indexed as \"c\", \"ca\", \"cat\", \"a\", \"at\", and \"t\").\n */\nvar AllSubstringsIndexStrategy = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  function AllSubstringsIndexStrategy() {}\n  var _proto = AllSubstringsIndexStrategy.prototype;\n\n  /**\n   * @inheritDocs\n   */\n  _proto.expandToken = function expandToken(token) {\n    var expandedTokens = [];\n    var string;\n    for (var i = 0, length = token.length; i < length; ++i) {\n      string = '';\n      for (var j = i; j < length; ++j) {\n        string += token.charAt(j);\n        expandedTokens.push(string);\n      }\n    }\n    return expandedTokens;\n  };\n  return AllSubstringsIndexStrategy;\n}()));\n\n/**\n * Indexes for exact word matches.\n */\nvar ExactWordIndexStrategy = /*#__PURE__*/function () {\n  function ExactWordIndexStrategy() {}\n  var _proto = ExactWordIndexStrategy.prototype;\n\n  /**\n   * @inheritDocs\n   */\n  _proto.expandToken = function expandToken(token) {\n    return token ? [token] : [];\n  };\n  return ExactWordIndexStrategy;\n}();\n\n/**\n * Indexes for prefix searches (e.g. the term \"cat\" is indexed as \"c\", \"ca\", and \"cat\" allowing prefix search lookups).\n */\nvar PrefixIndexStrategy = /*#__PURE__*/function () {\n  function PrefixIndexStrategy() {}\n  var _proto = PrefixIndexStrategy.prototype;\n\n  /**\n   * @inheritDocs\n   */\n  _proto.expandToken = function expandToken(token) {\n    var expandedTokens = [];\n    var string = '';\n    for (var i = 0, length = token.length; i < length; ++i) {\n      string += token.charAt(i);\n      expandedTokens.push(string);\n    }\n    return expandedTokens;\n  };\n  return PrefixIndexStrategy;\n}();\n\n/**\n * Enforces case-sensitive text matches.\n */\nvar CaseSensitiveSanitizer = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  function CaseSensitiveSanitizer() {}\n  var _proto = CaseSensitiveSanitizer.prototype;\n\n  /**\n   * @inheritDocs\n   */\n  _proto.sanitize = function sanitize(text) {\n    return text ? text.trim() : '';\n  };\n  return CaseSensitiveSanitizer;\n}()));\n\n/**\n * Sanitizes text by converting to a locale-friendly lower-case version and triming leading and trailing whitespace.\n */\nvar LowerCaseSanitizer = /*#__PURE__*/function () {\n  function LowerCaseSanitizer() {}\n  var _proto = LowerCaseSanitizer.prototype;\n\n  /**\n   * @inheritDocs\n   */\n  _proto.sanitize = function sanitize(text) {\n    return text ? text.toLocaleLowerCase().trim() : '';\n  };\n  return LowerCaseSanitizer;\n}();\n\n/**\n * Find and return a nested object value.\n *\n * @param object to crawl\n * @param path Property path\n * @returns {any}\n */\nfunction getNestedFieldValue(object, path) {\n  path = path || [];\n  object = object || {};\n  var value = object; // walk down the property path\n\n  for (var i = 0; i < path.length; i++) {\n    value = value[path[i]];\n    if (value == null) {\n      return null;\n    }\n  }\n  return value;\n}\n\n/**\n * Search index capable of returning results matching a set of tokens and ranked according to TF-IDF.\n */\nvar TfIdfSearchIndex = /*#__PURE__*/function () {\n  function TfIdfSearchIndex(uidFieldName) {\n    this._uidFieldName = uidFieldName;\n    this._tokenToIdfCache = {};\n    this._tokenMap = {};\n  }\n  /**\n   * @inheritDocs\n   */\n\n  var _proto = TfIdfSearchIndex.prototype;\n  _proto.indexDocument = function indexDocument(token, uid, doc) {\n    this._tokenToIdfCache = {}; // New index invalidates previous IDF caches\n\n    var tokenMap = this._tokenMap;\n    var tokenDatum;\n    if (typeof tokenMap[token] !== 'object') {\n      tokenMap[token] = tokenDatum = {\n        $numDocumentOccurrences: 0,\n        $totalNumOccurrences: 1,\n        $uidMap: {}\n      };\n    } else {\n      tokenDatum = tokenMap[token];\n      tokenDatum.$totalNumOccurrences++;\n    }\n    var uidMap = tokenDatum.$uidMap;\n    if (typeof uidMap[uid] !== 'object') {\n      tokenDatum.$numDocumentOccurrences++;\n      uidMap[uid] = {\n        $document: doc,\n        $numTokenOccurrences: 1\n      };\n    } else {\n      uidMap[uid].$numTokenOccurrences++;\n    }\n  }\n  /**\n   * @inheritDocs\n   */;\n  _proto.search = function search(tokens, corpus) {\n    var uidToDocumentMap = {};\n    for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n      var token = tokens[i];\n      var tokenMetadata = this._tokenMap[token]; // Short circuit if no matches were found for any given token.\n\n      if (!tokenMetadata) {\n        return [];\n      }\n      if (i === 0) {\n        var keys = Object.keys(tokenMetadata.$uidMap);\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n          uidToDocumentMap[uid] = tokenMetadata.$uidMap[uid].$document;\n        }\n      } else {\n        var keys = Object.keys(uidToDocumentMap);\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n          if (typeof tokenMetadata.$uidMap[uid] !== 'object') {\n            delete uidToDocumentMap[uid];\n          }\n        }\n      }\n    }\n    var documents = [];\n    for (var uid in uidToDocumentMap) {\n      documents.push(uidToDocumentMap[uid]);\n    }\n    var calculateTfIdf = this._createCalculateTfIdf(); // Return documents sorted by TF-IDF\n\n    return documents.sort(function (documentA, documentB) {\n      return calculateTfIdf(tokens, documentB, corpus) - calculateTfIdf(tokens, documentA, corpus);\n    });\n  };\n  _proto._createCalculateIdf = function _createCalculateIdf() {\n    var tokenMap = this._tokenMap;\n    var tokenToIdfCache = this._tokenToIdfCache;\n    return function calculateIdf(token, documents) {\n      if (!tokenToIdfCache[token]) {\n        var numDocumentsWithToken = typeof tokenMap[token] !== 'undefined' ? tokenMap[token].$numDocumentOccurrences : 0;\n        tokenToIdfCache[token] = 1 + Math.log(documents.length / (1 + numDocumentsWithToken));\n      }\n      return tokenToIdfCache[token];\n    };\n  };\n  _proto._createCalculateTfIdf = function _createCalculateTfIdf() {\n    var tokenMap = this._tokenMap;\n    var uidFieldName = this._uidFieldName;\n    var calculateIdf = this._createCalculateIdf();\n    return function calculateTfIdf(tokens, document, documents) {\n      var score = 0;\n      for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n        var token = tokens[i];\n        var inverseDocumentFrequency = calculateIdf(token, documents);\n        if (inverseDocumentFrequency === Infinity) {\n          inverseDocumentFrequency = 0;\n        }\n        var uid;\n        if (uidFieldName instanceof Array) {\n          uid = document && getNestedFieldValue(document, uidFieldName);\n        } else {\n          uid = document && document[uidFieldName];\n        }\n        var termFrequency = typeof tokenMap[token] !== 'undefined' && typeof tokenMap[token].$uidMap[uid] !== 'undefined' ? tokenMap[token].$uidMap[uid].$numTokenOccurrences : 0;\n        score += termFrequency * inverseDocumentFrequency;\n      }\n      return score;\n    };\n  };\n  return TfIdfSearchIndex;\n}();\n\n/**\n * Search index capable of returning results matching a set of tokens but without any meaningful rank or order.\n */\nvar UnorderedSearchIndex = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  function UnorderedSearchIndex() {\n    this._tokenToUidToDocumentMap = {};\n  }\n  /**\n   * @inheritDocs\n   */\n\n  var _proto = UnorderedSearchIndex.prototype;\n  _proto.indexDocument = function indexDocument(token, uid, doc) {\n    if (typeof this._tokenToUidToDocumentMap[token] !== 'object') {\n      this._tokenToUidToDocumentMap[token] = {};\n    }\n    this._tokenToUidToDocumentMap[token][uid] = doc;\n  }\n  /**\n   * @inheritDocs\n   */;\n  _proto.search = function search(tokens, corpus) {\n    var intersectingDocumentMap = {};\n    var tokenToUidToDocumentMap = this._tokenToUidToDocumentMap;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n      var token = tokens[i];\n      var documentMap = tokenToUidToDocumentMap[token]; // Short circuit if no matches were found for any given token.\n\n      if (!documentMap) {\n        return [];\n      }\n      if (i === 0) {\n        var keys = Object.keys(documentMap);\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n          intersectingDocumentMap[uid] = documentMap[uid];\n        }\n      } else {\n        var keys = Object.keys(intersectingDocumentMap);\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n          if (typeof documentMap[uid] !== 'object') {\n            delete intersectingDocumentMap[uid];\n          }\n        }\n      }\n    }\n    var keys = Object.keys(intersectingDocumentMap);\n    var documents = [];\n    for (var i = 0, numKeys = keys.length; i < numKeys; i++) {\n      var uid = keys[i];\n      documents.push(intersectingDocumentMap[uid]);\n    }\n    return documents;\n  };\n  return UnorderedSearchIndex;\n}()));\nvar REGEX = /[^a-zа-яё0-9\\-']+/i;\n/**\n * Simple tokenizer that splits strings on whitespace characters and returns an array of all non-empty substrings.\n */\n\nvar SimpleTokenizer = /*#__PURE__*/function () {\n  function SimpleTokenizer() {}\n  var _proto = SimpleTokenizer.prototype;\n\n  /**\n   * @inheritDocs\n   */\n  _proto.tokenize = function tokenize(text) {\n    return text.split(REGEX).filter(function (text) {\n      return text;\n    } // Filter empty tokens\n    );\n  };\n  return SimpleTokenizer;\n}();\n\n/**\n * Stemming is the process of reducing search tokens to their root (or stem) so that searches for different forms of a\n * word will match. For example \"search\", \"searching\" and \"searched\" are all reduced to the stem \"search\".\n *\n * <p>This stemming tokenizer converts tokens (words) to their stem forms before returning them. It requires an\n * external stemming function to be provided; for this purpose I recommend the NPM 'porter-stemmer' library.\n *\n * <p>For more information see http : //tartarus.org/~martin/PorterStemmer/\n */\nvar StemmingTokenizer = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  /**\n   * Constructor.\n   *\n   * @param stemmingFunction Function capable of accepting a word and returning its stem.\n   * @param decoratedIndexStrategy Index strategy to be run after all stop words have been removed.\n   */\n  function StemmingTokenizer(stemmingFunction, decoratedTokenizer) {\n    this._stemmingFunction = stemmingFunction;\n    this._tokenizer = decoratedTokenizer;\n  }\n  /**\n   * @inheritDocs\n   */\n\n  var _proto = StemmingTokenizer.prototype;\n  _proto.tokenize = function tokenize(text) {\n    return this._tokenizer.tokenize(text).map(this._stemmingFunction);\n  };\n  return StemmingTokenizer;\n}()));\n\n/**\n * Stop words list copied from Lunr JS.\n */\nvar StopWordsMap = {\n  a: true,\n  able: true,\n  about: true,\n  across: true,\n  after: true,\n  all: true,\n  almost: true,\n  also: true,\n  am: true,\n  among: true,\n  an: true,\n  and: true,\n  any: true,\n  are: true,\n  as: true,\n  at: true,\n  be: true,\n  because: true,\n  been: true,\n  but: true,\n  by: true,\n  can: true,\n  cannot: true,\n  could: true,\n  dear: true,\n  did: true,\n  'do': true,\n  does: true,\n  either: true,\n  'else': true,\n  ever: true,\n  every: true,\n  'for': true,\n  from: true,\n  'get': true,\n  got: true,\n  had: true,\n  has: true,\n  have: true,\n  he: true,\n  her: true,\n  hers: true,\n  him: true,\n  his: true,\n  how: true,\n  however: true,\n  i: true,\n  'if': true,\n  'in': true,\n  into: true,\n  is: true,\n  it: true,\n  its: true,\n  just: true,\n  least: true,\n  \"let\": true,\n  like: true,\n  likely: true,\n  may: true,\n  me: true,\n  might: true,\n  most: true,\n  must: true,\n  my: true,\n  neither: true,\n  no: true,\n  nor: true,\n  not: true,\n  of: true,\n  off: true,\n  often: true,\n  on: true,\n  only: true,\n  or: true,\n  other: true,\n  our: true,\n  own: true,\n  rather: true,\n  said: true,\n  say: true,\n  says: true,\n  she: true,\n  should: true,\n  since: true,\n  so: true,\n  some: true,\n  than: true,\n  that: true,\n  the: true,\n  their: true,\n  them: true,\n  then: true,\n  there: true,\n  these: true,\n  they: true,\n  'this': true,\n  tis: true,\n  to: true,\n  too: true,\n  twas: true,\n  us: true,\n  wants: true,\n  was: true,\n  we: true,\n  were: true,\n  what: true,\n  when: true,\n  where: true,\n  which: true,\n  'while': true,\n  who: true,\n  whom: true,\n  why: true,\n  will: true,\n  'with': true,\n  would: true,\n  yet: true,\n  you: true,\n  your: true\n}; // Prevent false positives for inherited properties\n\nStopWordsMap.constructor = false;\nStopWordsMap.hasOwnProperty = false;\nStopWordsMap.isPrototypeOf = false;\nStopWordsMap.propertyIsEnumerable = false;\nStopWordsMap.toLocaleString = false;\nStopWordsMap.toString = false;\nStopWordsMap.valueOf = false;\n\n/**\n * Stop words are very common (e.g. \"a\", \"and\", \"the\") and are often not semantically meaningful in the context of a\n * search. This tokenizer removes stop words from a set of tokens before passing the remaining tokens along for\n * indexing or searching purposes.\n */\n\nvar StopWordsTokenizer = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  /**\n   * Constructor.\n   *\n   * @param decoratedIndexStrategy Index strategy to be run after all stop words have been removed.\n   */\n  function StopWordsTokenizer(decoratedTokenizer) {\n    this._tokenizer = decoratedTokenizer;\n  }\n  /**\n   * @inheritDocs\n   */\n\n  var _proto = StopWordsTokenizer.prototype;\n  _proto.tokenize = function tokenize(text) {\n    return this._tokenizer.tokenize(text).filter(function (token) {\n      return !StopWordsMap[token];\n    });\n  };\n  return StopWordsTokenizer;\n}()));\nfunction js_search_defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction js_search_createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) js_search_defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) js_search_defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * Simple client-side searching within a set of documents.\n *\n * <p>Documents can be searched by any number of fields. Indexing and search strategies are highly customizable.\n */\nvar Search = /*#__PURE__*/function () {\n  /**\n   * Array containing either a property name or a path (list of property names) to a nested value\n   */\n\n  /**\n   * Constructor.\n   * @param uidFieldName Field containing values that uniquely identify search documents; this field's values are used\n   *                     to ensure that a search result set does not contain duplicate objects.\n   */\n  function Search(uidFieldName) {\n    if (!uidFieldName) {\n      throw Error('js-search requires a uid field name constructor parameter');\n    }\n    this._uidFieldName = uidFieldName; // Set default/recommended strategies\n\n    this._indexStrategy = new PrefixIndexStrategy();\n    this._searchIndex = new TfIdfSearchIndex(uidFieldName);\n    this._sanitizer = new LowerCaseSanitizer();\n    this._tokenizer = new SimpleTokenizer();\n    this._documents = [];\n    this._searchableFields = [];\n  }\n  /**\n   * Override the default index strategy.\n   * @param value Custom index strategy\n   * @throws Error if documents have already been indexed by this search instance\n   */\n\n  var _proto = Search.prototype;\n\n  /**\n   * Add a searchable document to the index. Document will automatically be indexed for search.\n   * @param document\n   */\n  _proto.addDocument = function addDocument(document) {\n    this.addDocuments([document]);\n  }\n  /**\n   * Adds searchable documents to the index. Documents will automatically be indexed for search.\n   * @param document\n   */;\n  _proto.addDocuments = function addDocuments(documents) {\n    this._documents = this._documents.concat(documents);\n    this.indexDocuments_(documents, this._searchableFields);\n  }\n  /**\n   * Add a new searchable field to the index. Existing documents will automatically be indexed using this new field.\n   *\n   * @param field Searchable field or field path. Pass a string to index a top-level field and an array of strings for nested fields.\n   */;\n  _proto.addIndex = function addIndex(field) {\n    this._searchableFields.push(field);\n    this.indexDocuments_(this._documents, [field]);\n  }\n  /**\n   * Search all documents for ones matching the specified query text.\n   * @param query\n   * @returns {Array<Object>}\n   */;\n  _proto.search = function search(query) {\n    var tokens = this._tokenizer.tokenize(this._sanitizer.sanitize(query));\n    return this._searchIndex.search(tokens, this._documents);\n  }\n  /**\n   * @param documents\n   * @param _searchableFields Array containing property names and paths (lists of property names) to nested values\n   * @private\n   */;\n  _proto.indexDocuments_ = function indexDocuments_(documents, _searchableFields) {\n    this._initialized = true;\n    var indexStrategy = this._indexStrategy;\n    var sanitizer = this._sanitizer;\n    var searchIndex = this._searchIndex;\n    var tokenizer = this._tokenizer;\n    var uidFieldName = this._uidFieldName;\n    for (var di = 0, numDocuments = documents.length; di < numDocuments; di++) {\n      var doc = documents[di];\n      var uid;\n      if (uidFieldName instanceof Array) {\n        uid = getNestedFieldValue(doc, uidFieldName);\n      } else {\n        uid = doc[uidFieldName];\n      }\n      for (var sfi = 0, numSearchableFields = _searchableFields.length; sfi < numSearchableFields; sfi++) {\n        var fieldValue;\n        var searchableField = _searchableFields[sfi];\n        if (searchableField instanceof Array) {\n          fieldValue = getNestedFieldValue(doc, searchableField);\n        } else {\n          fieldValue = doc[searchableField];\n        }\n        if (fieldValue != null && typeof fieldValue !== 'string' && fieldValue.toString) {\n          fieldValue = fieldValue.toString();\n        }\n        if (typeof fieldValue === 'string') {\n          var fieldTokens = tokenizer.tokenize(sanitizer.sanitize(fieldValue));\n          for (var fti = 0, numFieldValues = fieldTokens.length; fti < numFieldValues; fti++) {\n            var fieldToken = fieldTokens[fti];\n            var expandedTokens = indexStrategy.expandToken(fieldToken);\n            for (var eti = 0, nummExpandedTokens = expandedTokens.length; eti < nummExpandedTokens; eti++) {\n              var expandedToken = expandedTokens[eti];\n              searchIndex.indexDocument(expandedToken, uid, doc);\n            }\n          }\n        }\n      }\n    }\n  };\n  js_search_createClass(Search, [{\n    key: \"indexStrategy\",\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('IIndexStrategy cannot be set after initialization');\n      }\n      this._indexStrategy = value;\n    },\n    get: function get() {\n      return this._indexStrategy;\n    }\n    /**\n     * Override the default text sanitizing strategy.\n     * @param value Custom text sanitizing strategy\n     * @throws Error if documents have already been indexed by this search instance\n     */\n  }, {\n    key: \"sanitizer\",\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('ISanitizer cannot be set after initialization');\n      }\n      this._sanitizer = value;\n    },\n    get: function get() {\n      return this._sanitizer;\n    }\n    /**\n     * Override the default search index strategy.\n     * @param value Custom search index strategy\n     * @throws Error if documents have already been indexed\n     */\n  }, {\n    key: \"searchIndex\",\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('ISearchIndex cannot be set after initialization');\n      }\n      this._searchIndex = value;\n    },\n    get: function get() {\n      return this._searchIndex;\n    }\n    /**\n     * Override the default text tokenizing strategy.\n     * @param value Custom text tokenizing strategy\n     * @throws Error if documents have already been indexed by this search instance\n     */\n  }, {\n    key: \"tokenizer\",\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('ITokenizer cannot be set after initialization');\n      }\n      this._tokenizer = value;\n    },\n    get: function get() {\n      return this._tokenizer;\n    }\n  }]);\n  return Search;\n}();\n\n/**\n * This utility highlights the occurrences of tokens within a string of text. It can be used to give visual indicators\n * of match criteria within searchable fields.\n *\n * <p>For performance purposes this highlighter only works with full-word or prefix token indexes.\n */\nvar TokenHighlighter = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  /**\n   * Constructor.\n   *\n   * @param opt_indexStrategy Index strategy used by Search\n   * @param opt_sanitizer Sanitizer used by Search\n   * @param opt_wrapperTagName Optional wrapper tag name; defaults to 'mark' (e.g. <mark>)\n   */\n  function TokenHighlighter(opt_indexStrategy, opt_sanitizer, opt_wrapperTagName) {\n    this._indexStrategy = opt_indexStrategy || new PrefixIndexStrategy();\n    this._sanitizer = opt_sanitizer || new LowerCaseSanitizer();\n    this._wrapperTagName = opt_wrapperTagName || 'mark';\n  }\n  /**\n   * Highlights token occurrences within a string by wrapping them with a DOM element.\n   *\n   * @param text e.g. \"john wayne\"\n   * @param tokens e.g. [\"wa\"]\n   * @returns {string} e.g. \"john <mark>wa</mark>yne\"\n   */\n\n  var _proto = TokenHighlighter.prototype;\n  _proto.highlight = function highlight(text, tokens) {\n    var tagsLength = this._wrapText('').length;\n    var tokenDictionary = Object.create(null); // Create a token map for easier lookup below.\n\n    for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n      var token = this._sanitizer.sanitize(tokens[i]);\n      var expandedTokens = this._indexStrategy.expandToken(token);\n      for (var j = 0, numExpandedTokens = expandedTokens.length; j < numExpandedTokens; j++) {\n        var expandedToken = expandedTokens[j];\n        if (!tokenDictionary[expandedToken]) {\n          tokenDictionary[expandedToken] = [token];\n        } else {\n          tokenDictionary[expandedToken].push(token);\n        }\n      }\n    } // Track actualCurrentWord and sanitizedCurrentWord separately in case we encounter nested tags.\n\n    var actualCurrentWord = '';\n    var sanitizedCurrentWord = '';\n    var currentWordStartIndex = 0; // Note this assumes either prefix or full word matching.\n\n    for (var i = 0, textLength = text.length; i < textLength; i++) {\n      var character = text.charAt(i);\n      if (character === ' ') {\n        actualCurrentWord = '';\n        sanitizedCurrentWord = '';\n        currentWordStartIndex = i + 1;\n      } else {\n        actualCurrentWord += character;\n        sanitizedCurrentWord += this._sanitizer.sanitize(character);\n      }\n      if (tokenDictionary[sanitizedCurrentWord] && tokenDictionary[sanitizedCurrentWord].indexOf(sanitizedCurrentWord) >= 0) {\n        actualCurrentWord = this._wrapText(actualCurrentWord);\n        text = text.substring(0, currentWordStartIndex) + actualCurrentWord + text.substring(i + 1);\n        i += tagsLength;\n        textLength += tagsLength;\n      }\n    }\n    return text;\n  }\n  /**\n   * @param text to wrap\n   * @returns Text wrapped by wrapper tag (e.g. \"foo\" becomes \"<mark>foo</mark>\")\n   * @private\n   */;\n  _proto._wrapText = function _wrapText(text) {\n    var tagName = this._wrapperTagName;\n    return \"<\" + tagName + \">\" + text + \"</\" + tagName + \">\";\n  };\n  return TokenHighlighter;\n}()));\n\n;// ./src/components/MapSearchMessage/MapSearchMessage.module.scss\n// extracted by mini-css-extract-plugin\nvar hideMessage = \"MapSearchMessage-module--hideMessage--9LOUu\";\nvar showMessage = \"MapSearchMessage-module--showMessage--eatMu\";\n;// ./src/components/MapSearchMessage/MapSearchMessage.tsx\n;const MapSearchMessage=_ref=>{let{isSearchResultsNull}=_ref;const intl=(0,gatsby_plugin_intl.useIntl)();return/*#__PURE__*/react.createElement(\"div\",{className:isSearchResultsNull?showMessage:hideMessage},intl.formatMessage(explore/* MAP */.lC.SEARCH_RESULTS_EMPTY_MESSAGE));};/* harmony default export */ var MapSearchMessage_MapSearchMessage = (MapSearchMessage);\n;// ./src/components/MapSearchMessage/index.tsx\n/* harmony default export */ var components_MapSearchMessage = (MapSearchMessage_MapSearchMessage);\n;// ./src/components/MapSearch/MapSearch.module.scss\n// extracted by mini-css-extract-plugin\n\n;// ./src/components/MapSearch/MapSearch.tsx\n/* eslint-disable max-len */const MapSearch=_ref=>{let{goToPlace}=_ref;// State to hold if the search results are empty or not:\nconst{0:isSearchResultsNull,1:setIsSearchResultsNull}=(0,react.useState)(false);const intl=(0,gatsby_plugin_intl.useIntl)();/**\n   * At compile-time, the width/height returned by useWindowSize will be X. When the client requests the\n   * app on run-time from CDN, and the app hydrates, reconcilation no longer occurs and the client is forced\n   * to use X.\n   *\n   * To avoid this, we set the placeholder text as a state variable. We also create a useEffect that updates\n   * that state whenenver the width changes.\n   *\n   */const{width,height}=(0,useWindowSize/* default */.A)();const{0:placeholderText,1:setPlaceholderText}=(0,react.useState)(explore/* MAP */.lC.SEARCH_PLACEHOLDER);const{0:tractSearch,1:setTractSearch}=(0,react.useState)(null);/**\n   * Gets the tract search data and loads in the state.\n   */const getTractSearchData=async()=>{const searchDataUrl=`${constants/* TILE_BASE_URL */.RST}/${constants/* MAP_TRACT_SEARCH_PATH */.lsl}`;fetch(searchDataUrl).then(response=>{if(response.ok){return response.json();}else{throw new Error(`${response.statusText} error with status code of ${response.status}`);}}).then(data=>{// We use JsSearch to make it easy to load and quick to search.\nconst search=new Search('GEOID10');search.indexStrategy=new ExactWordIndexStrategy();search.addIndex('GEOID10');search.addDocuments(data);setTractSearch(search);}).catch(error=>console.error('Unable to read search tract table:',error));};(0,react.useEffect)(()=>{width>height?setPlaceholderText(explore/* MAP */.lC.SEARCH_PLACEHOLDER):setPlaceholderText(explore/* MAP */.lC.SEARCH_PLACEHOLDER_MOBILE);},[width]);(0,react.useEffect)(()=>{getTractSearchData();},[]);/**\n   * Searchs for a given Census tract ID.\n   * @param {string} tract the 11 digit tract ID as a string\n   */const searchForTract=async tract=>{// We create a bounding box just to get the tract in the view box.\n// The size is not important.\nconst BOUNDING_BOX_SIZE_DD=0.2;// Convert 10 digit tracts to 11.\nconst normalizedTractId=tract.length==10?'0'+tract:tract;setIsSearchResultsNull(true);if(tractSearch){const result=tractSearch.search(normalizedTractId);if(result.length>0){const searchTractRecord=result[0];const lat=Number(searchTractRecord.INTPTLAT10);const lon=Number(searchTractRecord.INTPTLON10);const boundingBox=[(lat-BOUNDING_BOX_SIZE_DD/2).toString(),(lat+BOUNDING_BOX_SIZE_DD/2).toString(),(lon-BOUNDING_BOX_SIZE_DD/2).toString(),(lon+BOUNDING_BOX_SIZE_DD/2).toString()];const[latMin,latMax,longMin,longMax]=boundingBox;setIsSearchResultsNull(false);// Now move the map and select the tract.\ngoToPlace([[Number(longMin),Number(latMin)],[Number(longMax),Number(latMax)]],false,normalizedTractId);}}};/**\n   * Searchs for a given location such as address, zip, etc. This method will\n   * will fetch data from the PSM API and return the results as JSON and\n   * results to US only. If the data is valid, destructure the boundingBox\n   * values from the search results. Finally, is pans the map to the location.\n   * @param {string} searchTerm the location to search for\n   */const searchForLocation=async searchTerm=>{const searchResults=await fetch(`https://nominatim.openstreetmap.org/search?q=${searchTerm}&format=json&countrycodes=us`,{mode:'cors'}).then(response=>{if(!response.ok){throw new Error('Network response was not OK');}return response.json();}).catch(error=>{console.error('There has been a problem with your fetch operation:',error);});console.log('Nominatum search results: ',searchResults);// If results are valid, set isSearchResultsNull to false and pan map to location:\nif(searchResults&&searchResults.length>0){setIsSearchResultsNull(false);const[latMin,latMax,longMin,longMax]=searchResults[0].boundingbox;goToPlace([[Number(longMin),Number(latMin)],[Number(longMax),Number(latMax)]],false,undefined);}else{setIsSearchResultsNull(true);}};/**\n    Searches for a given search term upon clicking on the search button.\n    @param {React.FormEvent<HTMLFormElement>} event the click event\n  */const onSearchHandler=async event=>{event.preventDefault();event.stopPropagation();const searchTerm=event.currentTarget.elements.namedItem('search').value;// If the search term a Census tract\nconst isTract=/^\\d{10,11}$/.test(searchTerm);if(isTract){searchForTract(searchTerm);}else{searchForLocation(searchTerm);}};return/*#__PURE__*/react.createElement(\"div\",{className:MapSearch_module_namespaceObject.mapSearchContainer},/*#__PURE__*/react.createElement(components_MapSearchMessage,{isSearchResultsNull:isSearchResultsNull}),/*#__PURE__*/react.createElement(lib.Search,{placeholder:intl.formatMessage(placeholderText),size:\"small\",onSubmit:e=>onSearchHandler(e)}));};/* harmony default export */ var MapSearch_MapSearch = (MapSearch);\n;// ./src/components/MapSearch/index.tsx\n/* harmony default export */ var components_MapSearch = (MapSearch_MapSearch);\n// EXTERNAL MODULE: ./src/data/copy/common.tsx + 3 modules\nvar common = __webpack_require__(5635);\n;// ./src/components/MapTractLayers/MapTractLayers.tsx\n// Contexts:\n/**\n * This function will determine the URL for the map tiles. It will read in a string that will designate either\n * high or low tiles. It will allow to overide the URL to the pipeline staging tile URL via feature flag.\n * Lastly, it allows to set the tiles to be local or via the CDN as well.\n *\n * @param {string} tilesetName\n * @return {string}\n */const featureURLForTilesetName=tilesetName=>{const flags=(0,FlagContext/* useFlags */.D0)();const pipelineStagingBaseURL=\"https://static-data-screeningtool.geoplatform.gov\"+`/data-pipeline-staging`;const XYZ_SUFFIX='{z}/{x}/{y}.pbf';if('stage_hash'in flags){// Check if the stage_hash is valid\nconst regex=/^[0-9]{4}\\/[a-f0-9]{40}$/;if(!regex.test(flags['stage_hash'])){console.error(common/* CONSOLE_ERROR */.b6.STAGE_URL);}return`${pipelineStagingBaseURL}/${flags['stage_hash']}/data/score/tiles/${tilesetName}/${XYZ_SUFFIX}`;}else{// The feature tile base URL and path can either point locally or the CDN.\n// This is selected based on the DATA_SOURCE env variable.\nconst featureTileBaseURL=constants/* TILE_BASE_URL */.RST;const featureTilePath=constants/* TILE_PATH */.Jau;return[featureTileBaseURL,featureTilePath,\"tiles\",tilesetName,XYZ_SUFFIX].join('/');}};/**\n * This component will return the appropriate source and layers for the census layer on the\n * map.\n *\n * There are two use cases here, eg, when the MapBox token is or isn't provided. When the token\n * is not provided, the open-source map will be rendered. When the open-source map is rendered\n * only the interactive layers are returned from this component. The reason being is that the\n * other layers are supplied by he getOSBaseMap function.\n *\n * @param {string | number} selectedFeatureId\n * @param {MapGeoJSONFeature | undefined} selectedFeature\n * @return {Style}\n */const MapTractLayers=_ref=>{let{selectedFeatures}=_ref;const selectedFeatureIds=selectedFeatures?selectedFeatures.map(feat=>feat.id):[''];const filter=['in',constants/* GEOID_PROPERTY */.TnO].concat((0,toConsumableArray/* default */.A)(selectedFeatureIds));return/*#__PURE__*/react.createElement(react.Fragment,null,/*#__PURE__*/react.createElement(source,{id:constants/* LOW_ZOOM_SOURCE_NAME */.LQt,type:\"vector\",promoteId:constants/* GEOID_PROPERTY */.TnO,tiles:[featureURLForTilesetName('low')],maxzoom:constants/* GLOBAL_MAX_ZOOM_LOW */.Gb5,minzoom:constants/* GLOBAL_MIN_ZOOM_LOW */.gD2},/*#__PURE__*/react.createElement(components_layer,{id:constants/* LOW_ZOOM_LAYER_ID */.v39,\"source-layer\":constants/* SCORE_SOURCE_LAYER */.ZG$,filter:['>',constants/* SCORE_PROPERTY_LOW */.UsB,constants/* SCORE_BOUNDARY_THRESHOLD */.y2s],type:\"fill\",paint:{'fill-color':constants/* PRIORITIZED_FEATURE_FILL_COLOR */.HOT,'fill-opacity':constants/* LOW_ZOOM_PRIORITIZED_FEATURE_FILL_OPACITY */.wAO},maxzoom:constants/* GLOBAL_MAX_ZOOM_LOW */.Gb5,minzoom:constants/* GLOBAL_MIN_ZOOM_LOW */.gD2})),/*#__PURE__*/react.createElement(source,{id:constants/* HIGH_ZOOM_SOURCE_NAME */.NP7,type:\"vector\",promoteId:constants/* GEOID_PROPERTY */.TnO,tiles:[featureURLForTilesetName('high')],maxzoom:constants/* GLOBAL_MAX_ZOOM_HIGH */._yN,minzoom:constants/* GLOBAL_MIN_ZOOM_HIGH */.uDw},/*#__PURE__*/react.createElement(components_layer,{id:constants/* HIGH_ZOOM_LAYER_ID */.jt_,\"source-layer\":constants/* SCORE_SOURCE_LAYER */.ZG$,filter:['==',constants/* SCORE_PROPERTY_HIGH */.YfI,false],type:\"fill\",paint:{'fill-opacity':constants/* NON_PRIORITIZED_FEATURE_FILL_OPACITY */.XP8},minzoom:constants/* GLOBAL_MIN_ZOOM_HIGH */.uDw}),/*#__PURE__*/react.createElement(components_layer,{id:constants/* PRIORITIZED_HIGH_ZOOM_LAYER_ID */.nHu,\"source-layer\":constants/* SCORE_SOURCE_LAYER */.ZG$,filter:['==',constants/* SCORE_PROPERTY_HIGH */.YfI,true],type:\"fill\",paint:{'fill-color':constants/* PRIORITIZED_FEATURE_FILL_COLOR */.HOT,'fill-opacity':constants/* HIGH_ZOOM_PRIORITIZED_FEATURE_FILL_OPACITY */.GrS},minzoom:constants/* GLOBAL_MIN_ZOOM_HIGH */.uDw}),/*#__PURE__*/react.createElement(components_layer,{id:constants/* GRANDFATHERED_HIGH_ZOOM_LAYER_ID */.J1r,\"source-layer\":constants/* SCORE_SOURCE_LAYER */.ZG$,filter:['==',constants/* IS_GRANDFATHERED */.fgy,true],type:\"fill\",paint:{'fill-color':constants/* GRANDFATHERED_FEATURE_FILL_COLOR */.NUZ,'fill-opacity':constants/* HIGH_ZOOM_PRIORITIZED_FEATURE_FILL_OPACITY */.GrS},minzoom:constants/* GLOBAL_MIN_ZOOM_HIGH */.uDw}),/*#__PURE__*/react.createElement(components_layer,{id:constants/* FEATURE_BORDER_LAYER_ID */.ESF,\"source-layer\":constants/* SCORE_SOURCE_LAYER */.ZG$,type:\"line\",paint:{'line-color':constants/* FEATURE_BORDER_COLOR */.IND,'line-width':constants/* FEATURE_BORDER_WIDTH */.n_R,'line-opacity':constants/* FEATURE_BORDER_OPACITY */.IkD},maxzoom:constants/* GLOBAL_MAX_ZOOM_FEATURE_BORDER */.Hvn,minzoom:constants/* GLOBAL_MIN_ZOOM_FEATURE_BORDER */.xvi}),/*#__PURE__*/react.createElement(components_layer,{id:constants/* SELECTED_FEATURE_BORDER_LAYER_ID */.oUX,\"source-layer\":constants/* SCORE_SOURCE_LAYER */.ZG$,filter:filter// This filter filters out all other features except the selected feature.\n,type:\"line\",paint:{'line-color':constants/* SELECTED_FEATURE_BORDER_COLOR */.Ckd,'line-width':constants/* SELECTED_FEATURE_BORDER_WIDTH */.NXr},minzoom:constants/* GLOBAL_MIN_ZOOM_HIGH */.uDw})));};/* harmony default export */ var MapTractLayers_MapTractLayers = (MapTractLayers);\n;// ./src/components/MapTribalLayers/MapTribalLayers.tsx\n/**\n * This function will determine the URL for the tribal tiles.\n * @return {string}\n */const tribalURL=()=>{const featureTileBaseURL=constants/* TILE_BASE_URL */.RST;const featureTilePath=constants/* GATSBY_DATA_PIPELINE_TRIBAL_PATH */.In6;const XYZ_SUFFIX='{z}/{x}/{y}.pbf';return[featureTileBaseURL,featureTilePath,\"tiles\",XYZ_SUFFIX].join('/');};/**\n * This component will return the appropriate source and layers for the tribal layer on the\n * map.\n *\n * There are two use cases here, eg, when the MapBox token is or isn't provided. When the token\n * is not provided, the open-source map will be rendered. When the open-source map is rendered\n * only the interactive layers are returned from this component. The reason being is that the\n * other layers are supplied by he getOSBaseMap function.\n *\n * @param {string | number} selectedFeatureId\n * @param {MapGeoJSONFeature | undefined} selectedFeature\n * @return {Style}\n */const MapTribalLayer=()=>{return(/*#__PURE__*/// In this case the MapBox token is found and ALL source(s)/layer(s) are returned.\nreact.createElement(source,{id:constants/* TRIBAL_SOURCE_NAME */.VFt,type:\"vector\",promoteId:constants/* TRIBAL_ID */.BtP,tiles:[tribalURL()]},/*#__PURE__*/react.createElement(components_layer,{id:constants/* TRIBAL_LAYER_ID */.jL2,\"source-layer\":constants/* TRIBAL_SOURCE_LAYER */.Fa3,type:\"fill\",paint:{'fill-color':constants/* PRIORITIZED_FEATURE_FILL_COLOR */.HOT,'fill-opacity':constants/* TRIBAL_FEATURE_FILL_OPACITY */.gWm},minzoom:constants/* TRIBAL_MIN_ZOOM */.o1R,maxzoom:constants/* TRIBAL_MAX_ZOOM */.IWD}),/*#__PURE__*/react.createElement(components_layer,{id:constants/* FEATURE_BORDER_LAYER_ID */.ESF,\"source-layer\":constants/* TRIBAL_SOURCE_LAYER */.Fa3,type:\"line\",paint:{'line-color':constants/* FEATURE_BORDER_COLOR */.IND,'line-width':constants/* FEATURE_BORDER_WIDTH */.n_R,'line-opacity':constants/* FEATURE_BORDER_OPACITY */.IkD},minzoom:constants/* TRIBAL_MIN_ZOOM */.o1R,maxzoom:constants/* TRIBAL_MAX_ZOOM */.IWD}),/*#__PURE__*/react.createElement(components_layer,{id:constants/* TRIBAL_ALASKA_POINTS_LAYER_ID */.$mQ,\"source-layer\":constants/* TRIBAL_SOURCE_LAYER */.Fa3,filter:['==',['geometry-type'],'Point'],type:\"circle\",paint:{'circle-radius':constants/* TRIBAL_ALASKA_CIRCLE_RADIUS */.Zj6,'circle-color':constants/* TRIBAL_ALASKA_CIRCLE_FILL_COLOR */.Mth,'circle-opacity':constants/* TRIBAL_FEATURE_FILL_OPACITY */.gWm,'circle-stroke-color':constants/* TRIBAL_BORDER_COLOR */.EFx,'circle-stroke-width':constants/* ALAKSA_POINTS_STROKE_WIDTH */.mIl,'circle-stroke-opacity':constants/* FEATURE_BORDER_OPACITY */.IkD},minzoom:constants/* ALASKA_MIN_ZOOM */.DgY,maxzoom:constants/* ALASKA_MAX_ZOOM */.L9E}),/*#__PURE__*/react.createElement(components_layer,{id:constants/* TRIBAL_LABELS_LAYER_ID */.paD,\"source-layer\":constants/* TRIBAL_SOURCE_LAYER */.Fa3,type:\"symbol\",layout:{'text-field':['case',['in',' LAR',['get',constants/* LAND_AREA_NAME */.M2L]],['slice',['get',constants/* LAND_AREA_NAME */.M2L],0,['-',['length',['get',constants/* LAND_AREA_NAME */.M2L]],4]],['in',' IRA',['get',constants/* LAND_AREA_NAME */.M2L]],['slice',['get',constants/* LAND_AREA_NAME */.M2L],0,['-',['length',['get',constants/* LAND_AREA_NAME */.M2L]],4]],['in',' TSA',['get',constants/* LAND_AREA_NAME */.M2L]],['slice',['get',constants/* LAND_AREA_NAME */.M2L],0,['-',['length',['get',constants/* LAND_AREA_NAME */.M2L]],4]],['get',constants/* LAND_AREA_NAME */.M2L]],'text-anchor':'top','text-offset':[0,1],'text-size':12,'text-allow-overlap':false,'text-ignore-placement':false},paint:{'text-color':'#333333','text-halo-color':'#FFFFFF','text-halo-width':1.5},minzoom:constants/* TRIBAL_MIN_ZOOM */.o1R,maxzoom:constants/* TRIBAL_MAX_ZOOM */.IWD})));};/* harmony default export */ var MapTribalLayers = (MapTribalLayer);\n;// ./src/components/territoryFocusControl.module.scss\n// extracted by mini-css-extract-plugin\nvar territoryFocusContainer = \"territoryFocusControl-module--territoryFocusContainer--X5A14\";\n;// ./src/components/territoryFocusControl.tsx\nconst TerritoryFocusControl=_ref=>{let{onClick}=_ref;const intl=(0,gatsby_plugin_intl.useIntl)();const territories=[{short:intl.formatMessage(explore/* MAP */.lC.LOWER48_SHORT),long:intl.formatMessage(explore/* MAP */.lC.LOWER48_LONG)},{short:intl.formatMessage(explore/* MAP */.lC.ALASKA_SHORT),long:intl.formatMessage(explore/* MAP */.lC.ALASKA_LONG)},{short:intl.formatMessage(explore/* MAP */.lC.HAWAII_SHORT),long:intl.formatMessage(explore/* MAP */.lC.HAWAII_LONG)},{short:intl.formatMessage(explore/* MAP */.lC.PR_SHORT),long:intl.formatMessage(explore/* MAP */.lC.PR_LONG)},{short:intl.formatMessage(explore/* MAP */.lC.GU_SHORT),long:intl.formatMessage(explore/* MAP */.lC.GU_LONG)},{short:intl.formatMessage(explore/* MAP */.lC.AS_SHORT),long:intl.formatMessage(explore/* MAP */.lC.AS_LONG)},{short:intl.formatMessage(explore/* MAP */.lC.MP_SHORT),long:intl.formatMessage(explore/* MAP */.lC.MP_LONG)},{short:intl.formatMessage(explore/* MAP */.lC.VI_SHORT),long:intl.formatMessage(explore/* MAP */.lC.VI_LONG)}];// the offset for this array should map the territories variable\nconst territoriesIconClassName=['mapboxgl-ctrl-zoom-to-48','mapboxgl-ctrl-zoom-to-ak','mapboxgl-ctrl-zoom-to-hi','mapboxgl-ctrl-zoom-to-pr','mapboxgl-ctrl-zoom-to-gu','mapboxgl-ctrl-zoom-to-as','mapboxgl-ctrl-zoom-to-mp','mapboxgl-ctrl-zoom-to-vi'];return/*#__PURE__*/react.createElement(\"div\",{className:territoryFocusContainer},/*#__PURE__*/react.createElement(\"div\",{className:'mapboxgl-ctrl mapboxgl-ctrl-group'},territories.map((territory,index)=>/*#__PURE__*/react.createElement(\"button\",{id:territory.short,key:territory.short// onClickCapture={(e) => onClickTerritoryFocusButton(e)}\n,onClickCapture:e=>onClick(e),className:'mapboxgl-ctrl-icon '+territoriesIconClassName[index],title:territories[index].long,\"aria-label\":intl.formatMessage({id:'map.territoryFocus.focusOn',defaultMessage:'Focus on {territory}',description:'Focus on the bounds of a specific territory'},{territory:territory.long})},/*#__PURE__*/react.createElement(\"span\",{className:'mapboxgl-ctrl-icon',\"aria-hidden\":true})))));};/* harmony default export */ var territoryFocusControl = (TerritoryFocusControl);\n;// ./src/components/J40Map.module.scss\n// extracted by mini-css-extract-plugin\nvar fullscreenControl = \"J40Map-module--fullscreenControl--gbYO0\";\nvar geolocateBox = \"J40Map-module--geolocateBox--5HnSE\";\nvar geolocateMessage = \"J40Map-module--geolocateMessage--jD1GP\";\nvar geolocateMessageHide = \"J40Map-module--geolocateMessageHide--MU8Bz\";\nvar j40Map = \"J40Map-module--j40Map--DFr6E\";\nvar j40Popup = \"J40Map-module--j40Popup--KLpXL\";\nvar mapHeaderRow = \"J40Map-module--mapHeaderRow--+ctO-\";\nvar J40Map_module_mapInfoPanel = \"J40Map-module--mapInfoPanel--WdI9e\";\nvar navigationControl = \"J40Map-module--navigationControl--6uUM7\";\n;// ./src/components/CreateReportPanel/CreateReportPanel.module.scss\n// extracted by mini-css-extract-plugin\nvar createReportButton = \"CreateReportPanel-module--createReportButton--+Usds\";\nvar createReportContainer = \"CreateReportPanel-module--createReportContainer--yFj9z\";\nvar startOver = \"CreateReportPanel-module--startOver--9sZuS\";\nvar tractListContainer = \"CreateReportPanel-module--tractListContainer--o2ner\";\nvar tractListItem = \"CreateReportPanel-module--tractListItem--JMCb4\";\nvar tractListItemDelete = \"CreateReportPanel-module--tractListItemDelete--BS88W\";\nvar tractListItemHighlight = \"CreateReportPanel-module--tractListItemHighlight--nxXly\";\n;// ./node_modules/uswds/dist/img/usa-icons/close.svg\n/* harmony default export */ var usa_icons_close = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE5IDYuNDFMMTcuNTkgNSAxMiAxMC41OSA2LjQxIDUgNSA2LjQxIDEwLjU5IDEyIDUgMTcuNTkgNi40MSAxOSAxMiAxMy40MSAxNy41OSAxOSAxOSAxNy41OSAxMy40MSAxMnoiLz48L3N2Zz4=\");\n;// ./src/components/CreateReportPanel/CreateReportPanel.tsx\n// @ts-ignore\nconst CreateReportPanel=_ref=>{let{className,featureList,maxNumTracts,showTooManyTractsAlert,deleteTractHandler,exitHandler}=_ref;const{0:numPrevTracts,1:setNumPrevTracts}=(0,react.useState)(0);(0,react.useEffect)(()=>{// If adding a tract then scroll to the bottom of the tract list to always show the last added tract\nif(numPrevTracts<featureList.length){const container=document.getElementById('j40-create-report-tract-list');if(container)container.scrollTop=container.scrollHeight;}setNumPrevTracts(featureList.length);},[featureList,numPrevTracts]);/**\n   * Handle the creation of a report.\n   */const handleCreateReport=()=>{if(featureList.length===1){// TODO: One tract report\n}else{// TODO: Multi tract report\n}};return/*#__PURE__*/react.createElement(\"div\",{id:\"create-report-panel\",className:className},/*#__PURE__*/react.createElement(\"div\",{className:createReportContainer},/*#__PURE__*/react.createElement(\"h4\",null,\"Create Report\"),showTooManyTractsAlert?/*#__PURE__*/react.createElement(lib.Alert,{type:\"error\",slim:true,headingLevel:\"h4\"},\"You can only select up to \",maxNumTracts,\" tracts for a report.\"):/*#__PURE__*/react.createElement(lib.Alert,{type:\"info\",slim:true,headingLevel:\"h4\"},\"Select \",/*#__PURE__*/react.createElement(\"strong\",null,\"up to \",maxNumTracts),\" tracts in the map\"),/*#__PURE__*/react.createElement(\"p\",null,/*#__PURE__*/react.createElement(\"span\",null,/*#__PURE__*/react.createElement(\"strong\",null,featureList.length,\" tract\",featureList.length===1?'':'s'),\" selected\")),/*#__PURE__*/react.createElement(\"div\",{id:\"j40-create-report-tract-list\",className:tractListContainer},featureList.map((item,index)=>/*#__PURE__*/react.createElement(lib.Grid,{row:true,key:index,className:index===featureList.length-1?tractListItemHighlight:tractListItem},/*#__PURE__*/react.createElement(lib.Grid,{col:\"auto\"},item.id,\", \",item.properties[constants/* STATE_NAME */.sfg]),/*#__PURE__*/react.createElement(lib.Grid,{col:\"fill\"}),/*#__PURE__*/react.createElement(lib.Grid,{col:\"auto\",className:tractListItemDelete},/*#__PURE__*/react.createElement(lib.Button,{type:\"button\",unstyled:true,onClick:()=>deleteTractHandler(item)},/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,src:usa_icons_close,alt:\"Need alt message\"})))))),/*#__PURE__*/react.createElement(\"div\",{className:createReportButton},/*#__PURE__*/react.createElement(lib.Button,{type:\"button\",onClick:handleCreateReport,disabled:featureList.length==0},\"Create Report\")),/*#__PURE__*/react.createElement(\"div\",{className:startOver},/*#__PURE__*/react.createElement(lib.Button,{type:\"button\",unstyled:true,onClick:exitHandler},\"Start Over\"))));};/* harmony default export */ var CreateReportPanel_CreateReportPanel = (CreateReportPanel);\n;// ./src/components/CreateReportPanel/index.tsx\n/* harmony default export */ var components_CreateReportPanel = (CreateReportPanel_CreateReportPanel);\n;// ./src/components/J40Map.tsx\n/* eslint-disable valid-jsdoc *//* eslint-disable no-unused-vars */// External Libs:\n// Contexts:\n// Components:\n// Styles and constants\n;;const MAX_SELECTED_TRACTS=20;const J40Map=_ref=>{var _mapRef$current;let{location}=_ref;/**\n   * Initializes the zoom, and the map's center point (lat, lng) via the URL hash #{z}/{lat}/{long}\n   * where\n   *  @TODO: These values do not update when zooming in/out. Could explain a number of cypress bugs\n   *  reference to ticket #1550\n   *\n   *    z = zoom\n   *    lat = map center's latitude\n   *    long = map center's longitude\n   */const[zoom,lat,lng]=location.hash.slice(1).split('/');/**\n   * If the URL has no #{z}/{lat}/{long} specified in the hash, then set the map's intial viewport state\n   * to use constants. This is so that we can load URLs with certain zoom/lat/long specified:\n   */const{0:viewport,1:setViewport}=(0,react.useState)({latitude:lat&&parseFloat(lat)?parseFloat(lat):constants/* DEFAULT_CENTER */.IiY[0],longitude:lng&&parseFloat(lng)?parseFloat(lng):constants/* DEFAULT_CENTER */.IiY[1],zoom:zoom&&parseFloat(zoom)?parseFloat(zoom):constants/* GLOBAL_MIN_ZOOM */.xaE});const{0:selectedFeatures,1:setSelectedFeatures}=(0,react.useState)([]);const{0:detailViewData,1:setDetailViewData}=(0,react.useState)();const{0:transitionInProgress,1:setTransitionInProgress}=(0,react.useState)(false);const{0:geolocationInProgress,1:setGeolocationInProgress}=(0,react.useState)(false);const{0:isMobileMapState,1:setIsMobileMapState}=(0,react.useState)(false);const{0:inMultiSelectMode,1:setInMultiSelectMode}=(0,react.useState)(false);const{0:showTooManyTractsAlert,1:setShowTooManyTractsAlert}=(0,react.useState)(false);const{0:selectTractId,1:setSelectTractId}=(0,react.useState)(undefined);const{width:windowWidth}=(0,useWindowSize/* default */.A)();/**\n   * Store the geolocation lock state in local storage. The Geolocation component from MapBox does not\n   * expose (API) various geolocation lock/unlock states in the version we are using. This makes it\n   * challenging to change the UI state to match the Geolocation state. A work around is to store the\n   * geolocation \"locked\" state in local storage. The local storage state will then be used to show the\n   * \"Finding location\" message. The local storage will be removed everytime the map is reloaded.\n   *\n   * The \"Finding location\" message only applies for desktop layouts.\n   */// eslint-disable-next-line max-len\nconst[isGeolocateLocked,setIsGeolocateLocked,removeGeolocateLock]=esm_useLocalStorage('is-geolocate-locked',false,{raw:true});const mapRef=(0,react.useRef)(null);const flags=(0,FlagContext/* useFlags */.D0)();const intl=(0,gatsby_plugin_intl.useIntl)();const zoomLatLngHash=(_mapRef$current=mapRef.current)===null||_mapRef$current===void 0?void 0:_mapRef$current.getMap()._hash._getCurrentHash();/**\n   * Get the bounding box for one or more features.\n   * @param featureList the list of features\n   * @returns the bounding box\n   */const getFeaturesBbox=featureList=>{if(featureList.length===0){throw new Error('featureList must be a non-empty array to get a bounding box.');}// Calculate a max and min lat/lon from all the selected features.\nconst minLngList=[];const minLatList=[];const maxLngList=[];const maxLatList=[];featureList.forEach(feature=>{const[featMinLng,featMinLat,featMaxLng,featMaxLat]=es(feature);minLngList.push(featMinLng);minLatList.push(featMinLat);maxLngList.push(featMaxLng);maxLatList.push(featMaxLat);});const minLng=Math.min.apply(Math,minLngList);const minLat=Math.max.apply(Math,minLatList);const maxLng=Math.max.apply(Math,maxLngList);const maxLat=Math.min.apply(Math,maxLatList);return[minLng,minLat,maxLng,maxLat];};/**\n   * Updates the state with the list of selected features. This function will:\n   *   - Add the feature to the list if in multi select and the feature does not already exist\n   *   - Remove the feature from the list if in multi select and the feature does already exist\n   * @param feature the feature to add or remove\n   * @param isMultiSelect true if in multiselect mode\n   * @returns the list of zero or more features\n   */const updateSelectedFeatures=(feature,isMultiSelect)=>{if(!feature)return selectedFeatures;// If the feature is in the list then remove it as it is being deselected\nconst exists=selectedFeatures.some(item=>item.id===feature.id);let featureList=selectedFeatures;if(exists){featureList=selectedFeatures.filter(item=>item.id!==feature.id);setShowTooManyTractsAlert(false);}else if(selectedFeatures.length<MAX_SELECTED_TRACTS){// Add the feature to the list if in multi select, otherwise replace the list\n// with just this one feature.\nfeatureList=isMultiSelect?[].concat((0,toConsumableArray/* default */.A)(selectedFeatures),[feature]):[feature];}else{setShowTooManyTractsAlert(true);}setSelectedFeatures(featureList);if(!inMultiSelectMode){// Turn on multi select mode any time we select more than one tract.\nsetInMultiSelectMode(featureList.length>1);}return featureList;};/**\n   * Selects the provided feature on the map.\n   * @param feature the feature to select\n   * @param isMultiSelectKeyDown true if the multi select key is down\n   */const selectFeaturesOnMap=function(feature,isMultiSelectKeyDown){if(isMultiSelectKeyDown===void 0){isMultiSelectKeyDown=false;}const featuresList=updateSelectedFeatures(feature,isMultiSelectKeyDown||inMultiSelectMode);if(featuresList.length>0){const[minLng,minLat,maxLng,maxLat]=getFeaturesBbox(featuresList);// Go to area of the selected feature(s)\ngoToPlace([[minLng,minLat],[maxLng,maxLat]]);/**\n       * The following logic is used for the popup for the fullscreen feature\n       */// Create a new viewport using the current viewport dimnesions:\nconst newViewPort=new WebMercatorViewport({height:viewport.height,width:viewport.width});// Fit the viewport to the new bounds and return a long, lat and zoom:\nconst{longitude,latitude,zoom}=newViewPort.fitBounds([[minLng,minLat],[maxLng,maxLat]],{padding:40});// Save the popupInfo\nconst popupInfo={longitude:longitude,latitude:latitude,zoom:zoom,properties:feature.properties};// Update the DetailedView state variable with the new popupInfo object:\nsetDetailViewData(popupInfo);/**\n       * End Fullscreen feature specific logic\n       */}};/**\n * This onClick event handler will listen and handle clicks on the map. It will listen for clicks on the\n * territory controls and it will listen to clicks on the map.\n *\n * It will NOT listen to clicks into the search field or the zoom controls. These clickHandlers are\n * captured in their own respective components.\n */const onClick=event=>{var _stopPropagation,_ref2;// Stop all propagation / bubbling / capturing\nevent.preventDefault();(_stopPropagation=(_ref2=event).stopPropagation)===null||_stopPropagation===void 0?void 0:_stopPropagation.call(_ref2);// Check if the click is for territories. Given the territories component's design, it can be\n// guaranteed that each territory control will have an id. We use this ID to determine\n// if the click is coming from a territory control\nif(event.target&&event.target.id){const buttonID=event.target&&event.target.id;switch(buttonID){case'48':goToPlace(constants/* LOWER_48_BOUNDS */.z1R,true);break;case'AK':goToPlace(constants/* ALASKA_BOUNDS */.YnL,true);break;case'HI':goToPlace(constants/* HAWAII_BOUNDS */.snE,true);break;case'PR':goToPlace(constants/* PUERTO_RICO_BOUNDS */.cKu,true);break;case'GU':goToPlace(constants/* GUAM_BOUNDS */.hsW,true);break;case'AS':goToPlace(constants/* AMERICAN_SAMOA_BOUNDS */.Vih,true);break;case'MP':goToPlace(constants/* MARIANA_ISLAND_BOUNDS */.eSo,true);break;case'VI':goToPlace(constants/* US_VIRGIN_ISLANDS_BOUNDS */.qT,true);break;default:break;}}else if(event.target&&event.target.nodeName=='DIV'){// This else clause will fire when the user clicks on the map and will ignore other controls\n// such as the search box and buttons.\n// @ts-ignore\nconst feature=event.features&&event.features[0];// @ts-ignore\nselectFeaturesOnMap(feature,event.srcEvent.ctrlKey);}};const onLoad=()=>{if(typeof window!=='undefined'&&window.Cypress&&mapRef.current){window.underlyingMap=mapRef.current.getMap();}// When map loads remove the geolocate lock boolean in local storage\nremoveGeolocateLock();if(dist_lib/* isMobile */.Fr)setIsMobileMapState(true);};/**\n   * This function will move the map (with easing) to the given lat/long bounds.\n   *\n   * When a user clicks on a tracts vs a territory button, the zoom level returned by the fitBounds\n   * function differ. Given that we want to handle the zoom differently depending on these two cases, we\n   * introduce a boolean, isTerritory that will allow the zoom level to be set depending on what the user\n   * is interacting with, namely a tract vs a territory button.\n   *\n   * @param {LngLatBoundsLike} bounds\n   * @param {boolean} isTerritory\n   */const goToPlace=function(bounds,isTerritory,selectTractId){if(isTerritory===void 0){isTerritory=false;}if(selectTractId===void 0){selectTractId=undefined;}const newViewPort=new WebMercatorViewport({height:viewport.height,width:viewport.width});const{longitude,latitude,zoom}=newViewPort.fitBounds(bounds,{// padding: 200,  // removing padding and offset in favor of a zoom offset below\n// offset: [0, -100],\n});/**\n     * When some tracts are selected, they end up too far zoomed in, causing some census tracts to\n     * only show a portion of the tract in the viewport. We reduce the zoom level by 1 to allow\n     * more space around the selected tract.\n     *\n     * Given that the high zoom tiles only go to zoom level 5, if the corrected zoom level (zoom - 1) is\n     * less than MIN_ZOOM_FEATURE_BORDER, then we floor the zoom to MIN_ZOOM_FEATURE_BORDER + .1 (which\n     * is 5.1 as of this comment)\n     */// eslint-disable-next-line max-len\nconst featureSelectionZoomLevel=zoom-1<constants/* GLOBAL_MIN_ZOOM_FEATURE_BORDER */.xvi+.1?constants/* GLOBAL_MIN_ZOOM_FEATURE_BORDER */.xvi:zoom-1;setViewport({...viewport,longitude,latitude,zoom:isTerritory?zoom:featureSelectionZoomLevel,transitionDuration:1000,transitionInterpolator:new ViewportFlyToInterpolator(),transitionEasing:cubicInOut});// Set the tract ID to be selected if any.\nsetSelectTractId(selectTractId);};const onTransitionStart=()=>{setTransitionInProgress(true);};const onTransitionEnd=()=>{setTransitionInProgress(false);/*\n    If there is a tract ID to be selected then do so once the map has finished moving.\n    Note that setting the viewpoint to move the map as done in this component does not\n    trigger a moveend or idle event like when using flyTo or easeTo.\n    */if(selectTractId){var _mapRef$current2;// Search for features in the map that have the tract ID.\nconst geoidSearchResults=(_mapRef$current2=mapRef.current)===null||_mapRef$current2===void 0?void 0:_mapRef$current2.getMap().querySourceFeatures(constants/* HIGH_ZOOM_SOURCE_NAME */.NP7,{sourceLayer:constants/* SCORE_SOURCE_LAYER */.ZG$,validate:true,filter:['==',constants/* GEOID_PROPERTY */.TnO,selectTractId]});if(geoidSearchResults&&geoidSearchResults.length>0){// TODO, support searching for a list of tracts\nselectFeaturesOnMap(geoidSearchResults[0]);}setSelectTractId(undefined);}};const onGeolocate=()=>{setGeolocationInProgress(false);// set local storage that location was locked on this app at some point\nsetIsGeolocateLocked(true);};const onClickGeolocate=()=>{setGeolocationInProgress(true);};/**\n   * Handler for when there is a change in the multi select side panel.\n   * @param feature the feature that was added or removed\n   */const onReportDeleteTract=feature=>{updateSelectedFeatures(feature,true);};/**\n   * Handler for when the multi select is finished.\n   */const onReportExit=()=>{// Clear everything\nsetSelectedFeatures([]);setDetailViewData(undefined);setInMultiSelectMode(false);};return/*#__PURE__*/react.createElement(react.Fragment,null,/*#__PURE__*/react.createElement(lib.Grid,{desktop:{col:9},className:j40Map},/*#__PURE__*/react.createElement(interactive_map// ****** Initialization props: ******\n// access token is j40StylesReadToken\n,Object.assign({mapboxApiAccessToken:({}).MAPBOX_STYLES_READ_TOKEN?({}).MAPBOX_STYLES_READ_TOKEN:''// ****** Map state props: ******\n// http://visgl.github.io/react-map-gl/docs/api-reference/interactive-map#map-state\n},viewport,{mapStyle:({}).MAPBOX_STYLES_READ_TOKEN?'mapbox://styles/justice40/cl9g30qh7000p15l9cp1ftw16':'https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json',width:\"100%\"// Ajusting this height with a conditional statement will not render the map on staging.\n// The reason for this issue is unknown. Consider styling the parent container via SASS.\n,height:\"100%\",mapOptions:{hash:true}// ****** Interaction option props: ******\n// http://visgl.github.io/react-map-gl/docs/api-reference/interactive-map#interaction-options\n,maxZoom:constants/* GLOBAL_MAX_ZOOM */.lZg,minZoom:constants/* GLOBAL_MIN_ZOOM */.xaE,dragRotate:false,touchRotate:false// eslint-disable-next-line max-len\n,interactiveLayerIds:[constants/* HIGH_ZOOM_LAYER_ID */.jt_,constants/* PRIORITIZED_HIGH_ZOOM_LAYER_ID */.nHu]// ****** Callback props: ******\n// http://visgl.github.io/react-map-gl/docs/api-reference/interactive-map#callbacks\n,onViewportChange:setViewport,onClick:onClick,onLoad:onLoad,onTransitionStart:onTransitionStart,onTransitionEnd:onTransitionEnd,ref:mapRef,\"data-cy\":'reactMapGL'}),/* Tribal layer is baked into Mapbox source,\n             * only render here if we're not using that\n             **/({}).MAPBOX_STYLES_READ_TOKEN||/*#__PURE__*/react.createElement(MapTribalLayers,null),/*#__PURE__*/react.createElement(MapTractLayers_MapTractLayers,{selectedFeatures:selectedFeatures}),/*#__PURE__*/react.createElement(\"div\",{className:mapHeaderRow},/*#__PURE__*/react.createElement(components_MapSearch,{goToPlace:goToPlace}),/*#__PURE__*/react.createElement(\"div\",{className:geolocateBox},windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG-1&&/*#__PURE__*/react.createElement(\"div\",{className:geolocationInProgress&&!isGeolocateLocked?geolocateMessage:geolocateMessageHide},intl.formatMessage(explore/* MAP */.lC.GEOLOC_MSG_LOCATING)),/*#__PURE__*/react.createElement(geolocate_control,{positionOptions:{enableHighAccuracy:true},onGeolocate:onGeolocate,onClick:onClickGeolocate,trackUserLocation:windowWidth<constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG,showUserHeading:windowWidth<constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG}))),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(navigation_control,{showCompass:false,className:navigationControl}),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(territoryFocusControl,{onClick:onClick}),'fs'in flags&&detailViewData&&!transitionInProgress&&/*#__PURE__*/react.createElement(popup,{className:j40Popup,tipSize:5,anchor:\"top\",longitude:detailViewData.longitude,latitude:detailViewData.latitude,closeOnClick:true,onClose:setDetailViewData,captureScroll:true},/*#__PURE__*/react.createElement(components_AreaDetail,{properties:detailViewData.properties,hash:zoomLatLngHash})),'fs'in flags?/*#__PURE__*/react.createElement(fullscreen_control,{className:fullscreenControl}):'')),/*#__PURE__*/react.createElement(lib.Grid,{desktop:{col:3}},inMultiSelectMode?/*#__PURE__*/react.createElement(components_CreateReportPanel,{className:J40Map_module_mapInfoPanel,featureList:selectedFeatures,deleteTractHandler:onReportDeleteTract,exitHandler:onReportExit,maxNumTracts:MAX_SELECTED_TRACTS,showTooManyTractsAlert:showTooManyTractsAlert}):/*#__PURE__*/react.createElement(mapInfoPanel,{className:J40Map_module_mapInfoPanel,featureProperties:detailViewData===null||detailViewData===void 0?void 0:detailViewData.properties,hash:zoomLatLngHash})));};/* harmony default export */ var components_J40Map = (J40Map);\n// EXTERNAL MODULE: ./src/components/J40MainGridContainer.tsx\nvar J40MainGridContainer = __webpack_require__(21481);\n// EXTERNAL MODULE: ./src/components/layout.tsx + 18 modules\nvar layout = __webpack_require__(5420);\n// EXTERNAL MODULE: ./src/components/DatasetsButton/index.ts + 2 modules\nvar DatasetsButton = __webpack_require__(34499);\n;// ./src/pages/index.tsx\nconst ExporeToolPage=_ref=>{let{location}=_ref;// We temporarily removed MapControls, which would enable you to `setFeatures` also, for now\n//   We will bring back later when we have interactive controls.\nconst intl=(0,gatsby_plugin_intl.useIntl)();return/*#__PURE__*/react.createElement(layout/* default */.A,{location:location,title:intl.formatMessage(explore/* PAGE_INTRO */.jk.PAGE_TILE)},/*#__PURE__*/react.createElement(J40MainGridContainer/* default */.A,null,/*#__PURE__*/react.createElement(\"section\",{className:'page-heading'},/*#__PURE__*/react.createElement(\"h1\",null,intl.formatMessage(explore/* PAGE_INTRO */.jk.PAGE_HEADING)),/*#__PURE__*/react.createElement(DatasetsButton/* default */.A,{href:intl.locale==='es'?constants/* DATA_SURVEY_LINKS */.axV.ES:constants/* DATA_SURVEY_LINKS */.axV.EN})),/*#__PURE__*/react.createElement(lib.Grid,{row:true,gap:true,className:'j40-mb5-mt3'},/*#__PURE__*/react.createElement(lib.Grid,{desktop:{col:8},tablet:{col:10},col:12},/*#__PURE__*/react.createElement(\"p\",null,explore/* PAGE_DESCRIPTION1 */.oy),/*#__PURE__*/react.createElement(\"p\",null,explore/* PAGE_DESCRIPTION2 */.v)),/*#__PURE__*/react.createElement(lib.Grid,{desktop:{col:4},tablet:{col:10},col:12},/*#__PURE__*/react.createElement(components_ExploreDataBox,null)))),/*#__PURE__*/react.createElement(J40MainGridContainer/* default */.A,null,/*#__PURE__*/react.createElement(lib.Grid,{row:true},/*#__PURE__*/react.createElement(components_J40Map,{location:location}))),/*#__PURE__*/react.createElement(J40MainGridContainer/* default */.A,null,/*#__PURE__*/react.createElement(lib.Grid,{desktop:{col:7},tablet:{col:10},col:12},/*#__PURE__*/react.createElement(\"h2\",null,explore/* NOTE_ON_TERRITORIES */.oI.INTRO),/*#__PURE__*/react.createElement(\"p\",null,explore/* NOTE_ON_TERRITORIES */.oI.PARA_0),/*#__PURE__*/react.createElement(\"p\",null,explore/* NOTE_ON_TERRITORIES */.oI.PARA_1),/*#__PURE__*/react.createElement(\"p\",null,explore/* NOTE_ON_TERRITORIES */.oI.PARA_2)),/*#__PURE__*/react.createElement(lib.Grid,{desktop:{col:7},tablet:{col:10},col:12},/*#__PURE__*/react.createElement(\"h2\",null,explore/* NOTE_ON_TRIBAL_NATIONS */.j2.INTRO),/*#__PURE__*/react.createElement(\"p\",null,explore/* NOTE_ON_TRIBAL_NATIONS */.j2.PARA_1),/*#__PURE__*/react.createElement(\"p\",null,explore/* NOTE_ON_TRIBAL_NATIONS */.j2.PARA_2))));};/* harmony default export */ var pages = (ExporeToolPage);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxXQUFXO0FBQ3RCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseUJBQXlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1GQUFtRixnQkFBZ0I7QUFDbkc7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOztBQ3BFNEI7QUFDcUI7QUFDakQ7QUFDQTtBQUNBLEVBQUUsRUFBRSxpQkFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZSx3QkFBd0IsS0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQzs7QUNwSTRCO0FBQ3FCO0FBQ2pEO0FBQ0E7QUFDQSxFQUFFLEVBQUUsaUJBQWlCO0FBQ3JCO0FBQ0E7QUFDZSx1QkFBdUIsS0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7O0FDdkQ0QjtBQUM1QixNQUFNLDRCQUFVO0FBQ0QsK0JBQStCLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxDOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0JBQVk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxvQkFBb0Isd0JBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOztBQzNFZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsWUFBWTtBQUNyQixTQUFTLGlCQUFpQjtBQUMxQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7O0FDeEt5QztBQUNLO0FBQ0Y7QUFDRjtBQUNnQjtBQUNMO0FBQzJHO0FBQ2hLLE1BQU0sNkJBQWU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZCQUFlO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0EsS0FBSztBQUNMLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0EsS0FBSztBQUNMLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0Esc0NBQXNDLG9CQUFvQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7OztBRTNSd0U7QUFDTjtBQUNNO0FBQ3hFLFNBQVMsc0JBQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMkJBQWE7QUFDdEIsa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0EsTUFBTSxzQkFBTztBQUNiLFFBQVEsZUFBZTtBQUN2QixPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLE1BQU0sc0JBQU87QUFDYjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNtQztBQUNlO0FBQzBCO0FBQzVFO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDhCQUE4QixrQkFBa0I7QUFDaEQsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZUFBZTtBQUNuQixJQUFJLGVBQWU7QUFDbkIsSUFBSSxlQUFlO0FBQ25CLElBQUksZUFBZTtBQUNuQixJQUFJLGVBQWU7QUFDbkIsSUFBSSxlQUFlO0FBQ25CLElBQUksZUFBZTtBQUNuQixJQUFJLGVBQWU7QUFDbkIsSUFBSSxlQUFlO0FBQ25CLElBQUksZUFBZTtBQUNuQjtBQUNBLEtBQUs7QUFDTCxJQUFJLGVBQWUsb0JBQW9CO0FBQ3ZDLElBQUksZUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGVBQWU7QUFDbkI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxFQUFFLFlBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RCx3QkFBd0IsMkJBQWEsQ0FBQywyQkFBYSxHQUFHO0FBQ3REO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUSxDQUFDLDJCQUFhLENBQUMsMkJBQWEsQ0FBQywyQkFBYSxHQUFHO0FBQ3RFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsa0RBQWtELDJCQUFhLENBQUMsMkJBQWEsR0FBRyw4QkFBOEI7QUFDOUc7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsa0RBQWtELDJCQUFhLENBQUMsMkJBQWEsR0FBRyw4QkFBOEI7QUFDOUc7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx1Q0FB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0EsT0FBTztBQUNQLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0EseUJBQXlCLG1DQUFtQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFL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O0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUIsVUFBVSxnQkFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNU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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0gsU0FBUywwQkFBaUI7QUFDMUIsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMscUJBQVk7QUFDckIsa0JBQWtCLDBCQUFpQjtBQUNuQyxtQkFBbUIsMEJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbUJBQW1CO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx3RUFBd0UsMkJBQTJCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHNCQUFzQjtBQUN2RjtBQUNBO0FBQ0EsMEVBQTBFLDBCQUEwQjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxxQkFBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQywrQ0FBK0MsZUFBZTtBQUM5RDtBQUNBO0FBQ0EsaUVBQWlFLHVCQUF1QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQyw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7OztBQ253Qkg7QUFDTztBQUNBLGdFOztBQ01OLENBRUQsS0FBTSxDQUFBRyxnQkFBZ0IsQ0FBRzNnQixJQUFBLEVBQTBDLElBQXpDLENBQUM0Z0IsbUJBQWtDLENBQUMsQ0FBQTVnQixJQUFBLENBQzVELEtBQU0sQ0FBQUMsSUFBSSxDQUFHTiw4QkFBTyxDQUFDLENBQUMsQ0FFdEIsbUJBQ0VKLG1CQUFBLFFBQUtZLFNBQVMsQ0FBRXlnQixtQkFBbUIsQ0FBRy9nQixXQUFrQixDQUFHQSxXQUFtQixFQUMzRUksSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1CQUFnQixDQUFDb2hCLDRCQUE0QixDQUM5RCxDQUFDLENBRVYsQ0FBQyxDQUVELHNFQUFlTCxnQkFBZ0IsRTs7QUNsQi9CLGdFQUFlQSxpQ0FBZ0IsRTs7QUNGL0I7OztBQ0FBLDRCQXdCQSxLQUFNLENBQUFTLFNBQVMsQ0FBR3BoQixJQUFBLEVBQTRCLElBQTNCLENBQUNxaEIsU0FBb0IsQ0FBQyxDQUFBcmhCLElBQUEsQ0FDdkM7QUFDQSxLQUFNLEdBQUM0Z0IsbUJBQW1CLEdBQUVVLHNCQUFzQixFQUFJbFksa0JBQVEsQ0FBQyxLQUFLLENBQUMsQ0FDckUsS0FBTSxDQUFBbkosSUFBSSxDQUFHTiw4QkFBTyxDQUFDLENBQUMsQ0FFdEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsS0FBTSxDQUFDdWUsS0FBSyxDQUFFcUQsTUFBTSxDQUFDLENBQUdqRSxnQ0FBYSxDQUFDLENBQUMsQ0FDdkMsS0FBTSxHQUFDa0UsZUFBZSxHQUFFQyxrQkFBa0IsRUFBR3JZLGtCQUFRLENBQUN4SixtQkFBZ0IsQ0FBQzhoQixrQkFBa0IsQ0FBQyxDQUMxRixLQUFNLEdBQUNDLFdBQVcsR0FBRUMsY0FBYyxFQUFJeFksa0JBQVEsQ0FBeUIsSUFBSSxDQUFDLENBRTVFO0FBQ0Y7QUFDQSxLQUNFLEtBQU0sQ0FBQXlZLGtCQUFrQixDQUFHLEtBQUFBLENBQUEsR0FBWSxDQUNyQyxLQUFNLENBQUFDLGFBQWEsQ0FBRyxHQUFHbmdCLGdDQUF1QixJQUFJQSx3Q0FBK0IsRUFBRSxDQUNyRnNnQixLQUFLLENBQUNILGFBQWEsQ0FBQyxDQUNmSSxJQUFJLENBQUVDLFFBQVEsRUFBSyxDQUNsQixHQUFJQSxRQUFRLENBQUNDLEVBQUUsQ0FBRSxDQUNmLE1BQU8sQ0FBQUQsUUFBUSxDQUFDRSxJQUFJLENBQUMsQ0FBQyxDQUN4QixDQUFDLElBQU0sQ0FDTCxLQUFNLElBQUksQ0FBQTFULEtBQUssQ0FBQyxHQUFHd1QsUUFBUSxDQUFDRyxVQUFVLDhCQUE4QkgsUUFBUSxDQUFDSSxNQUFNLEVBQUUsQ0FBQyxDQUN4RixDQUNGLENBQUMsQ0FBQyxDQUNETCxJQUFJLENBQUVNLElBQUksRUFBSyxDQUNkO0FBQ0EsS0FBTSxDQUFBQyxNQUFNLENBQUcsR0FBSSxDQUFBdEIsTUFBZSxDQUFDLFNBQVMsQ0FBQyxDQUM3Q3NCLE1BQU0sQ0FBQ0MsYUFBYSxDQUFHLEdBQUksQ0FBQXZCLHNCQUErQixDQUFDLENBQUMsQ0FDNURzQixNQUFNLENBQUNHLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FDMUJILE1BQU0sQ0FBQ0ksWUFBWSxDQUFDTCxJQUFJLENBQUMsQ0FDekJaLGNBQWMsQ0FBQ2EsTUFBTSxDQUFDLENBQ3hCLENBQUMsQ0FBQyxDQUNESyxLQUFLLENBQUVDLEtBQUssRUFDWG5VLE9BQU8sQ0FBQ21VLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBRUEsS0FBSyxDQUFDLENBQUMsQ0FDbkUsQ0FBQyxDQUVEOUIsbUJBQVMsQ0FBRSxJQUFNLENBQ2hCL0MsS0FBSyxDQUFHcUQsTUFBTSxDQUFHRSxrQkFBa0IsQ0FBQzdoQixtQkFBZ0IsQ0FBQzhoQixrQkFBa0IsQ0FBQyxDQUFFRCxrQkFBa0IsQ0FBQzdoQixtQkFBZ0IsQ0FBQ29qQix5QkFBeUIsQ0FBQyxDQUN6SSxDQUFDLENBQUUsQ0FBQzlFLEtBQUssQ0FBQyxDQUFDLENBRVgrQyxtQkFBUyxDQUFDLElBQUksQ0FDWlksa0JBQWtCLENBQUMsQ0FBQyxDQUN0QixDQUFDLENBQUUsRUFBRSxDQUFDLENBRU47QUFDRjtBQUNBO0FBQ0EsS0FDRSxLQUFNLENBQUFvQixjQUFjLENBQUcsS0FBTyxDQUFBQyxLQUFhLEVBQUssQ0FDOUM7QUFDQTtBQUNBLEtBQU0sQ0FBQUMsb0JBQW9CLENBQUcsR0FBRyxDQUVoQztBQUNBLEtBQU0sQ0FBQUMsaUJBQWlCLENBQUdGLEtBQUssQ0FBQ2xmLE1BQU0sRUFBSSxFQUFFLENBQUcsR0FBRyxDQUFHa2YsS0FBSyxDQUFHQSxLQUFLLENBRWxFNUIsc0JBQXNCLENBQUMsSUFBSSxDQUFDLENBRTVCLEdBQUlLLFdBQVcsQ0FBRSxDQUNmLEtBQU0sQ0FBQTBCLE1BQU0sQ0FBRzFCLFdBQVcsQ0FBQ2MsTUFBTSxDQUFDVyxpQkFBaUIsQ0FBQyxDQUNwRCxHQUFJQyxNQUFNLENBQUNyZixNQUFNLENBQUcsQ0FBQyxDQUFFLENBQ3JCLEtBQU0sQ0FBQXNmLGlCQUFpQixDQUFHRCxNQUFNLENBQUMsQ0FBQyxDQUF1QixDQUN6RCxLQUFNLENBQUFFLEdBQUcsQ0FBR2hlLE1BQU0sQ0FBQytkLGlCQUFpQixDQUFDRSxVQUFVLENBQUMsQ0FDaEQsS0FBTSxDQUFBQyxHQUFHLENBQUdsZSxNQUFNLENBQUMrZCxpQkFBaUIsQ0FBQ0ksVUFBVSxDQUFDLENBQ2hELEtBQU0sQ0FBQUMsV0FBVyxDQUFHLENBQ2xCLENBQUNKLEdBQUcsQ0FBSUosb0JBQW9CLENBQUcsQ0FBRSxFQUFFUyxRQUFRLENBQUMsQ0FBQyxDQUM3QyxDQUFDTCxHQUFHLENBQUlKLG9CQUFvQixDQUFHLENBQUUsRUFBRVMsUUFBUSxDQUFDLENBQUMsQ0FDN0MsQ0FBQ0gsR0FBRyxDQUFJTixvQkFBb0IsQ0FBRyxDQUFFLEVBQUVTLFFBQVEsQ0FBQyxDQUFDLENBQzdDLENBQUNILEdBQUcsQ0FBSU4sb0JBQW9CLENBQUcsQ0FBRSxFQUFFUyxRQUFRLENBQUMsQ0FBQyxDQUM5QyxDQUNELEtBQU0sQ0FBQ0MsTUFBTSxDQUFFQyxNQUFNLENBQUVDLE9BQU8sQ0FBRUMsT0FBTyxDQUFDLENBQUdMLFdBQVcsQ0FDdERyQyxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsQ0FFN0I7QUFDQUQsU0FBUyxDQUFDLENBQUMsQ0FBQzliLE1BQU0sQ0FBQ3dlLE9BQU8sQ0FBQyxDQUFFeGUsTUFBTSxDQUFDc2UsTUFBTSxDQUFDLENBQUMsQ0FBRSxDQUFDdGUsTUFBTSxDQUFDeWUsT0FBTyxDQUFDLENBQUV6ZSxNQUFNLENBQUN1ZSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUUsS0FBSyxDQUFFVixpQkFBaUIsQ0FBQyxDQUM3RyxDQUNGLENBQ0YsQ0FBQyxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsS0FBTSxDQUFBYSxpQkFBaUIsQ0FBRyxLQUFPLENBQUFDLFVBQWtCLEVBQUssQ0FDdEQsS0FBTSxDQUFBQyxhQUFhLENBQUcsS0FBTSxDQUFBbEMsS0FBSyxDQUM3QixnREFBZ0RpQyxVQUFVLDhCQUE4QixDQUN4RixDQUNFRSxJQUFJLENBQUUsTUFDUixDQUFDLENBQUMsQ0FDRGxDLElBQUksQ0FBRUMsUUFBUSxFQUFLLENBQ2xCLEdBQUksQ0FBQ0EsUUFBUSxDQUFDQyxFQUFFLENBQUUsQ0FDaEIsS0FBTSxJQUFJLENBQUF6VCxLQUFLLENBQUMsNkJBQTZCLENBQUMsQ0FDaEQsQ0FDQSxNQUFPLENBQUF3VCxRQUFRLENBQUNFLElBQUksQ0FBQyxDQUFDLENBQ3hCLENBQUMsQ0FBQyxDQUNEUyxLQUFLLENBQUVDLEtBQUssRUFBSyxDQUNoQm5VLE9BQU8sQ0FBQ21VLEtBQUssQ0FBQyxxREFBcUQsQ0FBRUEsS0FBSyxDQUFDLENBQzdFLENBQUMsQ0FBQyxDQUNOblUsT0FBTyxDQUFDQyxHQUFHLENBQUMsNEJBQTRCLENBQUVzVixhQUFhLENBQUMsQ0FFeEQ7QUFDQSxHQUFJQSxhQUFhLEVBQUlBLGFBQWEsQ0FBQ25nQixNQUFNLENBQUcsQ0FBQyxDQUFFLENBQzdDc2Qsc0JBQXNCLENBQUMsS0FBSyxDQUFDLENBQzdCLEtBQU0sQ0FBQ3VDLE1BQU0sQ0FBRUMsTUFBTSxDQUFFQyxPQUFPLENBQUVDLE9BQU8sQ0FBQyxDQUFHRyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUNFLFdBQVcsQ0FDdkVoRCxTQUFTLENBQUMsQ0FBQyxDQUFDOWIsTUFBTSxDQUFDd2UsT0FBTyxDQUFDLENBQUV4ZSxNQUFNLENBQUNzZSxNQUFNLENBQUMsQ0FBQyxDQUFFLENBQUN0ZSxNQUFNLENBQUN5ZSxPQUFPLENBQUMsQ0FBRXplLE1BQU0sQ0FBQ3VlLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBRSxLQUFLLENBQUVsWixTQUFTLENBQUMsQ0FDckcsQ0FBQyxJQUFNLENBQ0wwVyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FDOUIsQ0FDRixDQUFDLENBRUQ7QUFDRjtBQUNBO0FBQ0EsSUFDRSxLQUFNLENBQUFnRCxlQUFlLENBQUcsS0FBTyxDQUFBQyxLQUF1QyxFQUFLLENBQ3pFQSxLQUFLLENBQUNDLGNBQWMsQ0FBQyxDQUFDLENBQ3RCRCxLQUFLLENBQUNFLGVBQWUsQ0FBQyxDQUFDLENBRXZCLEtBQU0sQ0FBQVAsVUFBVSxDQUFJSyxLQUFLLENBQUNHLGFBQWEsQ0FBQ0MsUUFBUSxDQUFDQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQXNCM2hCLEtBQUssQ0FFL0Y7QUFDQSxLQUFNLENBQUE0aEIsT0FBTyxDQUFHLGFBQWEsQ0FBQ0MsSUFBSSxDQUFDWixVQUFVLENBQUMsQ0FDOUMsR0FBSVcsT0FBTyxDQUFFLENBQ1g1QixjQUFjLENBQUNpQixVQUFVLENBQUMsQ0FDNUIsQ0FBQyxJQUFNLENBQ0xELGlCQUFpQixDQUFDQyxVQUFVLENBQUMsQ0FDL0IsQ0FDRixDQUFDLENBRUQsbUJBQ0Uza0IsbUJBQUEsUUFBS1ksU0FBUyxDQUFFTixtREFBMEIsZUFDeENOLG1CQUFBLENBQUNvaEIsMkJBQWdCLEVBQUNDLG1CQUFtQixDQUFFQSxtQkFBb0IsQ0FBRSxDQUFDLGNBQzlEcmhCLG1CQUFBLENBQUMyaEIsVUFBTSxFQUNMOEQsV0FBVyxDQUFFL2tCLElBQUksQ0FBQ0ssYUFBYSxDQUFDa2hCLGVBQWUsQ0FBRSxDQUNqRHlELElBQUksQ0FBQyxPQUFPLENBQ1pDLFFBQVEsQ0FBR0MsQ0FBQyxFQUFLYixlQUFlLENBQUNhLENBQUMsQ0FBRSxDQUNyQyxDQUNFLENBQUMsQ0FFVixDQUFDLENBRUQsd0RBQWUvRCxTQUFTLEU7O0FDN0t4Qix5REFBZUEsbUJBQVMsRTs7OztBQ0V4QjtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FDTyxLQUFNLENBQUFvRSx3QkFBd0IsQ0FBSUMsV0FBbUIsRUFBYSxDQUN2RSxLQUFNLENBQUFDLEtBQUssQ0FBR0osZ0NBQVEsQ0FBQyxDQUFDLENBRXhCLEtBQU0sQ0FBQUssc0JBQXNCLENBQUdDLG1EQUFxQyxDQUFFLHdCQUF3QixDQUM5RixLQUFNLENBQUFHLFVBQVUsQ0FBRyxpQkFBaUIsQ0FFcEMsR0FBSSxZQUFZLEVBQUksQ0FBQUwsS0FBSyxDQUFFLENBQ3pCO0FBQ0EsS0FBTSxDQUFBTSxLQUFLLENBQUcsMEJBQTBCLENBQ3hDLEdBQUksQ0FBQ0EsS0FBSyxDQUFDbEIsSUFBSSxDQUFDWSxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBRSxDQUNwQzlXLE9BQU8sQ0FBQ21VLEtBQUssQ0FBQ3dDLDRCQUF5QixDQUFDVyxTQUFTLENBQUMsQ0FDcEQsQ0FFQSxNQUFPLEdBQUdQLHNCQUFzQixJQUFJRCxLQUFLLENBQUMsWUFBWSxDQUFDLHFCQUFxQkQsV0FBVyxJQUFJTSxVQUFVLEVBQUUsQ0FDekcsQ0FBQyxJQUFNLENBQ0w7QUFDQTtBQUNBLEtBQU0sQ0FBQUksa0JBQWtCLENBQUd4a0IsZ0NBQXVCLENBQ2xELEtBQU0sQ0FBQXlrQixlQUFlLENBQUd6a0IsNEJBQW1CLENBRTNDLE1BQU8sQ0FDTHdrQixrQkFBa0IsQ0FDbEJDLGVBQWUsQ0FDZlIsT0FBaUMsQ0FDakNILFdBQVcsQ0FDWE0sVUFBVSxDQUNYLENBQUNRLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FDYixDQUNGLENBQUMsQ0FFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUNBLEtBQU0sQ0FBQUMsY0FBYyxDQUFHeG1CLElBQUEsRUFFQSxJQUZDLENBQ3RCeW1CLGdCQUNlLENBQUMsQ0FBQXptQixJQUFBLENBQ2hCLEtBQU0sQ0FBQTBtQixrQkFBa0IsQ0FBR0QsZ0JBQWdCLENBQUlBLGdCQUFnQixDQUFDbmMsR0FBRyxDQUFFcWMsSUFBSSxFQUFLQSxJQUFJLENBQUNwa0IsRUFBRSxDQUFDLENBQUksQ0FBQyxFQUFFLENBQUMsQ0FDOUYsS0FBTSxDQUFBa1ksTUFBTSxFQUFJLElBQUksQ0FBRTlZLGlDQUF3QixFQUFBaWxCLE1BQUEsQ0FBQUMsb0NBQUEsQ0FBS0gsa0JBQWtCLEVBQUMsQ0FFdEUsbUJBQ0VubkIsbUJBQUEsQ0FBQUEsY0FBQSxtQkFDRUEsbUJBQUEsQ0FBQzZsQixNQUFNLEVBQ0w3aUIsRUFBRSxDQUFFWix1Q0FBK0IsQ0FDbkNxQixJQUFJLENBQUMsUUFBUSxDQUNiK2pCLFNBQVMsQ0FBRXBsQixpQ0FBeUIsQ0FDcENxbEIsS0FBSyxDQUFFLENBQUN4Qix3QkFBd0IsQ0FBQyxLQUFLLENBQUMsQ0FBRSxDQUN6Q3lCLE9BQU8sQ0FBRXRsQixzQ0FBOEIsQ0FDdkN3bEIsT0FBTyxDQUFFeGxCLHNDQUE4QixlQUl2Q3BDLG1CQUFBLENBQUM4bEIsZ0JBQUssRUFDSjlpQixFQUFFLENBQUVaLG9DQUE0QixDQUNoQyxlQUFjQSxxQ0FBNkIsQ0FDM0M4WSxNQUFNLENBQUUsQ0FBQyxHQUFHLENBQUU5WSxxQ0FBNEIsQ0FBRUEsMkNBQWtDLENBQUUsQ0FDaEZxQixJQUFJLENBQUMsTUFBTSxDQUNYeWtCLEtBQUssQ0FBRSxDQUNMLFlBQVksQ0FBRTlsQixpREFBd0MsQ0FDdEQsY0FBYyxDQUFFQSw0REFBbUQsQ0FBRSxDQUN2RXNsQixPQUFPLENBQUV0bEIsc0NBQThCLENBQ3ZDd2xCLE9BQU8sQ0FBRXhsQixzQ0FBOEIsQ0FDeEMsQ0FDSyxDQUFDLGNBR1RwQyxtQkFBQSxDQUFDNmxCLE1BQU0sRUFDTDdpQixFQUFFLENBQUVaLHdDQUFnQyxDQUNwQ3FCLElBQUksQ0FBQyxRQUFRLENBQ2IrakIsU0FBUyxDQUFFcGxCLGlDQUF5QixDQUNwQ3FsQixLQUFLLENBQUUsQ0FBQ3hCLHdCQUF3QixDQUFDLE1BQU0sQ0FBQyxDQUFFLENBQzFDeUIsT0FBTyxDQUFFdGxCLHVDQUErQixDQUN4Q3dsQixPQUFPLENBQUV4bEIsdUNBQStCLGVBSXhDcEMsbUJBQUEsQ0FBQzhsQixnQkFBSyxFQUNKOWlCLEVBQUUsQ0FBRVoscUNBQTZCLENBQ2pDLGVBQWNBLHFDQUE2QixDQUMzQzhZLE1BQU0sQ0FBRSxDQUFDLElBQUksQ0FBRTlZLHNDQUE2QixDQUFFLEtBQUssQ0FBRSxDQUNyRHFCLElBQUksQ0FBQyxNQUFNLENBQ1h5a0IsS0FBSyxDQUFFLENBQ0wsY0FBYyxDQUFFOWxCLHVEQUNsQixDQUFFLENBQ0Z3bEIsT0FBTyxDQUFFeGxCLHVDQUErQixDQUN6QyxDQUFDLGNBR0ZwQyxtQkFBQSxDQUFDOGxCLGdCQUFLLEVBQ0o5aUIsRUFBRSxDQUFFWixpREFBeUMsQ0FDN0MsZUFBY0EscUNBQTZCLENBQzNDOFksTUFBTSxDQUFFLENBQUMsSUFBSSxDQUFFOVksc0NBQTZCLENBQUUsSUFBSSxDQUFFLENBQ3BEcUIsSUFBSSxDQUFDLE1BQU0sQ0FDWHlrQixLQUFLLENBQUUsQ0FDTCxZQUFZLENBQUU5bEIsaURBQXdDLENBQ3RELGNBQWMsQ0FBRUEsNkRBQ2xCLENBQUUsQ0FDRndsQixPQUFPLENBQUV4bEIsdUNBQStCLENBQ3pDLENBQUMsY0FHRnBDLG1CQUFBLENBQUM4bEIsZ0JBQUssRUFDSjlpQixFQUFFLENBQUVaLG1EQUEyQyxDQUMvQyxlQUFjQSxxQ0FBNkIsQ0FDM0M4WSxNQUFNLENBQUUsQ0FBQyxJQUFJLENBQUU5WSxtQ0FBMEIsQ0FBRSxJQUFJLENBQUUsQ0FDakRxQixJQUFJLENBQUMsTUFBTSxDQUNYeWtCLEtBQUssQ0FBRSxDQUNMLFlBQVksQ0FBRTlsQixtREFBMEMsQ0FDeEQsY0FBYyxDQUFFQSw2REFDbEIsQ0FBRSxDQUNGd2xCLE9BQU8sQ0FBRXhsQix1Q0FBK0IsQ0FDekMsQ0FBQyxjQUdGcEMsbUJBQUEsQ0FBQzhsQixnQkFBSyxFQUNKOWlCLEVBQUUsQ0FBRVosMENBQWtDLENBQ3RDLGVBQWNBLHFDQUE2QixDQUMzQ3FCLElBQUksQ0FBQyxNQUFNLENBQ1h5a0IsS0FBSyxDQUFFLENBQ0wsWUFBWSxDQUFFOWxCLHVDQUE4QixDQUM1QyxZQUFZLENBQUVBLHVDQUE4QixDQUM1QyxjQUFjLENBQUVBLHlDQUNsQixDQUFFLENBQ0ZzbEIsT0FBTyxDQUFFdGxCLGlEQUF5QyxDQUNsRHdsQixPQUFPLENBQUV4bEIsaURBQXlDLENBQ25ELENBQUMsY0FHRnBDLG1CQUFBLENBQUM4bEIsZ0JBQUssRUFDSjlpQixFQUFFLENBQUVaLG1EQUEyQyxDQUMvQyxlQUFjQSxxQ0FBNkIsQ0FDM0M4WSxNQUFNLENBQUVBLE1BQVE7QUFBQSxDQUNoQnpYLElBQUksQ0FBQyxNQUFNLENBQ1h5a0IsS0FBSyxDQUFFLENBQ0wsWUFBWSxDQUFFOWxCLGdEQUF1QyxDQUNyRCxZQUFZLENBQUVBLGdEQUNoQixDQUFFLENBQ0Z3bEIsT0FBTyxDQUFFeGxCLHVDQUErQixDQUN6QyxDQUNLLENBQ1IsQ0FBQyxDQUVQLENBQUMsQ0FFRCxrRUFBZTZrQixjQUFjLEU7O0FDMUs3QjtBQUNBO0FBQ0E7QUFDQSxHQUNPLEtBQU0sQ0FBQXVDLFNBQVMsQ0FBR0EsQ0FBQSxHQUFjLENBQ3JDLEtBQU0sQ0FBQTVDLGtCQUFrQixDQUFHeGtCLGdDQUF1QixDQUNsRCxLQUFNLENBQUF5a0IsZUFBZSxDQUFHemtCLG1EQUEwQyxDQUNsRSxLQUFNLENBQUFva0IsVUFBVSxDQUFHLGlCQUFpQixDQUVwQyxNQUFPLENBQ0xJLGtCQUFrQixDQUNsQkMsZUFBZSxDQUNmUixPQUFpQyxDQUNqQ0csVUFBVSxDQUNYLENBQUNRLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FDYixDQUFDLENBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FDQSxLQUFNLENBQUEwQyxjQUFjLENBQUdBLENBQUEsR0FBTSxDQUMzQixvQkFFRTtBQUNBMXBCLG1CQUFBLENBQUM2bEIsTUFBTSxFQUNMN2lCLEVBQUUsQ0FBRVoscUNBQTZCLENBQ2pDcUIsSUFBSSxDQUFDLFFBQVEsQ0FDYitqQixTQUFTLENBQUVwbEIsNEJBQW9CLENBQy9CcWxCLEtBQUssQ0FBRSxDQUFDK0IsU0FBUyxDQUFDLENBQUMsQ0FBRSxlQUlyQnhwQixtQkFBQSxDQUFDOGxCLGdCQUFLLEVBQ0o5aUIsRUFBRSxDQUFFWixrQ0FBMEIsQ0FDOUIsZUFBY0Esc0NBQThCLENBQzVDcUIsSUFBSSxDQUFDLE1BQU0sQ0FDWHlrQixLQUFLLENBQUUsQ0FDTCxZQUFZLENBQUU5bEIsaURBQXdDLENBQ3RELGNBQWMsQ0FBRUEsOENBQXFDLENBQUUsQ0FDekR3bEIsT0FBTyxDQUFFeGxCLGtDQUEwQixDQUNuQ3NsQixPQUFPLENBQUV0bEIsa0NBQTBCLENBQ3BDLENBQUMsY0FHRnBDLG1CQUFBLENBQUM4bEIsZ0JBQUssRUFDSjlpQixFQUFFLENBQUVaLDBDQUFrQyxDQUN0QyxlQUFjQSxzQ0FBOEIsQ0FDNUNxQixJQUFJLENBQUMsTUFBTSxDQUNYeWtCLEtBQUssQ0FBRSxDQUNMLFlBQVksQ0FBRTlsQix1Q0FBOEIsQ0FDNUMsWUFBWSxDQUFFQSx1Q0FBOEIsQ0FDNUMsY0FBYyxDQUFFQSx5Q0FDbEIsQ0FBRSxDQUNGd2xCLE9BQU8sQ0FBRXhsQixrQ0FBMEIsQ0FDbkNzbEIsT0FBTyxDQUFFdGxCLGtDQUEwQixDQUNwQyxDQUFDLGNBR0ZwQyxtQkFBQSxDQUFDOGxCLGdCQUFLLEVBQ0o5aUIsRUFBRSxDQUFFWixnREFBd0MsQ0FDNUMsZUFBY0Esc0NBQThCLENBQzVDOFksTUFBTSxDQUFFLENBQUMsSUFBSSxDQUFFLENBQUMsZUFBZSxDQUFDLENBQUUsT0FBTyxDQUFFLENBQzNDelgsSUFBSSxDQUFDLFFBQVEsQ0FDYnlrQixLQUFLLENBQUUsQ0FDTCxlQUFlLENBQUU5bEIsOENBQXFDLENBQ3RELGNBQWMsQ0FBRUEsa0RBQXlDLENBQ3pELGdCQUFnQixDQUFFQSw4Q0FBcUMsQ0FDdkQscUJBQXFCLENBQUVBLHNDQUE2QixDQUNwRCxxQkFBcUIsQ0FBRUEsNkNBQW9DLENBQzNELHVCQUF1QixDQUFFQSx5Q0FDM0IsQ0FBRSxDQUNGd2xCLE9BQU8sQ0FBRXhsQixrQ0FBMEIsQ0FDbkNzbEIsT0FBTyxDQUFFdGxCLGtDQUEwQixDQUNwQyxDQUFDLGNBR0ZwQyxtQkFBQSxDQUFDOGxCLGdCQUFLLEVBQ0o5aUIsRUFBRSxDQUFFWix5Q0FBaUMsQ0FDckMsZUFBY0Esc0NBQThCLENBQzVDcUIsSUFBSSxDQUFDLFFBQVEsQ0FDYmluQixNQUFNLENBQUUsQ0FDTixZQUFZLENBQUUsQ0FDWixNQUFNLENBQ04sQ0FBQyxJQUFJLENBQUUsTUFBTSxDQUFFLENBQUMsS0FBSyxDQUFFdG9CLGlDQUF3QixDQUFDLENBQUMsQ0FDakQsQ0FBQyxPQUFPLENBQUUsQ0FBQyxLQUFLLENBQUVBLGlDQUF3QixDQUFDLENBQUUsQ0FBQyxDQUFFLENBQUMsR0FBRyxDQUFFLENBQUMsUUFBUSxDQUFFLENBQUMsS0FBSyxDQUFFQSxpQ0FBd0IsQ0FBQyxDQUFDLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FDeEcsQ0FBQyxJQUFJLENBQUUsTUFBTSxDQUFFLENBQUMsS0FBSyxDQUFFQSxpQ0FBd0IsQ0FBQyxDQUFDLENBQ2pELENBQUMsT0FBTyxDQUFFLENBQUMsS0FBSyxDQUFFQSxpQ0FBd0IsQ0FBQyxDQUFFLENBQUMsQ0FBRSxDQUFDLEdBQUcsQ0FBRSxDQUFDLFFBQVEsQ0FBRSxDQUFDLEtBQUssQ0FBRUEsaUNBQXdCLENBQUMsQ0FBQyxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQ3hHLENBQUMsSUFBSSxDQUFFLE1BQU0sQ0FBRSxDQUFDLEtBQUssQ0FBRUEsaUNBQXdCLENBQUMsQ0FBQyxDQUNqRCxDQUFDLE9BQU8sQ0FBRSxDQUFDLEtBQUssQ0FBRUEsaUNBQXdCLENBQUMsQ0FBRSxDQUFDLENBQUUsQ0FBQyxHQUFHLENBQUUsQ0FBQyxRQUFRLENBQUUsQ0FBQyxLQUFLLENBQUVBLGlDQUF3QixDQUFDLENBQUMsQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUN4RyxDQUFDLEtBQUssQ0FBRUEsaUNBQXdCLENBQUMsQ0FDbEMsQ0FDRCxhQUFhLENBQUUsS0FBSyxDQUNwQixhQUFhLENBQUUsQ0FBQyxDQUFDLENBQUUsQ0FBQyxDQUFDLENBQ3JCLFdBQVcsQ0FBRSxFQUFFLENBQ2Ysb0JBQW9CLENBQUUsS0FBSyxDQUMzQix1QkFBdUIsQ0FBRSxLQUMzQixDQUFFLENBQ0Y4bEIsS0FBSyxDQUFFLENBQ0wsWUFBWSxDQUFFLFNBQVMsQ0FDdkIsaUJBQWlCLENBQUUsU0FBUyxDQUM1QixpQkFBaUIsQ0FBRSxHQUNyQixDQUFFLENBQ0ZOLE9BQU8sQ0FBRXhsQixrQ0FBMEIsQ0FDbkNzbEIsT0FBTyxDQUFFdGxCLGtDQUEwQixDQUNwQyxDQUNLLENBQUMsRUFFYixDQUFDLENBRUQsb0RBQWVzbkIsY0FBYyxFOztBQzdIN0I7QUFDTyw2Rjs7QUNXUCxLQUFNLENBQUFrQixxQkFBcUIsQ0FBR25xQixJQUFBLEVBQXVDLElBQXRDLENBQUM4SixPQUErQixDQUFDLENBQUE5SixJQUFBLENBQzlELEtBQU0sQ0FBQUMsSUFBSSxDQUFHTiw4QkFBTyxDQUFDLENBQUMsQ0FFdEIsS0FBTSxDQUFBeXFCLFdBQVcsQ0FBRyxDQUNsQixDQUNFQyxLQUFLLENBQUVwcUIsSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1CQUFnQixDQUFDMHFCLGFBQWEsQ0FBQyxDQUN6REMsSUFBSSxDQUFFdHFCLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixtQkFBZ0IsQ0FBQzRxQixZQUFZLENBQ3hELENBQUMsQ0FDRCxDQUNFSCxLQUFLLENBQUVwcUIsSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1CQUFnQixDQUFDNnFCLFlBQVksQ0FBQyxDQUN4REYsSUFBSSxDQUFFdHFCLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixtQkFBZ0IsQ0FBQzhxQixXQUFXLENBQ3ZELENBQUMsQ0FDRCxDQUNFTCxLQUFLLENBQUVwcUIsSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1CQUFnQixDQUFDK3FCLFlBQVksQ0FBQyxDQUN4REosSUFBSSxDQUFFdHFCLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixtQkFBZ0IsQ0FBQ2dyQixXQUFXLENBQ3ZELENBQUMsQ0FDRCxDQUNFUCxLQUFLLENBQUVwcUIsSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1CQUFnQixDQUFDaXJCLFFBQVEsQ0FBQyxDQUNwRE4sSUFBSSxDQUFFdHFCLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixtQkFBZ0IsQ0FBQ2tyQixPQUFPLENBQ25ELENBQUMsQ0FDRCxDQUNFVCxLQUFLLENBQUVwcUIsSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1CQUFnQixDQUFDbXJCLFFBQVEsQ0FBQyxDQUNwRFIsSUFBSSxDQUFFdHFCLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixtQkFBZ0IsQ0FBQ29yQixPQUFPLENBQ25ELENBQUMsQ0FDRCxDQUNFWCxLQUFLLENBQUVwcUIsSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1CQUFnQixDQUFDcXJCLFFBQVEsQ0FBQyxDQUNwRFYsSUFBSSxDQUFFdHFCLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixtQkFBZ0IsQ0FBQ3NyQixPQUFPLENBQ25ELENBQUMsQ0FDRCxDQUNFYixLQUFLLENBQUVwcUIsSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1CQUFnQixDQUFDdXJCLFFBQVEsQ0FBQyxDQUNwRFosSUFBSSxDQUFFdHFCLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixtQkFBZ0IsQ0FBQ3dyQixPQUFPLENBQ25ELENBQUMsQ0FDRCxDQUNFZixLQUFLLENBQUVwcUIsSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1CQUFnQixDQUFDeXJCLFFBQVEsQ0FBQyxDQUNwRGQsSUFBSSxDQUFFdHFCLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixtQkFBZ0IsQ0FBQzByQixPQUFPLENBQ25ELENBQUMsQ0FDRixDQUNEO0FBQ0EsS0FBTSxDQUFBQyx3QkFBd0IsQ0FBRyxDQUMvQiwwQkFBMEIsQ0FDMUIsMEJBQTBCLENBQzFCLDBCQUEwQixDQUMxQiwwQkFBMEIsQ0FDMUIsMEJBQTBCLENBQzFCLDBCQUEwQixDQUMxQiwwQkFBMEIsQ0FDMUIsMEJBQTBCLENBQzNCLENBRUQsbUJBQ0Voc0IsbUJBQUEsUUFBS1ksU0FBUyxDQUFFTix1QkFBK0IsZUFDN0NOLG1CQUFBLFFBQUtZLFNBQVMsQ0FBRSxtQ0FBb0MsRUFDakRpcUIsV0FBVyxDQUFDOWYsR0FBRyxDQUFDLENBQUNtaEIsU0FBUyxDQUFFamhCLEtBQUssZ0JBQ2hDakwsbUJBQUEsV0FDRWdELEVBQUUsQ0FBRWtwQixTQUFTLENBQUNwQixLQUFNLENBQ3BCNWYsR0FBRyxDQUFFZ2hCLFNBQVMsQ0FBQ3BCLEtBQ2Y7QUFBQSxDQUNBcUIsY0FBYyxDQUFHdkcsQ0FBQyxFQUFLcmIsT0FBTyxDQUFDcWIsQ0FBQyxDQUFFLENBQ2xDaGxCLFNBQVMsQ0FBRSxxQkFBcUIsQ0FBR29yQix3QkFBd0IsQ0FBQy9nQixLQUFLLENBQUUsQ0FDbkVoQixLQUFLLENBQUU0Z0IsV0FBVyxDQUFDNWYsS0FBSyxDQUFDLENBQUMrZixJQUFLLENBQy9CLGFBQVl0cUIsSUFBSSxDQUFDSyxhQUFhLENBQzFCLENBQ0VpQyxFQUFFLENBQUUsNEJBQTRCLENBQ2hDdUMsY0FBYyxDQUFFLHNCQUFzQixDQUN0Q0QsV0FBVyxDQUFFLDZDQUNmLENBQUMsQ0FDRCxDQUNFNG1CLFNBQVMsQ0FBRUEsU0FBUyxDQUFDbEIsSUFDdkIsQ0FDSixDQUFFLGVBQ0ZockIsbUJBQUEsU0FBTVksU0FBUyxDQUFFLG9CQUFxQixDQUFDLGNBQWEsSUFBSyxDQUFDLENBQ3BELENBQ1YsQ0FDRyxDQUNGLENBQUMsQ0FFVixDQUFDLENBRUQsMERBQWVncUIscUJBQXFCLEU7O0FDMUZwQztBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwQkFBWTtBQUNoQixrRTs7QUNUUDtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGOztBQ1BQLG9EQUFlLG9CQUFvQjs7QUNPbkM7QUFZQSxLQUFNLENBQUEyQixpQkFBaUIsQ0FBRzlyQixJQUFBLEVBUXJCLElBUnNCLENBQ3pCRyxTQUFTLENBQ1Q0ckIsV0FBVyxDQUNYQyxZQUFZLENBQ1pDLHNCQUFzQixDQUN0QkMsa0JBQWtCLENBQ2xCQyxXQUNrQixDQUFDLENBQUFuc0IsSUFBQSxDQUVuQixLQUFNLEdBQUNvc0IsYUFBYSxHQUFFQyxnQkFBZ0IsRUFBSWpqQixrQkFBUSxDQUFTLENBQUMsQ0FBQyxDQUU3RDZYLG1CQUFTLENBQUMsSUFBTSxDQUNkO0FBQ0EsR0FBSW1MLGFBQWEsQ0FBR0wsV0FBVyxDQUFDL25CLE1BQU0sQ0FBRSxDQUN0QyxLQUFNLENBQUFzb0IsU0FBUyxDQUFHQyxRQUFRLENBQUNDLGNBQWMsQ0FBQyw4QkFBOEIsQ0FBQyxDQUN6RSxHQUFJRixTQUFTLENBQUVBLFNBQVMsQ0FBQ0csU0FBUyxDQUFHSCxTQUFTLENBQUNJLFlBQVksQ0FDN0QsQ0FDQUwsZ0JBQWdCLENBQUNOLFdBQVcsQ0FBQy9uQixNQUFNLENBQUMsQ0FDdEMsQ0FBQyxDQUFFLENBQUMrbkIsV0FBVyxDQUFFSyxhQUFhLENBQUMsQ0FBQyxDQUVoQztBQUNGO0FBQ0EsS0FDRSxLQUFNLENBQUFPLGtCQUFrQixDQUFHQSxDQUFBLEdBQU0sQ0FDL0IsR0FBSVosV0FBVyxDQUFDL25CLE1BQU0sR0FBSyxDQUFDLENBQUUsQ0FDNUI7QUFBQSxDQUNELElBQU0sQ0FDTDtBQUFBLENBRUosQ0FBQyxDQUVELG1CQUNFekUsbUJBQUEsUUFBS2dELEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQ3BDLFNBQVMsQ0FBRUEsU0FBVSxlQUNqRFosbUJBQUEsUUFBS1ksU0FBUyxDQUFFTixxQkFBNkIsZUFDM0NOLG1CQUFBLFdBQUksZUFBaUIsQ0FBQyxDQUNyQjBzQixzQkFBc0IsY0FDckIxc0IsbUJBQUEsQ0FBQ29zQixTQUFLLEVBQUMzb0IsSUFBSSxDQUFDLE9BQU8sQ0FBQzZwQixJQUFJLE1BQUN4c0IsWUFBWSxDQUFDLElBQUksRUFBQyw0QkFDZixDQUFDMnJCLFlBQVksQ0FBQyx1QkFDbkMsQ0FBQyxjQUNSenNCLG1CQUFBLENBQUNvc0IsU0FBSyxFQUFDM29CLElBQUksQ0FBQyxNQUFNLENBQUM2cEIsSUFBSSxNQUFDeHNCLFlBQVksQ0FBQyxJQUFJLEVBQUMsU0FDakMsY0FBQWQsbUJBQUEsZUFBUSxRQUFNLENBQUN5c0IsWUFBcUIsQ0FBQyxxQkFDdkMsQ0FBQyxjQUVWenNCLG1CQUFBLHVCQUNFQSxtQkFBQSwwQkFBTUEsbUJBQUEsZUFBU3dzQixXQUFXLENBQUMvbkIsTUFBTSxDQUFDLFFBQU0sQ0FBQytuQixXQUFXLENBQUMvbkIsTUFBTSxHQUFLLENBQUMsQ0FBRyxFQUFFLENBQUcsR0FBWSxDQUFDLFlBQWUsQ0FDcEcsQ0FBQyxjQUNKekUsbUJBQUEsUUFBS2dELEVBQUUsQ0FBQyw4QkFBOEIsQ0FBQ3BDLFNBQVMsQ0FBRU4sa0JBQTBCLEVBQ3pFa3NCLFdBQVcsQ0FBQ3poQixHQUFHLENBQUMsQ0FBQ3lpQixJQUFJLENBQUV2aUIsS0FBSyxnQkFDM0JqTCxtQkFBQSxDQUFDcXNCLFFBQUksRUFBQ29CLEdBQUcsTUFBQ3ZpQixHQUFHLENBQUVELEtBQU0sQ0FDbkJySyxTQUFTLENBQUVxSyxLQUFLLEdBQUt1aEIsV0FBVyxDQUFDL25CLE1BQU0sQ0FBRyxDQUFDLENBQUduRSxzQkFBNkIsQ0FBR0EsYUFBcUIsZUFDbkdOLG1CQUFBLENBQUNxc0IsUUFBSSxFQUFDdUIsR0FBRyxDQUFDLE1BQU0sRUFDYkosSUFBSSxDQUFDeHFCLEVBQUUsQ0FBQyxJQUFFLENBQUN3cUIsSUFBSSxDQUFDamlCLFVBQVUsQ0FBQ25KLDZCQUFvQixDQUFRLENBQUMsY0FDM0RwQyxtQkFBQSxDQUFDcXNCLFFBQUksRUFBQ3VCLEdBQUcsQ0FBQyxNQUFNLENBQUUsQ0FBQyxjQUNuQjV0QixtQkFBQSxDQUFDcXNCLFFBQUksRUFBQ3VCLEdBQUcsQ0FBQyxNQUFNLENBQUNodEIsU0FBUyxDQUFFTixtQkFBMkIsZUFDckROLG1CQUFBLENBQUN5TyxVQUFNLEVBQUNoTCxJQUFJLENBQUMsUUFBUSxDQUFDcXFCLFFBQVEsTUFDNUJ2akIsT0FBTyxDQUFFQSxDQUFBLEdBQU1vaUIsa0JBQWtCLENBQUNhLElBQUksQ0FBRSxlQUN4Q3h0QixtQkFBQSxRQUFLa0IsUUFBUSxDQUFFLENBQUUsQ0FBQ0MsR0FBRyxDQUFFbXJCLGVBQVcsQ0FDaENsckIsR0FBRyxDQUFDLGtCQUFrQixDQUN2QixDQUNLLENBQ0osQ0FDRixDQUNQLENBQ0UsQ0FBQyxjQUNOcEIsbUJBQUEsUUFBS1ksU0FBUyxDQUFFTixrQkFBMEIsZUFDeENOLG1CQUFBLENBQUN5TyxVQUFNLEVBQUNoTCxJQUFJLENBQUMsUUFBUSxDQUFDOEcsT0FBTyxDQUFFNmlCLGtCQUFtQixDQUNoRFksUUFBUSxDQUFFeEIsV0FBVyxDQUFDL25CLE1BQU0sRUFBSSxDQUFFLEVBQUMsZUFBcUIsQ0FDdkQsQ0FBQyxjQUNOekUsbUJBQUEsUUFBS1ksU0FBUyxDQUFFTixTQUFpQixlQUMvQk4sbUJBQUEsQ0FBQ3lPLFVBQU0sRUFBQ2hMLElBQUksQ0FBQyxRQUFRLENBQUNxcUIsUUFBUSxNQUFDdmpCLE9BQU8sQ0FBRXFpQixXQUFZLEVBQUMsWUFBa0IsQ0FDcEUsQ0FDRixDQUNGLENBQUMsQ0FFVixDQUFDLENBRUQsd0VBQWVMLGlCQUFpQixFOztBQzdGaEMsaUVBQWVBLG1DQUFpQixFOztBQ0ZoQyxnQ0FDQSxtQ0FDQTtBQXFCQTtBQUdBO0FBUUE7QUFnQkMsQ0FRQSxDQVNELEtBQU0sQ0FBQXVDLG1CQUFtQixDQUFHLEVBQUUsQ0FFOUIsS0FBTSxDQUFBQyxNQUFNLENBQUd0dUIsSUFBQSxFQUErQixLQUFBdXVCLGVBQUEsSUFBOUIsQ0FBQ0MsUUFBdUIsQ0FBQyxDQUFBeHVCLElBQUEsQ0FDdkM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxLQUFNLENBQUN5dUIsSUFBSSxDQUFFbEwsR0FBRyxDQUFFbUwsR0FBRyxDQUFDLENBQUdGLFFBQVEsQ0FBQzlOLElBQUksQ0FBQ3hjLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQ3lxQixLQUFLLENBQUMsR0FBRyxDQUFDLENBRTFEO0FBQ0Y7QUFDQTtBQUNBLEtBQ0UsS0FBTSxHQUFDQyxRQUFRLEdBQUVDLFdBQVcsRUFBSXpsQixrQkFBUSxDQUFnQixDQUN0RDBsQixRQUFRLENBQUV2TCxHQUFHLEVBQUk5YyxVQUFVLENBQUM4YyxHQUFHLENBQUMsQ0FBRzljLFVBQVUsQ0FBQzhjLEdBQUcsQ0FBQyxDQUFHNWhCLGlDQUF3QixDQUFDLENBQUMsQ0FBQyxDQUNoRnF0QixTQUFTLENBQUVOLEdBQUcsRUFBSWpvQixVQUFVLENBQUNpb0IsR0FBRyxDQUFDLENBQUdqb0IsVUFBVSxDQUFDaW9CLEdBQUcsQ0FBQyxDQUFHL3NCLGlDQUF3QixDQUFDLENBQUMsQ0FBQyxDQUNqRjhzQixJQUFJLENBQUVBLElBQUksRUFBSWhvQixVQUFVLENBQUNnb0IsSUFBSSxDQUFDLENBQUdob0IsVUFBVSxDQUFDZ29CLElBQUksQ0FBQyxDQUFHOXNCLGtDQUN0RCxDQUFDLENBQUMsQ0FFRixLQUFNLEdBQUM4a0IsZ0JBQWdCLEdBQUV5SSxtQkFBbUIsRUFBSTlsQixrQkFBUSxDQUFzQixFQUFFLENBQUMsQ0FDakYsS0FBTSxHQUFDK2xCLGNBQWMsR0FBRUMsaUJBQWlCLEVBQUlobUIsa0JBQVEsQ0FBdUIsQ0FBQyxDQUM1RSxLQUFNLEdBQUNpbUIsb0JBQW9CLEdBQUVDLHVCQUF1QixFQUFJbG1CLGtCQUFRLENBQVUsS0FBSyxDQUFDLENBQ2hGLEtBQU0sR0FBQ21tQixxQkFBcUIsR0FBRUMsd0JBQXdCLEVBQUlwbUIsa0JBQVEsQ0FBVSxLQUFLLENBQUMsQ0FDbEYsS0FBTSxHQUFDcW1CLGdCQUFnQixHQUFFQyxtQkFBbUIsRUFBSXRtQixrQkFBUSxDQUFVLEtBQUssQ0FBQyxDQUN4RSxLQUFNLEdBQUN1bUIsaUJBQWlCLEdBQUVDLG9CQUFvQixFQUFJeG1CLGtCQUFRLENBQVUsS0FBSyxDQUFDLENBQzFFLEtBQU0sR0FBQzZpQixzQkFBc0IsR0FBRTRELHlCQUF5QixFQUFJem1CLGtCQUFRLENBQVUsS0FBSyxDQUFDLENBQ3BGLEtBQU0sR0FBQzBtQixhQUFhLEdBQUVDLGdCQUFnQixFQUFJM21CLGtCQUFRLENBQXFCd0IsU0FBUyxDQUFDLENBQ2pGLEtBQU0sQ0FBQ3NULEtBQUssQ0FBRUMsV0FBVyxDQUFDLENBQUdiLGdDQUFhLENBQUMsQ0FBQyxDQUU1QztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRTtBQUNBLEtBQU0sQ0FBQzBTLGlCQUFpQixDQUFFQyxvQkFBb0IsQ0FBRUMsbUJBQW1CLENBQUMsQ0FBRzlCLG1CQUFlLENBQUMscUJBQXFCLENBQUUsS0FBSyxDQUFFLENBQUMrQixHQUFHLENBQUUsSUFBSSxDQUFDLENBQUMsQ0FFakksS0FBTSxDQUFBQyxNQUFNLENBQUczQyxnQkFBTSxDQUFTLElBQUksQ0FBQyxDQUNuQyxLQUFNLENBQUEvSCxLQUFLLENBQUdKLGdDQUFRLENBQUMsQ0FBQyxDQUN4QixLQUFNLENBQUFybEIsSUFBSSxDQUFHTiw4QkFBTyxDQUFDLENBQUMsQ0FFdEIsS0FBTSxDQUFBMHdCLGNBQWMsRUFBQTlCLGVBQUEsQ0FBRzZCLE1BQU0sQ0FBQ0UsT0FBTyxVQUFBL0IsZUFBQSxpQkFBZEEsZUFBQSxDQUFnQmdDLE1BQU0sQ0FBQyxDQUFDLENBQUNDLEtBQUssQ0FBQ0MsZUFBZSxDQUFDLENBQUMsQ0FFdkU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxLQUNFLEtBQU0sQ0FBQUMsZUFBZSxDQUFJM0UsV0FBZ0MsRUFBZSxDQUN0RSxHQUFJQSxXQUFXLENBQUMvbkIsTUFBTSxHQUFLLENBQUMsQ0FBRSxDQUM1QixLQUFNLElBQUksQ0FBQTJLLEtBQUssQ0FBQyw4REFBOEQsQ0FBQyxDQUNqRixDQUVBO0FBQ0EsS0FBTSxDQUFBZ2lCLFVBQW9CLENBQUcsRUFBRSxDQUMvQixLQUFNLENBQUFDLFVBQW9CLENBQUcsRUFBRSxDQUMvQixLQUFNLENBQUFDLFVBQW9CLENBQUcsRUFBRSxDQUMvQixLQUFNLENBQUFDLFVBQW9CLENBQUcsRUFBRSxDQUMvQi9FLFdBQVcsQ0FBQ2dGLE9BQU8sQ0FBRUMsT0FBTyxFQUFLLENBQy9CLEtBQU0sQ0FBQ0MsVUFBVSxDQUFFQyxVQUFVLENBQUVDLFVBQVUsQ0FBRUMsVUFBVSxDQUFDLENBQUduRCxFQUFJLENBQUMrQyxPQUFPLENBQUMsQ0FDdEVMLFVBQVUsQ0FBQ1UsSUFBSSxDQUFDSixVQUFVLENBQUMsQ0FDM0JMLFVBQVUsQ0FBQ1MsSUFBSSxDQUFDSCxVQUFVLENBQUMsQ0FDM0JMLFVBQVUsQ0FBQ1EsSUFBSSxDQUFDRixVQUFVLENBQUMsQ0FDM0JMLFVBQVUsQ0FBQ08sSUFBSSxDQUFDRCxVQUFVLENBQUMsQ0FDN0IsQ0FBQyxDQUFDLENBQ0YsS0FBTSxDQUFBRSxNQUFjLENBQUdqc0IsSUFBSSxDQUFDa3NCLEdBQUcsQ0FBQUMsS0FBQSxDQUFSbnNCLElBQUksQ0FBUXNyQixVQUFVLENBQUMsQ0FDOUMsS0FBTSxDQUFBYyxNQUFjLENBQUdwc0IsSUFBSSxDQUFDcXNCLEdBQUcsQ0FBQUYsS0FBQSxDQUFSbnNCLElBQUksQ0FBUXVyQixVQUFVLENBQUMsQ0FDOUMsS0FBTSxDQUFBZSxNQUFjLENBQUd0c0IsSUFBSSxDQUFDcXNCLEdBQUcsQ0FBQUYsS0FBQSxDQUFSbnNCLElBQUksQ0FBUXdyQixVQUFVLENBQUMsQ0FDOUMsS0FBTSxDQUFBZSxNQUFjLENBQUd2c0IsSUFBSSxDQUFDa3NCLEdBQUcsQ0FBQUMsS0FBQSxDQUFSbnNCLElBQUksQ0FBUXlyQixVQUFVLENBQUMsQ0FDOUMsTUFBTyxDQUFDUSxNQUFNLENBQUVHLE1BQU0sQ0FBRUUsTUFBTSxDQUFFQyxNQUFNLENBQUMsQ0FDekMsQ0FBQyxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxLQUFNLENBQUFDLHNCQUFzQixDQUFHQSxDQUFDYixPQUEwQixDQUFFYyxhQUFzQixHQUEwQixDQUMxRyxHQUFJLENBQUNkLE9BQU8sQ0FBRSxNQUFPLENBQUF2SyxnQkFBZ0IsQ0FFckM7QUFDQSxLQUFNLENBQUFzTCxNQUFNLENBQUd0TCxnQkFBZ0IsQ0FBQzdMLElBQUksQ0FBRW1TLElBQUksRUFBS0EsSUFBSSxDQUFDeHFCLEVBQUUsR0FBS3l1QixPQUFPLENBQUN6dUIsRUFBRSxDQUFDLENBQ3RFLEdBQUksQ0FBQXdwQixXQUFnQyxDQUFHdEYsZ0JBQWdCLENBQ3ZELEdBQUlzTCxNQUFNLENBQUUsQ0FDVmhHLFdBQVcsQ0FBR3RGLGdCQUFnQixDQUFDaE0sTUFBTSxDQUFFc1MsSUFBSSxFQUFLQSxJQUFJLENBQUN4cUIsRUFBRSxHQUFLeXVCLE9BQU8sQ0FBQ3p1QixFQUFFLENBQUMsQ0FDdkVzdEIseUJBQXlCLENBQUMsS0FBSyxDQUFDLENBQ2xDLENBQUMsSUFBTSxJQUFJcEosZ0JBQWdCLENBQUN6aUIsTUFBTSxDQUFHcXFCLG1CQUFtQixDQUFFLENBQ3hEO0FBQ0E7QUFDQXRDLFdBQVcsQ0FBRytGLGFBQWEsSUFBQWxMLE1BQUEsQ0FBQUMsb0NBQUEsQ0FDckJKLGdCQUFnQixHQUFFdUssT0FBTyxHQUM3QixDQUFDQSxPQUFPLENBQUMsQ0FDYixDQUFDLElBQU0sQ0FDTG5CLHlCQUF5QixDQUFDLElBQUksQ0FBQyxDQUNqQyxDQUNBWCxtQkFBbUIsQ0FBQ25ELFdBQVcsQ0FBQyxDQUVoQyxHQUFJLENBQUM0RCxpQkFBaUIsQ0FBRSxDQUN0QjtBQUNBQyxvQkFBb0IsQ0FBQzdELFdBQVcsQ0FBQy9uQixNQUFNLENBQUcsQ0FBQyxDQUFDLENBQzlDLENBRUEsTUFBTyxDQUFBK25CLFdBQVcsQ0FDcEIsQ0FBQyxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsS0FDRSxLQUFNLENBQUFpRyxtQkFBbUIsQ0FBRyxRQUFBQSxDQUFDaEIsT0FBb0IsQ0FBRWlCLG9CQUE2QixDQUFhLElBQTFDQSxvQkFBNkIsV0FBN0JBLG9CQUE2QixDQUFHLEtBQUssRUFDdEYsS0FBTSxDQUFBQyxZQUFZLENBQUdMLHNCQUFzQixDQUFDYixPQUFPLENBQUVpQixvQkFBb0IsRUFBSXRDLGlCQUFpQixDQUFDLENBQy9GLEdBQUl1QyxZQUFZLENBQUNsdUIsTUFBTSxDQUFHLENBQUMsQ0FBRSxDQUMzQixLQUFNLENBQUNzdEIsTUFBTSxDQUFFRyxNQUFNLENBQUVFLE1BQU0sQ0FBRUMsTUFBTSxDQUFDLENBQUdsQixlQUFlLENBQUN3QixZQUFZLENBQUMsQ0FFdEU7QUFDQTdRLFNBQVMsQ0FBQyxDQUNSLENBQUNpUSxNQUFNLENBQUVHLE1BQU0sQ0FBQyxDQUNoQixDQUFDRSxNQUFNLENBQUVDLE1BQU0sQ0FBQyxDQUNqQixDQUFDLENBRUY7QUFDTjtBQUNBLFNBQ007QUFDQSxLQUFNLENBQUFPLFdBQVcsQ0FBRyxHQUFJLENBQUF4RSxtQkFBbUIsQ0FBQyxDQUFDcE0sTUFBTSxDQUFFcU4sUUFBUSxDQUFDck4sTUFBTyxDQUFFckQsS0FBSyxDQUFFMFEsUUFBUSxDQUFDMVEsS0FBTSxDQUFDLENBQUMsQ0FFL0Y7QUFDQSxLQUFNLENBQUM4USxTQUFTLENBQUVGLFFBQVEsQ0FBRUwsSUFBSSxDQUFDLENBQUcwRCxXQUFXLENBQUNDLFNBQVMsQ0FDckQsQ0FDRSxDQUFDZCxNQUFNLENBQUVHLE1BQU0sQ0FBQyxDQUNoQixDQUFDRSxNQUFNLENBQUVDLE1BQU0sQ0FBQyxDQUNqQixDQUNELENBQ0VTLE9BQU8sQ0FBRSxFQUNYLENBQ0osQ0FBQyxDQUVEO0FBQ0EsS0FBTSxDQUFBQyxTQUFTLENBQUcsQ0FDaEJ0RCxTQUFTLENBQUVBLFNBQVMsQ0FDcEJGLFFBQVEsQ0FBRUEsUUFBUSxDQUNsQkwsSUFBSSxDQUFFQSxJQUFJLENBQ1YzakIsVUFBVSxDQUFFa21CLE9BQU8sQ0FBQ2xtQixVQUN0QixDQUFDLENBRUQ7QUFDQXNrQixpQkFBaUIsQ0FBQ2tELFNBQVMsQ0FBQyxDQUU1QjtBQUNOO0FBQ0EsU0FDSSxDQUNGLENBQUMsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUNFLEtBQU0sQ0FBQXhvQixPQUFPLENBQUl5YSxLQUFxRCxFQUFLLEtBQUFnTyxnQkFBQSxDQUFBeHZCLEtBQUEsQ0FDekU7QUFDQXdoQixLQUFLLENBQUNDLGNBQWMsQ0FBQyxDQUFDLENBQ3RCLENBQUErTixnQkFBQSxFQUFBeHZCLEtBQUEsQ0FBQ3doQixLQUFLLEVBQXlDRSxlQUFlLFVBQUE4TixnQkFBQSxpQkFBOURBLGdCQUFBLENBQUFDLElBQUEsQ0FBQXp2QixLQUFpRSxDQUFDLENBRWxFO0FBQ0E7QUFDQTtBQUNBLEdBQUl3aEIsS0FBSyxDQUFDOUgsTUFBTSxFQUFLOEgsS0FBSyxDQUFDOUgsTUFBTSxDQUFpQmxhLEVBQUUsQ0FBRSxDQUNwRCxLQUFNLENBQUFrd0IsUUFBUSxDQUFHbE8sS0FBSyxDQUFDOUgsTUFBTSxFQUFLOEgsS0FBSyxDQUFDOUgsTUFBTSxDQUFpQmxhLEVBQUUsQ0FFakUsT0FBUWt3QixRQUFRLEVBQ2QsSUFBSyxJQUFJLENBQ1BwUixTQUFTLENBQUMxZixrQ0FBeUIsQ0FBRSxJQUFJLENBQUMsQ0FDMUMsTUFDRixJQUFLLElBQUksQ0FDUDBmLFNBQVMsQ0FBQzFmLGdDQUF1QixDQUFFLElBQUksQ0FBQyxDQUN4QyxNQUNGLElBQUssSUFBSSxDQUNQMGYsU0FBUyxDQUFDMWYsZ0NBQXVCLENBQUUsSUFBSSxDQUFDLENBQ3hDLE1BQ0YsSUFBSyxJQUFJLENBQ1AwZixTQUFTLENBQUMxZixxQ0FBNEIsQ0FBRSxJQUFJLENBQUMsQ0FDN0MsTUFDRixJQUFLLElBQUksQ0FDUDBmLFNBQVMsQ0FBQzFmLDhCQUFxQixDQUFFLElBQUksQ0FBQyxDQUN0QyxNQUNGLElBQUssSUFBSSxDQUNQMGYsU0FBUyxDQUFDMWYsd0NBQStCLENBQUUsSUFBSSxDQUFDLENBQ2hELE1BQ0YsSUFBSyxJQUFJLENBQ1AwZixTQUFTLENBQUMxZix3Q0FBK0IsQ0FBRSxJQUFJLENBQUMsQ0FDaEQsTUFDRixJQUFLLElBQUksQ0FDUDBmLFNBQVMsQ0FBQzFmLDBDQUFrQyxDQUFFLElBQUksQ0FBQyxDQUNuRCxNQUVGLFFBQ0UsTUFDSixDQUNGLENBQUMsSUFBTSxJQUFJNGlCLEtBQUssQ0FBQzlILE1BQU0sRUFBSzhILEtBQUssQ0FBQzlILE1BQU0sQ0FBaUJ5VyxRQUFRLEVBQUksS0FBSyxDQUFFLENBQzFFO0FBQ0E7QUFFQTtBQUNBLEtBQU0sQ0FBQWxDLE9BQU8sQ0FBR3pNLEtBQUssQ0FBQzRPLFFBQVEsRUFBSTVPLEtBQUssQ0FBQzRPLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FFbkQ7QUFDQW5CLG1CQUFtQixDQUFDaEIsT0FBTyxDQUFFek0sS0FBSyxDQUFDNk8sUUFBUSxDQUFDQyxPQUFPLENBQUMsQ0FDdEQsQ0FDRixDQUFDLENBRUQsS0FBTSxDQUFBQyxNQUFNLENBQUdBLENBQUEsR0FBTSxDQUNuQixHQUFJLE1BQU8sQ0FBQUMsTUFBTSxHQUFLLFdBQVcsRUFBSUEsTUFBTSxDQUFDQyxPQUFPLEVBQUlwRCxNQUFNLENBQUNFLE9BQU8sQ0FBRSxDQUNyRWlELE1BQU0sQ0FBQ0UsYUFBYSxDQUFHckQsTUFBTSxDQUFDRSxPQUFPLENBQUNDLE1BQU0sQ0FBQyxDQUFDLENBQ2hELENBRUE7QUFDQUwsbUJBQW1CLENBQUMsQ0FBQyxDQUVyQixHQUFJL0IseUJBQVEsQ0FBRXVCLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUN6QyxDQUFDLENBR0Q7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLEtBQU0sQ0FBQXJPLFNBQVMsQ0FBRyxRQUFBQSxDQUFDcVMsTUFBd0IsQ0FBRWhaLFdBQVcsQ0FBVW9WLGFBQWlDLENBQWlCLElBQXZFcFYsV0FBVyxXQUFYQSxXQUFXLENBQUcsS0FBSyxLQUFFb1YsYUFBaUMsV0FBakNBLGFBQWlDLENBQUdsbEIsU0FBUyxFQUM3RyxLQUFNLENBQUF1bkIsV0FBVyxDQUFHLEdBQUksQ0FBQXhFLG1CQUFtQixDQUFDLENBQUNwTSxNQUFNLENBQUVxTixRQUFRLENBQUNyTixNQUFPLENBQUVyRCxLQUFLLENBQUUwUSxRQUFRLENBQUMxUSxLQUFNLENBQUMsQ0FBQyxDQUMvRixLQUFNLENBQUM4USxTQUFTLENBQUVGLFFBQVEsQ0FBRUwsSUFBSSxDQUFDLENBQUcwRCxXQUFXLENBQUNDLFNBQVMsQ0FDdkRzQixNQUFNLENBQTBDLENBQ2hEO0FBQ0E7QUFBQSxDQUNDLENBQUMsQ0FFSjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSTtBQUNBLEtBQU0sQ0FBQUMseUJBQXlCLENBQUlsRixJQUFJLENBQUcsQ0FBQyxDQUFJOXNCLGlEQUF3QyxDQUFHLEVBQUUsQ0FDMUZBLGlEQUF3QyxDQUN4QzhzQixJQUFJLENBQUcsQ0FBQyxDQUVWSSxXQUFXLENBQUMsQ0FDVixHQUFHRCxRQUFRLENBQ1hJLFNBQVMsQ0FDVEYsUUFBUSxDQUNSTCxJQUFJLENBQUUvVCxXQUFXLENBQUcrVCxJQUFJLENBQUdrRix5QkFBeUIsQ0FDcERDLGtCQUFrQixDQUFFLElBQUksQ0FDeEJDLHNCQUFzQixDQUFFLEdBQUksQ0FBQTlGLHlCQUFpQixDQUFDLENBQUMsQ0FDL0MrRixnQkFBZ0IsQ0FBRTVGLFVBQ3BCLENBQUMsQ0FBQyxDQUVGO0FBQ0E2QixnQkFBZ0IsQ0FBQ0QsYUFBYSxDQUFDLENBQ2pDLENBQUMsQ0FFRCxLQUFNLENBQUFrRSxpQkFBaUIsQ0FBR0EsQ0FBQSxHQUFNLENBQzlCMUUsdUJBQXVCLENBQUMsSUFBSSxDQUFDLENBQy9CLENBQUMsQ0FFRCxLQUFNLENBQUEyRSxlQUFlLENBQUdBLENBQUEsR0FBTSxDQUM1QjNFLHVCQUF1QixDQUFDLEtBQUssQ0FBQyxDQUU5QjtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQ0ksR0FBSVEsYUFBYSxDQUFFLEtBQUFvRSxnQkFBQSxDQUNqQjtBQUNBLEtBQU0sQ0FBQUMsa0JBQWtCLEVBQUFELGdCQUFBLENBQUc5RCxNQUFNLENBQUNFLE9BQU8sVUFBQTRELGdCQUFBLGlCQUFkQSxnQkFBQSxDQUFnQjNELE1BQU0sQ0FBQyxDQUFDLENBQzlDNkQsbUJBQW1CLENBQUN6eUIsd0NBQStCLENBQUUsQ0FDcEQweUIsV0FBVyxDQUFFMXlCLHFDQUE0QixDQUN6QzJ5QixRQUFRLENBQUUsSUFBSSxDQUNkN1osTUFBTSxDQUFFLENBQUMsSUFBSSxDQUFFOVksaUNBQXdCLENBQUVtdUIsYUFBYSxDQUN4RCxDQUFDLENBQUMsQ0FDTixHQUFJcUUsa0JBQWtCLEVBQUlBLGtCQUFrQixDQUFDbndCLE1BQU0sQ0FBRyxDQUFDLENBQUUsQ0FDdkQ7QUFDQWd1QixtQkFBbUIsQ0FBQ21DLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQzVDLENBQ0FwRSxnQkFBZ0IsQ0FBQ25sQixTQUFTLENBQUMsQ0FDN0IsQ0FDRixDQUFDLENBRUQsS0FBTSxDQUFBMnBCLFdBQVcsQ0FBR0EsQ0FBQSxHQUFNLENBQ3hCL0Usd0JBQXdCLENBQUMsS0FBSyxDQUFDLENBRS9CO0FBQ0FTLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUM1QixDQUFDLENBRUQsS0FBTSxDQUFBdUUsZ0JBQWdCLENBQUdBLENBQUEsR0FBTSxDQUM3QmhGLHdCQUF3QixDQUFDLElBQUksQ0FBQyxDQUNoQyxDQUFDLENBRUQ7QUFDRjtBQUNBO0FBQ0EsS0FDRSxLQUFNLENBQUFpRixtQkFBbUIsQ0FBSXpELE9BQTBCLEVBQUssQ0FDMURhLHNCQUFzQixDQUFDYixPQUFPLENBQUUsSUFBSSxDQUFDLENBQ3ZDLENBQUMsQ0FFRDtBQUNGO0FBQ0EsS0FDRSxLQUFNLENBQUEwRCxZQUFZLENBQUdBLENBQUEsR0FBTSxDQUN6QjtBQUNBeEYsbUJBQW1CLENBQUMsRUFBRSxDQUFDLENBQ3ZCRSxpQkFBaUIsQ0FBQ3hrQixTQUFTLENBQUMsQ0FDNUJnbEIsb0JBQW9CLENBQUMsS0FBSyxDQUFDLENBQzdCLENBQUMsQ0FFRCxtQkFDRXJ3QixtQkFBQSxDQUFBQSxjQUFBLG1CQUNFQSxtQkFBQSxDQUFDcXNCLFFBQUksRUFBQytJLE9BQU8sQ0FBRSxDQUFDeEgsR0FBRyxDQUFFLENBQUMsQ0FBRSxDQUFDaHRCLFNBQVMsQ0FBRU4sTUFBYyxlQTBCaEROLG1CQUFBLENBQUNtdUIsZUFDQztBQUNBO0FBQUEsQ0FBQW1ILE1BQUEsQ0FBQUMsTUFBQSxFQUNBQyxvQkFBb0IsQ0FDbEJuUCxJQUFXLENBQUNvUCx3QkFBd0IsQ0FDbENwUCxJQUFXLENBQUNvUCx3QkFBd0IsQ0FBRyxFQUUzQztBQUNBO0FBQUEsRUFDSXBHLFFBQVEsRUFDWnFHLFFBQVEsQ0FDTnJQLElBQVcsQ0FBQ29QLHdCQUF3QixDQUNsQyxxREFBcUQsQ0FDckQsOERBQ0gsQ0FDRDlXLEtBQUssQ0FBQyxNQUNOO0FBQ0E7QUFBQSxDQUNBcUQsTUFBTSxDQUFDLE1BQU0sQ0FDYjJULFVBQVUsQ0FBRSxDQUFDeFUsSUFBSSxDQUFFLElBQUksQ0FHdkI7QUFDQTtBQUFBLENBQ0F5VSxPQUFPLENBQUV4ekIsa0NBQTBCLENBQ25DMHpCLE9BQU8sQ0FBRTF6QixrQ0FBMEIsQ0FDbkMyekIsVUFBVSxDQUFFLEtBQU0sQ0FDbEJDLFdBQVcsQ0FBRSxLQUNiO0FBQUEsQ0FDQUMsbUJBQW1CLENBQ2pCLENBQ0U3ekIscUNBQTRCLENBQzVCQSxpREFBd0MsQ0FLNUM7QUFDQTtBQUFBLENBQ0E4ekIsZ0JBQWdCLENBQUU1RyxXQUFZLENBQzlCL2tCLE9BQU8sQ0FBRUEsT0FBUSxDQUNqQndwQixNQUFNLENBQUVBLE1BQU8sQ0FDZlUsaUJBQWlCLENBQUVBLGlCQUFrQixDQUNyQ0MsZUFBZSxDQUFFQSxlQUFnQixDQUNqQ3lCLEdBQUcsQ0FBRXRGLE1BQU8sQ0FDWixVQUFTLFlBQWEsR0FHcEI7QUFDWjtBQUNBLGdCQUNZeEssSUFBVyxDQUFDb1Asd0JBQXdCLGVBQ3BDejFCLG1CQUFBLENBQUMwcEIsZUFBYyxLQUFFLENBQUMsY0FHcEIxcEIsbUJBQUEsQ0FBQ2luQiw2QkFBYyxFQUNiQyxnQkFBZ0IsQ0FBRUEsZ0JBQWlCLENBQ3BDLENBQUMsY0FHRmxuQixtQkFBQSxRQUFLWSxTQUFTLENBQUVOLFlBQW9CLGVBQ2xDTixtQkFBQSxDQUFDNmhCLG9CQUFTLEVBQUNDLFNBQVMsQ0FBRUEsU0FBVSxDQUFFLENBQUMsY0FHbkM5aEIsbUJBQUEsUUFBS1ksU0FBUyxDQUFFTixZQUFvQixFQUVoQ3NlLFdBQVcsQ0FBR3hjLG9DQUEyQixDQUFDK2MsU0FBUyxDQUFHLENBQUMsZUFDdkRuZixtQkFBQSxRQUFLWSxTQUFTLENBQ1hvdkIscUJBQXFCLEVBQUksQ0FBQ1MsaUJBQWlCLENBQzFDbndCLGdCQUF1QixDQUN2QkEsb0JBQ0gsRUFDRUksSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1CQUFnQixDQUFDbTJCLG1CQUFtQixDQUNyRCxDQUFDLGNBRVJ4MkIsbUJBQUEsQ0FBQ3N1QixpQkFBZ0IsRUFDZm1JLGVBQWUsQ0FBRSxDQUFDQyxrQkFBa0IsQ0FBRSxJQUFJLENBQUUsQ0FDNUMxQixXQUFXLENBQUVBLFdBQVksQ0FDekJ6cUIsT0FBTyxDQUFFMHFCLGdCQUFpQixDQUMxQjBCLGlCQUFpQixDQUFFL1gsV0FBVyxDQUFHeGMsb0NBQTJCLENBQUMrYyxTQUFVLENBQ3ZFeVgsZUFBZSxDQUFFaFksV0FBVyxDQUFHeGMsb0NBQTJCLENBQUMrYyxTQUFVLENBQ3RFLENBQ0UsQ0FFRixDQUFDLENBSUxQLFdBQVcsQ0FBR3hjLG9DQUEyQixDQUFDK2MsU0FBUyxlQUFJbmYsbUJBQUEsQ0FBQ3F1QixrQkFBaUIsRUFDeEV3SSxXQUFXLENBQUUsS0FBTSxDQUNuQmoyQixTQUFTLENBQUVOLGlCQUF5QixDQUNyQyxDQUFDLENBSURzZSxXQUFXLENBQUd4YyxvQ0FBMkIsQ0FBQytjLFNBQVMsZUFDbERuZixtQkFBQSxDQUFDNHFCLHFCQUFxQixFQUFDcmdCLE9BQU8sQ0FBRUEsT0FBUSxDQUFFLENBQUMsQ0FHM0MsSUFBSSxFQUFJLENBQUE0YixLQUFLLEVBQUl5SixjQUFjLEVBQUksQ0FBQ0Usb0JBQW9CLGVBQ3hEOXZCLG1CQUFBLENBQUN1dUIsS0FBSyxFQUNKM3RCLFNBQVMsQ0FBRU4sUUFBZ0IsQ0FDM0IwMkIsT0FBTyxDQUFFLENBQUUsQ0FDWEMsTUFBTSxDQUFDLEtBQUssQ0FDWnhILFNBQVMsQ0FBRUcsY0FBYyxDQUFDSCxTQUFXLENBQ3JDRixRQUFRLENBQUVLLGNBQWMsQ0FBQ0wsUUFBVSxDQUNuQzJILFlBQVksQ0FBRSxJQUFLLENBQ25CQyxPQUFPLENBQUV0SCxpQkFBa0IsQ0FDM0J1SCxhQUFhLENBQUUsSUFBSyxlQUVwQnAzQixtQkFBQSxDQUFDOE8scUJBQVUsRUFDVHZELFVBQVUsQ0FBRXFrQixjQUFjLENBQUNya0IsVUFBVyxDQUN0QzRWLElBQUksQ0FBRTJQLGNBQWUsQ0FDdEIsQ0FDSSxDQUNSLENBQ0EsSUFBSSxFQUFJLENBQUEzSyxLQUFLLGNBQUdubUIsbUJBQUEsQ0FBQ3l1QixrQkFBaUIsRUFBQzd0QixTQUFTLENBQUVOLGlCQUF5QixDQUFFLENBQUMsQ0FBRyxFQUVwRSxDQUNSLENBQUMsY0FFUE4sbUJBQUEsQ0FBQ3FzQixRQUFJLEVBQUMrSSxPQUFPLENBQUUsQ0FBQ3hILEdBQUcsQ0FBRSxDQUFDLENBQUUsRUFDckJ3QyxpQkFBaUIsY0FDaEJwd0IsbUJBQUEsQ0FBQ3VzQiw0QkFBaUIsRUFDaEIzckIsU0FBUyxDQUFFTiwwQkFBb0IsQ0FDL0Jrc0IsV0FBVyxDQUFFdEYsZ0JBQWlCLENBQzlCeUYsa0JBQWtCLENBQUV1SSxtQkFBb0IsQ0FDeEN0SSxXQUFXLENBQUV1SSxZQUFhLENBQzFCMUksWUFBWSxDQUFFcUMsbUJBQW9CLENBQ2xDcEMsc0JBQXNCLENBQUVBLHNCQUF1QixDQUNoRCxDQUFDLGNBQ0Yxc0IsbUJBQUEsQ0FBQ2loQixZQUFZLEVBQ1hyZ0IsU0FBUyxDQUFFTiwwQkFBb0IsQ0FDL0I0Z0IsaUJBQWlCLENBQUUwTyxjQUFjLFNBQWRBLGNBQWMsaUJBQWRBLGNBQWMsQ0FBRXJrQixVQUFXLENBQzlDNFYsSUFBSSxDQUFFMlAsY0FBZSxDQUN0QixDQUVDLENBQ04sQ0FBQyxDQUVQLENBQUMsQ0FFRCxzREFBZS9CLE1BQU0sRTs7Ozs7Ozs7QUNuakJyQixLQUFNLENBQUE0SSxjQUFjLENBQUdsM0IsSUFBQSxFQUErQixJQUE5QixDQUFDd3VCLFFBQXVCLENBQUMsQ0FBQXh1QixJQUFBLENBQy9DO0FBQ0E7QUFDQSxLQUFNLENBQUFDLElBQUksQ0FBR04sOEJBQU8sQ0FBQyxDQUFDLENBR3RCLG1CQUFRSixtQkFBQSxDQUFDdzNCLHFCQUFNLEVBQUN2SSxRQUFRLENBQUVBLFFBQVMsQ0FBQ2hsQixLQUFLLENBQUV2SixJQUFJLENBQUNLLGFBQWEsQ0FBQ1YsMEJBQXVCLENBQUN3M0IsU0FBUyxDQUFFLGVBRS9GNzNCLG1CQUFBLENBQUN1M0IsbUNBQW9CLG1CQUVuQnYzQixtQkFBQSxZQUFTWSxTQUFTLENBQUUsY0FBZSxlQUNqQ1osbUJBQUEsV0FBS1UsSUFBSSxDQUFDSyxhQUFhLENBQUNWLDBCQUF1QixDQUFDeTNCLFlBQVksQ0FBTSxDQUFDLGNBQ25FOTNCLG1CQUFBLENBQUN5M0IsNkJBQWMsRUFBQzVhLElBQUksQ0FBR25jLElBQUksQ0FBQ29jLE1BQU0sR0FBSyxJQUFJLENBQUc0YSxvQ0FBaUIsQ0FBQzFhLEVBQUUsQ0FBRzBhLG9DQUFpQixDQUFDemEsRUFBRyxDQUFFLENBQ3JGLENBQUMsY0FFVmpkLG1CQUFBLENBQUNxc0IsUUFBSSxFQUFDb0IsR0FBRyxNQUFDc0ssR0FBRyxNQUFDbjNCLFNBQVMsQ0FBRSxhQUFjLGVBSXJDWixtQkFBQSxDQUFDcXNCLFFBQUksRUFBQytJLE9BQU8sQ0FBRSxDQUFDeEgsR0FBRyxDQUFFLENBQUMsQ0FBRSxDQUFDb0ssTUFBTSxDQUFFLENBQUNwSyxHQUFHLENBQUUsRUFBRSxDQUFFLENBQUNBLEdBQUcsQ0FBRSxFQUFHLGVBQ2xENXRCLG1CQUFBLFVBQ0dLLGlDQUNBLENBQUMsY0FDSkwsbUJBQUEsVUFDR0ssZ0NBQ0EsQ0FDQyxDQUFDLGNBQ1BMLG1CQUFBLENBQUNxc0IsUUFBSSxFQUFDK0ksT0FBTyxDQUFFLENBQUN4SCxHQUFHLENBQUUsQ0FBQyxDQUFFLENBQUNvSyxNQUFNLENBQUUsQ0FBQ3BLLEdBQUcsQ0FBRSxFQUFFLENBQUUsQ0FBQ0EsR0FBRyxDQUFFLEVBQUcsZUFDbEQ1dEIsbUJBQUEsQ0FBQ1EseUJBQWMsS0FBRSxDQUNiLENBQ0YsQ0FDYyxDQUFDLGNBRXZCUixtQkFBQSxDQUFDdTNCLG1DQUFvQixtQkFDbkJ2M0IsbUJBQUEsQ0FBQ3FzQixRQUFJLEVBQUNvQixHQUFHLG9CQUNQenRCLG1CQUFBLENBQUMrdUIsaUJBQU0sRUFBQ0UsUUFBUSxDQUFFQSxRQUFTLENBQUMsQ0FDeEIsQ0FDYyxDQUFDLGNBRXZCanZCLG1CQUFBLENBQUN1M0IsbUNBQW9CLG1CQUNuQnYzQixtQkFBQSxDQUFDcXNCLFFBQUksRUFBQytJLE9BQU8sQ0FBRSxDQUFDeEgsR0FBRyxDQUFFLENBQUMsQ0FBRSxDQUFDb0ssTUFBTSxDQUFFLENBQUNwSyxHQUFHLENBQUUsRUFBRSxDQUFFLENBQUNBLEdBQUcsQ0FBRSxFQUFHLGVBQ2xENXRCLG1CQUFBLFdBQUtLLG1DQUFnQyxDQUFDKzNCLEtBQVUsQ0FBQyxjQUNqRHA0QixtQkFBQSxVQUFJSyxtQ0FBZ0MsQ0FBQ2c0QixNQUFVLENBQUMsY0FDaERyNEIsbUJBQUEsVUFBSUssbUNBQWdDLENBQUNpNEIsTUFBVSxDQUFDLGNBQ2hEdDRCLG1CQUFBLFVBQUlLLG1DQUFnQyxDQUFDazRCLE1BQVUsQ0FDM0MsQ0FBQyxjQUVQdjRCLG1CQUFBLENBQUNxc0IsUUFBSSxFQUFDK0ksT0FBTyxDQUFFLENBQUN4SCxHQUFHLENBQUUsQ0FBQyxDQUFFLENBQUNvSyxNQUFNLENBQUUsQ0FBQ3BLLEdBQUcsQ0FBRSxFQUFFLENBQUUsQ0FBQ0EsR0FBRyxDQUFFLEVBQUcsZUFDbEQ1dEIsbUJBQUEsV0FBS0ssc0NBQW1DLENBQUMrM0IsS0FBVSxDQUFDLGNBQ3BEcDRCLG1CQUFBLFVBQUlLLHNDQUFtQyxDQUFDaTRCLE1BQVUsQ0FBQyxjQUNuRHQ0QixtQkFBQSxVQUFJSyxzQ0FBbUMsQ0FBQ2s0QixNQUFVLENBQzlDLENBQ2MsQ0FFaEIsQ0FBQyxDQUVYLENBQUMsQ0FFRCwwQ0FBZVosY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvRXhwbG9yZURhdGFCb3gvRXhwbG9yZURhdGFCb3gubW9kdWxlLnNjc3M/OTg4NyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0V4cGxvcmVEYXRhQm94L0V4cGxvcmVEYXRhQm94LnRzeD80MWM3Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvRXhwbG9yZURhdGFCb3gvaW5kZXgudHM/NzNkMiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzPzMwYWQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzP2FhOWUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9QcmltaXRpdmUuanM/ZTgwNSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1Byb3BlcnR5S2V5LmpzPzY3N2QiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanM/MTNiMSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhIb2xlcy5qcz85Yjg4Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzPzkzNGMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzPzVhNjEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qcz8xNTM4Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vY29tbW9uLmpzP2I5M2UiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS92ZWM0LmpzPzg5YmIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvd2ViLW1lcmNhdG9yL2Rpc3QvZXNtL21hdGgtdXRpbHMuanM/ZDkwNiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL21hdDQuanM/NDU4OSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL3ZlYzIuanM/MWE3MSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL3ZlYzMuanM/ODkwMiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC93ZWItbWVyY2F0b3IvZGlzdC9lc20vYXNzZXJ0LmpzP2FhN2EiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvd2ViLW1lcmNhdG9yL2Rpc3QvZXNtL3dlYi1tZXJjYXRvci11dGlscy5qcz83MzUyIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3dlYi1tZXJjYXRvci9kaXN0L2VzbS9maXQtYm91bmRzLmpzPzgxN2UiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvd2ViLW1lcmNhdG9yL2Rpc3QvZXNtL2dldC1ib3VuZHMuanM/NDBmMyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC93ZWItbWVyY2F0b3IvZGlzdC9lc20vd2ViLW1lcmNhdG9yLXZpZXdwb3J0LmpzPzFhZDYiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvd2ViLW1lcmNhdG9yL2Rpc3QvZXNtL25vcm1hbGl6ZS12aWV3cG9ydC1wcm9wcy5qcz9jM2Q4Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3dlYi1tZXJjYXRvci9kaXN0L2VzbS9mbHktdG8tdmlld3BvcnQuanM/M2MyOCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC93ZWItbWVyY2F0b3IvZGlzdC9lc20vaW5kZXguanM/ZTViMyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy92aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0L21vZHVsZS5qcz9lMjQ1Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbC9kaXN0L1Jlc2l6ZU9ic2VydmVyLmVzLmpzPzZmZWEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanM/MWQ3YiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcy5qcz85MWEzIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy9nbG9iYWxzLmpzP2U3YWUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL3N0eWxlLXV0aWxzLmpzP2UyZGEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL21hcGJveC9tYXBib3guanM/OWM3ZCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvbWFwYm94Z2wuYnJvd3Nlci5qcz9kN2Q0Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy9tYXRoLXV0aWxzLmpzP2Y5MWEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL2Fzc2VydC5qcz84MDQ3Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy9tYXAtc3RhdGUuanM/NGZiMSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvbWFwLWNvbnN0cmFpbnRzLmpzPzIxY2IiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvbWFwLWNvbnRleHQuanM/YzY3YSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvdXNlLWlzb21vcnBoaWMtbGF5b3V0LWVmZmVjdC5qcz80ZjcxIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy90ZXJyYWluLmpzPzEwMWIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvc3RhdGljLW1hcC5qcz82OGQwIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy90cmFuc2l0aW9uL3RyYW5zaXRpb24taW50ZXJwb2xhdG9yLmpzPzRhZDQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzPzg2NzMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHMuanM/ZDY3ZSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzP2E4MmMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2YuanM/YmZlZiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvdHJhbnNpdGlvbi90cmFuc2l0aW9uLXV0aWxzLmpzPzhkMzYiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL3RyYW5zaXRpb24vdmlld3BvcnQtZmx5LXRvLWludGVycG9sYXRvci5qcz80ODcyIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy90cmFuc2l0aW9uL2xpbmVhci1pbnRlcnBvbGF0b3IuanM/NGIwZSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvdHJhbnNpdGlvbi9pbmRleC5qcz8yYmI5Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy90cmFuc2l0aW9uLW1hbmFnZXIuanM/YzMzNCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9tam9sbmlyLmpzL2Rpc3QvZXNtL3V0aWxzL2hhbW1lci1vdmVycmlkZXMuanM/M2M3NiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9tam9sbmlyLmpzL2Rpc3QvZXNtL3V0aWxzL2hhbW1lci5icm93c2VyLmpzP2I2OTgiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS9pbnB1dHMvaW5wdXQuanM/MGM0MyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9tam9sbmlyLmpzL2Rpc3QvZXNtL2NvbnN0YW50cy5qcz9mNDI1Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL21qb2xuaXIuanMvZGlzdC9lc20vdXRpbHMvZ2xvYmFscy5qcz9lMTQxIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL21qb2xuaXIuanMvZGlzdC9lc20vaW5wdXRzL3doZWVsLWlucHV0LmpzPzA1M2UiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS9pbnB1dHMvbW92ZS1pbnB1dC5qcz9iYjQwIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL21qb2xuaXIuanMvZGlzdC9lc20vaW5wdXRzL2tleS1pbnB1dC5qcz80MzJhIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL21qb2xuaXIuanMvZGlzdC9lc20vaW5wdXRzL2NvbnRleHRtZW51LWlucHV0LmpzPzVlZDEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS91dGlscy9ldmVudC11dGlscy5qcz8yNTYyIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL21qb2xuaXIuanMvZGlzdC9lc20vdXRpbHMvZXZlbnQtcmVnaXN0cmFyLmpzPzQ3NTMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS9ldmVudC1tYW5hZ2VyLmpzP2QxNzEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS9pbmRleC5qcz8wOWVlIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy9tYXAtY29udHJvbGxlci5qcz8yYzUxIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL2ludGVyYWN0aXZlLW1hcC5qcz84NmRiIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy9kZWVwLWVxdWFsLmpzPzY1MDIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvc291cmNlLmpzPzZlZTQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcz9kZWRjIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzLmpzP2E4ZjUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvbGF5ZXIuanM/OWZmNyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy91c2UtbWFwLWNvbnRyb2wuanM/ODNiNyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9iYXNlLWNvbnRyb2wuanM/YzM1NyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9kcmFnZ2FibGUtY29udHJvbC5qcz8yZjc0Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy9jcmlzcC1waXhlbC5qcz84OGFkIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL21hcmtlci5qcz8wMDhkIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy9keW5hbWljLXBvc2l0aW9uLmpzP2FkMzkiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvcG9wdXAuanM/OTkzNiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9hdHRyaWJ1dGlvbi1jb250cm9sLmpzPzIzMTIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvZnVsbHNjcmVlbi1jb250cm9sLmpzPzEwMzYiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL2dlb2xvY2F0ZS11dGlscy5qcz9kMzZiIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL2dlb2xvY2F0ZS1jb250cm9sLmpzP2FjMzAiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL3ZlcnNpb24uanM/YjI3OCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9uYXZpZ2F0aW9uLWNvbnRyb2wuanM/YTFjNSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9zY2FsZS1jb250cm9sLmpzP2U3MjAiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL292ZXJsYXlzL2NhbnZhcy1vdmVybGF5LmpzPzg1MzMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL292ZXJsYXlzL2h0bWwtb3ZlcmxheS5qcz9jZDdkIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9vdmVybGF5cy9zdmctb3ZlcmxheS5qcz84ZTUwIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy9zZXQtcnRsLXRleHQtcGx1Z2luLmpzPzAwY2YiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2luZGV4LmpzP2MxYjMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQHR1cmYvaGVscGVycy9kaXN0L2VzL2luZGV4LmpzPzI5MjUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQHR1cmYvbWV0YS9kaXN0L2VzL2luZGV4LmpzPzRlNTgiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQHR1cmYvYmJveC9kaXN0L2VzL2luZGV4LmpzP2NlMWMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvY3ViaWMuanM/ZTQyZCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC11c2UvZXNtL3VzZUxvY2FsU3RvcmFnZS5qcz81MjhmIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvRGlzYWR2YW50YWdlRG90L0Rpc2FkdmFudGFnZURvdC5tb2R1bGUuc2Nzcz9kZjc1Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvRGlzYWR2YW50YWdlRG90L0Rpc2FkdmFudGFnZURvdC50c3g/M2I5NCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0Rpc2FkdmFudGFnZURvdC9pbmRleC50c3g/ODM0MiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0NhdGVnb3J5L0NhdGVnb3J5Lm1vZHVsZS5zY3NzPzY5OTIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9DYXRlZ29yeS9DYXRlZ29yeS50c3g/NWM2MiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0NhdGVnb3J5L2luZGV4LnRzeD9hOTExIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRvb2x0aXAvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9ybmcuanM/NjljNSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC10b29sdGlwL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvYnl0ZXNUb1V1aWQuanM/NWU3ZiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC10b29sdGlwL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanM/N2VmNCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC10b29sdGlwL2Rpc3QvaW5kZXguZXMuanM/ZTliOSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0luZGljYXRvci9JbmRpY2F0b3IubW9kdWxlLnNjc3M/MWM5ZCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy91c3dkcy9kaXN0L2ltZy91c2EtaWNvbnMvaW5mby5zdmc/MjUwMyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0luZGljYXRvci9JbmRpY2F0b3IudHN4P2YyYmEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9Eb251dENvcHkvRG9udXRDb3B5Lm1vZHVsZS5zY3NzPzkwYTEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9Eb251dENvcHkvRG9udXRDb3B5LnRzeD82MThlIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvRG9udXRDb3B5L2luZGV4LnRzP2YyZDEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9JbmRpY2F0b3IvaW5kZXgudHN4P2U2ZjUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9Qcmlvcml0aXphdGlvbkNvcHkvUHJpb3JpdGl6YXRpb25Db3B5LnRzeD8yNmFjIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvUHJpb3JpdGl6YXRpb25Db3B5L2luZGV4LnRzPzk1ZDgiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9Qcmlvcml0aXphdGlvbkNvcHkyL1ByaW9yaXRpemF0aW9uQ29weTIudHN4P2QxNzMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9Qcmlvcml0aXphdGlvbkNvcHkyL2luZGV4LnRzPzFhYWYiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9UcmFjdERlbW9ncmFwaGljcy9UcmFjdERlbW9ncmFwaGljcy5tb2R1bGUuc2Nzcz8wODEyIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvVHJhY3REZW1vZ3JhcGhpY3MvVHJhY3REZW1vZ3JhcGhpY3MudHN4PzU0ZjIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9UcmFjdERlbW9ncmFwaGljcy9pbmRleC50cz82MzZmIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvVHJhY3RJbmZvL1RyYWN0SW5mby5tb2R1bGUuc2Nzcz9jODg2Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvVHJhY3RJbmZvL1RyYWN0SW5mby50c3g/NDRlZiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL1RyYWN0SW5mby9pbmRleC50cz81ODBiIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvVHJhY3RQcmlvcml0aXphdGlvbi9UcmFjdFByaW9yaXRpemF0aW9uLm1vZHVsZS5zY3NzPzk3OWUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9UcmFjdFByaW9yaXRpemF0aW9uL1RyYWN0UHJpb3JpdGl6YXRpb24udHN4PzgwYWYiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9UcmFjdFByaW9yaXRpemF0aW9uL2luZGV4LnRzPzg4OTQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9BcmVhRGV0YWlsL2FyZWFEZXRhaWwubW9kdWxlLnNjc3M/NGMzNiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0lzbGFuZENvcHkvSXNsYW5kQ29weS5tb2R1bGUuc2Nzcz8xZTQ0Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvSXNsYW5kQ29weS9Jc2xhbmRDb3B5LnRzeD82NzU1Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvQXJlYURldGFpbC9BcmVhRGV0YWlsLnRzeD83MjJjIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvQXJlYURldGFpbC9pbmRleC50c3g/MDk5NyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy91c3dkcy9kaXN0L2ltZy91c2EtaWNvbnMvYWRkLnN2Zz8xMTY2Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3Vzd2RzL2Rpc3QvaW1nL3VzYS1pY29ucy9zZWFyY2guc3ZnPzMzYTgiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL215X2xvY2F0aW9uLnN2Zz80NjNhIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3Vzd2RzL2Rpc3QvaW1nL3VzYS1pY29ucy9wZW9wbGUuc3ZnPzA2NmIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL2ZpbGVfdXBsb2FkLnN2Zz81YzUwIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3Vzd2RzL2Rpc3QvaW1nL3VzYS1pY29ucy9jaGVjay5zdmc/NGQ5NyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9pbWFnZXMvc2lkZVBhbmVsSWNvbnMvcHV6emxlLnN2Zz84MTY5Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2ltYWdlcy9zaWRlUGFuZWxJY29ucy9iZWxsLWN1cnZlLnN2Zz9hMDkwIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2ltYWdlcy9zaWRlUGFuZWxJY29ucy9waWUtY2hhcnQuc3ZnPzdlMmMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9TaWRlUGFuZWxJbmZvL1NpZGVQYW5lbEluZm8ubW9kdWxlLnNjc3M/OWM1NCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL1NpZGVQYW5lbEluZm8vU2lkZVBhbmVsSW5mby50c3g/ZjE4YSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL1NpZGVQYW5lbEluZm8vaW5kZXgudHN4P2I5YjciLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9tYXBJbmZvUGFuZWwudHN4Pzg4NDMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvanMtc2VhcmNoL2Rpc3QvZXNtL2pzLXNlYXJjaC5qcz9iOTk5Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvTWFwU2VhcmNoTWVzc2FnZS9NYXBTZWFyY2hNZXNzYWdlLm1vZHVsZS5zY3NzPzk3NGYiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9NYXBTZWFyY2hNZXNzYWdlL01hcFNlYXJjaE1lc3NhZ2UudHN4PzNmYWEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9NYXBTZWFyY2hNZXNzYWdlL2luZGV4LnRzeD9jOWIxIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvTWFwU2VhcmNoL01hcFNlYXJjaC5tb2R1bGUuc2Nzcz83ZTU3Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvTWFwU2VhcmNoL01hcFNlYXJjaC50c3g/OTY5YyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL01hcFNlYXJjaC9pbmRleC50c3g/YjYzMSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL01hcFRyYWN0TGF5ZXJzL01hcFRyYWN0TGF5ZXJzLnRzeD83NTEzIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvTWFwVHJpYmFsTGF5ZXJzL01hcFRyaWJhbExheWVycy50c3g/ZDI1NCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL3RlcnJpdG9yeUZvY3VzQ29udHJvbC5tb2R1bGUuc2Nzcz8wMDBjIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvdGVycml0b3J5Rm9jdXNDb250cm9sLnRzeD8xNGU1Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvSjQwTWFwLm1vZHVsZS5zY3NzP2I3ZGIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9DcmVhdGVSZXBvcnRQYW5lbC9DcmVhdGVSZXBvcnRQYW5lbC5tb2R1bGUuc2Nzcz85YWViIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3Vzd2RzL2Rpc3QvaW1nL3VzYS1pY29ucy9jbG9zZS5zdmc/MTZkYiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0NyZWF0ZVJlcG9ydFBhbmVsL0NyZWF0ZVJlcG9ydFBhbmVsLnRzeD8wNjUzIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvQ3JlYXRlUmVwb3J0UGFuZWwvaW5kZXgudHN4P2U1OTIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9KNDBNYXAudHN4P2FmNzciLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvcGFnZXMvaW5kZXgudHN4PzQxZTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIGZpbGVEb3duSWNvbiA9IFwiRXhwbG9yZURhdGFCb3gtbW9kdWxlLS1maWxlRG93bkljb24tLUVMcFJmXCI7XG5leHBvcnQgdmFyIHN1bW1hcnlCb3hDb250YWluZXIgPSBcIkV4cGxvcmVEYXRhQm94LW1vZHVsZS0tc3VtbWFyeUJveENvbnRhaW5lci0tN0RuVENcIjsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtTdW1tYXJ5Qm94LCBTdW1tYXJ5Qm94Q29udGVudCwgU3VtbWFyeUJveEhlYWRpbmd9IGZyb20gJ0B0cnVzc3dvcmtzL3JlYWN0LXVzd2RzJztcbmltcG9ydCB7dXNlSW50bH0gZnJvbSAnZ2F0c2J5LXBsdWdpbi1pbnRsJztcblxuaW1wb3J0ICogYXMgRVhQTE9SRV9DT1BZIGZyb20gJy4uLy4uL2RhdGEvY29weS9leHBsb3JlJztcblxuaW1wb3J0ICogYXMgc3R5bGVzIGZyb20gJy4vRXhwbG9yZURhdGFCb3gubW9kdWxlLnNjc3MnO1xuXG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgZmlsZURvd25JY29uIGZyb20gJy9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL2ZpbGVfZG93bmxvYWQuc3ZnJztcblxuXG5leHBvcnQgaW50ZXJmYWNlIElFeHBsb3JlRGF0YUJveFByb3BzIHt9XG5cbmNvbnN0IEV4cGxvcmVEYXRhQm94ID0gKHt9OiBJRXhwbG9yZURhdGFCb3hQcm9wcykgPT4ge1xuICBjb25zdCBpbnRsID0gdXNlSW50bCgpO1xuXG4gIHJldHVybiAoXG4gICAgPFN1bW1hcnlCb3ggY2xhc3NOYW1lPXtzdHlsZXMuc3VtbWFyeUJveENvbnRhaW5lcn0+XG5cbiAgICAgIDxTdW1tYXJ5Qm94SGVhZGluZyBoZWFkaW5nTGV2ZWw9J2gyJz5cbiAgICAgICAge2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuRVhQTE9SRV9EQVRBX0JPWC5USVRMRSl9XG4gICAgICAgIDxpbWcgdGFiSW5kZXg9ezB9IGNsYXNzTmFtZT17c3R5bGVzLmZpbGVEb3duSWNvbn0gc3JjPXtmaWxlRG93bkljb259XG4gICAgICAgICAgYWx0PXtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5JVF9TVEFURV9JQ09OX0FMVF9URVhULlBMVVMpfVxuICAgICAgICAvPlxuICAgICAgPC9TdW1tYXJ5Qm94SGVhZGluZz5cblxuICAgICAgPFN1bW1hcnlCb3hDb250ZW50PlxuICAgICAgICB7RVhQTE9SRV9DT1BZLkVYUExPUkVfREFUQV9CT1hfQk9EWX1cbiAgICAgIDwvU3VtbWFyeUJveENvbnRlbnQ+XG5cbiAgICA8L1N1bW1hcnlCb3g+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFeHBsb3JlRGF0YUJveDtcbiIsImltcG9ydCBFeHBsb3JlRGF0YUJveCBmcm9tICcuL0V4cGxvcmVEYXRhQm94JztcbmV4cG9ydCBkZWZhdWx0IEV4cGxvcmVEYXRhQm94O1xuIiwiZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIHJldHVybiBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciB0ID0gYXJndW1lbnRzW2VdO1xuICAgICAgZm9yICh2YXIgciBpbiB0KSAoe30pLmhhc093blByb3BlcnR5LmNhbGwodCwgcikgJiYgKG5bcl0gPSB0W3JdKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH0sIF9leHRlbmRzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5leHBvcnQgeyBfZXh0ZW5kcyBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn1cbmV4cG9ydCB7IF90eXBlb2YgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfdHlwZW9mIGZyb20gXCIuL3R5cGVvZi5qc1wiO1xuZnVuY3Rpb24gdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbmV4cG9ydCB7IHRvUHJpbWl0aXZlIGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgX3R5cGVvZiBmcm9tIFwiLi90eXBlb2YuanNcIjtcbmltcG9ydCB0b1ByaW1pdGl2ZSBmcm9tIFwiLi90b1ByaW1pdGl2ZS5qc1wiO1xuZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7XG59XG5leHBvcnQgeyB0b1Byb3BlcnR5S2V5IGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgdG9Qcm9wZXJ0eUtleSBmcm9tIFwiLi90b1Byb3BlcnR5S2V5LmpzXCI7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuICByZXR1cm4gKHIgPSB0b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICB2YWx1ZTogdCxcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIHdyaXRhYmxlOiAhMFxuICB9KSA6IGVbcl0gPSB0LCBlO1xufVxuZXhwb3J0IHsgX2RlZmluZVByb3BlcnR5IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikge1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7XG59XG5leHBvcnQgeyBfYXJyYXlXaXRoSG9sZXMgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7XG4gIHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChudWxsICE9IHQpIHtcbiAgICB2YXIgZSxcbiAgICAgIG4sXG4gICAgICBpLFxuICAgICAgdSxcbiAgICAgIGEgPSBbXSxcbiAgICAgIGYgPSAhMCxcbiAgICAgIG8gPSAhMTtcbiAgICB0cnkge1xuICAgICAgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkge1xuICAgICAgICBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47XG4gICAgICAgIGYgPSAhMTtcbiAgICAgIH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBvID0gITAsIG4gPSByO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAobykgdGhyb3cgbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbn1cbmV4cG9ydCB7IF9pdGVyYWJsZVRvQXJyYXlMaW1pdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmV4cG9ydCB7IF9ub25JdGVyYWJsZVJlc3QgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBhcnJheVdpdGhIb2xlcyBmcm9tIFwiLi9hcnJheVdpdGhIb2xlcy5qc1wiO1xuaW1wb3J0IGl0ZXJhYmxlVG9BcnJheUxpbWl0IGZyb20gXCIuL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzXCI7XG5pbXBvcnQgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgZnJvbSBcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanNcIjtcbmltcG9ydCBub25JdGVyYWJsZVJlc3QgZnJvbSBcIi4vbm9uSXRlcmFibGVSZXN0LmpzXCI7XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cbmV4cG9ydCB7IF9zbGljZWRUb0FycmF5IGFzIGRlZmF1bHQgfTsiLCIvKipcbiAqIENvbW1vbiB1dGlsaXRpZXNcbiAqIEBtb2R1bGUgZ2xNYXRyaXhcbiAqL1xuLy8gQ29uZmlndXJhdGlvbiBDb25zdGFudHNcbmV4cG9ydCB2YXIgRVBTSUxPTiA9IDAuMDAwMDAxO1xuZXhwb3J0IHZhciBBUlJBWV9UWVBFID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbmV4cG9ydCB2YXIgUkFORE9NID0gTWF0aC5yYW5kb207XG4vKipcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xuICpcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5Q29uc3RydWN0b3IgfCBBcnJheUNvbnN0cnVjdG9yfSB0eXBlIEFycmF5IHR5cGUsIHN1Y2ggYXMgRmxvYXQzMkFycmF5IG9yIEFycmF5XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldE1hdHJpeEFycmF5VHlwZSh0eXBlKSB7XG4gIEFSUkFZX1RZUEUgPSB0eXBlO1xufVxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG4vKipcbiAqIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIEFuZ2xlIGluIERlZ3JlZXNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdG9SYWRpYW4oYSkge1xuICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cbi8qKlxuICogVGVzdHMgd2hldGhlciBvciBub3QgdGhlIGFyZ3VtZW50cyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgdmFsdWUsIHdpdGhpbiBhbiBhYnNvbHV0ZVxuICogb3IgcmVsYXRpdmUgdG9sZXJhbmNlIG9mIGdsTWF0cml4LkVQU0lMT04gKGFuIGFic29sdXRlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciB2YWx1ZXMgbGVzc1xuICogdGhhbiBvciBlcXVhbCB0byAxLjAsIGFuZCBhIHJlbGF0aXZlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciBsYXJnZXIgdmFsdWVzKVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gdGVzdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgbnVtYmVyIHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbnVtYmVycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEpLCBNYXRoLmFicyhiKSk7XG59XG5pZiAoIU1hdGguaHlwb3QpIE1hdGguaHlwb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB5ID0gMCxcbiAgICBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHkgKz0gYXJndW1lbnRzW2ldICogYXJndW1lbnRzW2ldO1xuICB9XG4gIHJldHVybiBNYXRoLnNxcnQoeSk7XG59OyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXG4gKiA0IERpbWVuc2lvbmFsIFZlY3RvclxuICogQG1vZHVsZSB2ZWM0XG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWM0XG4gKlxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHosIHcpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjNCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6LCB3KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIG91dFszXSA9IHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFkZHMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgb3V0WzNdID0gYVszXSAqIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAvIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5jZWlsKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gIG91dFszXSA9IE1hdGguZmxvb3IoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5taW4oYVszXSwgYlszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5tYXgoYVszXSwgYlszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5yb3VuZChhWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2NhbGVzIGEgdmVjNCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHZhciB3ID0gYlszXSAtIGFbM107XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHosIHcpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICB2YXIgdyA9IGJbM10gLSBhWzNdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIHcgPSBhWzNdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6LCB3KTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIHcgPSBhWzNdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG59XG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSAtYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICBvdXRbM10gPSAxLjAgLyBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICB2YXIgdyA9IGFbM107XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdztcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cbiAgb3V0WzBdID0geCAqIGxlbjtcbiAgb3V0WzFdID0geSAqIGxlbjtcbiAgb3V0WzJdID0geiAqIGxlbjtcbiAgb3V0WzNdID0gdyAqIGxlbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXSArIGFbM10gKiBiWzNdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjcm9zcy1wcm9kdWN0IG9mIHRocmVlIHZlY3RvcnMgaW4gYSA0LWRpbWVuc2lvbmFsIHNwYWNlXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IHJlc3VsdCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IFUgdGhlIGZpcnN0IHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IFYgdGhlIHNlY29uZCB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBXIHRoZSB0aGlyZCB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWM0fSByZXN1bHRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3Mob3V0LCB1LCB2LCB3KSB7XG4gIHZhciBBID0gdlswXSAqIHdbMV0gLSB2WzFdICogd1swXSxcbiAgICBCID0gdlswXSAqIHdbMl0gLSB2WzJdICogd1swXSxcbiAgICBDID0gdlswXSAqIHdbM10gLSB2WzNdICogd1swXSxcbiAgICBEID0gdlsxXSAqIHdbMl0gLSB2WzJdICogd1sxXSxcbiAgICBFID0gdlsxXSAqIHdbM10gLSB2WzNdICogd1sxXSxcbiAgICBGID0gdlsyXSAqIHdbM10gLSB2WzNdICogd1syXTtcbiAgdmFyIEcgPSB1WzBdO1xuICB2YXIgSCA9IHVbMV07XG4gIHZhciBJID0gdVsyXTtcbiAgdmFyIEogPSB1WzNdO1xuICBvdXRbMF0gPSBIICogRiAtIEkgKiBFICsgSiAqIEQ7XG4gIG91dFsxXSA9IC0oRyAqIEYpICsgSSAqIEMgLSBKICogQjtcbiAgb3V0WzJdID0gRyAqIEUgLSBIICogQyArIEogKiBBO1xuICBvdXRbM10gPSAtKEcgKiBEKSArIEggKiBCIC0gSSAqIEE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXTtcbiAgdmFyIGF5ID0gYVsxXTtcbiAgdmFyIGF6ID0gYVsyXTtcbiAgdmFyIGF3ID0gYVszXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgb3V0WzNdID0gYXcgKyB0ICogKGJbM10gLSBhdyk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wOyAvLyBNYXJzYWdsaWEsIEdlb3JnZS4gQ2hvb3NpbmcgYSBQb2ludCBmcm9tIHRoZSBTdXJmYWNlIG9mIGFcbiAgLy8gU3BoZXJlLiBBbm4uIE1hdGguIFN0YXRpc3QuIDQzICgxOTcyKSwgbm8uIDIsIDY0NS0tNjQ2LlxuICAvLyBodHRwOi8vcHJvamVjdGV1Y2xpZC5vcmcvZXVjbGlkLmFvbXMvMTE3NzY5MjY0NDtcblxuICB2YXIgdjEsIHYyLCB2MywgdjQ7XG4gIHZhciBzMSwgczI7XG4gIGRvIHtcbiAgICB2MSA9IGdsTWF0cml4LlJBTkRPTSgpICogMiAtIDE7XG4gICAgdjIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIgLSAxO1xuICAgIHMxID0gdjEgKiB2MSArIHYyICogdjI7XG4gIH0gd2hpbGUgKHMxID49IDEpO1xuICBkbyB7XG4gICAgdjMgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIgLSAxO1xuICAgIHY0ID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICBzMiA9IHYzICogdjMgKyB2NCAqIHY0O1xuICB9IHdoaWxlIChzMiA+PSAxKTtcbiAgdmFyIGQgPSBNYXRoLnNxcnQoKDEgLSBzMSkgLyBzMik7XG4gIG91dFswXSA9IHNjYWxlICogdjE7XG4gIG91dFsxXSA9IHNjYWxlICogdjI7XG4gIG91dFsyXSA9IHNjYWxlICogdjMgKiBkO1xuICBvdXRbM10gPSBzY2FsZSAqIHY0ICogZDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgbWF0NC5cbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV0sXG4gICAgeiA9IGFbMl0sXG4gICAgdyA9IGFbM107XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdICogdztcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10gKiB3O1xuICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0gKiB3O1xuICBvdXRbM10gPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV0gKiB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXSxcbiAgICB6ID0gYVsyXTtcbiAgdmFyIHF4ID0gcVswXSxcbiAgICBxeSA9IHFbMV0sXG4gICAgcXogPSBxWzJdLFxuICAgIHF3ID0gcVszXTsgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcblxuICB2YXIgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG4gIHZhciBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcbiAgdmFyIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICB2YXIgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6OyAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG5cbiAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB6ZXJvXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gemVybyhvdXQpIHtcbiAgb3V0WzBdID0gMC4wO1xuICBvdXRbMV0gPSAwLjA7XG4gIG91dFsyXSA9IDAuMDtcbiAgb3V0WzNdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwidmVjNChcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIilcIjtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgIGExID0gYVsxXSxcbiAgICBhMiA9IGFbMl0sXG4gICAgYTMgPSBhWzNdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgIGIxID0gYlsxXSxcbiAgICBiMiA9IGJbMl0sXG4gICAgYjMgPSBiWzNdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpO1xufVxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0O1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBkaXYgPSBkaXZpZGU7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgZGlzdCA9IGRpc3RhbmNlO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBsZW4gPSBsZW5ndGg7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjNHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjNC4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzRzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlYyA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIHZhciBpLCBsO1xuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSA0O1xuICAgIH1cbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oY291bnQgKiBzdHJpZGUgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICB2ZWNbM10gPSBhW2kgKyAzXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgICAgYVtpICsgMl0gPSB2ZWNbMl07XG4gICAgICBhW2kgKyAzXSA9IHZlY1szXTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG59KCk7IiwiaW1wb3J0IHsgdHJhbnNmb3JtTWF0NCwgc2NhbGUgfSBmcm9tICdnbC1tYXRyaXgvdmVjNCc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWF0NCgpIHtcbiAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1WZWN0b3IobWF0cml4LCB2ZWN0b3IpIHtcbiAgY29uc3QgcmVzdWx0ID0gdHJhbnNmb3JtTWF0NChbXSwgdmVjdG9yLCBtYXRyaXgpO1xuICBzY2FsZShyZXN1bHQsIHJlc3VsdCwgMSAvIHJlc3VsdFszXSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gbW9kKHZhbHVlLCBkaXZpc29yKSB7XG4gIGNvbnN0IG1vZHVsdXMgPSB2YWx1ZSAlIGRpdmlzb3I7XG4gIHJldHVybiBtb2R1bHVzIDwgMCA/IGRpdmlzb3IgKyBtb2R1bHVzIDogbW9kdWx1cztcbn1cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgcmV0dXJuIHN0ZXAgKiBlbmQgKyAoMSAtIHN0ZXApICogc3RhcnQ7XG59XG5leHBvcnQgZnVuY3Rpb24gY2xhbXAoeCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIHggPCBtaW4gPyBtaW4gOiB4ID4gbWF4ID8gbWF4IDogeDtcbn1cbmZ1bmN0aW9uIGllTG9nMih4KSB7XG4gIHJldHVybiBNYXRoLmxvZyh4KSAqIE1hdGguTE9HMkU7XG59XG5leHBvcnQgY29uc3QgbG9nMiA9IE1hdGgubG9nMiB8fCBpZUxvZzI7IiwiaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG4vKipcbiAqIDR4NCBNYXRyaXg8YnI+Rm9ybWF0OiBjb2x1bW4tbWFqb3IsIHdoZW4gdHlwZWQgb3V0IGl0IGxvb2tzIGxpa2Ugcm93LW1ham9yPGJyPlRoZSBtYXRyaWNlcyBhcmUgYmVpbmcgcG9zdCBtdWx0aXBsaWVkLlxuICogQG1vZHVsZSBtYXQ0XG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgfVxuICBvdXRbMF0gPSAxO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICBvdXRbOV0gPSBhWzldO1xuICBvdXRbMTBdID0gYVsxMF07XG4gIG91dFsxMV0gPSBhWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0NCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIG91dFs5XSA9IGFbOV07XG4gIG91dFsxMF0gPSBhWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdO1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtYXQ0IHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcbiAqIEByZXR1cm5zIHttYXQ0fSBBIG5ldyBtYXQ0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0NCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gICAgdmFyIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICAgIHZhciBhMjMgPSBhWzExXTtcbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYTAxO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYTAyO1xuICAgIG91dFs5XSA9IGExMjtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGEwMztcbiAgICBvdXRbMTNdID0gYTEzO1xuICAgIG91dFsxNF0gPSBhMjM7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYVsxXTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYVsyXTtcbiAgICBvdXRbOV0gPSBhWzZdO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGFbM107XG4gICAgb3V0WzEzXSA9IGFbN107XG4gICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgIGEwMSA9IGFbMV0sXG4gICAgYTAyID0gYVsyXSxcbiAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICBhMTEgPSBhWzVdLFxuICAgIGExMiA9IGFbNl0sXG4gICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgYTIxID0gYVs5XSxcbiAgICBhMjIgPSBhWzEwXSxcbiAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgIGEzMSA9IGFbMTNdLFxuICAgIGEzMiA9IGFbMTRdLFxuICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgYTAxID0gYVsxXSxcbiAgICBhMDIgPSBhWzJdLFxuICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgIGExMSA9IGFbNV0sXG4gICAgYTEyID0gYVs2XSxcbiAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICBhMjEgPSBhWzldLFxuICAgIGEyMiA9IGFbMTBdLFxuICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgYTMxID0gYVsxM10sXG4gICAgYTMyID0gYVsxNF0sXG4gICAgYTMzID0gYVsxNV07XG4gIG91dFswXSA9IGExMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKTtcbiAgb3V0WzFdID0gLShhMDEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICBvdXRbMl0gPSBhMDEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMik7XG4gIG91dFszXSA9IC0oYTAxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzRdID0gLShhMTAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICBvdXRbNV0gPSBhMDAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMik7XG4gIG91dFs2XSA9IC0oYTAwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzddID0gYTAwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpO1xuICBvdXRbOF0gPSBhMTAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSk7XG4gIG91dFs5XSA9IC0oYTAwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpKTtcbiAgb3V0WzEwXSA9IGEwMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKTtcbiAgb3V0WzExXSA9IC0oYTAwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgb3V0WzEyXSA9IC0oYTEwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpKTtcbiAgb3V0WzEzXSA9IGEwMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKTtcbiAgb3V0WzE0XSA9IC0oYTAwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgb3V0WzE1XSA9IGEwMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICBhMDEgPSBhWzFdLFxuICAgIGEwMiA9IGFbMl0sXG4gICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgYTExID0gYVs1XSxcbiAgICBhMTIgPSBhWzZdLFxuICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgIGEyMSA9IGFbOV0sXG4gICAgYTIyID0gYVsxMF0sXG4gICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICBhMzEgPSBhWzEzXSxcbiAgICBhMzIgPSBhWzE0XSxcbiAgICBhMzMgPSBhWzE1XTtcbiAgdmFyIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgdmFyIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgdmFyIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgdmFyIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgdmFyIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgdmFyIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgdmFyIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgdmFyIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgdmFyIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgdmFyIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgdmFyIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgdmFyIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjsgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuXG4gIHJldHVybiBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG59XG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgIGEwMSA9IGFbMV0sXG4gICAgYTAyID0gYVsyXSxcbiAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICBhMTEgPSBhWzVdLFxuICAgIGExMiA9IGFbNl0sXG4gICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgYTIxID0gYVs5XSxcbiAgICBhMjIgPSBhWzEwXSxcbiAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgIGEzMSA9IGFbMTNdLFxuICAgIGEzMiA9IGFbMTRdLFxuICAgIGEzMyA9IGFbMTVdOyAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcblxuICB2YXIgYjAgPSBiWzBdLFxuICAgIGIxID0gYlsxXSxcbiAgICBiMiA9IGJbMl0sXG4gICAgYjMgPSBiWzNdO1xuICBvdXRbMF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzFdID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFsyXSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbM10gPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMztcbiAgYjAgPSBiWzRdO1xuICBiMSA9IGJbNV07XG4gIGIyID0gYls2XTtcbiAgYjMgPSBiWzddO1xuICBvdXRbNF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzVdID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFs2XSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbN10gPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMztcbiAgYjAgPSBiWzhdO1xuICBiMSA9IGJbOV07XG4gIGIyID0gYlsxMF07XG4gIGIzID0gYlsxMV07XG4gIG91dFs4XSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xuICBvdXRbOV0gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzEwXSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbMTFdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYlsxMl07XG4gIGIxID0gYlsxM107XG4gIGIyID0gYlsxNF07XG4gIGIzID0gYlsxNV07XG4gIG91dFsxMl0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzEzXSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbMTRdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gIG91dFsxNV0gPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIHggPSB2WzBdLFxuICAgIHkgPSB2WzFdLFxuICAgIHogPSB2WzJdO1xuICB2YXIgYTAwLCBhMDEsIGEwMiwgYTAzO1xuICB2YXIgYTEwLCBhMTEsIGExMiwgYTEzO1xuICB2YXIgYTIwLCBhMjEsIGEyMiwgYTIzO1xuICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gIH0gZWxzZSB7XG4gICAgYTAwID0gYVswXTtcbiAgICBhMDEgPSBhWzFdO1xuICAgIGEwMiA9IGFbMl07XG4gICAgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdO1xuICAgIGExMSA9IGFbNV07XG4gICAgYTEyID0gYVs2XTtcbiAgICBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07XG4gICAgYTIxID0gYVs5XTtcbiAgICBhMjIgPSBhWzEwXTtcbiAgICBhMjMgPSBhWzExXTtcbiAgICBvdXRbMF0gPSBhMDA7XG4gICAgb3V0WzFdID0gYTAxO1xuICAgIG91dFsyXSA9IGEwMjtcbiAgICBvdXRbM10gPSBhMDM7XG4gICAgb3V0WzRdID0gYTEwO1xuICAgIG91dFs1XSA9IGExMTtcbiAgICBvdXRbNl0gPSBhMTI7XG4gICAgb3V0WzddID0gYTEzO1xuICAgIG91dFs4XSA9IGEyMDtcbiAgICBvdXRbOV0gPSBhMjE7XG4gICAgb3V0WzEwXSA9IGEyMjtcbiAgICBvdXRbMTFdID0gYTIzO1xuICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzMgbm90IHVzaW5nIHZlY3Rvcml6YXRpb25cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICoqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciB4ID0gdlswXSxcbiAgICB5ID0gdlsxXSxcbiAgICB6ID0gdlsyXTtcbiAgb3V0WzBdID0gYVswXSAqIHg7XG4gIG91dFsxXSA9IGFbMV0gKiB4O1xuICBvdXRbMl0gPSBhWzJdICogeDtcbiAgb3V0WzNdID0gYVszXSAqIHg7XG4gIG91dFs0XSA9IGFbNF0gKiB5O1xuICBvdXRbNV0gPSBhWzVdICogeTtcbiAgb3V0WzZdID0gYVs2XSAqIHk7XG4gIG91dFs3XSA9IGFbN10gKiB5O1xuICBvdXRbOF0gPSBhWzhdICogejtcbiAgb3V0WzldID0gYVs5XSAqIHo7XG4gIG91dFsxMF0gPSBhWzEwXSAqIHo7XG4gIG91dFsxMV0gPSBhWzExXSAqIHo7XG4gIG91dFsxMl0gPSBhWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdO1xuICBvdXRbMTRdID0gYVsxNF07XG4gIG91dFsxNV0gPSBhWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICB5ID0gYXhpc1sxXSxcbiAgICB6ID0gYXhpc1syXTtcbiAgdmFyIGxlbiA9IE1hdGguaHlwb3QoeCwgeSwgeik7XG4gIHZhciBzLCBjLCB0O1xuICB2YXIgYTAwLCBhMDEsIGEwMiwgYTAzO1xuICB2YXIgYTEwLCBhMTEsIGExMiwgYTEzO1xuICB2YXIgYTIwLCBhMjEsIGEyMiwgYTIzO1xuICB2YXIgYjAwLCBiMDEsIGIwMjtcbiAgdmFyIGIxMCwgYjExLCBiMTI7XG4gIHZhciBiMjAsIGIyMSwgYjIyO1xuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxlbiA9IDEgLyBsZW47XG4gIHggKj0gbGVuO1xuICB5ICo9IGxlbjtcbiAgeiAqPSBsZW47XG4gIHMgPSBNYXRoLnNpbihyYWQpO1xuICBjID0gTWF0aC5jb3MocmFkKTtcbiAgdCA9IDEgLSBjO1xuICBhMDAgPSBhWzBdO1xuICBhMDEgPSBhWzFdO1xuICBhMDIgPSBhWzJdO1xuICBhMDMgPSBhWzNdO1xuICBhMTAgPSBhWzRdO1xuICBhMTEgPSBhWzVdO1xuICBhMTIgPSBhWzZdO1xuICBhMTMgPSBhWzddO1xuICBhMjAgPSBhWzhdO1xuICBhMjEgPSBhWzldO1xuICBhMjIgPSBhWzEwXTtcbiAgYTIzID0gYVsxMV07IC8vIENvbnN0cnVjdCB0aGUgZWxlbWVudHMgb2YgdGhlIHJvdGF0aW9uIG1hdHJpeFxuXG4gIGIwMCA9IHggKiB4ICogdCArIGM7XG4gIGIwMSA9IHkgKiB4ICogdCArIHogKiBzO1xuICBiMDIgPSB6ICogeCAqIHQgLSB5ICogcztcbiAgYjEwID0geCAqIHkgKiB0IC0geiAqIHM7XG4gIGIxMSA9IHkgKiB5ICogdCArIGM7XG4gIGIxMiA9IHogKiB5ICogdCArIHggKiBzO1xuICBiMjAgPSB4ICogeiAqIHQgKyB5ICogcztcbiAgYjIxID0geSAqIHogKiB0IC0geCAqIHM7XG4gIGIyMiA9IHogKiB6ICogdCArIGM7IC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyO1xuICBvdXRbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gIG91dFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcbiAgb3V0WzNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyO1xuICBvdXRbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTI7XG4gIG91dFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMjtcbiAgb3V0WzZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyO1xuICBvdXRbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTI7XG4gIG91dFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMjtcbiAgb3V0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyO1xuICBvdXRbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyO1xuICBvdXRbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyO1xuICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBhMTAgPSBhWzRdO1xuICB2YXIgYTExID0gYVs1XTtcbiAgdmFyIGExMiA9IGFbNl07XG4gIHZhciBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XTtcbiAgdmFyIGEyMSA9IGFbOV07XG4gIHZhciBhMjIgPSBhWzEwXTtcbiAgdmFyIGEyMyA9IGFbMTFdO1xuICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBhMDAgPSBhWzBdO1xuICB2YXIgYTAxID0gYVsxXTtcbiAgdmFyIGEwMiA9IGFbMl07XG4gIHZhciBhMDMgPSBhWzNdO1xuICB2YXIgYTIwID0gYVs4XTtcbiAgdmFyIGEyMSA9IGFbOV07XG4gIHZhciBhMjIgPSBhWzEwXTtcbiAgdmFyIGEyMyA9IGFbMTFdO1xuICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgLSBhMjIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gIG91dFs5XSA9IGEwMSAqIHMgKyBhMjEgKiBjO1xuICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBhMDAgPSBhWzBdO1xuICB2YXIgYTAxID0gYVsxXTtcbiAgdmFyIGEwMiA9IGFbMl07XG4gIHZhciBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XTtcbiAgdmFyIGExMSA9IGFbNV07XG4gIHZhciBhMTIgPSBhWzZdO1xuICB2YXIgYTEzID0gYVs3XTtcbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSB2WzFdO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gdlsyXTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZShkZXN0LCBkZXN0LCByYWQsIGF4aXMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCwgYXhpcykge1xuICB2YXIgeCA9IGF4aXNbMF0sXG4gICAgeSA9IGF4aXNbMV0sXG4gICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcbiAgaWYgKGxlbiA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZW4gPSAxIC8gbGVuO1xuICB4ICo9IGxlbjtcbiAgeSAqPSBsZW47XG4gIHogKj0gbGVuO1xuICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgYyA9IE1hdGguY29zKHJhZCk7XG4gIHQgPSAxIC0gYzsgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSB4ICogeCAqIHQgKyBjO1xuICBvdXRbMV0gPSB5ICogeCAqIHQgKyB6ICogcztcbiAgb3V0WzJdID0geiAqIHggKiB0IC0geSAqIHM7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHggKiB5ICogdCAtIHogKiBzO1xuICBvdXRbNV0gPSB5ICogeSAqIHQgKyBjO1xuICBvdXRbNl0gPSB6ICogeSAqIHQgKyB4ICogcztcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geCAqIHogKiB0ICsgeSAqIHM7XG4gIG91dFs5XSA9IHkgKiB6ICogdCAtIHggKiBzO1xuICBvdXRbMTBdID0geiAqIHogKiB0ICsgYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVgoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWFJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpOyAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gcztcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gLXM7XG4gIG91dFsxMF0gPSBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWShkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21ZUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAtcztcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gcztcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVaKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVpSb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTsgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IC1zO1xuICBvdXRbNV0gPSBjO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgcSwgdikge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLFxuICAgIHkgPSBxWzFdLFxuICAgIHogPSBxWzJdLFxuICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB4eSA9IHggKiB5MjtcbiAgdmFyIHh6ID0geCAqIHoyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB5eiA9IHkgKiB6MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICBvdXRbMV0gPSB4eSArIHd6O1xuICBvdXRbMl0gPSB4eiAtIHd5O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4eSAtIHd6O1xuICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICBvdXRbNl0gPSB5eiArIHd4O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4eiArIHd5O1xuICBvdXRbOV0gPSB5eiAtIHd4O1xuICBvdXRbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDQgZnJvbSBhIGR1YWwgcXVhdC5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBNYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSBEdWFsIFF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHttYXQ0fSBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWF0MihvdXQsIGEpIHtcbiAgdmFyIHRyYW5zbGF0aW9uID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIHZhciBieCA9IC1hWzBdLFxuICAgIGJ5ID0gLWFbMV0sXG4gICAgYnogPSAtYVsyXSxcbiAgICBidyA9IGFbM10sXG4gICAgYXggPSBhWzRdLFxuICAgIGF5ID0gYVs1XSxcbiAgICBheiA9IGFbNl0sXG4gICAgYXcgPSBhWzddO1xuICB2YXIgbWFnbml0dWRlID0gYnggKiBieCArIGJ5ICogYnkgKyBieiAqIGJ6ICsgYncgKiBidzsgLy9Pbmx5IHNjYWxlIGlmIGl0IG1ha2VzIHNlbnNlXG5cbiAgaWYgKG1hZ25pdHVkZSA+IDApIHtcbiAgICB0cmFuc2xhdGlvblswXSA9IChheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5KSAqIDIgLyBtYWduaXR1ZGU7XG4gICAgdHJhbnNsYXRpb25bMV0gPSAoYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieikgKiAyIC8gbWFnbml0dWRlO1xuICAgIHRyYW5zbGF0aW9uWzJdID0gKGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngpICogMiAvIG1hZ25pdHVkZTtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc2xhdGlvblswXSA9IChheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5KSAqIDI7XG4gICAgdHJhbnNsYXRpb25bMV0gPSAoYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieikgKiAyO1xuICAgIHRyYW5zbGF0aW9uWzJdID0gKGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngpICogMjtcbiAgfVxuICBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIGEsIHRyYW5zbGF0aW9uKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yIGNvbXBvbmVudCBvZiBhIHRyYW5zZm9ybWF0aW9uXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLFxuICogIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yXG4gKiAgb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSAge3ZlYzN9IG91dCBWZWN0b3IgdG8gcmVjZWl2ZSB0cmFuc2xhdGlvbiBjb21wb25lbnRcbiAqIEBwYXJhbSAge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcbiAqIEByZXR1cm4ge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2xhdGlvbihvdXQsIG1hdCkge1xuICBvdXRbMF0gPSBtYXRbMTJdO1xuICBvdXRbMV0gPSBtYXRbMTNdO1xuICBvdXRbMl0gPSBtYXRbMTRdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlXG4gKiAgd2l0aCBhIG5vcm1hbGl6ZWQgUXVhdGVybmlvbiBwYXJhbXRlciwgdGhlIHJldHVybmVkIHZlY3RvciB3aWxsIGJlXG4gKiAgdGhlIHNhbWUgYXMgdGhlIHNjYWxpbmcgdmVjdG9yXG4gKiAgb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSAge3ZlYzN9IG91dCBWZWN0b3IgdG8gcmVjZWl2ZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnRcbiAqIEBwYXJhbSAge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcbiAqIEByZXR1cm4ge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2FsaW5nKG91dCwgbWF0KSB7XG4gIHZhciBtMTEgPSBtYXRbMF07XG4gIHZhciBtMTIgPSBtYXRbMV07XG4gIHZhciBtMTMgPSBtYXRbMl07XG4gIHZhciBtMjEgPSBtYXRbNF07XG4gIHZhciBtMjIgPSBtYXRbNV07XG4gIHZhciBtMjMgPSBtYXRbNl07XG4gIHZhciBtMzEgPSBtYXRbOF07XG4gIHZhciBtMzIgPSBtYXRbOV07XG4gIHZhciBtMzMgPSBtYXRbMTBdO1xuICBvdXRbMF0gPSBNYXRoLmh5cG90KG0xMSwgbTEyLCBtMTMpO1xuICBvdXRbMV0gPSBNYXRoLmh5cG90KG0yMSwgbTIyLCBtMjMpO1xuICBvdXRbMl0gPSBNYXRoLmh5cG90KG0zMSwgbTMyLCBtMzMpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJvdGF0aW9uYWwgY29tcG9uZW50XG4gKiAgb2YgYSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGhcbiAqICBmcm9tUm90YXRpb25UcmFuc2xhdGlvbiwgdGhlIHJldHVybmVkIHF1YXRlcm5pb24gd2lsbCBiZSB0aGVcbiAqICBzYW1lIGFzIHRoZSBxdWF0ZXJuaW9uIG9yaWdpbmFsbHkgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBRdWF0ZXJuaW9uIHRvIHJlY2VpdmUgdGhlIHJvdGF0aW9uIGNvbXBvbmVudFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHtxdWF0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um90YXRpb24ob3V0LCBtYXQpIHtcbiAgdmFyIHNjYWxpbmcgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgZ2V0U2NhbGluZyhzY2FsaW5nLCBtYXQpO1xuICB2YXIgaXMxID0gMSAvIHNjYWxpbmdbMF07XG4gIHZhciBpczIgPSAxIC8gc2NhbGluZ1sxXTtcbiAgdmFyIGlzMyA9IDEgLyBzY2FsaW5nWzJdO1xuICB2YXIgc20xMSA9IG1hdFswXSAqIGlzMTtcbiAgdmFyIHNtMTIgPSBtYXRbMV0gKiBpczI7XG4gIHZhciBzbTEzID0gbWF0WzJdICogaXMzO1xuICB2YXIgc20yMSA9IG1hdFs0XSAqIGlzMTtcbiAgdmFyIHNtMjIgPSBtYXRbNV0gKiBpczI7XG4gIHZhciBzbTIzID0gbWF0WzZdICogaXMzO1xuICB2YXIgc20zMSA9IG1hdFs4XSAqIGlzMTtcbiAgdmFyIHNtMzIgPSBtYXRbOV0gKiBpczI7XG4gIHZhciBzbTMzID0gbWF0WzEwXSAqIGlzMztcbiAgdmFyIHRyYWNlID0gc20xMSArIHNtMjIgKyBzbTMzO1xuICB2YXIgUyA9IDA7XG4gIGlmICh0cmFjZSA+IDApIHtcbiAgICBTID0gTWF0aC5zcXJ0KHRyYWNlICsgMS4wKSAqIDI7XG4gICAgb3V0WzNdID0gMC4yNSAqIFM7XG4gICAgb3V0WzBdID0gKHNtMjMgLSBzbTMyKSAvIFM7XG4gICAgb3V0WzFdID0gKHNtMzEgLSBzbTEzKSAvIFM7XG4gICAgb3V0WzJdID0gKHNtMTIgLSBzbTIxKSAvIFM7XG4gIH0gZWxzZSBpZiAoc20xMSA+IHNtMjIgJiYgc20xMSA+IHNtMzMpIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIHNtMTEgLSBzbTIyIC0gc20zMykgKiAyO1xuICAgIG91dFszXSA9IChzbTIzIC0gc20zMikgLyBTO1xuICAgIG91dFswXSA9IDAuMjUgKiBTO1xuICAgIG91dFsxXSA9IChzbTEyICsgc20yMSkgLyBTO1xuICAgIG91dFsyXSA9IChzbTMxICsgc20xMykgLyBTO1xuICB9IGVsc2UgaWYgKHNtMjIgPiBzbTMzKSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTIyIC0gc20xMSAtIHNtMzMpICogMjtcbiAgICBvdXRbM10gPSAoc20zMSAtIHNtMTMpIC8gUztcbiAgICBvdXRbMF0gPSAoc20xMiArIHNtMjEpIC8gUztcbiAgICBvdXRbMV0gPSAwLjI1ICogUztcbiAgICBvdXRbMl0gPSAoc20yMyArIHNtMzIpIC8gUztcbiAgfSBlbHNlIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIHNtMzMgLSBzbTExIC0gc20yMikgKiAyO1xuICAgIG91dFszXSA9IChzbTEyIC0gc20yMSkgLyBTO1xuICAgIG91dFswXSA9IChzbTMxICsgc20xMykgLyBTO1xuICAgIG91dFsxXSA9IChzbTIzICsgc20zMikgLyBTO1xuICAgIG91dFsyXSA9IDAuMjUgKiBTO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gcyBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlKG91dCwgcSwgdiwgcykge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLFxuICAgIHkgPSBxWzFdLFxuICAgIHogPSBxWzJdLFxuICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB4eSA9IHggKiB5MjtcbiAgdmFyIHh6ID0geCAqIHoyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB5eiA9IHkgKiB6MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICB2YXIgc3ggPSBzWzBdO1xuICB2YXIgc3kgPSBzWzFdO1xuICB2YXIgc3ogPSBzWzJdO1xuICBvdXRbMF0gPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgb3V0WzFdID0gKHh5ICsgd3opICogc3g7XG4gIG91dFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAoeHkgLSB3eikgKiBzeTtcbiAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gIG91dFs2XSA9ICh5eiArIHd4KSAqIHN5O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAoeHogKyB3eSkgKiBzejtcbiAgb3V0WzldID0gKHl6IC0gd3gpICogc3o7XG4gIG91dFsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZSwgcm90YXRpbmcgYW5kIHNjYWxpbmcgYXJvdW5kIHRoZSBnaXZlbiBvcmlnaW5cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgb3JpZ2luKTtcbiAqICAgICBsZXQgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBzY2FsZSlcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBuZWdhdGl2ZU9yaWdpbik7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBzIFNjYWxpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gbyBUaGUgb3JpZ2luIHZlY3RvciBhcm91bmQgd2hpY2ggdG8gc2NhbGUgYW5kIHJvdGF0ZVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luKG91dCwgcSwgdiwgcywgbykge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLFxuICAgIHkgPSBxWzFdLFxuICAgIHogPSBxWzJdLFxuICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB4eSA9IHggKiB5MjtcbiAgdmFyIHh6ID0geCAqIHoyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB5eiA9IHkgKiB6MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICB2YXIgc3ggPSBzWzBdO1xuICB2YXIgc3kgPSBzWzFdO1xuICB2YXIgc3ogPSBzWzJdO1xuICB2YXIgb3ggPSBvWzBdO1xuICB2YXIgb3kgPSBvWzFdO1xuICB2YXIgb3ogPSBvWzJdO1xuICB2YXIgb3V0MCA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICB2YXIgb3V0MSA9ICh4eSArIHd6KSAqIHN4O1xuICB2YXIgb3V0MiA9ICh4eiAtIHd5KSAqIHN4O1xuICB2YXIgb3V0NCA9ICh4eSAtIHd6KSAqIHN5O1xuICB2YXIgb3V0NSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICB2YXIgb3V0NiA9ICh5eiArIHd4KSAqIHN5O1xuICB2YXIgb3V0OCA9ICh4eiArIHd5KSAqIHN6O1xuICB2YXIgb3V0OSA9ICh5eiAtIHd4KSAqIHN6O1xuICB2YXIgb3V0MTAgPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgb3V0WzBdID0gb3V0MDtcbiAgb3V0WzFdID0gb3V0MTtcbiAgb3V0WzJdID0gb3V0MjtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gb3V0NDtcbiAgb3V0WzVdID0gb3V0NTtcbiAgb3V0WzZdID0gb3V0NjtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gb3V0ODtcbiAgb3V0WzldID0gb3V0OTtcbiAgb3V0WzEwXSA9IG91dDEwO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF0gKyBveCAtIChvdXQwICogb3ggKyBvdXQ0ICogb3kgKyBvdXQ4ICogb3opO1xuICBvdXRbMTNdID0gdlsxXSArIG95IC0gKG91dDEgKiBveCArIG91dDUgKiBveSArIG91dDkgKiBveik7XG4gIG91dFsxNF0gPSB2WzJdICsgb3ogLSAob3V0MiAqIG94ICsgb3V0NiAqIG95ICsgb3V0MTAgKiBveik7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgNHg0IG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICB2YXIgeCA9IHFbMF0sXG4gICAgeSA9IHFbMV0sXG4gICAgeiA9IHFbMl0sXG4gICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHl4ID0geSAqIHgyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB6eCA9IHogKiB4MjtcbiAgdmFyIHp5ID0geiAqIHkyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbMl0gPSB6eCAtIHd5O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB5eCAtIHd6O1xuICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgb3V0WzZdID0genkgKyB3eDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0genggKyB3eTtcbiAgb3V0WzldID0genkgLSB3eDtcbiAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIGZydXN0dW0gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcnVzdHVtKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgdmFyIHJsID0gMSAvIChyaWdodCAtIGxlZnQpO1xuICB2YXIgdGIgPSAxIC8gKHRvcCAtIGJvdHRvbSk7XG4gIHZhciBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IG5lYXIgKiAyICogcmw7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IG5lYXIgKiAyICogdGI7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IChyaWdodCArIGxlZnQpICogcmw7XG4gIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XG4gIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSBmYXIgKiBuZWFyICogMiAqIG5mO1xuICBvdXRbMTVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzLlxuICogVGhlIG5lYXIvZmFyIGNsaXAgcGxhbmVzIGNvcnJlc3BvbmQgdG8gYSBub3JtYWxpemVkIGRldmljZSBjb29yZGluYXRlIFogcmFuZ2Ugb2YgWy0xLCAxXSxcbiAqIHdoaWNoIG1hdGNoZXMgV2ViR0wvT3BlbkdMJ3MgY2xpcCB2b2x1bWUuXG4gKiBQYXNzaW5nIG51bGwvdW5kZWZpbmVkL25vIHZhbHVlIGZvciBmYXIgd2lsbCBnZW5lcmF0ZSBpbmZpbml0ZSBwcm9qZWN0aW9uIG1hdHJpeC5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgQXNwZWN0IHJhdGlvLiB0eXBpY2FsbHkgdmlld3BvcnQgd2lkdGgvaGVpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bSwgY2FuIGJlIG51bGwgb3IgSW5maW5pdHlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGVyc3BlY3RpdmVOTyhvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgIG5mO1xuICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBmO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTFdID0gLTE7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE1XSA9IDA7XG4gIGlmIChmYXIgIT0gbnVsbCAmJiBmYXIgIT09IEluZmluaXR5KSB7XG4gICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTRdID0gMiAqIGZhciAqIG5lYXIgKiBuZjtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMTBdID0gLTE7XG4gICAgb3V0WzE0XSA9IC0yICogbmVhcjtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQucGVyc3BlY3RpdmVOT31cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgcGVyc3BlY3RpdmUgPSBwZXJzcGVjdGl2ZU5PO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCBzdWl0YWJsZSBmb3IgV2ViR1BVIHdpdGggdGhlIGdpdmVuIGJvdW5kcy5cbiAqIFRoZSBuZWFyL2ZhciBjbGlwIHBsYW5lcyBjb3JyZXNwb25kIHRvIGEgbm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZSBaIHJhbmdlIG9mIFswLCAxXSxcbiAqIHdoaWNoIG1hdGNoZXMgV2ViR1BVL1Z1bGthbi9EaXJlY3RYL01ldGFsJ3MgY2xpcCB2b2x1bWUuXG4gKiBQYXNzaW5nIG51bGwvdW5kZWZpbmVkL25vIHZhbHVlIGZvciBmYXIgd2lsbCBnZW5lcmF0ZSBpbmZpbml0ZSBwcm9qZWN0aW9uIG1hdHJpeC5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgQXNwZWN0IHJhdGlvLiB0eXBpY2FsbHkgdmlld3BvcnQgd2lkdGgvaGVpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bSwgY2FuIGJlIG51bGwgb3IgSW5maW5pdHlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGVyc3BlY3RpdmVaTyhvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgIG5mO1xuICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBmO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTFdID0gLTE7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE1XSA9IDA7XG4gIGlmIChmYXIgIT0gbnVsbCAmJiBmYXIgIT09IEluZmluaXR5KSB7XG4gICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxMF0gPSBmYXIgKiBuZjtcbiAgICBvdXRbMTRdID0gZmFyICogbmVhciAqIG5mO1xuICB9IGVsc2Uge1xuICAgIG91dFsxMF0gPSAtMTtcbiAgICBvdXRbMTRdID0gLW5lYXI7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZmllbGQgb2Ygdmlldy5cbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCBmb3IgZ2VuZXJhdGluZyBwcm9qZWN0aW9uIG1hdHJpY2VzIHRvIGJlIHVzZWRcbiAqIHdpdGggdGhlIHN0aWxsIGV4cGVyaWVtZW50YWwgV2ViVlIgQVBJLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBmb3YgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyB2YWx1ZXM6IHVwRGVncmVlcywgZG93bkRlZ3JlZXMsIGxlZnREZWdyZWVzLCByaWdodERlZ3JlZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgdmFyIHVwVGFuID0gTWF0aC50YW4oZm92LnVwRGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciBkb3duVGFuID0gTWF0aC50YW4oZm92LmRvd25EZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIGxlZnRUYW4gPSBNYXRoLnRhbihmb3YubGVmdERlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgcmlnaHRUYW4gPSBNYXRoLnRhbihmb3YucmlnaHREZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIHhTY2FsZSA9IDIuMCAvIChsZWZ0VGFuICsgcmlnaHRUYW4pO1xuICB2YXIgeVNjYWxlID0gMi4wIC8gKHVwVGFuICsgZG93blRhbik7XG4gIG91dFswXSA9IHhTY2FsZTtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIG91dFszXSA9IDAuMDtcbiAgb3V0WzRdID0gMC4wO1xuICBvdXRbNV0gPSB5U2NhbGU7XG4gIG91dFs2XSA9IDAuMDtcbiAgb3V0WzddID0gMC4wO1xuICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgb3V0WzldID0gKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjU7XG4gIG91dFsxMF0gPSBmYXIgLyAobmVhciAtIGZhcik7XG4gIG91dFsxMV0gPSAtMS4wO1xuICBvdXRbMTJdID0gMC4wO1xuICBvdXRbMTNdID0gMC4wO1xuICBvdXRbMTRdID0gZmFyICogbmVhciAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzE1XSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHMuXG4gKiBUaGUgbmVhci9mYXIgY2xpcCBwbGFuZXMgY29ycmVzcG9uZCB0byBhIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGUgWiByYW5nZSBvZiBbLTEsIDFdLFxuICogd2hpY2ggbWF0Y2hlcyBXZWJHTC9PcGVuR0wncyBjbGlwIHZvbHVtZS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gb3J0aG9OTyhvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gIHZhciBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KTtcbiAgdmFyIGJ0ID0gMSAvIChib3R0b20gLSB0b3ApO1xuICB2YXIgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSAtMiAqIGxyO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAtMiAqIGJ0O1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMiAqIG5mO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG4gIG91dFsxM10gPSAodG9wICsgYm90dG9tKSAqIGJ0O1xuICBvdXRbMTRdID0gKGZhciArIG5lYXIpICogbmY7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQub3J0aG9OT31cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgb3J0aG8gPSBvcnRob05PO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBvcnRob2dvbmFsIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kcy5cbiAqIFRoZSBuZWFyL2ZhciBjbGlwIHBsYW5lcyBjb3JyZXNwb25kIHRvIGEgbm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZSBaIHJhbmdlIG9mIFswLCAxXSxcbiAqIHdoaWNoIG1hdGNoZXMgV2ViR1BVL1Z1bGthbi9EaXJlY3RYL01ldGFsJ3MgY2xpcCB2b2x1bWUuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG9ydGhvWk8ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICB2YXIgbHIgPSAxIC8gKGxlZnQgLSByaWdodCk7XG4gIHZhciBidCA9IDEgLyAoYm90dG9tIC0gdG9wKTtcbiAgdmFyIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gLTIgKiBscjtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gLTIgKiBidDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IG5mO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG4gIG91dFsxM10gPSAodG9wICsgYm90dG9tKSAqIGJ0O1xuICBvdXRbMTRdID0gbmVhciAqIG5mO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXMuXG4gKiBJZiB5b3Ugd2FudCBhIG1hdHJpeCB0aGF0IGFjdHVhbGx5IG1ha2VzIGFuIG9iamVjdCBsb29rIGF0IGFub3RoZXIgb2JqZWN0LCB5b3Ugc2hvdWxkIHVzZSB0YXJnZXRUbyBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxvb2tBdChvdXQsIGV5ZSwgY2VudGVyLCB1cCkge1xuICB2YXIgeDAsIHgxLCB4MiwgeTAsIHkxLCB5MiwgejAsIHoxLCB6MiwgbGVuO1xuICB2YXIgZXlleCA9IGV5ZVswXTtcbiAgdmFyIGV5ZXkgPSBleWVbMV07XG4gIHZhciBleWV6ID0gZXllWzJdO1xuICB2YXIgdXB4ID0gdXBbMF07XG4gIHZhciB1cHkgPSB1cFsxXTtcbiAgdmFyIHVweiA9IHVwWzJdO1xuICB2YXIgY2VudGVyeCA9IGNlbnRlclswXTtcbiAgdmFyIGNlbnRlcnkgPSBjZW50ZXJbMV07XG4gIHZhciBjZW50ZXJ6ID0gY2VudGVyWzJdO1xuICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJiBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCBnbE1hdHJpeC5FUFNJTE9OICYmIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gaWRlbnRpdHkob3V0KTtcbiAgfVxuICB6MCA9IGV5ZXggLSBjZW50ZXJ4O1xuICB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICB6MiA9IGV5ZXogLSBjZW50ZXJ6O1xuICBsZW4gPSAxIC8gTWF0aC5oeXBvdCh6MCwgejEsIHoyKTtcbiAgejAgKj0gbGVuO1xuICB6MSAqPSBsZW47XG4gIHoyICo9IGxlbjtcbiAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgbGVuID0gTWF0aC5oeXBvdCh4MCwgeDEsIHgyKTtcbiAgaWYgKCFsZW4pIHtcbiAgICB4MCA9IDA7XG4gICAgeDEgPSAwO1xuICAgIHgyID0gMDtcbiAgfSBlbHNlIHtcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHgwICo9IGxlbjtcbiAgICB4MSAqPSBsZW47XG4gICAgeDIgKj0gbGVuO1xuICB9XG4gIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG4gIGxlbiA9IE1hdGguaHlwb3QoeTAsIHkxLCB5Mik7XG4gIGlmICghbGVuKSB7XG4gICAgeTAgPSAwO1xuICAgIHkxID0gMDtcbiAgICB5MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB5MCAqPSBsZW47XG4gICAgeTEgKj0gbGVuO1xuICAgIHkyICo9IGxlbjtcbiAgfVxuICBvdXRbMF0gPSB4MDtcbiAgb3V0WzFdID0geTA7XG4gIG91dFsyXSA9IHowO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4MTtcbiAgb3V0WzVdID0geTE7XG4gIG91dFs2XSA9IHoxO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4MjtcbiAgb3V0WzldID0geTI7XG4gIG91dFsxMF0gPSB6MjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAtKHgwICogZXlleCArIHgxICogZXlleSArIHgyICogZXlleik7XG4gIG91dFsxM10gPSAtKHkwICogZXlleCArIHkxICogZXlleSArIHkyICogZXlleik7XG4gIG91dFsxNF0gPSAtKHowICogZXlleCArIHoxICogZXlleSArIHoyICogZXlleik7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBtYXRyaXggdGhhdCBtYWtlcyBzb21ldGhpbmcgbG9vayBhdCBzb21ldGhpbmcgZWxzZS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0YXJnZXRUbyhvdXQsIGV5ZSwgdGFyZ2V0LCB1cCkge1xuICB2YXIgZXlleCA9IGV5ZVswXSxcbiAgICBleWV5ID0gZXllWzFdLFxuICAgIGV5ZXogPSBleWVbMl0sXG4gICAgdXB4ID0gdXBbMF0sXG4gICAgdXB5ID0gdXBbMV0sXG4gICAgdXB6ID0gdXBbMl07XG4gIHZhciB6MCA9IGV5ZXggLSB0YXJnZXRbMF0sXG4gICAgejEgPSBleWV5IC0gdGFyZ2V0WzFdLFxuICAgIHoyID0gZXlleiAtIHRhcmdldFsyXTtcbiAgdmFyIGxlbiA9IHowICogejAgKyB6MSAqIHoxICsgejIgKiB6MjtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG4gIH1cbiAgdmFyIHgwID0gdXB5ICogejIgLSB1cHogKiB6MSxcbiAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejIsXG4gICAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICBsZW4gPSB4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDI7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgIHgwICo9IGxlbjtcbiAgICB4MSAqPSBsZW47XG4gICAgeDIgKj0gbGVuO1xuICB9XG4gIG91dFswXSA9IHgwO1xuICBvdXRbMV0gPSB4MTtcbiAgb3V0WzJdID0geDI7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHoxICogeDIgLSB6MiAqIHgxO1xuICBvdXRbNV0gPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgb3V0WzZdID0gejAgKiB4MSAtIHoxICogeDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHowO1xuICBvdXRbOV0gPSB6MTtcbiAgb3V0WzEwXSA9IHoyO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IGV5ZXg7XG4gIG91dFsxM10gPSBleWV5O1xuICBvdXRbMTRdID0gZXllejtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwibWF0NChcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIiwgXCIgKyBhWzRdICsgXCIsIFwiICsgYVs1XSArIFwiLCBcIiArIGFbNl0gKyBcIiwgXCIgKyBhWzddICsgXCIsIFwiICsgYVs4XSArIFwiLCBcIiArIGFbOV0gKyBcIiwgXCIgKyBhWzEwXSArIFwiLCBcIiArIGFbMTFdICsgXCIsIFwiICsgYVsxMl0gKyBcIiwgXCIgKyBhWzEzXSArIFwiLCBcIiArIGFbMTRdICsgXCIsIFwiICsgYVsxNV0gKyBcIilcIjtcbn1cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLmh5cG90KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0sIGFbNl0sIGFbN10sIGFbOF0sIGFbOV0sIGFbMTBdLCBhWzExXSwgYVsxMl0sIGFbMTNdLCBhWzE0XSwgYVsxNV0pO1xufVxuLyoqXG4gKiBBZGRzIHR3byBtYXQ0J3NcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdO1xuICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gIG91dFs5XSA9IGFbOV0gKyBiWzldO1xuICBvdXRbMTBdID0gYVsxMF0gKyBiWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV07XG4gIG91dFsxMl0gPSBhWzEyXSArIGJbMTJdO1xuICBvdXRbMTNdID0gYVsxM10gKyBiWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF07XG4gIG91dFsxNV0gPSBhWzE1XSArIGJbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICBvdXRbNl0gPSBhWzZdIC0gYls2XTtcbiAgb3V0WzddID0gYVs3XSAtIGJbN107XG4gIG91dFs4XSA9IGFbOF0gLSBiWzhdO1xuICBvdXRbOV0gPSBhWzldIC0gYls5XTtcbiAgb3V0WzEwXSA9IGFbMTBdIC0gYlsxMF07XG4gIG91dFsxMV0gPSBhWzExXSAtIGJbMTFdO1xuICBvdXRbMTJdID0gYVsxMl0gLSBiWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdIC0gYlsxM107XG4gIG91dFsxNF0gPSBhWzE0XSAtIGJbMTRdO1xuICBvdXRbMTVdID0gYVsxNV0gLSBiWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIG91dFs5XSA9IGFbOV0gKiBiO1xuICBvdXRbMTBdID0gYVsxMF0gKiBiO1xuICBvdXRbMTFdID0gYVsxMV0gKiBiO1xuICBvdXRbMTJdID0gYVsxMl0gKiBiO1xuICBvdXRbMTNdID0gYVsxM10gKiBiO1xuICBvdXRbMTRdID0gYVsxNF0gKiBiO1xuICBvdXRbMTVdID0gYVsxNV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBBZGRzIHR3byBtYXQ0J3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICBvdXRbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XSAqIHNjYWxlO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XSAqIHNjYWxlO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XSAqIHNjYWxlO1xuICBvdXRbN10gPSBhWzddICsgYls3XSAqIHNjYWxlO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XSAqIHNjYWxlO1xuICBvdXRbOV0gPSBhWzldICsgYls5XSAqIHNjYWxlO1xuICBvdXRbMTBdID0gYVsxMF0gKyBiWzEwXSAqIHNjYWxlO1xuICBvdXRbMTFdID0gYVsxMV0gKyBiWzExXSAqIHNjYWxlO1xuICBvdXRbMTJdID0gYVsxMl0gKyBiWzEyXSAqIHNjYWxlO1xuICBvdXRbMTNdID0gYVsxM10gKyBiWzEzXSAqIHNjYWxlO1xuICBvdXRbMTRdID0gYVsxNF0gKyBiWzE0XSAqIHNjYWxlO1xuICBvdXRbMTVdID0gYVsxNV0gKyBiWzE1XSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJiBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN10gJiYgYVs4XSA9PT0gYls4XSAmJiBhWzldID09PSBiWzldICYmIGFbMTBdID09PSBiWzEwXSAmJiBhWzExXSA9PT0gYlsxMV0gJiYgYVsxMl0gPT09IGJbMTJdICYmIGFbMTNdID09PSBiWzEzXSAmJiBhWzE0XSA9PT0gYlsxNF0gJiYgYVsxNV0gPT09IGJbMTVdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgIGExID0gYVsxXSxcbiAgICBhMiA9IGFbMl0sXG4gICAgYTMgPSBhWzNdO1xuICB2YXIgYTQgPSBhWzRdLFxuICAgIGE1ID0gYVs1XSxcbiAgICBhNiA9IGFbNl0sXG4gICAgYTcgPSBhWzddO1xuICB2YXIgYTggPSBhWzhdLFxuICAgIGE5ID0gYVs5XSxcbiAgICBhMTAgPSBhWzEwXSxcbiAgICBhMTEgPSBhWzExXTtcbiAgdmFyIGExMiA9IGFbMTJdLFxuICAgIGExMyA9IGFbMTNdLFxuICAgIGExNCA9IGFbMTRdLFxuICAgIGExNSA9IGFbMTVdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgIGIxID0gYlsxXSxcbiAgICBiMiA9IGJbMl0sXG4gICAgYjMgPSBiWzNdO1xuICB2YXIgYjQgPSBiWzRdLFxuICAgIGI1ID0gYls1XSxcbiAgICBiNiA9IGJbNl0sXG4gICAgYjcgPSBiWzddO1xuICB2YXIgYjggPSBiWzhdLFxuICAgIGI5ID0gYls5XSxcbiAgICBiMTAgPSBiWzEwXSxcbiAgICBiMTEgPSBiWzExXTtcbiAgdmFyIGIxMiA9IGJbMTJdLFxuICAgIGIxMyA9IGJbMTNdLFxuICAgIGIxNCA9IGJbMTRdLFxuICAgIGIxNSA9IGJbMTVdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiYgTWF0aC5hYnMoYTYgLSBiNikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE3KSwgTWF0aC5hYnMoYjcpKSAmJiBNYXRoLmFicyhhOCAtIGI4KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOCksIE1hdGguYWJzKGI4KSkgJiYgTWF0aC5hYnMoYTkgLSBiOSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTkpLCBNYXRoLmFicyhiOSkpICYmIE1hdGguYWJzKGExMCAtIGIxMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEwKSwgTWF0aC5hYnMoYjEwKSkgJiYgTWF0aC5hYnMoYTExIC0gYjExKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTEpLCBNYXRoLmFicyhiMTEpKSAmJiBNYXRoLmFicyhhMTIgLSBiMTIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMiksIE1hdGguYWJzKGIxMikpICYmIE1hdGguYWJzKGExMyAtIGIxMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEzKSwgTWF0aC5hYnMoYjEzKSkgJiYgTWF0aC5hYnMoYTE0IC0gYjE0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTQpLCBNYXRoLmFicyhiMTQpKSAmJiBNYXRoLmFicyhhMTUgLSBiMTUpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExNSksIE1hdGguYWJzKGIxNSkpO1xufVxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0OyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXG4gKiAyIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG1vZHVsZSB2ZWMyXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKlxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHkpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgeCwgeSkge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgeSA9IGJbMV0gLSBhWzFdO1xuICByZXR1cm4geCAqIHggKyB5ICogeTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHkpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIHJldHVybiB4ICogeCArIHkgKiB5O1xufVxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXTtcbiAgdmFyIGxlbiA9IHggKiB4ICsgeSAqIHk7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cbiAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCBtdXN0IGJ5IGRlZmluaXRpb24gcHJvZHVjZSBhIDNEIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIG91dFswXSA9IG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICBheSA9IGFbMV07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHNjYWxlO1xuICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MihvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyZChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDNcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDRcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzAnXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVsxMl07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlIGEgMkQgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIFRoZSB2ZWMyIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgYiwgcmFkKSB7XG4gIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgdmFyIHAwID0gYVswXSAtIGJbMF0sXG4gICAgcDEgPSBhWzFdIC0gYlsxXSxcbiAgICBzaW5DID0gTWF0aC5zaW4ocmFkKSxcbiAgICBjb3NDID0gTWF0aC5jb3MocmFkKTsgLy9wZXJmb3JtIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHAwICogY29zQyAtIHAxICogc2luQyArIGJbMF07XG4gIG91dFsxXSA9IHAwICogc2luQyArIHAxICogY29zQyArIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gMkQgdmVjdG9yc1xuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgVGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIFRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICB2YXIgeDEgPSBhWzBdLFxuICAgIHkxID0gYVsxXSxcbiAgICB4MiA9IGJbMF0sXG4gICAgeTIgPSBiWzFdLFxuICAgIC8vIG1hZyBpcyB0aGUgcHJvZHVjdCBvZiB0aGUgbWFnbml0dWRlcyBvZiBhIGFuZCBiXG4gICAgbWFnID0gTWF0aC5zcXJ0KHgxICogeDEgKyB5MSAqIHkxKSAqIE1hdGguc3FydCh4MiAqIHgyICsgeTIgKiB5MiksXG4gICAgLy8gbWFnICYmLi4gc2hvcnQgY2lyY3VpdHMgaWYgbWFnID09IDBcbiAgICBjb3NpbmUgPSBtYWcgJiYgKHgxICogeDIgKyB5MSAqIHkyKSAvIG1hZzsgLy8gTWF0aC5taW4oTWF0aC5tYXgoY29zaW5lLCAtMSksIDEpIGNsYW1wcyB0aGUgY29zaW5lIGJldHdlZW4gLTEgYW5kIDFcblxuICByZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KGNvc2luZSwgLTEpLCAxKSk7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gemVyb1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHplcm8ob3V0KSB7XG4gIG91dFswXSA9IDAuMDtcbiAgb3V0WzFdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwidmVjMihcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIpXCI7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV07XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgIGExID0gYVsxXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICBiMSA9IGJbMV07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpO1xufVxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBsZW4gPSBsZW5ndGg7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3ViID0gc3VidHJhY3Q7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGRpdiA9IGRpdmlkZTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBkaXN0ID0gZGlzdGFuY2U7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2U7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjMnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMi4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzJzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlYyA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIHZhciBpLCBsO1xuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSAyO1xuICAgIH1cbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oY291bnQgKiBzdHJpZGUgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICBhW2ldID0gdmVjWzBdO1xuICAgICAgYVtpICsgMV0gPSB2ZWNbMV07XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xufSgpOyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXG4gKiAzIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG1vZHVsZSB2ZWMzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXG4gKlxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHopO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHopIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHopIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWRkcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXTtcbiAgdmFyIHkgPSBiWzFdIC0gYVsxXTtcbiAgdmFyIHogPSBiWzJdIC0gYVsyXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSwgeik7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG59XG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cbiAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgb3V0WzJdID0gYVsyXSAqIGxlbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgIGF5ID0gYVsxXSxcbiAgICBheiA9IGFbMl07XG4gIHZhciBieCA9IGJbMF0sXG4gICAgYnkgPSBiWzFdLFxuICAgIGJ6ID0gYlsyXTtcbiAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgYXggPSBhWzBdO1xuICB2YXIgYXkgPSBhWzFdO1xuICB2YXIgYXogPSBhWzJdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBQZXJmb3JtcyBhIGhlcm1pdGUgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGhlcm1pdGUob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBmYWN0b3JUaW1lczIgPSB0ICogdDtcbiAgdmFyIGZhY3RvcjEgPSBmYWN0b3JUaW1lczIgKiAoMiAqIHQgLSAzKSArIDE7XG4gIHZhciBmYWN0b3IyID0gZmFjdG9yVGltZXMyICogKHQgLSAyKSArIHQ7XG4gIHZhciBmYWN0b3IzID0gZmFjdG9yVGltZXMyICogKHQgLSAxKTtcbiAgdmFyIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiAoMyAtIDIgKiB0KTtcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSBiZXppZXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGJlemllcihvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGludmVyc2VGYWN0b3IgPSAxIC0gdDtcbiAgdmFyIGludmVyc2VGYWN0b3JUaW1lc1R3byA9IGludmVyc2VGYWN0b3IgKiBpbnZlcnNlRmFjdG9yO1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIHZhciBmYWN0b3IxID0gaW52ZXJzZUZhY3RvclRpbWVzVHdvICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvcjIgPSAzICogdCAqIGludmVyc2VGYWN0b3JUaW1lc1R3bztcbiAgdmFyIGZhY3RvcjMgPSAzICogZmFjdG9yVGltZXMyICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiB0O1xuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcbiAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gIHZhciB6ID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgLSAxLjA7XG4gIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wIC0geiAqIHopICogc2NhbGU7XG4gIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlO1xuICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTtcbiAgb3V0WzJdID0geiAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV0sXG4gICAgeiA9IGFbMl07XG4gIHZhciB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdO1xuICB3ID0gdyB8fCAxLjA7XG4gIG91dFswXSA9IChtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSkgLyB3O1xuICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gdztcbiAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdLFxuICAgIHogPSBhWzJdO1xuICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl07XG4gIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XG4gKiBDYW4gYWxzbyBiZSB1c2VkIGZvciBkdWFsIHF1YXRlcm5pb25zLiAoTXVsdGlwbHkgaXQgd2l0aCB0aGUgcmVhbCBwYXJ0KVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1RdWF0KG91dCwgYSwgcSkge1xuICAvLyBiZW5jaG1hcmtzOiBodHRwczovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnMtZml4ZWRcbiAgdmFyIHF4ID0gcVswXSxcbiAgICBxeSA9IHFbMV0sXG4gICAgcXogPSBxWzJdLFxuICAgIHF3ID0gcVszXTtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdLFxuICAgIHogPSBhWzJdOyAvLyB2YXIgcXZlYyA9IFtxeCwgcXksIHF6XTtcbiAgLy8gdmFyIHV2ID0gdmVjMy5jcm9zcyhbXSwgcXZlYywgYSk7XG5cbiAgdmFyIHV2eCA9IHF5ICogeiAtIHF6ICogeSxcbiAgICB1dnkgPSBxeiAqIHggLSBxeCAqIHosXG4gICAgdXZ6ID0gcXggKiB5IC0gcXkgKiB4OyAvLyB2YXIgdXV2ID0gdmVjMy5jcm9zcyhbXSwgcXZlYywgdXYpO1xuXG4gIHZhciB1dXZ4ID0gcXkgKiB1dnogLSBxeiAqIHV2eSxcbiAgICB1dXZ5ID0gcXogKiB1dnggLSBxeCAqIHV2eixcbiAgICB1dXZ6ID0gcXggKiB1dnkgLSBxeSAqIHV2eDsgLy8gdmVjMy5zY2FsZSh1diwgdXYsIDIgKiB3KTtcblxuICB2YXIgdzIgPSBxdyAqIDI7XG4gIHV2eCAqPSB3MjtcbiAgdXZ5ICo9IHcyO1xuICB1dnogKj0gdzI7IC8vIHZlYzMuc2NhbGUodXV2LCB1dXYsIDIpO1xuXG4gIHV1dnggKj0gMjtcbiAgdXV2eSAqPSAyO1xuICB1dXZ6ICo9IDI7IC8vIHJldHVybiB2ZWMzLmFkZChvdXQsIGEsIHZlYzMuYWRkKG91dCwgdXYsIHV1dikpO1xuXG4gIG91dFswXSA9IHggKyB1dnggKyB1dXZ4O1xuICBvdXRbMV0gPSB5ICsgdXZ5ICsgdXV2eTtcbiAgb3V0WzJdID0geiArIHV2eiArIHV1dno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCBiLCByYWQpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFswXTtcbiAgclsxXSA9IHBbMV0gKiBNYXRoLmNvcyhyYWQpIC0gcFsyXSAqIE1hdGguc2luKHJhZCk7XG4gIHJbMl0gPSBwWzFdICogTWF0aC5zaW4ocmFkKSArIHBbMl0gKiBNYXRoLmNvcyhyYWQpOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeS1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzJdICogTWF0aC5zaW4ocmFkKSArIHBbMF0gKiBNYXRoLmNvcyhyYWQpO1xuICByWzFdID0gcFsxXTtcbiAgclsyXSA9IHBbMl0gKiBNYXRoLmNvcyhyYWQpIC0gcFswXSAqIE1hdGguc2luKHJhZCk7IC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgYiwgcmFkKSB7XG4gIHZhciBwID0gW10sXG4gICAgciA9IFtdOyAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTsgLy9wZXJmb3JtIHJvdGF0aW9uXG5cbiAgclswXSA9IHBbMF0gKiBNYXRoLmNvcyhyYWQpIC0gcFsxXSAqIE1hdGguc2luKHJhZCk7XG4gIHJbMV0gPSBwWzBdICogTWF0aC5zaW4ocmFkKSArIHBbMV0gKiBNYXRoLmNvcyhyYWQpO1xuICByWzJdID0gcFsyXTsgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgIGF5ID0gYVsxXSxcbiAgICBheiA9IGFbMl0sXG4gICAgYnggPSBiWzBdLFxuICAgIGJ5ID0gYlsxXSxcbiAgICBieiA9IGJbMl0sXG4gICAgbWFnMSA9IE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSArIGF6ICogYXopLFxuICAgIG1hZzIgPSBNYXRoLnNxcnQoYnggKiBieCArIGJ5ICogYnkgKyBieiAqIGJ6KSxcbiAgICBtYWcgPSBtYWcxICogbWFnMixcbiAgICBjb3NpbmUgPSBtYWcgJiYgZG90KGEsIGIpIC8gbWFnO1xuICByZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KGNvc2luZSwgLTEpLCAxKSk7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gemVyb1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHplcm8ob3V0KSB7XG4gIG91dFswXSA9IDAuMDtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJ2ZWMzKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIpXCI7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgYTEgPSBhWzFdLFxuICAgIGEyID0gYVsyXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICBiMSA9IGJbMV0sXG4gICAgYjIgPSBiWzJdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSk7XG59XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3ViID0gc3VidHJhY3Q7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGRpdiA9IGRpdmlkZTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBkaXN0ID0gZGlzdGFuY2U7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2U7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjM3MgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBmb3JFYWNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmVjID0gY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgdmFyIGksIGw7XG4gICAgaWYgKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDM7XG4gICAgfVxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIGwgPSBNYXRoLm1pbihjb3VudCAqIHN0cmlkZSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2ZWNbMF0gPSBhW2ldO1xuICAgICAgdmVjWzFdID0gYVtpICsgMV07XG4gICAgICB2ZWNbMl0gPSBhW2kgKyAyXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgICAgYVtpICsgMl0gPSB2ZWNbMl07XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xufSgpOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnQG1hdGguZ2wvd2ViLW1lcmNhdG9yOiBhc3NlcnRpb24gZmFpbGVkLicpO1xuICB9XG59IiwiaW1wb3J0IHsgY3JlYXRlTWF0NCwgdHJhbnNmb3JtVmVjdG9yLCBjbGFtcCwgbG9nMiB9IGZyb20gJy4vbWF0aC11dGlscyc7XG5pbXBvcnQgKiBhcyBtYXQ0IGZyb20gJ2dsLW1hdHJpeC9tYXQ0JztcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnZ2wtbWF0cml4L3ZlYzInO1xuaW1wb3J0ICogYXMgdmVjMyBmcm9tICdnbC1tYXRyaXgvdmVjMyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4vYXNzZXJ0JztcbmNvbnN0IFBJID0gTWF0aC5QSTtcbmNvbnN0IFBJXzQgPSBQSSAvIDQ7XG5jb25zdCBERUdSRUVTX1RPX1JBRElBTlMgPSBQSSAvIDE4MDtcbmNvbnN0IFJBRElBTlNfVE9fREVHUkVFUyA9IDE4MCAvIFBJO1xuY29uc3QgVElMRV9TSVpFID0gNTEyO1xuY29uc3QgRUFSVEhfQ0lSQ1VNRkVSRU5DRSA9IDQwLjAzZTY7XG5leHBvcnQgY29uc3QgTUFYX0xBVElUVURFID0gODUuMDUxMTI5O1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQUxUSVRVREUgPSAxLjU7XG5leHBvcnQgZnVuY3Rpb24gem9vbVRvU2NhbGUoem9vbSkge1xuICByZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2NhbGVUb1pvb20oc2NhbGUpIHtcbiAgcmV0dXJuIGxvZzIoc2NhbGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxuZ0xhdFRvV29ybGQobG5nTGF0KSB7XG4gIGNvbnN0IFtsbmcsIGxhdF0gPSBsbmdMYXQ7XG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUobG5nKSk7XG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUobGF0KSAmJiBsYXQgPj0gLTkwICYmIGxhdCA8PSA5MCwgJ2ludmFsaWQgbGF0aXR1ZGUnKTtcbiAgY29uc3QgbGFtYmRhMiA9IGxuZyAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgY29uc3QgcGhpMiA9IGxhdCAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgY29uc3QgeCA9IFRJTEVfU0laRSAqIChsYW1iZGEyICsgUEkpIC8gKDIgKiBQSSk7XG4gIGNvbnN0IHkgPSBUSUxFX1NJWkUgKiAoUEkgKyBNYXRoLmxvZyhNYXRoLnRhbihQSV80ICsgcGhpMiAqIDAuNSkpKSAvICgyICogUEkpO1xuICByZXR1cm4gW3gsIHldO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdvcmxkVG9MbmdMYXQoeHkpIHtcbiAgY29uc3QgW3gsIHldID0geHk7XG4gIGNvbnN0IGxhbWJkYTIgPSB4IC8gVElMRV9TSVpFICogKDIgKiBQSSkgLSBQSTtcbiAgY29uc3QgcGhpMiA9IDIgKiAoTWF0aC5hdGFuKE1hdGguZXhwKHkgLyBUSUxFX1NJWkUgKiAoMiAqIFBJKSAtIFBJKSkgLSBQSV80KTtcbiAgcmV0dXJuIFtsYW1iZGEyICogUkFESUFOU19UT19ERUdSRUVTLCBwaGkyICogUkFESUFOU19UT19ERUdSRUVTXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZXRlclpvb20ob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgbGF0aXR1ZGVcbiAgfSA9IG9wdGlvbnM7XG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUobGF0aXR1ZGUpKTtcbiAgY29uc3QgbGF0Q29zaW5lID0gTWF0aC5jb3MobGF0aXR1ZGUgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICByZXR1cm4gc2NhbGVUb1pvb20oRUFSVEhfQ0lSQ1VNRkVSRU5DRSAqIGxhdENvc2luZSkgLSA5O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVuaXRzUGVyTWV0ZXIobGF0aXR1ZGUpIHtcbiAgY29uc3QgbGF0Q29zaW5lID0gTWF0aC5jb3MobGF0aXR1ZGUgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICByZXR1cm4gVElMRV9TSVpFIC8gRUFSVEhfQ0lSQ1VNRkVSRU5DRSAvIGxhdENvc2luZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0YW5jZVNjYWxlcyhvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBsYXRpdHVkZSxcbiAgICBsb25naXR1ZGUsXG4gICAgaGlnaFByZWNpc2lvbiA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGxhdGl0dWRlKSAmJiBOdW1iZXIuaXNGaW5pdGUobG9uZ2l0dWRlKSk7XG4gIGNvbnN0IHdvcmxkU2l6ZSA9IFRJTEVfU0laRTtcbiAgY29uc3QgbGF0Q29zaW5lID0gTWF0aC5jb3MobGF0aXR1ZGUgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICBjb25zdCB1bml0c1BlckRlZ3JlZVggPSB3b3JsZFNpemUgLyAzNjA7XG4gIGNvbnN0IHVuaXRzUGVyRGVncmVlWSA9IHVuaXRzUGVyRGVncmVlWCAvIGxhdENvc2luZTtcbiAgY29uc3QgYWx0VW5pdHNQZXJNZXRlciA9IHdvcmxkU2l6ZSAvIEVBUlRIX0NJUkNVTUZFUkVOQ0UgLyBsYXRDb3NpbmU7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB1bml0c1Blck1ldGVyOiBbYWx0VW5pdHNQZXJNZXRlciwgYWx0VW5pdHNQZXJNZXRlciwgYWx0VW5pdHNQZXJNZXRlcl0sXG4gICAgbWV0ZXJzUGVyVW5pdDogWzEgLyBhbHRVbml0c1Blck1ldGVyLCAxIC8gYWx0VW5pdHNQZXJNZXRlciwgMSAvIGFsdFVuaXRzUGVyTWV0ZXJdLFxuICAgIHVuaXRzUGVyRGVncmVlOiBbdW5pdHNQZXJEZWdyZWVYLCB1bml0c1BlckRlZ3JlZVksIGFsdFVuaXRzUGVyTWV0ZXJdLFxuICAgIGRlZ3JlZXNQZXJVbml0OiBbMSAvIHVuaXRzUGVyRGVncmVlWCwgMSAvIHVuaXRzUGVyRGVncmVlWSwgMSAvIGFsdFVuaXRzUGVyTWV0ZXJdXG4gIH07XG4gIGlmIChoaWdoUHJlY2lzaW9uKSB7XG4gICAgY29uc3QgbGF0Q29zaW5lMiA9IERFR1JFRVNfVE9fUkFESUFOUyAqIE1hdGgudGFuKGxhdGl0dWRlICogREVHUkVFU19UT19SQURJQU5TKSAvIGxhdENvc2luZTtcbiAgICBjb25zdCB1bml0c1BlckRlZ3JlZVkyID0gdW5pdHNQZXJEZWdyZWVYICogbGF0Q29zaW5lMiAvIDI7XG4gICAgY29uc3QgYWx0VW5pdHNQZXJEZWdyZWUyID0gd29ybGRTaXplIC8gRUFSVEhfQ0lSQ1VNRkVSRU5DRSAqIGxhdENvc2luZTI7XG4gICAgY29uc3QgYWx0VW5pdHNQZXJNZXRlcjIgPSBhbHRVbml0c1BlckRlZ3JlZTIgLyB1bml0c1BlckRlZ3JlZVkgKiBhbHRVbml0c1Blck1ldGVyO1xuICAgIHJlc3VsdC51bml0c1BlckRlZ3JlZTIgPSBbMCwgdW5pdHNQZXJEZWdyZWVZMiwgYWx0VW5pdHNQZXJEZWdyZWUyXTtcbiAgICByZXN1bHQudW5pdHNQZXJNZXRlcjIgPSBbYWx0VW5pdHNQZXJNZXRlcjIsIDAsIGFsdFVuaXRzUGVyTWV0ZXIyXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFkZE1ldGVyc1RvTG5nTGF0KGxuZ0xhdFosIHh5eikge1xuICBjb25zdCBbbG9uZ2l0dWRlLCBsYXRpdHVkZSwgejBdID0gbG5nTGF0WjtcbiAgY29uc3QgW3gsIHksIHpdID0geHl6O1xuICBjb25zdCB7XG4gICAgdW5pdHNQZXJNZXRlcixcbiAgICB1bml0c1Blck1ldGVyMlxuICB9ID0gZ2V0RGlzdGFuY2VTY2FsZXMoe1xuICAgIGxvbmdpdHVkZSxcbiAgICBsYXRpdHVkZSxcbiAgICBoaWdoUHJlY2lzaW9uOiB0cnVlXG4gIH0pO1xuICBjb25zdCB3b3JsZHNwYWNlID0gbG5nTGF0VG9Xb3JsZChsbmdMYXRaKTtcbiAgd29ybGRzcGFjZVswXSArPSB4ICogKHVuaXRzUGVyTWV0ZXJbMF0gKyB1bml0c1Blck1ldGVyMlswXSAqIHkpO1xuICB3b3JsZHNwYWNlWzFdICs9IHkgKiAodW5pdHNQZXJNZXRlclsxXSArIHVuaXRzUGVyTWV0ZXIyWzFdICogeSk7XG4gIGNvbnN0IG5ld0xuZ0xhdCA9IHdvcmxkVG9MbmdMYXQod29ybGRzcGFjZSk7XG4gIGNvbnN0IG5ld1ogPSAoejAgfHwgMCkgKyAoeiB8fCAwKTtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh6MCkgfHwgTnVtYmVyLmlzRmluaXRlKHopID8gW25ld0xuZ0xhdFswXSwgbmV3TG5nTGF0WzFdLCBuZXdaXSA6IG5ld0xuZ0xhdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRWaWV3TWF0cml4KG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGhlaWdodCxcbiAgICBwaXRjaCxcbiAgICBiZWFyaW5nLFxuICAgIGFsdGl0dWRlLFxuICAgIHNjYWxlLFxuICAgIGNlbnRlclxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgdm0gPSBjcmVhdGVNYXQ0KCk7XG4gIG1hdDQudHJhbnNsYXRlKHZtLCB2bSwgWzAsIDAsIC1hbHRpdHVkZV0pO1xuICBtYXQ0LnJvdGF0ZVgodm0sIHZtLCAtcGl0Y2ggKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICBtYXQ0LnJvdGF0ZVoodm0sIHZtLCBiZWFyaW5nICogREVHUkVFU19UT19SQURJQU5TKTtcbiAgY29uc3QgcmVsYXRpdmVTY2FsZSA9IHNjYWxlIC8gaGVpZ2h0O1xuICBtYXQ0LnNjYWxlKHZtLCB2bSwgW3JlbGF0aXZlU2NhbGUsIHJlbGF0aXZlU2NhbGUsIHJlbGF0aXZlU2NhbGVdKTtcbiAgaWYgKGNlbnRlcikge1xuICAgIG1hdDQudHJhbnNsYXRlKHZtLCB2bSwgdmVjMy5uZWdhdGUoW10sIGNlbnRlcikpO1xuICB9XG4gIHJldHVybiB2bTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9qZWN0aW9uUGFyYW1ldGVycyhvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgYWx0aXR1ZGUsXG4gICAgcGl0Y2ggPSAwLFxuICAgIG9mZnNldCxcbiAgICBjZW50ZXIsXG4gICAgc2NhbGUsXG4gICAgbmVhclpNdWx0aXBsaWVyID0gMSxcbiAgICBmYXJaTXVsdGlwbGllciA9IDFcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCB7XG4gICAgZm92eSA9IGFsdGl0dWRlVG9Gb3Z5KERFRkFVTFRfQUxUSVRVREUpXG4gIH0gPSBvcHRpb25zO1xuICBpZiAoYWx0aXR1ZGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvdnkgPSBhbHRpdHVkZVRvRm92eShhbHRpdHVkZSk7XG4gIH1cbiAgY29uc3QgZm92UmFkaWFucyA9IGZvdnkgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHBpdGNoUmFkaWFucyA9IHBpdGNoICogREVHUkVFU19UT19SQURJQU5TO1xuICBjb25zdCBmb2NhbERpc3RhbmNlID0gZm92eVRvQWx0aXR1ZGUoZm92eSk7XG4gIGxldCBjYW1lcmFUb1NlYUxldmVsRGlzdGFuY2UgPSBmb2NhbERpc3RhbmNlO1xuICBpZiAoY2VudGVyKSB7XG4gICAgY2FtZXJhVG9TZWFMZXZlbERpc3RhbmNlICs9IGNlbnRlclsyXSAqIHNjYWxlIC8gTWF0aC5jb3MocGl0Y2hSYWRpYW5zKSAvIGhlaWdodDtcbiAgfVxuICBjb25zdCBmb3ZBYm92ZUNlbnRlciA9IGZvdlJhZGlhbnMgKiAoMC41ICsgKG9mZnNldCA/IG9mZnNldFsxXSA6IDApIC8gaGVpZ2h0KTtcbiAgY29uc3QgdG9wSGFsZlN1cmZhY2VEaXN0YW5jZSA9IE1hdGguc2luKGZvdkFib3ZlQ2VudGVyKSAqIGNhbWVyYVRvU2VhTGV2ZWxEaXN0YW5jZSAvIE1hdGguc2luKGNsYW1wKE1hdGguUEkgLyAyIC0gcGl0Y2hSYWRpYW5zIC0gZm92QWJvdmVDZW50ZXIsIDAuMDEsIE1hdGguUEkgLSAwLjAxKSk7XG4gIGNvbnN0IGZ1cnRoZXN0RGlzdGFuY2UgPSBNYXRoLnNpbihwaXRjaFJhZGlhbnMpICogdG9wSGFsZlN1cmZhY2VEaXN0YW5jZSArIGNhbWVyYVRvU2VhTGV2ZWxEaXN0YW5jZTtcbiAgY29uc3QgaG9yaXpvbkRpc3RhbmNlID0gY2FtZXJhVG9TZWFMZXZlbERpc3RhbmNlICogMTA7XG4gIGNvbnN0IGZhclogPSBNYXRoLm1pbihmdXJ0aGVzdERpc3RhbmNlICogZmFyWk11bHRpcGxpZXIsIGhvcml6b25EaXN0YW5jZSk7XG4gIHJldHVybiB7XG4gICAgZm92OiBmb3ZSYWRpYW5zLFxuICAgIGFzcGVjdDogd2lkdGggLyBoZWlnaHQsXG4gICAgZm9jYWxEaXN0YW5jZSxcbiAgICBuZWFyOiBuZWFyWk11bHRpcGxpZXIsXG4gICAgZmFyOiBmYXJaXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvamVjdGlvbk1hdHJpeChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBmb3YsXG4gICAgYXNwZWN0LFxuICAgIG5lYXIsXG4gICAgZmFyXG4gIH0gPSBnZXRQcm9qZWN0aW9uUGFyYW1ldGVycyhvcHRpb25zKTtcbiAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IG1hdDQucGVyc3BlY3RpdmUoW10sIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIpO1xuICByZXR1cm4gcHJvamVjdGlvbk1hdHJpeDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhbHRpdHVkZVRvRm92eShhbHRpdHVkZSkge1xuICByZXR1cm4gMiAqIE1hdGguYXRhbigwLjUgLyBhbHRpdHVkZSkgKiBSQURJQU5TX1RPX0RFR1JFRVM7XG59XG5leHBvcnQgZnVuY3Rpb24gZm92eVRvQWx0aXR1ZGUoZm92eSkge1xuICByZXR1cm4gMC41IC8gTWF0aC50YW4oMC41ICogZm92eSAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG59XG5leHBvcnQgZnVuY3Rpb24gd29ybGRUb1BpeGVscyh4eXosIHBpeGVsUHJvamVjdGlvbk1hdHJpeCkge1xuICBjb25zdCBbeCwgeSwgeiA9IDBdID0geHl6O1xuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHgpICYmIE51bWJlci5pc0Zpbml0ZSh5KSAmJiBOdW1iZXIuaXNGaW5pdGUoeikpO1xuICByZXR1cm4gdHJhbnNmb3JtVmVjdG9yKHBpeGVsUHJvamVjdGlvbk1hdHJpeCwgW3gsIHksIHosIDFdKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwaXhlbHNUb1dvcmxkKHh5eiwgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXgpIHtcbiAgbGV0IHRhcmdldFogPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gIGNvbnN0IFt4LCB5LCB6XSA9IHh5ejtcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh4KSAmJiBOdW1iZXIuaXNGaW5pdGUoeSksICdpbnZhbGlkIHBpeGVsIGNvb3JkaW5hdGUnKTtcbiAgaWYgKE51bWJlci5pc0Zpbml0ZSh6KSkge1xuICAgIGNvbnN0IGNvb3JkID0gdHJhbnNmb3JtVmVjdG9yKHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgeSwgeiwgMV0pO1xuICAgIHJldHVybiBjb29yZDtcbiAgfVxuICBjb25zdCBjb29yZDAgPSB0cmFuc2Zvcm1WZWN0b3IocGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIFt4LCB5LCAwLCAxXSk7XG4gIGNvbnN0IGNvb3JkMSA9IHRyYW5zZm9ybVZlY3RvcihwaXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIHksIDEsIDFdKTtcbiAgY29uc3QgejAgPSBjb29yZDBbMl07XG4gIGNvbnN0IHoxID0gY29vcmQxWzJdO1xuICBjb25zdCB0ID0gejAgPT09IHoxID8gMCA6ICgodGFyZ2V0WiB8fCAwKSAtIHowKSAvICh6MSAtIHowKTtcbiAgcmV0dXJuIHZlYzIubGVycChbXSwgY29vcmQwLCBjb29yZDEsIHQpO1xufSIsImltcG9ydCBhc3NlcnQgZnJvbSAnLi9hc3NlcnQnO1xuaW1wb3J0IHsgbG9nMiwgY2xhbXAgfSBmcm9tICcuL21hdGgtdXRpbHMnO1xuaW1wb3J0IHsgTUFYX0xBVElUVURFLCBsbmdMYXRUb1dvcmxkLCB3b3JsZFRvTG5nTGF0IH0gZnJvbSAnLi93ZWItbWVyY2F0b3ItdXRpbHMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZml0Qm91bmRzKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBib3VuZHMsXG4gICAgbWluRXh0ZW50ID0gMCxcbiAgICBtYXhab29tID0gMjQsXG4gICAgb2Zmc2V0ID0gWzAsIDBdXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBbW3dlc3QsIHNvdXRoXSwgW2Vhc3QsIG5vcnRoXV0gPSBib3VuZHM7XG4gIGNvbnN0IHBhZGRpbmcgPSBnZXRQYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZyk7XG4gIGNvbnN0IG53ID0gbG5nTGF0VG9Xb3JsZChbd2VzdCwgY2xhbXAobm9ydGgsIC1NQVhfTEFUSVRVREUsIE1BWF9MQVRJVFVERSldKTtcbiAgY29uc3Qgc2UgPSBsbmdMYXRUb1dvcmxkKFtlYXN0LCBjbGFtcChzb3V0aCwgLU1BWF9MQVRJVFVERSwgTUFYX0xBVElUVURFKV0pO1xuICBjb25zdCBzaXplID0gW01hdGgubWF4KE1hdGguYWJzKHNlWzBdIC0gbndbMF0pLCBtaW5FeHRlbnQpLCBNYXRoLm1heChNYXRoLmFicyhzZVsxXSAtIG53WzFdKSwgbWluRXh0ZW50KV07XG4gIGNvbnN0IHRhcmdldFNpemUgPSBbd2lkdGggLSBwYWRkaW5nLmxlZnQgLSBwYWRkaW5nLnJpZ2h0IC0gTWF0aC5hYnMob2Zmc2V0WzBdKSAqIDIsIGhlaWdodCAtIHBhZGRpbmcudG9wIC0gcGFkZGluZy5ib3R0b20gLSBNYXRoLmFicyhvZmZzZXRbMV0pICogMl07XG4gIGFzc2VydCh0YXJnZXRTaXplWzBdID4gMCAmJiB0YXJnZXRTaXplWzFdID4gMCk7XG4gIGNvbnN0IHNjYWxlWCA9IHRhcmdldFNpemVbMF0gLyBzaXplWzBdO1xuICBjb25zdCBzY2FsZVkgPSB0YXJnZXRTaXplWzFdIC8gc2l6ZVsxXTtcbiAgY29uc3Qgb2Zmc2V0WCA9IChwYWRkaW5nLnJpZ2h0IC0gcGFkZGluZy5sZWZ0KSAvIDIgLyBzY2FsZVg7XG4gIGNvbnN0IG9mZnNldFkgPSAocGFkZGluZy50b3AgLSBwYWRkaW5nLmJvdHRvbSkgLyAyIC8gc2NhbGVZO1xuICBjb25zdCBjZW50ZXIgPSBbKHNlWzBdICsgbndbMF0pIC8gMiArIG9mZnNldFgsIChzZVsxXSArIG53WzFdKSAvIDIgKyBvZmZzZXRZXTtcbiAgY29uc3QgY2VudGVyTG5nTGF0ID0gd29ybGRUb0xuZ0xhdChjZW50ZXIpO1xuICBjb25zdCB6b29tID0gTWF0aC5taW4obWF4Wm9vbSwgbG9nMihNYXRoLmFicyhNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSkpKSk7XG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoem9vbSkpO1xuICByZXR1cm4ge1xuICAgIGxvbmdpdHVkZTogY2VudGVyTG5nTGF0WzBdLFxuICAgIGxhdGl0dWRlOiBjZW50ZXJMbmdMYXRbMV0sXG4gICAgem9vbVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UGFkZGluZ09iamVjdCgpIHtcbiAgbGV0IHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gIGlmICh0eXBlb2YgcGFkZGluZyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBwYWRkaW5nLFxuICAgICAgYm90dG9tOiBwYWRkaW5nLFxuICAgICAgbGVmdDogcGFkZGluZyxcbiAgICAgIHJpZ2h0OiBwYWRkaW5nXG4gICAgfTtcbiAgfVxuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHBhZGRpbmcudG9wKSAmJiBOdW1iZXIuaXNGaW5pdGUocGFkZGluZy5ib3R0b20pICYmIE51bWJlci5pc0Zpbml0ZShwYWRkaW5nLmxlZnQpICYmIE51bWJlci5pc0Zpbml0ZShwYWRkaW5nLnJpZ2h0KSk7XG4gIHJldHVybiBwYWRkaW5nO1xufSIsImltcG9ydCB7IHdvcmxkVG9MbmdMYXQgfSBmcm9tICcuL3dlYi1tZXJjYXRvci11dGlscyc7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJ2dsLW1hdHJpeC92ZWMyJztcbmltcG9ydCB7IHRyYW5zZm9ybVZlY3RvciB9IGZyb20gJy4vbWF0aC11dGlscyc7XG5jb25zdCBERUdSRUVTX1RPX1JBRElBTlMgPSBNYXRoLlBJIC8gMTgwO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Qm91bmRzKHZpZXdwb3J0KSB7XG4gIGxldCB6ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHVucHJvamVjdFxuICB9ID0gdmlld3BvcnQ7XG4gIGNvbnN0IHVucHJvamVjdE9wcyA9IHtcbiAgICB0YXJnZXRaOiB6XG4gIH07XG4gIGNvbnN0IGJvdHRvbUxlZnQgPSB1bnByb2plY3QoWzAsIGhlaWdodF0sIHVucHJvamVjdE9wcyk7XG4gIGNvbnN0IGJvdHRvbVJpZ2h0ID0gdW5wcm9qZWN0KFt3aWR0aCwgaGVpZ2h0XSwgdW5wcm9qZWN0T3BzKTtcbiAgbGV0IHRvcExlZnQ7XG4gIGxldCB0b3BSaWdodDtcbiAgY29uc3QgaGFsZkZvdiA9IHZpZXdwb3J0LmZvdnkgPyAwLjUgKiB2aWV3cG9ydC5mb3Z5ICogREVHUkVFU19UT19SQURJQU5TIDogTWF0aC5hdGFuKDAuNSAvIHZpZXdwb3J0LmFsdGl0dWRlKTtcbiAgY29uc3QgYW5nbGVUb0dyb3VuZCA9ICg5MCAtIHZpZXdwb3J0LnBpdGNoKSAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgaWYgKGhhbGZGb3YgPiBhbmdsZVRvR3JvdW5kIC0gMC4wMSkge1xuICAgIHRvcExlZnQgPSB1bnByb2plY3RPbkZhclBsYW5lKHZpZXdwb3J0LCAwLCB6KTtcbiAgICB0b3BSaWdodCA9IHVucHJvamVjdE9uRmFyUGxhbmUodmlld3BvcnQsIHdpZHRoLCB6KTtcbiAgfSBlbHNlIHtcbiAgICB0b3BMZWZ0ID0gdW5wcm9qZWN0KFswLCAwXSwgdW5wcm9qZWN0T3BzKTtcbiAgICB0b3BSaWdodCA9IHVucHJvamVjdChbd2lkdGgsIDBdLCB1bnByb2plY3RPcHMpO1xuICB9XG4gIHJldHVybiBbYm90dG9tTGVmdCwgYm90dG9tUmlnaHQsIHRvcFJpZ2h0LCB0b3BMZWZ0XTtcbn1cbmZ1bmN0aW9uIHVucHJvamVjdE9uRmFyUGxhbmUodmlld3BvcnQsIHgsIHRhcmdldFopIHtcbiAgY29uc3Qge1xuICAgIHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4XG4gIH0gPSB2aWV3cG9ydDtcbiAgY29uc3QgY29vcmQwID0gdHJhbnNmb3JtVmVjdG9yKHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgMCwgMSwgMV0pO1xuICBjb25zdCBjb29yZDEgPSB0cmFuc2Zvcm1WZWN0b3IocGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIFt4LCB2aWV3cG9ydC5oZWlnaHQsIDEsIDFdKTtcbiAgY29uc3QgeiA9IHRhcmdldFogKiB2aWV3cG9ydC5kaXN0YW5jZVNjYWxlcy51bml0c1Blck1ldGVyWzJdO1xuICBjb25zdCB0ID0gKHogLSBjb29yZDBbMl0pIC8gKGNvb3JkMVsyXSAtIGNvb3JkMFsyXSk7XG4gIGNvbnN0IGNvb3JkID0gdmVjMi5sZXJwKFtdLCBjb29yZDAsIGNvb3JkMSwgdCk7XG4gIGNvbnN0IHJlc3VsdCA9IHdvcmxkVG9MbmdMYXQoY29vcmQpO1xuICByZXN1bHQucHVzaCh0YXJnZXRaKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0iLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgY3JlYXRlTWF0NCB9IGZyb20gJy4vbWF0aC11dGlscyc7XG5pbXBvcnQgeyB6b29tVG9TY2FsZSwgcGl4ZWxzVG9Xb3JsZCwgbG5nTGF0VG9Xb3JsZCwgd29ybGRUb0xuZ0xhdCwgd29ybGRUb1BpeGVscywgYWx0aXR1ZGVUb0ZvdnksIGZvdnlUb0FsdGl0dWRlLCBERUZBVUxUX0FMVElUVURFLCBnZXRQcm9qZWN0aW9uTWF0cml4LCBnZXREaXN0YW5jZVNjYWxlcywgZ2V0Vmlld01hdHJpeCB9IGZyb20gJy4vd2ViLW1lcmNhdG9yLXV0aWxzJztcbmltcG9ydCBmaXRCb3VuZHMgZnJvbSAnLi9maXQtYm91bmRzJztcbmltcG9ydCBnZXRCb3VuZHMgZnJvbSAnLi9nZXQtYm91bmRzJztcbmltcG9ydCAqIGFzIG1hdDQgZnJvbSAnZ2wtbWF0cml4L21hdDQnO1xuaW1wb3J0ICogYXMgdmVjMiBmcm9tICdnbC1tYXRyaXgvdmVjMic7XG5pbXBvcnQgKiBhcyB2ZWMzIGZyb20gJ2dsLW1hdHJpeC92ZWMzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYk1lcmNhdG9yVmlld3BvcnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGxldCBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge1xuICAgICAgd2lkdGg6IDEsXG4gICAgICBoZWlnaHQ6IDFcbiAgICB9O1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhdGl0dWRlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibG9uZ2l0dWRlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiem9vbVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBpdGNoXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYmVhcmluZ1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFsdGl0dWRlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZm92eVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGVyT2Zmc2V0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2VudGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2lkdGhcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoZWlnaHRcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzY2FsZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRpc3RhbmNlU2NhbGVzXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidmlld01hdHJpeFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb2plY3Rpb25NYXRyaXhcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2aWV3UHJvamVjdGlvbk1hdHJpeFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBpeGVsUHJvamVjdGlvbk1hdHJpeFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBpeGVsVW5wcm9qZWN0aW9uTWF0cml4XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXF1YWxzXCIsIHZpZXdwb3J0ID0+IHtcbiAgICAgIGlmICghKHZpZXdwb3J0IGluc3RhbmNlb2YgV2ViTWVyY2F0b3JWaWV3cG9ydCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZpZXdwb3J0LndpZHRoID09PSB0aGlzLndpZHRoICYmIHZpZXdwb3J0LmhlaWdodCA9PT0gdGhpcy5oZWlnaHQgJiYgbWF0NC5lcXVhbHModmlld3BvcnQucHJvamVjdGlvbk1hdHJpeCwgdGhpcy5wcm9qZWN0aW9uTWF0cml4KSAmJiBtYXQ0LmVxdWFscyh2aWV3cG9ydC52aWV3TWF0cml4LCB0aGlzLnZpZXdNYXRyaXgpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb2plY3RcIiwgZnVuY3Rpb24gKGxuZ0xhdFopIHtcbiAgICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdG9wTGVmdCA9IHRydWVcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3Qgd29ybGRQb3NpdGlvbiA9IF90aGlzLnByb2plY3RQb3NpdGlvbihsbmdMYXRaKTtcbiAgICAgIGNvbnN0IGNvb3JkID0gd29ybGRUb1BpeGVscyh3b3JsZFBvc2l0aW9uLCBfdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXgpO1xuICAgICAgY29uc3QgW3gsIHldID0gY29vcmQ7XG4gICAgICBjb25zdCB5MiA9IHRvcExlZnQgPyB5IDogX3RoaXMuaGVpZ2h0IC0geTtcbiAgICAgIHJldHVybiBsbmdMYXRaLmxlbmd0aCA9PT0gMiA/IFt4LCB5Ml0gOiBbeCwgeTIsIGNvb3JkWzJdXTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1bnByb2plY3RcIiwgZnVuY3Rpb24gKHh5eikge1xuICAgICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgY29uc3Qge1xuICAgICAgICB0b3BMZWZ0ID0gdHJ1ZSxcbiAgICAgICAgdGFyZ2V0WiA9IHVuZGVmaW5lZFxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBbeCwgeSwgel0gPSB4eXo7XG4gICAgICBjb25zdCB5MiA9IHRvcExlZnQgPyB5IDogX3RoaXMuaGVpZ2h0IC0geTtcbiAgICAgIGNvbnN0IHRhcmdldFpXb3JsZCA9IHRhcmdldFogJiYgdGFyZ2V0WiAqIF90aGlzLmRpc3RhbmNlU2NhbGVzLnVuaXRzUGVyTWV0ZXJbMl07XG4gICAgICBjb25zdCBjb29yZCA9IHBpeGVsc1RvV29ybGQoW3gsIHkyLCB6XSwgX3RoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIHRhcmdldFpXb3JsZCk7XG4gICAgICBjb25zdCBbWCwgWSwgWl0gPSBfdGhpcy51bnByb2plY3RQb3NpdGlvbihjb29yZCk7XG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHopKSB7XG4gICAgICAgIHJldHVybiBbWCwgWSwgWl07XG4gICAgICB9XG4gICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHRhcmdldFopID8gW1gsIFksIHRhcmdldFpdIDogW1gsIFldO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb2plY3RQb3NpdGlvblwiLCB4eXogPT4ge1xuICAgICAgY29uc3QgW1gsIFldID0gbG5nTGF0VG9Xb3JsZCh4eXopO1xuICAgICAgY29uc3QgWiA9ICh4eXpbMl0gfHwgMCkgKiB0aGlzLmRpc3RhbmNlU2NhbGVzLnVuaXRzUGVyTWV0ZXJbMl07XG4gICAgICByZXR1cm4gW1gsIFksIFpdO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVucHJvamVjdFBvc2l0aW9uXCIsIHh5eiA9PiB7XG4gICAgICBjb25zdCBbWCwgWV0gPSB3b3JsZFRvTG5nTGF0KHh5eik7XG4gICAgICBjb25zdCBaID0gKHh5elsyXSB8fCAwKSAqIHRoaXMuZGlzdGFuY2VTY2FsZXMubWV0ZXJzUGVyVW5pdFsyXTtcbiAgICAgIHJldHVybiBbWCwgWSwgWl07XG4gICAgfSk7XG4gICAgbGV0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgYWx0aXR1ZGUgPSBudWxsLFxuICAgICAgZm92eSA9IG51bGxcbiAgICB9ID0gcHJvcHM7XG4gICAgY29uc3Qge1xuICAgICAgbGF0aXR1ZGUgPSAwLFxuICAgICAgbG9uZ2l0dWRlID0gMCxcbiAgICAgIHpvb20gPSAwLFxuICAgICAgcGl0Y2ggPSAwLFxuICAgICAgYmVhcmluZyA9IDAsXG4gICAgICBwb3NpdGlvbiA9IG51bGwsXG4gICAgICBuZWFyWk11bHRpcGxpZXIgPSAwLjAyLFxuICAgICAgZmFyWk11bHRpcGxpZXIgPSAxLjAxXG4gICAgfSA9IHByb3BzO1xuICAgIHdpZHRoID0gd2lkdGggfHwgMTtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgMTtcbiAgICBpZiAoZm92eSA9PT0gbnVsbCAmJiBhbHRpdHVkZSA9PT0gbnVsbCkge1xuICAgICAgYWx0aXR1ZGUgPSBERUZBVUxUX0FMVElUVURFO1xuICAgICAgZm92eSA9IGFsdGl0dWRlVG9Gb3Z5KGFsdGl0dWRlKTtcbiAgICB9IGVsc2UgaWYgKGZvdnkgPT09IG51bGwpIHtcbiAgICAgIGZvdnkgPSBhbHRpdHVkZVRvRm92eShhbHRpdHVkZSk7XG4gICAgfSBlbHNlIGlmIChhbHRpdHVkZSA9PT0gbnVsbCkge1xuICAgICAgYWx0aXR1ZGUgPSBmb3Z5VG9BbHRpdHVkZShmb3Z5KTtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGUgPSB6b29tVG9TY2FsZSh6b29tKTtcbiAgICBhbHRpdHVkZSA9IE1hdGgubWF4KDAuNzUsIGFsdGl0dWRlKTtcbiAgICBjb25zdCBkaXN0YW5jZVNjYWxlcyA9IGdldERpc3RhbmNlU2NhbGVzKHtcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlXG4gICAgfSk7XG4gICAgY29uc3QgY2VudGVyID0gbG5nTGF0VG9Xb3JsZChbbG9uZ2l0dWRlLCBsYXRpdHVkZV0pO1xuICAgIGNlbnRlci5wdXNoKDApO1xuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgdmVjMy5hZGQoY2VudGVyLCBjZW50ZXIsIHZlYzMubXVsKFtdLCBwb3NpdGlvbiwgZGlzdGFuY2VTY2FsZXMudW5pdHNQZXJNZXRlcikpO1xuICAgIH1cbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBnZXRQcm9qZWN0aW9uTWF0cml4KHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgc2NhbGUsXG4gICAgICBjZW50ZXIsXG4gICAgICBwaXRjaCxcbiAgICAgIGZvdnksXG4gICAgICBuZWFyWk11bHRpcGxpZXIsXG4gICAgICBmYXJaTXVsdGlwbGllclxuICAgIH0pO1xuICAgIHRoaXMudmlld01hdHJpeCA9IGdldFZpZXdNYXRyaXgoe1xuICAgICAgaGVpZ2h0LFxuICAgICAgc2NhbGUsXG4gICAgICBjZW50ZXIsXG4gICAgICBwaXRjaCxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBhbHRpdHVkZVxuICAgIH0pO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5sYXRpdHVkZSA9IGxhdGl0dWRlO1xuICAgIHRoaXMubG9uZ2l0dWRlID0gbG9uZ2l0dWRlO1xuICAgIHRoaXMuem9vbSA9IHpvb207XG4gICAgdGhpcy5waXRjaCA9IHBpdGNoO1xuICAgIHRoaXMuYmVhcmluZyA9IGJlYXJpbmc7XG4gICAgdGhpcy5hbHRpdHVkZSA9IGFsdGl0dWRlO1xuICAgIHRoaXMuZm92eSA9IGZvdnk7XG4gICAgdGhpcy5jZW50ZXIgPSBjZW50ZXI7XG4gICAgdGhpcy5tZXRlck9mZnNldCA9IHBvc2l0aW9uIHx8IFswLCAwLCAwXTtcbiAgICB0aGlzLmRpc3RhbmNlU2NhbGVzID0gZGlzdGFuY2VTY2FsZXM7XG4gICAgdGhpcy5faW5pdE1hdHJpY2VzKCk7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuICBfaW5pdE1hdHJpY2VzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIHZpZXdNYXRyaXhcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB2cG0gPSBjcmVhdGVNYXQ0KCk7XG4gICAgbWF0NC5tdWx0aXBseSh2cG0sIHZwbSwgcHJvamVjdGlvbk1hdHJpeCk7XG4gICAgbWF0NC5tdWx0aXBseSh2cG0sIHZwbSwgdmlld01hdHJpeCk7XG4gICAgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCA9IHZwbTtcbiAgICBjb25zdCBtID0gY3JlYXRlTWF0NCgpO1xuICAgIG1hdDQuc2NhbGUobSwgbSwgW3dpZHRoIC8gMiwgLWhlaWdodCAvIDIsIDFdKTtcbiAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbMSwgLTEsIDBdKTtcbiAgICBtYXQ0Lm11bHRpcGx5KG0sIG0sIHZwbSk7XG4gICAgY29uc3QgbUludmVyc2UgPSBtYXQ0LmludmVydChjcmVhdGVNYXQ0KCksIG0pO1xuICAgIGlmICghbUludmVyc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGl4ZWwgcHJvamVjdCBtYXRyaXggbm90IGludmVydGlibGUnKTtcbiAgICB9XG4gICAgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXggPSBtO1xuICAgIHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXggPSBtSW52ZXJzZTtcbiAgfVxuICBwcm9qZWN0RmxhdChsbmdMYXQpIHtcbiAgICByZXR1cm4gbG5nTGF0VG9Xb3JsZChsbmdMYXQpO1xuICB9XG4gIHVucHJvamVjdEZsYXQoeHkpIHtcbiAgICByZXR1cm4gd29ybGRUb0xuZ0xhdCh4eSk7XG4gIH1cbiAgZ2V0TWFwQ2VudGVyQnlMbmdMYXRQb3NpdGlvbihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIGxuZ0xhdCxcbiAgICAgIHBvc1xuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IGZyb21Mb2NhdGlvbiA9IHBpeGVsc1RvV29ybGQocG9zLCB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICBjb25zdCB0b0xvY2F0aW9uID0gbG5nTGF0VG9Xb3JsZChsbmdMYXQpO1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHZlYzIuYWRkKFtdLCB0b0xvY2F0aW9uLCB2ZWMyLm5lZ2F0ZShbXSwgZnJvbUxvY2F0aW9uKSk7XG4gICAgY29uc3QgbmV3Q2VudGVyID0gdmVjMi5hZGQoW10sIHRoaXMuY2VudGVyLCB0cmFuc2xhdGUpO1xuICAgIHJldHVybiB3b3JsZFRvTG5nTGF0KG5ld0NlbnRlcik7XG4gIH1cbiAgZml0Qm91bmRzKGJvdW5kcykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgem9vbVxuICAgIH0gPSBmaXRCb3VuZHMoT2JqZWN0LmFzc2lnbih7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGJvdW5kc1xuICAgIH0sIG9wdGlvbnMpKTtcbiAgICByZXR1cm4gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZSxcbiAgICAgIHpvb21cbiAgICB9KTtcbiAgfVxuICBnZXRCb3VuZHMob3B0aW9ucykge1xuICAgIGNvbnN0IGNvcm5lcnMgPSB0aGlzLmdldEJvdW5kaW5nUmVnaW9uKG9wdGlvbnMpO1xuICAgIGNvbnN0IHdlc3QgPSBNYXRoLm1pbiguLi5jb3JuZXJzLm1hcChwID0+IHBbMF0pKTtcbiAgICBjb25zdCBlYXN0ID0gTWF0aC5tYXgoLi4uY29ybmVycy5tYXAocCA9PiBwWzBdKSk7XG4gICAgY29uc3Qgc291dGggPSBNYXRoLm1pbiguLi5jb3JuZXJzLm1hcChwID0+IHBbMV0pKTtcbiAgICBjb25zdCBub3J0aCA9IE1hdGgubWF4KC4uLmNvcm5lcnMubWFwKHAgPT4gcFsxXSkpO1xuICAgIHJldHVybiBbW3dlc3QsIHNvdXRoXSwgW2Vhc3QsIG5vcnRoXV07XG4gIH1cbiAgZ2V0Qm91bmRpbmdSZWdpb24oKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHJldHVybiBnZXRCb3VuZHModGhpcywgb3B0aW9ucy56IHx8IDApO1xuICB9XG4gIGdldExvY2F0aW9uQXRQb2ludChfcmVmMikge1xuICAgIGxldCB7XG4gICAgICBsbmdMYXQsXG4gICAgICBwb3NcbiAgICB9ID0gX3JlZjI7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWFwQ2VudGVyQnlMbmdMYXRQb3NpdGlvbih7XG4gICAgICBsbmdMYXQsXG4gICAgICBwb3NcbiAgICB9KTtcbiAgfVxufSIsImltcG9ydCB7IHdvcmxkVG9MbmdMYXQgfSBmcm9tICcuL3dlYi1tZXJjYXRvci11dGlscyc7XG5pbXBvcnQgeyBtb2QsIGxvZzIgfSBmcm9tICcuL21hdGgtdXRpbHMnO1xuY29uc3QgVElMRV9TSVpFID0gNTEyO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplVmlld3BvcnRQcm9wcyhwcm9wcykge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHBpdGNoID0gMFxuICB9ID0gcHJvcHM7XG4gIGxldCB7XG4gICAgbG9uZ2l0dWRlLFxuICAgIGxhdGl0dWRlLFxuICAgIHpvb20sXG4gICAgYmVhcmluZyA9IDBcbiAgfSA9IHByb3BzO1xuICBpZiAobG9uZ2l0dWRlIDwgLTE4MCB8fCBsb25naXR1ZGUgPiAxODApIHtcbiAgICBsb25naXR1ZGUgPSBtb2QobG9uZ2l0dWRlICsgMTgwLCAzNjApIC0gMTgwO1xuICB9XG4gIGlmIChiZWFyaW5nIDwgLTE4MCB8fCBiZWFyaW5nID4gMTgwKSB7XG4gICAgYmVhcmluZyA9IG1vZChiZWFyaW5nICsgMTgwLCAzNjApIC0gMTgwO1xuICB9XG4gIGNvbnN0IG1pblpvb20gPSBsb2cyKGhlaWdodCAvIFRJTEVfU0laRSk7XG4gIGlmICh6b29tIDw9IG1pblpvb20pIHtcbiAgICB6b29tID0gbWluWm9vbTtcbiAgICBsYXRpdHVkZSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaGFsZkhlaWdodFBpeGVscyA9IGhlaWdodCAvIDIgLyBNYXRoLnBvdygyLCB6b29tKTtcbiAgICBjb25zdCBtaW5MYXRpdHVkZSA9IHdvcmxkVG9MbmdMYXQoWzAsIGhhbGZIZWlnaHRQaXhlbHNdKVsxXTtcbiAgICBpZiAobGF0aXR1ZGUgPCBtaW5MYXRpdHVkZSkge1xuICAgICAgbGF0aXR1ZGUgPSBtaW5MYXRpdHVkZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWF4TGF0aXR1ZGUgPSB3b3JsZFRvTG5nTGF0KFswLCBUSUxFX1NJWkUgLSBoYWxmSGVpZ2h0UGl4ZWxzXSlbMV07XG4gICAgICBpZiAobGF0aXR1ZGUgPiBtYXhMYXRpdHVkZSkge1xuICAgICAgICBsYXRpdHVkZSA9IG1heExhdGl0dWRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBsb25naXR1ZGUsXG4gICAgbGF0aXR1ZGUsXG4gICAgem9vbSxcbiAgICBwaXRjaCxcbiAgICBiZWFyaW5nXG4gIH07XG59IiwiaW1wb3J0IHsgbGVycCB9IGZyb20gJy4vbWF0aC11dGlscyc7XG5pbXBvcnQgeyBzY2FsZVRvWm9vbSwgem9vbVRvU2NhbGUsIGxuZ0xhdFRvV29ybGQsIHdvcmxkVG9MbmdMYXQgfSBmcm9tICcuL3dlYi1tZXJjYXRvci11dGlscyc7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJ2dsLW1hdHJpeC92ZWMyJztcbmNvbnN0IEVQU0lMT04gPSAwLjAxO1xuY29uc3QgVklFV1BPUlRfVFJBTlNJVElPTl9QUk9QUyA9IFsnbG9uZ2l0dWRlJywgJ2xhdGl0dWRlJywgJ3pvb20nXTtcbmNvbnN0IERFRkFVTFRfT1BUUyA9IHtcbiAgY3VydmU6IDEuNDE0LFxuICBzcGVlZDogMS4yXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmx5VG9WaWV3cG9ydChzdGFydFByb3BzLCBlbmRQcm9wcywgdCwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgc3RhcnRab29tLFxuICAgIHN0YXJ0Q2VudGVyWFksXG4gICAgdURlbHRhLFxuICAgIHcwLFxuICAgIHUxLFxuICAgIFMsXG4gICAgcmhvLFxuICAgIHJobzIsXG4gICAgcjBcbiAgfSA9IGdldEZseVRvVHJhbnNpdGlvblBhcmFtcyhzdGFydFByb3BzLCBlbmRQcm9wcywgb3B0aW9ucyk7XG4gIGlmICh1MSA8IEVQU0lMT04pIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFZJRVdQT1JUX1RSQU5TSVRJT05fUFJPUFMpIHtcbiAgICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSBzdGFydFByb3BzW2tleV07XG4gICAgICBjb25zdCBlbmRWYWx1ZSA9IGVuZFByb3BzW2tleV07XG4gICAgICB2aWV3cG9ydFtrZXldID0gbGVycChzdGFydFZhbHVlLCBlbmRWYWx1ZSwgdCk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3cG9ydDtcbiAgfVxuICBjb25zdCBzID0gdCAqIFM7XG4gIGNvbnN0IHcgPSBNYXRoLmNvc2gocjApIC8gTWF0aC5jb3NoKHIwICsgcmhvICogcyk7XG4gIGNvbnN0IHUgPSB3MCAqICgoTWF0aC5jb3NoKHIwKSAqIE1hdGgudGFuaChyMCArIHJobyAqIHMpIC0gTWF0aC5zaW5oKHIwKSkgLyByaG8yKSAvIHUxO1xuICBjb25zdCBzY2FsZUluY3JlbWVudCA9IDEgLyB3O1xuICBjb25zdCBuZXdab29tID0gc3RhcnRab29tICsgc2NhbGVUb1pvb20oc2NhbGVJbmNyZW1lbnQpO1xuICBjb25zdCBuZXdDZW50ZXJXb3JsZCA9IHZlYzIuc2NhbGUoW10sIHVEZWx0YSwgdSk7XG4gIHZlYzIuYWRkKG5ld0NlbnRlcldvcmxkLCBuZXdDZW50ZXJXb3JsZCwgc3RhcnRDZW50ZXJYWSk7XG4gIGNvbnN0IG5ld0NlbnRlciA9IHdvcmxkVG9MbmdMYXQobmV3Q2VudGVyV29ybGQpO1xuICByZXR1cm4ge1xuICAgIGxvbmdpdHVkZTogbmV3Q2VudGVyWzBdLFxuICAgIGxhdGl0dWRlOiBuZXdDZW50ZXJbMV0sXG4gICAgem9vbTogbmV3Wm9vbVxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEZseVRvRHVyYXRpb24oc3RhcnRQcm9wcywgZW5kUHJvcHMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICAuLi5ERUZBVUxUX09QVFMsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCB7XG4gICAgc2NyZWVuU3BlZWQsXG4gICAgc3BlZWQsXG4gICAgbWF4RHVyYXRpb25cbiAgfSA9IG9wdHM7XG4gIGNvbnN0IHtcbiAgICBTLFxuICAgIHJob1xuICB9ID0gZ2V0Rmx5VG9UcmFuc2l0aW9uUGFyYW1zKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCBvcHRzKTtcbiAgY29uc3QgbGVuZ3RoID0gMTAwMCAqIFM7XG4gIGxldCBkdXJhdGlvbjtcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShzY3JlZW5TcGVlZCkpIHtcbiAgICBkdXJhdGlvbiA9IGxlbmd0aCAvIChzY3JlZW5TcGVlZCAvIHJobyk7XG4gIH0gZWxzZSB7XG4gICAgZHVyYXRpb24gPSBsZW5ndGggLyBzcGVlZDtcbiAgfVxuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG1heER1cmF0aW9uKSAmJiBkdXJhdGlvbiA+IG1heER1cmF0aW9uID8gMCA6IGR1cmF0aW9uO1xufVxuZnVuY3Rpb24gZ2V0Rmx5VG9UcmFuc2l0aW9uUGFyYW1zKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCBvcHRzKSB7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVFMsIG9wdHMpO1xuICBjb25zdCByaG8gPSBvcHRzLmN1cnZlO1xuICBjb25zdCBzdGFydFpvb20gPSBzdGFydFByb3BzLnpvb207XG4gIGNvbnN0IHN0YXJ0Q2VudGVyID0gW3N0YXJ0UHJvcHMubG9uZ2l0dWRlLCBzdGFydFByb3BzLmxhdGl0dWRlXTtcbiAgY29uc3Qgc3RhcnRTY2FsZSA9IHpvb21Ub1NjYWxlKHN0YXJ0Wm9vbSk7XG4gIGNvbnN0IGVuZFpvb20gPSBlbmRQcm9wcy56b29tO1xuICBjb25zdCBlbmRDZW50ZXIgPSBbZW5kUHJvcHMubG9uZ2l0dWRlLCBlbmRQcm9wcy5sYXRpdHVkZV07XG4gIGNvbnN0IHNjYWxlID0gem9vbVRvU2NhbGUoZW5kWm9vbSAtIHN0YXJ0Wm9vbSk7XG4gIGNvbnN0IHN0YXJ0Q2VudGVyWFkgPSBsbmdMYXRUb1dvcmxkKHN0YXJ0Q2VudGVyKTtcbiAgY29uc3QgZW5kQ2VudGVyWFkgPSBsbmdMYXRUb1dvcmxkKGVuZENlbnRlcik7XG4gIGNvbnN0IHVEZWx0YSA9IHZlYzIuc3ViKFtdLCBlbmRDZW50ZXJYWSwgc3RhcnRDZW50ZXJYWSk7XG4gIGNvbnN0IHcwID0gTWF0aC5tYXgoc3RhcnRQcm9wcy53aWR0aCwgc3RhcnRQcm9wcy5oZWlnaHQpO1xuICBjb25zdCB3MSA9IHcwIC8gc2NhbGU7XG4gIGNvbnN0IHUxID0gdmVjMi5sZW5ndGgodURlbHRhKSAqIHN0YXJ0U2NhbGU7XG4gIGNvbnN0IF91MSA9IE1hdGgubWF4KHUxLCBFUFNJTE9OKTtcbiAgY29uc3QgcmhvMiA9IHJobyAqIHJobztcbiAgY29uc3QgYjAgPSAodzEgKiB3MSAtIHcwICogdzAgKyByaG8yICogcmhvMiAqIF91MSAqIF91MSkgLyAoMiAqIHcwICogcmhvMiAqIF91MSk7XG4gIGNvbnN0IGIxID0gKHcxICogdzEgLSB3MCAqIHcwIC0gcmhvMiAqIHJobzIgKiBfdTEgKiBfdTEpIC8gKDIgKiB3MSAqIHJobzIgKiBfdTEpO1xuICBjb25zdCByMCA9IE1hdGgubG9nKE1hdGguc3FydChiMCAqIGIwICsgMSkgLSBiMCk7XG4gIGNvbnN0IHIxID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIxICogYjEgKyAxKSAtIGIxKTtcbiAgY29uc3QgUyA9IChyMSAtIHIwKSAvIHJobztcbiAgcmV0dXJuIHtcbiAgICBzdGFydFpvb20sXG4gICAgc3RhcnRDZW50ZXJYWSxcbiAgICB1RGVsdGEsXG4gICAgdzAsXG4gICAgdTEsXG4gICAgUyxcbiAgICByaG8sXG4gICAgcmhvMixcbiAgICByMCxcbiAgICByMVxuICB9O1xufSIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL3dlYi1tZXJjYXRvci12aWV3cG9ydCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFdlYk1lcmNhdG9yVmlld3BvcnQgfSBmcm9tICcuL3dlYi1tZXJjYXRvci12aWV3cG9ydCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGdldEJvdW5kcyB9IGZyb20gJy4vZ2V0LWJvdW5kcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZpdEJvdW5kcyB9IGZyb20gJy4vZml0LWJvdW5kcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG5vcm1hbGl6ZVZpZXdwb3J0UHJvcHMgfSBmcm9tICcuL25vcm1hbGl6ZS12aWV3cG9ydC1wcm9wcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZseVRvVmlld3BvcnQsIGdldEZseVRvRHVyYXRpb24gfSBmcm9tICcuL2ZseS10by12aWV3cG9ydCc7XG5leHBvcnQgeyBNQVhfTEFUSVRVREUsIGxuZ0xhdFRvV29ybGQsIHdvcmxkVG9MbmdMYXQsIHdvcmxkVG9QaXhlbHMsIHBpeGVsc1RvV29ybGQsIHpvb21Ub1NjYWxlLCBzY2FsZVRvWm9vbSwgYWx0aXR1ZGVUb0ZvdnksIGZvdnlUb0FsdGl0dWRlLCBnZXRNZXRlclpvb20sIHVuaXRzUGVyTWV0ZXIsIGdldERpc3RhbmNlU2NhbGVzLCBhZGRNZXRlcnNUb0xuZ0xhdCwgZ2V0Vmlld01hdHJpeCwgZ2V0UHJvamVjdGlvbk1hdHJpeCwgZ2V0UHJvamVjdGlvblBhcmFtZXRlcnMgfSBmcm9tICcuL3dlYi1tZXJjYXRvci11dGlscyc7IiwiZXhwb3J0IHsgV2ViTWVyY2F0b3JWaWV3cG9ydCBhcyBkZWZhdWx0IH0gZnJvbSAnQG1hdGguZ2wvd2ViLW1lcmNhdG9yJztcbmV4cG9ydCAqIGZyb20gJ0BtYXRoLmdsL3dlYi1tZXJjYXRvcic7IiwiLyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiBzaGltcyB0aGF0IHByb3ZpZGUgbWluaW1hbCBmdW5jdGlvbmFsaXR5IG9mIHRoZSBFUzYgY29sbGVjdGlvbnMuXHJcbiAqXHJcbiAqIFRoZXNlIGltcGxlbWVudGF0aW9ucyBhcmUgbm90IG1lYW50IHRvIGJlIHVzZWQgb3V0c2lkZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJcclxuICogbW9kdWxlcyBhcyB0aGV5IGNvdmVyIG9ubHkgYSBsaW1pdGVkIHJhbmdlIG9mIHVzZSBjYXNlcy5cclxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWpzZG9jLCB2YWxpZC1qc2RvYyAqL1xudmFyIE1hcFNoaW0gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBNYXA7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBpbmRleCBpbiBwcm92aWRlZCBhcnJheSB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gYXJyXHJcbiAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xuICBmdW5jdGlvbiBnZXRJbmRleChhcnIsIGtleSkge1xuICAgIHZhciByZXN1bHQgPSAtMTtcbiAgICBhcnIuc29tZShmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XG4gICAgICBpZiAoZW50cnlbMF0gPT09IGtleSkge1xuICAgICAgICByZXN1bHQgPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgdGhpcy5fX2VudHJpZXNfXyA9IFtdO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICAgICAvKipcclxuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAqL1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZW50cmllc19fLmxlbmd0aDtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cbiAgICBjbGFzc18xLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fX2VudHJpZXNfX1tpbmRleF07XG4gICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMV07XG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xuICAgIGNsYXNzXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xuICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICB0aGlzLl9fZW50cmllc19fW2luZGV4XVsxXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xuICAgIGNsYXNzXzEucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5fX2VudHJpZXNfXztcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KGVudHJpZXMsIGtleSk7XG4gICAgICBpZiAofmluZGV4KSB7XG4gICAgICAgIGVudHJpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXG4gICAgY2xhc3NfMS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuICEhfmdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXG4gICAgY2xhc3NfMS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9fZW50cmllc19fLnNwbGljZSgwKTtcbiAgICB9O1xuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgICAqIEBwYXJhbSB7Kn0gW2N0eD1udWxsXVxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cbiAgICBjbGFzc18xLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjdHgpIHtcbiAgICAgIGlmIChjdHggPT09IHZvaWQgMCkge1xuICAgICAgICBjdHggPSBudWxsO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX19lbnRyaWVzX187IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcbiAgICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGVudHJ5WzFdLCBlbnRyeVswXSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gY2xhc3NfMTtcbiAgfSgpO1xufSgpO1xuXG4vKipcclxuICogRGV0ZWN0cyB3aGV0aGVyIHdpbmRvdyBhbmQgZG9jdW1lbnQgb2JqZWN0cyBhcmUgYXZhaWxhYmxlIGluIGN1cnJlbnQgZW52aXJvbm1lbnQuXHJcbiAqL1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ID09PSBkb2N1bWVudDtcblxuLy8gUmV0dXJucyBnbG9iYWwgb2JqZWN0IG9mIGEgY3VycmVudCBlbnZpcm9ubWVudC5cbnZhciBnbG9iYWwkMSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5NYXRoID09PSBNYXRoKSB7XG4gICAgcmV0dXJuIGdsb2JhbDtcbiAgfVxuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PT0gTWF0aCkge1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PT0gTWF0aCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIHJldHVybiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xufSgpO1xuXG4vKipcclxuICogQSBzaGltIGZvciB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHdoaWNoIGZhbGxzIGJhY2sgdG8gdGhlIHNldFRpbWVvdXQgaWZcclxuICogZmlyc3Qgb25lIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJlcXVlc3RzJyBpZGVudGlmaWVyLlxyXG4gKi9cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJdCdzIHJlcXVpcmVkIHRvIHVzZSBhIGJvdW5kZWQgZnVuY3Rpb24gYmVjYXVzZSBJRSBzb21ldGltZXMgdGhyb3dzXG4gICAgLy8gYW4gXCJJbnZhbGlkIGNhbGxpbmcgb2JqZWN0XCIgZXJyb3IgaWYgckFGIGlzIGludm9rZWQgd2l0aG91dCB0aGUgZ2xvYmFsXG4gICAgLy8gb2JqZWN0IG9uIHRoZSBsZWZ0IGhhbmQgc2lkZS5cbiAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQoZ2xvYmFsJDEpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soRGF0ZS5ub3coKSk7XG4gICAgfSwgMTAwMCAvIDYwKTtcbiAgfTtcbn0oKTtcblxuLy8gRGVmaW5lcyBtaW5pbXVtIHRpbWVvdXQgYmVmb3JlIGFkZGluZyBhIHRyYWlsaW5nIGNhbGwuXG52YXIgdHJhaWxpbmdUaW1lb3V0ID0gMjtcbi8qKlxyXG4gKiBDcmVhdGVzIGEgd3JhcHBlciBmdW5jdGlvbiB3aGljaCBlbnN1cmVzIHRoYXQgcHJvdmlkZWQgY2FsbGJhY2sgd2lsbCBiZVxyXG4gKiBpbnZva2VkIG9ubHkgb25jZSBkdXJpbmcgdGhlIHNwZWNpZmllZCBkZWxheSBwZXJpb2QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgZGVsYXkgcGVyaW9kLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgLSBEZWxheSBhZnRlciB3aGljaCB0byBpbnZva2UgY2FsbGJhY2suXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuICovXG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaywgZGVsYXkpIHtcbiAgdmFyIGxlYWRpbmdDYWxsID0gZmFsc2UsXG4gICAgdHJhaWxpbmdDYWxsID0gZmFsc2UsXG4gICAgbGFzdENhbGxUaW1lID0gMDtcbiAgLyoqXHJcbiAgICogSW52b2tlcyB0aGUgb3JpZ2luYWwgY2FsbGJhY2sgZnVuY3Rpb24gYW5kIHNjaGVkdWxlcyBuZXcgaW52b2NhdGlvbiBpZlxyXG4gICAqIHRoZSBcInByb3h5XCIgd2FzIGNhbGxlZCBkdXJpbmcgY3VycmVudCByZXF1ZXN0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG4gIGZ1bmN0aW9uIHJlc29sdmVQZW5kaW5nKCkge1xuICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuICAgICAgbGVhZGluZ0NhbGwgPSBmYWxzZTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGlmICh0cmFpbGluZ0NhbGwpIHtcbiAgICAgIHByb3h5KCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIGludm9rZWQgYWZ0ZXIgdGhlIHNwZWNpZmllZCBkZWxheS4gSXQgd2lsbCBmdXJ0aGVyIHBvc3Rwb25lXHJcbiAgICogaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gZGVsZWdhdGluZyBpdCB0byB0aGVcclxuICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cbiAgZnVuY3Rpb24gdGltZW91dENhbGxiYWNrKCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxKHJlc29sdmVQZW5kaW5nKTtcbiAgfVxuICAvKipcclxuICAgKiBTY2hlZHVsZXMgaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cbiAgZnVuY3Rpb24gcHJveHkoKSB7XG4gICAgdmFyIHRpbWVTdGFtcCA9IERhdGUubm93KCk7XG4gICAgaWYgKGxlYWRpbmdDYWxsKSB7XG4gICAgICAvLyBSZWplY3QgaW1tZWRpYXRlbHkgZm9sbG93aW5nIGNhbGxzLlxuICAgICAgaWYgKHRpbWVTdGFtcCAtIGxhc3RDYWxsVGltZSA8IHRyYWlsaW5nVGltZW91dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBTY2hlZHVsZSBuZXcgY2FsbCB0byBiZSBpbiBpbnZva2VkIHdoZW4gdGhlIHBlbmRpbmcgb25lIGlzIHJlc29sdmVkLlxuICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIFwidHJhbnNpdGlvbnNcIiB3aGljaCBuZXZlciBhY3R1YWxseSBzdGFydFxuICAgICAgLy8gaW1tZWRpYXRlbHkgc28gdGhlcmUgaXMgYSBjaGFuY2UgdGhhdCB3ZSBtaWdodCBtaXNzIG9uZSBpZiBjaGFuZ2VcbiAgICAgIC8vIGhhcHBlbnMgYW1pZHMgdGhlIHBlbmRpbmcgaW52b2NhdGlvbi5cbiAgICAgIHRyYWlsaW5nQ2FsbCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlYWRpbmdDYWxsID0gdHJ1ZTtcbiAgICAgIHRyYWlsaW5nQ2FsbCA9IGZhbHNlO1xuICAgICAgc2V0VGltZW91dCh0aW1lb3V0Q2FsbGJhY2ssIGRlbGF5KTtcbiAgICB9XG4gICAgbGFzdENhbGxUaW1lID0gdGltZVN0YW1wO1xuICB9XG4gIHJldHVybiBwcm94eTtcbn1cblxuLy8gTWluaW11bSBkZWxheSBiZWZvcmUgaW52b2tpbmcgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuXG52YXIgUkVGUkVTSF9ERUxBWSA9IDIwO1xuLy8gQSBsaXN0IG9mIHN1YnN0cmluZ3Mgb2YgQ1NTIHByb3BlcnRpZXMgdXNlZCB0byBmaW5kIHRyYW5zaXRpb24gZXZlbnRzIHRoYXRcbi8vIG1pZ2h0IGFmZmVjdCBkaW1lbnNpb25zIG9mIG9ic2VydmVkIGVsZW1lbnRzLlxudmFyIHRyYW5zaXRpb25LZXlzID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ3NpemUnLCAnd2VpZ2h0J107XG4vLyBDaGVjayBpZiBNdXRhdGlvbk9ic2VydmVyIGlzIGF2YWlsYWJsZS5cbnZhciBtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkID0gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xuLyoqXHJcbiAqIFNpbmdsZXRvbiBjb250cm9sbGVyIGNsYXNzIHdoaWNoIGhhbmRsZXMgdXBkYXRlcyBvZiBSZXNpemVPYnNlcnZlciBpbnN0YW5jZXMuXHJcbiAqL1xudmFyIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cbiAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCkge1xuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgRE9NIGxpc3RlbmVycyBoYXZlIGJlZW4gYWRkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcbiAgICAgKi9cbiAgICB0aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHRoYXQgY29udHJvbGxlciBoYXMgc3Vic2NyaWJlZCBmb3IgTXV0YXRpb24gRXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIHtib29sZWFufVxyXG4gICAgICovXG4gICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xuICAgIC8qKlxyXG4gICAgICogS2VlcHMgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSBvZiBNdXRhdGlvbk9ic2VydmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIHtNdXRhdGlvbk9ic2VydmVyfVxyXG4gICAgICovXG4gICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xuICAgIC8qKlxyXG4gICAgICogQSBsaXN0IG9mIGNvbm5lY3RlZCBvYnNlcnZlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGUge0FycmF5PFJlc2l6ZU9ic2VydmVyU1BJPn1cclxuICAgICAqL1xuICAgIHRoaXMub2JzZXJ2ZXJzXyA9IFtdO1xuICAgIHRoaXMub25UcmFuc2l0aW9uRW5kXyA9IHRoaXMub25UcmFuc2l0aW9uRW5kXy5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVmcmVzaCA9IHRocm90dGxlKHRoaXMucmVmcmVzaC5iaW5kKHRoaXMpLCBSRUZSRVNIX0RFTEFZKTtcbiAgfVxuICAvKipcclxuICAgKiBBZGRzIG9ic2VydmVyIHRvIG9ic2VydmVycyBsaXN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSBhZGRlZC5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cbiAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5hZGRPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgIGlmICghfnRoaXMub2JzZXJ2ZXJzXy5pbmRleE9mKG9ic2VydmVyKSkge1xuICAgICAgdGhpcy5vYnNlcnZlcnNfLnB1c2gob2JzZXJ2ZXIpO1xuICAgIH1cbiAgICAvLyBBZGQgbGlzdGVuZXJzIGlmIHRoZXkgaGF2ZW4ndCBiZWVuIGFkZGVkIHlldC5cbiAgICBpZiAoIXRoaXMuY29ubmVjdGVkXykge1xuICAgICAgdGhpcy5jb25uZWN0XygpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSByZW1vdmVkLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZU9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzXztcbiAgICB2YXIgaW5kZXggPSBvYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7XG4gICAgLy8gUmVtb3ZlIG9ic2VydmVyIGlmIGl0J3MgcHJlc2VudCBpbiByZWdpc3RyeS5cbiAgICBpZiAofmluZGV4KSB7XG4gICAgICBvYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGxpc3RlbmVycyBpZiBjb250cm9sbGVyIGhhcyBubyBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxuICAgIGlmICghb2JzZXJ2ZXJzLmxlbmd0aCAmJiB0aGlzLmNvbm5lY3RlZF8pIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdF8oKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEludm9rZXMgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuIEl0IHdpbGwgY29udGludWUgcnVubmluZyB1cGRhdGVzIGluc29mYXJcclxuICAgKiBpdCBkZXRlY3RzIGNoYW5nZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cbiAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjaGFuZ2VzRGV0ZWN0ZWQgPSB0aGlzLnVwZGF0ZU9ic2VydmVyc18oKTtcbiAgICAvLyBDb250aW51ZSBydW5uaW5nIHVwZGF0ZXMgaWYgY2hhbmdlcyBoYXZlIGJlZW4gZGV0ZWN0ZWQgYXMgdGhlcmUgbWlnaHRcbiAgICAvLyBiZSBmdXR1cmUgb25lcyBjYXVzZWQgYnkgQ1NTIHRyYW5zaXRpb25zLlxuICAgIGlmIChjaGFuZ2VzRGV0ZWN0ZWQpIHtcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlcyBldmVyeSBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0IGFuZCBub3RpZmllcyB0aGVtIG9mIHF1ZXVlZFxyXG4gICAqIGVudHJpZXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIFwidHJ1ZVwiIGlmIGFueSBvYnNlcnZlciBoYXMgZGV0ZWN0ZWQgY2hhbmdlcyBpblxyXG4gICAqICAgICAgZGltZW5zaW9ucyBvZiBpdCdzIGVsZW1lbnRzLlxyXG4gICAqL1xuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZU9ic2VydmVyc18gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ29sbGVjdCBvYnNlcnZlcnMgdGhhdCBoYXZlIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXG4gICAgdmFyIGFjdGl2ZU9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzXy5maWx0ZXIoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICByZXR1cm4gb2JzZXJ2ZXIuZ2F0aGVyQWN0aXZlKCksIG9ic2VydmVyLmhhc0FjdGl2ZSgpO1xuICAgIH0pO1xuICAgIC8vIERlbGl2ZXIgbm90aWZpY2F0aW9ucyBpbiBhIHNlcGFyYXRlIGN5Y2xlIGluIG9yZGVyIHRvIGF2b2lkIGFueVxuICAgIC8vIGNvbGxpc2lvbnMgYmV0d2VlbiBvYnNlcnZlcnMsIGUuZy4gd2hlbiBtdWx0aXBsZSBpbnN0YW5jZXMgb2ZcbiAgICAvLyBSZXNpemVPYnNlcnZlciBhcmUgdHJhY2tpbmcgdGhlIHNhbWUgZWxlbWVudCBhbmQgdGhlIGNhbGxiYWNrIG9mIG9uZVxuICAgIC8vIG9mIHRoZW0gY2hhbmdlcyBjb250ZW50IGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIHRhcmdldC4gU29tZXRpbWVzXG4gICAgLy8gdGhpcyBtYXkgcmVzdWx0IGluIG5vdGlmaWNhdGlvbnMgYmVpbmcgYmxvY2tlZCBmb3IgdGhlIHJlc3Qgb2Ygb2JzZXJ2ZXJzLlxuICAgIGFjdGl2ZU9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgcmV0dXJuIG9ic2VydmVyLmJyb2FkY2FzdEFjdGl2ZSgpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY3RpdmVPYnNlcnZlcnMubGVuZ3RoID4gMDtcbiAgfTtcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZXMgRE9NIGxpc3RlbmVycy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG4gIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRG8gbm90aGluZyBpZiBydW5uaW5nIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQgb3IgaWYgbGlzdGVuZXJzXG4gICAgLy8gaGF2ZSBiZWVuIGFscmVhZHkgYWRkZWQuXG4gICAgaWYgKCFpc0Jyb3dzZXIgfHwgdGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFN1YnNjcmlwdGlvbiB0byB0aGUgXCJUcmFuc2l0aW9uZW5kXCIgZXZlbnQgaXMgdXNlZCBhcyBhIHdvcmthcm91bmQgZm9yXG4gICAgLy8gZGVsYXllZCB0cmFuc2l0aW9ucy4gVGhpcyB3YXkgaXQncyBwb3NzaWJsZSB0byBjYXB0dXJlIGF0IGxlYXN0IHRoZVxuICAgIC8vIGZpbmFsIHN0YXRlIG9mIGFuIGVsZW1lbnQuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XG4gICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5yZWZyZXNoKTtcbiAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLm9ic2VydmUoZG9jdW1lbnQsIHtcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcbiAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3RlZF8gPSB0cnVlO1xuICB9O1xuICAvKipcclxuICAgKiBSZW1vdmVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmRpc2Nvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xuICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IHJlbW92ZWQuXG4gICAgaWYgKCFpc0Jyb3dzZXIgfHwgIXRoaXMuY29ubmVjdGVkXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5vblRyYW5zaXRpb25FbmRfKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZWZyZXNoKTtcbiAgICBpZiAodGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8pIHtcbiAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8pIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTVN1YnRyZWVNb2RpZmllZCcsIHRoaXMucmVmcmVzaCk7XG4gICAgfVxuICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcbiAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gZmFsc2U7XG4gICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XG4gIH07XG4gIC8qKlxyXG4gICAqIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGhhbmRsZXIuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7VHJhbnNpdGlvbkV2ZW50fSBldmVudFxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uVHJhbnNpdGlvbkVuZF8gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX2IgPSBfYS5wcm9wZXJ0eU5hbWUsXG4gICAgICBwcm9wZXJ0eU5hbWUgPSBfYiA9PT0gdm9pZCAwID8gJycgOiBfYjtcbiAgICAvLyBEZXRlY3Qgd2hldGhlciB0cmFuc2l0aW9uIG1heSBhZmZlY3QgZGltZW5zaW9ucyBvZiBhbiBlbGVtZW50LlxuICAgIHZhciBpc1JlZmxvd1Byb3BlcnR5ID0gdHJhbnNpdGlvbktleXMuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gISF+cHJvcGVydHlOYW1lLmluZGV4T2Yoa2V5KTtcbiAgICB9KTtcbiAgICBpZiAoaXNSZWZsb3dQcm9wZXJ0eSkge1xuICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm5zIGluc3RhbmNlIG9mIHRoZSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAqL1xuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmluc3RhbmNlXykge1xuICAgICAgdGhpcy5pbnN0YW5jZV8gPSBuZXcgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlXztcbiAgfTtcbiAgLyoqXHJcbiAgICogSG9sZHMgcmVmZXJlbmNlIHRvIHRoZSBjb250cm9sbGVyJ3MgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAqL1xuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuaW5zdGFuY2VfID0gbnVsbDtcbiAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjtcbn0oKTtcblxuLyoqXHJcbiAqIERlZmluZXMgbm9uLXdyaXRhYmxlL2VudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgcHJvdmlkZWQgdGFyZ2V0IG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIE9iamVjdCBmb3Igd2hpY2ggdG8gZGVmaW5lIHByb3BlcnRpZXMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIFByb3BlcnRpZXMgdG8gYmUgZGVmaW5lZC5cclxuICogQHJldHVybnMge09iamVjdH0gVGFyZ2V0IG9iamVjdC5cclxuICovXG52YXIgZGVmaW5lQ29uZmlndXJhYmxlID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKHByb3BzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIga2V5ID0gX2FbX2ldO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgICAgdmFsdWU6IHByb3BzW2tleV0sXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgZ2xvYmFsIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggcHJvdmlkZWQgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gKi9cbnZhciBnZXRXaW5kb3dPZiA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgLy8gQXNzdW1lIHRoYXQgdGhlIGVsZW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgTm9kZSwgd2hpY2ggbWVhbnMgdGhhdCBpdFxuICAvLyBoYXMgdGhlIFwib3duZXJEb2N1bWVudFwiIHByb3BlcnR5IGZyb20gd2hpY2ggd2UgY2FuIHJldHJpZXZlIGFcbiAgLy8gY29ycmVzcG9uZGluZyBnbG9iYWwgb2JqZWN0LlxuICB2YXIgb3duZXJHbG9iYWwgPSB0YXJnZXQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIC8vIFJldHVybiB0aGUgbG9jYWwgZ2xvYmFsIG9iamVjdCBpZiBpdCdzIG5vdCBwb3NzaWJsZSBleHRyYWN0IG9uZSBmcm9tXG4gIC8vIHByb3ZpZGVkIGVsZW1lbnQuXG4gIHJldHVybiBvd25lckdsb2JhbCB8fCBnbG9iYWwkMTtcbn07XG5cbi8vIFBsYWNlaG9sZGVyIG9mIGFuIGVtcHR5IGNvbnRlbnQgcmVjdGFuZ2xlLlxudmFyIGVtcHR5UmVjdCA9IGNyZWF0ZVJlY3RJbml0KDAsIDAsIDAsIDApO1xuLyoqXHJcbiAqIENvbnZlcnRzIHByb3ZpZGVkIHN0cmluZyB0byBhIG51bWJlci5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cbmZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcbiAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIHx8IDA7XG59XG4vKipcclxuICogRXh0cmFjdHMgYm9yZGVycyBzaXplIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gcG9zaXRpb25zIC0gQm9yZGVycyBwb3NpdGlvbnMgKHRvcCwgcmlnaHQsIC4uLilcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMpIHtcbiAgdmFyIHBvc2l0aW9ucyA9IFtdO1xuICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIHBvc2l0aW9uc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgfVxuICByZXR1cm4gcG9zaXRpb25zLnJlZHVjZShmdW5jdGlvbiAoc2l6ZSwgcG9zaXRpb24pIHtcbiAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ2JvcmRlci0nICsgcG9zaXRpb24gKyAnLXdpZHRoJ107XG4gICAgcmV0dXJuIHNpemUgKyB0b0Zsb2F0KHZhbHVlKTtcbiAgfSwgMCk7XG59XG4vKipcclxuICogRXh0cmFjdHMgcGFkZGluZ3Mgc2l6ZXMgZnJvbSBwcm92aWRlZCBzdHlsZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFBhZGRpbmdzIGJveC5cclxuICovXG5mdW5jdGlvbiBnZXRQYWRkaW5ncyhzdHlsZXMpIHtcbiAgdmFyIHBvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG4gIHZhciBwYWRkaW5ncyA9IHt9O1xuICBmb3IgKHZhciBfaSA9IDAsIHBvc2l0aW9uc18xID0gcG9zaXRpb25zOyBfaSA8IHBvc2l0aW9uc18xLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBwb3NpdGlvbiA9IHBvc2l0aW9uc18xW19pXTtcbiAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ3BhZGRpbmctJyArIHBvc2l0aW9uXTtcbiAgICBwYWRkaW5nc1twb3NpdGlvbl0gPSB0b0Zsb2F0KHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcGFkZGluZ3M7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyBjb250ZW50IHJlY3RhbmdsZSBvZiBwcm92aWRlZCBTVkcgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtTVkdHcmFwaGljc0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHNcclxuICogICAgICB0byBiZSBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xuZnVuY3Rpb24gZ2V0U1ZHQ29udGVudFJlY3QodGFyZ2V0KSB7XG4gIHZhciBiYm94ID0gdGFyZ2V0LmdldEJCb3goKTtcbiAgcmV0dXJuIGNyZWF0ZVJlY3RJbml0KDAsIDAsIGJib3gud2lkdGgsIGJib3guaGVpZ2h0KTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHByb3ZpZGVkIEhUTUxFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGZvciB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xuZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCh0YXJnZXQpIHtcbiAgLy8gQ2xpZW50IHdpZHRoICYgaGVpZ2h0IHByb3BlcnRpZXMgY2FuJ3QgYmVcbiAgLy8gdXNlZCBleGNsdXNpdmVseSBhcyB0aGV5IHByb3ZpZGUgcm91bmRlZCB2YWx1ZXMuXG4gIHZhciBjbGllbnRXaWR0aCA9IHRhcmdldC5jbGllbnRXaWR0aCxcbiAgICBjbGllbnRIZWlnaHQgPSB0YXJnZXQuY2xpZW50SGVpZ2h0O1xuICAvLyBCeSB0aGlzIGNvbmRpdGlvbiB3ZSBjYW4gY2F0Y2ggYWxsIG5vbi1yZXBsYWNlZCBpbmxpbmUsIGhpZGRlbiBhbmRcbiAgLy8gZGV0YWNoZWQgZWxlbWVudHMuIFRob3VnaCBlbGVtZW50cyB3aXRoIHdpZHRoICYgaGVpZ2h0IHByb3BlcnRpZXMgbGVzc1xuICAvLyB0aGFuIDAuNSB3aWxsIGJlIGRpc2NhcmRlZCBhcyB3ZWxsLlxuICAvL1xuICAvLyBXaXRob3V0IGl0IHdlIHdvdWxkIG5lZWQgdG8gaW1wbGVtZW50IHNlcGFyYXRlIG1ldGhvZHMgZm9yIGVhY2ggb2ZcbiAgLy8gdGhvc2UgY2FzZXMgYW5kIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHBlcmZvcm0gYSBwcmVjaXNlIGFuZCBwZXJmb3JtYW5jZVxuICAvLyBlZmZlY3RpdmUgdGVzdCBmb3IgaGlkZGVuIGVsZW1lbnRzLiBFLmcuIGV2ZW4galF1ZXJ5J3MgJzp2aXNpYmxlJyBmaWx0ZXJcbiAgLy8gZ2l2ZXMgd3JvbmcgcmVzdWx0cyBmb3IgZWxlbWVudHMgd2l0aCB3aWR0aCAmIGhlaWdodCBsZXNzIHRoYW4gMC41LlxuICBpZiAoIWNsaWVudFdpZHRoICYmICFjbGllbnRIZWlnaHQpIHtcbiAgICByZXR1cm4gZW1wdHlSZWN0O1xuICB9XG4gIHZhciBzdHlsZXMgPSBnZXRXaW5kb3dPZih0YXJnZXQpLmdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgdmFyIHBhZGRpbmdzID0gZ2V0UGFkZGluZ3Moc3R5bGVzKTtcbiAgdmFyIGhvcml6UGFkID0gcGFkZGluZ3MubGVmdCArIHBhZGRpbmdzLnJpZ2h0O1xuICB2YXIgdmVydFBhZCA9IHBhZGRpbmdzLnRvcCArIHBhZGRpbmdzLmJvdHRvbTtcbiAgLy8gQ29tcHV0ZWQgc3R5bGVzIG9mIHdpZHRoICYgaGVpZ2h0IGFyZSBiZWluZyB1c2VkIGJlY2F1c2UgdGhleSBhcmUgdGhlXG4gIC8vIG9ubHkgZGltZW5zaW9ucyBhdmFpbGFibGUgdG8gSlMgdGhhdCBjb250YWluIG5vbi1yb3VuZGVkIHZhbHVlcy4gSXQgY291bGRcbiAgLy8gYmUgcG9zc2libGUgdG8gdXRpbGl6ZSB0aGUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlmIG9ubHkgaXQncyBkYXRhIHdhc24ndFxuICAvLyBhZmZlY3RlZCBieSBDU1MgdHJhbnNmb3JtYXRpb25zIGxldCBhbG9uZSBwYWRkaW5ncywgYm9yZGVycyBhbmQgc2Nyb2xsIGJhcnMuXG4gIHZhciB3aWR0aCA9IHRvRmxvYXQoc3R5bGVzLndpZHRoKSxcbiAgICBoZWlnaHQgPSB0b0Zsb2F0KHN0eWxlcy5oZWlnaHQpO1xuICAvLyBXaWR0aCAmIGhlaWdodCBpbmNsdWRlIHBhZGRpbmdzIGFuZCBib3JkZXJzIHdoZW4gdGhlICdib3JkZXItYm94JyBib3hcbiAgLy8gbW9kZWwgaXMgYXBwbGllZCAoZXhjZXB0IGZvciBJRSkuXG4gIGlmIChzdHlsZXMuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCcpIHtcbiAgICAvLyBGb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgcmVxdWlyZWQgdG8gaGFuZGxlIEludGVybmV0IEV4cGxvcmVyIHdoaWNoXG4gICAgLy8gZG9lc24ndCBpbmNsdWRlIHBhZGRpbmdzIGFuZCBib3JkZXJzIHRvIGNvbXB1dGVkIENTUyBkaW1lbnNpb25zLlxuICAgIC8vXG4gICAgLy8gV2UgY2FuIHNheSB0aGF0IGlmIENTUyBkaW1lbnNpb25zICsgcGFkZGluZ3MgYXJlIGVxdWFsIHRvIHRoZSBcImNsaWVudFwiXG4gICAgLy8gcHJvcGVydGllcyB0aGVuIGl0J3MgZWl0aGVyIElFLCBhbmQgdGh1cyB3ZSBkb24ndCBuZWVkIHRvIHN1YnRyYWN0XG4gICAgLy8gYW55dGhpbmcsIG9yIGFuIGVsZW1lbnQgbWVyZWx5IGRvZXNuJ3QgaGF2ZSBwYWRkaW5ncy9ib3JkZXJzIHN0eWxlcy5cbiAgICBpZiAoTWF0aC5yb3VuZCh3aWR0aCArIGhvcml6UGFkKSAhPT0gY2xpZW50V2lkdGgpIHtcbiAgICAgIHdpZHRoIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ2xlZnQnLCAncmlnaHQnKSArIGhvcml6UGFkO1xuICAgIH1cbiAgICBpZiAoTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAhPT0gY2xpZW50SGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAndG9wJywgJ2JvdHRvbScpICsgdmVydFBhZDtcbiAgICB9XG4gIH1cbiAgLy8gRm9sbG93aW5nIHN0ZXBzIGNhbid0IGJlIGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50J3Mgcm9vdCBlbGVtZW50IGFzIGl0c1xuICAvLyBjbGllbnRbV2lkdGgvSGVpZ2h0XSBwcm9wZXJ0aWVzIHJlcHJlc2VudCB2aWV3cG9ydCBhcmVhIG9mIHRoZSB3aW5kb3cuXG4gIC8vIEJlc2lkZXMsIGl0J3MgYXMgd2VsbCBub3QgbmVjZXNzYXJ5IGFzIHRoZSA8aHRtbD4gaXRzZWxmIG5laXRoZXIgaGFzXG4gIC8vIHJlbmRlcmVkIHNjcm9sbCBiYXJzIG5vciBpdCBjYW4gYmUgY2xpcHBlZC5cbiAgaWYgKCFpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpKSB7XG4gICAgLy8gSW4gc29tZSBicm93c2VycyAob25seSBpbiBGaXJlZm94LCBhY3R1YWxseSkgQ1NTIHdpZHRoICYgaGVpZ2h0XG4gICAgLy8gaW5jbHVkZSBzY3JvbGwgYmFycyBzaXplIHdoaWNoIGNhbiBiZSByZW1vdmVkIGF0IHRoaXMgc3RlcCBhcyBzY3JvbGxcbiAgICAvLyBiYXJzIGFyZSB0aGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gcm91bmRlZCBkaW1lbnNpb25zICsgcGFkZGluZ3NcbiAgICAvLyBhbmQgXCJjbGllbnRcIiBwcm9wZXJ0aWVzLCB0aG91Z2ggdGhhdCBpcyBub3QgYWx3YXlzIHRydWUgaW4gQ2hyb21lLlxuICAgIHZhciB2ZXJ0U2Nyb2xsYmFyID0gTWF0aC5yb3VuZCh3aWR0aCArIGhvcml6UGFkKSAtIGNsaWVudFdpZHRoO1xuICAgIHZhciBob3JpelNjcm9sbGJhciA9IE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgLSBjbGllbnRIZWlnaHQ7XG4gICAgLy8gQ2hyb21lIGhhcyBhIHJhdGhlciB3ZWlyZCByb3VuZGluZyBvZiBcImNsaWVudFwiIHByb3BlcnRpZXMuXG4gICAgLy8gRS5nLiBmb3IgYW4gZWxlbWVudCB3aXRoIGNvbnRlbnQgd2lkdGggb2YgMzE0LjJweCBpdCBzb21ldGltZXMgZ2l2ZXNcbiAgICAvLyB0aGUgY2xpZW50IHdpZHRoIG9mIDMxNXB4IGFuZCBmb3IgdGhlIHdpZHRoIG9mIDMxNC43cHggaXQgbWF5IGdpdmVcbiAgICAvLyAzMTRweC4gQW5kIGl0IGRvZXNuJ3QgaGFwcGVuIGFsbCB0aGUgdGltZS4gU28ganVzdCBpZ25vcmUgdGhpcyBkZWx0YVxuICAgIC8vIGFzIGEgbm9uLXJlbGV2YW50LlxuICAgIGlmIChNYXRoLmFicyh2ZXJ0U2Nyb2xsYmFyKSAhPT0gMSkge1xuICAgICAgd2lkdGggLT0gdmVydFNjcm9sbGJhcjtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKGhvcml6U2Nyb2xsYmFyKSAhPT0gMSkge1xuICAgICAgaGVpZ2h0IC09IGhvcml6U2Nyb2xsYmFyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlUmVjdEluaXQocGFkZGluZ3MubGVmdCwgcGFkZGluZ3MudG9wLCB3aWR0aCwgaGVpZ2h0KTtcbn1cbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBTVkdHcmFwaGljc0VsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXG52YXIgaXNTVkdHcmFwaGljc0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFNvbWUgYnJvd3NlcnMsIG5hbWVseSBJRSBhbmQgRWRnZSwgZG9uJ3QgaGF2ZSB0aGUgU1ZHR3JhcGhpY3NFbGVtZW50XG4gIC8vIGludGVyZmFjZS5cbiAgaWYgKHR5cGVvZiBTVkdHcmFwaGljc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0dyYXBoaWNzRWxlbWVudDtcbiAgICB9O1xuICB9XG4gIC8vIElmIGl0J3Mgc28sIHRoZW4gY2hlY2sgdGhhdCBlbGVtZW50IGlzIGF0IGxlYXN0IGFuIGluc3RhbmNlIG9mIHRoZVxuICAvLyBTVkdFbGVtZW50IGFuZCB0aGF0IGl0IGhhcyB0aGUgXCJnZXRCQm94XCIgbWV0aG9kLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zXG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuU1ZHRWxlbWVudCAmJiB0eXBlb2YgdGFyZ2V0LmdldEJCb3ggPT09ICdmdW5jdGlvbic7XG4gIH07XG59KCk7XG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhIGRvY3VtZW50IGVsZW1lbnQgKDxodG1sPikuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXG5mdW5jdGlvbiBpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldCA9PT0gZ2V0V2luZG93T2YodGFyZ2V0KS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyBhbiBhcHByb3ByaWF0ZSBjb250ZW50IHJlY3RhbmdsZSBmb3IgcHJvdmlkZWQgaHRtbCBvciBzdmcgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHdoaWNoIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXG5mdW5jdGlvbiBnZXRDb250ZW50UmVjdCh0YXJnZXQpIHtcbiAgaWYgKCFpc0Jyb3dzZXIpIHtcbiAgICByZXR1cm4gZW1wdHlSZWN0O1xuICB9XG4gIGlmIChpc1NWR0dyYXBoaWNzRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIHJlY3RhbmdsZSB3aXRoIGFuIGludGVyZmFjZSBvZiB0aGUgRE9NUmVjdFJlYWRPbmx5LlxyXG4gKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZG9tcmVjdHJlYWRvbmx5XHJcbiAqXHJcbiAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gT2JqZWN0IHdpdGggcmVjdGFuZ2xlJ3MgeC95IGNvb3JkaW5hdGVzIGFuZCBkaW1lbnNpb25zLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdFJlYWRPbmx5fVxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlYWRPbmx5UmVjdChfYSkge1xuICB2YXIgeCA9IF9hLngsXG4gICAgeSA9IF9hLnksXG4gICAgd2lkdGggPSBfYS53aWR0aCxcbiAgICBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gIC8vIElmIERPTVJlY3RSZWFkT25seSBpcyBhdmFpbGFibGUgdXNlIGl0IGFzIGEgcHJvdG90eXBlIGZvciB0aGUgcmVjdGFuZ2xlLlxuICB2YXIgQ29uc3RyID0gdHlwZW9mIERPTVJlY3RSZWFkT25seSAhPT0gJ3VuZGVmaW5lZCcgPyBET01SZWN0UmVhZE9ubHkgOiBPYmplY3Q7XG4gIHZhciByZWN0ID0gT2JqZWN0LmNyZWF0ZShDb25zdHIucHJvdG90eXBlKTtcbiAgLy8gUmVjdGFuZ2xlJ3MgcHJvcGVydGllcyBhcmUgbm90IHdyaXRhYmxlIGFuZCBub24tZW51bWVyYWJsZS5cbiAgZGVmaW5lQ29uZmlndXJhYmxlKHJlY3QsIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogaGVpZ2h0ICsgeSxcbiAgICBsZWZ0OiB4XG4gIH0pO1xuICByZXR1cm4gcmVjdDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIERPTVJlY3RJbml0IG9iamVjdCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZGltZW5zaW9ucyBhbmQgdGhlIHgveSBjb29yZGluYXRlcy5cclxuICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RpY3RkZWYtZG9tcmVjdGluaXRcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBYIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBSZWN0YW5nbGUncyB3aWR0aC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFJlY3RhbmdsZSdzIGhlaWdodC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlY3RJbml0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG5cbi8qKlxyXG4gKiBDbGFzcyB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBjb21wdXRhdGlvbnMgb2YgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlIG9mXHJcbiAqIHByb3ZpZGVkIERPTSBlbGVtZW50IGFuZCBmb3Iga2VlcGluZyB0cmFjayBvZiBpdCdzIGNoYW5nZXMuXHJcbiAqL1xudmFyIFJlc2l6ZU9ic2VydmF0aW9uID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBvYnNlcnZlZC5cclxuICAgKi9cbiAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0KSB7XG4gICAgLyoqXHJcbiAgICAgKiBCcm9hZGNhc3RlZCB3aWR0aCBvZiBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXG4gICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IDA7XG4gICAgLyoqXHJcbiAgICAgKiBCcm9hZGNhc3RlZCBoZWlnaHQgb2YgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xuICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gMDtcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgbGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSB7RE9NUmVjdEluaXR9XHJcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRlbnRSZWN0XyA9IGNyZWF0ZVJlY3RJbml0KDAsIDAsIDAsIDApO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgY29udGVudCByZWN0YW5nbGUgYW5kIHRlbGxzIHdoZXRoZXIgaXQncyB3aWR0aCBvciBoZWlnaHQgcHJvcGVydGllc1xyXG4gICAqIGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBicm9hZGNhc3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cbiAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWN0ID0gZ2V0Q29udGVudFJlY3QodGhpcy50YXJnZXQpO1xuICAgIHRoaXMuY29udGVudFJlY3RfID0gcmVjdDtcbiAgICByZXR1cm4gcmVjdC53aWR0aCAhPT0gdGhpcy5icm9hZGNhc3RXaWR0aCB8fCByZWN0LmhlaWdodCAhPT0gdGhpcy5icm9hZGNhc3RIZWlnaHQ7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgJ2Jyb2FkY2FzdFdpZHRoJyBhbmQgJ2Jyb2FkY2FzdEhlaWdodCcgcHJvcGVydGllcyB3aXRoIGEgZGF0YVxyXG4gICAqIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllcyBvZiB0aGUgbGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtET01SZWN0SW5pdH0gTGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgKi9cbiAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmJyb2FkY2FzdFJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmNvbnRlbnRSZWN0XztcbiAgICB0aGlzLmJyb2FkY2FzdFdpZHRoID0gcmVjdC53aWR0aDtcbiAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgIHJldHVybiByZWN0O1xuICB9O1xuICByZXR1cm4gUmVzaXplT2JzZXJ2YXRpb247XG59KCk7XG52YXIgUmVzaXplT2JzZXJ2ZXJFbnRyeSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJFbnRyeS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0aGF0IGlzIGJlaW5nIG9ic2VydmVkLlxyXG4gICAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gRGF0YSBvZiB0aGUgZWxlbWVudCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5KHRhcmdldCwgcmVjdEluaXQpIHtcbiAgICB2YXIgY29udGVudFJlY3QgPSBjcmVhdGVSZWFkT25seVJlY3QocmVjdEluaXQpO1xuICAgIC8vIEFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgbm90IHdyaXRhYmxlXG4gICAgLy8gYW5kIGFyZSBhbHNvIG5vdCBlbnVtZXJhYmxlIGluIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24uXG4gICAgLy9cbiAgICAvLyBQcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIG5vdCBiZWluZyB1c2VkIGFzIHRoZXknZCByZXF1aXJlIHRvIGRlZmluZSBhXG4gICAgLy8gcHJpdmF0ZSBXZWFrTWFwIHN0b3JhZ2Ugd2hpY2ggbWF5IGNhdXNlIG1lbW9yeSBsZWFrcyBpbiBicm93c2VycyB0aGF0XG4gICAgLy8gZG9uJ3Qgc3VwcG9ydCB0aGlzIHR5cGUgb2YgY29sbGVjdGlvbnMuXG4gICAgZGVmaW5lQ29uZmlndXJhYmxlKHRoaXMsIHtcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgY29udGVudFJlY3Q6IGNvbnRlbnRSZWN0XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyRW50cnk7XG59KCk7XG52YXIgUmVzaXplT2JzZXJ2ZXJTUEkgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZFxyXG4gICAqICAgICAgd2hlbiBvbmUgb2YgdGhlIG9ic2VydmVkIGVsZW1lbnRzIGNoYW5nZXMgaXQncyBjb250ZW50IGRpbWVuc2lvbnMuXHJcbiAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9IGNvbnRyb2xsZXIgLSBDb250cm9sbGVyIGluc3RhbmNlIHdoaWNoXHJcbiAgICogICAgICBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHVwZGF0ZXMgb2Ygb2JzZXJ2ZXIuXHJcbiAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlcn0gY2FsbGJhY2tDdHggLSBSZWZlcmVuY2UgdG8gdGhlIHB1YmxpY1xyXG4gICAqICAgICAgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2Ugd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICovXG4gIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyU1BJKGNhbGxiYWNrLCBjb250cm9sbGVyLCBjYWxsYmFja0N0eCkge1xuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdGlvbiBvZiByZXNpemUgb2JzZXJ2YXRpb25zIHRoYXQgaGF2ZSBkZXRlY3RlZCBjaGFuZ2VzIGluIGRpbWVuc2lvbnNcclxuICAgICAqIG9mIGVsZW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIHtBcnJheTxSZXNpemVPYnNlcnZhdGlvbj59XHJcbiAgICAgKi9cbiAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18gPSBbXTtcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdHJ5IG9mIHRoZSBSZXNpemVPYnNlcnZhdGlvbiBpbnN0YW5jZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGUge01hcDxFbGVtZW50LCBSZXNpemVPYnNlcnZhdGlvbj59XHJcbiAgICAgKi9cbiAgICB0aGlzLm9ic2VydmF0aW9uc18gPSBuZXcgTWFwU2hpbSgpO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG4gICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcbiAgICB0aGlzLmNvbnRyb2xsZXJfID0gY29udHJvbGxlcjtcbiAgICB0aGlzLmNhbGxiYWNrQ3R4XyA9IGNhbGxiYWNrQ3R4O1xuICB9XG4gIC8qKlxyXG4gICAqIFN0YXJ0cyBvYnNlcnZpbmcgcHJvdmlkZWQgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBvYnNlcnZlZC5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cbiAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XG4gICAgfVxuICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxuICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLkVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcbiAgICB9XG4gICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcbiAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBvYnNlcnZlZC5cbiAgICBpZiAob2JzZXJ2YXRpb25zLmhhcyh0YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9ic2VydmF0aW9ucy5zZXQodGFyZ2V0LCBuZXcgUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0KSk7XG4gICAgdGhpcy5jb250cm9sbGVyXy5hZGRPYnNlcnZlcih0aGlzKTtcbiAgICAvLyBGb3JjZSB0aGUgdXBkYXRlIG9mIG9ic2VydmF0aW9ucy5cbiAgICB0aGlzLmNvbnRyb2xsZXJfLnJlZnJlc2goKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogU3RvcHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gc3RvcCBvYnNlcnZpbmcuXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG4gIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS51bm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XG4gICAgfVxuICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxuICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLkVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcbiAgICB9XG4gICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcbiAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgbm90IGJlaW5nIG9ic2VydmVkLlxuICAgIGlmICghb2JzZXJ2YXRpb25zLmhhcyh0YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9ic2VydmF0aW9ucy5kZWxldGUodGFyZ2V0KTtcbiAgICBpZiAoIW9ic2VydmF0aW9ucy5zaXplKSB7XG4gICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlbW92ZU9ic2VydmVyKHRoaXMpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogU3RvcHMgb2JzZXJ2aW5nIGFsbCBlbGVtZW50cy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XG4gICAgdGhpcy5vYnNlcnZhdGlvbnNfLmNsZWFyKCk7XG4gICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ29sbGVjdHMgb2JzZXJ2YXRpb24gaW5zdGFuY2VzIHRoZSBhc3NvY2lhdGVkIGVsZW1lbnQgb2Ygd2hpY2ggaGFzIGNoYW5nZWRcclxuICAgKiBpdCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG4gIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5nYXRoZXJBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XG4gICAgdGhpcy5vYnNlcnZhdGlvbnNfLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmF0aW9uKSB7XG4gICAgICBpZiAob2JzZXJ2YXRpb24uaXNBY3RpdmUoKSkge1xuICAgICAgICBfdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLnB1c2gob2JzZXJ2YXRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBJbnZva2VzIGluaXRpYWwgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBhIGxpc3Qgb2YgUmVzaXplT2JzZXJ2ZXJFbnRyeVxyXG4gICAqIGluc3RhbmNlcyBjb2xsZWN0ZWQgZnJvbSBhY3RpdmUgcmVzaXplIG9ic2VydmF0aW9ucy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuYnJvYWRjYXN0QWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIERvIG5vdGhpbmcgaWYgb2JzZXJ2ZXIgZG9lc24ndCBoYXZlIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXG4gICAgaWYgKCF0aGlzLmhhc0FjdGl2ZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjdHggPSB0aGlzLmNhbGxiYWNrQ3R4XztcbiAgICAvLyBDcmVhdGUgUmVzaXplT2JzZXJ2ZXJFbnRyeSBpbnN0YW5jZSBmb3IgZXZlcnkgYWN0aXZlIG9ic2VydmF0aW9uLlxuICAgIHZhciBlbnRyaWVzID0gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLm1hcChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcbiAgICAgIHJldHVybiBuZXcgUmVzaXplT2JzZXJ2ZXJFbnRyeShvYnNlcnZhdGlvbi50YXJnZXQsIG9ic2VydmF0aW9uLmJyb2FkY2FzdFJlY3QoKSk7XG4gICAgfSk7XG4gICAgdGhpcy5jYWxsYmFja18uY2FsbChjdHgsIGVudHJpZXMsIGN0eCk7XG4gICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xuICB9O1xuICAvKipcclxuICAgKiBDbGVhcnMgdGhlIGNvbGxlY3Rpb24gb2YgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuY2xlYXJBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLnNwbGljZSgwKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVGVsbHMgd2hldGhlciBvYnNlcnZlciBoYXMgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xuICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuaGFzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ubGVuZ3RoID4gMDtcbiAgfTtcbiAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyU1BJO1xufSgpO1xuXG4vLyBSZWdpc3RyeSBvZiBpbnRlcm5hbCBvYnNlcnZlcnMuIElmIFdlYWtNYXAgaXMgbm90IGF2YWlsYWJsZSB1c2UgY3VycmVudCBzaGltXG4vLyBmb3IgdGhlIE1hcCBjb2xsZWN0aW9uIGFzIGl0IGhhcyBhbGwgcmVxdWlyZWQgbWV0aG9kcyBhbmQgYmVjYXVzZSBXZWFrTWFwXG4vLyBjYW4ndCBiZSBmdWxseSBwb2x5ZmlsbGVkIGFueXdheS5cbnZhciBvYnNlcnZlcnMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgV2Vha01hcCgpIDogbmV3IE1hcFNoaW0oKTtcbi8qKlxyXG4gKiBSZXNpemVPYnNlcnZlciBBUEkuIEVuY2Fwc3VsYXRlcyB0aGUgUmVzaXplT2JzZXJ2ZXIgU1BJIGltcGxlbWVudGF0aW9uXHJcbiAqIGV4cG9zaW5nIG9ubHkgdGhvc2UgbWV0aG9kcyBhbmQgcHJvcGVydGllcyB0aGF0IGFyZSBkZWZpbmVkIGluIHRoZSBzcGVjLlxyXG4gKi9cbnZhciBSZXNpemVPYnNlcnZlciA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIHdoZW5cclxuICAgKiAgICAgIGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIGVsZW1lbnRzIGNoYW5nZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXIoY2FsbGJhY2spIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzaXplT2JzZXJ2ZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xuICAgIH1cbiAgICB2YXIgY29udHJvbGxlciA9IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSgpO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgdGhpcyk7XG4gICAgb2JzZXJ2ZXJzLnNldCh0aGlzLCBvYnNlcnZlcik7XG4gIH1cbiAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xufSgpO1xuLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzIG9mIFJlc2l6ZU9ic2VydmVyLlxuWydvYnNlcnZlJywgJ3Vub2JzZXJ2ZScsICdkaXNjb25uZWN0J10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIFJlc2l6ZU9ic2VydmVyLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gb2JzZXJ2ZXJzLmdldCh0aGlzKSlbbWV0aG9kXS5hcHBseShfYSwgYXJndW1lbnRzKTtcbiAgfTtcbn0pO1xudmFyIGluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAvLyBFeHBvcnQgZXhpc3RpbmcgaW1wbGVtZW50YXRpb24gaWYgYXZhaWxhYmxlLlxuICBpZiAodHlwZW9mIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBnbG9iYWwkMS5SZXNpemVPYnNlcnZlcjtcbiAgfVxuICByZXR1cm4gUmVzaXplT2JzZXJ2ZXI7XG59KCk7XG5leHBvcnQgZGVmYXVsdCBpbmRleDsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikge1xuICBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5leHBvcnQgeyBfY2xhc3NDYWxsQ2hlY2sgYXMgZGVmYXVsdCB9OyIsImltcG9ydCB0b1Byb3BlcnR5S2V5IGZyb20gXCIuL3RvUHJvcGVydHlLZXkuanNcIjtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG8gPSByW3RdO1xuICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7XG4gIHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogITFcbiAgfSksIGU7XG59XG5leHBvcnQgeyBfY3JlYXRlQ2xhc3MgYXMgZGVmYXVsdCB9OyIsInZhciB3aW5kb3dfID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWw7XG52YXIgZ2xvYmFsXyA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93O1xudmFyIGRvY3VtZW50XyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHt9O1xuZXhwb3J0IHsgd2luZG93XyBhcyB3aW5kb3csIGdsb2JhbF8gYXMgZ2xvYmFsLCBkb2N1bWVudF8gYXMgZG9jdW1lbnQgfTsiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQ7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHM6IEYsXG4gICAgICAgIG46IGZ1bmN0aW9uIG4oKSB7XG4gICAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZTogZnVuY3Rpb24gZShfZSkge1xuICAgICAgICAgIHRocm93IF9lO1xuICAgICAgICB9LFxuICAgICAgICBmOiBGXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cbiAgdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLFxuICAgIGRpZEVyciA9IGZhbHNlLFxuICAgIGVycjtcbiAgcmV0dXJuIHtcbiAgICBzOiBmdW5jdGlvbiBzKCkge1xuICAgICAgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9LFxuICAgIG46IGZ1bmN0aW9uIG4oKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0Lm5leHQoKTtcbiAgICAgIG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7XG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uIGUoX2UyKSB7XG4gICAgICBkaWRFcnIgPSB0cnVlO1xuICAgICAgZXJyID0gX2UyO1xuICAgIH0sXG4gICAgZjogZnVuY3Rpb24gZigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGRpZEVycikgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG4gIHJldHVybiBhcnIyO1xufVxudmFyIHJlZlByb3BzID0gWyd0eXBlJywgJ3NvdXJjZScsICdzb3VyY2UtbGF5ZXInLCAnbWluem9vbScsICdtYXh6b29tJywgJ2ZpbHRlcicsICdsYXlvdXQnXTtcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVTdHlsZShzdHlsZSkge1xuICBpZiAoIXN0eWxlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cbiAgaWYgKHN0eWxlLnRvSlMpIHtcbiAgICBzdHlsZSA9IHN0eWxlLnRvSlMoKTtcbiAgfVxuICB2YXIgbGF5ZXJJbmRleCA9IHt9O1xuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3R5bGUubGF5ZXJzKSxcbiAgICBfc3RlcDtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIGxheWVyID0gX3N0ZXAudmFsdWU7XG4gICAgICBsYXllckluZGV4W2xheWVyLmlkXSA9IGxheWVyO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG4gIHZhciBsYXllcnMgPSBzdHlsZS5sYXllcnMubWFwKGZ1bmN0aW9uIChsYXllcikge1xuICAgIHZhciBsYXllclJlZiA9IGxheWVySW5kZXhbbGF5ZXIucmVmXTtcbiAgICB2YXIgbm9ybWFsaXplZExheWVyID0gbnVsbDtcbiAgICBpZiAoJ2ludGVyYWN0aXZlJyBpbiBsYXllcikge1xuICAgICAgbm9ybWFsaXplZExheWVyID0gX29iamVjdFNwcmVhZCh7fSwgbGF5ZXIpO1xuICAgICAgZGVsZXRlIG5vcm1hbGl6ZWRMYXllci5pbnRlcmFjdGl2ZTtcbiAgICB9XG4gICAgaWYgKGxheWVyUmVmKSB7XG4gICAgICBub3JtYWxpemVkTGF5ZXIgPSBub3JtYWxpemVkTGF5ZXIgfHwgX29iamVjdFNwcmVhZCh7fSwgbGF5ZXIpO1xuICAgICAgZGVsZXRlIG5vcm1hbGl6ZWRMYXllci5yZWY7XG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJlZlByb3BzKSxcbiAgICAgICAgX3N0ZXAyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgaWYgKHByb3BOYW1lIGluIGxheWVyUmVmKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkTGF5ZXJbcHJvcE5hbWVdID0gbGF5ZXJSZWZbcHJvcE5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkTGF5ZXIgfHwgbGF5ZXI7XG4gIH0pO1xuICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdHlsZSksIHt9LCB7XG4gICAgbGF5ZXJzOiBsYXllcnNcbiAgfSk7XG59IiwiaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0ICogYXMgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgZG9jdW1lbnQgfSBmcm9tICcuLi91dGlscy9nbG9iYWxzJztcbmltcG9ydCB7IG5vcm1hbGl6ZVN0eWxlIH0gZnJvbSAnLi4vdXRpbHMvc3R5bGUtdXRpbHMnO1xuZnVuY3Rpb24gbm9vcCgpIHt9XG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvcihldmVudCkge1xuICBpZiAoZXZlbnQpIHtcbiAgICBjb25zb2xlLmVycm9yKGV2ZW50LmVycm9yKTtcbiAgfVxufVxudmFyIHByb3BUeXBlcyA9IHtcbiAgY29udGFpbmVyOiBQcm9wVHlwZXMub2JqZWN0LFxuICBnbDogUHJvcFR5cGVzLm9iamVjdCxcbiAgbWFwYm94QXBpQWNjZXNzVG9rZW46IFByb3BUeXBlcy5zdHJpbmcsXG4gIG1hcGJveEFwaVVybDogUHJvcFR5cGVzLnN0cmluZyxcbiAgYXR0cmlidXRpb25Db250cm9sOiBQcm9wVHlwZXMuYm9vbCxcbiAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgcmV1c2VNYXBzOiBQcm9wVHlwZXMuYm9vbCxcbiAgdHJhbnNmb3JtUmVxdWVzdDogUHJvcFR5cGVzLmZ1bmMsXG4gIG1hcE9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3QsXG4gIG1hcFN0eWxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSksXG4gIHByZXZlbnRTdHlsZURpZmZpbmc6IFByb3BUeXBlcy5ib29sLFxuICB2aXNpYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgYXN5bmNSZW5kZXI6IFByb3BUeXBlcy5ib29sLFxuICBvbkxvYWQ6IFByb3BUeXBlcy5mdW5jLFxuICBvbkVycm9yOiBQcm9wVHlwZXMuZnVuYyxcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcbiAgdmlld1N0YXRlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBsb25naXR1ZGU6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxhdGl0dWRlOiBQcm9wVHlwZXMubnVtYmVyLFxuICB6b29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICBiZWFyaW5nOiBQcm9wVHlwZXMubnVtYmVyLFxuICBwaXRjaDogUHJvcFR5cGVzLm51bWJlcixcbiAgYWx0aXR1ZGU6IFByb3BUeXBlcy5udW1iZXJcbn07XG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBjb250YWluZXI6IGRvY3VtZW50LmJvZHksXG4gIG1hcGJveEFwaUFjY2Vzc1Rva2VuOiBnZXRBY2Nlc3NUb2tlbigpLFxuICBtYXBib3hBcGlVcmw6ICdodHRwczovL2FwaS5tYXBib3guY29tJyxcbiAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgYXR0cmlidXRpb25Db250cm9sOiB0cnVlLFxuICByZXVzZU1hcHM6IGZhbHNlLFxuICBtYXBPcHRpb25zOiB7fSxcbiAgbWFwU3R5bGU6ICdtYXBib3g6Ly9zdHlsZXMvbWFwYm94L2xpZ2h0LXY4JyxcbiAgcHJldmVudFN0eWxlRGlmZmluZzogZmFsc2UsXG4gIHZpc2libGU6IHRydWUsXG4gIGFzeW5jUmVuZGVyOiBmYWxzZSxcbiAgb25Mb2FkOiBub29wLFxuICBvbkVycm9yOiBkZWZhdWx0T25FcnJvcixcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgbG9uZ2l0dWRlOiAwLFxuICBsYXRpdHVkZTogMCxcbiAgem9vbTogMCxcbiAgYmVhcmluZzogMCxcbiAgcGl0Y2g6IDAsXG4gIGFsdGl0dWRlOiAxLjVcbn07XG5leHBvcnQgZnVuY3Rpb24gZ2V0QWNjZXNzVG9rZW4oKSB7XG4gIHZhciBhY2Nlc3NUb2tlbiA9IG51bGw7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYXRpb24pIHtcbiAgICB2YXIgbWF0Y2ggPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLm1hdGNoKC9hY2Nlc3NfdG9rZW49KFteJlxcL10qKS8pO1xuICAgIGFjY2Vzc1Rva2VuID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gIH1cbiAgaWYgKCFhY2Nlc3NUb2tlbiAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBhY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuIHx8IHByb2Nlc3MuZW52Lk1hcGJveEFjY2Vzc1Rva2VuIHx8IHByb2Nlc3MuZW52LlJFQUNUX0FQUF9NQVBCT1hfQUNDRVNTX1RPS0VOO1xuICB9XG4gIHJldHVybiBhY2Nlc3NUb2tlbiB8fCAnbm8tdG9rZW4nO1xufVxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXMocHJvcHMpIHtcbiAgdmFyIGNvbXBvbmVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2NvbXBvbmVudCc7XG4gIGlmIChwcm9wcy5kZWJ1Zykge1xuICAgIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIHByb3BzLCAncHJvcCcsIGNvbXBvbmVudCk7XG4gIH1cbn1cbnZhciBNYXBib3ggPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hcGJveChwcm9wcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcGJveCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvcHNcIiwgZGVmYXVsdFByb3BzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3aWR0aFwiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoZWlnaHRcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ZpcmVMb2FkRXZlbnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMucHJvcHMub25Mb2FkKHtcbiAgICAgICAgdHlwZTogJ2xvYWQnLFxuICAgICAgICB0YXJnZXQ6IF90aGlzLl9tYXBcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9oYW5kbGVFcnJvclwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzLnByb3BzLm9uRXJyb3IoZXZlbnQpO1xuICAgIH0pO1xuICAgIGlmICghcHJvcHMubWFwYm94Z2wpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWFwYm94IG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG4gICAgdGhpcy5tYXBib3hnbCA9IHByb3BzLm1hcGJveGdsO1xuICAgIGlmICghTWFwYm94LmluaXRpYWxpemVkKSB7XG4gICAgICBNYXBib3guaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fY2hlY2tTdHlsZVNoZWV0KHRoaXMubWFwYm94Z2wudmVyc2lvbik7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxpemUocHJvcHMpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhNYXBib3gsIFt7XG4gICAga2V5OiBcImZpbmFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmFsaXplKCkge1xuICAgICAgdGhpcy5fZGVzdHJveSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFByb3BzKHByb3BzKSB7XG4gICAgICB0aGlzLl91cGRhdGUodGhpcy5wcm9wcywgcHJvcHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWRyYXcoKSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuICAgICAgaWYgKG1hcC5zdHlsZSkge1xuICAgICAgICBpZiAobWFwLl9mcmFtZSkge1xuICAgICAgICAgIG1hcC5fZnJhbWUuY2FuY2VsKCk7XG4gICAgICAgICAgbWFwLl9mcmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbWFwLl9yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZXVzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmV1c2UocHJvcHMpIHtcbiAgICAgIHRoaXMuX21hcCA9IE1hcGJveC5zYXZlZE1hcDtcbiAgICAgIHZhciBvbGRDb250YWluZXIgPSB0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCk7XG4gICAgICB2YXIgbmV3Q29udGFpbmVyID0gcHJvcHMuY29udGFpbmVyO1xuICAgICAgbmV3Q29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ21hcGJveGdsLW1hcCcpO1xuICAgICAgd2hpbGUgKG9sZENvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbmV3Q29udGFpbmVyLmFwcGVuZENoaWxkKG9sZENvbnRhaW5lci5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21hcC5fY29udGFpbmVyID0gbmV3Q29udGFpbmVyO1xuICAgICAgTWFwYm94LnNhdmVkTWFwID0gbnVsbDtcbiAgICAgIGlmIChwcm9wcy5tYXBTdHlsZSkge1xuICAgICAgICB0aGlzLl9tYXAuc2V0U3R5bGUobm9ybWFsaXplU3R5bGUocHJvcHMubWFwU3R5bGUpLCB7XG4gICAgICAgICAgZGlmZjogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbWFwLmlzU3R5bGVMb2FkZWQoKSkge1xuICAgICAgICB0aGlzLl9maXJlTG9hZEV2ZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9tYXAub25jZSgnc3R5bGVkYXRhJywgdGhpcy5fZmlyZUxvYWRFdmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZShwcm9wcykge1xuICAgICAgaWYgKHByb3BzLnJldXNlTWFwcyAmJiBNYXBib3guc2F2ZWRNYXApIHtcbiAgICAgICAgdGhpcy5fcmV1c2UocHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb3BzLmdsKSB7XG4gICAgICAgICAgdmFyIGdldENvbnRleHQgPSBIVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUuZ2V0Q29udGV4dDtcbiAgICAgICAgICBIVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIEhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZ2V0Q29udGV4dDtcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5nbDtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXBPcHRpb25zID0ge1xuICAgICAgICAgIGNvbnRhaW5lcjogcHJvcHMuY29udGFpbmVyLFxuICAgICAgICAgIGNlbnRlcjogWzAsIDBdLFxuICAgICAgICAgIHpvb206IDgsXG4gICAgICAgICAgcGl0Y2g6IDAsXG4gICAgICAgICAgYmVhcmluZzogMCxcbiAgICAgICAgICBtYXhab29tOiAyNCxcbiAgICAgICAgICBzdHlsZTogbm9ybWFsaXplU3R5bGUocHJvcHMubWFwU3R5bGUpLFxuICAgICAgICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICB0cmFja1Jlc2l6ZTogZmFsc2UsXG4gICAgICAgICAgYXR0cmlidXRpb25Db250cm9sOiBwcm9wcy5hdHRyaWJ1dGlvbkNvbnRyb2wsXG4gICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBwcm9wcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByb3BzLnRyYW5zZm9ybVJlcXVlc3QpIHtcbiAgICAgICAgICBtYXBPcHRpb25zLnRyYW5zZm9ybVJlcXVlc3QgPSBwcm9wcy50cmFuc2Zvcm1SZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyB0aGlzLm1hcGJveGdsLk1hcChPYmplY3QuYXNzaWduKHt9LCBtYXBPcHRpb25zLCBwcm9wcy5tYXBPcHRpb25zKSk7XG4gICAgICAgIHRoaXMuX21hcC5vbmNlKCdsb2FkJywgdGhpcy5fZmlyZUxvYWRFdmVudCk7XG4gICAgICAgIHRoaXMuX21hcC5vbignZXJyb3InLCB0aGlzLl9oYW5kbGVFcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICBpZiAoIXRoaXMuX21hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcm9wcy5yZXVzZU1hcHMgJiYgIU1hcGJveC5zYXZlZE1hcCkge1xuICAgICAgICBNYXBib3guc2F2ZWRNYXAgPSB0aGlzLl9tYXA7XG4gICAgICAgIHRoaXMuX21hcC5vZmYoJ2xvYWQnLCB0aGlzLl9maXJlTG9hZEV2ZW50KTtcbiAgICAgICAgdGhpcy5fbWFwLm9mZignZXJyb3InLCB0aGlzLl9oYW5kbGVFcnJvcik7XG4gICAgICAgIHRoaXMuX21hcC5vZmYoJ3N0eWxlZGF0YScsIHRoaXMuX2ZpcmVMb2FkRXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbWFwLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRpYWxpemUocHJvcHMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgcHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UHJvcHMsIHByb3BzKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BzLCAnTWFwYm94Jyk7XG4gICAgICB0aGlzLm1hcGJveGdsLmFjY2Vzc1Rva2VuID0gcHJvcHMubWFwYm94QXBpQWNjZXNzVG9rZW4gfHwgZGVmYXVsdFByb3BzLm1hcGJveEFwaUFjY2Vzc1Rva2VuO1xuICAgICAgdGhpcy5tYXBib3hnbC5iYXNlQXBpVXJsID0gcHJvcHMubWFwYm94QXBpVXJsO1xuICAgICAgdGhpcy5fY3JlYXRlKHByb3BzKTtcbiAgICAgIHZhciBfcHJvcHMgPSBwcm9wcyxcbiAgICAgICAgY29udGFpbmVyID0gX3Byb3BzLmNvbnRhaW5lcjtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250YWluZXIsICdvZmZzZXRXaWR0aCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250YWluZXIsICdjbGllbnRXaWR0aCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250YWluZXIsICdvZmZzZXRIZWlnaHQnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnRhaW5lciwgJ2NsaWVudEhlaWdodCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5fbWFwLmdldENhbnZhcygpO1xuICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICBjYW52YXMuc3R5bGUub3V0bGluZSA9ICdub25lJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZU1hcFZpZXdwb3J0KHt9LCBwcm9wcyk7XG4gICAgICB0aGlzLl91cGRhdGVNYXBTaXplKHt9LCBwcm9wcyk7XG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZShvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICAgIGlmICghdGhpcy5fbWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywgbmV3UHJvcHMpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMobmV3UHJvcHMsICdNYXBib3gnKTtcbiAgICAgIHZhciB2aWV3cG9ydENoYW5nZWQgPSB0aGlzLl91cGRhdGVNYXBWaWV3cG9ydChvbGRQcm9wcywgbmV3UHJvcHMpO1xuICAgICAgdmFyIHNpemVDaGFuZ2VkID0gdGhpcy5fdXBkYXRlTWFwU2l6ZShvbGRQcm9wcywgbmV3UHJvcHMpO1xuICAgICAgdGhpcy5fdXBkYXRlTWFwU3R5bGUob2xkUHJvcHMsIG5ld1Byb3BzKTtcbiAgICAgIGlmICghbmV3UHJvcHMuYXN5bmNSZW5kZXIgJiYgKHZpZXdwb3J0Q2hhbmdlZCB8fCBzaXplQ2hhbmdlZCkpIHtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJvcHMgPSBuZXdQcm9wcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZU1hcFN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVNYXBTdHlsZShvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICAgIHZhciBzdHlsZUNoYW5nZWQgPSBvbGRQcm9wcy5tYXBTdHlsZSAhPT0gbmV3UHJvcHMubWFwU3R5bGU7XG4gICAgICBpZiAoc3R5bGVDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuX21hcC5zZXRTdHlsZShub3JtYWxpemVTdHlsZShuZXdQcm9wcy5tYXBTdHlsZSksIHtcbiAgICAgICAgICBkaWZmOiAhbmV3UHJvcHMucHJldmVudFN0eWxlRGlmZmluZ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZU1hcFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZU1hcFNpemUob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgICB2YXIgc2l6ZUNoYW5nZWQgPSBvbGRQcm9wcy53aWR0aCAhPT0gbmV3UHJvcHMud2lkdGggfHwgb2xkUHJvcHMuaGVpZ2h0ICE9PSBuZXdQcm9wcy5oZWlnaHQ7XG4gICAgICBpZiAoc2l6ZUNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IG5ld1Byb3BzLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IG5ld1Byb3BzLmhlaWdodDtcbiAgICAgICAgdGhpcy5fbWFwLnJlc2l6ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpemVDaGFuZ2VkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlTWFwVmlld3BvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZU1hcFZpZXdwb3J0KG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgICAgdmFyIG9sZFZpZXdTdGF0ZSA9IHRoaXMuX2dldFZpZXdTdGF0ZShvbGRQcm9wcyk7XG4gICAgICB2YXIgbmV3Vmlld1N0YXRlID0gdGhpcy5fZ2V0Vmlld1N0YXRlKG5ld1Byb3BzKTtcbiAgICAgIHZhciB2aWV3cG9ydENoYW5nZWQgPSBuZXdWaWV3U3RhdGUubGF0aXR1ZGUgIT09IG9sZFZpZXdTdGF0ZS5sYXRpdHVkZSB8fCBuZXdWaWV3U3RhdGUubG9uZ2l0dWRlICE9PSBvbGRWaWV3U3RhdGUubG9uZ2l0dWRlIHx8IG5ld1ZpZXdTdGF0ZS56b29tICE9PSBvbGRWaWV3U3RhdGUuem9vbSB8fCBuZXdWaWV3U3RhdGUucGl0Y2ggIT09IG9sZFZpZXdTdGF0ZS5waXRjaCB8fCBuZXdWaWV3U3RhdGUuYmVhcmluZyAhPT0gb2xkVmlld1N0YXRlLmJlYXJpbmcgfHwgbmV3Vmlld1N0YXRlLmFsdGl0dWRlICE9PSBvbGRWaWV3U3RhdGUuYWx0aXR1ZGU7XG4gICAgICBpZiAodmlld3BvcnRDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuX21hcC5qdW1wVG8odGhpcy5fdmlld1N0YXRlVG9NYXBib3hQcm9wcyhuZXdWaWV3U3RhdGUpKTtcbiAgICAgICAgaWYgKG5ld1ZpZXdTdGF0ZS5hbHRpdHVkZSAhPT0gb2xkVmlld1N0YXRlLmFsdGl0dWRlKSB7XG4gICAgICAgICAgdGhpcy5fbWFwLnRyYW5zZm9ybS5hbHRpdHVkZSA9IG5ld1ZpZXdTdGF0ZS5hbHRpdHVkZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZpZXdwb3J0Q2hhbmdlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFZpZXdTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Vmlld1N0YXRlKHByb3BzKSB7XG4gICAgICB2YXIgX3JlZiA9IHByb3BzLnZpZXdTdGF0ZSB8fCBwcm9wcyxcbiAgICAgICAgbG9uZ2l0dWRlID0gX3JlZi5sb25naXR1ZGUsXG4gICAgICAgIGxhdGl0dWRlID0gX3JlZi5sYXRpdHVkZSxcbiAgICAgICAgem9vbSA9IF9yZWYuem9vbSxcbiAgICAgICAgX3JlZiRwaXRjaCA9IF9yZWYucGl0Y2gsXG4gICAgICAgIHBpdGNoID0gX3JlZiRwaXRjaCA9PT0gdm9pZCAwID8gMCA6IF9yZWYkcGl0Y2gsXG4gICAgICAgIF9yZWYkYmVhcmluZyA9IF9yZWYuYmVhcmluZyxcbiAgICAgICAgYmVhcmluZyA9IF9yZWYkYmVhcmluZyA9PT0gdm9pZCAwID8gMCA6IF9yZWYkYmVhcmluZyxcbiAgICAgICAgX3JlZiRhbHRpdHVkZSA9IF9yZWYuYWx0aXR1ZGUsXG4gICAgICAgIGFsdGl0dWRlID0gX3JlZiRhbHRpdHVkZSA9PT0gdm9pZCAwID8gMS41IDogX3JlZiRhbHRpdHVkZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxvbmdpdHVkZTogbG9uZ2l0dWRlLFxuICAgICAgICBsYXRpdHVkZTogbGF0aXR1ZGUsXG4gICAgICAgIHpvb206IHpvb20sXG4gICAgICAgIHBpdGNoOiBwaXRjaCxcbiAgICAgICAgYmVhcmluZzogYmVhcmluZyxcbiAgICAgICAgYWx0aXR1ZGU6IGFsdGl0dWRlXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2hlY2tTdHlsZVNoZWV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja1N0eWxlU2hlZXQoKSB7XG4gICAgICB2YXIgbWFwYm94VmVyc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJzAuNDcuMCc7XG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGVzdEVsZW1lbnQuY2xhc3NOYW1lID0gJ21hcGJveGdsLW1hcCc7XG4gICAgICAgIHRlc3RFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVzdEVsZW1lbnQpO1xuICAgICAgICB2YXIgaXNDc3NMb2FkZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0ZXN0RWxlbWVudCkucG9zaXRpb24gIT09ICdzdGF0aWMnO1xuICAgICAgICBpZiAoIWlzQ3NzTG9hZGVkKSB7XG4gICAgICAgICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ3JlbCcsICdzdHlsZXNoZWV0Jyk7XG4gICAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnaHJlZicsIFwiaHR0cHM6Ly9hcGkudGlsZXMubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvdlwiLmNvbmNhdChtYXBib3hWZXJzaW9uLCBcIi9tYXBib3gtZ2wuY3NzXCIpKTtcbiAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3ZpZXdTdGF0ZVRvTWFwYm94UHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ZpZXdTdGF0ZVRvTWFwYm94UHJvcHModmlld1N0YXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjZW50ZXI6IFt2aWV3U3RhdGUubG9uZ2l0dWRlLCB2aWV3U3RhdGUubGF0aXR1ZGVdLFxuICAgICAgICB6b29tOiB2aWV3U3RhdGUuem9vbSxcbiAgICAgICAgYmVhcmluZzogdmlld1N0YXRlLmJlYXJpbmcsXG4gICAgICAgIHBpdGNoOiB2aWV3U3RhdGUucGl0Y2hcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNYXBib3g7XG59KCk7XG5fZGVmaW5lUHJvcGVydHkoTWFwYm94LCBcImluaXRpYWxpemVkXCIsIGZhbHNlKTtcbl9kZWZpbmVQcm9wZXJ0eShNYXBib3gsIFwicHJvcFR5cGVzXCIsIHByb3BUeXBlcyk7XG5fZGVmaW5lUHJvcGVydHkoTWFwYm94LCBcImRlZmF1bHRQcm9wc1wiLCBkZWZhdWx0UHJvcHMpO1xuX2RlZmluZVByb3BlcnR5KE1hcGJveCwgXCJzYXZlZE1hcFwiLCBudWxsKTtcbmV4cG9ydCB7IE1hcGJveCBhcyBkZWZhdWx0IH07IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJ21hcGJveC1nbCc7IiwidmFyIEVQU0lMT04gPSAxZS03O1xuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FycmF5KGEpICYmIGlzQXJyYXkoYikpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKCFlcXVhbHMoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IEVQU0lMT047XG59XG5leHBvcnQgZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKGEsIGIsIHQpIHtcbiAgaWYgKGlzQXJyYXkoYSkpIHtcbiAgICByZXR1cm4gYS5tYXAoZnVuY3Rpb24gKGFpLCBpKSB7XG4gICAgICByZXR1cm4gbGVycChhaSwgYltpXSwgdCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHQgKiBiICsgKDEgLSB0KSAqIGE7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdyZWFjdC1tYXAtZ2w6IGFzc2VydGlvbiBmYWlsZWQuJyk7XG4gIH1cbn0iLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuaW1wb3J0IFdlYk1lcmNhdG9yVmlld3BvcnQsIHsgbm9ybWFsaXplVmlld3BvcnRQcm9wcyB9IGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QnO1xuaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuL21hdGgtdXRpbHMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuL2Fzc2VydCc7XG5leHBvcnQgdmFyIE1BUEJPWF9MSU1JVFMgPSB7XG4gIG1pblpvb206IDAsXG4gIG1heFpvb206IDI0LFxuICBtaW5QaXRjaDogMCxcbiAgbWF4UGl0Y2g6IDg1XG59O1xudmFyIERFRkFVTFRfU1RBVEUgPSB7XG4gIHBpdGNoOiAwLFxuICBiZWFyaW5nOiAwLFxuICBhbHRpdHVkZTogMS41XG59O1xudmFyIFBJVENIX01PVVNFX1RIUkVTSE9MRCA9IDU7XG52YXIgUElUQ0hfQUNDRUwgPSAxLjI7XG52YXIgTWFwU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hcFN0YXRlKF9yZWYpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICBsYXRpdHVkZSA9IF9yZWYubGF0aXR1ZGUsXG4gICAgICBsb25naXR1ZGUgPSBfcmVmLmxvbmdpdHVkZSxcbiAgICAgIHpvb20gPSBfcmVmLnpvb20sXG4gICAgICBfcmVmJGJlYXJpbmcgPSBfcmVmLmJlYXJpbmcsXG4gICAgICBiZWFyaW5nID0gX3JlZiRiZWFyaW5nID09PSB2b2lkIDAgPyBERUZBVUxUX1NUQVRFLmJlYXJpbmcgOiBfcmVmJGJlYXJpbmcsXG4gICAgICBfcmVmJHBpdGNoID0gX3JlZi5waXRjaCxcbiAgICAgIHBpdGNoID0gX3JlZiRwaXRjaCA9PT0gdm9pZCAwID8gREVGQVVMVF9TVEFURS5waXRjaCA6IF9yZWYkcGl0Y2gsXG4gICAgICBfcmVmJGFsdGl0dWRlID0gX3JlZi5hbHRpdHVkZSxcbiAgICAgIGFsdGl0dWRlID0gX3JlZiRhbHRpdHVkZSA9PT0gdm9pZCAwID8gREVGQVVMVF9TVEFURS5hbHRpdHVkZSA6IF9yZWYkYWx0aXR1ZGUsXG4gICAgICBfcmVmJG1heFpvb20gPSBfcmVmLm1heFpvb20sXG4gICAgICBtYXhab29tID0gX3JlZiRtYXhab29tID09PSB2b2lkIDAgPyBNQVBCT1hfTElNSVRTLm1heFpvb20gOiBfcmVmJG1heFpvb20sXG4gICAgICBfcmVmJG1pblpvb20gPSBfcmVmLm1pblpvb20sXG4gICAgICBtaW5ab29tID0gX3JlZiRtaW5ab29tID09PSB2b2lkIDAgPyBNQVBCT1hfTElNSVRTLm1pblpvb20gOiBfcmVmJG1pblpvb20sXG4gICAgICBfcmVmJG1heFBpdGNoID0gX3JlZi5tYXhQaXRjaCxcbiAgICAgIG1heFBpdGNoID0gX3JlZiRtYXhQaXRjaCA9PT0gdm9pZCAwID8gTUFQQk9YX0xJTUlUUy5tYXhQaXRjaCA6IF9yZWYkbWF4UGl0Y2gsXG4gICAgICBfcmVmJG1pblBpdGNoID0gX3JlZi5taW5QaXRjaCxcbiAgICAgIG1pblBpdGNoID0gX3JlZiRtaW5QaXRjaCA9PT0gdm9pZCAwID8gTUFQQk9YX0xJTUlUUy5taW5QaXRjaCA6IF9yZWYkbWluUGl0Y2gsXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSBfcmVmLnRyYW5zaXRpb25EdXJhdGlvbixcbiAgICAgIHRyYW5zaXRpb25FYXNpbmcgPSBfcmVmLnRyYW5zaXRpb25FYXNpbmcsXG4gICAgICB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yID0gX3JlZi50cmFuc2l0aW9uSW50ZXJwb2xhdG9yLFxuICAgICAgdHJhbnNpdGlvbkludGVycnVwdGlvbiA9IF9yZWYudHJhbnNpdGlvbkludGVycnVwdGlvbixcbiAgICAgIHN0YXJ0UGFuTG5nTGF0ID0gX3JlZi5zdGFydFBhbkxuZ0xhdCxcbiAgICAgIHN0YXJ0Wm9vbUxuZ0xhdCA9IF9yZWYuc3RhcnRab29tTG5nTGF0LFxuICAgICAgc3RhcnRSb3RhdGVQb3MgPSBfcmVmLnN0YXJ0Um90YXRlUG9zLFxuICAgICAgc3RhcnRCZWFyaW5nID0gX3JlZi5zdGFydEJlYXJpbmcsXG4gICAgICBzdGFydFBpdGNoID0gX3JlZi5zdGFydFBpdGNoLFxuICAgICAgc3RhcnRab29tID0gX3JlZi5zdGFydFpvb207XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcFN0YXRlKTtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHdpZHRoKSwgJ2B3aWR0aGAgbXVzdCBiZSBzdXBwbGllZCcpO1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoaGVpZ2h0KSwgJ2BoZWlnaHRgIG11c3QgYmUgc3VwcGxpZWQnKTtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGxvbmdpdHVkZSksICdgbG9uZ2l0dWRlYCBtdXN0IGJlIHN1cHBsaWVkJyk7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShsYXRpdHVkZSksICdgbGF0aXR1ZGVgIG11c3QgYmUgc3VwcGxpZWQnKTtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHpvb20pLCAnYHpvb21gIG11c3QgYmUgc3VwcGxpZWQnKTtcbiAgICB0aGlzLl92aWV3cG9ydFByb3BzID0gdGhpcy5fYXBwbHlDb25zdHJhaW50cyh7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIGxhdGl0dWRlOiBsYXRpdHVkZSxcbiAgICAgIGxvbmdpdHVkZTogbG9uZ2l0dWRlLFxuICAgICAgem9vbTogem9vbSxcbiAgICAgIGJlYXJpbmc6IGJlYXJpbmcsXG4gICAgICBwaXRjaDogcGl0Y2gsXG4gICAgICBhbHRpdHVkZTogYWx0aXR1ZGUsXG4gICAgICBtYXhab29tOiBtYXhab29tLFxuICAgICAgbWluWm9vbTogbWluWm9vbSxcbiAgICAgIG1heFBpdGNoOiBtYXhQaXRjaCxcbiAgICAgIG1pblBpdGNoOiBtaW5QaXRjaCxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogdHJhbnNpdGlvbkR1cmF0aW9uLFxuICAgICAgdHJhbnNpdGlvbkVhc2luZzogdHJhbnNpdGlvbkVhc2luZyxcbiAgICAgIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IHRyYW5zaXRpb25JbnRlcnBvbGF0b3IsXG4gICAgICB0cmFuc2l0aW9uSW50ZXJydXB0aW9uOiB0cmFuc2l0aW9uSW50ZXJydXB0aW9uXG4gICAgfSk7XG4gICAgdGhpcy5fc3RhdGUgPSB7XG4gICAgICBzdGFydFBhbkxuZ0xhdDogc3RhcnRQYW5MbmdMYXQsXG4gICAgICBzdGFydFpvb21MbmdMYXQ6IHN0YXJ0Wm9vbUxuZ0xhdCxcbiAgICAgIHN0YXJ0Um90YXRlUG9zOiBzdGFydFJvdGF0ZVBvcyxcbiAgICAgIHN0YXJ0QmVhcmluZzogc3RhcnRCZWFyaW5nLFxuICAgICAgc3RhcnRQaXRjaDogc3RhcnRQaXRjaCxcbiAgICAgIHN0YXJ0Wm9vbTogc3RhcnRab29tXG4gICAgfTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoTWFwU3RhdGUsIFt7XG4gICAga2V5OiBcImdldFZpZXdwb3J0UHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Vmlld3BvcnRQcm9wcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl92aWV3cG9ydFByb3BzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFuU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFuU3RhcnQoX3JlZjIpIHtcbiAgICAgIHZhciBwb3MgPSBfcmVmMi5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE1hcFN0YXRlKHtcbiAgICAgICAgc3RhcnRQYW5MbmdMYXQ6IHRoaXMuX3VucHJvamVjdChwb3MpXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhbihfcmVmMykge1xuICAgICAgdmFyIHBvcyA9IF9yZWYzLnBvcyxcbiAgICAgICAgc3RhcnRQb3MgPSBfcmVmMy5zdGFydFBvcztcbiAgICAgIHZhciBzdGFydFBhbkxuZ0xhdCA9IHRoaXMuX3N0YXRlLnN0YXJ0UGFuTG5nTGF0IHx8IHRoaXMuX3VucHJvamVjdChzdGFydFBvcyk7XG4gICAgICBpZiAoIXN0YXJ0UGFuTG5nTGF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIF90aGlzJF9jYWxjdWxhdGVOZXdMbiA9IHRoaXMuX2NhbGN1bGF0ZU5ld0xuZ0xhdCh7XG4gICAgICAgICAgc3RhcnRQYW5MbmdMYXQ6IHN0YXJ0UGFuTG5nTGF0LFxuICAgICAgICAgIHBvczogcG9zXG4gICAgICAgIH0pLFxuICAgICAgICBfdGhpcyRfY2FsY3VsYXRlTmV3TG4yID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2NhbGN1bGF0ZU5ld0xuLCAyKSxcbiAgICAgICAgbG9uZ2l0dWRlID0gX3RoaXMkX2NhbGN1bGF0ZU5ld0xuMlswXSxcbiAgICAgICAgbGF0aXR1ZGUgPSBfdGhpcyRfY2FsY3VsYXRlTmV3TG4yWzFdO1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZSh7XG4gICAgICAgIGxvbmdpdHVkZTogbG9uZ2l0dWRlLFxuICAgICAgICBsYXRpdHVkZTogbGF0aXR1ZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYW5FbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFuRW5kKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZSh7XG4gICAgICAgIHN0YXJ0UGFuTG5nTGF0OiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm90YXRlU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm90YXRlU3RhcnQoX3JlZjQpIHtcbiAgICAgIHZhciBwb3MgPSBfcmVmNC5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE1hcFN0YXRlKHtcbiAgICAgICAgc3RhcnRSb3RhdGVQb3M6IHBvcyxcbiAgICAgICAgc3RhcnRCZWFyaW5nOiB0aGlzLl92aWV3cG9ydFByb3BzLmJlYXJpbmcsXG4gICAgICAgIHN0YXJ0UGl0Y2g6IHRoaXMuX3ZpZXdwb3J0UHJvcHMucGl0Y2hcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm90YXRlKF9yZWY1KSB7XG4gICAgICB2YXIgcG9zID0gX3JlZjUucG9zLFxuICAgICAgICBfcmVmNSRkZWx0YUFuZ2xlWCA9IF9yZWY1LmRlbHRhQW5nbGVYLFxuICAgICAgICBkZWx0YUFuZ2xlWCA9IF9yZWY1JGRlbHRhQW5nbGVYID09PSB2b2lkIDAgPyAwIDogX3JlZjUkZGVsdGFBbmdsZVgsXG4gICAgICAgIF9yZWY1JGRlbHRhQW5nbGVZID0gX3JlZjUuZGVsdGFBbmdsZVksXG4gICAgICAgIGRlbHRhQW5nbGVZID0gX3JlZjUkZGVsdGFBbmdsZVkgPT09IHZvaWQgMCA/IDAgOiBfcmVmNSRkZWx0YUFuZ2xlWTtcbiAgICAgIHZhciBfdGhpcyRfc3RhdGUgPSB0aGlzLl9zdGF0ZSxcbiAgICAgICAgc3RhcnRSb3RhdGVQb3MgPSBfdGhpcyRfc3RhdGUuc3RhcnRSb3RhdGVQb3MsXG4gICAgICAgIHN0YXJ0QmVhcmluZyA9IF90aGlzJF9zdGF0ZS5zdGFydEJlYXJpbmcsXG4gICAgICAgIHN0YXJ0UGl0Y2ggPSBfdGhpcyRfc3RhdGUuc3RhcnRQaXRjaDtcbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHN0YXJ0QmVhcmluZykgfHwgIU51bWJlci5pc0Zpbml0ZShzdGFydFBpdGNoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdSb3RhdGlvbjtcbiAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgbmV3Um90YXRpb24gPSB0aGlzLl9jYWxjdWxhdGVOZXdQaXRjaEFuZEJlYXJpbmcoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLl9nZXRSb3RhdGlvblBhcmFtcyhwb3MsIHN0YXJ0Um90YXRlUG9zKSksIHt9LCB7XG4gICAgICAgICAgc3RhcnRCZWFyaW5nOiBzdGFydEJlYXJpbmcsXG4gICAgICAgICAgc3RhcnRQaXRjaDogc3RhcnRQaXRjaFxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdSb3RhdGlvbiA9IHtcbiAgICAgICAgICBiZWFyaW5nOiBzdGFydEJlYXJpbmcgKyBkZWx0YUFuZ2xlWCxcbiAgICAgICAgICBwaXRjaDogc3RhcnRQaXRjaCArIGRlbHRhQW5nbGVZXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE1hcFN0YXRlKG5ld1JvdGF0aW9uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm90YXRlRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdGF0ZUVuZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkTWFwU3RhdGUoe1xuICAgICAgICBzdGFydEJlYXJpbmc6IG51bGwsXG4gICAgICAgIHN0YXJ0UGl0Y2g6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ6b29tU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gem9vbVN0YXJ0KF9yZWY2KSB7XG4gICAgICB2YXIgcG9zID0gX3JlZjYucG9zO1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZSh7XG4gICAgICAgIHN0YXJ0Wm9vbUxuZ0xhdDogdGhpcy5fdW5wcm9qZWN0KHBvcyksXG4gICAgICAgIHN0YXJ0Wm9vbTogdGhpcy5fdmlld3BvcnRQcm9wcy56b29tXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiem9vbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB6b29tKF9yZWY3KSB7XG4gICAgICB2YXIgcG9zID0gX3JlZjcucG9zLFxuICAgICAgICBzdGFydFBvcyA9IF9yZWY3LnN0YXJ0UG9zLFxuICAgICAgICBzY2FsZSA9IF9yZWY3LnNjYWxlO1xuICAgICAgYXNzZXJ0KHNjYWxlID4gMCwgJ2BzY2FsZWAgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgdmFyIF90aGlzJF9zdGF0ZTIgPSB0aGlzLl9zdGF0ZSxcbiAgICAgICAgc3RhcnRab29tID0gX3RoaXMkX3N0YXRlMi5zdGFydFpvb20sXG4gICAgICAgIHN0YXJ0Wm9vbUxuZ0xhdCA9IF90aGlzJF9zdGF0ZTIuc3RhcnRab29tTG5nTGF0O1xuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoc3RhcnRab29tKSkge1xuICAgICAgICBzdGFydFpvb20gPSB0aGlzLl92aWV3cG9ydFByb3BzLnpvb207XG4gICAgICAgIHN0YXJ0Wm9vbUxuZ0xhdCA9IHRoaXMuX3VucHJvamVjdChzdGFydFBvcykgfHwgdGhpcy5fdW5wcm9qZWN0KHBvcyk7XG4gICAgICB9XG4gICAgICBhc3NlcnQoc3RhcnRab29tTG5nTGF0LCAnYHN0YXJ0Wm9vbUxuZ0xhdGAgcHJvcCBpcyByZXF1aXJlZCAnICsgJ2ZvciB6b29tIGJlaGF2aW9yIHRvIGNhbGN1bGF0ZSB3aGVyZSB0byBwb3NpdGlvbiB0aGUgbWFwLicpO1xuICAgICAgdmFyIHpvb20gPSB0aGlzLl9jYWxjdWxhdGVOZXdab29tKHtcbiAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICBzdGFydFpvb206IHN0YXJ0Wm9vbSB8fCAwXG4gICAgICB9KTtcbiAgICAgIHZhciB6b29tZWRWaWV3cG9ydCA9IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3ZpZXdwb3J0UHJvcHMsIHtcbiAgICAgICAgem9vbTogem9vbVxuICAgICAgfSkpO1xuICAgICAgdmFyIF96b29tZWRWaWV3cG9ydCRnZXRNYSA9IHpvb21lZFZpZXdwb3J0LmdldE1hcENlbnRlckJ5TG5nTGF0UG9zaXRpb24oe1xuICAgICAgICAgIGxuZ0xhdDogc3RhcnRab29tTG5nTGF0LFxuICAgICAgICAgIHBvczogcG9zXG4gICAgICAgIH0pLFxuICAgICAgICBfem9vbWVkVmlld3BvcnQkZ2V0TWEyID0gX3NsaWNlZFRvQXJyYXkoX3pvb21lZFZpZXdwb3J0JGdldE1hLCAyKSxcbiAgICAgICAgbG9uZ2l0dWRlID0gX3pvb21lZFZpZXdwb3J0JGdldE1hMlswXSxcbiAgICAgICAgbGF0aXR1ZGUgPSBfem9vbWVkVmlld3BvcnQkZ2V0TWEyWzFdO1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZSh7XG4gICAgICAgIHpvb206IHpvb20sXG4gICAgICAgIGxvbmdpdHVkZTogbG9uZ2l0dWRlLFxuICAgICAgICBsYXRpdHVkZTogbGF0aXR1ZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ6b29tRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHpvb21FbmQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE1hcFN0YXRlKHtcbiAgICAgICAgc3RhcnRab29tTG5nTGF0OiBudWxsLFxuICAgICAgICBzdGFydFpvb206IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0VXBkYXRlZE1hcFN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRVcGRhdGVkTWFwU3RhdGUobmV3UHJvcHMpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwU3RhdGUoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fdmlld3BvcnRQcm9wcywgdGhpcy5fc3RhdGUsIG5ld1Byb3BzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hcHBseUNvbnN0cmFpbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBseUNvbnN0cmFpbnRzKHByb3BzKSB7XG4gICAgICB2YXIgbWF4Wm9vbSA9IHByb3BzLm1heFpvb20sXG4gICAgICAgIG1pblpvb20gPSBwcm9wcy5taW5ab29tLFxuICAgICAgICB6b29tID0gcHJvcHMuem9vbTtcbiAgICAgIHByb3BzLnpvb20gPSBjbGFtcCh6b29tLCBtaW5ab29tLCBtYXhab29tKTtcbiAgICAgIHZhciBtYXhQaXRjaCA9IHByb3BzLm1heFBpdGNoLFxuICAgICAgICBtaW5QaXRjaCA9IHByb3BzLm1pblBpdGNoLFxuICAgICAgICBwaXRjaCA9IHByb3BzLnBpdGNoO1xuICAgICAgcHJvcHMucGl0Y2ggPSBjbGFtcChwaXRjaCwgbWluUGl0Y2gsIG1heFBpdGNoKTtcbiAgICAgIE9iamVjdC5hc3NpZ24ocHJvcHMsIG5vcm1hbGl6ZVZpZXdwb3J0UHJvcHMocHJvcHMpKTtcbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VucHJvamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5wcm9qZWN0KHBvcykge1xuICAgICAgdmFyIHZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQodGhpcy5fdmlld3BvcnRQcm9wcyk7XG4gICAgICByZXR1cm4gcG9zICYmIHZpZXdwb3J0LnVucHJvamVjdChwb3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2FsY3VsYXRlTmV3TG5nTGF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVOZXdMbmdMYXQoX3JlZjgpIHtcbiAgICAgIHZhciBzdGFydFBhbkxuZ0xhdCA9IF9yZWY4LnN0YXJ0UGFuTG5nTGF0LFxuICAgICAgICBwb3MgPSBfcmVmOC5wb3M7XG4gICAgICB2YXIgdmlld3BvcnQgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh0aGlzLl92aWV3cG9ydFByb3BzKTtcbiAgICAgIHJldHVybiB2aWV3cG9ydC5nZXRNYXBDZW50ZXJCeUxuZ0xhdFBvc2l0aW9uKHtcbiAgICAgICAgbG5nTGF0OiBzdGFydFBhbkxuZ0xhdCxcbiAgICAgICAgcG9zOiBwb3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2FsY3VsYXRlTmV3Wm9vbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlTmV3Wm9vbShfcmVmOSkge1xuICAgICAgdmFyIHNjYWxlID0gX3JlZjkuc2NhbGUsXG4gICAgICAgIHN0YXJ0Wm9vbSA9IF9yZWY5LnN0YXJ0Wm9vbTtcbiAgICAgIHZhciBfdGhpcyRfdmlld3BvcnRQcm9wcyA9IHRoaXMuX3ZpZXdwb3J0UHJvcHMsXG4gICAgICAgIG1heFpvb20gPSBfdGhpcyRfdmlld3BvcnRQcm9wcy5tYXhab29tLFxuICAgICAgICBtaW5ab29tID0gX3RoaXMkX3ZpZXdwb3J0UHJvcHMubWluWm9vbTtcbiAgICAgIHZhciB6b29tID0gc3RhcnRab29tICsgTWF0aC5sb2cyKHNjYWxlKTtcbiAgICAgIHJldHVybiBjbGFtcCh6b29tLCBtaW5ab29tLCBtYXhab29tKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZU5ld1BpdGNoQW5kQmVhcmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlTmV3UGl0Y2hBbmRCZWFyaW5nKF9yZWYxMCkge1xuICAgICAgdmFyIGRlbHRhU2NhbGVYID0gX3JlZjEwLmRlbHRhU2NhbGVYLFxuICAgICAgICBkZWx0YVNjYWxlWSA9IF9yZWYxMC5kZWx0YVNjYWxlWSxcbiAgICAgICAgc3RhcnRCZWFyaW5nID0gX3JlZjEwLnN0YXJ0QmVhcmluZyxcbiAgICAgICAgc3RhcnRQaXRjaCA9IF9yZWYxMC5zdGFydFBpdGNoO1xuICAgICAgZGVsdGFTY2FsZVkgPSBjbGFtcChkZWx0YVNjYWxlWSwgLTEsIDEpO1xuICAgICAgdmFyIF90aGlzJF92aWV3cG9ydFByb3BzMiA9IHRoaXMuX3ZpZXdwb3J0UHJvcHMsXG4gICAgICAgIG1pblBpdGNoID0gX3RoaXMkX3ZpZXdwb3J0UHJvcHMyLm1pblBpdGNoLFxuICAgICAgICBtYXhQaXRjaCA9IF90aGlzJF92aWV3cG9ydFByb3BzMi5tYXhQaXRjaDtcbiAgICAgIHZhciBiZWFyaW5nID0gc3RhcnRCZWFyaW5nICsgMTgwICogZGVsdGFTY2FsZVg7XG4gICAgICB2YXIgcGl0Y2ggPSBzdGFydFBpdGNoO1xuICAgICAgaWYgKGRlbHRhU2NhbGVZID4gMCkge1xuICAgICAgICBwaXRjaCA9IHN0YXJ0UGl0Y2ggKyBkZWx0YVNjYWxlWSAqIChtYXhQaXRjaCAtIHN0YXJ0UGl0Y2gpO1xuICAgICAgfSBlbHNlIGlmIChkZWx0YVNjYWxlWSA8IDApIHtcbiAgICAgICAgcGl0Y2ggPSBzdGFydFBpdGNoIC0gZGVsdGFTY2FsZVkgKiAobWluUGl0Y2ggLSBzdGFydFBpdGNoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBpdGNoOiBwaXRjaCxcbiAgICAgICAgYmVhcmluZzogYmVhcmluZ1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFJvdGF0aW9uUGFyYW1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRSb3RhdGlvblBhcmFtcyhwb3MsIHN0YXJ0UG9zKSB7XG4gICAgICB2YXIgZGVsdGFYID0gcG9zWzBdIC0gc3RhcnRQb3NbMF07XG4gICAgICB2YXIgZGVsdGFZID0gcG9zWzFdIC0gc3RhcnRQb3NbMV07XG4gICAgICB2YXIgY2VudGVyWSA9IHBvc1sxXTtcbiAgICAgIHZhciBzdGFydFkgPSBzdGFydFBvc1sxXTtcbiAgICAgIHZhciBfdGhpcyRfdmlld3BvcnRQcm9wczMgPSB0aGlzLl92aWV3cG9ydFByb3BzLFxuICAgICAgICB3aWR0aCA9IF90aGlzJF92aWV3cG9ydFByb3BzMy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkX3ZpZXdwb3J0UHJvcHMzLmhlaWdodDtcbiAgICAgIHZhciBkZWx0YVNjYWxlWCA9IGRlbHRhWCAvIHdpZHRoO1xuICAgICAgdmFyIGRlbHRhU2NhbGVZID0gMDtcbiAgICAgIGlmIChkZWx0YVkgPiAwKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhoZWlnaHQgLSBzdGFydFkpID4gUElUQ0hfTU9VU0VfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgZGVsdGFTY2FsZVkgPSBkZWx0YVkgLyAoc3RhcnRZIC0gaGVpZ2h0KSAqIFBJVENIX0FDQ0VMO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRlbHRhWSA8IDApIHtcbiAgICAgICAgaWYgKHN0YXJ0WSA+IFBJVENIX01PVVNFX1RIUkVTSE9MRCkge1xuICAgICAgICAgIGRlbHRhU2NhbGVZID0gMSAtIGNlbnRlclkgLyBzdGFydFk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlbHRhU2NhbGVZID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoLTEsIGRlbHRhU2NhbGVZKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZWx0YVNjYWxlWDogZGVsdGFTY2FsZVgsXG4gICAgICAgIGRlbHRhU2NhbGVZOiBkZWx0YVNjYWxlWVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE1hcFN0YXRlO1xufSgpO1xuZXhwb3J0IHsgTWFwU3RhdGUgYXMgZGVmYXVsdCB9OyIsImltcG9ydCB7IE1BUEJPWF9MSU1JVFMgfSBmcm9tICcuL21hcC1zdGF0ZSc7XG5mdW5jdGlvbiBkZWNhcGl0YWxpemUocykge1xuICByZXR1cm4gc1swXS50b0xvd2VyQ2FzZSgpICsgcy5zbGljZSgxKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1Zpc2liaWxpdHlDb25zdHJhaW50cyhwcm9wcykge1xuICB2YXIgY29uc3RyYWludHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IE1BUEJPWF9MSU1JVFM7XG4gIGZvciAodmFyIGNvbnN0cmFpbnROYW1lIGluIGNvbnN0cmFpbnRzKSB7XG4gICAgdmFyIHR5cGUgPSBjb25zdHJhaW50TmFtZS5zbGljZSgwLCAzKTtcbiAgICB2YXIgcHJvcE5hbWUgPSBkZWNhcGl0YWxpemUoY29uc3RyYWludE5hbWUuc2xpY2UoMykpO1xuICAgIGlmICh0eXBlID09PSAnbWluJyAmJiBwcm9wc1twcm9wTmFtZV0gPCBjb25zdHJhaW50c1tjb25zdHJhaW50TmFtZV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdtYXgnICYmIHByb3BzW3Byb3BOYW1lXSA+IGNvbnN0cmFpbnRzW2NvbnN0cmFpbnROYW1lXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0iLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xudmFyIE1hcENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHtcbiAgdmlld3BvcnQ6IG51bGwsXG4gIG1hcDogbnVsbCxcbiAgY29udGFpbmVyOiBudWxsLFxuICBvblZpZXdwb3J0Q2hhbmdlOiBudWxsLFxuICBvblZpZXdTdGF0ZUNoYW5nZTogbnVsbCxcbiAgZXZlbnRNYW5hZ2VyOiBudWxsXG59KTtcbmV4cG9ydCB2YXIgTWFwQ29udGV4dFByb3ZpZGVyID0gTWFwQ29udGV4dC5Qcm92aWRlcjtcbmZ1bmN0aW9uIFdyYXBwZWRQcm92aWRlcihfcmVmKSB7XG4gIHZhciB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUobnVsbCksXG4gICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgbWFwID0gX3VzZVN0YXRlMlswXSxcbiAgICBzZXRNYXAgPSBfdXNlU3RhdGUyWzFdO1xuICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gIHZhbHVlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICBzZXRNYXA6IHNldE1hcFxuICB9LCBjb250ZXh0KSwge30sIHtcbiAgICBtYXA6IGNvbnRleHQgJiYgY29udGV4dC5tYXAgfHwgbWFwXG4gIH0sIHZhbHVlKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFwQ29udGV4dFByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHZhbHVlXG4gIH0sIGNoaWxkcmVuKTtcbn1cbk1hcENvbnRleHQuUHJvdmlkZXIgPSBXcmFwcGVkUHJvdmlkZXI7XG5leHBvcnQgZGVmYXVsdCBNYXBDb250ZXh0OyIsImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcbmV4cG9ydCBkZWZhdWx0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3Q7IiwiZXhwb3J0IGZ1bmN0aW9uIGdldFRlcnJhaW5FbGV2YXRpb24obWFwLCBfcmVmKSB7XG4gIHZhciBsb25naXR1ZGUgPSBfcmVmLmxvbmdpdHVkZSxcbiAgICBsYXRpdHVkZSA9IF9yZWYubGF0aXR1ZGU7XG4gIGlmIChtYXAgJiYgbWFwLnF1ZXJ5VGVycmFpbkVsZXZhdGlvbikge1xuICAgIHJldHVybiBtYXAucXVlcnlUZXJyYWluRWxldmF0aW9uKFtsb25naXR1ZGUsIGxhdGl0dWRlXSkgfHwgMDtcbiAgfVxuICByZXR1cm4gMDtcbn0iLCJpbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VJbXBlcmF0aXZlSGFuZGxlLCBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFdlYk1lcmNhdG9yVmlld3BvcnQgZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5pbXBvcnQgUmVzaXplT2JzZXJ2ZXIgZnJvbSAncmVzaXplLW9ic2VydmVyLXBvbHlmaWxsJztcbmltcG9ydCBNYXBib3ggZnJvbSAnLi4vbWFwYm94L21hcGJveCc7XG5pbXBvcnQgbWFwYm94Z2wgZnJvbSAnLi4vdXRpbHMvbWFwYm94Z2wnO1xuaW1wb3J0IHsgY2hlY2tWaXNpYmlsaXR5Q29uc3RyYWludHMgfSBmcm9tICcuLi91dGlscy9tYXAtY29uc3RyYWludHMnO1xuaW1wb3J0IHsgTUFQQk9YX0xJTUlUUyB9IGZyb20gJy4uL3V0aWxzL21hcC1zdGF0ZSc7XG5pbXBvcnQgTWFwQ29udGV4dCwgeyBNYXBDb250ZXh0UHJvdmlkZXIgfSBmcm9tICcuL21hcC1jb250ZXh0JztcbmltcG9ydCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IGZyb20gJy4uL3V0aWxzL3VzZS1pc29tb3JwaGljLWxheW91dC1lZmZlY3QnO1xuaW1wb3J0IHsgZ2V0VGVycmFpbkVsZXZhdGlvbiB9IGZyb20gJy4uL3V0aWxzL3RlcnJhaW4nO1xudmFyIFRPS0VOX0RPQ19VUkwgPSAnaHR0cHM6Ly92aXNnbC5naXRodWIuaW8vcmVhY3QtbWFwLWdsL2RvY3MvZ2V0LXN0YXJ0ZWQvbWFwYm94LXRva2Vucyc7XG52YXIgTk9fVE9LRU5fV0FSTklORyA9ICdBIHZhbGlkIEFQSSBhY2Nlc3MgdG9rZW4gaXMgcmVxdWlyZWQgdG8gdXNlIE1hcGJveCBkYXRhJztcbmZ1bmN0aW9uIG5vb3AoKSB7fVxuZXhwb3J0IGZ1bmN0aW9uIGdldFZpZXdwb3J0KF9yZWYpIHtcbiAgdmFyIG1hcCA9IF9yZWYubWFwLFxuICAgIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG4gIHZhciB2aWV3cG9ydFByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwgcHJvcHMudmlld1N0YXRlKSwge30sIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfSk7XG4gIHZpZXdwb3J0UHJvcHMucG9zaXRpb24gPSBbMCwgMCwgZ2V0VGVycmFpbkVsZXZhdGlvbihtYXAsIHZpZXdwb3J0UHJvcHMpXTtcbiAgcmV0dXJuIG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHZpZXdwb3J0UHJvcHMpO1xufVxudmFyIFVOQVVUSE9SSVpFRF9FUlJPUl9DT0RFID0gNDAxO1xudmFyIENPTlRBSU5FUl9TVFlMRSA9IHtcbiAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gIHdpZHRoOiAnMTAwJScsXG4gIGhlaWdodDogJzEwMCUnLFxuICBvdmVyZmxvdzogJ2hpZGRlbidcbn07XG52YXIgZGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgTWFwYm94LmRlZmF1bHRQcm9wcywge1xuICBkaXNhYmxlVG9rZW5XYXJuaW5nOiBmYWxzZSxcbiAgdmlzaWJsZTogdHJ1ZSxcbiAgb25SZXNpemU6IG5vb3AsXG4gIGNsYXNzTmFtZTogJycsXG4gIHN0eWxlOiBudWxsLFxuICB2aXNpYmlsaXR5Q29uc3RyYWludHM6IE1BUEJPWF9MSU1JVFNcbn0pO1xuZnVuY3Rpb24gTm9Ub2tlbldhcm5pbmcoKSB7XG4gIHZhciBzdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMFxuICB9O1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAga2V5OiBcIndhcm5pbmdcIixcbiAgICBpZDogXCJuby10b2tlbi13YXJuaW5nXCIsXG4gICAgc3R5bGU6IHN0eWxlXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoM1wiLCB7XG4gICAga2V5OiBcImhlYWRlclwiXG4gIH0sIE5PX1RPS0VOX1dBUk5JTkcpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IFwidGV4dFwiXG4gIH0sIFwiRm9yIGluZm9ybWF0aW9uIG9uIHNldHRpbmcgdXAgeW91ciBiYXNlbWFwLCByZWFkXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7XG4gICAga2V5OiBcImxpbmtcIixcbiAgICBocmVmOiBUT0tFTl9ET0NfVVJMXG4gIH0sIFwiTm90ZSBvbiBNYXAgVG9rZW5zXCIpKTtcbn1cbmZ1bmN0aW9uIGdldFJlZkhhbmRsZXMobWFwYm94UmVmKSB7XG4gIHJldHVybiB7XG4gICAgZ2V0TWFwOiBmdW5jdGlvbiBnZXRNYXAoKSB7XG4gICAgICByZXR1cm4gbWFwYm94UmVmLmN1cnJlbnQgJiYgbWFwYm94UmVmLmN1cnJlbnQuZ2V0TWFwKCk7XG4gICAgfSxcbiAgICBxdWVyeVJlbmRlcmVkRmVhdHVyZXM6IGZ1bmN0aW9uIHF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhnZW9tZXRyeSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIG1hcCA9IG1hcGJveFJlZi5jdXJyZW50ICYmIG1hcGJveFJlZi5jdXJyZW50LmdldE1hcCgpO1xuICAgICAgcmV0dXJuIG1hcCAmJiBtYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKGdlb21ldHJ5LCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG59XG52YXIgU3RhdGljTWFwID0gZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUodHJ1ZSksXG4gICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgYWNjZXNzVG9rZW5WYWxpZCA9IF91c2VTdGF0ZTJbMF0sXG4gICAgc2V0VG9rZW5TdGF0ZSA9IF91c2VTdGF0ZTJbMV07XG4gIHZhciBfdXNlU3RhdGUzID0gdXNlU3RhdGUoe1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9KSxcbiAgICBfdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMywgMiksXG4gICAgc2l6ZSA9IF91c2VTdGF0ZTRbMF0sXG4gICAgc2V0U2l6ZSA9IF91c2VTdGF0ZTRbMV07XG4gIHZhciBtYXBib3hSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBtYXBEaXZSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBjb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBvdmVybGF5UmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghU3RhdGljTWFwLnN1cHBvcnRlZCgpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgbWFwYm94ID0gbmV3IE1hcGJveChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCBzaXplKSwge30sIHtcbiAgICAgIG1hcGJveGdsOiBtYXBib3hnbCxcbiAgICAgIGNvbnRhaW5lcjogbWFwRGl2UmVmLmN1cnJlbnQsXG4gICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKGV2dCkge1xuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IGV2dC5lcnJvciAmJiBldnQuZXJyb3Iuc3RhdHVzIHx8IGV2dC5zdGF0dXM7XG4gICAgICAgIGlmIChzdGF0dXNDb2RlID09PSBVTkFVVEhPUklaRURfRVJST1JfQ09ERSAmJiBhY2Nlc3NUb2tlblZhbGlkKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihOT19UT0tFTl9XQVJOSU5HKTtcbiAgICAgICAgICBzZXRUb2tlblN0YXRlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wcy5vbkVycm9yKGV2dCk7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIG1hcGJveFJlZi5jdXJyZW50ID0gbWFwYm94O1xuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuc2V0TWFwKSB7XG4gICAgICBjb250ZXh0LnNldE1hcChtYXBib3guZ2V0TWFwKCkpO1xuICAgIH1cbiAgICB2YXIgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgIGlmIChlbnRyaWVzWzBdLmNvbnRlbnRSZWN0KSB7XG4gICAgICAgIHZhciBfZW50cmllcyQwJGNvbnRlbnRSZWMgPSBlbnRyaWVzWzBdLmNvbnRlbnRSZWN0LFxuICAgICAgICAgIF93aWR0aCA9IF9lbnRyaWVzJDAkY29udGVudFJlYy53aWR0aCxcbiAgICAgICAgICBfaGVpZ2h0ID0gX2VudHJpZXMkMCRjb250ZW50UmVjLmhlaWdodDtcbiAgICAgICAgc2V0U2l6ZSh7XG4gICAgICAgICAgd2lkdGg6IF93aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IF9oZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIHByb3BzLm9uUmVzaXplKHtcbiAgICAgICAgICB3aWR0aDogX3dpZHRoLFxuICAgICAgICAgIGhlaWdodDogX2hlaWdodFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lclJlZi5jdXJyZW50KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgbWFwYm94LmZpbmFsaXplKCk7XG4gICAgICBtYXBib3hSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfTtcbiAgfSwgW10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobWFwYm94UmVmLmN1cnJlbnQpIHtcbiAgICAgIG1hcGJveFJlZi5jdXJyZW50LnNldFByb3BzKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCBzaXplKSk7XG4gICAgfVxuICB9KTtcbiAgdmFyIG1hcCA9IG1hcGJveFJlZi5jdXJyZW50ICYmIG1hcGJveFJlZi5jdXJyZW50LmdldE1hcCgpO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRSZWZIYW5kbGVzKG1hcGJveFJlZik7XG4gIH0sIFtdKTtcbiAgdmFyIHByZXZlbnRTY3JvbGwgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgdGFyZ2V0ID0gX3JlZjIudGFyZ2V0O1xuICAgIGlmICh0YXJnZXQgPT09IG92ZXJsYXlSZWYuY3VycmVudCkge1xuICAgICAgdGFyZ2V0LnNjcm9sbFRvKDAsIDApO1xuICAgIH1cbiAgfSwgW10pO1xuICB2YXIgb3ZlcmxheXMgPSBtYXAgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChNYXBDb250ZXh0UHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjb250ZXh0KSwge30sIHtcbiAgICAgIHZpZXdwb3J0OiBjb250ZXh0LnZpZXdwb3J0IHx8IGdldFZpZXdwb3J0KF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBtYXA6IG1hcCxcbiAgICAgICAgcHJvcHM6IHByb3BzXG4gICAgICB9LCBzaXplKSksXG4gICAgICBtYXA6IG1hcCxcbiAgICAgIGNvbnRhaW5lcjogY29udGV4dC5jb250YWluZXIgfHwgY29udGFpbmVyUmVmLmN1cnJlbnRcbiAgICB9KVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IFwibWFwLW92ZXJsYXlzXCIsXG4gICAgY2xhc3NOYW1lOiBcIm92ZXJsYXlzXCIsXG4gICAgcmVmOiBvdmVybGF5UmVmLFxuICAgIHN0eWxlOiBDT05UQUlORVJfU1RZTEUsXG4gICAgb25TY3JvbGw6IHByZXZlbnRTY3JvbGxcbiAgfSwgcHJvcHMuY2hpbGRyZW4pKTtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICB3aWR0aCA9IHByb3BzLndpZHRoLFxuICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCxcbiAgICBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgIHZpc2liaWxpdHlDb25zdHJhaW50cyA9IHByb3BzLnZpc2liaWxpdHlDb25zdHJhaW50cztcbiAgdmFyIG1hcENvbnRhaW5lclN0eWxlID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgfSwgc3R5bGUsIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfSk7XG4gIHZhciB2aXNpYmxlID0gcHJvcHMudmlzaWJsZSAmJiBjaGVja1Zpc2liaWxpdHlDb25zdHJhaW50cyhwcm9wcy52aWV3U3RhdGUgfHwgcHJvcHMsIHZpc2liaWxpdHlDb25zdHJhaW50cyk7XG4gIHZhciBtYXBTdHlsZSA9IE9iamVjdC5hc3NpZ24oe30sIENPTlRBSU5FUl9TVFlMRSwge1xuICAgIHZpc2liaWxpdHk6IHZpc2libGUgPyAnaW5oZXJpdCcgOiAnaGlkZGVuJ1xuICB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGtleTogXCJtYXAtY29udGFpbmVyXCIsXG4gICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgc3R5bGU6IG1hcENvbnRhaW5lclN0eWxlXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGtleTogXCJtYXAtbWFwYm94XCIsXG4gICAgcmVmOiBtYXBEaXZSZWYsXG4gICAgc3R5bGU6IG1hcFN0eWxlLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gIH0pLCBvdmVybGF5cywgIWFjY2Vzc1Rva2VuVmFsaWQgJiYgIXByb3BzLmRpc2FibGVUb2tlbldhcm5pbmcgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChOb1Rva2VuV2FybmluZywgbnVsbCkpO1xufSk7XG5TdGF0aWNNYXAuc3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbWFwYm94Z2wgJiYgbWFwYm94Z2wuc3VwcG9ydGVkKCk7XG59O1xuU3RhdGljTWFwLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbmV4cG9ydCBkZWZhdWx0IFN0YXRpY01hcDsiLCJpbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQ7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHM6IEYsXG4gICAgICAgIG46IGZ1bmN0aW9uIG4oKSB7XG4gICAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZTogZnVuY3Rpb24gZShfZSkge1xuICAgICAgICAgIHRocm93IF9lO1xuICAgICAgICB9LFxuICAgICAgICBmOiBGXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cbiAgdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLFxuICAgIGRpZEVyciA9IGZhbHNlLFxuICAgIGVycjtcbiAgcmV0dXJuIHtcbiAgICBzOiBmdW5jdGlvbiBzKCkge1xuICAgICAgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9LFxuICAgIG46IGZ1bmN0aW9uIG4oKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0Lm5leHQoKTtcbiAgICAgIG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7XG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uIGUoX2UyKSB7XG4gICAgICBkaWRFcnIgPSB0cnVlO1xuICAgICAgZXJyID0gX2UyO1xuICAgIH0sXG4gICAgZjogZnVuY3Rpb24gZigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGRpZEVycikgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG4gIHJldHVybiBhcnIyO1xufVxuaW1wb3J0IHsgZXF1YWxzIH0gZnJvbSAnLi4vbWF0aC11dGlscyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uL2Fzc2VydCc7XG52YXIgVHJhbnNpdGlvbkludGVycG9sYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHJhbnNpdGlvbkludGVycG9sYXRvcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNpdGlvbkludGVycG9sYXRvcik7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvcE5hbWVzXCIsIFtdKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoVHJhbnNpdGlvbkludGVycG9sYXRvciwgW3tcbiAgICBrZXk6IFwiYXJlUHJvcHNFcXVhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcmVQcm9wc0VxdWFsKGN1cnJlbnRQcm9wcywgbmV4dFByb3BzKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5wcm9wTmFtZXMgfHwgW10pLFxuICAgICAgICBfc3RlcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGlmICghZXF1YWxzKGN1cnJlbnRQcm9wc1trZXldLCBuZXh0UHJvcHNba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0aWFsaXplUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZVByb3BzKHN0YXJ0UHJvcHMsIGVuZFByb3BzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogc3RhcnRQcm9wcyxcbiAgICAgICAgZW5kOiBlbmRQcm9wc1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJwb2xhdGVQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnBvbGF0ZVByb3BzKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCB0KSB7XG4gICAgICBhc3NlcnQoZmFsc2UsICdpbnRlcnBvbGF0ZVByb3BzIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREdXJhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREdXJhdGlvbihzdGFydFByb3BzLCBlbmRQcm9wcykge1xuICAgICAgcmV0dXJuIGVuZFByb3BzLnRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRyYW5zaXRpb25JbnRlcnBvbGF0b3I7XG59KCk7XG5leHBvcnQgeyBUcmFuc2l0aW9uSW50ZXJwb2xhdG9yIGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKGUpIHtcbiAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICByZXR1cm4gZTtcbn1cbmV4cG9ydCB7IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBzZXRQcm90b3R5cGVPZiBmcm9tIFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiO1xuZnVuY3Rpb24gX2luaGVyaXRzKHQsIGUpIHtcbiAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiB0LFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgIH1cbiAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6ICExXG4gIH0pLCBlICYmIHNldFByb3RvdHlwZU9mKHQsIGUpO1xufVxuZXhwb3J0IHsgX2luaGVyaXRzIGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgX3R5cGVvZiBmcm9tIFwiLi90eXBlb2YuanNcIjtcbmltcG9ydCBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgZnJvbSBcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzXCI7XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBlKSB7XG4gIGlmIChlICYmIChcIm9iamVjdFwiID09IF90eXBlb2YoZSkgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7XG4gIGlmICh2b2lkIDAgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZCh0KTtcbn1cbmV4cG9ydCB7IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YodCkge1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KTtcbiAgfSwgX2dldFByb3RvdHlwZU9mKHQpO1xufVxuZXhwb3J0IHsgX2dldFByb3RvdHlwZU9mIGFzIGRlZmF1bHQgfTsiLCJ2YXIgV1JBUFBFRF9BTkdVTEFSX1BST1BTID0ge1xuICBsb25naXR1ZGU6IDEsXG4gIGJlYXJpbmc6IDFcbn07XG5leHBvcnQgZnVuY3Rpb24gbW9kKHZhbHVlLCBkaXZpc29yKSB7XG4gIHZhciBtb2R1bHVzID0gdmFsdWUgJSBkaXZpc29yO1xuICByZXR1cm4gbW9kdWx1cyA8IDAgPyBkaXZpc29yICsgbW9kdWx1cyA6IG1vZHVsdXM7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZChwcm9wKSB7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUocHJvcCkgfHwgQXJyYXkuaXNBcnJheShwcm9wKTtcbn1cbmZ1bmN0aW9uIGlzV3JhcHBlZEFuZ3VsYXJQcm9wKHByb3BOYW1lKSB7XG4gIHJldHVybiBwcm9wTmFtZSBpbiBXUkFQUEVEX0FOR1VMQVJfUFJPUFM7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RW5kVmFsdWVCeVNob3J0ZXN0UGF0aChwcm9wTmFtZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpIHtcbiAgaWYgKGlzV3JhcHBlZEFuZ3VsYXJQcm9wKHByb3BOYW1lKSAmJiBNYXRoLmFicyhlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpID4gMTgwKSB7XG4gICAgZW5kVmFsdWUgPSBlbmRWYWx1ZSA8IDAgPyBlbmRWYWx1ZSArIDM2MCA6IGVuZFZhbHVlIC0gMzYwO1xuICB9XG4gIHJldHVybiBlbmRWYWx1ZTtcbn0iLCJpbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIjtcbmltcG9ydCBfaW5oZXJpdHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzXCI7XG5pbXBvcnQgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjtcbmltcG9ydCBfZ2V0UHJvdG90eXBlT2YgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0O1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChpdCkgbyA9IGl0O1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzOiBGLFxuICAgICAgICBuOiBmdW5jdGlvbiBuKCkge1xuICAgICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGU6IGZ1bmN0aW9uIGUoX2UpIHtcbiAgICAgICAgICB0aHJvdyBfZTtcbiAgICAgICAgfSxcbiAgICAgICAgZjogRlxuICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG4gIHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSxcbiAgICBkaWRFcnIgPSBmYWxzZSxcbiAgICBlcnI7XG4gIHJldHVybiB7XG4gICAgczogZnVuY3Rpb24gcygpIHtcbiAgICAgIGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfSxcbiAgICBuOiBmdW5jdGlvbiBuKCkge1xuICAgICAgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7XG4gICAgICBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lO1xuICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfSxcbiAgICBlOiBmdW5jdGlvbiBlKF9lMikge1xuICAgICAgZGlkRXJyID0gdHJ1ZTtcbiAgICAgIGVyciA9IF9lMjtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uIGYoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChkaWRFcnIpIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuICByZXR1cm4gYXJyMjtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgcmVzdWx0O1xuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuaW1wb3J0IGFzc2VydCBmcm9tICcuLi9hc3NlcnQnO1xuaW1wb3J0IFRyYW5zaXRpb25JbnRlcnBvbGF0b3IgZnJvbSAnLi90cmFuc2l0aW9uLWludGVycG9sYXRvcic7XG5pbXBvcnQgeyBmbHlUb1ZpZXdwb3J0LCBnZXRGbHlUb0R1cmF0aW9uIH0gZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5pbXBvcnQgeyBpc1ZhbGlkLCBnZXRFbmRWYWx1ZUJ5U2hvcnRlc3RQYXRoIH0gZnJvbSAnLi90cmFuc2l0aW9uLXV0aWxzJztcbmltcG9ydCB7IGxlcnAgfSBmcm9tICcuLi9tYXRoLXV0aWxzJztcbnZhciBWSUVXUE9SVF9UUkFOU0lUSU9OX1BST1BTID0gWydsb25naXR1ZGUnLCAnbGF0aXR1ZGUnLCAnem9vbScsICdiZWFyaW5nJywgJ3BpdGNoJ107XG52YXIgUkVRVUlSRURfUFJPUFMgPSBbJ2xhdGl0dWRlJywgJ2xvbmdpdHVkZScsICd6b29tJywgJ3dpZHRoJywgJ2hlaWdodCddO1xudmFyIExJTkVBUkxZX0lOVEVSUE9MQVRFRF9QUk9QUyA9IFsnYmVhcmluZycsICdwaXRjaCddO1xudmFyIERFRkFVTFRfT1BUUyA9IHtcbiAgc3BlZWQ6IDEuMixcbiAgY3VydmU6IDEuNDE0XG59O1xudmFyIFZpZXdwb3J0Rmx5VG9JbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiAoX1RyYW5zaXRpb25JbnRlcnBvbGF0KSB7XG4gIF9pbmhlcml0cyhWaWV3cG9ydEZseVRvSW50ZXJwb2xhdG9yLCBfVHJhbnNpdGlvbkludGVycG9sYXQpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFZpZXdwb3J0Rmx5VG9JbnRlcnBvbGF0b3IpO1xuICBmdW5jdGlvbiBWaWV3cG9ydEZseVRvSW50ZXJwb2xhdG9yKCkge1xuICAgIHZhciBfdGhpcztcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWV3cG9ydEZseVRvSW50ZXJwb2xhdG9yKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJwcm9wTmFtZXNcIiwgVklFV1BPUlRfVFJBTlNJVElPTl9QUk9QUyk7XG4gICAgX3RoaXMucHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVFMsIHByb3BzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFZpZXdwb3J0Rmx5VG9JbnRlcnBvbGF0b3IsIFt7XG4gICAga2V5OiBcImluaXRpYWxpemVQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplUHJvcHMoc3RhcnRQcm9wcywgZW5kUHJvcHMpIHtcbiAgICAgIHZhciBzdGFydFZpZXdwb3J0UHJvcHMgPSB7fTtcbiAgICAgIHZhciBlbmRWaWV3cG9ydFByb3BzID0ge307XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoUkVRVUlSRURfUFJPUFMpLFxuICAgICAgICBfc3RlcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBzdGFydFZhbHVlID0gc3RhcnRQcm9wc1trZXldO1xuICAgICAgICAgIHZhciBlbmRWYWx1ZSA9IGVuZFByb3BzW2tleV07XG4gICAgICAgICAgYXNzZXJ0KGlzVmFsaWQoc3RhcnRWYWx1ZSkgJiYgaXNWYWxpZChlbmRWYWx1ZSksIFwiXCIuY29uY2F0KGtleSwgXCIgbXVzdCBiZSBzdXBwbGllZCBmb3IgdHJhbnNpdGlvblwiKSk7XG4gICAgICAgICAgc3RhcnRWaWV3cG9ydFByb3BzW2tleV0gPSBzdGFydFZhbHVlO1xuICAgICAgICAgIGVuZFZpZXdwb3J0UHJvcHNba2V5XSA9IGdldEVuZFZhbHVlQnlTaG9ydGVzdFBhdGgoa2V5LCBzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoTElORUFSTFlfSU5URVJQT0xBVEVEX1BST1BTKSxcbiAgICAgICAgX3N0ZXAyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX2tleSA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICB2YXIgX3N0YXJ0VmFsdWUgPSBzdGFydFByb3BzW19rZXldIHx8IDA7XG4gICAgICAgICAgdmFyIF9lbmRWYWx1ZSA9IGVuZFByb3BzW19rZXldIHx8IDA7XG4gICAgICAgICAgc3RhcnRWaWV3cG9ydFByb3BzW19rZXldID0gX3N0YXJ0VmFsdWU7XG4gICAgICAgICAgZW5kVmlld3BvcnRQcm9wc1tfa2V5XSA9IGdldEVuZFZhbHVlQnlTaG9ydGVzdFBhdGgoX2tleSwgX3N0YXJ0VmFsdWUsIF9lbmRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0Vmlld3BvcnRQcm9wcyxcbiAgICAgICAgZW5kOiBlbmRWaWV3cG9ydFByb3BzXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnBvbGF0ZVByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVycG9sYXRlUHJvcHMoc3RhcnRQcm9wcywgZW5kUHJvcHMsIHQpIHtcbiAgICAgIHZhciB2aWV3cG9ydCA9IGZseVRvVmlld3BvcnQoc3RhcnRQcm9wcywgZW5kUHJvcHMsIHQsIHRoaXMucHJvcHMpO1xuICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihMSU5FQVJMWV9JTlRFUlBPTEFURURfUFJPUFMpLFxuICAgICAgICBfc3RlcDM7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgdmlld3BvcnRba2V5XSA9IGxlcnAoc3RhcnRQcm9wc1trZXldLCBlbmRQcm9wc1trZXldLCB0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmlld3BvcnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldER1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldER1cmF0aW9uKHN0YXJ0UHJvcHMsIGVuZFByb3BzKSB7XG4gICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gZW5kUHJvcHMudHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgICAgaWYgKHRyYW5zaXRpb25EdXJhdGlvbiA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IGdldEZseVRvRHVyYXRpb24oc3RhcnRQcm9wcywgZW5kUHJvcHMsIHRoaXMucHJvcHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFZpZXdwb3J0Rmx5VG9JbnRlcnBvbGF0b3I7XG59KFRyYW5zaXRpb25JbnRlcnBvbGF0b3IpO1xuZXhwb3J0IHsgVmlld3BvcnRGbHlUb0ludGVycG9sYXRvciBhcyBkZWZhdWx0IH07IiwiaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCBfaW5oZXJpdHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzXCI7XG5pbXBvcnQgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjtcbmltcG9ydCBfZ2V0UHJvdG90eXBlT2YgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mXCI7XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQ7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHM6IEYsXG4gICAgICAgIG46IGZ1bmN0aW9uIG4oKSB7XG4gICAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZTogZnVuY3Rpb24gZShfZSkge1xuICAgICAgICAgIHRocm93IF9lO1xuICAgICAgICB9LFxuICAgICAgICBmOiBGXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cbiAgdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLFxuICAgIGRpZEVyciA9IGZhbHNlLFxuICAgIGVycjtcbiAgcmV0dXJuIHtcbiAgICBzOiBmdW5jdGlvbiBzKCkge1xuICAgICAgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9LFxuICAgIG46IGZ1bmN0aW9uIG4oKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0Lm5leHQoKTtcbiAgICAgIG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7XG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uIGUoX2UyKSB7XG4gICAgICBkaWRFcnIgPSB0cnVlO1xuICAgICAgZXJyID0gX2UyO1xuICAgIH0sXG4gICAgZjogZnVuY3Rpb24gZigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGRpZEVycikgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG4gIHJldHVybiBhcnIyO1xufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICByZXN1bHQ7XG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5pbXBvcnQgV2ViTWVyY2F0b3JWaWV3cG9ydCBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi4vYXNzZXJ0JztcbmltcG9ydCBUcmFuc2l0aW9uSW50ZXJwb2xhdG9yIGZyb20gJy4vdHJhbnNpdGlvbi1pbnRlcnBvbGF0b3InO1xuaW1wb3J0IHsgaXNWYWxpZCwgZ2V0RW5kVmFsdWVCeVNob3J0ZXN0UGF0aCB9IGZyb20gJy4vdHJhbnNpdGlvbi11dGlscyc7XG5pbXBvcnQgeyBsZXJwIH0gZnJvbSAnLi4vbWF0aC11dGlscyc7XG52YXIgVklFV1BPUlRfVFJBTlNJVElPTl9QUk9QUyA9IFsnbG9uZ2l0dWRlJywgJ2xhdGl0dWRlJywgJ3pvb20nLCAnYmVhcmluZycsICdwaXRjaCddO1xudmFyIExpbmVhckludGVycG9sYXRvciA9IGZ1bmN0aW9uIChfVHJhbnNpdGlvbkludGVycG9sYXQpIHtcbiAgX2luaGVyaXRzKExpbmVhckludGVycG9sYXRvciwgX1RyYW5zaXRpb25JbnRlcnBvbGF0KTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihMaW5lYXJJbnRlcnBvbGF0b3IpO1xuICBmdW5jdGlvbiBMaW5lYXJJbnRlcnBvbGF0b3IoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGluZWFySW50ZXJwb2xhdG9yKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICBvcHRzID0ge1xuICAgICAgICB0cmFuc2l0aW9uUHJvcHM6IG9wdHNcbiAgICAgIH07XG4gICAgfVxuICAgIF90aGlzLnByb3BOYW1lcyA9IG9wdHMudHJhbnNpdGlvblByb3BzIHx8IFZJRVdQT1JUX1RSQU5TSVRJT05fUFJPUFM7XG4gICAgaWYgKG9wdHMuYXJvdW5kKSB7XG4gICAgICBfdGhpcy5hcm91bmQgPSBvcHRzLmFyb3VuZDtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhMaW5lYXJJbnRlcnBvbGF0b3IsIFt7XG4gICAga2V5OiBcImluaXRpYWxpemVQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplUHJvcHMoc3RhcnRQcm9wcywgZW5kUHJvcHMpIHtcbiAgICAgIHZhciBzdGFydFZpZXdwb3J0UHJvcHMgPSB7fTtcbiAgICAgIHZhciBlbmRWaWV3cG9ydFByb3BzID0ge307XG4gICAgICBpZiAodGhpcy5hcm91bmQpIHtcbiAgICAgICAgc3RhcnRWaWV3cG9ydFByb3BzLmFyb3VuZCA9IHRoaXMuYXJvdW5kO1xuICAgICAgICB2YXIgYXJvdW5kTG5nTGF0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoc3RhcnRQcm9wcykudW5wcm9qZWN0KHRoaXMuYXJvdW5kKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihlbmRWaWV3cG9ydFByb3BzLCBlbmRQcm9wcywge1xuICAgICAgICAgIGFyb3VuZDogbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoZW5kUHJvcHMpLnByb2plY3QoYXJvdW5kTG5nTGF0KSxcbiAgICAgICAgICBhcm91bmRMbmdMYXQ6IGFyb3VuZExuZ0xhdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLnByb3BOYW1lcyksXG4gICAgICAgIF9zdGVwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIHN0YXJ0VmFsdWUgPSBzdGFydFByb3BzW2tleV07XG4gICAgICAgICAgdmFyIGVuZFZhbHVlID0gZW5kUHJvcHNba2V5XTtcbiAgICAgICAgICBhc3NlcnQoaXNWYWxpZChzdGFydFZhbHVlKSAmJiBpc1ZhbGlkKGVuZFZhbHVlKSwgXCJcIi5jb25jYXQoa2V5LCBcIiBtdXN0IGJlIHN1cHBsaWVkIGZvciB0cmFuc2l0aW9uXCIpKTtcbiAgICAgICAgICBzdGFydFZpZXdwb3J0UHJvcHNba2V5XSA9IHN0YXJ0VmFsdWU7XG4gICAgICAgICAgZW5kVmlld3BvcnRQcm9wc1trZXldID0gZ2V0RW5kVmFsdWVCeVNob3J0ZXN0UGF0aChrZXksIHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0Vmlld3BvcnRQcm9wcyxcbiAgICAgICAgZW5kOiBlbmRWaWV3cG9ydFByb3BzXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnBvbGF0ZVByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVycG9sYXRlUHJvcHMoc3RhcnRQcm9wcywgZW5kUHJvcHMsIHQpIHtcbiAgICAgIHZhciB2aWV3cG9ydCA9IHt9O1xuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLnByb3BOYW1lcyksXG4gICAgICAgIF9zdGVwMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGtleSA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICB2aWV3cG9ydFtrZXldID0gbGVycChzdGFydFByb3BzW2tleV0sIGVuZFByb3BzW2tleV0sIHQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmRQcm9wcy5hcm91bmQpIHtcbiAgICAgICAgdmFyIF9XZWJNZXJjYXRvclZpZXdwb3J0JCA9IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KE9iamVjdC5hc3NpZ24oe30sIGVuZFByb3BzLCB2aWV3cG9ydCkpLmdldE1hcENlbnRlckJ5TG5nTGF0UG9zaXRpb24oe1xuICAgICAgICAgICAgbG5nTGF0OiBlbmRQcm9wcy5hcm91bmRMbmdMYXQsXG4gICAgICAgICAgICBwb3M6IGxlcnAoc3RhcnRQcm9wcy5hcm91bmQsIGVuZFByb3BzLmFyb3VuZCwgdClcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBfV2ViTWVyY2F0b3JWaWV3cG9ydCQyID0gX3NsaWNlZFRvQXJyYXkoX1dlYk1lcmNhdG9yVmlld3BvcnQkLCAyKSxcbiAgICAgICAgICBsb25naXR1ZGUgPSBfV2ViTWVyY2F0b3JWaWV3cG9ydCQyWzBdLFxuICAgICAgICAgIGxhdGl0dWRlID0gX1dlYk1lcmNhdG9yVmlld3BvcnQkMlsxXTtcbiAgICAgICAgdmlld3BvcnQubG9uZ2l0dWRlID0gbG9uZ2l0dWRlO1xuICAgICAgICB2aWV3cG9ydC5sYXRpdHVkZSA9IGxhdGl0dWRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZpZXdwb3J0O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTGluZWFySW50ZXJwb2xhdG9yO1xufShUcmFuc2l0aW9uSW50ZXJwb2xhdG9yKTtcbmV4cG9ydCB7IExpbmVhckludGVycG9sYXRvciBhcyBkZWZhdWx0IH07IiwiZXhwb3J0IHsgZGVmYXVsdCBhcyBUcmFuc2l0aW9uSW50ZXJwb2xhdG9yIH0gZnJvbSAnLi90cmFuc2l0aW9uLWludGVycG9sYXRvcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFZpZXdwb3J0Rmx5VG9JbnRlcnBvbGF0b3IgfSBmcm9tICcuL3ZpZXdwb3J0LWZseS10by1pbnRlcnBvbGF0b3InO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaW5lYXJJbnRlcnBvbGF0b3IgfSBmcm9tICcuL2xpbmVhci1pbnRlcnBvbGF0b3InOyIsImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi9hc3NlcnQnO1xuaW1wb3J0IHsgTGluZWFySW50ZXJwb2xhdG9yIH0gZnJvbSAnLi90cmFuc2l0aW9uJztcbmltcG9ydCBNYXBTdGF0ZSBmcm9tICcuL21hcC1zdGF0ZSc7XG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbmV4cG9ydCBmdW5jdGlvbiBjcm9wRWFzaW5nRnVuY3Rpb24oZWFzaW5nLCB4MCkge1xuICB2YXIgeTAgPSBlYXNpbmcoeDApO1xuICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gMSAvICgxIC0geTApICogKGVhc2luZyh0ICogKDEgLSB4MCkgKyB4MCkgLSB5MCk7XG4gIH07XG59XG5leHBvcnQgdmFyIFRSQU5TSVRJT05fRVZFTlRTID0ge1xuICBCUkVBSzogMSxcbiAgU05BUF9UT19FTkQ6IDIsXG4gIElHTk9SRTogMyxcbiAgVVBEQVRFOiA0XG59O1xudmFyIERFRkFVTFRfUFJPUFMgPSB7XG4gIHRyYW5zaXRpb25EdXJhdGlvbjogMCxcbiAgdHJhbnNpdGlvbkVhc2luZzogZnVuY3Rpb24gdHJhbnNpdGlvbkVhc2luZyh0KSB7XG4gICAgcmV0dXJuIHQ7XG4gIH0sXG4gIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IG5ldyBMaW5lYXJJbnRlcnBvbGF0b3IoKSxcbiAgdHJhbnNpdGlvbkludGVycnVwdGlvbjogVFJBTlNJVElPTl9FVkVOVFMuQlJFQUssXG4gIG9uVHJhbnNpdGlvblN0YXJ0OiBub29wLFxuICBvblRyYW5zaXRpb25JbnRlcnJ1cHQ6IG5vb3AsXG4gIG9uVHJhbnNpdGlvbkVuZDogbm9vcFxufTtcbnZhciBUcmFuc2l0aW9uTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHJhbnNpdGlvbk1hbmFnZXIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zaXRpb25NYW5hZ2VyKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfYW5pbWF0aW9uRnJhbWVcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX29uVHJhbnNpdGlvbkZyYW1lXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9hbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy5fb25UcmFuc2l0aW9uRnJhbWUpO1xuICAgICAgX3RoaXMuX3VwZGF0ZVZpZXdwb3J0KCk7XG4gICAgfSk7XG4gICAgdGhpcy5wcm9wcyA9IG51bGw7XG4gICAgdGhpcy5vblZpZXdwb3J0Q2hhbmdlID0gb3B0cy5vblZpZXdwb3J0Q2hhbmdlIHx8IG5vb3A7XG4gICAgdGhpcy5vblN0YXRlQ2hhbmdlID0gb3B0cy5vblN0YXRlQ2hhbmdlIHx8IG5vb3A7XG4gICAgdGhpcy50aW1lID0gb3B0cy5nZXRUaW1lIHx8IERhdGUubm93O1xuICB9XG4gIF9jcmVhdGVDbGFzcyhUcmFuc2l0aW9uTWFuYWdlciwgW3tcbiAgICBrZXk6IFwiZ2V0Vmlld3BvcnRJblRyYW5zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Vmlld3BvcnRJblRyYW5zaXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYW5pbWF0aW9uRnJhbWUgPyB0aGlzLnN0YXRlLnByb3BzSW5UcmFuc2l0aW9uIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvY2Vzc1ZpZXdwb3J0Q2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWaWV3cG9ydENoYW5nZShuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBjdXJyZW50UHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdGhpcy5wcm9wcyA9IG5leHRQcm9wcztcbiAgICAgIGlmICghY3VycmVudFByb3BzIHx8IHRoaXMuX3Nob3VsZElnbm9yZVZpZXdwb3J0Q2hhbmdlKGN1cnJlbnRQcm9wcywgbmV4dFByb3BzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uRW5hYmxlZChuZXh0UHJvcHMpKSB7XG4gICAgICAgIHZhciBzdGFydFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudFByb3BzKTtcbiAgICAgICAgdmFyIGVuZFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbmV4dFByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbkluUHJvZ3Jlc3MoKSkge1xuICAgICAgICAgIGN1cnJlbnRQcm9wcy5vblRyYW5zaXRpb25JbnRlcnJ1cHQoKTtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5pbnRlcnJ1cHRpb24gPT09IFRSQU5TSVRJT05fRVZFTlRTLlNOQVBfVE9fRU5EKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0YXJ0UHJvcHMsIHRoaXMuc3RhdGUuZW5kUHJvcHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0YXJ0UHJvcHMsIHRoaXMuc3RhdGUucHJvcHNJblRyYW5zaXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5pbnRlcnJ1cHRpb24gPT09IFRSQU5TSVRJT05fRVZFTlRTLlVQREFURSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGhpcy50aW1lKCk7XG4gICAgICAgICAgICB2YXIgeDAgPSAoY3VycmVudFRpbWUgLSB0aGlzLnN0YXRlLnN0YXJ0VGltZSkgLyB0aGlzLnN0YXRlLmR1cmF0aW9uO1xuICAgICAgICAgICAgZW5kUHJvcHMudHJhbnNpdGlvbkR1cmF0aW9uID0gdGhpcy5zdGF0ZS5kdXJhdGlvbiAtIChjdXJyZW50VGltZSAtIHRoaXMuc3RhdGUuc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIGVuZFByb3BzLnRyYW5zaXRpb25FYXNpbmcgPSBjcm9wRWFzaW5nRnVuY3Rpb24odGhpcy5zdGF0ZS5lYXNpbmcsIHgwKTtcbiAgICAgICAgICAgIGVuZFByb3BzLnRyYW5zaXRpb25JbnRlcnBvbGF0b3IgPSBzdGFydFByb3BzLnRyYW5zaXRpb25JbnRlcnBvbGF0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVuZFByb3BzLm9uVHJhbnNpdGlvblN0YXJ0KCk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJUcmFuc2l0aW9uKHN0YXJ0UHJvcHMsIGVuZFByb3BzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uSW5Qcm9ncmVzcygpKSB7XG4gICAgICAgIGN1cnJlbnRQcm9wcy5vblRyYW5zaXRpb25JbnRlcnJ1cHQoKTtcbiAgICAgICAgdGhpcy5fZW5kVHJhbnNpdGlvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaXNUcmFuc2l0aW9uSW5Qcm9ncmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNUcmFuc2l0aW9uSW5Qcm9ncmVzcygpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuX2FuaW1hdGlvbkZyYW1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzVHJhbnNpdGlvbkVuYWJsZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzVHJhbnNpdGlvbkVuYWJsZWQocHJvcHMpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBwcm9wcy50cmFuc2l0aW9uRHVyYXRpb24sXG4gICAgICAgIHRyYW5zaXRpb25JbnRlcnBvbGF0b3IgPSBwcm9wcy50cmFuc2l0aW9uSW50ZXJwb2xhdG9yO1xuICAgICAgcmV0dXJuICh0cmFuc2l0aW9uRHVyYXRpb24gPiAwIHx8IHRyYW5zaXRpb25EdXJhdGlvbiA9PT0gJ2F1dG8nKSAmJiBCb29sZWFuKHRyYW5zaXRpb25JbnRlcnBvbGF0b3IpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaXNVcGRhdGVEdWVUb0N1cnJlbnRUcmFuc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1VwZGF0ZUR1ZVRvQ3VycmVudFRyYW5zaXRpb24ocHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnByb3BzSW5UcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmludGVycG9sYXRvci5hcmVQcm9wc0VxdWFsKHByb3BzLCB0aGlzLnN0YXRlLnByb3BzSW5UcmFuc2l0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Nob3VsZElnbm9yZVZpZXdwb3J0Q2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG91bGRJZ25vcmVWaWV3cG9ydENoYW5nZShjdXJyZW50UHJvcHMsIG5leHRQcm9wcykge1xuICAgICAgaWYgKCFjdXJyZW50UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uSW5Qcm9ncmVzcygpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmludGVycnVwdGlvbiA9PT0gVFJBTlNJVElPTl9FVkVOVFMuSUdOT1JFIHx8IHRoaXMuX2lzVXBkYXRlRHVlVG9DdXJyZW50VHJhbnNpdGlvbihuZXh0UHJvcHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbkVuYWJsZWQobmV4dFByb3BzKSkge1xuICAgICAgICByZXR1cm4gbmV4dFByb3BzLnRyYW5zaXRpb25JbnRlcnBvbGF0b3IuYXJlUHJvcHNFcXVhbChjdXJyZW50UHJvcHMsIG5leHRQcm9wcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3RyaWdnZXJUcmFuc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cmlnZ2VyVHJhbnNpdGlvbihzdGFydFByb3BzLCBlbmRQcm9wcykge1xuICAgICAgYXNzZXJ0KHRoaXMuX2lzVHJhbnNpdGlvbkVuYWJsZWQoZW5kUHJvcHMpKTtcbiAgICAgIGlmICh0aGlzLl9hbmltYXRpb25GcmFtZSkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltYXRpb25GcmFtZSk7XG4gICAgICB9XG4gICAgICB2YXIgdHJhbnNpdGlvbkludGVycG9sYXRvciA9IGVuZFByb3BzLnRyYW5zaXRpb25JbnRlcnBvbGF0b3I7XG4gICAgICB2YXIgZHVyYXRpb24gPSB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yLmdldER1cmF0aW9uID8gdHJhbnNpdGlvbkludGVycG9sYXRvci5nZXREdXJhdGlvbihzdGFydFByb3BzLCBlbmRQcm9wcykgOiBlbmRQcm9wcy50cmFuc2l0aW9uRHVyYXRpb247XG4gICAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGluaXRpYWxQcm9wcyA9IGVuZFByb3BzLnRyYW5zaXRpb25JbnRlcnBvbGF0b3IuaW5pdGlhbGl6ZVByb3BzKHN0YXJ0UHJvcHMsIGVuZFByb3BzKTtcbiAgICAgIHZhciBpbnRlcmFjdGlvblN0YXRlID0ge1xuICAgICAgICBpblRyYW5zaXRpb246IHRydWUsXG4gICAgICAgIGlzWm9vbWluZzogc3RhcnRQcm9wcy56b29tICE9PSBlbmRQcm9wcy56b29tLFxuICAgICAgICBpc1Bhbm5pbmc6IHN0YXJ0UHJvcHMubG9uZ2l0dWRlICE9PSBlbmRQcm9wcy5sb25naXR1ZGUgfHwgc3RhcnRQcm9wcy5sYXRpdHVkZSAhPT0gZW5kUHJvcHMubGF0aXR1ZGUsXG4gICAgICAgIGlzUm90YXRpbmc6IHN0YXJ0UHJvcHMuYmVhcmluZyAhPT0gZW5kUHJvcHMuYmVhcmluZyB8fCBzdGFydFByb3BzLnBpdGNoICE9PSBlbmRQcm9wcy5waXRjaFxuICAgICAgfTtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiBlbmRQcm9wcy50cmFuc2l0aW9uRWFzaW5nLFxuICAgICAgICBpbnRlcnBvbGF0b3I6IGVuZFByb3BzLnRyYW5zaXRpb25JbnRlcnBvbGF0b3IsXG4gICAgICAgIGludGVycnVwdGlvbjogZW5kUHJvcHMudHJhbnNpdGlvbkludGVycnVwdGlvbixcbiAgICAgICAgc3RhcnRUaW1lOiB0aGlzLnRpbWUoKSxcbiAgICAgICAgc3RhcnRQcm9wczogaW5pdGlhbFByb3BzLnN0YXJ0LFxuICAgICAgICBlbmRQcm9wczogaW5pdGlhbFByb3BzLmVuZCxcbiAgICAgICAgYW5pbWF0aW9uOiBudWxsLFxuICAgICAgICBwcm9wc0luVHJhbnNpdGlvbjoge31cbiAgICAgIH07XG4gICAgICB0aGlzLl9vblRyYW5zaXRpb25GcmFtZSgpO1xuICAgICAgdGhpcy5vblN0YXRlQ2hhbmdlKGludGVyYWN0aW9uU3RhdGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZW5kVHJhbnNpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW5kVHJhbnNpdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9hbmltYXRpb25GcmFtZSkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltYXRpb25GcmFtZSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMub25TdGF0ZUNoYW5nZSh7XG4gICAgICAgIGluVHJhbnNpdGlvbjogZmFsc2UsXG4gICAgICAgIGlzWm9vbWluZzogZmFsc2UsXG4gICAgICAgIGlzUGFubmluZzogZmFsc2UsXG4gICAgICAgIGlzUm90YXRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVZpZXdwb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVWaWV3cG9ydCgpIHtcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMudGltZSgpO1xuICAgICAgdmFyIF90aGlzJHN0YXRlID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgc3RhcnRUaW1lID0gX3RoaXMkc3RhdGUuc3RhcnRUaW1lLFxuICAgICAgICBkdXJhdGlvbiA9IF90aGlzJHN0YXRlLmR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcgPSBfdGhpcyRzdGF0ZS5lYXNpbmcsXG4gICAgICAgIGludGVycG9sYXRvciA9IF90aGlzJHN0YXRlLmludGVycG9sYXRvcixcbiAgICAgICAgc3RhcnRQcm9wcyA9IF90aGlzJHN0YXRlLnN0YXJ0UHJvcHMsXG4gICAgICAgIGVuZFByb3BzID0gX3RoaXMkc3RhdGUuZW5kUHJvcHM7XG4gICAgICB2YXIgc2hvdWxkRW5kID0gZmFsc2U7XG4gICAgICB2YXIgdCA9IChjdXJyZW50VGltZSAtIHN0YXJ0VGltZSkgLyBkdXJhdGlvbjtcbiAgICAgIGlmICh0ID49IDEpIHtcbiAgICAgICAgdCA9IDE7XG4gICAgICAgIHNob3VsZEVuZCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0ID0gZWFzaW5nKHQpO1xuICAgICAgdmFyIHZpZXdwb3J0ID0gaW50ZXJwb2xhdG9yLmludGVycG9sYXRlUHJvcHMoc3RhcnRQcm9wcywgZW5kUHJvcHMsIHQpO1xuICAgICAgdmFyIG1hcFN0YXRlID0gbmV3IE1hcFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHZpZXdwb3J0KSk7XG4gICAgICB0aGlzLnN0YXRlLnByb3BzSW5UcmFuc2l0aW9uID0gbWFwU3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpO1xuICAgICAgdGhpcy5vblZpZXdwb3J0Q2hhbmdlKHRoaXMuc3RhdGUucHJvcHNJblRyYW5zaXRpb24sIHRoaXMucHJvcHMpO1xuICAgICAgaWYgKHNob3VsZEVuZCkge1xuICAgICAgICB0aGlzLl9lbmRUcmFuc2l0aW9uKCk7XG4gICAgICAgIHRoaXMucHJvcHMub25UcmFuc2l0aW9uRW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUcmFuc2l0aW9uTWFuYWdlcjtcbn0oKTtcbl9kZWZpbmVQcm9wZXJ0eShUcmFuc2l0aW9uTWFuYWdlciwgXCJkZWZhdWx0UHJvcHNcIiwgREVGQVVMVF9QUk9QUyk7XG5leHBvcnQgeyBUcmFuc2l0aW9uTWFuYWdlciBhcyBkZWZhdWx0IH07IiwiLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgb3ZlcnJpZGVzIHRoZSBkZWZhdWx0XG4gKiBoYW1tZXIuanMgZnVuY3Rpb25zIHRvIGFkZCBvdXIgb3duIHV0aWxpdHlcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qIEhhbW1lci5qcyBjb25zdGFudHMgKi9cbmNvbnN0IElOUFVUX1NUQVJUID0gMTtcbmNvbnN0IElOUFVUX01PVkUgPSAyO1xuY29uc3QgSU5QVVRfRU5EID0gNDtcbmNvbnN0IE1PVVNFX0lOUFVUX01BUCA9IHtcbiAgbW91c2Vkb3duOiBJTlBVVF9TVEFSVCxcbiAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxuICBtb3VzZXVwOiBJTlBVVF9FTkRcbn07XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiBhbnkgZWxlbWVudCBpbiBhbiBhcnJheSBtZWV0cyBnaXZlbiBjcml0ZXJpYS5cbiAqIEJlY2F1c2Ugb2xkZXIgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgYEFycmF5LnByb3RvdHlwZS5zb21lYFxuICogQHBhcmFtcyBhcnJheSB7QXJyYXl9XG4gKiBAcGFyYW1zIHByZWRpY3Qge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBzb21lKGFycmF5LCBwcmVkaWN0KSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocHJlZGljdChhcnJheVtpXSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmhhbmNlUG9pbnRlckV2ZW50SW5wdXQoUG9pbnRlckV2ZW50SW5wdXQpIHtcbiAgY29uc3Qgb2xkSGFuZGxlciA9IFBvaW50ZXJFdmVudElucHV0LnByb3RvdHlwZS5oYW5kbGVyO1xuICAvLyBvdmVycmlkZXMgUG9pbnRlckV2ZW50SW5wdXQuaGFuZGxlciB0byBhY2NlcHQgcmlnaHQgbW91c2UgYnV0dG9uXG4gIFBvaW50ZXJFdmVudElucHV0LnByb3RvdHlwZS5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgIGNvbnN0IHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAvLyBBbGxvdyBub24tbGVmdCBtb3VzZSBidXR0b25zIHRocm91Z2hcbiAgICBpZiAoZXYuYnV0dG9uID4gMCAmJiBldi50eXBlID09PSAncG9pbnRlcmRvd24nKSB7XG4gICAgICBpZiAoIXNvbWUoc3RvcmUsIGUgPT4gZS5wb2ludGVySWQgPT09IGV2LnBvaW50ZXJJZCkpIHtcbiAgICAgICAgc3RvcmUucHVzaChldik7XG4gICAgICB9XG4gICAgfVxuICAgIG9sZEhhbmRsZXIuY2FsbCh0aGlzLCBldik7XG4gIH07XG59XG4vLyBvdmVycmlkZXMgTW91c2VJbnB1dC5oYW5kbGVyIHRvIGFjY2VwdCByaWdodCBtb3VzZSBidXR0b25cbmV4cG9ydCBmdW5jdGlvbiBlbmhhbmNlTW91c2VJbnB1dChNb3VzZUlucHV0KSB7XG4gIE1vdXNlSW5wdXQucHJvdG90eXBlLmhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGV2KSB7XG4gICAgbGV0IGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTtcbiAgICAvLyBvbiBzdGFydCB3ZSB3YW50IHRvIGhhdmUgdGhlIG1vdXNlIGJ1dHRvbiBkb3duXG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA+PSAwKSB7XG4gICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi5idXR0b25zID09PSAwKSB7XG4gICAgICBldmVudFR5cGUgPSBJTlBVVF9FTkQ7XG4gICAgfVxuICAgIC8vIG1vdXNlIG11c3QgYmUgZG93blxuICAgIGlmICghdGhpcy5wcmVzc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICBwb2ludGVyczogW2V2XSxcbiAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgIHBvaW50ZXJUeXBlOiAnbW91c2UnLFxuICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgfSk7XG4gIH07XG59IiwiaW1wb3J0ICogYXMgaGFtbWVyanMgZnJvbSAnaGFtbWVyanMnO1xuaW1wb3J0IHsgZW5oYW5jZVBvaW50ZXJFdmVudElucHV0LCBlbmhhbmNlTW91c2VJbnB1dCB9IGZyb20gJy4vaGFtbWVyLW92ZXJyaWRlcyc7XG5lbmhhbmNlUG9pbnRlckV2ZW50SW5wdXQoaGFtbWVyanMuUG9pbnRlckV2ZW50SW5wdXQpO1xuZW5oYW5jZU1vdXNlSW5wdXQoaGFtbWVyanMuTW91c2VJbnB1dCk7XG5leHBvcnQgY29uc3QgTWFuYWdlciA9IGhhbW1lcmpzLk1hbmFnZXI7XG5leHBvcnQgZGVmYXVsdCBoYW1tZXJqczsiLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgZW5hYmxlOiB0cnVlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gIH1cbn0iLCJpbXBvcnQgSGFtbWVyIGZyb20gJy4vdXRpbHMvaGFtbWVyJztcbi8vIFRoaXMgbW9kdWxlIGNvbnRhaW5zIGNvbnN0YW50cyB0aGF0IG11c3QgYmUgY29uZGl0aW9uYWxseSByZXF1aXJlZFxuLy8gZHVlIHRvIGB3aW5kb3dgL2Bkb2N1bWVudGAgcmVmZXJlbmNlcyBkb3duc3RyZWFtLlxuZXhwb3J0IGNvbnN0IFJFQ09HTklaRVJTID0gSGFtbWVyID8gW1tIYW1tZXIuUGFuLCB7XG4gIGV2ZW50OiAndHJpcGFuJyxcbiAgcG9pbnRlcnM6IDMsXG4gIHRocmVzaG9sZDogMCxcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtIYW1tZXIuUm90YXRlLCB7XG4gIGVuYWJsZTogZmFsc2Vcbn1dLCBbSGFtbWVyLlBpbmNoLCB7XG4gIGVuYWJsZTogZmFsc2Vcbn1dLCBbSGFtbWVyLlN3aXBlLCB7XG4gIGVuYWJsZTogZmFsc2Vcbn1dLCBbSGFtbWVyLlBhbiwge1xuICB0aHJlc2hvbGQ6IDAsXG4gIGVuYWJsZTogZmFsc2Vcbn1dLCBbSGFtbWVyLlByZXNzLCB7XG4gIGVuYWJsZTogZmFsc2Vcbn1dLCBbSGFtbWVyLlRhcCwge1xuICBldmVudDogJ2RvdWJsZXRhcCcsXG4gIHRhcHM6IDIsXG4gIGVuYWJsZTogZmFsc2Vcbn1dLFxuLy8gVE9ETyAtIHJlbmFtZSB0byAndGFwJyBhbmQgJ3NpbmdsZXRhcCcgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxuW0hhbW1lci5UYXAsIHtcbiAgZXZlbnQ6ICdhbnl0YXAnLFxuICBlbmFibGU6IGZhbHNlXG59XSwgW0hhbW1lci5UYXAsIHtcbiAgZW5hYmxlOiBmYWxzZVxufV1dIDogbnVsbDtcbi8vIFJlY29nbml6ZSB0aGUgZm9sbG93aW5nIGdlc3R1cmVzIGV2ZW4gaWYgYSBnaXZlbiByZWNvZ25pemVyIHN1Y2NlZWRzXG5leHBvcnQgY29uc3QgUkVDT0dOSVpFUl9DT01QQVRJQkxFX01BUCA9IHtcbiAgdHJpcGFuOiBbJ3JvdGF0ZScsICdwaW5jaCcsICdwYW4nXSxcbiAgcm90YXRlOiBbJ3BpbmNoJ10sXG4gIHBpbmNoOiBbJ3BhbiddLFxuICBwYW46IFsncHJlc3MnLCAnZG91YmxldGFwJywgJ2FueXRhcCcsICd0YXAnXSxcbiAgZG91YmxldGFwOiBbJ2FueXRhcCddLFxuICBhbnl0YXA6IFsndGFwJ11cbn07XG4vLyBSZWNvZ25pemUgdGhlIGZvbGxpbmcgZ2VzdHVyZXMgb25seSBpZiBhIGdpdmVuIHJlY29nbml6ZXIgZmFpbHNcbmV4cG9ydCBjb25zdCBSRUNPR05JWkVSX0ZBTExCQUNLX01BUCA9IHtcbiAgZG91YmxldGFwOiBbJ3RhcCddXG59O1xuLyoqXG4gKiBPbmx5IG9uZSBzZXQgb2YgYmFzaWMgaW5wdXQgZXZlbnRzIHdpbGwgYmUgZmlyZWQgYnkgSGFtbWVyLmpzOlxuICogZWl0aGVyIHBvaW50ZXIsIHRvdWNoLCBvciBtb3VzZSwgZGVwZW5kaW5nIG9uIHN5c3RlbSBzdXBwb3J0LlxuICogSW4gb3JkZXIgdG8gZW5hYmxlIGFuIGFwcGxpY2F0aW9uIHRvIGJlIGFnbm9zdGljIG9mIHN5c3RlbSBzdXBwb3J0LFxuICogYWxpYXMgYmFzaWMgaW5wdXQgZXZlbnRzIGludG8gXCJjbGFzc2VzXCIgb2YgZXZlbnRzOiBkb3duLCBtb3ZlLCBhbmQgdXAuXG4gKiBTZWUgYF9vbkJhc2ljSW5wdXQoKWAgZm9yIHVzYWdlIG9mIHRoZXNlIGFsaWFzZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBCQVNJQ19FVkVOVF9BTElBU0VTID0ge1xuICBwb2ludGVyZG93bjogJ3BvaW50ZXJkb3duJyxcbiAgcG9pbnRlcm1vdmU6ICdwb2ludGVybW92ZScsXG4gIHBvaW50ZXJ1cDogJ3BvaW50ZXJ1cCcsXG4gIHRvdWNoc3RhcnQ6ICdwb2ludGVyZG93bicsXG4gIHRvdWNobW92ZTogJ3BvaW50ZXJtb3ZlJyxcbiAgdG91Y2hlbmQ6ICdwb2ludGVydXAnLFxuICBtb3VzZWRvd246ICdwb2ludGVyZG93bicsXG4gIG1vdXNlbW92ZTogJ3BvaW50ZXJtb3ZlJyxcbiAgbW91c2V1cDogJ3BvaW50ZXJ1cCdcbn07XG5leHBvcnQgY29uc3QgSU5QVVRfRVZFTlRfVFlQRVMgPSB7XG4gIEtFWV9FVkVOVFM6IFsna2V5ZG93bicsICdrZXl1cCddLFxuICBNT1VTRV9FVkVOVFM6IFsnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdtb3VzZXVwJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdtb3VzZWxlYXZlJ10sXG4gIFdIRUVMX0VWRU5UUzogW1xuICAvLyBDaHJvbWUsIFNhZmFyaVxuICAnd2hlZWwnLFxuICAvLyBJRVxuICAnbW91c2V3aGVlbCddXG59O1xuLyoqXG4gKiBcIkdlc3R1cmFsXCIgZXZlbnRzIGFyZSB0aG9zZSB0aGF0IGhhdmUgc2VtYW50aWMgbWVhbmluZyBiZXlvbmQgdGhlIGJhc2ljIGlucHV0IGV2ZW50LFxuICogZS5nLiBhIGNsaWNrIG9yIHRhcCBpcyBhIHNlcXVlbmNlIG9mIGBkb3duYCBhbmQgYHVwYCBldmVudHMgd2l0aCBubyBgbW92ZWAgZXZlbnQgaW4gYmV0d2Vlbi5cbiAqIEhhbW1lci5qcyBoYW5kbGVzIHRoZXNlIHdpdGggaXRzIFJlY29nbml6ZXIgc3lzdGVtO1xuICogdGhpcyBibG9jayBtYXBzIGV2ZW50IG5hbWVzIHRvIHRoZSBSZWNvZ25pemVycyByZXF1aXJlZCB0byBkZXRlY3QgdGhlIGV2ZW50cy5cbiAqL1xuZXhwb3J0IGNvbnN0IEVWRU5UX1JFQ09HTklaRVJfTUFQID0ge1xuICB0YXA6ICd0YXAnLFxuICBhbnl0YXA6ICdhbnl0YXAnLFxuICBkb3VibGV0YXA6ICdkb3VibGV0YXAnLFxuICBwcmVzczogJ3ByZXNzJyxcbiAgcGluY2g6ICdwaW5jaCcsXG4gIHBpbmNoaW46ICdwaW5jaCcsXG4gIHBpbmNob3V0OiAncGluY2gnLFxuICBwaW5jaHN0YXJ0OiAncGluY2gnLFxuICBwaW5jaG1vdmU6ICdwaW5jaCcsXG4gIHBpbmNoZW5kOiAncGluY2gnLFxuICBwaW5jaGNhbmNlbDogJ3BpbmNoJyxcbiAgcm90YXRlOiAncm90YXRlJyxcbiAgcm90YXRlc3RhcnQ6ICdyb3RhdGUnLFxuICByb3RhdGVtb3ZlOiAncm90YXRlJyxcbiAgcm90YXRlZW5kOiAncm90YXRlJyxcbiAgcm90YXRlY2FuY2VsOiAncm90YXRlJyxcbiAgdHJpcGFuOiAndHJpcGFuJyxcbiAgdHJpcGFuc3RhcnQ6ICd0cmlwYW4nLFxuICB0cmlwYW5tb3ZlOiAndHJpcGFuJyxcbiAgdHJpcGFudXA6ICd0cmlwYW4nLFxuICB0cmlwYW5kb3duOiAndHJpcGFuJyxcbiAgdHJpcGFubGVmdDogJ3RyaXBhbicsXG4gIHRyaXBhbnJpZ2h0OiAndHJpcGFuJyxcbiAgdHJpcGFuZW5kOiAndHJpcGFuJyxcbiAgdHJpcGFuY2FuY2VsOiAndHJpcGFuJyxcbiAgcGFuOiAncGFuJyxcbiAgcGFuc3RhcnQ6ICdwYW4nLFxuICBwYW5tb3ZlOiAncGFuJyxcbiAgcGFudXA6ICdwYW4nLFxuICBwYW5kb3duOiAncGFuJyxcbiAgcGFubGVmdDogJ3BhbicsXG4gIHBhbnJpZ2h0OiAncGFuJyxcbiAgcGFuZW5kOiAncGFuJyxcbiAgcGFuY2FuY2VsOiAncGFuJyxcbiAgc3dpcGU6ICdzd2lwZScsXG4gIHN3aXBlbGVmdDogJ3N3aXBlJyxcbiAgc3dpcGVyaWdodDogJ3N3aXBlJyxcbiAgc3dpcGV1cDogJ3N3aXBlJyxcbiAgc3dpcGVkb3duOiAnc3dpcGUnXG59O1xuLyoqXG4gKiBNYXAgZ2VzdHVyYWwgZXZlbnRzIHR5cGljYWxseSBwcm92aWRlZCBieSBicm93c2Vyc1xuICogdGhhdCBhcmUgbm90IHJlcG9ydGVkIGluICdoYW1tZXIuaW5wdXQnIGV2ZW50c1xuICogdG8gY29ycmVzcG9uZGluZyBIYW1tZXIuanMgZ2VzdHVyZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBHRVNUVVJFX0VWRU5UX0FMSUFTRVMgPSB7XG4gIGNsaWNrOiAndGFwJyxcbiAgYW55Y2xpY2s6ICdhbnl0YXAnLFxuICBkYmxjbGljazogJ2RvdWJsZXRhcCcsXG4gIG1vdXNlZG93bjogJ3BvaW50ZXJkb3duJyxcbiAgbW91c2Vtb3ZlOiAncG9pbnRlcm1vdmUnLFxuICBtb3VzZXVwOiAncG9pbnRlcnVwJyxcbiAgbW91c2VvdmVyOiAncG9pbnRlcm92ZXInLFxuICBtb3VzZW91dDogJ3BvaW50ZXJvdXQnLFxuICBtb3VzZWxlYXZlOiAncG9pbnRlcmxlYXZlJ1xufTsiLCIvLyBQdXJwb3NlOiBpbmNsdWRlIHRoaXMgaW4geW91ciBtb2R1bGUgdG8gYXZvaWRzIGFkZGluZyBkZXBlbmRlbmNpZXMgb25cbi8vIG1pY3JvIG1vZHVsZXMgbGlrZSAnZ2xvYmFsJ1xuLyogZ2xvYmFsIHdpbmRvdywgZ2xvYmFsLCBkb2N1bWVudCwgbmF2aWdhdG9yICovXG5leHBvcnQgY29uc3QgdXNlckFnZW50ID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCA/IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSA6ICcnO1xuY29uc3Qgd2luZG93XyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsO1xuY29uc3QgZ2xvYmFsXyA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93O1xuY29uc3QgZG9jdW1lbnRfID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDoge307XG5leHBvcnQgeyB3aW5kb3dfIGFzIHdpbmRvdywgZ2xvYmFsXyBhcyBnbG9iYWwsIGRvY3VtZW50XyBhcyBkb2N1bWVudCB9O1xuLypcbiAqIERldGVjdCB3aGV0aGVyIHBhc3NpdmUgb3B0aW9uIGlzIHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCBicm93c2VyLlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXJcbiAgICNTYWZlbHlfZGV0ZWN0aW5nX29wdGlvbl9zdXBwb3J0XG4gKi9cbmxldCBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG4vKiBlc2xpbnQtZGlzYWJsZSBhY2Nlc3Nvci1wYWlycywgbm8tZW1wdHkgKi9cbnRyeSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBicm93c2VyXG4gICAgLy8gYXR0ZW1wdHMgdG8gYWNjZXNzIHRoZSBwYXNzaXZlIHByb3BlcnR5LlxuICAgIGdldCBwYXNzaXZlKCkge1xuICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIHdpbmRvd18uYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICB3aW5kb3dfLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsKTtcbn0gY2F0Y2ggKGVycikge1xuICBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG59XG5leHBvcnQgeyBwYXNzaXZlU3VwcG9ydGVkIH07IiwiaW1wb3J0IElucHV0IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IHsgSU5QVVRfRVZFTlRfVFlQRVMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgd2luZG93LCB1c2VyQWdlbnQsIHBhc3NpdmVTdXBwb3J0ZWQgfSBmcm9tICcuLi91dGlscy9nbG9iYWxzJztcbmNvbnN0IGZpcmVmb3ggPSB1c2VyQWdlbnQuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMTtcbmNvbnN0IHtcbiAgV0hFRUxfRVZFTlRTXG59ID0gSU5QVVRfRVZFTlRfVFlQRVM7XG5jb25zdCBFVkVOVF9UWVBFID0gJ3doZWVsJztcbi8vIENvbnN0YW50cyBmb3Igbm9ybWFsaXppbmcgaW5wdXQgZGVsdGFcbmNvbnN0IFdIRUVMX0RFTFRBX01BR0lDX1NDQUxFUiA9IDQuMDAwMjQ0MTQwNjI1O1xuY29uc3QgV0hFRUxfREVMVEFfUEVSX0xJTkUgPSA0MDtcbi8vIFNsb3cgZG93biB6b29tIGlmIHNoaWZ0IGtleSBpcyBoZWxkIGZvciBtb3JlIHByZWNpc2Ugem9vbWluZ1xuY29uc3QgU0hJRlRfTVVMVElQTElFUiA9IDAuMjU7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaGVlbElucHV0IGV4dGVuZHMgSW5wdXQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHN1cGVyKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50cyAqL1xuICAgIHRoaXMuaGFuZGxlRXZlbnQgPSBldmVudCA9PiB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHZhbHVlID0gZXZlbnQuZGVsdGFZO1xuICAgICAgaWYgKHdpbmRvdy5XaGVlbEV2ZW50KSB7XG4gICAgICAgIC8vIEZpcmVmb3ggZG91YmxlcyB0aGUgdmFsdWVzIG9uIHJldGluYSBzY3JlZW5zLi4uXG4gICAgICAgIGlmIChmaXJlZm94ICYmIGV2ZW50LmRlbHRhTW9kZSA9PT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMKSB7XG4gICAgICAgICAgdmFsdWUgLz0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmRlbHRhTW9kZSA9PT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUpIHtcbiAgICAgICAgICB2YWx1ZSAqPSBXSEVFTF9ERUxUQV9QRVJfTElORTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHZhbHVlICUgV0hFRUxfREVMVEFfTUFHSUNfU0NBTEVSID09PSAwKSB7XG4gICAgICAgIC8vIFRoaXMgb25lIGlzIGRlZmluaXRlbHkgYSBtb3VzZSB3aGVlbCBldmVudC5cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoaXMgdmFsdWUgdG8gbWF0Y2ggdHJhY2twYWQuXG4gICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIFdIRUVMX0RFTFRBX01BR0lDX1NDQUxFUik7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQuc2hpZnRLZXkgJiYgdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIFNISUZUX01VTFRJUExJRVI7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxiYWNrKHtcbiAgICAgICAgdHlwZTogRVZFTlRfVFlQRSxcbiAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgICAgIH0sXG4gICAgICAgIGRlbHRhOiAtdmFsdWUsXG4gICAgICAgIHNyY0V2ZW50OiBldmVudCxcbiAgICAgICAgcG9pbnRlclR5cGU6ICdtb3VzZScsXG4gICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuZXZlbnRzID0gKHRoaXMub3B0aW9ucy5ldmVudHMgfHwgW10pLmNvbmNhdChXSEVFTF9FVkVOVFMpO1xuICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZUV2ZW50LCBwYXNzaXZlU3VwcG9ydGVkID8ge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9IDogZmFsc2UpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuaGFuZGxlRXZlbnQpKTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIHRoaXMgaW5wdXQgKGJlZ2luIHByb2Nlc3NpbmcgZXZlbnRzKVxuICAgKiBpZiB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUgaXMgYW1vbmcgdGhvc2UgaGFuZGxlZCBieSB0aGlzIGlucHV0LlxuICAgKi9cbiAgZW5hYmxlRXZlbnRUeXBlKGV2ZW50VHlwZSwgZW5hYmxlZCkge1xuICAgIGlmIChldmVudFR5cGUgPT09IEVWRU5UX1RZUEUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5lbmFibGUgPSBlbmFibGVkO1xuICAgIH1cbiAgfVxufSIsImltcG9ydCBJbnB1dCBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IElOUFVUX0VWRU5UX1RZUEVTIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmNvbnN0IHtcbiAgTU9VU0VfRVZFTlRTXG59ID0gSU5QVVRfRVZFTlRfVFlQRVM7XG5jb25zdCBNT1ZFX0VWRU5UX1RZUEUgPSAncG9pbnRlcm1vdmUnO1xuY29uc3QgT1ZFUl9FVkVOVF9UWVBFID0gJ3BvaW50ZXJvdmVyJztcbmNvbnN0IE9VVF9FVkVOVF9UWVBFID0gJ3BvaW50ZXJvdXQnO1xuY29uc3QgRU5URVJfRVZFTlRfVFlQRSA9ICdwb2ludGVyZW50ZXInO1xuY29uc3QgTEVBVkVfRVZFTlRfVFlQRSA9ICdwb2ludGVybGVhdmUnO1xuLyoqXG4gKiBIYW1tZXIuanMgc3dhbGxvd3MgJ21vdmUnIGV2ZW50cyAoZm9yIHBvaW50ZXIvdG91Y2gvbW91c2UpXG4gKiB3aGVuIHRoZSBwb2ludGVyIGlzIG5vdCBkb3duLiBUaGlzIGNsYXNzIHNldHMgdXAgYSBoYW5kbGVyXG4gKiBzcGVjaWZpY2FsbHkgZm9yIHRoZXNlIGV2ZW50cyB0byB3b3JrIGFyb3VuZCB0aGlzIGxpbWl0YXRpb24uXG4gKiBOb3RlIHRoYXQgdGhpcyBjb3VsZCBiZSBleHRlbmRlZCB0byBtb3JlIGludGVsbGlnZW50bHkgaGFuZGxlXG4gKiBtb3ZlIGV2ZW50cyBhY3Jvc3MgaW5wdXQgdHlwZXMsIGUuZy4gc3RvcmluZyBtdWx0aXBsZSBzaW11bHRhbmVvdXNcbiAqIHBvaW50ZXIvdG91Y2ggZXZlbnRzLCBjYWxjdWxhdGluZyBzcGVlZC9kaXJlY3Rpb24sIGV0Yy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW92ZUlucHV0IGV4dGVuZHMgSW5wdXQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHN1cGVyKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgICB0aGlzLmhhbmRsZUV2ZW50ID0gZXZlbnQgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVPdmVyRXZlbnQoZXZlbnQpO1xuICAgICAgdGhpcy5oYW5kbGVPdXRFdmVudChldmVudCk7XG4gICAgICB0aGlzLmhhbmRsZUVudGVyRXZlbnQoZXZlbnQpO1xuICAgICAgdGhpcy5oYW5kbGVMZWF2ZUV2ZW50KGV2ZW50KTtcbiAgICAgIHRoaXMuaGFuZGxlTW92ZUV2ZW50KGV2ZW50KTtcbiAgICB9O1xuICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHtcbiAgICAgIGVuYWJsZVxuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgdGhpcy5lbmFibGVNb3ZlRXZlbnQgPSBlbmFibGU7XG4gICAgdGhpcy5lbmFibGVMZWF2ZUV2ZW50ID0gZW5hYmxlO1xuICAgIHRoaXMuZW5hYmxlRW50ZXJFdmVudCA9IGVuYWJsZTtcbiAgICB0aGlzLmVuYWJsZU91dEV2ZW50ID0gZW5hYmxlO1xuICAgIHRoaXMuZW5hYmxlT3ZlckV2ZW50ID0gZW5hYmxlO1xuICAgIHRoaXMuZXZlbnRzID0gKHRoaXMub3B0aW9ucy5ldmVudHMgfHwgW10pLmNvbmNhdChNT1VTRV9FVkVOVFMpO1xuICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZUV2ZW50KSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZUV2ZW50KSk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGlzIGlucHV0IChiZWdpbiBwcm9jZXNzaW5nIGV2ZW50cylcbiAgICogaWYgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlIGlzIGFtb25nIHRob3NlIGhhbmRsZWQgYnkgdGhpcyBpbnB1dC5cbiAgICovXG4gIGVuYWJsZUV2ZW50VHlwZShldmVudFR5cGUsIGVuYWJsZWQpIHtcbiAgICBpZiAoZXZlbnRUeXBlID09PSBNT1ZFX0VWRU5UX1RZUEUpIHtcbiAgICAgIHRoaXMuZW5hYmxlTW92ZUV2ZW50ID0gZW5hYmxlZDtcbiAgICB9XG4gICAgaWYgKGV2ZW50VHlwZSA9PT0gT1ZFUl9FVkVOVF9UWVBFKSB7XG4gICAgICB0aGlzLmVuYWJsZU92ZXJFdmVudCA9IGVuYWJsZWQ7XG4gICAgfVxuICAgIGlmIChldmVudFR5cGUgPT09IE9VVF9FVkVOVF9UWVBFKSB7XG4gICAgICB0aGlzLmVuYWJsZU91dEV2ZW50ID0gZW5hYmxlZDtcbiAgICB9XG4gICAgaWYgKGV2ZW50VHlwZSA9PT0gRU5URVJfRVZFTlRfVFlQRSkge1xuICAgICAgdGhpcy5lbmFibGVFbnRlckV2ZW50ID0gZW5hYmxlZDtcbiAgICB9XG4gICAgaWYgKGV2ZW50VHlwZSA9PT0gTEVBVkVfRVZFTlRfVFlQRSkge1xuICAgICAgdGhpcy5lbmFibGVMZWF2ZUV2ZW50ID0gZW5hYmxlZDtcbiAgICB9XG4gIH1cbiAgaGFuZGxlT3ZlckV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZW5hYmxlT3ZlckV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlb3ZlcicpIHtcbiAgICAgICAgdGhpcy5fZW1pdChPVkVSX0VWRU5UX1RZUEUsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlT3V0RXZlbnQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5lbmFibGVPdXRFdmVudCkge1xuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgICAgdGhpcy5fZW1pdChPVVRfRVZFTlRfVFlQRSwgZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYW5kbGVFbnRlckV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZW5hYmxlRW50ZXJFdmVudCkge1xuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZWVudGVyJykge1xuICAgICAgICB0aGlzLl9lbWl0KEVOVEVSX0VWRU5UX1RZUEUsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlTGVhdmVFdmVudChldmVudCkge1xuICAgIGlmICh0aGlzLmVuYWJsZUxlYXZlRXZlbnQpIHtcbiAgICAgIGlmIChldmVudC50eXBlID09PSAnbW91c2VsZWF2ZScpIHtcbiAgICAgICAgdGhpcy5fZW1pdChMRUFWRV9FVkVOVF9UWVBFLCBldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhbmRsZU1vdmVFdmVudChldmVudCkge1xuICAgIGlmICh0aGlzLmVuYWJsZU1vdmVFdmVudCkge1xuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA+PSAwKSB7XG4gICAgICAgICAgICAvLyBCdXR0b24gaXMgZG93blxuICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAgICAgLy8gTW92ZSBldmVudHMgdXNlIGBib3R0b25zYCB0byB0cmFjayB0aGUgYnV0dG9uIGJlaW5nIHByZXNzZWRcbiAgICAgICAgICBpZiAoZXZlbnQuYnV0dG9ucyA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQnV0dG9uIGlzIG5vdCBkb3duXG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLnByZXNzZWQpIHtcbiAgICAgICAgICAgIC8vIERyYWcgZXZlbnRzIGFyZSBlbWl0dGVkIGJ5IGhhbW1lciBhbHJlYWR5XG4gICAgICAgICAgICAvLyB3ZSBqdXN0IG5lZWQgdG8gZW1pdCB0aGUgbW92ZSBldmVudCBvbiBob3ZlclxuICAgICAgICAgICAgdGhpcy5fZW1pdChNT1ZFX0VWRU5UX1RZUEUsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfZW1pdCh0eXBlLCBldmVudCkge1xuICAgIHRoaXMuY2FsbGJhY2soe1xuICAgICAgdHlwZSxcbiAgICAgIGNlbnRlcjoge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgICB9LFxuICAgICAgc3JjRXZlbnQ6IGV2ZW50LFxuICAgICAgcG9pbnRlclR5cGU6ICdtb3VzZScsXG4gICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldFxuICAgIH0pO1xuICB9XG59IiwiaW1wb3J0IElucHV0IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IHsgSU5QVVRfRVZFTlRfVFlQRVMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuY29uc3Qge1xuICBLRVlfRVZFTlRTXG59ID0gSU5QVVRfRVZFTlRfVFlQRVM7XG5jb25zdCBET1dOX0VWRU5UX1RZUEUgPSAna2V5ZG93bic7XG5jb25zdCBVUF9FVkVOVF9UWVBFID0gJ2tleXVwJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtleUlucHV0IGV4dGVuZHMgSW5wdXQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHN1cGVyKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgICB0aGlzLmhhbmRsZUV2ZW50ID0gZXZlbnQgPT4ge1xuICAgICAgLy8gSWdub3JlIGlmIGZvY3VzZWQgb24gdGV4dCBpbnB1dFxuICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuICAgICAgaWYgKHRhcmdldEVsZW1lbnQudGFnTmFtZSA9PT0gJ0lOUFVUJyAmJiB0YXJnZXRFbGVtZW50LnR5cGUgPT09ICd0ZXh0JyB8fCB0YXJnZXRFbGVtZW50LnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZW5hYmxlRG93bkV2ZW50ICYmIGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrKHtcbiAgICAgICAgICB0eXBlOiBET1dOX0VWRU5UX1RZUEUsXG4gICAgICAgICAgc3JjRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIGtleTogZXZlbnQua2V5LFxuICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZW5hYmxlVXBFdmVudCAmJiBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soe1xuICAgICAgICAgIHR5cGU6IFVQX0VWRU5UX1RZUEUsXG4gICAgICAgICAgc3JjRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIGtleTogZXZlbnQua2V5LFxuICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5lbmFibGVEb3duRXZlbnQgPSB0aGlzLm9wdGlvbnMuZW5hYmxlO1xuICAgIHRoaXMuZW5hYmxlVXBFdmVudCA9IHRoaXMub3B0aW9ucy5lbmFibGU7XG4gICAgdGhpcy5ldmVudHMgPSAodGhpcy5vcHRpb25zLmV2ZW50cyB8fCBbXSkuY29uY2F0KEtFWV9FVkVOVFMpO1xuICAgIGVsZW1lbnQudGFiSW5kZXggPSB0aGlzLm9wdGlvbnMudGFiSW5kZXggfHwgMDtcbiAgICBlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XG4gICAgdGhpcy5ldmVudHMuZm9yRWFjaChldmVudCA9PiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuaGFuZGxlRXZlbnQpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuaGFuZGxlRXZlbnQpKTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIHRoaXMgaW5wdXQgKGJlZ2luIHByb2Nlc3NpbmcgZXZlbnRzKVxuICAgKiBpZiB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUgaXMgYW1vbmcgdGhvc2UgaGFuZGxlZCBieSB0aGlzIGlucHV0LlxuICAgKi9cbiAgZW5hYmxlRXZlbnRUeXBlKGV2ZW50VHlwZSwgZW5hYmxlZCkge1xuICAgIGlmIChldmVudFR5cGUgPT09IERPV05fRVZFTlRfVFlQRSkge1xuICAgICAgdGhpcy5lbmFibGVEb3duRXZlbnQgPSBlbmFibGVkO1xuICAgIH1cbiAgICBpZiAoZXZlbnRUeXBlID09PSBVUF9FVkVOVF9UWVBFKSB7XG4gICAgICB0aGlzLmVuYWJsZVVwRXZlbnQgPSBlbmFibGVkO1xuICAgIH1cbiAgfVxufSIsImltcG9ydCBJbnB1dCBmcm9tICcuL2lucHV0JztcbmNvbnN0IEVWRU5UX1RZUEUgPSAnY29udGV4dG1lbnUnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udGV4dG1lbnVJbnB1dCBleHRlbmRzIElucHV0IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBzdXBlcihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgdGhpcy5oYW5kbGVFdmVudCA9IGV2ZW50ID0+IHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuYWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxiYWNrKHtcbiAgICAgICAgdHlwZTogRVZFTlRfVFlQRSxcbiAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgICAgIH0sXG4gICAgICAgIHNyY0V2ZW50OiBldmVudCxcbiAgICAgICAgcG9pbnRlclR5cGU6ICdtb3VzZScsXG4gICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMuaGFuZGxlRXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGUgdGhpcyBpbnB1dCAoYmVnaW4gcHJvY2Vzc2luZyBldmVudHMpXG4gICAqIGlmIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZSBpcyBhbW9uZyB0aG9zZSBoYW5kbGVkIGJ5IHRoaXMgaW5wdXQuXG4gICAqL1xuICBlbmFibGVFdmVudFR5cGUoZXZlbnRUeXBlLCBlbmFibGVkKSB7XG4gICAgaWYgKGV2ZW50VHlwZSA9PT0gRVZFTlRfVFlQRSkge1xuICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZSA9IGVuYWJsZWQ7XG4gICAgfVxuICB9XG59IiwiLyogQ29uc3RhbnRzICovXG5jb25zdCBET1dOX0VWRU5UID0gMTtcbmNvbnN0IE1PVkVfRVZFTlQgPSAyO1xuY29uc3QgVVBfRVZFTlQgPSA0O1xuY29uc3QgTU9VU0VfRVZFTlRTID0ge1xuICBwb2ludGVyZG93bjogRE9XTl9FVkVOVCxcbiAgcG9pbnRlcm1vdmU6IE1PVkVfRVZFTlQsXG4gIHBvaW50ZXJ1cDogVVBfRVZFTlQsXG4gIG1vdXNlZG93bjogRE9XTl9FVkVOVCxcbiAgbW91c2Vtb3ZlOiBNT1ZFX0VWRU5ULFxuICBtb3VzZXVwOiBVUF9FVkVOVFxufTtcbi8vIE1vdXNlRXZlbnQuYnV0dG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L2J1dHRvblxuY29uc3QgTU9VU0VfRVZFTlRfQlVUVE9OX0xFRlQgPSAwO1xuY29uc3QgTU9VU0VfRVZFTlRfQlVUVE9OX01JRERMRSA9IDE7XG5jb25zdCBNT1VTRV9FVkVOVF9CVVRUT05fUklHSFQgPSAyO1xuLy8gTW91c2VFdmVudC5idXR0b25zIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L2J1dHRvbnNcbmNvbnN0IE1PVVNFX0VWRU5UX0JVVFRPTlNfTEVGVF9NQVNLID0gMTtcbmNvbnN0IE1PVVNFX0VWRU5UX0JVVFRPTlNfUklHSFRfTUFTSyA9IDI7XG5jb25zdCBNT1VTRV9FVkVOVF9CVVRUT05TX01JRERMRV9NQVNLID0gNDtcbi8qKlxuICogRXh0cmFjdCB0aGUgaW52b2x2ZWQgbW91c2UgYnV0dG9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aGljaEJ1dHRvbnMoZXZlbnQpIHtcbiAgY29uc3QgZXZlbnRUeXBlID0gTU9VU0VfRVZFTlRTW2V2ZW50LnNyY0V2ZW50LnR5cGVdO1xuICBpZiAoIWV2ZW50VHlwZSkge1xuICAgIC8vIE5vdCBhIG1vdXNlIGV2ZXRcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB7XG4gICAgYnV0dG9ucyxcbiAgICBidXR0b25cbiAgfSA9IGV2ZW50LnNyY0V2ZW50O1xuICBsZXQgbGVmdEJ1dHRvbiA9IGZhbHNlO1xuICBsZXQgbWlkZGxlQnV0dG9uID0gZmFsc2U7XG4gIGxldCByaWdodEJ1dHRvbiA9IGZhbHNlO1xuICBpZiAoZXZlbnRUeXBlID09PSBNT1ZFX0VWRU5UKSB7XG4gICAgbGVmdEJ1dHRvbiA9IEJvb2xlYW4oYnV0dG9ucyAmIE1PVVNFX0VWRU5UX0JVVFRPTlNfTEVGVF9NQVNLKTtcbiAgICBtaWRkbGVCdXR0b24gPSBCb29sZWFuKGJ1dHRvbnMgJiBNT1VTRV9FVkVOVF9CVVRUT05TX01JRERMRV9NQVNLKTtcbiAgICByaWdodEJ1dHRvbiA9IEJvb2xlYW4oYnV0dG9ucyAmIE1PVVNFX0VWRU5UX0JVVFRPTlNfUklHSFRfTUFTSyk7XG4gIH0gZWxzZSB7XG4gICAgbGVmdEJ1dHRvbiA9IGJ1dHRvbiA9PT0gTU9VU0VfRVZFTlRfQlVUVE9OX0xFRlQ7XG4gICAgbWlkZGxlQnV0dG9uID0gYnV0dG9uID09PSBNT1VTRV9FVkVOVF9CVVRUT05fTUlERExFO1xuICAgIHJpZ2h0QnV0dG9uID0gYnV0dG9uID09PSBNT1VTRV9FVkVOVF9CVVRUT05fUklHSFQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsZWZ0QnV0dG9uLFxuICAgIG1pZGRsZUJ1dHRvbixcbiAgICByaWdodEJ1dHRvblxuICB9O1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgZXZlbnQgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHJvb3QgZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T2Zmc2V0UG9zaXRpb24oZXZlbnQsIHJvb3RFbGVtZW50KSB7XG4gIGNvbnN0IGNlbnRlciA9IGV2ZW50LmNlbnRlcjtcbiAgLy8gYGNlbnRlcmAgaXMgYSBoYW1tZXIuanMgZXZlbnQgcHJvcGVydHlcbiAgaWYgKCFjZW50ZXIpIHtcbiAgICAvLyBOb3QgYSBnZXN0dXJhbCBldmVudFxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHJlY3QgPSByb290RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgLy8gRml4IHNjYWxlIGZvciBtYXAgYWZmZWN0ZWQgYnkgYSBDU1MgdHJhbnNmb3JtLlxuICAvLyBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2ODkzNjYzLzM1Mjg1MzNcbiAgY29uc3Qgc2NhbGVYID0gcmVjdC53aWR0aCAvIHJvb3RFbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XG4gIGNvbnN0IHNjYWxlWSA9IHJlY3QuaGVpZ2h0IC8gcm9vdEVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gIC8vIENhbGN1bGF0ZSBjZW50ZXIgcmVsYXRpdmUgdG8gdGhlIHJvb3QgZWxlbWVudFxuICBjb25zdCBvZmZzZXRDZW50ZXIgPSB7XG4gICAgeDogKGNlbnRlci54IC0gcmVjdC5sZWZ0IC0gcm9vdEVsZW1lbnQuY2xpZW50TGVmdCkgLyBzY2FsZVgsXG4gICAgeTogKGNlbnRlci55IC0gcmVjdC50b3AgLSByb290RWxlbWVudC5jbGllbnRUb3ApIC8gc2NhbGVZXG4gIH07XG4gIHJldHVybiB7XG4gICAgY2VudGVyLFxuICAgIG9mZnNldENlbnRlclxuICB9O1xufSIsImltcG9ydCB7IHdoaWNoQnV0dG9ucywgZ2V0T2Zmc2V0UG9zaXRpb24gfSBmcm9tICcuL2V2ZW50LXV0aWxzJztcbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgc3JjRWxlbWVudDogJ3Jvb3QnLFxuICBwcmlvcml0eTogMFxufTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50UmVnaXN0cmFyIHtcbiAgY29uc3RydWN0b3IoZXZlbnRNYW5hZ2VyKSB7XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBoYW1tZXJqcyBldmVudFxuICAgICAqL1xuICAgIHRoaXMuaGFuZGxlRXZlbnQgPSBldmVudCA9PiB7XG4gICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbWpvbG5pckV2ZW50ID0gdGhpcy5fbm9ybWFsaXplRXZlbnQoZXZlbnQpO1xuICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LnNyY0V2ZW50LnRhcmdldDtcbiAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBtam9sbmlyRXZlbnQucm9vdEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fZW1pdChtam9sbmlyRXZlbnQsIHRhcmdldCk7XG4gICAgICAgIGlmIChtam9sbmlyRXZlbnQuaGFuZGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VtaXQobWpvbG5pckV2ZW50LCAncm9vdCcpO1xuICAgIH07XG4gICAgdGhpcy5ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG4gICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIC8vIEVsZW1lbnQgLT4gaGFuZGxlciBtYXBcbiAgICB0aGlzLmhhbmRsZXJzQnlFbGVtZW50ID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICB9XG4gIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgbm8gbm9uLXBhc3NpdmUgaGFuZGxlcnNcbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gIXRoaXMuX2FjdGl2ZTtcbiAgfVxuICBhZGQodHlwZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGxldCBvbmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgICBsZXQgcGFzc2l2ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG4gICAgY29uc3Qge1xuICAgICAgaGFuZGxlcnMsXG4gICAgICBoYW5kbGVyc0J5RWxlbWVudFxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBvcHRzID0gREVGQVVMVF9PUFRJT05TO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycgfHwgb3B0aW9ucyAmJiBvcHRpb25zLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIC8vIGlzIERPTSBlbGVtZW50LCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBvcHRzID0ge1xuICAgICAgICAuLi5ERUZBVUxUX09QVElPTlMsXG4gICAgICAgIHNyY0VsZW1lbnQ6IG9wdGlvbnNcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChvcHRpb25zKSB7XG4gICAgICBvcHRzID0ge1xuICAgICAgICAuLi5ERUZBVUxUX09QVElPTlMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBlbnRyaWVzID0gaGFuZGxlcnNCeUVsZW1lbnQuZ2V0KG9wdHMuc3JjRWxlbWVudCk7XG4gICAgaWYgKCFlbnRyaWVzKSB7XG4gICAgICBlbnRyaWVzID0gW107XG4gICAgICBoYW5kbGVyc0J5RWxlbWVudC5zZXQob3B0cy5zcmNFbGVtZW50LCBlbnRyaWVzKTtcbiAgICB9XG4gICAgY29uc3QgZW50cnkgPSB7XG4gICAgICB0eXBlLFxuICAgICAgaGFuZGxlcixcbiAgICAgIHNyY0VsZW1lbnQ6IG9wdHMuc3JjRWxlbWVudCxcbiAgICAgIHByaW9yaXR5OiBvcHRzLnByaW9yaXR5XG4gICAgfTtcbiAgICBpZiAob25jZSkge1xuICAgICAgZW50cnkub25jZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChwYXNzaXZlKSB7XG4gICAgICBlbnRyeS5wYXNzaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgaGFuZGxlcnMucHVzaChlbnRyeSk7XG4gICAgdGhpcy5fYWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8ICFlbnRyeS5wYXNzaXZlO1xuICAgIC8vIFNvcnQgaGFuZGxlcnMgYnkgZGVzY2VuZGluZyBwcmlvcml0eVxuICAgIC8vIEhhbmRsZXJzIHdpdGggdGhlIHNhbWUgcHJpb3JpdHkgYXJlIGV4Y3V0ZWQgaW4gdGhlIG9yZGVyIG9mIHJlZ2lzdHJhdGlvblxuICAgIGxldCBpbnNlcnRQb3NpdGlvbiA9IGVudHJpZXMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoaW5zZXJ0UG9zaXRpb24gPj0gMCkge1xuICAgICAgaWYgKGVudHJpZXNbaW5zZXJ0UG9zaXRpb25dLnByaW9yaXR5ID49IGVudHJ5LnByaW9yaXR5KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaW5zZXJ0UG9zaXRpb24tLTtcbiAgICB9XG4gICAgZW50cmllcy5zcGxpY2UoaW5zZXJ0UG9zaXRpb24gKyAxLCAwLCBlbnRyeSk7XG4gIH1cbiAgcmVtb3ZlKHR5cGUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBoYW5kbGVycyxcbiAgICAgIGhhbmRsZXJzQnlFbGVtZW50XG4gICAgfSA9IHRoaXM7XG4gICAgZm9yIChsZXQgaSA9IGhhbmRsZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGhhbmRsZXJzW2ldO1xuICAgICAgaWYgKGVudHJ5LnR5cGUgPT09IHR5cGUgJiYgZW50cnkuaGFuZGxlciA9PT0gaGFuZGxlcikge1xuICAgICAgICBoYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBoYW5kbGVyc0J5RWxlbWVudC5nZXQoZW50cnkuc3JjRWxlbWVudCk7XG4gICAgICAgIGVudHJpZXMuc3BsaWNlKGVudHJpZXMuaW5kZXhPZihlbnRyeSksIDEpO1xuICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBoYW5kbGVyc0J5RWxlbWVudC5kZWxldGUoZW50cnkuc3JjRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fYWN0aXZlID0gaGFuZGxlcnMuc29tZShlbnRyeSA9PiAhZW50cnkucGFzc2l2ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEludm9rZSBoYW5kbGVycyBvbiBhIHBhcnRpY3VsYXIgZWxlbWVudFxuICAgKi9cbiAgX2VtaXQoZXZlbnQsIHNyY0VsZW1lbnQpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gdGhpcy5oYW5kbGVyc0J5RWxlbWVudC5nZXQoc3JjRWxlbWVudCk7XG4gICAgaWYgKGVudHJpZXMpIHtcbiAgICAgIGxldCBpbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcbiAgICAgIC8vIFByZXZlbnRzIHRoZSBjdXJyZW50IGV2ZW50IGZyb20gYnViYmxpbmcgdXBcbiAgICAgIGNvbnN0IHN0b3BQcm9wYWdhdGlvbiA9ICgpID0+IHtcbiAgICAgICAgZXZlbnQuaGFuZGxlZCA9IHRydWU7XG4gICAgICB9O1xuICAgICAgLy8gUHJldmVudCBhbnkgcmVtYWluaW5nIGxpc3RlbmVycyBmcm9tIGJlaW5nIGNhbGxlZFxuICAgICAgY29uc3Qgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gKCkgPT4ge1xuICAgICAgICBldmVudC5oYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBjb25zdCBlbnRyaWVzVG9SZW1vdmUgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIG9uY2VcbiAgICAgICAgfSA9IGVudHJpZXNbaV07XG4gICAgICAgIGhhbmRsZXIoe1xuICAgICAgICAgIC4uLmV2ZW50LFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbixcbiAgICAgICAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvbmNlKSB7XG4gICAgICAgICAgZW50cmllc1RvUmVtb3ZlLnB1c2goZW50cmllc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJpZXNUb1JlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBoYW5kbGVyXG4gICAgICAgIH0gPSBlbnRyaWVzVG9SZW1vdmVbaV07XG4gICAgICAgIHRoaXMucmVtb3ZlKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogTm9ybWFsaXplcyBoYW1tZXJqcyBhbmQgY3VzdG9tIGV2ZW50cyB0byBoYXZlIHByZWRpY3RhYmxlIGZpZWxkcy5cbiAgICovXG4gIF9ub3JtYWxpemVFdmVudChldmVudCkge1xuICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gdGhpcy5ldmVudE1hbmFnZXIuZ2V0RWxlbWVudCgpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5ldmVudCxcbiAgICAgIC4uLndoaWNoQnV0dG9ucyhldmVudCksXG4gICAgICAuLi5nZXRPZmZzZXRQb3NpdGlvbihldmVudCwgcm9vdEVsZW1lbnQpLFxuICAgICAgcHJldmVudERlZmF1bHQ6ICgpID0+IHtcbiAgICAgICAgZXZlbnQuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sXG4gICAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IG51bGwsXG4gICAgICBzdG9wUHJvcGFnYXRpb246IG51bGwsXG4gICAgICBoYW5kbGVkOiBmYWxzZSxcbiAgICAgIHJvb3RFbGVtZW50XG4gICAgfTtcbiAgfVxufSIsImltcG9ydCB7IE1hbmFnZXIgfSBmcm9tICcuL3V0aWxzL2hhbW1lcic7XG5pbXBvcnQgV2hlZWxJbnB1dCBmcm9tICcuL2lucHV0cy93aGVlbC1pbnB1dCc7XG5pbXBvcnQgTW92ZUlucHV0IGZyb20gJy4vaW5wdXRzL21vdmUtaW5wdXQnO1xuaW1wb3J0IEtleUlucHV0IGZyb20gJy4vaW5wdXRzL2tleS1pbnB1dCc7XG5pbXBvcnQgQ29udGV4dG1lbnVJbnB1dCBmcm9tICcuL2lucHV0cy9jb250ZXh0bWVudS1pbnB1dCc7XG5pbXBvcnQgRXZlbnRSZWdpc3RyYXIgZnJvbSAnLi91dGlscy9ldmVudC1yZWdpc3RyYXInO1xuaW1wb3J0IHsgQkFTSUNfRVZFTlRfQUxJQVNFUywgRVZFTlRfUkVDT0dOSVpFUl9NQVAsIEdFU1RVUkVfRVZFTlRfQUxJQVNFUywgUkVDT0dOSVpFUlMsIFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVAsIFJFQ09HTklaRVJfRkFMTEJBQ0tfTUFQIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICAvLyBldmVudCBoYW5kbGVyc1xuICBldmVudHM6IG51bGwsXG4gIC8vIGN1c3RvbSByZWNvZ25pemVyc1xuICByZWNvZ25pemVyczogbnVsbCxcbiAgcmVjb2duaXplck9wdGlvbnM6IHt9LFxuICAvLyBNYW5hZ2VyIGNsYXNzXG4gIE1hbmFnZXIsXG4gIC8vIGFsbG93IGJyb3dzZXIgZGVmYXVsdCB0b3VjaCBhY3Rpb25cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ViZXIvcmVhY3QtbWFwLWdsL2lzc3Vlcy81MDZcbiAgdG91Y2hBY3Rpb246ICdub25lJyxcbiAgdGFiSW5kZXg6IDBcbn07XG4vLyBVbmlmaWVkIEFQSSBmb3Igc3Vic2NyaWJpbmcgdG8gZXZlbnRzIGFib3V0IGJvdGhcbi8vIGJhc2ljIGlucHV0IGV2ZW50cyAoZS5nLiAnbW91c2Vtb3ZlJywgJ3RvdWNoc3RhcnQnLCAnd2hlZWwnKVxuLy8gYW5kIGdlc3R1cmFsIGlucHV0IChlLmcuICdjbGljaycsICd0YXAnLCAncGFuc3RhcnQnKS5cbi8vIERlbGVnYXRlcyBnZXN0dXJlIHJlbGF0ZWQgZXZlbnQgcmVnaXN0cmF0aW9uIGFuZCBoYW5kbGluZyB0byBIYW1tZXIuanMuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgZWxlbWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBiYXNpYyBldmVudHMgdXNpbmcgdGhlICdoYW1tZXIuaW5wdXQnIEhhbW1lci5qcyBBUEk6XG4gICAgICogQmVmb3JlIHJ1bm5pbmcgUmVjb2duaXplcnMsIEhhbW1lciBlbWl0cyBhICdoYW1tZXIuaW5wdXQnIGV2ZW50XG4gICAgICogd2l0aCB0aGUgYmFzaWMgZXZlbnQgaW5mby4gVGhpcyBmdW5jdGlvbiBlbWl0cyBhbGwgYmFzaWMgZXZlbnRzXG4gICAgICogYWxpYXNlZCB0byB0aGUgXCJjbGFzc1wiIG9mIGV2ZW50IHJlY2VpdmVkLlxuICAgICAqIFNlZSBjb25zdGFudHMuQkFTSUNfRVZFTlRfQ0xBU1NFUyBiYXNpYyBldmVudCBjbGFzcyBkZWZpbml0aW9ucy5cbiAgICAgKi9cbiAgICB0aGlzLl9vbkJhc2ljSW5wdXQgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNyY0V2ZW50XG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICBjb25zdCBhbGlhcyA9IEJBU0lDX0VWRU5UX0FMSUFTRVNbc3JjRXZlbnQudHlwZV07XG4gICAgICBpZiAoYWxpYXMpIHtcbiAgICAgICAgLy8gZmlyZSBhbGwgZXZlbnRzIGFsaWFzZWQgdG8gc3JjRXZlbnQudHlwZVxuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdChhbGlhcywgZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGV2ZW50cyBub3Qgc3VwcG9ydGVkIGJ5IEhhbW1lci5qcyxcbiAgICAgKiBhbmQgcGlwZSBiYWNrIG91dCB0aHJvdWdoIHNhbWUgKEhhbW1lcikgY2hhbm5lbCB1c2VkIGJ5IG90aGVyIGV2ZW50cy5cbiAgICAgKi9cbiAgICB0aGlzLl9vbk90aGVyRXZlbnQgPSBldmVudCA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnb25vdGhlcmV2ZW50JywgZXZlbnQudHlwZSwgZXZlbnQpXG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdChldmVudC50eXBlLCBldmVudCk7XG4gICAgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi5ERUZBVUxUX09QVElPTlMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnNldEVsZW1lbnQoZWxlbWVudCk7XG4gICAgLy8gUmVnaXN0ZXIgYWxsIHBhc3NlZCBldmVudHMuXG4gICAgY29uc3Qge1xuICAgICAgZXZlbnRzXG4gICAgfSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoZXZlbnRzKSB7XG4gICAgICB0aGlzLm9uKGV2ZW50cyk7XG4gICAgfVxuICB9XG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgfVxuICBzZXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICAvLyB1bnJlZ2lzdGVyIGFsbCBldmVudHNcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBvcHRpb25zXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgTWFuYWdlckNsYXNzID0gb3B0aW9ucy5NYW5hZ2VyO1xuICAgIHRoaXMubWFuYWdlciA9IG5ldyBNYW5hZ2VyQ2xhc3MoZWxlbWVudCwge1xuICAgICAgdG91Y2hBY3Rpb246IG9wdGlvbnMudG91Y2hBY3Rpb24sXG4gICAgICByZWNvZ25pemVyczogb3B0aW9ucy5yZWNvZ25pemVycyB8fCBSRUNPR05JWkVSU1xuICAgIH0pLm9uKCdoYW1tZXIuaW5wdXQnLCB0aGlzLl9vbkJhc2ljSW5wdXQpO1xuICAgIGlmICghb3B0aW9ucy5yZWNvZ25pemVycykge1xuICAgICAgLy8gU2V0IGRlZmF1bHQgcmVjb2duaXplIHdpdGhzXG4gICAgICAvLyBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL3JlY29nbml6ZS13aXRoL1xuICAgICAgT2JqZWN0LmtleXMoUkVDT0dOSVpFUl9DT01QQVRJQkxFX01BUCkuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgY29uc3QgcmVjb2duaXplciA9IHRoaXMubWFuYWdlci5nZXQobmFtZSk7XG4gICAgICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICAgICAgUkVDT0dOSVpFUl9DT01QQVRJQkxFX01BUFtuYW1lXS5mb3JFYWNoKG90aGVyTmFtZSA9PiB7XG4gICAgICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgob3RoZXJOYW1lKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFNldCByZWNvZ25pemVyIG9wdGlvbnNcbiAgICBmb3IgKGNvbnN0IHJlY29nbml6ZXJOYW1lIGluIG9wdGlvbnMucmVjb2duaXplck9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHJlY29nbml6ZXIgPSB0aGlzLm1hbmFnZXIuZ2V0KHJlY29nbml6ZXJOYW1lKTtcbiAgICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICAgIGNvbnN0IHJlY29nbml6ZXJPcHRpb24gPSBvcHRpb25zLnJlY29nbml6ZXJPcHRpb25zW3JlY29nbml6ZXJOYW1lXTtcbiAgICAgICAgLy8gYGVuYWJsZWAgaXMgbWFuYWdlZCBieSB0aGUgZXZlbnQgcmVnaXN0cmF0aW9uc1xuICAgICAgICBkZWxldGUgcmVjb2duaXplck9wdGlvbi5lbmFibGU7XG4gICAgICAgIHJlY29nbml6ZXIuc2V0KHJlY29nbml6ZXJPcHRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBIYW5kbGUgZXZlbnRzIG5vdCBoYW5kbGVkIGJ5IEhhbW1lci5qczpcbiAgICAvLyAtIG1vdXNlIHdoZWVsXG4gICAgLy8gLSBwb2ludGVyL3RvdWNoL21vdXNlIG1vdmVcbiAgICB0aGlzLndoZWVsSW5wdXQgPSBuZXcgV2hlZWxJbnB1dChlbGVtZW50LCB0aGlzLl9vbk90aGVyRXZlbnQsIHtcbiAgICAgIGVuYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLm1vdmVJbnB1dCA9IG5ldyBNb3ZlSW5wdXQoZWxlbWVudCwgdGhpcy5fb25PdGhlckV2ZW50LCB7XG4gICAgICBlbmFibGU6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5rZXlJbnB1dCA9IG5ldyBLZXlJbnB1dChlbGVtZW50LCB0aGlzLl9vbk90aGVyRXZlbnQsIHtcbiAgICAgIGVuYWJsZTogZmFsc2UsXG4gICAgICB0YWJJbmRleDogb3B0aW9ucy50YWJJbmRleFxuICAgIH0pO1xuICAgIHRoaXMuY29udGV4dG1lbnVJbnB1dCA9IG5ldyBDb250ZXh0bWVudUlucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge1xuICAgICAgZW5hYmxlOiBmYWxzZVxuICAgIH0pO1xuICAgIC8vIFJlZ2lzdGVyIGFsbCBleGlzdGluZyBldmVudHNcbiAgICBmb3IgKGNvbnN0IFtldmVudEFsaWFzLCBldmVudFJlZ2lzdHJhcl0gb2YgdGhpcy5ldmVudHMpIHtcbiAgICAgIGlmICghZXZlbnRSZWdpc3RyYXIuaXNFbXB0eSgpKSB7XG4gICAgICAgIC8vIEVuYWJsZSByZWNvZ25pemVyIGZvciB0aGlzIGV2ZW50LlxuICAgICAgICB0aGlzLl90b2dnbGVSZWNvZ25pemVyKGV2ZW50UmVnaXN0cmFyLnJlY29nbml6ZXJOYW1lLCB0cnVlKTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLm9uKGV2ZW50QWxpYXMsIGV2ZW50UmVnaXN0cmFyLmhhbmRsZUV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gVGVhciBkb3duIGludGVybmFsIGV2ZW50IG1hbmFnZW1lbnQgaW1wbGVtZW50YXRpb25zLlxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgIC8vIHdoZWVsSW5wdXQgZXRjLiBhcmUgY3JlYXRlZCBpbiBzZXRFbGVtZW50KCkgYW5kIHRoZXJlZm9yZVxuICAgICAgLy8gY2Fubm90IGV4aXN0IGlmIHRoZXJlIGlzIG5vIGVsZW1lbnRcbiAgICAgIHRoaXMud2hlZWxJbnB1dC5kZXN0cm95KCk7XG4gICAgICB0aGlzLm1vdmVJbnB1dC5kZXN0cm95KCk7XG4gICAgICB0aGlzLmtleUlucHV0LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuY29udGV4dG1lbnVJbnB1dC5kZXN0cm95KCk7XG4gICAgICB0aGlzLm1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy53aGVlbElucHV0ID0gbnVsbDtcbiAgICAgIHRoaXMubW92ZUlucHV0ID0gbnVsbDtcbiAgICAgIHRoaXMua2V5SW5wdXQgPSBudWxsO1xuICAgICAgdGhpcy5jb250ZXh0bWVudUlucHV0ID0gbnVsbDtcbiAgICAgIHRoaXMubWFuYWdlciA9IG51bGw7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKiogUmVnaXN0ZXIgYW4gZXZlbnQgaGFuZGxlciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYGV2ZW50YCAqL1xuICBvbihldmVudCwgaGFuZGxlciwgb3B0cykge1xuICAgIHRoaXMuX2FkZEV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlciwgb3B0cywgZmFsc2UpO1xuICB9XG4gIG9uY2UoZXZlbnQsIGhhbmRsZXIsIG9wdHMpIHtcbiAgICB0aGlzLl9hZGRFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIsIG9wdHMsIHRydWUpO1xuICB9XG4gIHdhdGNoKGV2ZW50LCBoYW5kbGVyLCBvcHRzKSB7XG4gICAgdGhpcy5fYWRkRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBvcHRzLCBmYWxzZSwgdHJ1ZSk7XG4gIH1cbiAgb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgdGhpcy5fcmVtb3ZlRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgfVxuICAvKlxuICAgKiBFbmFibGUvZGlzYWJsZSByZWNvZ25pemVyIGZvciB0aGUgZ2l2ZW4gZXZlbnRcbiAgICovXG4gIF90b2dnbGVSZWNvZ25pemVyKG5hbWUsIGVuYWJsZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBtYW5hZ2VyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtYW5hZ2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlY29nbml6ZXIgPSBtYW5hZ2VyLmdldChuYW1lKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHJlY29nbml6ZXIgJiYgcmVjb2duaXplci5vcHRpb25zLmVuYWJsZSAhPT0gZW5hYmxlZCkge1xuICAgICAgcmVjb2duaXplci5zZXQoe1xuICAgICAgICBlbmFibGU6IGVuYWJsZWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZmFsbGJhY2tSZWNvZ25pemVycyA9IFJFQ09HTklaRVJfRkFMTEJBQ0tfTUFQW25hbWVdO1xuICAgICAgaWYgKGZhbGxiYWNrUmVjb2duaXplcnMgJiYgIXRoaXMub3B0aW9ucy5yZWNvZ25pemVycykge1xuICAgICAgICAvLyBTZXQgZGVmYXVsdCByZXF1aXJlIGZhaWx1cmVzXG4gICAgICAgIC8vIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vcmVxdWlyZS1mYWlsdXJlL1xuICAgICAgICBmYWxsYmFja1JlY29nbml6ZXJzLmZvckVhY2gob3RoZXJOYW1lID0+IHtcbiAgICAgICAgICBjb25zdCBvdGhlclJlY29nbml6ZXIgPSBtYW5hZ2VyLmdldChvdGhlck5hbWUpO1xuICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBXYWl0IGZvciB0aGlzIHJlY29nbml6ZXIgdG8gZmFpbFxuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKG5hbWUpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIHNlZW1zIHRvIGJlIGEgYnVnIGluIGhhbW1lcmpzOlxuICAgICAgICAgICAgICogcmVxdWlyZUZhaWx1cmUoKSBhZGRzIGJvdGggd2F5c1xuICAgICAgICAgICAgICogZHJvcFJlcXVpcmVGYWlsdXJlKCkgb25seSBkcm9wcyBvbmUgd2F5XG4gICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vaGFtbWVyanMvaGFtbWVyLmpzL2Jsb2IvbWFzdGVyL3NyYy9yZWNvZ25pemVyanMvXG4gICAgICAgICAgICAgICByZWNvZ25pemVyLWNvbnN0cnVjdG9yLmpzI0wxMzZcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVjb2duaXplci5kcm9wUmVxdWlyZUZhaWx1cmUob3RoZXJOYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRG8gbm90IHdhaXQgZm9yIHRoaXMgcmVjb2duaXplciB0byBmYWlsXG4gICAgICAgICAgICBvdGhlclJlY29nbml6ZXIuZHJvcFJlcXVpcmVGYWlsdXJlKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMud2hlZWxJbnB1dC5lbmFibGVFdmVudFR5cGUobmFtZSwgZW5hYmxlZCk7XG4gICAgdGhpcy5tb3ZlSW5wdXQuZW5hYmxlRXZlbnRUeXBlKG5hbWUsIGVuYWJsZWQpO1xuICAgIHRoaXMua2V5SW5wdXQuZW5hYmxlRXZlbnRUeXBlKG5hbWUsIGVuYWJsZWQpO1xuICAgIHRoaXMuY29udGV4dG1lbnVJbnB1dC5lbmFibGVFdmVudFR5cGUobmFtZSwgZW5hYmxlZCk7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgdGhlIGV2ZW50IHJlZ2lzdHJhdGlvbiBmb3IgYSBzaW5nbGUgZXZlbnQgKyBoYW5kbGVyLlxuICAgKi9cbiAgX2FkZEV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlciwgb3B0cywgb25jZSwgcGFzc2l2ZSkge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBvcHRzID0gaGFuZGxlcjtcbiAgICAgIC8vIElmIGBldmVudGAgaXMgYSBtYXAsIGNhbGwgYG9uKClgIGZvciBlYWNoIGVudHJ5LlxuICAgICAgZm9yIChjb25zdCBldmVudE5hbWUgaW4gZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fYWRkRXZlbnRIYW5kbGVyKGV2ZW50TmFtZSwgZXZlbnRbZXZlbnROYW1lXSwgb3B0cywgb25jZSwgcGFzc2l2ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG1hbmFnZXIsXG4gICAgICBldmVudHNcbiAgICB9ID0gdGhpcztcbiAgICAvLyBBbGlhcyB0byBhIHJlY29nbml6ZWQgZ2VzdHVyZSBhcyBuZWNlc3NhcnkuXG4gICAgY29uc3QgZXZlbnRBbGlhcyA9IEdFU1RVUkVfRVZFTlRfQUxJQVNFU1tldmVudF0gfHwgZXZlbnQ7XG4gICAgbGV0IGV2ZW50UmVnaXN0cmFyID0gZXZlbnRzLmdldChldmVudEFsaWFzKTtcbiAgICBpZiAoIWV2ZW50UmVnaXN0cmFyKSB7XG4gICAgICBldmVudFJlZ2lzdHJhciA9IG5ldyBFdmVudFJlZ2lzdHJhcih0aGlzKTtcbiAgICAgIGV2ZW50cy5zZXQoZXZlbnRBbGlhcywgZXZlbnRSZWdpc3RyYXIpO1xuICAgICAgLy8gRW5hYmxlIHJlY29nbml6ZXIgZm9yIHRoaXMgZXZlbnQuXG4gICAgICBldmVudFJlZ2lzdHJhci5yZWNvZ25pemVyTmFtZSA9IEVWRU5UX1JFQ09HTklaRVJfTUFQW2V2ZW50QWxpYXNdIHx8IGV2ZW50QWxpYXM7XG4gICAgICAvLyBMaXN0ZW4gdG8gdGhlIGV2ZW50XG4gICAgICBpZiAobWFuYWdlcikge1xuICAgICAgICBtYW5hZ2VyLm9uKGV2ZW50QWxpYXMsIGV2ZW50UmVnaXN0cmFyLmhhbmRsZUV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXZlbnRSZWdpc3RyYXIuYWRkKGV2ZW50LCBoYW5kbGVyLCBvcHRzLCBvbmNlLCBwYXNzaXZlKTtcbiAgICBpZiAoIWV2ZW50UmVnaXN0cmFyLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5fdG9nZ2xlUmVjb2duaXplcihldmVudFJlZ2lzdHJhci5yZWNvZ25pemVyTmFtZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBldmVudCBkZXJlZ2lzdHJhdGlvbiBmb3IgYSBzaW5nbGUgZXZlbnQgKyBoYW5kbGVyLlxuICAgKi9cbiAgX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiBgZXZlbnRgIGlzIGEgbWFwLCBjYWxsIGBvZmYoKWAgZm9yIGVhY2ggZW50cnkuXG4gICAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBpbiBldmVudCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXIoZXZlbnROYW1lLCBldmVudFtldmVudE5hbWVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZXZlbnRzXG4gICAgfSA9IHRoaXM7XG4gICAgLy8gQWxpYXMgdG8gYSByZWNvZ25pemVkIGdlc3R1cmUgYXMgbmVjZXNzYXJ5LlxuICAgIGNvbnN0IGV2ZW50QWxpYXMgPSBHRVNUVVJFX0VWRU5UX0FMSUFTRVNbZXZlbnRdIHx8IGV2ZW50O1xuICAgIGNvbnN0IGV2ZW50UmVnaXN0cmFyID0gZXZlbnRzLmdldChldmVudEFsaWFzKTtcbiAgICBpZiAoIWV2ZW50UmVnaXN0cmFyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50UmVnaXN0cmFyLnJlbW92ZShldmVudCwgaGFuZGxlcik7XG4gICAgaWYgKGV2ZW50UmVnaXN0cmFyLmlzRW1wdHkoKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWNvZ25pemVyTmFtZVxuICAgICAgfSA9IGV2ZW50UmVnaXN0cmFyO1xuICAgICAgLy8gRGlzYWJsZSByZWNvZ25pemVyIGlmIG5vIG1vcmUgaGFuZGxlcnMgYXJlIGF0dGFjaGVkIHRvIGl0cyBldmVudHNcbiAgICAgIGxldCBpc1JlY29nbml6ZXJVc2VkID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IGVoIG9mIGV2ZW50cy52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoZWgucmVjb2duaXplck5hbWUgPT09IHJlY29nbml6ZXJOYW1lICYmICFlaC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICBpc1JlY29nbml6ZXJVc2VkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc1JlY29nbml6ZXJVc2VkKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZVJlY29nbml6ZXIocmVjb2duaXplck5hbWUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0iLCJleHBvcnQgeyBkZWZhdWx0IGFzIEV2ZW50TWFuYWdlciB9IGZyb20gJy4vZXZlbnQtbWFuYWdlcic7IiwiaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5pbXBvcnQgTWFwU3RhdGUgZnJvbSAnLi9tYXAtc3RhdGUnO1xuaW1wb3J0IHsgTGluZWFySW50ZXJwb2xhdG9yIH0gZnJvbSAnLi90cmFuc2l0aW9uJztcbmltcG9ydCBUcmFuc2l0aW9uTWFuYWdlciwgeyBUUkFOU0lUSU9OX0VWRU5UUyB9IGZyb20gJy4vdHJhbnNpdGlvbi1tYW5hZ2VyJztcbnZhciBOT19UUkFOU0lUSU9OX1BST1BTID0ge1xuICB0cmFuc2l0aW9uRHVyYXRpb246IDBcbn07XG5leHBvcnQgdmFyIExJTkVBUl9UUkFOU0lUSU9OX1BST1BTID0ge1xuICB0cmFuc2l0aW9uRHVyYXRpb246IDMwMCxcbiAgdHJhbnNpdGlvbkVhc2luZzogZnVuY3Rpb24gdHJhbnNpdGlvbkVhc2luZyh0KSB7XG4gICAgcmV0dXJuIHQ7XG4gIH0sXG4gIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IG5ldyBMaW5lYXJJbnRlcnBvbGF0b3IoKSxcbiAgdHJhbnNpdGlvbkludGVycnVwdGlvbjogVFJBTlNJVElPTl9FVkVOVFMuQlJFQUtcbn07XG52YXIgREVGQVVMVF9JTkVSVElBID0gMzAwO1xudmFyIElORVJUSUFfRUFTSU5HID0gZnVuY3Rpb24gSU5FUlRJQV9FQVNJTkcodCkge1xuICByZXR1cm4gMSAtICgxIC0gdCkgKiAoMSAtIHQpO1xufTtcbnZhciBFVkVOVF9UWVBFUyA9IHtcbiAgV0hFRUw6IFsnd2hlZWwnXSxcbiAgUEFOOiBbJ3BhbnN0YXJ0JywgJ3Bhbm1vdmUnLCAncGFuZW5kJ10sXG4gIFBJTkNIOiBbJ3BpbmNoc3RhcnQnLCAncGluY2htb3ZlJywgJ3BpbmNoZW5kJ10sXG4gIFRSSVBMRV9QQU46IFsndHJpcGFuc3RhcnQnLCAndHJpcGFubW92ZScsICd0cmlwYW5lbmQnXSxcbiAgRE9VQkxFX1RBUDogWydkb3VibGV0YXAnXSxcbiAgS0VZQk9BUkQ6IFsna2V5ZG93biddXG59O1xudmFyIE1hcENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hcENvbnRyb2xsZXIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFwQ29udHJvbGxlcik7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXZlbnRzXCIsIFtdKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzY3JvbGxab29tXCIsIHRydWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRyYWdQYW5cIiwgdHJ1ZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZHJhZ1JvdGF0ZVwiLCB0cnVlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb3VibGVDbGlja1pvb21cIiwgdHJ1ZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG91Y2hab29tXCIsIHRydWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvdWNoUm90YXRlXCIsIGZhbHNlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJrZXlib2FyZFwiLCB0cnVlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW50ZXJhY3Rpb25TdGF0ZVwiLCB7XG4gICAgICBpc0RyYWdnaW5nOiBmYWxzZVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9ldmVudHNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zZXRJbnRlcmFjdGlvblN0YXRlXCIsIGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihfdGhpcy5faW50ZXJhY3Rpb25TdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgaWYgKF90aGlzLm9uU3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMub25TdGF0ZUNoYW5nZShfdGhpcy5faW50ZXJhY3Rpb25TdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX29uVHJhbnNpdGlvblwiLCBmdW5jdGlvbiAobmV3Vmlld3BvcnQsIG9sZFZpZXdwb3J0KSB7XG4gICAgICBfdGhpcy5vblZpZXdwb3J0Q2hhbmdlKG5ld1ZpZXdwb3J0LCBfdGhpcy5faW50ZXJhY3Rpb25TdGF0ZSwgb2xkVmlld3BvcnQpO1xuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlRXZlbnQgPSB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fdHJhbnNpdGlvbk1hbmFnZXIgPSBuZXcgVHJhbnNpdGlvbk1hbmFnZXIoe1xuICAgICAgb25WaWV3cG9ydENoYW5nZTogdGhpcy5fb25UcmFuc2l0aW9uLFxuICAgICAgb25TdGF0ZUNoYW5nZTogdGhpcy5fc2V0SW50ZXJhY3Rpb25TdGF0ZVxuICAgIH0pO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhNYXBDb250cm9sbGVyLCBbe1xuICAgIGtleTogXCJoYW5kbGVFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgdGhpcy5tYXBTdGF0ZSA9IHRoaXMuZ2V0TWFwU3RhdGUoKTtcbiAgICAgIHZhciBldmVudFN0YXJ0QmxvY2tlZCA9IHRoaXMuX2V2ZW50U3RhcnRCbG9ja2VkO1xuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3BhbnN0YXJ0JzpcbiAgICAgICAgICByZXR1cm4gZXZlbnRTdGFydEJsb2NrZWQgPyBmYWxzZSA6IHRoaXMuX29uUGFuU3RhcnQoZXZlbnQpO1xuICAgICAgICBjYXNlICdwYW5tb3ZlJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb25QYW4oZXZlbnQpO1xuICAgICAgICBjYXNlICdwYW5lbmQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9vblBhbkVuZChldmVudCk7XG4gICAgICAgIGNhc2UgJ3BpbmNoc3RhcnQnOlxuICAgICAgICAgIHJldHVybiBldmVudFN0YXJ0QmxvY2tlZCA/IGZhbHNlIDogdGhpcy5fb25QaW5jaFN0YXJ0KGV2ZW50KTtcbiAgICAgICAgY2FzZSAncGluY2htb3ZlJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb25QaW5jaChldmVudCk7XG4gICAgICAgIGNhc2UgJ3BpbmNoZW5kJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb25QaW5jaEVuZChldmVudCk7XG4gICAgICAgIGNhc2UgJ3RyaXBhbnN0YXJ0JzpcbiAgICAgICAgICByZXR1cm4gZXZlbnRTdGFydEJsb2NrZWQgPyBmYWxzZSA6IHRoaXMuX29uVHJpcGxlUGFuU3RhcnQoZXZlbnQpO1xuICAgICAgICBjYXNlICd0cmlwYW5tb3ZlJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb25UcmlwbGVQYW4oZXZlbnQpO1xuICAgICAgICBjYXNlICd0cmlwYW5lbmQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9vblRyaXBsZVBhbkVuZChldmVudCk7XG4gICAgICAgIGNhc2UgJ2RvdWJsZXRhcCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29uRG91YmxlVGFwKGV2ZW50KTtcbiAgICAgICAgY2FzZSAnd2hlZWwnOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9vbldoZWVsKGV2ZW50KTtcbiAgICAgICAgY2FzZSAna2V5ZG93bic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29uS2V5RG93bihldmVudCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDZW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2VudGVyKGV2ZW50KSB7XG4gICAgICB2YXIgX2V2ZW50JG9mZnNldENlbnRlciA9IGV2ZW50Lm9mZnNldENlbnRlcixcbiAgICAgICAgeCA9IF9ldmVudCRvZmZzZXRDZW50ZXIueCxcbiAgICAgICAgeSA9IF9ldmVudCRvZmZzZXRDZW50ZXIueTtcbiAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRnVuY3Rpb25LZXlQcmVzc2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KSB7XG4gICAgICB2YXIgc3JjRXZlbnQgPSBldmVudC5zcmNFdmVudDtcbiAgICAgIHJldHVybiBCb29sZWFuKHNyY0V2ZW50Lm1ldGFLZXkgfHwgc3JjRXZlbnQuYWx0S2V5IHx8IHNyY0V2ZW50LmN0cmxLZXkgfHwgc3JjRXZlbnQuc2hpZnRLZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJibG9ja0V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBibG9ja0V2ZW50cyh0aW1lb3V0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMyLl9ldmVudFN0YXJ0QmxvY2tlZCA9PT0gdGltZXIpIHtcbiAgICAgICAgICBfdGhpczIuX2V2ZW50U3RhcnRCbG9ja2VkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSwgdGltZW91dCk7XG4gICAgICB0aGlzLl9ldmVudFN0YXJ0QmxvY2tlZCA9IHRpbWVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVWaWV3cG9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgZXh0cmFQcm9wcywgaW50ZXJhY3Rpb25TdGF0ZSkge1xuICAgICAgdmFyIG9sZFZpZXdwb3J0ID0gdGhpcy5tYXBTdGF0ZSBpbnN0YW5jZW9mIE1hcFN0YXRlID8gdGhpcy5tYXBTdGF0ZS5nZXRWaWV3cG9ydFByb3BzKCkgOiB0aGlzLm1hcFN0YXRlO1xuICAgICAgdmFyIG5ld1ZpZXdwb3J0ID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBuZXdNYXBTdGF0ZS5nZXRWaWV3cG9ydFByb3BzKCkpLCBleHRyYVByb3BzKTtcbiAgICAgIHZhciB2aWV3U3RhdGVDaGFuZ2VkID0gT2JqZWN0LmtleXMobmV3Vmlld3BvcnQpLnNvbWUoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gb2xkVmlld3BvcnRba2V5XSAhPT0gbmV3Vmlld3BvcnRba2V5XTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc3RhdGUgPSBuZXdNYXBTdGF0ZS5nZXRTdGF0ZSgpO1xuICAgICAgdGhpcy5fc2V0SW50ZXJhY3Rpb25TdGF0ZShpbnRlcmFjdGlvblN0YXRlKTtcbiAgICAgIGlmICh2aWV3U3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMub25WaWV3cG9ydENoYW5nZShuZXdWaWV3cG9ydCwgdGhpcy5faW50ZXJhY3Rpb25TdGF0ZSwgb2xkVmlld3BvcnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXBTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXBTdGF0ZShvdmVycmlkZXMpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwU3RhdGUoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMubWFwU3RhdGVQcm9wcyksIHRoaXMuX3N0YXRlKSwgb3ZlcnJpZGVzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRHJhZ2dpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNEcmFnZ2luZygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnRlcmFjdGlvblN0YXRlLmlzRHJhZ2dpbmc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgb25WaWV3cG9ydENoYW5nZSA9IG9wdGlvbnMub25WaWV3cG9ydENoYW5nZSxcbiAgICAgICAgb25TdGF0ZUNoYW5nZSA9IG9wdGlvbnMub25TdGF0ZUNoYW5nZSxcbiAgICAgICAgX29wdGlvbnMkZXZlbnRNYW5hZ2VyID0gb3B0aW9ucy5ldmVudE1hbmFnZXIsXG4gICAgICAgIGV2ZW50TWFuYWdlciA9IF9vcHRpb25zJGV2ZW50TWFuYWdlciA9PT0gdm9pZCAwID8gdGhpcy5ldmVudE1hbmFnZXIgOiBfb3B0aW9ucyRldmVudE1hbmFnZXIsXG4gICAgICAgIF9vcHRpb25zJGlzSW50ZXJhY3RpdiA9IG9wdGlvbnMuaXNJbnRlcmFjdGl2ZSxcbiAgICAgICAgaXNJbnRlcmFjdGl2ZSA9IF9vcHRpb25zJGlzSW50ZXJhY3RpdiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGlzSW50ZXJhY3RpdixcbiAgICAgICAgX29wdGlvbnMkc2Nyb2xsWm9vbSA9IG9wdGlvbnMuc2Nyb2xsWm9vbSxcbiAgICAgICAgc2Nyb2xsWm9vbSA9IF9vcHRpb25zJHNjcm9sbFpvb20gPT09IHZvaWQgMCA/IHRoaXMuc2Nyb2xsWm9vbSA6IF9vcHRpb25zJHNjcm9sbFpvb20sXG4gICAgICAgIF9vcHRpb25zJGRyYWdQYW4gPSBvcHRpb25zLmRyYWdQYW4sXG4gICAgICAgIGRyYWdQYW4gPSBfb3B0aW9ucyRkcmFnUGFuID09PSB2b2lkIDAgPyB0aGlzLmRyYWdQYW4gOiBfb3B0aW9ucyRkcmFnUGFuLFxuICAgICAgICBfb3B0aW9ucyRkcmFnUm90YXRlID0gb3B0aW9ucy5kcmFnUm90YXRlLFxuICAgICAgICBkcmFnUm90YXRlID0gX29wdGlvbnMkZHJhZ1JvdGF0ZSA9PT0gdm9pZCAwID8gdGhpcy5kcmFnUm90YXRlIDogX29wdGlvbnMkZHJhZ1JvdGF0ZSxcbiAgICAgICAgX29wdGlvbnMkZG91YmxlQ2xpY2taID0gb3B0aW9ucy5kb3VibGVDbGlja1pvb20sXG4gICAgICAgIGRvdWJsZUNsaWNrWm9vbSA9IF9vcHRpb25zJGRvdWJsZUNsaWNrWiA9PT0gdm9pZCAwID8gdGhpcy5kb3VibGVDbGlja1pvb20gOiBfb3B0aW9ucyRkb3VibGVDbGlja1osXG4gICAgICAgIF9vcHRpb25zJHRvdWNoWm9vbSA9IG9wdGlvbnMudG91Y2hab29tLFxuICAgICAgICB0b3VjaFpvb20gPSBfb3B0aW9ucyR0b3VjaFpvb20gPT09IHZvaWQgMCA/IHRoaXMudG91Y2hab29tIDogX29wdGlvbnMkdG91Y2hab29tLFxuICAgICAgICBfb3B0aW9ucyR0b3VjaFJvdGF0ZSA9IG9wdGlvbnMudG91Y2hSb3RhdGUsXG4gICAgICAgIHRvdWNoUm90YXRlID0gX29wdGlvbnMkdG91Y2hSb3RhdGUgPT09IHZvaWQgMCA/IHRoaXMudG91Y2hSb3RhdGUgOiBfb3B0aW9ucyR0b3VjaFJvdGF0ZSxcbiAgICAgICAgX29wdGlvbnMka2V5Ym9hcmQgPSBvcHRpb25zLmtleWJvYXJkLFxuICAgICAgICBrZXlib2FyZCA9IF9vcHRpb25zJGtleWJvYXJkID09PSB2b2lkIDAgPyB0aGlzLmtleWJvYXJkIDogX29wdGlvbnMka2V5Ym9hcmQ7XG4gICAgICB0aGlzLm9uVmlld3BvcnRDaGFuZ2UgPSBvblZpZXdwb3J0Q2hhbmdlO1xuICAgICAgdGhpcy5vblN0YXRlQ2hhbmdlID0gb25TdGF0ZUNoYW5nZTtcbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IHRoaXMubWFwU3RhdGVQcm9wcyB8fCB7fTtcbiAgICAgIHZhciBkaW1lbnNpb25DaGFuZ2VkID0gcHJldk9wdGlvbnMuaGVpZ2h0ICE9PSBvcHRpb25zLmhlaWdodCB8fCBwcmV2T3B0aW9ucy53aWR0aCAhPT0gb3B0aW9ucy53aWR0aDtcbiAgICAgIHRoaXMubWFwU3RhdGVQcm9wcyA9IG9wdGlvbnM7XG4gICAgICBpZiAoZGltZW5zaW9uQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLm1hcFN0YXRlID0gcHJldk9wdGlvbnM7XG4gICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3IE1hcFN0YXRlKG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RyYW5zaXRpb25NYW5hZ2VyLnByb2Nlc3NWaWV3cG9ydENoYW5nZShvcHRpb25zKTtcbiAgICAgIGlmICh0aGlzLmV2ZW50TWFuYWdlciAhPT0gZXZlbnRNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgICAgdGhpcy50b2dnbGVFdmVudHModGhpcy5ldmVudHMsIHRydWUpO1xuICAgICAgfVxuICAgICAgdGhpcy50b2dnbGVFdmVudHMoRVZFTlRfVFlQRVMuV0hFRUwsIGlzSW50ZXJhY3RpdmUgJiYgQm9vbGVhbihzY3JvbGxab29tKSk7XG4gICAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5QQU4sIGlzSW50ZXJhY3RpdmUgJiYgQm9vbGVhbihkcmFnUGFuIHx8IGRyYWdSb3RhdGUpKTtcbiAgICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLlBJTkNILCBpc0ludGVyYWN0aXZlICYmIEJvb2xlYW4odG91Y2hab29tIHx8IHRvdWNoUm90YXRlKSk7XG4gICAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5UUklQTEVfUEFOLCBpc0ludGVyYWN0aXZlICYmIEJvb2xlYW4odG91Y2hSb3RhdGUpKTtcbiAgICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLkRPVUJMRV9UQVAsIGlzSW50ZXJhY3RpdmUgJiYgQm9vbGVhbihkb3VibGVDbGlja1pvb20pKTtcbiAgICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLktFWUJPQVJELCBpc0ludGVyYWN0aXZlICYmIEJvb2xlYW4oa2V5Ym9hcmQpKTtcbiAgICAgIHRoaXMuc2Nyb2xsWm9vbSA9IHNjcm9sbFpvb207XG4gICAgICB0aGlzLmRyYWdQYW4gPSBkcmFnUGFuO1xuICAgICAgdGhpcy5kcmFnUm90YXRlID0gZHJhZ1JvdGF0ZTtcbiAgICAgIHRoaXMuZG91YmxlQ2xpY2tab29tID0gZG91YmxlQ2xpY2tab29tO1xuICAgICAgdGhpcy50b3VjaFpvb20gPSB0b3VjaFpvb207XG4gICAgICB0aGlzLnRvdWNoUm90YXRlID0gdG91Y2hSb3RhdGU7XG4gICAgICB0aGlzLmtleWJvYXJkID0ga2V5Ym9hcmQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZUV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVFdmVudHMoZXZlbnROYW1lcywgZW5hYmxlZCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5ldmVudE1hbmFnZXIpIHtcbiAgICAgICAgZXZlbnROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICBpZiAoX3RoaXMzLl9ldmVudHNbZXZlbnROYW1lXSAhPT0gZW5hYmxlZCkge1xuICAgICAgICAgICAgX3RoaXMzLl9ldmVudHNbZXZlbnROYW1lXSA9IGVuYWJsZWQ7XG4gICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgICBfdGhpczMuZXZlbnRNYW5hZ2VyLm9uKGV2ZW50TmFtZSwgX3RoaXMzLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF90aGlzMy5ldmVudE1hbmFnZXIub2ZmKGV2ZW50TmFtZSwgX3RoaXMzLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25QYW5TdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25QYW5TdGFydChldmVudCkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgIHRoaXMuX3BhblJvdGF0ZSA9IHRoaXMuaXNGdW5jdGlvbktleVByZXNzZWQoZXZlbnQpIHx8IGV2ZW50LnJpZ2h0QnV0dG9uO1xuICAgICAgdmFyIG5ld01hcFN0YXRlID0gdGhpcy5fcGFuUm90YXRlID8gdGhpcy5tYXBTdGF0ZS5yb3RhdGVTdGFydCh7XG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KSA6IHRoaXMubWFwU3RhdGUucGFuU3RhcnQoe1xuICAgICAgICBwb3M6IHBvc1xuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlLCBOT19UUkFOU0lUSU9OX1BST1BTLCB7XG4gICAgICAgIGlzRHJhZ2dpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblBhblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25QYW4oZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3BhblJvdGF0ZSA/IHRoaXMuX29uUGFuUm90YXRlKGV2ZW50KSA6IHRoaXMuX29uUGFuTW92ZShldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblBhbkVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25QYW5FbmQoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3BhblJvdGF0ZSA/IHRoaXMuX29uUGFuUm90YXRlRW5kKGV2ZW50KSA6IHRoaXMuX29uUGFuTW92ZUVuZChldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblBhbk1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUGFuTW92ZShldmVudCkge1xuICAgICAgaWYgKCF0aGlzLmRyYWdQYW4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgIHZhciBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucGFuKHtcbiAgICAgICAgcG9zOiBwb3NcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgTk9fVFJBTlNJVElPTl9QUk9QUywge1xuICAgICAgICBpc1Bhbm5pbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblBhbk1vdmVFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUGFuTW92ZUVuZChldmVudCkge1xuICAgICAgaWYgKHRoaXMuZHJhZ1Bhbikge1xuICAgICAgICB2YXIgX3RoaXMkZHJhZ1BhbiRpbmVydGlhID0gdGhpcy5kcmFnUGFuLmluZXJ0aWEsXG4gICAgICAgICAgaW5lcnRpYSA9IF90aGlzJGRyYWdQYW4kaW5lcnRpYSA9PT0gdm9pZCAwID8gREVGQVVMVF9JTkVSVElBIDogX3RoaXMkZHJhZ1BhbiRpbmVydGlhO1xuICAgICAgICBpZiAoaW5lcnRpYSAmJiBldmVudC52ZWxvY2l0eSkge1xuICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgICAgICAgdmFyIGVuZFBvcyA9IFtwb3NbMF0gKyBldmVudC52ZWxvY2l0eVggKiBpbmVydGlhIC8gMiwgcG9zWzFdICsgZXZlbnQudmVsb2NpdHlZICogaW5lcnRpYSAvIDJdO1xuICAgICAgICAgIHZhciBuZXdDb250cm9sbGVyU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnBhbih7XG4gICAgICAgICAgICBwb3M6IGVuZFBvc1xuICAgICAgICAgIH0pLnBhbkVuZCgpO1xuICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Q29udHJvbGxlclN0YXRlLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIExJTkVBUl9UUkFOU0lUSU9OX1BST1BTKSwge30sIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogaW5lcnRpYSxcbiAgICAgICAgICAgIHRyYW5zaXRpb25FYXNpbmc6IElORVJUSUFfRUFTSU5HXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgaXNQYW5uaW5nOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucGFuRW5kKCk7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlLCBudWxsLCB7XG4gICAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICBpc1Bhbm5pbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25QYW5Sb3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUGFuUm90YXRlKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuZHJhZ1JvdGF0ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgICAgdmFyIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS5yb3RhdGUoe1xuICAgICAgICBwb3M6IHBvc1xuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlLCBOT19UUkFOU0lUSU9OX1BST1BTLCB7XG4gICAgICAgIGlzUm90YXRpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblBhblJvdGF0ZUVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25QYW5Sb3RhdGVFbmQoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLmRyYWdSb3RhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzJGRyYWdSb3RhdGUkaW5lciA9IHRoaXMuZHJhZ1JvdGF0ZS5pbmVydGlhLFxuICAgICAgICAgIGluZXJ0aWEgPSBfdGhpcyRkcmFnUm90YXRlJGluZXIgPT09IHZvaWQgMCA/IERFRkFVTFRfSU5FUlRJQSA6IF90aGlzJGRyYWdSb3RhdGUkaW5lcjtcbiAgICAgICAgaWYgKGluZXJ0aWEgJiYgZXZlbnQudmVsb2NpdHkpIHtcbiAgICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgICAgICAgIHZhciBlbmRQb3MgPSBbcG9zWzBdICsgZXZlbnQudmVsb2NpdHlYICogaW5lcnRpYSAvIDIsIHBvc1sxXSArIGV2ZW50LnZlbG9jaXR5WSAqIGluZXJ0aWEgLyAyXTtcbiAgICAgICAgICB2YXIgbmV3Q29udHJvbGxlclN0YXRlID0gdGhpcy5tYXBTdGF0ZS5yb3RhdGUoe1xuICAgICAgICAgICAgcG9zOiBlbmRQb3NcbiAgICAgICAgICB9KS5yb3RhdGVFbmQoKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld0NvbnRyb2xsZXJTdGF0ZSwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyksIHt9LCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGluZXJ0aWEsXG4gICAgICAgICAgICB0cmFuc2l0aW9uRWFzaW5nOiBJTkVSVElBX0VBU0lOR1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUm90YXRpbmc6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS5wYW5FbmQoKTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIG51bGwsIHtcbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIGlzUm90YXRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25XaGVlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25XaGVlbChldmVudCkge1xuICAgICAgaWYgKCF0aGlzLnNjcm9sbFpvb20pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIF90aGlzJHNjcm9sbFpvb20gPSB0aGlzLnNjcm9sbFpvb20sXG4gICAgICAgIF90aGlzJHNjcm9sbFpvb20kc3BlZSA9IF90aGlzJHNjcm9sbFpvb20uc3BlZWQsXG4gICAgICAgIHNwZWVkID0gX3RoaXMkc2Nyb2xsWm9vbSRzcGVlID09PSB2b2lkIDAgPyAwLjAxIDogX3RoaXMkc2Nyb2xsWm9vbSRzcGVlLFxuICAgICAgICBfdGhpcyRzY3JvbGxab29tJHNtb28gPSBfdGhpcyRzY3JvbGxab29tLnNtb290aCxcbiAgICAgICAgc21vb3RoID0gX3RoaXMkc2Nyb2xsWm9vbSRzbW9vID09PSB2b2lkIDAgPyBmYWxzZSA6IF90aGlzJHNjcm9sbFpvb20kc21vbztcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgICAgdmFyIGRlbHRhID0gZXZlbnQuZGVsdGE7XG4gICAgICB2YXIgc2NhbGUgPSAyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZGVsdGEgKiBzcGVlZCkpKTtcbiAgICAgIGlmIChkZWx0YSA8IDAgJiYgc2NhbGUgIT09IDApIHtcbiAgICAgICAgc2NhbGUgPSAxIC8gc2NhbGU7XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnpvb20oe1xuICAgICAgICBwb3M6IHBvcyxcbiAgICAgICAgc2NhbGU6IHNjYWxlXG4gICAgICB9KTtcbiAgICAgIGlmIChuZXdNYXBTdGF0ZS5nZXRWaWV3cG9ydFByb3BzKCkuem9vbSA9PT0gdGhpcy5tYXBTdGF0ZVByb3BzLnpvb20pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyksIHt9LCB7XG4gICAgICAgIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IG5ldyBMaW5lYXJJbnRlcnBvbGF0b3Ioe1xuICAgICAgICAgIGFyb3VuZDogcG9zXG4gICAgICAgIH0pLFxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IHNtb290aCA/IDI1MCA6IDFcbiAgICAgIH0pLCB7XG4gICAgICAgIGlzUGFubmluZzogdHJ1ZSxcbiAgICAgICAgaXNab29taW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25QaW5jaFN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblBpbmNoU3RhcnQoZXZlbnQpIHtcbiAgICAgIHZhciBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnpvb21TdGFydCh7XG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KS5yb3RhdGVTdGFydCh7XG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3N0YXJ0UGluY2hSb3RhdGlvbiA9IGV2ZW50LnJvdGF0aW9uO1xuICAgICAgdGhpcy5fbGFzdFBpbmNoRXZlbnQgPSBldmVudDtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIE5PX1RSQU5TSVRJT05fUFJPUFMsIHtcbiAgICAgICAgaXNEcmFnZ2luZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uUGluY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUGluY2goZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnRvdWNoWm9vbSAmJiAhdGhpcy50b3VjaFJvdGF0ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlO1xuICAgICAgaWYgKHRoaXMudG91Y2hab29tKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IGV2ZW50LnNjYWxlO1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgICAgICBuZXdNYXBTdGF0ZSA9IG5ld01hcFN0YXRlLnpvb20oe1xuICAgICAgICAgIHBvczogcG9zLFxuICAgICAgICAgIHNjYWxlOiBzY2FsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRvdWNoUm90YXRlKSB7XG4gICAgICAgIHZhciByb3RhdGlvbiA9IGV2ZW50LnJvdGF0aW9uO1xuICAgICAgICBuZXdNYXBTdGF0ZSA9IG5ld01hcFN0YXRlLnJvdGF0ZSh7XG4gICAgICAgICAgZGVsdGFBbmdsZVg6IHRoaXMuX3N0YXJ0UGluY2hSb3RhdGlvbiAtIHJvdGF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgTk9fVFJBTlNJVElPTl9QUk9QUywge1xuICAgICAgICBpc0RyYWdnaW5nOiB0cnVlLFxuICAgICAgICBpc1Bhbm5pbmc6IEJvb2xlYW4odGhpcy50b3VjaFpvb20pLFxuICAgICAgICBpc1pvb21pbmc6IEJvb2xlYW4odGhpcy50b3VjaFpvb20pLFxuICAgICAgICBpc1JvdGF0aW5nOiBCb29sZWFuKHRoaXMudG91Y2hSb3RhdGUpXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2xhc3RQaW5jaEV2ZW50ID0gZXZlbnQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uUGluY2hFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUGluY2hFbmQoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudG91Y2hab29tKSB7XG4gICAgICAgIHZhciBfdGhpcyR0b3VjaFpvb20kaW5lcnQgPSB0aGlzLnRvdWNoWm9vbS5pbmVydGlhLFxuICAgICAgICAgIGluZXJ0aWEgPSBfdGhpcyR0b3VjaFpvb20kaW5lcnQgPT09IHZvaWQgMCA/IERFRkFVTFRfSU5FUlRJQSA6IF90aGlzJHRvdWNoWm9vbSRpbmVydDtcbiAgICAgICAgdmFyIF9sYXN0UGluY2hFdmVudCA9IHRoaXMuX2xhc3RQaW5jaEV2ZW50O1xuICAgICAgICBpZiAoaW5lcnRpYSAmJiBfbGFzdFBpbmNoRXZlbnQgJiYgZXZlbnQuc2NhbGUgIT09IF9sYXN0UGluY2hFdmVudC5zY2FsZSkge1xuICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgICAgICAgdmFyIF9uZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucm90YXRlRW5kKCk7XG4gICAgICAgICAgdmFyIHogPSBNYXRoLmxvZzIoZXZlbnQuc2NhbGUpO1xuICAgICAgICAgIHZhciB2ZWxvY2l0eVogPSAoeiAtIE1hdGgubG9nMihfbGFzdFBpbmNoRXZlbnQuc2NhbGUpKSAvIChldmVudC5kZWx0YVRpbWUgLSBfbGFzdFBpbmNoRXZlbnQuZGVsdGFUaW1lKTtcbiAgICAgICAgICB2YXIgZW5kU2NhbGUgPSBNYXRoLnBvdygyLCB6ICsgdmVsb2NpdHlaICogaW5lcnRpYSAvIDIpO1xuICAgICAgICAgIF9uZXdNYXBTdGF0ZSA9IF9uZXdNYXBTdGF0ZS56b29tKHtcbiAgICAgICAgICAgIHBvczogcG9zLFxuICAgICAgICAgICAgc2NhbGU6IGVuZFNjYWxlXG4gICAgICAgICAgfSkuem9vbUVuZCgpO1xuICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQoX25ld01hcFN0YXRlLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIExJTkVBUl9UUkFOU0lUSU9OX1BST1BTKSwge30sIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IG5ldyBMaW5lYXJJbnRlcnBvbGF0b3Ioe1xuICAgICAgICAgICAgICBhcm91bmQ6IHBvc1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGluZXJ0aWEsXG4gICAgICAgICAgICB0cmFuc2l0aW9uRWFzaW5nOiBJTkVSVElBX0VBU0lOR1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUGFubmluZzogQm9vbGVhbih0aGlzLnRvdWNoWm9vbSksXG4gICAgICAgICAgICBpc1pvb21pbmc6IEJvb2xlYW4odGhpcy50b3VjaFpvb20pLFxuICAgICAgICAgICAgaXNSb3RhdGluZzogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmJsb2NrRXZlbnRzKGluZXJ0aWEpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnpvb21FbmQoKS5yb3RhdGVFbmQoKTtcbiAgICAgIHRoaXMuX3N0YXRlLnN0YXJ0UGluY2hSb3RhdGlvbiA9IDA7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlLCBudWxsLCB7XG4gICAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICBpc1Bhbm5pbmc6IGZhbHNlLFxuICAgICAgICBpc1pvb21pbmc6IGZhbHNlLFxuICAgICAgICBpc1JvdGF0aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9zdGFydFBpbmNoUm90YXRpb24gPSBudWxsO1xuICAgICAgdGhpcy5fbGFzdFBpbmNoRXZlbnQgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblRyaXBsZVBhblN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblRyaXBsZVBhblN0YXJ0KGV2ZW50KSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgICAgdmFyIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS5yb3RhdGVTdGFydCh7XG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIE5PX1RSQU5TSVRJT05fUFJPUFMsIHtcbiAgICAgICAgaXNEcmFnZ2luZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uVHJpcGxlUGFuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblRyaXBsZVBhbihldmVudCkge1xuICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMudG91Y2hSb3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgIHBvc1swXSAtPSBldmVudC5kZWx0YVg7XG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnJvdGF0ZSh7XG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIE5PX1RSQU5TSVRJT05fUFJPUFMsIHtcbiAgICAgICAgaXNSb3RhdGluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uVHJpcGxlUGFuRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblRyaXBsZVBhbkVuZChldmVudCkge1xuICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50b3VjaFJvdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMkdG91Y2hSb3RhdGUkaW5lID0gdGhpcy50b3VjaFJvdGF0ZS5pbmVydGlhLFxuICAgICAgICAgIGluZXJ0aWEgPSBfdGhpcyR0b3VjaFJvdGF0ZSRpbmUgPT09IHZvaWQgMCA/IERFRkFVTFRfSU5FUlRJQSA6IF90aGlzJHRvdWNoUm90YXRlJGluZTtcbiAgICAgICAgaWYgKGluZXJ0aWEgJiYgZXZlbnQudmVsb2NpdHlZKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgICAgICB2YXIgZW5kUG9zID0gW3Bvc1swXSwgcG9zWzFdICs9IGV2ZW50LnZlbG9jaXR5WSAqIGluZXJ0aWEgLyAyXTtcbiAgICAgICAgICB2YXIgX25ld01hcFN0YXRlMiA9IHRoaXMubWFwU3RhdGUucm90YXRlKHtcbiAgICAgICAgICAgIHBvczogZW5kUG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChfbmV3TWFwU3RhdGUyLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIExJTkVBUl9UUkFOU0lUSU9OX1BST1BTKSwge30sIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogaW5lcnRpYSxcbiAgICAgICAgICAgIHRyYW5zaXRpb25FYXNpbmc6IElORVJUSUFfRUFTSU5HXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgaXNSb3RhdGluZzogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYmxvY2tFdmVudHMoaW5lcnRpYSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnJvdGF0ZUVuZCgpO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgbnVsbCwge1xuICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgaXNSb3RhdGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vbkRvdWJsZVRhcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Eb3VibGVUYXAoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5kb3VibGVDbGlja1pvb20pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgIHZhciBpc1pvb21PdXQgPSB0aGlzLmlzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KTtcbiAgICAgIHZhciBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUuem9vbSh7XG4gICAgICAgIHBvczogcG9zLFxuICAgICAgICBzY2FsZTogaXNab29tT3V0ID8gMC41IDogMlxuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlLCBPYmplY3QuYXNzaWduKHt9LCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUywge1xuICAgICAgICB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yOiBuZXcgTGluZWFySW50ZXJwb2xhdG9yKHtcbiAgICAgICAgICBhcm91bmQ6IHBvc1xuICAgICAgICB9KVxuICAgICAgfSksIHtcbiAgICAgICAgaXNab29taW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25LZXlEb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbktleURvd24oZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5rZXlib2FyZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgZnVuY0tleSA9IHRoaXMuaXNGdW5jdGlvbktleVByZXNzZWQoZXZlbnQpO1xuICAgICAgdmFyIF90aGlzJGtleWJvYXJkID0gdGhpcy5rZXlib2FyZCxcbiAgICAgICAgX3RoaXMka2V5Ym9hcmQkem9vbVNwID0gX3RoaXMka2V5Ym9hcmQuem9vbVNwZWVkLFxuICAgICAgICB6b29tU3BlZWQgPSBfdGhpcyRrZXlib2FyZCR6b29tU3AgPT09IHZvaWQgMCA/IDIgOiBfdGhpcyRrZXlib2FyZCR6b29tU3AsXG4gICAgICAgIF90aGlzJGtleWJvYXJkJG1vdmVTcCA9IF90aGlzJGtleWJvYXJkLm1vdmVTcGVlZCxcbiAgICAgICAgbW92ZVNwZWVkID0gX3RoaXMka2V5Ym9hcmQkbW92ZVNwID09PSB2b2lkIDAgPyAxMDAgOiBfdGhpcyRrZXlib2FyZCRtb3ZlU3AsXG4gICAgICAgIF90aGlzJGtleWJvYXJkJHJvdGF0ZSA9IF90aGlzJGtleWJvYXJkLnJvdGF0ZVNwZWVkWCxcbiAgICAgICAgcm90YXRlU3BlZWRYID0gX3RoaXMka2V5Ym9hcmQkcm90YXRlID09PSB2b2lkIDAgPyAxNSA6IF90aGlzJGtleWJvYXJkJHJvdGF0ZSxcbiAgICAgICAgX3RoaXMka2V5Ym9hcmQkcm90YXRlMiA9IF90aGlzJGtleWJvYXJkLnJvdGF0ZVNwZWVkWSxcbiAgICAgICAgcm90YXRlU3BlZWRZID0gX3RoaXMka2V5Ym9hcmQkcm90YXRlMiA9PT0gdm9pZCAwID8gMTAgOiBfdGhpcyRrZXlib2FyZCRyb3RhdGUyO1xuICAgICAgdmFyIG1hcFN0YXRlUHJvcHMgPSB0aGlzLm1hcFN0YXRlUHJvcHM7XG4gICAgICB2YXIgbmV3TWFwU3RhdGU7XG4gICAgICBzd2l0Y2ggKGV2ZW50LnNyY0V2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSAxODk6XG4gICAgICAgICAgaWYgKGZ1bmNLZXkpIHtcbiAgICAgICAgICAgIG5ld01hcFN0YXRlID0gdGhpcy5nZXRNYXBTdGF0ZSh7XG4gICAgICAgICAgICAgIHpvb206IG1hcFN0YXRlUHJvcHMuem9vbSAtIE1hdGgubG9nMih6b29tU3BlZWQpIC0gMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld01hcFN0YXRlID0gdGhpcy5nZXRNYXBTdGF0ZSh7XG4gICAgICAgICAgICAgIHpvb206IG1hcFN0YXRlUHJvcHMuem9vbSAtIE1hdGgubG9nMih6b29tU3BlZWQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTg3OlxuICAgICAgICAgIGlmIChmdW5jS2V5KSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMuZ2V0TWFwU3RhdGUoe1xuICAgICAgICAgICAgICB6b29tOiBtYXBTdGF0ZVByb3BzLnpvb20gKyBNYXRoLmxvZzIoem9vbVNwZWVkKSArIDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMuZ2V0TWFwU3RhdGUoe1xuICAgICAgICAgICAgICB6b29tOiBtYXBTdGF0ZVByb3BzLnpvb20gKyBNYXRoLmxvZzIoem9vbVNwZWVkKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgIGlmIChmdW5jS2V5KSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMuZ2V0TWFwU3RhdGUoe1xuICAgICAgICAgICAgICBiZWFyaW5nOiBtYXBTdGF0ZVByb3BzLmJlYXJpbmcgLSByb3RhdGVTcGVlZFhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucGFuKHtcbiAgICAgICAgICAgICAgcG9zOiBbbW92ZVNwZWVkLCAwXSxcbiAgICAgICAgICAgICAgc3RhcnRQb3M6IFswLCAwXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgIGlmIChmdW5jS2V5KSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMuZ2V0TWFwU3RhdGUoe1xuICAgICAgICAgICAgICBiZWFyaW5nOiBtYXBTdGF0ZVByb3BzLmJlYXJpbmcgKyByb3RhdGVTcGVlZFhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucGFuKHtcbiAgICAgICAgICAgICAgcG9zOiBbLW1vdmVTcGVlZCwgMF0sXG4gICAgICAgICAgICAgIHN0YXJ0UG9zOiBbMCwgMF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICBpZiAoZnVuY0tleSkge1xuICAgICAgICAgICAgbmV3TWFwU3RhdGUgPSB0aGlzLmdldE1hcFN0YXRlKHtcbiAgICAgICAgICAgICAgcGl0Y2g6IG1hcFN0YXRlUHJvcHMucGl0Y2ggKyByb3RhdGVTcGVlZFlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucGFuKHtcbiAgICAgICAgICAgICAgcG9zOiBbMCwgbW92ZVNwZWVkXSxcbiAgICAgICAgICAgICAgc3RhcnRQb3M6IFswLCAwXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgIGlmIChmdW5jS2V5KSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMuZ2V0TWFwU3RhdGUoe1xuICAgICAgICAgICAgICBwaXRjaDogbWFwU3RhdGVQcm9wcy5waXRjaCAtIHJvdGF0ZVNwZWVkWVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS5wYW4oe1xuICAgICAgICAgICAgICBwb3M6IFswLCAtbW92ZVNwZWVkXSxcbiAgICAgICAgICAgICAgc3RhcnRQb3M6IFswLCAwXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlLCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNYXBDb250cm9sbGVyO1xufSgpO1xuZXhwb3J0IHsgTWFwQ29udHJvbGxlciBhcyBkZWZhdWx0IH07IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheVwiO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlUmVmLCB1c2VNZW1vLCB1c2VFZmZlY3QsIHVzZUltcGVyYXRpdmVIYW5kbGUsIGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgU3RhdGljTWFwLCB7IGdldFZpZXdwb3J0IH0gZnJvbSAnLi9zdGF0aWMtbWFwJztcbmltcG9ydCB7IE1BUEJPWF9MSU1JVFMgfSBmcm9tICcuLi91dGlscy9tYXAtc3RhdGUnO1xuaW1wb3J0IFRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4uL3V0aWxzL3RyYW5zaXRpb24tbWFuYWdlcic7XG5pbXBvcnQgTWFwQ29udGV4dCwgeyBNYXBDb250ZXh0UHJvdmlkZXIgfSBmcm9tICcuL21hcC1jb250ZXh0JztcbmltcG9ydCB7IEV2ZW50TWFuYWdlciB9IGZyb20gJ21qb2xuaXIuanMnO1xuaW1wb3J0IE1hcENvbnRyb2xsZXIgZnJvbSAnLi4vdXRpbHMvbWFwLWNvbnRyb2xsZXInO1xuaW1wb3J0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgZnJvbSAnLi4vdXRpbHMvdXNlLWlzb21vcnBoaWMtbGF5b3V0LWVmZmVjdCc7XG5pbXBvcnQgeyBnZXRUZXJyYWluRWxldmF0aW9uIH0gZnJvbSAnLi4vdXRpbHMvdGVycmFpbic7XG52YXIgcHJvcFR5cGVzID0gT2JqZWN0LmFzc2lnbih7fSwgU3RhdGljTWFwLnByb3BUeXBlcywge1xuICBtYXhab29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICBtaW5ab29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICBtYXhQaXRjaDogUHJvcFR5cGVzLm51bWJlcixcbiAgbWluUGl0Y2g6IFByb3BUeXBlcy5udW1iZXIsXG4gIG9uVmlld1N0YXRlQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25WaWV3cG9ydENoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uSW50ZXJhY3Rpb25TdGF0ZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRyYW5zaXRpb25EdXJhdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yOiBQcm9wVHlwZXMub2JqZWN0LFxuICB0cmFuc2l0aW9uSW50ZXJydXB0aW9uOiBQcm9wVHlwZXMubnVtYmVyLFxuICB0cmFuc2l0aW9uRWFzaW5nOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25UcmFuc2l0aW9uU3RhcnQ6IFByb3BUeXBlcy5mdW5jLFxuICBvblRyYW5zaXRpb25JbnRlcnJ1cHQ6IFByb3BUeXBlcy5mdW5jLFxuICBvblRyYW5zaXRpb25FbmQ6IFByb3BUeXBlcy5mdW5jLFxuICBzY3JvbGxab29tOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICBkcmFnUGFuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICBkcmFnUm90YXRlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICBkb3VibGVDbGlja1pvb206IFByb3BUeXBlcy5ib29sLFxuICB0b3VjaFpvb206IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMub2JqZWN0XSksXG4gIHRvdWNoUm90YXRlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICBrZXlib2FyZDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgb25Ib3ZlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBvbkRibENsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Db250ZXh0TWVudTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uTW91c2VEb3duOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZU1vdmU6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlVXA6IFByb3BUeXBlcy5mdW5jLFxuICBvblRvdWNoU3RhcnQ6IFByb3BUeXBlcy5mdW5jLFxuICBvblRvdWNoTW92ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uVG91Y2hFbmQ6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlT3V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25XaGVlbDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRvdWNoQWN0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBldmVudFJlY29nbml6ZXJPcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0LFxuICBjbGlja1JhZGl1czogUHJvcFR5cGVzLm51bWJlcixcbiAgaW50ZXJhY3RpdmVMYXllcklkczogUHJvcFR5cGVzLmFycmF5LFxuICBnZXRDdXJzb3I6IFByb3BUeXBlcy5mdW5jLFxuICBjb250cm9sbGVyOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihNYXBDb250cm9sbGVyKVxufSk7XG52YXIgZ2V0RGVmYXVsdEN1cnNvciA9IGZ1bmN0aW9uIGdldERlZmF1bHRDdXJzb3IoX3JlZikge1xuICB2YXIgaXNEcmFnZ2luZyA9IF9yZWYuaXNEcmFnZ2luZyxcbiAgICBpc0hvdmVyaW5nID0gX3JlZi5pc0hvdmVyaW5nO1xuICByZXR1cm4gaXNEcmFnZ2luZyA/ICdncmFiYmluZycgOiBpc0hvdmVyaW5nID8gJ3BvaW50ZXInIDogJ2dyYWInO1xufTtcbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBTdGF0aWNNYXAuZGVmYXVsdFByb3BzLCBNQVBCT1hfTElNSVRTLCBUcmFuc2l0aW9uTWFuYWdlci5kZWZhdWx0UHJvcHMsIHtcbiAgb25WaWV3U3RhdGVDaGFuZ2U6IG51bGwsXG4gIG9uVmlld3BvcnRDaGFuZ2U6IG51bGwsXG4gIG9uQ2xpY2s6IG51bGwsXG4gIG9uTmF0aXZlQ2xpY2s6IG51bGwsXG4gIG9uSG92ZXI6IG51bGwsXG4gIG9uQ29udGV4dE1lbnU6IGZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSxcbiAgc2Nyb2xsWm9vbTogdHJ1ZSxcbiAgZHJhZ1BhbjogdHJ1ZSxcbiAgZHJhZ1JvdGF0ZTogdHJ1ZSxcbiAgZG91YmxlQ2xpY2tab29tOiB0cnVlLFxuICB0b3VjaFpvb206IHRydWUsXG4gIHRvdWNoUm90YXRlOiBmYWxzZSxcbiAga2V5Ym9hcmQ6IHRydWUsXG4gIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gIGV2ZW50UmVjb2duaXplck9wdGlvbnM6IHt9LFxuICBjbGlja1JhZGl1czogMCxcbiAgZ2V0Q3Vyc29yOiBnZXREZWZhdWx0Q3Vyc29yXG59KTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50KGV2ZW50KSB7XG4gIGlmIChldmVudC5sbmdMYXQgfHwgIWV2ZW50Lm9mZnNldENlbnRlcikge1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICB2YXIgX2V2ZW50JG9mZnNldENlbnRlciA9IGV2ZW50Lm9mZnNldENlbnRlcixcbiAgICB4ID0gX2V2ZW50JG9mZnNldENlbnRlci54LFxuICAgIHkgPSBfZXZlbnQkb2Zmc2V0Q2VudGVyLnk7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKHgpIHx8ICFOdW1iZXIuaXNGaW5pdGUoeSkpIHtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgdmFyIHBvcyA9IFt4LCB5XTtcbiAgZXZlbnQucG9pbnQgPSBwb3M7XG4gIGlmICh0aGlzLm1hcCkge1xuICAgIHZhciBsb2NhdGlvbiA9IHRoaXMubWFwLnVucHJvamVjdChwb3MpO1xuICAgIGV2ZW50LmxuZ0xhdCA9IFtsb2NhdGlvbi5sbmcsIGxvY2F0aW9uLmxhdF07XG4gIH1cbiAgcmV0dXJuIGV2ZW50O1xufVxuZnVuY3Rpb24gZ2V0RmVhdHVyZXMocG9zKSB7XG4gIHZhciBtYXAgPSB0aGlzLm1hcDtcbiAgaWYgKCFtYXAgfHwgIXBvcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBxdWVyeVBhcmFtcyA9IHt9O1xuICB2YXIgc2l6ZSA9IHRoaXMucHJvcHMuY2xpY2tSYWRpdXM7XG4gIGlmICh0aGlzLnByb3BzLmludGVyYWN0aXZlTGF5ZXJJZHMpIHtcbiAgICBxdWVyeVBhcmFtcy5sYXllcnMgPSB0aGlzLnByb3BzLmludGVyYWN0aXZlTGF5ZXJJZHM7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gbWFwLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhzaXplID8gW1twb3NbMF0gLSBzaXplLCBwb3NbMV0gKyBzaXplXSwgW3Bvc1swXSArIHNpemUsIHBvc1sxXSAtIHNpemVdXSA6IHBvcywgcXVlcnlQYXJhbXMpO1xuICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIG9uRXZlbnQoY2FsbGJhY2tOYW1lLCBldmVudCkge1xuICB2YXIgZnVuYyA9IHRoaXMucHJvcHNbY2FsbGJhY2tOYW1lXTtcbiAgaWYgKGZ1bmMpIHtcbiAgICBmdW5jKG5vcm1hbGl6ZUV2ZW50LmNhbGwodGhpcywgZXZlbnQpKTtcbiAgfVxufVxuZnVuY3Rpb24gb25Qb2ludGVyRG93bihldmVudCkge1xuICBvbkV2ZW50LmNhbGwodGhpcywgZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgPyAnb25Ub3VjaFN0YXJ0JyA6ICdvbk1vdXNlRG93bicsIGV2ZW50KTtcbn1cbmZ1bmN0aW9uIG9uUG9pbnRlclVwKGV2ZW50KSB7XG4gIG9uRXZlbnQuY2FsbCh0aGlzLCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyA/ICdvblRvdWNoRW5kJyA6ICdvbk1vdXNlVXAnLCBldmVudCk7XG59XG5mdW5jdGlvbiBvblBvaW50ZXJNb3ZlKGV2ZW50KSB7XG4gIG9uRXZlbnQuY2FsbCh0aGlzLCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyA/ICdvblRvdWNoTW92ZScgOiAnb25Nb3VzZU1vdmUnLCBldmVudCk7XG4gIGlmICghdGhpcy5zdGF0ZS5pc0RyYWdnaW5nKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgIG9uSG92ZXIgPSBfdGhpcyRwcm9wcy5vbkhvdmVyLFxuICAgICAgaW50ZXJhY3RpdmVMYXllcklkcyA9IF90aGlzJHByb3BzLmludGVyYWN0aXZlTGF5ZXJJZHM7XG4gICAgdmFyIGZlYXR1cmVzO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgaWYgKGludGVyYWN0aXZlTGF5ZXJJZHMgfHwgb25Ib3Zlcikge1xuICAgICAgZmVhdHVyZXMgPSBnZXRGZWF0dXJlcy5jYWxsKHRoaXMsIGV2ZW50LnBvaW50KTtcbiAgICB9XG4gICAgdmFyIGlzSG92ZXJpbmcgPSBCb29sZWFuKGludGVyYWN0aXZlTGF5ZXJJZHMgJiYgZmVhdHVyZXMgJiYgZmVhdHVyZXMubGVuZ3RoID4gMCk7XG4gICAgdmFyIGlzRW50ZXJpbmcgPSBpc0hvdmVyaW5nICYmICF0aGlzLnN0YXRlLmlzSG92ZXJpbmc7XG4gICAgdmFyIGlzRXhpdGluZyA9ICFpc0hvdmVyaW5nICYmIHRoaXMuc3RhdGUuaXNIb3ZlcmluZztcbiAgICBpZiAob25Ib3ZlciB8fCBpc0VudGVyaW5nKSB7XG4gICAgICBldmVudC5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuICAgICAgaWYgKG9uSG92ZXIpIHtcbiAgICAgICAgb25Ib3ZlcihldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0VudGVyaW5nKSB7XG4gICAgICBvbkV2ZW50LmNhbGwodGhpcywgJ29uTW91c2VFbnRlcicsIGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGlzRXhpdGluZykge1xuICAgICAgb25FdmVudC5jYWxsKHRoaXMsICdvbk1vdXNlTGVhdmUnLCBldmVudCk7XG4gICAgfVxuICAgIGlmIChpc0VudGVyaW5nIHx8IGlzRXhpdGluZykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzSG92ZXJpbmc6IGlzSG92ZXJpbmdcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Qb2ludGVyQ2xpY2soZXZlbnQpIHtcbiAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgb25DbGljayA9IF90aGlzJHByb3BzMi5vbkNsaWNrLFxuICAgIG9uTmF0aXZlQ2xpY2sgPSBfdGhpcyRwcm9wczIub25OYXRpdmVDbGljayxcbiAgICBvbkRibENsaWNrID0gX3RoaXMkcHJvcHMyLm9uRGJsQ2xpY2ssXG4gICAgZG91YmxlQ2xpY2tab29tID0gX3RoaXMkcHJvcHMyLmRvdWJsZUNsaWNrWm9vbTtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgaXNEb3VibGVDbGlja0VuYWJsZWQgPSBvbkRibENsaWNrIHx8IGRvdWJsZUNsaWNrWm9vbTtcbiAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgY2FzZSAnYW55Y2xpY2snOlxuICAgICAgY2FsbGJhY2tzLnB1c2gob25OYXRpdmVDbGljayk7XG4gICAgICBpZiAoIWlzRG91YmxlQ2xpY2tFbmFibGVkKSB7XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKG9uQ2xpY2spO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY2xpY2snOlxuICAgICAgaWYgKGlzRG91YmxlQ2xpY2tFbmFibGVkKSB7XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKG9uQ2xpY2spO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgfVxuICBjYWxsYmFja3MgPSBjYWxsYmFja3MuZmlsdGVyKEJvb2xlYW4pO1xuICBpZiAoY2FsbGJhY2tzLmxlbmd0aCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgZXZlbnQuZmVhdHVyZXMgPSBnZXRGZWF0dXJlcy5jYWxsKHRoaXMsIGV2ZW50LnBvaW50KTtcbiAgICBjYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHJldHVybiBjYihldmVudCk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJlZkhhbmRsZXMoc3RhdGljTWFwUmVmKSB7XG4gIHJldHVybiB7XG4gICAgZ2V0TWFwOiBzdGF0aWNNYXBSZWYuY3VycmVudCAmJiBzdGF0aWNNYXBSZWYuY3VycmVudC5nZXRNYXAsXG4gICAgcXVlcnlSZW5kZXJlZEZlYXR1cmVzOiBzdGF0aWNNYXBSZWYuY3VycmVudCAmJiBzdGF0aWNNYXBSZWYuY3VycmVudC5xdWVyeVJlbmRlcmVkRmVhdHVyZXNcbiAgfTtcbn1cbnZhciBJbnRlcmFjdGl2ZU1hcCA9IGZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgdmFyIHBhcmVudENvbnRleHQgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICB2YXIgY29udHJvbGxlciA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9wcy5jb250cm9sbGVyIHx8IG5ldyBNYXBDb250cm9sbGVyKCk7XG4gIH0sIFtdKTtcbiAgdmFyIGV2ZW50TWFuYWdlciA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRXZlbnRNYW5hZ2VyKG51bGwsIHtcbiAgICAgIHRvdWNoQWN0aW9uOiBwcm9wcy50b3VjaEFjdGlvbixcbiAgICAgIHJlY29nbml6ZXJPcHRpb25zOiBwcm9wcy5ldmVudFJlY29nbml6ZXJPcHRpb25zXG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgdmFyIGV2ZW50Q2FudmFzUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgc3RhdGljTWFwUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgX3RoaXNSZWYgPSB1c2VSZWYoe1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBzdGF0ZToge1xuICAgICAgaXNIb3ZlcmluZzogZmFsc2UsXG4gICAgICBpc0RyYWdnaW5nOiBmYWxzZVxuICAgIH1cbiAgfSk7XG4gIHZhciB0aGlzUmVmID0gX3RoaXNSZWYuY3VycmVudDtcbiAgdGhpc1JlZi5wcm9wcyA9IHByb3BzO1xuICB0aGlzUmVmLm1hcCA9IHN0YXRpY01hcFJlZi5jdXJyZW50ICYmIHN0YXRpY01hcFJlZi5jdXJyZW50LmdldE1hcCgpO1xuICB0aGlzUmVmLnNldFN0YXRlID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgdGhpc1JlZi5zdGF0ZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpc1JlZi5zdGF0ZSksIG5ld1N0YXRlKTtcbiAgICBldmVudENhbnZhc1JlZi5jdXJyZW50LnN0eWxlLmN1cnNvciA9IHByb3BzLmdldEN1cnNvcih0aGlzUmVmLnN0YXRlKTtcbiAgfTtcbiAgdmFyIGluUmVuZGVyID0gdHJ1ZTtcbiAgdmFyIHZpZXdwb3J0VXBkYXRlUmVxdWVzdGVkO1xuICB2YXIgc3RhdGVVcGRhdGVSZXF1ZXN0ZWQ7XG4gIHZhciBoYW5kbGVWaWV3cG9ydENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVZpZXdwb3J0Q2hhbmdlKHZpZXdTdGF0ZSwgaW50ZXJhY3Rpb25TdGF0ZSwgb2xkVmlld1N0YXRlKSB7XG4gICAgaWYgKGluUmVuZGVyKSB7XG4gICAgICB2aWV3cG9ydFVwZGF0ZVJlcXVlc3RlZCA9IFt2aWV3U3RhdGUsIGludGVyYWN0aW9uU3RhdGUsIG9sZFZpZXdTdGF0ZV07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBfdGhpc1JlZiRwcm9wcyA9IHRoaXNSZWYucHJvcHMsXG4gICAgICBvblZpZXdTdGF0ZUNoYW5nZSA9IF90aGlzUmVmJHByb3BzLm9uVmlld1N0YXRlQ2hhbmdlLFxuICAgICAgb25WaWV3cG9ydENoYW5nZSA9IF90aGlzUmVmJHByb3BzLm9uVmlld3BvcnRDaGFuZ2U7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZpZXdTdGF0ZSwgJ3Bvc2l0aW9uJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBbMCwgMCwgZ2V0VGVycmFpbkVsZXZhdGlvbih0aGlzUmVmLm1hcCwgdmlld1N0YXRlKV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG9uVmlld1N0YXRlQ2hhbmdlKSB7XG4gICAgICBvblZpZXdTdGF0ZUNoYW5nZSh7XG4gICAgICAgIHZpZXdTdGF0ZTogdmlld1N0YXRlLFxuICAgICAgICBpbnRlcmFjdGlvblN0YXRlOiBpbnRlcmFjdGlvblN0YXRlLFxuICAgICAgICBvbGRWaWV3U3RhdGU6IG9sZFZpZXdTdGF0ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvblZpZXdwb3J0Q2hhbmdlKSB7XG4gICAgICBvblZpZXdwb3J0Q2hhbmdlKHZpZXdTdGF0ZSwgaW50ZXJhY3Rpb25TdGF0ZSwgb2xkVmlld1N0YXRlKTtcbiAgICB9XG4gIH07XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldFJlZkhhbmRsZXMoc3RhdGljTWFwUmVmKTtcbiAgfSwgW10pO1xuICB2YXIgY29udGV4dCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcmVudENvbnRleHQpLCB7fSwge1xuICAgICAgZXZlbnRNYW5hZ2VyOiBldmVudE1hbmFnZXIsXG4gICAgICBjb250YWluZXI6IHBhcmVudENvbnRleHQuY29udGFpbmVyIHx8IGV2ZW50Q2FudmFzUmVmLmN1cnJlbnRcbiAgICB9KTtcbiAgfSwgW3BhcmVudENvbnRleHQsIGV2ZW50Q2FudmFzUmVmLmN1cnJlbnRdKTtcbiAgY29udGV4dC5vblZpZXdwb3J0Q2hhbmdlID0gaGFuZGxlVmlld3BvcnRDaGFuZ2U7XG4gIGNvbnRleHQudmlld3BvcnQgPSBwYXJlbnRDb250ZXh0LnZpZXdwb3J0IHx8IGdldFZpZXdwb3J0KHRoaXNSZWYpO1xuICB0aGlzUmVmLnZpZXdwb3J0ID0gY29udGV4dC52aWV3cG9ydDtcbiAgdmFyIGhhbmRsZUludGVyYWN0aW9uU3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVJbnRlcmFjdGlvblN0YXRlQ2hhbmdlKGludGVyYWN0aW9uU3RhdGUpIHtcbiAgICB2YXIgX2ludGVyYWN0aW9uU3RhdGUkaXNEID0gaW50ZXJhY3Rpb25TdGF0ZS5pc0RyYWdnaW5nLFxuICAgICAgaXNEcmFnZ2luZyA9IF9pbnRlcmFjdGlvblN0YXRlJGlzRCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaW50ZXJhY3Rpb25TdGF0ZSRpc0Q7XG4gICAgaWYgKGlzRHJhZ2dpbmcgIT09IHRoaXNSZWYuc3RhdGUuaXNEcmFnZ2luZykge1xuICAgICAgdGhpc1JlZi5zZXRTdGF0ZSh7XG4gICAgICAgIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmdcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaW5SZW5kZXIpIHtcbiAgICAgIHN0YXRlVXBkYXRlUmVxdWVzdGVkID0gaW50ZXJhY3Rpb25TdGF0ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG9uSW50ZXJhY3Rpb25TdGF0ZUNoYW5nZSA9IHRoaXNSZWYucHJvcHMub25JbnRlcmFjdGlvblN0YXRlQ2hhbmdlO1xuICAgIGlmIChvbkludGVyYWN0aW9uU3RhdGVDaGFuZ2UpIHtcbiAgICAgIG9uSW50ZXJhY3Rpb25TdGF0ZUNoYW5nZShpbnRlcmFjdGlvblN0YXRlKTtcbiAgICB9XG4gIH07XG4gIHZhciB1cGRhdGVDb250cm9sbGVyT3B0cyA9IGZ1bmN0aW9uIHVwZGF0ZUNvbnRyb2xsZXJPcHRzKCkge1xuICAgIGlmICh0aGlzUmVmLndpZHRoICYmIHRoaXNSZWYuaGVpZ2h0KSB7XG4gICAgICBjb250cm9sbGVyLnNldE9wdGlvbnMoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXNSZWYucHJvcHMpLCB0aGlzUmVmLnByb3BzLnZpZXdTdGF0ZSksIHt9LCB7XG4gICAgICAgIGlzSW50ZXJhY3RpdmU6IEJvb2xlYW4odGhpc1JlZi5wcm9wcy5vblZpZXdTdGF0ZUNoYW5nZSB8fCB0aGlzUmVmLnByb3BzLm9uVmlld3BvcnRDaGFuZ2UpLFxuICAgICAgICBvblZpZXdwb3J0Q2hhbmdlOiBoYW5kbGVWaWV3cG9ydENoYW5nZSxcbiAgICAgICAgb25TdGF0ZUNoYW5nZTogaGFuZGxlSW50ZXJhY3Rpb25TdGF0ZUNoYW5nZSxcbiAgICAgICAgZXZlbnRNYW5hZ2VyOiBldmVudE1hbmFnZXIsXG4gICAgICAgIHdpZHRoOiB0aGlzUmVmLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXNSZWYuaGVpZ2h0XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuICB2YXIgb25SZXNpemUgPSBmdW5jdGlvbiBvblJlc2l6ZShfcmVmMikge1xuICAgIHZhciB3aWR0aCA9IF9yZWYyLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgIHRoaXNSZWYud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzUmVmLmhlaWdodCA9IGhlaWdodDtcbiAgICB1cGRhdGVDb250cm9sbGVyT3B0cygpO1xuICAgIHRoaXNSZWYucHJvcHMub25SZXNpemUoe1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9KTtcbiAgfTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBldmVudE1hbmFnZXIuc2V0RWxlbWVudChldmVudENhbnZhc1JlZi5jdXJyZW50KTtcbiAgICBldmVudE1hbmFnZXIub24oe1xuICAgICAgcG9pbnRlcmRvd246IG9uUG9pbnRlckRvd24uYmluZCh0aGlzUmVmKSxcbiAgICAgIHBvaW50ZXJtb3ZlOiBvblBvaW50ZXJNb3ZlLmJpbmQodGhpc1JlZiksXG4gICAgICBwb2ludGVydXA6IG9uUG9pbnRlclVwLmJpbmQodGhpc1JlZiksXG4gICAgICBwb2ludGVybGVhdmU6IG9uRXZlbnQuYmluZCh0aGlzUmVmLCAnb25Nb3VzZU91dCcpLFxuICAgICAgY2xpY2s6IG9uUG9pbnRlckNsaWNrLmJpbmQodGhpc1JlZiksXG4gICAgICBhbnljbGljazogb25Qb2ludGVyQ2xpY2suYmluZCh0aGlzUmVmKSxcbiAgICAgIGRibGNsaWNrOiBvbkV2ZW50LmJpbmQodGhpc1JlZiwgJ29uRGJsQ2xpY2snKSxcbiAgICAgIHdoZWVsOiBvbkV2ZW50LmJpbmQodGhpc1JlZiwgJ29uV2hlZWwnKSxcbiAgICAgIGNvbnRleHRtZW51OiBvbkV2ZW50LmJpbmQodGhpc1JlZiwgJ29uQ29udGV4dE1lbnUnKVxuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBldmVudE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHZpZXdwb3J0VXBkYXRlUmVxdWVzdGVkKSB7XG4gICAgICBoYW5kbGVWaWV3cG9ydENoYW5nZS5hcHBseSh2b2lkIDAsIF90b0NvbnN1bWFibGVBcnJheSh2aWV3cG9ydFVwZGF0ZVJlcXVlc3RlZCkpO1xuICAgIH1cbiAgICBpZiAoc3RhdGVVcGRhdGVSZXF1ZXN0ZWQpIHtcbiAgICAgIGhhbmRsZUludGVyYWN0aW9uU3RhdGVDaGFuZ2Uoc3RhdGVVcGRhdGVSZXF1ZXN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIHVwZGF0ZUNvbnRyb2xsZXJPcHRzKCk7XG4gIHZhciB3aWR0aCA9IHByb3BzLndpZHRoLFxuICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCxcbiAgICBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgIGdldEN1cnNvciA9IHByb3BzLmdldEN1cnNvcjtcbiAgdmFyIGV2ZW50Q2FudmFzU3R5bGUgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgfSwgc3R5bGUpLCB7fSwge1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICBjdXJzb3I6IGdldEN1cnNvcih0aGlzUmVmLnN0YXRlKVxuICAgIH0pO1xuICB9LCBbc3R5bGUsIHdpZHRoLCBoZWlnaHQsIGdldEN1cnNvciwgdGhpc1JlZi5zdGF0ZV0pO1xuICBpZiAoIXZpZXdwb3J0VXBkYXRlUmVxdWVzdGVkIHx8ICF0aGlzUmVmLl9jaGlsZCkge1xuICAgIHRoaXNSZWYuX2NoaWxkID0gUmVhY3QuY3JlYXRlRWxlbWVudChNYXBDb250ZXh0UHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBjb250ZXh0XG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBrZXk6IFwiZXZlbnQtY2FudmFzXCIsXG4gICAgICByZWY6IGV2ZW50Q2FudmFzUmVmLFxuICAgICAgc3R5bGU6IGV2ZW50Q2FudmFzU3R5bGVcbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFN0YXRpY01hcCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgc3R5bGU6IG51bGwsXG4gICAgICBvblJlc2l6ZTogb25SZXNpemUsXG4gICAgICByZWY6IHN0YXRpY01hcFJlZlxuICAgIH0pKSkpO1xuICB9XG4gIGluUmVuZGVyID0gZmFsc2U7XG4gIHJldHVybiB0aGlzUmVmLl9jaGlsZDtcbn0pO1xuSW50ZXJhY3RpdmVNYXAuc3VwcG9ydGVkID0gU3RhdGljTWFwLnN1cHBvcnRlZDtcbkludGVyYWN0aXZlTWFwLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbkludGVyYWN0aXZlTWFwLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbmV4cG9ydCBkZWZhdWx0IEludGVyYWN0aXZlTWFwOyIsImltcG9ydCBfdHlwZW9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2ZcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFhIHx8ICFiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGIpIHx8IGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoX3R5cGVvZihhKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihiKSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcbiAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYUtleXMgPSBhS2V5czsgX2kgPCBfYUtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIga2V5ID0gX2FLZXlzW19pXTtcbiAgICAgIGlmICghYi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn0iLCJpbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlU3RhdGUsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNsb25lRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBNYXBDb250ZXh0IGZyb20gJy4vbWFwLWNvbnRleHQnO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi91dGlscy9hc3NlcnQnO1xuaW1wb3J0IGRlZXBFcXVhbCBmcm9tICcuLi91dGlscy9kZWVwLWVxdWFsJztcbnZhciBzb3VyY2VDb3VudGVyID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZVNvdXJjZShtYXAsIGlkLCBwcm9wcykge1xuICBpZiAobWFwICYmIG1hcC5zdHlsZSAmJiBtYXAuc3R5bGUuX2xvYWRlZCkge1xuICAgIHZhciBvcHRpb25zID0gX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpO1xuICAgIGRlbGV0ZSBvcHRpb25zLmlkO1xuICAgIGRlbGV0ZSBvcHRpb25zLmNoaWxkcmVuO1xuICAgIG1hcC5hZGRTb3VyY2UoaWQsIG9wdGlvbnMpO1xuICAgIHJldHVybiBtYXAuZ2V0U291cmNlKGlkKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVNvdXJjZShzb3VyY2UsIHByb3BzLCBwcmV2UHJvcHMpIHtcbiAgYXNzZXJ0KHByb3BzLmlkID09PSBwcmV2UHJvcHMuaWQsICdzb3VyY2UgaWQgY2hhbmdlZCcpO1xuICBhc3NlcnQocHJvcHMudHlwZSA9PT0gcHJldlByb3BzLnR5cGUsICdzb3VyY2UgdHlwZSBjaGFuZ2VkJyk7XG4gIHZhciBjaGFuZ2VkS2V5ID0gJyc7XG4gIHZhciBjaGFuZ2VkS2V5Q291bnQgPSAwO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2lkJyAmJiAhZGVlcEVxdWFsKHByZXZQcm9wc1trZXldLCBwcm9wc1trZXldKSkge1xuICAgICAgY2hhbmdlZEtleSA9IGtleTtcbiAgICAgIGNoYW5nZWRLZXlDb3VudCsrO1xuICAgIH1cbiAgfVxuICBpZiAoIWNoYW5nZWRLZXlDb3VudCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdHlwZSA9IHByb3BzLnR5cGU7XG4gIGlmICh0eXBlID09PSAnZ2VvanNvbicpIHtcbiAgICBzb3VyY2Uuc2V0RGF0YShwcm9wcy5kYXRhKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnaW1hZ2UnKSB7XG4gICAgc291cmNlLnVwZGF0ZUltYWdlKHtcbiAgICAgIHVybDogcHJvcHMudXJsLFxuICAgICAgY29vcmRpbmF0ZXM6IHByb3BzLmNvb3JkaW5hdGVzXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoKHR5cGUgPT09ICdjYW52YXMnIHx8IHR5cGUgPT09ICd2aWRlbycpICYmIGNoYW5nZWRLZXlDb3VudCA9PT0gMSAmJiBjaGFuZ2VkS2V5ID09PSAnY29vcmRpbmF0ZXMnKSB7XG4gICAgc291cmNlLnNldENvb3JkaW5hdGVzKHByb3BzLmNvb3JkaW5hdGVzKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAndmVjdG9yJyAmJiBzb3VyY2Uuc2V0VXJsKSB7XG4gICAgc3dpdGNoIChjaGFuZ2VkS2V5KSB7XG4gICAgICBjYXNlICd1cmwnOlxuICAgICAgICBzb3VyY2Uuc2V0VXJsKHByb3BzLnVybCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGlsZXMnOlxuICAgICAgICBzb3VyY2Uuc2V0VGlsZXMocHJvcHMudGlsZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybihcIlVuYWJsZSB0byB1cGRhdGUgPFNvdXJjZT4gcHJvcDogXCIuY29uY2F0KGNoYW5nZWRLZXkpKTtcbiAgfVxufVxuZnVuY3Rpb24gU291cmNlKHByb3BzKSB7XG4gIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgdmFyIHByb3BzUmVmID0gdXNlUmVmKHtcbiAgICBpZDogcHJvcHMuaWQsXG4gICAgdHlwZTogcHJvcHMudHlwZVxuICB9KTtcbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKDApLFxuICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgIHNldFN0eWxlTG9hZGVkID0gX3VzZVN0YXRlMlsxXTtcbiAgdmFyIGlkID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb3BzLmlkIHx8IFwianN4LXNvdXJjZS1cIi5jb25jYXQoc291cmNlQ291bnRlcisrKTtcbiAgfSwgW10pO1xuICB2YXIgbWFwID0gY29udGV4dC5tYXA7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG1hcCkge1xuICAgICAgdmFyIGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIHJldHVybiBzZXRTdHlsZUxvYWRlZChmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgIHJldHVybiB2ZXJzaW9uICsgMTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgbWFwLm9uKCdzdHlsZWRhdGEnLCBmb3JjZVVwZGF0ZSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBtYXAub2ZmKCdzdHlsZWRhdGEnLCBmb3JjZVVwZGF0ZSk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG1hcC5zdHlsZSAmJiBtYXAuc3R5bGUuX2xvYWRlZCAmJiBtYXAuZ2V0U291cmNlKGlkKSkge1xuICAgICAgICAgICAgbWFwLnJlbW92ZVNvdXJjZShpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sIFttYXAsIGlkXSk7XG4gIHZhciBzb3VyY2UgPSBtYXAgJiYgbWFwLnN0eWxlICYmIG1hcC5nZXRTb3VyY2UoaWQpO1xuICBpZiAoc291cmNlKSB7XG4gICAgdXBkYXRlU291cmNlKHNvdXJjZSwgcHJvcHMsIHByb3BzUmVmLmN1cnJlbnQpO1xuICB9IGVsc2Uge1xuICAgIHNvdXJjZSA9IGNyZWF0ZVNvdXJjZShtYXAsIGlkLCBwcm9wcyk7XG4gIH1cbiAgcHJvcHNSZWYuY3VycmVudCA9IHByb3BzO1xuICByZXR1cm4gc291cmNlICYmIFJlYWN0LkNoaWxkcmVuLm1hcChwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkICYmIGNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgc291cmNlOiBpZFxuICAgIH0pO1xuICB9KSB8fCBudWxsO1xufVxuZXhwb3J0IGRlZmF1bHQgU291cmNlOyIsImZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHIsIGUpIHtcbiAgaWYgKG51bGwgPT0gcikgcmV0dXJuIHt9O1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBuIGluIHIpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIG4pKSB7XG4gICAgaWYgKGUuaW5jbHVkZXMobikpIGNvbnRpbnVlO1xuICAgIHRbbl0gPSByW25dO1xuICB9XG4gIHJldHVybiB0O1xufVxuZXhwb3J0IHsgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCIuL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanNcIjtcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhlLCB0KSB7XG4gIGlmIChudWxsID09IGUpIHJldHVybiB7fTtcbiAgdmFyIG8sXG4gICAgcixcbiAgICBpID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShlLCB0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgZm9yIChyID0gMDsgciA8IHMubGVuZ3RoOyByKyspIG8gPSBzW3JdLCB0LmluY2x1ZGVzKG8pIHx8IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSwgbykgJiYgKGlbb10gPSBlW29dKTtcbiAgfVxuICByZXR1cm4gaTtcbn1cbmV4cG9ydCB7IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBhcyBkZWZhdWx0IH07IiwiaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VTdGF0ZSwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IE1hcENvbnRleHQgZnJvbSAnLi9tYXAtY29udGV4dCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uL3V0aWxzL2Fzc2VydCc7XG5pbXBvcnQgZGVlcEVxdWFsIGZyb20gJy4uL3V0aWxzL2RlZXAtZXF1YWwnO1xudmFyIExBWUVSX1RZUEVTID0gWydmaWxsJywgJ2xpbmUnLCAnc3ltYm9sJywgJ2NpcmNsZScsICdmaWxsLWV4dHJ1c2lvbicsICdyYXN0ZXInLCAnYmFja2dyb3VuZCcsICdoZWF0bWFwJywgJ2hpbGxzaGFkZScsICdza3knXTtcbnZhciBwcm9wVHlwZXMgPSB7XG4gIHR5cGU6IFByb3BUeXBlcy5vbmVPZihMQVlFUl9UWVBFUykuaXNSZXF1aXJlZCxcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHNvdXJjZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgYmVmb3JlSWQ6IFByb3BUeXBlcy5zdHJpbmdcbn07XG5mdW5jdGlvbiBkaWZmTGF5ZXJTdHlsZXMobWFwLCBpZCwgcHJvcHMsIHByZXZQcm9wcykge1xuICB2YXIgX3Byb3BzJGxheW91dCA9IHByb3BzLmxheW91dCxcbiAgICBsYXlvdXQgPSBfcHJvcHMkbGF5b3V0ID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRsYXlvdXQsXG4gICAgX3Byb3BzJHBhaW50ID0gcHJvcHMucGFpbnQsXG4gICAgcGFpbnQgPSBfcHJvcHMkcGFpbnQgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJHBhaW50LFxuICAgIGZpbHRlciA9IHByb3BzLmZpbHRlcixcbiAgICBtaW56b29tID0gcHJvcHMubWluem9vbSxcbiAgICBtYXh6b29tID0gcHJvcHMubWF4em9vbSxcbiAgICBiZWZvcmVJZCA9IHByb3BzLmJlZm9yZUlkLFxuICAgIG90aGVyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImxheW91dFwiLCBcInBhaW50XCIsIFwiZmlsdGVyXCIsIFwibWluem9vbVwiLCBcIm1heHpvb21cIiwgXCJiZWZvcmVJZFwiXSk7XG4gIGlmIChiZWZvcmVJZCAhPT0gcHJldlByb3BzLmJlZm9yZUlkKSB7XG4gICAgbWFwLm1vdmVMYXllcihpZCwgYmVmb3JlSWQpO1xuICB9XG4gIGlmIChsYXlvdXQgIT09IHByZXZQcm9wcy5sYXlvdXQpIHtcbiAgICB2YXIgcHJldkxheW91dCA9IHByZXZQcm9wcy5sYXlvdXQgfHwge307XG4gICAgZm9yICh2YXIga2V5IGluIGxheW91dCkge1xuICAgICAgaWYgKCFkZWVwRXF1YWwobGF5b3V0W2tleV0sIHByZXZMYXlvdXRba2V5XSkpIHtcbiAgICAgICAgbWFwLnNldExheW91dFByb3BlcnR5KGlkLCBrZXksIGxheW91dFtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgX2tleSBpbiBwcmV2TGF5b3V0KSB7XG4gICAgICBpZiAoIWxheW91dC5oYXNPd25Qcm9wZXJ0eShfa2V5KSkge1xuICAgICAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkoaWQsIF9rZXksIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwYWludCAhPT0gcHJldlByb3BzLnBhaW50KSB7XG4gICAgdmFyIHByZXZQYWludCA9IHByZXZQcm9wcy5wYWludCB8fCB7fTtcbiAgICBmb3IgKHZhciBfa2V5MiBpbiBwYWludCkge1xuICAgICAgaWYgKCFkZWVwRXF1YWwocGFpbnRbX2tleTJdLCBwcmV2UGFpbnRbX2tleTJdKSkge1xuICAgICAgICBtYXAuc2V0UGFpbnRQcm9wZXJ0eShpZCwgX2tleTIsIHBhaW50W19rZXkyXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIF9rZXkzIGluIHByZXZQYWludCkge1xuICAgICAgaWYgKCFwYWludC5oYXNPd25Qcm9wZXJ0eShfa2V5MykpIHtcbiAgICAgICAgbWFwLnNldFBhaW50UHJvcGVydHkoaWQsIF9rZXkzLCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWRlZXBFcXVhbChmaWx0ZXIsIHByZXZQcm9wcy5maWx0ZXIpKSB7XG4gICAgbWFwLnNldEZpbHRlcihpZCwgZmlsdGVyKTtcbiAgfVxuICBpZiAobWluem9vbSAhPT0gcHJldlByb3BzLm1pbnpvb20gfHwgbWF4em9vbSAhPT0gcHJldlByb3BzLm1heHpvb20pIHtcbiAgICBtYXAuc2V0TGF5ZXJab29tUmFuZ2UoaWQsIG1pbnpvb20sIG1heHpvb20pO1xuICB9XG4gIGZvciAodmFyIF9rZXk0IGluIG90aGVyUHJvcHMpIHtcbiAgICBpZiAoIWRlZXBFcXVhbChvdGhlclByb3BzW19rZXk0XSwgcHJldlByb3BzW19rZXk0XSkpIHtcbiAgICAgIG1hcC5zZXRMYXllclByb3BlcnR5KGlkLCBfa2V5NCwgb3RoZXJQcm9wc1tfa2V5NF0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTGF5ZXIobWFwLCBpZCwgcHJvcHMpIHtcbiAgaWYgKG1hcC5zdHlsZSAmJiBtYXAuc3R5bGUuX2xvYWRlZCkge1xuICAgIHZhciBvcHRpb25zID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgICBpZDogaWRcbiAgICB9KTtcbiAgICBkZWxldGUgb3B0aW9ucy5iZWZvcmVJZDtcbiAgICBtYXAuYWRkTGF5ZXIob3B0aW9ucywgcHJvcHMuYmVmb3JlSWQpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVMYXllcihtYXAsIGlkLCBwcm9wcywgcHJldlByb3BzKSB7XG4gIGFzc2VydChwcm9wcy5pZCA9PT0gcHJldlByb3BzLmlkLCAnbGF5ZXIgaWQgY2hhbmdlZCcpO1xuICBhc3NlcnQocHJvcHMudHlwZSA9PT0gcHJldlByb3BzLnR5cGUsICdsYXllciB0eXBlIGNoYW5nZWQnKTtcbiAgdHJ5IHtcbiAgICBkaWZmTGF5ZXJTdHlsZXMobWFwLCBpZCwgcHJvcHMsIHByZXZQcm9wcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS53YXJuKGVycm9yKTtcbiAgfVxufVxudmFyIGxheWVyQ291bnRlciA9IDA7XG5mdW5jdGlvbiBMYXllcihwcm9wcykge1xuICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gIHZhciBwcm9wc1JlZiA9IHVzZVJlZih7XG4gICAgaWQ6IHByb3BzLmlkLFxuICAgIHR5cGU6IHByb3BzLnR5cGVcbiAgfSk7XG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZSgwKSxcbiAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICBzZXRTdHlsZUxvYWRlZCA9IF91c2VTdGF0ZTJbMV07XG4gIHZhciBpZCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9wcy5pZCB8fCBcImpzeC1sYXllci1cIi5jb25jYXQobGF5ZXJDb3VudGVyKyspO1xuICB9LCBbXSk7XG4gIHZhciBtYXAgPSBjb250ZXh0Lm1hcDtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobWFwKSB7XG4gICAgICB2YXIgZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHNldFN0eWxlTG9hZGVkKGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHZlcnNpb24gKyAxO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBtYXAub24oJ3N0eWxlZGF0YScsIGZvcmNlVXBkYXRlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1hcC5vZmYoJ3N0eWxlZGF0YScsIGZvcmNlVXBkYXRlKTtcbiAgICAgICAgaWYgKG1hcC5zdHlsZSAmJiBtYXAuc3R5bGUuX2xvYWRlZCkge1xuICAgICAgICAgIG1hcC5yZW1vdmVMYXllcihpZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sIFttYXBdKTtcbiAgdmFyIGxheWVyID0gbWFwICYmIG1hcC5zdHlsZSAmJiBtYXAuZ2V0TGF5ZXIoaWQpO1xuICBpZiAobGF5ZXIpIHtcbiAgICB1cGRhdGVMYXllcihtYXAsIGlkLCBwcm9wcywgcHJvcHNSZWYuY3VycmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY3JlYXRlTGF5ZXIobWFwLCBpZCwgcHJvcHMpO1xuICB9XG4gIHByb3BzUmVmLmN1cnJlbnQgPSBwcm9wcztcbiAgcmV0dXJuIG51bGw7XG59XG5MYXllci5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5leHBvcnQgZGVmYXVsdCBMYXllcjsiLCJpbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VSZWYsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBNYXBDb250ZXh0IGZyb20gJy4vbWFwLWNvbnRleHQnO1xuZXhwb3J0IHZhciBtYXBDb250cm9sRGVmYXVsdFByb3BzID0ge1xuICBjYXB0dXJlU2Nyb2xsOiBmYWxzZSxcbiAgY2FwdHVyZURyYWc6IHRydWUsXG4gIGNhcHR1cmVDbGljazogdHJ1ZSxcbiAgY2FwdHVyZURvdWJsZUNsaWNrOiB0cnVlLFxuICBjYXB0dXJlUG9pbnRlck1vdmU6IGZhbHNlXG59O1xuZXhwb3J0IHZhciBtYXBDb250cm9sUHJvcFR5cGVzID0ge1xuICBjYXB0dXJlU2Nyb2xsOiBQcm9wVHlwZXMuYm9vbCxcbiAgY2FwdHVyZURyYWc6IFByb3BUeXBlcy5ib29sLFxuICBjYXB0dXJlQ2xpY2s6IFByb3BUeXBlcy5ib29sLFxuICBjYXB0dXJlRG91YmxlQ2xpY2s6IFByb3BUeXBlcy5ib29sLFxuICBjYXB0dXJlUG9pbnRlck1vdmU6IFByb3BUeXBlcy5ib29sXG59O1xuZnVuY3Rpb24gb25Nb3VudCh0aGlzUmVmKSB7XG4gIHZhciByZWYgPSB0aGlzUmVmLmNvbnRhaW5lclJlZi5jdXJyZW50O1xuICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpc1JlZi5jb250ZXh0LmV2ZW50TWFuYWdlcjtcbiAgaWYgKCFyZWYgfHwgIWV2ZW50TWFuYWdlcikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIGV2ZW50cyA9IHtcbiAgICB3aGVlbDogZnVuY3Rpb24gd2hlZWwoZXZ0KSB7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzUmVmLnByb3BzO1xuICAgICAgaWYgKHByb3BzLmNhcHR1cmVTY3JvbGwpIHtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLm9uU2Nyb2xsKSB7XG4gICAgICAgIHByb3BzLm9uU2Nyb2xsKGV2dCwgdGhpc1JlZik7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYW5zdGFydDogZnVuY3Rpb24gcGFuc3RhcnQoZXZ0KSB7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzUmVmLnByb3BzO1xuICAgICAgaWYgKHByb3BzLmNhcHR1cmVEcmFnKSB7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5vbkRyYWdTdGFydCkge1xuICAgICAgICBwcm9wcy5vbkRyYWdTdGFydChldnQsIHRoaXNSZWYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYW55Y2xpY2s6IGZ1bmN0aW9uIGFueWNsaWNrKGV2dCkge1xuICAgICAgdmFyIHByb3BzID0gdGhpc1JlZi5wcm9wcztcbiAgICAgIGlmIChwcm9wcy5jYXB0dXJlQ2xpY2spIHtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLm9uTmF0aXZlQ2xpY2spIHtcbiAgICAgICAgcHJvcHMub25OYXRpdmVDbGljayhldnQsIHRoaXNSZWYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKGV2dCkge1xuICAgICAgdmFyIHByb3BzID0gdGhpc1JlZi5wcm9wcztcbiAgICAgIGlmIChwcm9wcy5jYXB0dXJlQ2xpY2spIHtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLm9uQ2xpY2spIHtcbiAgICAgICAgcHJvcHMub25DbGljayhldnQsIHRoaXNSZWYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGJsY2xpY2s6IGZ1bmN0aW9uIGRibGNsaWNrKGV2dCkge1xuICAgICAgdmFyIHByb3BzID0gdGhpc1JlZi5wcm9wcztcbiAgICAgIGlmIChwcm9wcy5jYXB0dXJlRG91YmxlQ2xpY2spIHtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLm9uRG91YmxlQ2xpY2spIHtcbiAgICAgICAgcHJvcHMub25Eb3VibGVDbGljayhldnQsIHRoaXNSZWYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcG9pbnRlcm1vdmU6IGZ1bmN0aW9uIHBvaW50ZXJtb3ZlKGV2dCkge1xuICAgICAgdmFyIHByb3BzID0gdGhpc1JlZi5wcm9wcztcbiAgICAgIGlmIChwcm9wcy5jYXB0dXJlUG9pbnRlck1vdmUpIHtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLm9uUG9pbnRlck1vdmUpIHtcbiAgICAgICAgcHJvcHMub25Qb2ludGVyTW92ZShldnQsIHRoaXNSZWYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZXZlbnRNYW5hZ2VyLndhdGNoKGV2ZW50cywgcmVmKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBldmVudE1hbmFnZXIub2ZmKGV2ZW50cyk7XG4gIH07XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VNYXBDb250cm9sKCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gIHZhciBjb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBfdGhpc1JlZiA9IHVzZVJlZih7XG4gICAgcHJvcHM6IHByb3BzLFxuICAgIHN0YXRlOiB7fSxcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIGNvbnRhaW5lclJlZjogY29udGFpbmVyUmVmXG4gIH0pO1xuICB2YXIgdGhpc1JlZiA9IF90aGlzUmVmLmN1cnJlbnQ7XG4gIHRoaXNSZWYucHJvcHMgPSBwcm9wcztcbiAgdGhpc1JlZi5jb250ZXh0ID0gY29udGV4dDtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gb25Nb3VudCh0aGlzUmVmKTtcbiAgfSwgW2NvbnRleHQuZXZlbnRNYW5hZ2VyXSk7XG4gIHJldHVybiB0aGlzUmVmO1xufSIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2Fzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCI7XG5pbXBvcnQgX2luaGVyaXRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c1wiO1xuaW1wb3J0IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI7XG5pbXBvcnQgX2dldFByb3RvdHlwZU9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZlwiO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgcmVzdWx0O1xuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUHVyZUNvbXBvbmVudCwgY3JlYXRlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZU1hcENvbnRyb2wsIHsgbWFwQ29udHJvbERlZmF1bHRQcm9wcywgbWFwQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4vdXNlLW1hcC1jb250cm9sJztcbmZ1bmN0aW9uIENvbnRyb2wocHJvcHMpIHtcbiAgdmFyIGluc3RhbmNlID0gcHJvcHMuaW5zdGFuY2U7XG4gIHZhciBfdXNlTWFwQ29udHJvbCA9IHVzZU1hcENvbnRyb2wocHJvcHMpLFxuICAgIGNvbnRleHQgPSBfdXNlTWFwQ29udHJvbC5jb250ZXh0LFxuICAgIGNvbnRhaW5lclJlZiA9IF91c2VNYXBDb250cm9sLmNvbnRhaW5lclJlZjtcbiAgaW5zdGFuY2UuX2NvbnRleHQgPSBjb250ZXh0O1xuICBpbnN0YW5jZS5fY29udGFpbmVyUmVmID0gY29udGFpbmVyUmVmO1xuICByZXR1cm4gaW5zdGFuY2UuX3JlbmRlcigpO1xufVxudmFyIEJhc2VDb250cm9sID0gZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhCYXNlQ29udHJvbCwgX1B1cmVDb21wb25lbnQpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEJhc2VDb250cm9sKTtcbiAgZnVuY3Rpb24gQmFzZUNvbnRyb2woKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlQ29udHJvbCk7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsLmFwcGx5KF9zdXBlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9jb250ZXh0XCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX2NvbnRhaW5lclJlZlwiLCBjcmVhdGVSZWYoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9vblNjcm9sbFwiLCBmdW5jdGlvbiAoZXZ0KSB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9vbkRyYWdTdGFydFwiLCBmdW5jdGlvbiAoZXZ0KSB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9vbkRibENsaWNrXCIsIGZ1bmN0aW9uIChldnQpIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX29uQ2xpY2tcIiwgZnVuY3Rpb24gKGV2dCkge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfb25Qb2ludGVyTW92ZVwiLCBmdW5jdGlvbiAoZXZ0KSB7fSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhCYXNlQ29udHJvbCwgW3tcbiAgICBrZXk6IFwiX3JlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdfcmVuZGVyKCkgbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb250cm9sLCBfZXh0ZW5kcyh7XG4gICAgICAgIGluc3RhbmNlOiB0aGlzXG4gICAgICB9LCB0aGlzLnByb3BzLCB7XG4gICAgICAgIG9uU2Nyb2xsOiB0aGlzLl9vblNjcm9sbCxcbiAgICAgICAgb25EcmFnU3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuICAgICAgICBvbkRibENsaWNrOiB0aGlzLl9vbkRibENsaWNrLFxuICAgICAgICBvbkNsaWNrOiB0aGlzLl9vbkNsaWNrLFxuICAgICAgICBvblBvaW50ZXJNb3ZlOiB0aGlzLl9vblBvaW50ZXJNb3ZlXG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCYXNlQ29udHJvbDtcbn0oUHVyZUNvbXBvbmVudCk7XG5fZGVmaW5lUHJvcGVydHkoQmFzZUNvbnRyb2wsIFwicHJvcFR5cGVzXCIsIG1hcENvbnRyb2xQcm9wVHlwZXMpO1xuX2RlZmluZVByb3BlcnR5KEJhc2VDb250cm9sLCBcImRlZmF1bHRQcm9wc1wiLCBtYXBDb250cm9sRGVmYXVsdFByb3BzKTtcbmV4cG9ydCB7IEJhc2VDb250cm9sIGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmltcG9ydCAqIGFzIFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sRGVmYXVsdFByb3BzLCBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi91c2UtbWFwLWNvbnRyb2wnO1xuZXhwb3J0IHZhciBkcmFnZ2FibGVDb250cm9sUHJvcFR5cGVzID0gT2JqZWN0LmFzc2lnbih7fSwgbWFwQ29udHJvbFByb3BUeXBlcywge1xuICBkcmFnZ2FibGU6IFByb3BUeXBlcy5ib29sLFxuICBvbkRyYWc6IFByb3BUeXBlcy5mdW5jLFxuICBvbkRyYWdFbmQ6IFByb3BUeXBlcy5mdW5jLFxuICBvbkRyYWdTdGFydDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9mZnNldExlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIG9mZnNldFRvcDogUHJvcFR5cGVzLm51bWJlclxufSk7XG5leHBvcnQgdmFyIGRyYWdnYWJsZUNvbnRyb2xEZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXBDb250cm9sRGVmYXVsdFByb3BzLCB7XG4gIGRyYWdnYWJsZTogZmFsc2UsXG4gIG9mZnNldExlZnQ6IDAsXG4gIG9mZnNldFRvcDogMFxufSk7XG5mdW5jdGlvbiBnZXREcmFnRXZlbnRQb3NpdGlvbihldmVudCkge1xuICB2YXIgX2V2ZW50JG9mZnNldENlbnRlciA9IGV2ZW50Lm9mZnNldENlbnRlcixcbiAgICB4ID0gX2V2ZW50JG9mZnNldENlbnRlci54LFxuICAgIHkgPSBfZXZlbnQkb2Zmc2V0Q2VudGVyLnk7XG4gIHJldHVybiBbeCwgeV07XG59XG5mdW5jdGlvbiBnZXREcmFnRXZlbnRPZmZzZXQoZXZlbnQsIGNvbnRhaW5lcikge1xuICB2YXIgX2V2ZW50JGNlbnRlciA9IGV2ZW50LmNlbnRlcixcbiAgICB4ID0gX2V2ZW50JGNlbnRlci54LFxuICAgIHkgPSBfZXZlbnQkY2VudGVyLnk7XG4gIGlmIChjb250YWluZXIpIHtcbiAgICB2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gW3JlY3QubGVmdCAtIHgsIHJlY3QudG9wIC0geV07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXREcmFnTG5nTGF0KGRyYWdQb3MsIGRyYWdPZmZzZXQsIHByb3BzLCBjb250ZXh0KSB7XG4gIHZhciB4ID0gZHJhZ1Bvc1swXSArIGRyYWdPZmZzZXRbMF0gLSBwcm9wcy5vZmZzZXRMZWZ0O1xuICB2YXIgeSA9IGRyYWdQb3NbMV0gKyBkcmFnT2Zmc2V0WzFdIC0gcHJvcHMub2Zmc2V0VG9wO1xuICByZXR1cm4gY29udGV4dC52aWV3cG9ydC51bnByb2plY3QoW3gsIHldKTtcbn1cbmZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGV2ZW50LCBfcmVmKSB7XG4gIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgY2FsbGJhY2tzID0gX3JlZi5jYWxsYmFja3MsXG4gICAgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXG4gICAgY29udGFpbmVyUmVmID0gX3JlZi5jb250YWluZXJSZWY7XG4gIHZhciBkcmFnZ2FibGUgPSBwcm9wcy5kcmFnZ2FibGU7XG4gIGlmICghZHJhZ2dhYmxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB2YXIgZHJhZ1BvcyA9IGdldERyYWdFdmVudFBvc2l0aW9uKGV2ZW50KTtcbiAgdmFyIGRyYWdPZmZzZXQgPSBnZXREcmFnRXZlbnRPZmZzZXQoZXZlbnQsIGNvbnRhaW5lclJlZi5jdXJyZW50KTtcbiAgc3RhdGUuc2V0RHJhZ1BvcyhkcmFnUG9zKTtcbiAgc3RhdGUuc2V0RHJhZ09mZnNldChkcmFnT2Zmc2V0KTtcbiAgaWYgKGNhbGxiYWNrcy5vbkRyYWdTdGFydCAmJiBkcmFnT2Zmc2V0KSB7XG4gICAgdmFyIGNhbGxiYWNrRXZlbnQgPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCk7XG4gICAgY2FsbGJhY2tFdmVudC5sbmdMYXQgPSBnZXREcmFnTG5nTGF0KGRyYWdQb3MsIGRyYWdPZmZzZXQsIHByb3BzLCBjb250ZXh0KTtcbiAgICBjYWxsYmFja3Mub25EcmFnU3RhcnQoY2FsbGJhY2tFdmVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9uRHJhZyhldmVudCwgX3JlZjIpIHtcbiAgdmFyIHByb3BzID0gX3JlZjIucHJvcHMsXG4gICAgY2FsbGJhY2tzID0gX3JlZjIuY2FsbGJhY2tzLFxuICAgIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgY29udGV4dCA9IF9yZWYyLmNvbnRleHQ7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB2YXIgZHJhZ1BvcyA9IGdldERyYWdFdmVudFBvc2l0aW9uKGV2ZW50KTtcbiAgc3RhdGUuc2V0RHJhZ1BvcyhkcmFnUG9zKTtcbiAgdmFyIGRyYWdPZmZzZXQgPSBzdGF0ZS5kcmFnT2Zmc2V0O1xuICBpZiAoY2FsbGJhY2tzLm9uRHJhZyAmJiBkcmFnT2Zmc2V0KSB7XG4gICAgdmFyIGNhbGxiYWNrRXZlbnQgPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCk7XG4gICAgY2FsbGJhY2tFdmVudC5sbmdMYXQgPSBnZXREcmFnTG5nTGF0KGRyYWdQb3MsIGRyYWdPZmZzZXQsIHByb3BzLCBjb250ZXh0KTtcbiAgICBjYWxsYmFja3Mub25EcmFnKGNhbGxiYWNrRXZlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBvbkRyYWdFbmQoZXZlbnQsIF9yZWYzKSB7XG4gIHZhciBwcm9wcyA9IF9yZWYzLnByb3BzLFxuICAgIGNhbGxiYWNrcyA9IF9yZWYzLmNhbGxiYWNrcyxcbiAgICBzdGF0ZSA9IF9yZWYzLnN0YXRlLFxuICAgIGNvbnRleHQgPSBfcmVmMy5jb250ZXh0O1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgdmFyIGRyYWdQb3MgPSBzdGF0ZS5kcmFnUG9zLFxuICAgIGRyYWdPZmZzZXQgPSBzdGF0ZS5kcmFnT2Zmc2V0O1xuICBzdGF0ZS5zZXREcmFnUG9zKG51bGwpO1xuICBzdGF0ZS5zZXREcmFnT2Zmc2V0KG51bGwpO1xuICBpZiAoY2FsbGJhY2tzLm9uRHJhZ0VuZCAmJiBkcmFnUG9zICYmIGRyYWdPZmZzZXQpIHtcbiAgICB2YXIgY2FsbGJhY2tFdmVudCA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50KTtcbiAgICBjYWxsYmFja0V2ZW50LmxuZ0xhdCA9IGdldERyYWdMbmdMYXQoZHJhZ1BvcywgZHJhZ09mZnNldCwgcHJvcHMsIGNvbnRleHQpO1xuICAgIGNhbGxiYWNrcy5vbkRyYWdFbmQoY2FsbGJhY2tFdmVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9uRHJhZ0NhbmNlbChldmVudCwgX3JlZjQpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjQuc3RhdGU7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICBzdGF0ZS5zZXREcmFnUG9zKG51bGwpO1xuICBzdGF0ZS5zZXREcmFnT2Zmc2V0KG51bGwpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHModGhpc1JlZikge1xuICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpc1JlZi5jb250ZXh0LmV2ZW50TWFuYWdlcjtcbiAgaWYgKCFldmVudE1hbmFnZXIgfHwgIXRoaXNSZWYuc3RhdGUuZHJhZ1Bvcykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIGV2ZW50cyA9IHtcbiAgICBwYW5tb3ZlOiBmdW5jdGlvbiBwYW5tb3ZlKGV2dCkge1xuICAgICAgcmV0dXJuIG9uRHJhZyhldnQsIHRoaXNSZWYpO1xuICAgIH0sXG4gICAgcGFuZW5kOiBmdW5jdGlvbiBwYW5lbmQoZXZ0KSB7XG4gICAgICByZXR1cm4gb25EcmFnRW5kKGV2dCwgdGhpc1JlZik7XG4gICAgfSxcbiAgICBwYW5jYW5jZWw6IGZ1bmN0aW9uIHBhbmNhbmNlbChldnQpIHtcbiAgICAgIHJldHVybiBvbkRyYWdDYW5jZWwoZXZ0LCB0aGlzUmVmKTtcbiAgICB9XG4gIH07XG4gIGV2ZW50TWFuYWdlci53YXRjaChldmVudHMpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGV2ZW50TWFuYWdlci5vZmYoZXZlbnRzKTtcbiAgfTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZURyYWdnYWJsZUNvbnRyb2wocHJvcHMpIHtcbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKG51bGwpLFxuICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgIGRyYWdQb3MgPSBfdXNlU3RhdGUyWzBdLFxuICAgIHNldERyYWdQb3MgPSBfdXNlU3RhdGUyWzFdO1xuICB2YXIgX3VzZVN0YXRlMyA9IHVzZVN0YXRlKG51bGwpLFxuICAgIF91c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUzLCAyKSxcbiAgICBkcmFnT2Zmc2V0ID0gX3VzZVN0YXRlNFswXSxcbiAgICBzZXREcmFnT2Zmc2V0ID0gX3VzZVN0YXRlNFsxXTtcbiAgdmFyIHRoaXNSZWYgPSB1c2VNYXBDb250cm9sKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgIG9uRHJhZ1N0YXJ0OiBvbkRyYWdTdGFydFxuICB9KSk7XG4gIHRoaXNSZWYuY2FsbGJhY2tzID0gcHJvcHM7XG4gIHRoaXNSZWYuc3RhdGUuZHJhZ1BvcyA9IGRyYWdQb3M7XG4gIHRoaXNSZWYuc3RhdGUuc2V0RHJhZ1BvcyA9IHNldERyYWdQb3M7XG4gIHRoaXNSZWYuc3RhdGUuZHJhZ09mZnNldCA9IGRyYWdPZmZzZXQ7XG4gIHRoaXNSZWYuc3RhdGUuc2V0RHJhZ09mZnNldCA9IHNldERyYWdPZmZzZXQ7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVyRXZlbnRzKHRoaXNSZWYpO1xuICB9LCBbdGhpc1JlZi5jb250ZXh0LmV2ZW50TWFuYWdlciwgQm9vbGVhbihkcmFnUG9zKV0pO1xuICByZXR1cm4gdGhpc1JlZjtcbn0iLCJ2YXIgcGl4ZWxSYXRpbyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5leHBvcnQgdmFyIGNyaXNwUGl4ZWwgPSBmdW5jdGlvbiBjcmlzcFBpeGVsKHNpemUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoc2l6ZSAqIHBpeGVsUmF0aW8pIC8gcGl4ZWxSYXRpbztcbn07XG5leHBvcnQgdmFyIGNyaXNwUGVyY2VudGFnZSA9IGZ1bmN0aW9uIGNyaXNwUGVyY2VudGFnZShlbCwgcGVyY2VudGFnZSkge1xuICB2YXIgZGltZW5zaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAneCc7XG4gIGlmIChlbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBwZXJjZW50YWdlO1xuICB9XG4gIHZhciBvcmlnU2l6ZSA9IGRpbWVuc2lvbiA9PT0gJ3gnID8gZWwub2Zmc2V0V2lkdGggOiBlbC5vZmZzZXRIZWlnaHQ7XG4gIHJldHVybiBjcmlzcFBpeGVsKHBlcmNlbnRhZ2UgLyAxMDAgKiBvcmlnU2l6ZSkgLyBvcmlnU2l6ZSAqIDEwMDtcbn07IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZURyYWdnYWJsZUNvbnRyb2wsIHsgZHJhZ2dhYmxlQ29udHJvbERlZmF1bHRQcm9wcywgZHJhZ2dhYmxlQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4vZHJhZ2dhYmxlLWNvbnRyb2wnO1xuaW1wb3J0IHsgY3Jpc3BQaXhlbCB9IGZyb20gJy4uL3V0aWxzL2NyaXNwLXBpeGVsJztcbmltcG9ydCB7IGdldFRlcnJhaW5FbGV2YXRpb24gfSBmcm9tICcuLi91dGlscy90ZXJyYWluJztcbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBkcmFnZ2FibGVDb250cm9sRGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogJydcbn0pO1xuZnVuY3Rpb24gZ2V0UG9zaXRpb24oX3JlZikge1xuICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0O1xuICB2YXIgbG9uZ2l0dWRlID0gcHJvcHMubG9uZ2l0dWRlLFxuICAgIGxhdGl0dWRlID0gcHJvcHMubGF0aXR1ZGUsXG4gICAgb2Zmc2V0TGVmdCA9IHByb3BzLm9mZnNldExlZnQsXG4gICAgb2Zmc2V0VG9wID0gcHJvcHMub2Zmc2V0VG9wO1xuICB2YXIgZHJhZ1BvcyA9IHN0YXRlLmRyYWdQb3MsXG4gICAgZHJhZ09mZnNldCA9IHN0YXRlLmRyYWdPZmZzZXQ7XG4gIHZhciB2aWV3cG9ydCA9IGNvbnRleHQudmlld3BvcnQsXG4gICAgbWFwID0gY29udGV4dC5tYXA7XG4gIGlmIChkcmFnUG9zICYmIGRyYWdPZmZzZXQpIHtcbiAgICByZXR1cm4gW2RyYWdQb3NbMF0gKyBkcmFnT2Zmc2V0WzBdLCBkcmFnUG9zWzFdICsgZHJhZ09mZnNldFsxXV07XG4gIH1cbiAgdmFyIGFsdGl0dWRlID0gZ2V0VGVycmFpbkVsZXZhdGlvbihtYXAsIHtcbiAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICBsYXRpdHVkZTogbGF0aXR1ZGVcbiAgfSk7XG4gIHZhciBfdmlld3BvcnQkcHJvamVjdCA9IHZpZXdwb3J0LnByb2plY3QoW2xvbmdpdHVkZSwgbGF0aXR1ZGUsIGFsdGl0dWRlXSksXG4gICAgX3ZpZXdwb3J0JHByb2plY3QyID0gX3NsaWNlZFRvQXJyYXkoX3ZpZXdwb3J0JHByb2plY3QsIDIpLFxuICAgIHggPSBfdmlld3BvcnQkcHJvamVjdDJbMF0sXG4gICAgeSA9IF92aWV3cG9ydCRwcm9qZWN0MlsxXTtcbiAgeCArPSBvZmZzZXRMZWZ0O1xuICB5ICs9IG9mZnNldFRvcDtcbiAgcmV0dXJuIFt4LCB5XTtcbn1cbmZ1bmN0aW9uIE1hcmtlcihwcm9wcykge1xuICB2YXIgdGhpc1JlZiA9IHVzZURyYWdnYWJsZUNvbnRyb2wocHJvcHMpO1xuICB2YXIgc3RhdGUgPSB0aGlzUmVmLnN0YXRlLFxuICAgIGNvbnRhaW5lclJlZiA9IHRoaXNSZWYuY29udGFpbmVyUmVmO1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgZHJhZ2dhYmxlID0gcHJvcHMuZHJhZ2dhYmxlLFxuICAgIHN0eWxlID0gcHJvcHMuc3R5bGU7XG4gIHZhciBkcmFnUG9zID0gc3RhdGUuZHJhZ1BvcztcbiAgdmFyIF9nZXRQb3NpdGlvbiA9IGdldFBvc2l0aW9uKHRoaXNSZWYpLFxuICAgIF9nZXRQb3NpdGlvbjIgPSBfc2xpY2VkVG9BcnJheShfZ2V0UG9zaXRpb24sIDIpLFxuICAgIHggPSBfZ2V0UG9zaXRpb24yWzBdLFxuICAgIHkgPSBfZ2V0UG9zaXRpb24yWzFdO1xuICB2YXIgdHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KGNyaXNwUGl4ZWwoeCksIFwicHgsIFwiKS5jb25jYXQoY3Jpc3BQaXhlbCh5KSwgXCJweClcIik7XG4gIHZhciBjdXJzb3IgPSBkcmFnZ2FibGUgPyBkcmFnUG9zID8gJ2dyYWJiaW5nJyA6ICdncmFiJyA6ICdhdXRvJztcbiAgdmFyIGNvbnRyb2wgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGFpbmVyU3R5bGUgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgY3Vyc29yOiBjdXJzb3JcbiAgICB9LCBzdHlsZSk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLW1hcmtlciBcIi5jb25jYXQoY2xhc3NOYW1lKSxcbiAgICAgIHJlZjogdGhpc1JlZi5jb250YWluZXJSZWYsXG4gICAgICBzdHlsZTogY29udGFpbmVyU3R5bGVcbiAgICB9LCBjaGlsZHJlbik7XG4gIH0sIFtjaGlsZHJlbiwgY2xhc3NOYW1lXSk7XG4gIHZhciBjb250YWluZXIgPSBjb250YWluZXJSZWYuY3VycmVudDtcbiAgaWYgKGNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lci5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgY29udGFpbmVyLnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcbiAgfVxuICByZXR1cm4gY29udHJvbDtcbn1cbk1hcmtlci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKE1hcmtlcik7IiwiZXhwb3J0IHZhciBBTkNIT1JfUE9TSVRJT04gPSB7XG4gIHRvcDoge1xuICAgIHg6IDAuNSxcbiAgICB5OiAwXG4gIH0sXG4gICd0b3AtbGVmdCc6IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfSxcbiAgJ3RvcC1yaWdodCc6IHtcbiAgICB4OiAxLFxuICAgIHk6IDBcbiAgfSxcbiAgYm90dG9tOiB7XG4gICAgeDogMC41LFxuICAgIHk6IDFcbiAgfSxcbiAgJ2JvdHRvbS1sZWZ0Jzoge1xuICAgIHg6IDAsXG4gICAgeTogMVxuICB9LFxuICAnYm90dG9tLXJpZ2h0Jzoge1xuICAgIHg6IDEsXG4gICAgeTogMVxuICB9LFxuICBsZWZ0OiB7XG4gICAgeDogMCxcbiAgICB5OiAwLjVcbiAgfSxcbiAgcmlnaHQ6IHtcbiAgICB4OiAxLFxuICAgIHk6IDAuNVxuICB9XG59O1xudmFyIEFOQ0hPUl9UWVBFUyA9IE9iamVjdC5rZXlzKEFOQ0hPUl9QT1NJVElPTik7XG5leHBvcnQgZnVuY3Rpb24gZ2V0RHluYW1pY1Bvc2l0aW9uKF9yZWYpIHtcbiAgdmFyIHggPSBfcmVmLngsXG4gICAgeSA9IF9yZWYueSxcbiAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgc2VsZldpZHRoID0gX3JlZi5zZWxmV2lkdGgsXG4gICAgc2VsZkhlaWdodCA9IF9yZWYuc2VsZkhlaWdodCxcbiAgICBhbmNob3IgPSBfcmVmLmFuY2hvcixcbiAgICBfcmVmJHBhZGRpbmcgPSBfcmVmLnBhZGRpbmcsXG4gICAgcGFkZGluZyA9IF9yZWYkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9yZWYkcGFkZGluZztcbiAgdmFyIF9BTkNIT1JfUE9TSVRJT04kYW5jaCA9IEFOQ0hPUl9QT1NJVElPTlthbmNob3JdLFxuICAgIGFuY2hvclggPSBfQU5DSE9SX1BPU0lUSU9OJGFuY2gueCxcbiAgICBhbmNob3JZID0gX0FOQ0hPUl9QT1NJVElPTiRhbmNoLnk7XG4gIHZhciB0b3AgPSB5IC0gYW5jaG9yWSAqIHNlbGZIZWlnaHQ7XG4gIHZhciBib3R0b20gPSB0b3AgKyBzZWxmSGVpZ2h0O1xuICB2YXIgY3V0b2ZmWSA9IE1hdGgubWF4KDAsIHBhZGRpbmcgLSB0b3ApICsgTWF0aC5tYXgoMCwgYm90dG9tIC0gaGVpZ2h0ICsgcGFkZGluZyk7XG4gIGlmIChjdXRvZmZZID4gMCkge1xuICAgIHZhciBiZXN0QW5jaG9yWSA9IGFuY2hvclk7XG4gICAgdmFyIG1pbkN1dG9mZiA9IGN1dG9mZlk7XG4gICAgZm9yIChhbmNob3JZID0gMDsgYW5jaG9yWSA8PSAxOyBhbmNob3JZICs9IDAuNSkge1xuICAgICAgdG9wID0geSAtIGFuY2hvclkgKiBzZWxmSGVpZ2h0O1xuICAgICAgYm90dG9tID0gdG9wICsgc2VsZkhlaWdodDtcbiAgICAgIGN1dG9mZlkgPSBNYXRoLm1heCgwLCBwYWRkaW5nIC0gdG9wKSArIE1hdGgubWF4KDAsIGJvdHRvbSAtIGhlaWdodCArIHBhZGRpbmcpO1xuICAgICAgaWYgKGN1dG9mZlkgPCBtaW5DdXRvZmYpIHtcbiAgICAgICAgbWluQ3V0b2ZmID0gY3V0b2ZmWTtcbiAgICAgICAgYmVzdEFuY2hvclkgPSBhbmNob3JZO1xuICAgICAgfVxuICAgIH1cbiAgICBhbmNob3JZID0gYmVzdEFuY2hvclk7XG4gIH1cbiAgdmFyIHhTdGVwID0gMC41O1xuICBpZiAoYW5jaG9yWSA9PT0gMC41KSB7XG4gICAgYW5jaG9yWCA9IE1hdGguZmxvb3IoYW5jaG9yWCk7XG4gICAgeFN0ZXAgPSAxO1xuICB9XG4gIHZhciBsZWZ0ID0geCAtIGFuY2hvclggKiBzZWxmV2lkdGg7XG4gIHZhciByaWdodCA9IGxlZnQgKyBzZWxmV2lkdGg7XG4gIHZhciBjdXRvZmZYID0gTWF0aC5tYXgoMCwgcGFkZGluZyAtIGxlZnQpICsgTWF0aC5tYXgoMCwgcmlnaHQgLSB3aWR0aCArIHBhZGRpbmcpO1xuICBpZiAoY3V0b2ZmWCA+IDApIHtcbiAgICB2YXIgYmVzdEFuY2hvclggPSBhbmNob3JYO1xuICAgIHZhciBfbWluQ3V0b2ZmID0gY3V0b2ZmWDtcbiAgICBmb3IgKGFuY2hvclggPSAwOyBhbmNob3JYIDw9IDE7IGFuY2hvclggKz0geFN0ZXApIHtcbiAgICAgIGxlZnQgPSB4IC0gYW5jaG9yWCAqIHNlbGZXaWR0aDtcbiAgICAgIHJpZ2h0ID0gbGVmdCArIHNlbGZXaWR0aDtcbiAgICAgIGN1dG9mZlggPSBNYXRoLm1heCgwLCBwYWRkaW5nIC0gbGVmdCkgKyBNYXRoLm1heCgwLCByaWdodCAtIHdpZHRoICsgcGFkZGluZyk7XG4gICAgICBpZiAoY3V0b2ZmWCA8IF9taW5DdXRvZmYpIHtcbiAgICAgICAgX21pbkN1dG9mZiA9IGN1dG9mZlg7XG4gICAgICAgIGJlc3RBbmNob3JYID0gYW5jaG9yWDtcbiAgICAgIH1cbiAgICB9XG4gICAgYW5jaG9yWCA9IGJlc3RBbmNob3JYO1xuICB9XG4gIHJldHVybiBBTkNIT1JfVFlQRVMuZmluZChmdW5jdGlvbiAocG9zaXRpb25UeXBlKSB7XG4gICAgdmFyIGFuY2hvclBvc2l0aW9uID0gQU5DSE9SX1BPU0lUSU9OW3Bvc2l0aW9uVHlwZV07XG4gICAgcmV0dXJuIGFuY2hvclBvc2l0aW9uLnggPT09IGFuY2hvclggJiYgYW5jaG9yUG9zaXRpb24ueSA9PT0gYW5jaG9yWTtcbiAgfSkgfHwgYW5jaG9yO1xufSIsImltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VNYXBDb250cm9sLCB7IG1hcENvbnRyb2xEZWZhdWx0UHJvcHMsIG1hcENvbnRyb2xQcm9wVHlwZXMgfSBmcm9tICcuL3VzZS1tYXAtY29udHJvbCc7XG5pbXBvcnQgeyBnZXREeW5hbWljUG9zaXRpb24sIEFOQ0hPUl9QT1NJVElPTiB9IGZyb20gJy4uL3V0aWxzL2R5bmFtaWMtcG9zaXRpb24nO1xuaW1wb3J0IHsgZ2V0VGVycmFpbkVsZXZhdGlvbiB9IGZyb20gJy4uL3V0aWxzL3RlcnJhaW4nO1xuaW1wb3J0IHsgY3Jpc3BQZXJjZW50YWdlLCBjcmlzcFBpeGVsIH0gZnJvbSAnLi4vdXRpbHMvY3Jpc3AtcGl4ZWwnO1xudmFyIGRlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hcENvbnRyb2xEZWZhdWx0UHJvcHMsIHtcbiAgY2xhc3NOYW1lOiAnJyxcbiAgb2Zmc2V0TGVmdDogMCxcbiAgb2Zmc2V0VG9wOiAwLFxuICB0aXBTaXplOiAxMCxcbiAgYW5jaG9yOiAnYm90dG9tJyxcbiAgZHluYW1pY1Bvc2l0aW9uOiB0cnVlLFxuICBzb3J0QnlEZXB0aDogZmFsc2UsXG4gIGNsb3NlQnV0dG9uOiB0cnVlLFxuICBjbG9zZU9uQ2xpY2s6IHRydWUsXG4gIG9uQ2xvc2U6IGZ1bmN0aW9uIG9uQ2xvc2UoKSB7fVxufSk7XG5mdW5jdGlvbiBnZXRQb3NpdGlvbihwcm9wcywgdmlld3BvcnQsIGVsLCBfcmVmKSB7XG4gIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgIHggPSBfcmVmMlswXSxcbiAgICB5ID0gX3JlZjJbMV07XG4gIHZhciBhbmNob3IgPSBwcm9wcy5hbmNob3IsXG4gICAgZHluYW1pY1Bvc2l0aW9uID0gcHJvcHMuZHluYW1pY1Bvc2l0aW9uLFxuICAgIHRpcFNpemUgPSBwcm9wcy50aXBTaXplO1xuICBpZiAoZWwpIHtcbiAgICByZXR1cm4gZHluYW1pY1Bvc2l0aW9uID8gZ2V0RHluYW1pY1Bvc2l0aW9uKHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICBwYWRkaW5nOiB0aXBTaXplLFxuICAgICAgd2lkdGg6IHZpZXdwb3J0LndpZHRoLFxuICAgICAgaGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHQsXG4gICAgICBzZWxmV2lkdGg6IGVsLmNsaWVudFdpZHRoLFxuICAgICAgc2VsZkhlaWdodDogZWwuY2xpZW50SGVpZ2h0XG4gICAgfSkgOiBhbmNob3I7XG4gIH1cbiAgcmV0dXJuIGFuY2hvcjtcbn1cbmZ1bmN0aW9uIGdldENvbnRhaW5lclN0eWxlKHByb3BzLCB2aWV3cG9ydCwgZWwsIF9yZWYzLCBwb3NpdGlvblR5cGUpIHtcbiAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDMpLFxuICAgIHggPSBfcmVmNFswXSxcbiAgICB5ID0gX3JlZjRbMV0sXG4gICAgeiA9IF9yZWY0WzJdO1xuICB2YXIgb2Zmc2V0TGVmdCA9IHByb3BzLm9mZnNldExlZnQsXG4gICAgb2Zmc2V0VG9wID0gcHJvcHMub2Zmc2V0VG9wLFxuICAgIHNvcnRCeURlcHRoID0gcHJvcHMuc29ydEJ5RGVwdGg7XG4gIHZhciBhbmNob3JQb3NpdGlvbiA9IEFOQ0hPUl9QT1NJVElPTltwb3NpdGlvblR5cGVdO1xuICB2YXIgbGVmdCA9IHggKyBvZmZzZXRMZWZ0O1xuICB2YXIgdG9wID0geSArIG9mZnNldFRvcDtcbiAgdmFyIHhQZXJjZW50YWdlID0gY3Jpc3BQZXJjZW50YWdlKGVsLCAtYW5jaG9yUG9zaXRpb24ueCAqIDEwMCk7XG4gIHZhciB5UGVyY2VudGFnZSA9IGNyaXNwUGVyY2VudGFnZShlbCwgLWFuY2hvclBvc2l0aW9uLnkgKiAxMDAsICd5Jyk7XG4gIHZhciBzdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0cmFuc2Zvcm06IFwiXFxuICAgICAgdHJhbnNsYXRlKFwiLmNvbmNhdCh4UGVyY2VudGFnZSwgXCIlLCBcIikuY29uY2F0KHlQZXJjZW50YWdlLCBcIiUpXFxuICAgICAgdHJhbnNsYXRlKFwiKS5jb25jYXQoY3Jpc3BQaXhlbChsZWZ0KSwgXCJweCwgXCIpLmNvbmNhdChjcmlzcFBpeGVsKHRvcCksIFwicHgpXFxuICAgIFwiKSxcbiAgICBkaXNwbGF5OiB1bmRlZmluZWQsXG4gICAgekluZGV4OiB1bmRlZmluZWRcbiAgfTtcbiAgaWYgKCFzb3J0QnlEZXB0aCkge1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuICBpZiAoeiA+IDEgfHwgeiA8IC0xIHx8IHggPCAwIHx8IHggPiB2aWV3cG9ydC53aWR0aCB8fCB5IDwgMCB8fCB5ID4gdmlld3BvcnQuaGVpZ2h0KSB7XG4gICAgc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS56SW5kZXggPSBNYXRoLmZsb29yKCgxIC0geikgLyAyICogMTAwMDAwKTtcbiAgfVxuICByZXR1cm4gc3R5bGU7XG59XG5mdW5jdGlvbiBQb3B1cChwcm9wcykge1xuICB2YXIgY29udGVudFJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHRoaXNSZWYgPSB1c2VNYXBDb250cm9sKHByb3BzKTtcbiAgdmFyIGNvbnRleHQgPSB0aGlzUmVmLmNvbnRleHQsXG4gICAgY29udGFpbmVyUmVmID0gdGhpc1JlZi5jb250YWluZXJSZWY7XG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShmYWxzZSksXG4gICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgc2V0TG9hZGVkID0gX3VzZVN0YXRlMlsxXTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBzZXRMb2FkZWQodHJ1ZSk7XG4gIH0sIFtjb250ZW50UmVmLmN1cnJlbnRdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY29udGV4dC5ldmVudE1hbmFnZXIgJiYgcHJvcHMuY2xvc2VPbkNsaWNrKSB7XG4gICAgICB2YXIgY2xpY2tDYWxsYmFjayA9IGZ1bmN0aW9uIGNsaWNrQ2FsbGJhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzUmVmLnByb3BzLm9uQ2xvc2UoKTtcbiAgICAgIH07XG4gICAgICBjb250ZXh0LmV2ZW50TWFuYWdlci5vbignYW55Y2xpY2snLCBjbGlja0NhbGxiYWNrKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRleHQuZXZlbnRNYW5hZ2VyLm9mZignYW55Y2xpY2snLCBjbGlja0NhbGxiYWNrKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sIFtjb250ZXh0LmV2ZW50TWFuYWdlciwgcHJvcHMuY2xvc2VPbkNsaWNrXSk7XG4gIHZhciB2aWV3cG9ydCA9IGNvbnRleHQudmlld3BvcnQsXG4gICAgbWFwID0gY29udGV4dC5tYXA7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgbG9uZ2l0dWRlID0gcHJvcHMubG9uZ2l0dWRlLFxuICAgIGxhdGl0dWRlID0gcHJvcHMubGF0aXR1ZGUsXG4gICAgdGlwU2l6ZSA9IHByb3BzLnRpcFNpemUsXG4gICAgY2xvc2VCdXR0b24gPSBwcm9wcy5jbG9zZUJ1dHRvbixcbiAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICB2YXIgYWx0aXR1ZGUgPSBwcm9wcy5hbHRpdHVkZTtcbiAgaWYgKGFsdGl0dWRlID09PSB1bmRlZmluZWQpIHtcbiAgICBhbHRpdHVkZSA9IGdldFRlcnJhaW5FbGV2YXRpb24obWFwLCB7XG4gICAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlOiBsYXRpdHVkZVxuICAgIH0pO1xuICB9XG4gIHZhciBwb3NpdGlvbiA9IHZpZXdwb3J0LnByb2plY3QoW2xvbmdpdHVkZSwgbGF0aXR1ZGUsIGFsdGl0dWRlXSk7XG4gIHZhciBwb3NpdGlvblR5cGUgPSBnZXRQb3NpdGlvbihwcm9wcywgdmlld3BvcnQsIGNvbnRlbnRSZWYuY3VycmVudCwgcG9zaXRpb24pO1xuICB2YXIgY29udGFpbmVyU3R5bGUgPSBnZXRDb250YWluZXJTdHlsZShwcm9wcywgdmlld3BvcnQsIGNvbnRhaW5lclJlZi5jdXJyZW50LCBwb3NpdGlvbiwgcG9zaXRpb25UeXBlKTtcbiAgdmFyIG9uQ2xpY2tDbG9zZUJ1dHRvbiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldnQpIHtcbiAgICB0aGlzUmVmLnByb3BzLm9uQ2xvc2UoKTtcbiAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpc1JlZi5jb250ZXh0LmV2ZW50TWFuYWdlcjtcbiAgICBpZiAoZXZlbnRNYW5hZ2VyKSB7XG4gICAgICBldmVudE1hbmFnZXIub25jZSgnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0sIGV2dC50YXJnZXQpO1xuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLXBvcHVwIG1hcGJveGdsLXBvcHVwLWFuY2hvci1cIi5jb25jYXQocG9zaXRpb25UeXBlLCBcIiBcIikuY29uY2F0KGNsYXNzTmFtZSksXG4gICAgc3R5bGU6IGNvbnRhaW5lclN0eWxlLFxuICAgIHJlZjogY29udGFpbmVyUmVmXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGtleTogXCJ0aXBcIixcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtcG9wdXAtdGlwXCIsXG4gICAgc3R5bGU6IHtcbiAgICAgIGJvcmRlcldpZHRoOiB0aXBTaXplXG4gICAgfVxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAga2V5OiBcImNvbnRlbnRcIixcbiAgICByZWY6IGNvbnRlbnRSZWYsXG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLXBvcHVwLWNvbnRlbnRcIlxuICB9LCBjbG9zZUJ1dHRvbiAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICBrZXk6IFwiY2xvc2UtYnV0dG9uXCIsXG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLXBvcHVwLWNsb3NlLWJ1dHRvblwiLFxuICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgb25DbGljazogb25DbGlja0Nsb3NlQnV0dG9uXG4gIH0sIFwiXFx4RDdcIiksIGNoaWxkcmVuKSk7XG59XG5Qb3B1cC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKFBvcHVwKTsiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlLCB1c2VSZWYsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgbWFwYm94Z2wgZnJvbSAnLi4vdXRpbHMvbWFwYm94Z2wnO1xuaW1wb3J0IHVzZU1hcENvbnRyb2wsIHsgbWFwQ29udHJvbERlZmF1bHRQcm9wcywgbWFwQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4vdXNlLW1hcC1jb250cm9sJztcbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXBDb250cm9sRGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogJycsXG4gIHRvZ2dsZUxhYmVsOiAnVG9nZ2xlIEF0dHJpYnV0aW9uJ1xufSk7XG5mdW5jdGlvbiBzZXR1cEF0dHJpYnV0aW9uY29udHJvbChvcHRzLCBtYXAsIGNvbnRhaW5lciwgYXR0cmlidXRpb25Db250YWluZXIpIHtcbiAgdmFyIGNvbnRyb2wgPSBuZXcgbWFwYm94Z2wuQXR0cmlidXRpb25Db250cm9sKG9wdHMpO1xuICBjb250cm9sLl9tYXAgPSBtYXA7XG4gIGNvbnRyb2wuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgY29udHJvbC5faW5uZXJDb250YWluZXIgPSBhdHRyaWJ1dGlvbkNvbnRhaW5lcjtcbiAgY29udHJvbC5fdXBkYXRlQXR0cmlidXRpb25zKCk7XG4gIGNvbnRyb2wuX3VwZGF0ZUVkaXRMaW5rKCk7XG4gIG1hcC5vbignc3R5bGVkYXRhJywgY29udHJvbC5fdXBkYXRlRGF0YSk7XG4gIG1hcC5vbignc291cmNlZGF0YScsIGNvbnRyb2wuX3VwZGF0ZURhdGEpO1xuICByZXR1cm4gY29udHJvbDtcbn1cbmZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0aW9uQ29udHJvbChjb250cm9sKSB7XG4gIGNvbnRyb2wuX21hcC5vZmYoJ3N0eWxlZGF0YScsIGNvbnRyb2wuX3VwZGF0ZURhdGEpO1xuICBjb250cm9sLl9tYXAub2ZmKCdzb3VyY2VkYXRhJywgY29udHJvbC5fdXBkYXRlRGF0YSk7XG59XG5mdW5jdGlvbiBBdHRyaWJ1dGlvbkNvbnRyb2wocHJvcHMpIHtcbiAgdmFyIF91c2VNYXBDb250cm9sID0gdXNlTWFwQ29udHJvbChwcm9wcyksXG4gICAgY29udGV4dCA9IF91c2VNYXBDb250cm9sLmNvbnRleHQsXG4gICAgY29udGFpbmVyUmVmID0gX3VzZU1hcENvbnRyb2wuY29udGFpbmVyUmVmO1xuICB2YXIgaW5uZXJDb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShmYWxzZSksXG4gICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgc2hvd0NvbXBhY3QgPSBfdXNlU3RhdGUyWzBdLFxuICAgIHNldFNob3dDb21wYWN0ID0gX3VzZVN0YXRlMlsxXTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udHJvbDtcbiAgICBpZiAoY29udGV4dC5tYXApIHtcbiAgICAgIGNvbnRyb2wgPSBzZXR1cEF0dHJpYnV0aW9uY29udHJvbCh7XG4gICAgICAgIGN1c3RvbUF0dHJpYnV0aW9uOiBwcm9wcy5jdXN0b21BdHRyaWJ1dGlvblxuICAgICAgfSwgY29udGV4dC5tYXAsIGNvbnRhaW5lclJlZi5jdXJyZW50LCBpbm5lckNvbnRhaW5lclJlZi5jdXJyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjb250cm9sICYmIHJlbW92ZUF0dHJpYnV0aW9uQ29udHJvbChjb250cm9sKTtcbiAgICB9O1xuICB9LCBbY29udGV4dC5tYXBdKTtcbiAgdmFyIGNvbXBhY3QgPSBwcm9wcy5jb21wYWN0ID09PSB1bmRlZmluZWQgPyBjb250ZXh0LnZpZXdwb3J0LndpZHRoIDw9IDY0MCA6IHByb3BzLmNvbXBhY3Q7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjb21wYWN0ICYmIHNob3dDb21wYWN0KSB7XG4gICAgICBzZXRTaG93Q29tcGFjdChmYWxzZSk7XG4gICAgfVxuICB9LCBbY29tcGFjdF0pO1xuICB2YXIgdG9nZ2xlQXR0cmlidXRpb24gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNldFNob3dDb21wYWN0KGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuICF2YWx1ZTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICB2YXIgc3R5bGUgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sIHByb3BzLnN0eWxlKTtcbiAgfSwgW3Byb3BzLnN0eWxlXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgY2xhc3NOYW1lOiBwcm9wcy5jbGFzc05hbWVcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgXCJhcmlhLXByZXNzZWRcIjogc2hvd0NvbXBhY3QsXG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwgbWFwYm94Z2wtY3RybC1hdHRyaWIgXCIuY29uY2F0KGNvbXBhY3QgPyAnbWFwYm94Z2wtY29tcGFjdCcgOiAnJywgXCIgXCIpLmNvbmNhdChzaG93Q29tcGFjdCA/ICdtYXBib3hnbC1jb21wYWN0LXNob3cnIDogJycpXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwtYXR0cmliLWJ1dHRvblwiLFxuICAgIHRpdGxlOiBwcm9wcy50b2dnbGVMYWJlbCxcbiAgICBvbkNsaWNrOiB0b2dnbGVBdHRyaWJ1dGlvblxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBpbm5lckNvbnRhaW5lclJlZixcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybC1hdHRyaWItaW5uZXJcIixcbiAgICByb2xlOiBcImxpc3RcIlxuICB9KSkpO1xufVxuQXR0cmlidXRpb25Db250cm9sLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbmV4cG9ydCBkZWZhdWx0IFJlYWN0Lm1lbW8oQXR0cmlidXRpb25Db250cm9sKTsiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmltcG9ydCB7IGRvY3VtZW50IH0gZnJvbSAnLi4vdXRpbHMvZ2xvYmFscyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IG1hcGJveGdsIGZyb20gJy4uL3V0aWxzL21hcGJveGdsJztcbmltcG9ydCB1c2VNYXBDb250cm9sLCB7IG1hcENvbnRyb2xEZWZhdWx0UHJvcHMsIG1hcENvbnRyb2xQcm9wVHlwZXMgfSBmcm9tICcuL3VzZS1tYXAtY29udHJvbCc7XG52YXIgZGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbWFwQ29udHJvbERlZmF1bHRQcm9wcywge1xuICBjbGFzc05hbWU6ICcnLFxuICBjb250YWluZXI6IG51bGwsXG4gIGxhYmVsOiAnVG9nZ2xlIGZ1bGxzY3JlZW4nXG59KTtcbmZ1bmN0aW9uIEZ1bGxzY3JlZW5Db250cm9sKHByb3BzKSB7XG4gIHZhciBfdXNlTWFwQ29udHJvbCA9IHVzZU1hcENvbnRyb2wocHJvcHMpLFxuICAgIGNvbnRleHQgPSBfdXNlTWFwQ29udHJvbC5jb250ZXh0LFxuICAgIGNvbnRhaW5lclJlZiA9IF91c2VNYXBDb250cm9sLmNvbnRhaW5lclJlZjtcbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKGZhbHNlKSxcbiAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICBpc0Z1bGxzY3JlZW4gPSBfdXNlU3RhdGUyWzBdLFxuICAgIHNldElzRnVsbHNjcmVlbiA9IF91c2VTdGF0ZTJbMV07XG4gIHZhciBfdXNlU3RhdGUzID0gdXNlU3RhdGUoZmFsc2UpLFxuICAgIF91c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUzLCAyKSxcbiAgICBzaG93QnV0dG9uID0gX3VzZVN0YXRlNFswXSxcbiAgICBzZXRTaG93QnV0dG9uID0gX3VzZVN0YXRlNFsxXTtcbiAgdmFyIF91c2VTdGF0ZTUgPSB1c2VTdGF0ZShudWxsKSxcbiAgICBfdXNlU3RhdGU2ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlNSwgMiksXG4gICAgbWFwYm94RnVsbHNjcmVlbkNvbnRyb2wgPSBfdXNlU3RhdGU2WzBdLFxuICAgIGNyZWF0ZU1hcGJveEZ1bGxzY3JlZW5Db250cm9sID0gX3VzZVN0YXRlNlsxXTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udHJvbCA9IG5ldyBtYXBib3hnbC5GdWxsc2NyZWVuQ29udHJvbCgpO1xuICAgIGNyZWF0ZU1hcGJveEZ1bGxzY3JlZW5Db250cm9sKGNvbnRyb2wpO1xuICAgIHNldFNob3dCdXR0b24oY29udHJvbC5fY2hlY2tGdWxsc2NyZWVuU3VwcG9ydCgpKTtcbiAgICB2YXIgb25GdWxsc2NyZWVuQ2hhbmdlID0gZnVuY3Rpb24gb25GdWxsc2NyZWVuQ2hhbmdlKCkge1xuICAgICAgdmFyIG5leHRTdGF0ZSA9ICFjb250cm9sLl9mdWxsc2NyZWVuO1xuICAgICAgY29udHJvbC5fZnVsbHNjcmVlbiA9IG5leHRTdGF0ZTtcbiAgICAgIHNldElzRnVsbHNjcmVlbihuZXh0U3RhdGUpO1xuICAgIH07XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihjb250cm9sLl9mdWxsc2NyZWVuY2hhbmdlLCBvbkZ1bGxzY3JlZW5DaGFuZ2UpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGNvbnRyb2wuX2Z1bGxzY3JlZW5jaGFuZ2UsIG9uRnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgfTtcbiAgfSwgW10pO1xuICB2YXIgb25DbGlja0Z1bGxzY3JlZW4gPSBmdW5jdGlvbiBvbkNsaWNrRnVsbHNjcmVlbigpIHtcbiAgICBpZiAobWFwYm94RnVsbHNjcmVlbkNvbnRyb2wpIHtcbiAgICAgIG1hcGJveEZ1bGxzY3JlZW5Db250cm9sLl9jb250YWluZXIgPSBwcm9wcy5jb250YWluZXIgfHwgY29udGV4dC5jb250YWluZXI7XG4gICAgICBtYXBib3hGdWxsc2NyZWVuQ29udHJvbC5fb25DbGlja0Z1bGxzY3JlZW4oKTtcbiAgICB9XG4gIH07XG4gIHZhciBzdHlsZSA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSwgcHJvcHMuc3R5bGUpO1xuICB9LCBbcHJvcHMuc3R5bGVdKTtcbiAgaWYgKCFzaG93QnV0dG9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICBsYWJlbCA9IHByb3BzLmxhYmVsO1xuICB2YXIgdHlwZSA9IGlzRnVsbHNjcmVlbiA/ICdzaHJpbmsnIDogJ2Z1bGxzY3JlZW4nO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsIG1hcGJveGdsLWN0cmwtZ3JvdXBcIixcbiAgICByZWY6IGNvbnRhaW5lclJlZlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICBrZXk6IHR5cGUsXG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwtaWNvbiBtYXBib3hnbC1jdHJsLVwiLmNvbmNhdCh0eXBlKSxcbiAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgIHRpdGxlOiBsYWJlbCxcbiAgICBvbkNsaWNrOiBvbkNsaWNrRnVsbHNjcmVlblxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwtaWNvblwiLFxuICAgIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCJcbiAgfSkpKSk7XG59XG5GdWxsc2NyZWVuQ29udHJvbC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKEZ1bGxzY3JlZW5Db250cm9sKTsiLCJ2YXIgc3VwcG9ydGVkO1xuZXhwb3J0IGZ1bmN0aW9uIGlzR2VvbG9jYXRpb25TdXBwb3J0ZWQoKSB7XG4gIGlmIChzdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3VwcG9ydGVkKTtcbiAgfVxuICBpZiAod2luZG93Lm5hdmlnYXRvci5wZXJtaXNzaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IucGVybWlzc2lvbnMucXVlcnkoe1xuICAgICAgbmFtZTogJ2dlb2xvY2F0aW9uJ1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHApIHtcbiAgICAgIHN1cHBvcnRlZCA9IHAuc3RhdGUgIT09ICdkZW5pZWQnO1xuICAgICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgICB9KTtcbiAgfVxuICBzdXBwb3J0ZWQgPSBCb29sZWFuKHdpbmRvdy5uYXZpZ2F0b3IuZ2VvbG9jYXRpb24pO1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHN1cHBvcnRlZCk7XG59IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZG9jdW1lbnQgfSBmcm9tICcuLi91dGlscy9nbG9iYWxzJztcbmltcG9ydCBtYXBib3hnbCBmcm9tICcuLi91dGlscy9tYXBib3hnbCc7XG5pbXBvcnQgTWFwU3RhdGUgZnJvbSAnLi4vdXRpbHMvbWFwLXN0YXRlJztcbmltcG9ydCB7IExJTkVBUl9UUkFOU0lUSU9OX1BST1BTIH0gZnJvbSAnLi4vdXRpbHMvbWFwLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgaXNHZW9sb2NhdGlvblN1cHBvcnRlZCB9IGZyb20gJy4uL3V0aWxzL2dlb2xvY2F0ZS11dGlscyc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sRGVmYXVsdFByb3BzLCBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi91c2UtbWFwLWNvbnRyb2wnO1xudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG52YXIgZGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbWFwQ29udHJvbERlZmF1bHRQcm9wcywge1xuICBjbGFzc05hbWU6ICcnLFxuICBsYWJlbDogJ0ZpbmQgTXkgTG9jYXRpb24nLFxuICBkaXNhYmxlZExhYmVsOiAnTG9jYXRpb24gTm90IEF2YWlsYWJsZScsXG4gIGF1dG86IGZhbHNlLFxuICBwb3NpdGlvbk9wdGlvbnM6IHtcbiAgICBlbmFibGVIaWdoQWNjdXJhY3k6IGZhbHNlLFxuICAgIHRpbWVvdXQ6IDYwMDBcbiAgfSxcbiAgZml0Qm91bmRzT3B0aW9uczoge1xuICAgIG1heFpvb206IDE1XG4gIH0sXG4gIHRyYWNrVXNlckxvY2F0aW9uOiBmYWxzZSxcbiAgc2hvd1VzZXJMb2NhdGlvbjogdHJ1ZSxcbiAgc2hvd1VzZXJIZWFkaW5nOiBmYWxzZSxcbiAgc2hvd0FjY3VyYWN5Q2lyY2xlOiB0cnVlLFxuICBvbkdlb2xvY2F0ZTogZnVuY3Rpb24gb25HZW9sb2NhdGUoKSB7fVxufSk7XG5mdW5jdGlvbiBnZXRCb3VuZHMocG9zaXRpb24pIHtcbiAgdmFyIGNlbnRlciA9IG5ldyBtYXBib3hnbC5MbmdMYXQocG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZSwgcG9zaXRpb24uY29vcmRzLmxhdGl0dWRlKTtcbiAgdmFyIHJhZGl1cyA9IHBvc2l0aW9uLmNvb3Jkcy5hY2N1cmFjeTtcbiAgdmFyIGJvdW5kcyA9IGNlbnRlci50b0JvdW5kcyhyYWRpdXMpO1xuICByZXR1cm4gW1tib3VuZHMuX25lLmxuZywgYm91bmRzLl9uZS5sYXRdLCBbYm91bmRzLl9zdy5sbmcsIGJvdW5kcy5fc3cubGF0XV07XG59XG5mdW5jdGlvbiBzZXR1cE1hcGJveEdlb2xvY2F0ZUNvbnRyb2woY29udGV4dCwgcHJvcHMsIGdlb2xvY2F0ZUJ1dHRvbikge1xuICB2YXIgY29udHJvbCA9IG5ldyBtYXBib3hnbC5HZW9sb2NhdGVDb250cm9sKHByb3BzKTtcbiAgY29udHJvbC5fY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnRyb2wuX21hcCA9IHtcbiAgICBvbjogZnVuY3Rpb24gb24oKSB7fSxcbiAgICBfZ2V0VUlTdHJpbmc6IGZ1bmN0aW9uIF9nZXRVSVN0cmluZygpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH07XG4gIGNvbnRyb2wuX3NldHVwVUkodHJ1ZSk7XG4gIGNvbnRyb2wuX21hcCA9IGNvbnRleHQubWFwO1xuICBjb250cm9sLl9nZW9sb2NhdGVCdXR0b24gPSBnZW9sb2NhdGVCdXR0b247XG4gIHZhciBldmVudE1hbmFnZXIgPSBjb250ZXh0LmV2ZW50TWFuYWdlcjtcbiAgaWYgKGNvbnRyb2wub3B0aW9ucy50cmFja1VzZXJMb2NhdGlvbiAmJiBldmVudE1hbmFnZXIpIHtcbiAgICBldmVudE1hbmFnZXIub24oJ3BhbnN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNvbnRyb2wuX3dhdGNoU3RhdGUgPT09ICdBQ1RJVkVfTE9DSycpIHtcbiAgICAgICAgY29udHJvbC5fd2F0Y2hTdGF0ZSA9ICdCQUNLR1JPVU5EJztcbiAgICAgICAgZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ21hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmQnKTtcbiAgICAgICAgZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ21hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZScpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnRyb2wub24oJ2dlb2xvY2F0ZScsIHByb3BzLm9uR2VvbG9jYXRlKTtcbiAgcmV0dXJuIGNvbnRyb2w7XG59XG5mdW5jdGlvbiB1cGRhdGVDYW1lcmEocG9zaXRpb24sIF9yZWYpIHtcbiAgdmFyIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXG4gICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuICB2YXIgYm91bmRzID0gZ2V0Qm91bmRzKHBvc2l0aW9uKTtcbiAgdmFyIF9jb250ZXh0JHZpZXdwb3J0JGZpdCA9IGNvbnRleHQudmlld3BvcnQuZml0Qm91bmRzKGJvdW5kcywgcHJvcHMuZml0Qm91bmRzT3B0aW9ucyksXG4gICAgbG9uZ2l0dWRlID0gX2NvbnRleHQkdmlld3BvcnQkZml0LmxvbmdpdHVkZSxcbiAgICBsYXRpdHVkZSA9IF9jb250ZXh0JHZpZXdwb3J0JGZpdC5sYXRpdHVkZSxcbiAgICB6b29tID0gX2NvbnRleHQkdmlld3BvcnQkZml0Lnpvb207XG4gIHZhciBuZXdWaWV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0LnZpZXdwb3J0LCB7XG4gICAgbG9uZ2l0dWRlOiBsb25naXR1ZGUsXG4gICAgbGF0aXR1ZGU6IGxhdGl0dWRlLFxuICAgIHpvb206IHpvb21cbiAgfSk7XG4gIHZhciBtYXBTdGF0ZSA9IG5ldyBNYXBTdGF0ZShuZXdWaWV3U3RhdGUpO1xuICB2YXIgdmlld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgbWFwU3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpLCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyk7XG4gIHZhciBvblZpZXdwb3J0Q2hhbmdlID0gcHJvcHMub25WaWV3cG9ydENoYW5nZSB8fCBjb250ZXh0Lm9uVmlld3BvcnRDaGFuZ2UgfHwgbm9vcDtcbiAgdmFyIG9uVmlld1N0YXRlQ2hhbmdlID0gcHJvcHMub25WaWV3U3RhdGVDaGFuZ2UgfHwgY29udGV4dC5vblZpZXdTdGF0ZUNoYW5nZSB8fCBub29wO1xuICBvblZpZXdTdGF0ZUNoYW5nZSh7XG4gICAgdmlld1N0YXRlOiB2aWV3U3RhdGVcbiAgfSk7XG4gIG9uVmlld3BvcnRDaGFuZ2Uodmlld1N0YXRlKTtcbn1cbmZ1bmN0aW9uIEdlb2xvY2F0ZUNvbnRyb2wocHJvcHMpIHtcbiAgdmFyIHRoaXNSZWYgPSB1c2VNYXBDb250cm9sKHByb3BzKTtcbiAgdmFyIGNvbnRleHQgPSB0aGlzUmVmLmNvbnRleHQsXG4gICAgY29udGFpbmVyUmVmID0gdGhpc1JlZi5jb250YWluZXJSZWY7XG4gIHZhciBnZW9sb2NhdGVCdXR0b25SZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShudWxsKSxcbiAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICBtYXBib3hHZW9sb2NhdGVDb250cm9sID0gX3VzZVN0YXRlMlswXSxcbiAgICBjcmVhdGVNYXBib3hHZW9sb2NhdGVDb250cm9sID0gX3VzZVN0YXRlMlsxXTtcbiAgdmFyIF91c2VTdGF0ZTMgPSB1c2VTdGF0ZShmYWxzZSksXG4gICAgX3VzZVN0YXRlNCA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZTMsIDIpLFxuICAgIHN1cHBvcnRzR2VvbG9jYXRpb24gPSBfdXNlU3RhdGU0WzBdLFxuICAgIHNldFN1cHBvcnRzR2VvbG9jYXRpb24gPSBfdXNlU3RhdGU0WzFdO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250cm9sO1xuICAgIGlmIChjb250ZXh0Lm1hcCkge1xuICAgICAgaXNHZW9sb2NhdGlvblN1cHBvcnRlZCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBzZXRTdXBwb3J0c0dlb2xvY2F0aW9uKHJlc3VsdCk7XG4gICAgICAgIGlmIChnZW9sb2NhdGVCdXR0b25SZWYuY3VycmVudCkge1xuICAgICAgICAgIGNvbnRyb2wgPSBzZXR1cE1hcGJveEdlb2xvY2F0ZUNvbnRyb2woY29udGV4dCwgcHJvcHMsIGdlb2xvY2F0ZUJ1dHRvblJlZi5jdXJyZW50KTtcbiAgICAgICAgICBjb250cm9sLl91cGRhdGVDYW1lcmEgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYW1lcmEocG9zaXRpb24sIHRoaXNSZWYpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY3JlYXRlTWFwYm94R2VvbG9jYXRlQ29udHJvbChjb250cm9sKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY29udHJvbCkge1xuICAgICAgICBjb250cm9sLl9jbGVhcldhdGNoKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2NvbnRleHQubWFwXSk7XG4gIHZhciB0cmlnZ2VyR2VvbG9jYXRlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGlmIChtYXBib3hHZW9sb2NhdGVDb250cm9sKSB7XG4gICAgICBtYXBib3hHZW9sb2NhdGVDb250cm9sLm9wdGlvbnMgPSB0aGlzUmVmLnByb3BzO1xuICAgICAgbWFwYm94R2VvbG9jYXRlQ29udHJvbC50cmlnZ2VyKCk7XG4gICAgfVxuICB9LCBbbWFwYm94R2VvbG9jYXRlQ29udHJvbF0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcm9wcy5hdXRvKSB7XG4gICAgICB0cmlnZ2VyR2VvbG9jYXRlKCk7XG4gICAgfVxuICB9LCBbbWFwYm94R2VvbG9jYXRlQ29udHJvbCwgcHJvcHMuYXV0b10pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChtYXBib3hHZW9sb2NhdGVDb250cm9sKSB7XG4gICAgICBtYXBib3hHZW9sb2NhdGVDb250cm9sLl9vblpvb20oKTtcbiAgICB9XG4gIH0sIFtjb250ZXh0LnZpZXdwb3J0Lnpvb21dKTtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICBsYWJlbCA9IHByb3BzLmxhYmVsLFxuICAgIGRpc2FibGVkTGFiZWwgPSBwcm9wcy5kaXNhYmxlZExhYmVsLFxuICAgIHRyYWNrVXNlckxvY2F0aW9uID0gcHJvcHMudHJhY2tVc2VyTG9jYXRpb247XG4gIHZhciBzdHlsZSA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSwgcHJvcHMuc3R5bGUpO1xuICB9LCBbcHJvcHMuc3R5bGVdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHN0eWxlOiBzdHlsZSxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IFwiZ2VvbG9jYXRlLWNvbnRyb2xcIixcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybCBtYXBib3hnbC1jdHJsLWdyb3VwXCIsXG4gICAgcmVmOiBjb250YWluZXJSZWZcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAga2V5OiBcImdlb2xvY2F0ZVwiLFxuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsLWljb24gbWFwYm94Z2wtY3RybC1nZW9sb2NhdGVcIixcbiAgICByZWY6IGdlb2xvY2F0ZUJ1dHRvblJlZixcbiAgICBkaXNhYmxlZDogIXN1cHBvcnRzR2VvbG9jYXRpb24sXG4gICAgXCJhcmlhLXByZXNzZWRcIjogIXRyYWNrVXNlckxvY2F0aW9uLFxuICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgdGl0bGU6IHN1cHBvcnRzR2VvbG9jYXRpb24gPyBsYWJlbCA6IGRpc2FibGVkTGFiZWwsXG4gICAgXCJhcmlhLWxhYmVsXCI6IHN1cHBvcnRzR2VvbG9jYXRpb24gPyBsYWJlbCA6IGRpc2FibGVkTGFiZWwsXG4gICAgb25DbGljazogdHJpZ2dlckdlb2xvY2F0ZVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwtaWNvblwiLFxuICAgIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCJcbiAgfSkpKSk7XG59XG5HZW9sb2NhdGVDb250cm9sLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbmV4cG9ydCBkZWZhdWx0IFJlYWN0Lm1lbW8oR2VvbG9jYXRlQ29udHJvbCk7IiwiZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9ucyh2ZXJzaW9uMSwgdmVyc2lvbjIpIHtcbiAgdmFyIHYxID0gKHZlcnNpb24xIHx8ICcnKS5zcGxpdCgnLicpLm1hcChOdW1iZXIpO1xuICB2YXIgdjIgPSAodmVyc2lvbjIgfHwgJycpLnNwbGl0KCcuJykubWFwKE51bWJlcik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgdmFyIHBhcnQxID0gdjFbaV0gfHwgMDtcbiAgICB2YXIgcGFydDIgPSB2MltpXSB8fCAwO1xuICAgIGlmIChwYXJ0MSA8IHBhcnQyKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChwYXJ0MSA+IHBhcnQyKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBNYXBTdGF0ZSBmcm9tICcuLi91dGlscy9tYXAtc3RhdGUnO1xuaW1wb3J0IHsgTElORUFSX1RSQU5TSVRJT05fUFJPUFMgfSBmcm9tICcuLi91dGlscy9tYXAtY29udHJvbGxlcic7XG5pbXBvcnQgeyBjb21wYXJlVmVyc2lvbnMgfSBmcm9tICcuLi91dGlscy92ZXJzaW9uJztcbmltcG9ydCB1c2VNYXBDb250cm9sLCB7IG1hcENvbnRyb2xEZWZhdWx0UHJvcHMsIG1hcENvbnRyb2xQcm9wVHlwZXMgfSBmcm9tICcuL3VzZS1tYXAtY29udHJvbCc7XG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXBDb250cm9sRGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogJycsXG4gIHNob3dDb21wYXNzOiB0cnVlLFxuICBzaG93Wm9vbTogdHJ1ZSxcbiAgem9vbUluTGFiZWw6ICdab29tIEluJyxcbiAgem9vbU91dExhYmVsOiAnWm9vbSBPdXQnLFxuICBjb21wYXNzTGFiZWw6ICdSZXNldCBOb3J0aCdcbn0pO1xudmFyIFZFUlNJT05fTEVHQUNZID0gMTtcbnZhciBWRVJTSU9OXzFfNiA9IDI7XG5mdW5jdGlvbiBnZXRVSVZlcnNpb24obWFwYm94VmVyc2lvbikge1xuICByZXR1cm4gY29tcGFyZVZlcnNpb25zKG1hcGJveFZlcnNpb24sICcxLjYuMCcpID49IDAgPyBWRVJTSU9OXzFfNiA6IFZFUlNJT05fTEVHQUNZO1xufVxuZnVuY3Rpb24gdXBkYXRlVmlld3BvcnQoY29udGV4dCwgcHJvcHMsIG9wdHMpIHtcbiAgdmFyIHZpZXdwb3J0ID0gY29udGV4dC52aWV3cG9ydDtcbiAgdmFyIG1hcFN0YXRlID0gbmV3IE1hcFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIHZpZXdwb3J0LCBvcHRzKSk7XG4gIHZhciB2aWV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtYXBTdGF0ZS5nZXRWaWV3cG9ydFByb3BzKCksIExJTkVBUl9UUkFOU0lUSU9OX1BST1BTKTtcbiAgdmFyIG9uVmlld3BvcnRDaGFuZ2UgPSBwcm9wcy5vblZpZXdwb3J0Q2hhbmdlIHx8IGNvbnRleHQub25WaWV3cG9ydENoYW5nZSB8fCBub29wO1xuICB2YXIgb25WaWV3U3RhdGVDaGFuZ2UgPSBwcm9wcy5vblZpZXdTdGF0ZUNoYW5nZSB8fCBjb250ZXh0Lm9uVmlld1N0YXRlQ2hhbmdlIHx8IG5vb3A7XG4gIG9uVmlld1N0YXRlQ2hhbmdlKHtcbiAgICB2aWV3U3RhdGU6IHZpZXdTdGF0ZVxuICB9KTtcbiAgb25WaWV3cG9ydENoYW5nZSh2aWV3U3RhdGUpO1xufVxuZnVuY3Rpb24gcmVuZGVyQnV0dG9uKHR5cGUsIGxhYmVsLCBjYWxsYmFjaywgY2hpbGRyZW4pIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIGtleTogdHlwZSxcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybC1pY29uIG1hcGJveGdsLWN0cmwtXCIuY29uY2F0KHR5cGUpLFxuICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgdGl0bGU6IGxhYmVsLFxuICAgIG9uQ2xpY2s6IGNhbGxiYWNrXG4gIH0sIGNoaWxkcmVuIHx8IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybC1pY29uXCIsXG4gICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuICB9KSk7XG59XG5mdW5jdGlvbiByZW5kZXJDb21wYXNzKGNvbnRleHQpIHtcbiAgdmFyIHVpVmVyc2lvbiA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb250ZXh0Lm1hcCA/IGdldFVJVmVyc2lvbihjb250ZXh0Lm1hcC52ZXJzaW9uKSA6IFZFUlNJT05fMV82O1xuICB9LCBbY29udGV4dC5tYXBdKTtcbiAgdmFyIGJlYXJpbmcgPSBjb250ZXh0LnZpZXdwb3J0LmJlYXJpbmc7XG4gIHZhciBzdHlsZSA9IHtcbiAgICB0cmFuc2Zvcm06IFwicm90YXRlKFwiLmNvbmNhdCgtYmVhcmluZywgXCJkZWcpXCIpXG4gIH07XG4gIHJldHVybiB1aVZlcnNpb24gPT09IFZFUlNJT05fMV82ID8gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsLWljb25cIixcbiAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9KSA6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybC1jb21wYXNzLWFycm93XCIsXG4gICAgc3R5bGU6IHN0eWxlXG4gIH0pO1xufVxuZnVuY3Rpb24gTmF2aWdhdGlvbkNvbnRyb2wocHJvcHMpIHtcbiAgdmFyIF91c2VNYXBDb250cm9sID0gdXNlTWFwQ29udHJvbChwcm9wcyksXG4gICAgY29udGV4dCA9IF91c2VNYXBDb250cm9sLmNvbnRleHQsXG4gICAgY29udGFpbmVyUmVmID0gX3VzZU1hcENvbnRyb2wuY29udGFpbmVyUmVmO1xuICB2YXIgb25ab29tSW4gPSBmdW5jdGlvbiBvblpvb21JbigpIHtcbiAgICB1cGRhdGVWaWV3cG9ydChjb250ZXh0LCBwcm9wcywge1xuICAgICAgem9vbTogY29udGV4dC52aWV3cG9ydC56b29tICsgMVxuICAgIH0pO1xuICB9O1xuICB2YXIgb25ab29tT3V0ID0gZnVuY3Rpb24gb25ab29tT3V0KCkge1xuICAgIHVwZGF0ZVZpZXdwb3J0KGNvbnRleHQsIHByb3BzLCB7XG4gICAgICB6b29tOiBjb250ZXh0LnZpZXdwb3J0Lnpvb20gLSAxXG4gICAgfSk7XG4gIH07XG4gIHZhciBvblJlc2V0Tm9ydGggPSBmdW5jdGlvbiBvblJlc2V0Tm9ydGgoKSB7XG4gICAgdXBkYXRlVmlld3BvcnQoY29udGV4dCwgcHJvcHMsIHtcbiAgICAgIGJlYXJpbmc6IDAsXG4gICAgICBwaXRjaDogMFxuICAgIH0pO1xuICB9O1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgIHNob3dDb21wYXNzID0gcHJvcHMuc2hvd0NvbXBhc3MsXG4gICAgc2hvd1pvb20gPSBwcm9wcy5zaG93Wm9vbSxcbiAgICB6b29tSW5MYWJlbCA9IHByb3BzLnpvb21JbkxhYmVsLFxuICAgIHpvb21PdXRMYWJlbCA9IHByb3BzLnpvb21PdXRMYWJlbCxcbiAgICBjb21wYXNzTGFiZWwgPSBwcm9wcy5jb21wYXNzTGFiZWw7XG4gIHZhciBzdHlsZSA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSwgcHJvcHMuc3R5bGUpO1xuICB9LCBbcHJvcHMuc3R5bGVdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHN0eWxlOiBzdHlsZSxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybCBtYXBib3hnbC1jdHJsLWdyb3VwXCIsXG4gICAgcmVmOiBjb250YWluZXJSZWZcbiAgfSwgc2hvd1pvb20gJiYgcmVuZGVyQnV0dG9uKCd6b29tLWluJywgem9vbUluTGFiZWwsIG9uWm9vbUluKSwgc2hvd1pvb20gJiYgcmVuZGVyQnV0dG9uKCd6b29tLW91dCcsIHpvb21PdXRMYWJlbCwgb25ab29tT3V0KSwgc2hvd0NvbXBhc3MgJiYgcmVuZGVyQnV0dG9uKCdjb21wYXNzJywgY29tcGFzc0xhYmVsLCBvblJlc2V0Tm9ydGgsIHJlbmRlckNvbXBhc3MoY29udGV4dCkpKSk7XG59XG5OYXZpZ2F0aW9uQ29udHJvbC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKE5hdmlnYXRpb25Db250cm9sKTsiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgbWFwYm94Z2wgZnJvbSAnLi4vdXRpbHMvbWFwYm94Z2wnO1xuaW1wb3J0IHVzZU1hcENvbnRyb2wsIHsgbWFwQ29udHJvbERlZmF1bHRQcm9wcywgbWFwQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4vdXNlLW1hcC1jb250cm9sJztcbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXBDb250cm9sRGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogJycsXG4gIG1heFdpZHRoOiAxMDAsXG4gIHVuaXQ6ICdtZXRyaWMnXG59KTtcbmZ1bmN0aW9uIFNjYWxlQ29udHJvbChwcm9wcykge1xuICB2YXIgX3VzZU1hcENvbnRyb2wgPSB1c2VNYXBDb250cm9sKHByb3BzKSxcbiAgICBjb250ZXh0ID0gX3VzZU1hcENvbnRyb2wuY29udGV4dCxcbiAgICBjb250YWluZXJSZWYgPSBfdXNlTWFwQ29udHJvbC5jb250YWluZXJSZWY7XG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShudWxsKSxcbiAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICBtYXBib3hTY2FsZUNvbnRyb2wgPSBfdXNlU3RhdGUyWzBdLFxuICAgIGNyZWF0ZU1hcGJveFNjYWxlQ29udHJvbCA9IF91c2VTdGF0ZTJbMV07XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbnRleHQubWFwKSB7XG4gICAgICB2YXIgY29udHJvbCA9IG5ldyBtYXBib3hnbC5TY2FsZUNvbnRyb2woKTtcbiAgICAgIGNvbnRyb2wuX21hcCA9IGNvbnRleHQubWFwO1xuICAgICAgY29udHJvbC5fY29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICBjcmVhdGVNYXBib3hTY2FsZUNvbnRyb2woY29udHJvbCk7XG4gICAgfVxuICB9LCBbY29udGV4dC5tYXBdKTtcbiAgaWYgKG1hcGJveFNjYWxlQ29udHJvbCkge1xuICAgIG1hcGJveFNjYWxlQ29udHJvbC5vcHRpb25zID0gcHJvcHM7XG4gICAgaWYgKG1hcGJveFNjYWxlQ29udHJvbC5fb25Nb3ZlKSBtYXBib3hTY2FsZUNvbnRyb2wuX29uTW92ZSgpO1xuICB9XG4gIHZhciBzdHlsZSA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSwgcHJvcHMuc3R5bGUpO1xuICB9LCBbcHJvcHMuc3R5bGVdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHN0eWxlOiBzdHlsZSxcbiAgICBjbGFzc05hbWU6IHByb3BzLmNsYXNzTmFtZVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICByZWY6IGNvbnRhaW5lclJlZixcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybCBtYXBib3hnbC1jdHJsLXNjYWxlXCJcbiAgfSkpO1xufVxuU2NhbGVDb250cm9sLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbmV4cG9ydCBkZWZhdWx0IFJlYWN0Lm1lbW8oU2NhbGVDb250cm9sKTsiLCJpbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi4vY29tcG9uZW50cy91c2UtbWFwLWNvbnRyb2wnO1xudmFyIHBpeGVsUmF0aW8gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgY2FwdHVyZVNjcm9sbDogZmFsc2UsXG4gIGNhcHR1cmVEcmFnOiBmYWxzZSxcbiAgY2FwdHVyZUNsaWNrOiBmYWxzZSxcbiAgY2FwdHVyZURvdWJsZUNsaWNrOiBmYWxzZSxcbiAgY2FwdHVyZVBvaW50ZXJNb3ZlOiBmYWxzZVxufTtcbmZ1bmN0aW9uIENhbnZhc092ZXJsYXkocHJvcHMpIHtcbiAgdmFyIF91c2VNYXBDb250cm9sID0gdXNlTWFwQ29udHJvbChwcm9wcyksXG4gICAgY29udGV4dCA9IF91c2VNYXBDb250cm9sLmNvbnRleHQsXG4gICAgY29udGFpbmVyUmVmID0gX3VzZU1hcENvbnRyb2wuY29udGFpbmVyUmVmO1xuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUobnVsbCksXG4gICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgY3R4ID0gX3VzZVN0YXRlMlswXSxcbiAgICBzZXREcmF3aW5nQ29udGV4dCA9IF91c2VTdGF0ZTJbMV07XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgc2V0RHJhd2luZ0NvbnRleHQoY29udGFpbmVyUmVmLmN1cnJlbnQuZ2V0Q29udGV4dCgnMmQnKSk7XG4gIH0sIFtdKTtcbiAgdmFyIHZpZXdwb3J0ID0gY29udGV4dC52aWV3cG9ydCxcbiAgICBpc0RyYWdnaW5nID0gY29udGV4dC5pc0RyYWdnaW5nO1xuICBpZiAoY3R4KSB7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgcHJvcHMucmVkcmF3KHtcbiAgICAgIHdpZHRoOiB2aWV3cG9ydC53aWR0aCxcbiAgICAgIGhlaWdodDogdmlld3BvcnQuaGVpZ2h0LFxuICAgICAgY3R4OiBjdHgsXG4gICAgICBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nLFxuICAgICAgcHJvamVjdDogdmlld3BvcnQucHJvamVjdCxcbiAgICAgIHVucHJvamVjdDogdmlld3BvcnQudW5wcm9qZWN0XG4gICAgfSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiLCB7XG4gICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgd2lkdGg6IHZpZXdwb3J0LndpZHRoICogcGl4ZWxSYXRpbyxcbiAgICBoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCAqIHBpeGVsUmF0aW8sXG4gICAgc3R5bGU6IHtcbiAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdCh2aWV3cG9ydC53aWR0aCwgXCJweFwiKSxcbiAgICAgIGhlaWdodDogXCJcIi5jb25jYXQodmlld3BvcnQuaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfVxuICB9KTtcbn1cbkNhbnZhc092ZXJsYXkuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuZXhwb3J0IGRlZmF1bHQgQ2FudmFzT3ZlcmxheTsiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi4vY29tcG9uZW50cy91c2UtbWFwLWNvbnRyb2wnO1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgY2FwdHVyZVNjcm9sbDogZmFsc2UsXG4gIGNhcHR1cmVEcmFnOiBmYWxzZSxcbiAgY2FwdHVyZUNsaWNrOiBmYWxzZSxcbiAgY2FwdHVyZURvdWJsZUNsaWNrOiBmYWxzZSxcbiAgY2FwdHVyZVBvaW50ZXJNb3ZlOiBmYWxzZVxufTtcbmZ1bmN0aW9uIEhUTUxPdmVybGF5KHByb3BzKSB7XG4gIHZhciBfdXNlTWFwQ29udHJvbCA9IHVzZU1hcENvbnRyb2wocHJvcHMpLFxuICAgIGNvbnRleHQgPSBfdXNlTWFwQ29udHJvbC5jb250ZXh0LFxuICAgIGNvbnRhaW5lclJlZiA9IF91c2VNYXBDb250cm9sLmNvbnRhaW5lclJlZjtcbiAgdmFyIHZpZXdwb3J0ID0gY29udGV4dC52aWV3cG9ydCxcbiAgICBpc0RyYWdnaW5nID0gY29udGV4dC5pc0RyYWdnaW5nO1xuICB2YXIgc3R5bGUgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbiAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgaGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHRcbiAgfSwgcHJvcHMuc3R5bGUpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgc3R5bGU6IHN0eWxlXG4gIH0sIHByb3BzLnJlZHJhdyh7XG4gICAgd2lkdGg6IHZpZXdwb3J0LndpZHRoLFxuICAgIGhlaWdodDogdmlld3BvcnQuaGVpZ2h0LFxuICAgIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmcsXG4gICAgcHJvamVjdDogdmlld3BvcnQucHJvamVjdCxcbiAgICB1bnByb2plY3Q6IHZpZXdwb3J0LnVucHJvamVjdFxuICB9KSk7XG59XG5IVE1MT3ZlcmxheS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBIVE1MT3ZlcmxheTsiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi4vY29tcG9uZW50cy91c2UtbWFwLWNvbnRyb2wnO1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgY2FwdHVyZVNjcm9sbDogZmFsc2UsXG4gIGNhcHR1cmVEcmFnOiBmYWxzZSxcbiAgY2FwdHVyZUNsaWNrOiBmYWxzZSxcbiAgY2FwdHVyZURvdWJsZUNsaWNrOiBmYWxzZSxcbiAgY2FwdHVyZVBvaW50ZXJNb3ZlOiBmYWxzZVxufTtcbmZ1bmN0aW9uIFNWR092ZXJsYXkocHJvcHMpIHtcbiAgdmFyIF91c2VNYXBDb250cm9sID0gdXNlTWFwQ29udHJvbChwcm9wcyksXG4gICAgY29udGV4dCA9IF91c2VNYXBDb250cm9sLmNvbnRleHQsXG4gICAgY29udGFpbmVyUmVmID0gX3VzZU1hcENvbnRyb2wuY29udGFpbmVyUmVmO1xuICB2YXIgdmlld3BvcnQgPSBjb250ZXh0LnZpZXdwb3J0LFxuICAgIGlzRHJhZ2dpbmcgPSBjb250ZXh0LmlzRHJhZ2dpbmc7XG4gIHZhciBzdHlsZSA9IF9vYmplY3RTcHJlYWQoe1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwXG4gIH0sIHByb3BzLnN0eWxlKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgIHdpZHRoOiB2aWV3cG9ydC53aWR0aCxcbiAgICBoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCxcbiAgICByZWY6IGNvbnRhaW5lclJlZixcbiAgICBzdHlsZTogc3R5bGVcbiAgfSwgcHJvcHMucmVkcmF3KHtcbiAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgaGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHQsXG4gICAgaXNEcmFnZ2luZzogaXNEcmFnZ2luZyxcbiAgICBwcm9qZWN0OiB2aWV3cG9ydC5wcm9qZWN0LFxuICAgIHVucHJvamVjdDogdmlld3BvcnQudW5wcm9qZWN0XG4gIH0pKTtcbn1cblNWR092ZXJsYXkuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuZXhwb3J0IGRlZmF1bHQgU1ZHT3ZlcmxheTsiLCJpbXBvcnQgbWFwYm94Z2wgZnJvbSAnLi9tYXBib3hnbCc7XG52YXIgc2V0UlRMVGV4dFBsdWdpbiA9IG1hcGJveGdsID8gbWFwYm94Z2wuc2V0UlRMVGV4dFBsdWdpbiA6IGZ1bmN0aW9uICgpIHt9O1xuZXhwb3J0IGRlZmF1bHQgc2V0UlRMVGV4dFBsdWdpbjsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9jb21wb25lbnRzL2ludGVyYWN0aXZlLW1hcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEludGVyYWN0aXZlTWFwIH0gZnJvbSAnLi9jb21wb25lbnRzL2ludGVyYWN0aXZlLW1hcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN0YXRpY01hcCB9IGZyb20gJy4vY29tcG9uZW50cy9zdGF0aWMtbWFwJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU291cmNlIH0gZnJvbSAnLi9jb21wb25lbnRzL3NvdXJjZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIExheWVyIH0gZnJvbSAnLi9jb21wb25lbnRzL2xheWVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQmFzZUNvbnRyb2wgfSBmcm9tICcuL2NvbXBvbmVudHMvYmFzZS1jb250cm9sJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWFya2VyIH0gZnJvbSAnLi9jb21wb25lbnRzL21hcmtlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBvcHVwIH0gZnJvbSAnLi9jb21wb25lbnRzL3BvcHVwJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQXR0cmlidXRpb25Db250cm9sIH0gZnJvbSAnLi9jb21wb25lbnRzL2F0dHJpYnV0aW9uLWNvbnRyb2wnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGdWxsc2NyZWVuQ29udHJvbCB9IGZyb20gJy4vY29tcG9uZW50cy9mdWxsc2NyZWVuLWNvbnRyb2wnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBHZW9sb2NhdGVDb250cm9sIH0gZnJvbSAnLi9jb21wb25lbnRzL2dlb2xvY2F0ZS1jb250cm9sJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTmF2aWdhdGlvbkNvbnRyb2wgfSBmcm9tICcuL2NvbXBvbmVudHMvbmF2aWdhdGlvbi1jb250cm9sJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2NhbGVDb250cm9sIH0gZnJvbSAnLi9jb21wb25lbnRzL3NjYWxlLWNvbnRyb2wnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDYW52YXNPdmVybGF5IH0gZnJvbSAnLi9vdmVybGF5cy9jYW52YXMtb3ZlcmxheSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEhUTUxPdmVybGF5IH0gZnJvbSAnLi9vdmVybGF5cy9odG1sLW92ZXJsYXknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTVkdPdmVybGF5IH0gZnJvbSAnLi9vdmVybGF5cy9zdmctb3ZlcmxheSc7XG5leHBvcnQgeyBUUkFOU0lUSU9OX0VWRU5UUyB9IGZyb20gJy4vdXRpbHMvdHJhbnNpdGlvbi1tYW5hZ2VyJztcbmV4cG9ydCB7IFRyYW5zaXRpb25JbnRlcnBvbGF0b3IsIExpbmVhckludGVycG9sYXRvciwgVmlld3BvcnRGbHlUb0ludGVycG9sYXRvciBhcyBGbHlUb0ludGVycG9sYXRvciB9IGZyb20gJy4vdXRpbHMvdHJhbnNpdGlvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1hcENvbnRyb2xsZXIgfSBmcm9tICcuL3V0aWxzL21hcC1jb250cm9sbGVyJztcbmV4cG9ydCB7IFdlYk1lcmNhdG9yVmlld3BvcnQgfSBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc2V0UlRMVGV4dFBsdWdpbiB9IGZyb20gJy4vdXRpbHMvc2V0LXJ0bC10ZXh0LXBsdWdpbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1hcENvbnRleHQgfSBmcm9tICcuL2NvbXBvbmVudHMvbWFwLWNvbnRleHQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBfdXNlTWFwQ29udHJvbCB9IGZyb20gJy4vY29tcG9uZW50cy91c2UtbWFwLWNvbnRyb2wnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBfTWFwQ29udGV4dCB9IGZyb20gJy4vY29tcG9uZW50cy9tYXAtY29udGV4dCc7IiwiLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnNcbiAqL1xuLyoqXG4gKiBFYXJ0aCBSYWRpdXMgdXNlZCB3aXRoIHRoZSBIYXJ2ZXNpbmUgZm9ybXVsYSBhbmQgYXBwcm94aW1hdGVzIHVzaW5nIGEgc3BoZXJpY2FsIChub24tZWxsaXBzb2lkKSBFYXJ0aC5cbiAqXG4gKiBAbWVtYmVyb2YgaGVscGVyc1xuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBlYXJ0aFJhZGl1cyA9IDYzNzEwMDguODtcbi8qKlxuICogVW5pdCBvZiBtZWFzdXJlbWVudCBmYWN0b3JzIHVzaW5nIGEgc3BoZXJpY2FsIChub24tZWxsaXBzb2lkKSBlYXJ0aCByYWRpdXMuXG4gKlxuICogQG1lbWJlcm9mIGhlbHBlcnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydCB2YXIgZmFjdG9ycyA9IHtcbiAgY2VudGltZXRlcnM6IGVhcnRoUmFkaXVzICogMTAwLFxuICBjZW50aW1ldHJlczogZWFydGhSYWRpdXMgKiAxMDAsXG4gIGRlZ3JlZXM6IGVhcnRoUmFkaXVzIC8gMTExMzI1LFxuICBmZWV0OiBlYXJ0aFJhZGl1cyAqIDMuMjgwODQsXG4gIGluY2hlczogZWFydGhSYWRpdXMgKiAzOS4zNyxcbiAga2lsb21ldGVyczogZWFydGhSYWRpdXMgLyAxMDAwLFxuICBraWxvbWV0cmVzOiBlYXJ0aFJhZGl1cyAvIDEwMDAsXG4gIG1ldGVyczogZWFydGhSYWRpdXMsXG4gIG1ldHJlczogZWFydGhSYWRpdXMsXG4gIG1pbGVzOiBlYXJ0aFJhZGl1cyAvIDE2MDkuMzQ0LFxuICBtaWxsaW1ldGVyczogZWFydGhSYWRpdXMgKiAxMDAwLFxuICBtaWxsaW1ldHJlczogZWFydGhSYWRpdXMgKiAxMDAwLFxuICBuYXV0aWNhbG1pbGVzOiBlYXJ0aFJhZGl1cyAvIDE4NTIsXG4gIHJhZGlhbnM6IDEsXG4gIHlhcmRzOiBlYXJ0aFJhZGl1cyAqIDEuMDkzNlxufTtcbi8qKlxuICogVW5pdHMgb2YgbWVhc3VyZW1lbnQgZmFjdG9ycyBiYXNlZCBvbiAxIG1ldGVyLlxuICpcbiAqIEBtZW1iZXJvZiBoZWxwZXJzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnQgdmFyIHVuaXRzRmFjdG9ycyA9IHtcbiAgY2VudGltZXRlcnM6IDEwMCxcbiAgY2VudGltZXRyZXM6IDEwMCxcbiAgZGVncmVlczogMSAvIDExMTMyNSxcbiAgZmVldDogMy4yODA4NCxcbiAgaW5jaGVzOiAzOS4zNyxcbiAga2lsb21ldGVyczogMSAvIDEwMDAsXG4gIGtpbG9tZXRyZXM6IDEgLyAxMDAwLFxuICBtZXRlcnM6IDEsXG4gIG1ldHJlczogMSxcbiAgbWlsZXM6IDEgLyAxNjA5LjM0NCxcbiAgbWlsbGltZXRlcnM6IDEwMDAsXG4gIG1pbGxpbWV0cmVzOiAxMDAwLFxuICBuYXV0aWNhbG1pbGVzOiAxIC8gMTg1MixcbiAgcmFkaWFuczogMSAvIGVhcnRoUmFkaXVzLFxuICB5YXJkczogMS4wOTM2MTMzXG59O1xuLyoqXG4gKiBBcmVhIG9mIG1lYXN1cmVtZW50IGZhY3RvcnMgYmFzZWQgb24gMSBzcXVhcmUgbWV0ZXIuXG4gKlxuICogQG1lbWJlcm9mIGhlbHBlcnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydCB2YXIgYXJlYUZhY3RvcnMgPSB7XG4gIGFjcmVzOiAwLjAwMDI0NzEwNSxcbiAgY2VudGltZXRlcnM6IDEwMDAwLFxuICBjZW50aW1ldHJlczogMTAwMDAsXG4gIGZlZXQ6IDEwLjc2MzkxMDQxNyxcbiAgaGVjdGFyZXM6IDAuMDAwMSxcbiAgaW5jaGVzOiAxNTUwLjAwMzEwMDAwNixcbiAga2lsb21ldGVyczogMC4wMDAwMDEsXG4gIGtpbG9tZXRyZXM6IDAuMDAwMDAxLFxuICBtZXRlcnM6IDEsXG4gIG1ldHJlczogMSxcbiAgbWlsZXM6IDMuODZlLTcsXG4gIG1pbGxpbWV0ZXJzOiAxMDAwMDAwLFxuICBtaWxsaW1ldHJlczogMTAwMDAwMCxcbiAgeWFyZHM6IDEuMTk1OTkwMDQ2XG59O1xuLyoqXG4gKiBXcmFwcyBhIEdlb0pTT04ge0BsaW5rIEdlb21ldHJ5fSBpbiBhIEdlb0pTT04ge0BsaW5rIEZlYXR1cmV9LlxuICpcbiAqIEBuYW1lIGZlYXR1cmVcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb21ldHJ5IGlucHV0IGdlb21ldHJ5XG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmV9IGEgR2VvSlNPTiBGZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIGdlb21ldHJ5ID0ge1xuICogICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICBcImNvb3JkaW5hdGVzXCI6IFsxMTAsIDUwXVxuICogfTtcbiAqXG4gKiB2YXIgZmVhdHVyZSA9IHR1cmYuZmVhdHVyZShnZW9tZXRyeSk7XG4gKlxuICogLy89ZmVhdHVyZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgdmFyIGZlYXQgPSB7XG4gICAgdHlwZTogXCJGZWF0dXJlXCJcbiAgfTtcbiAgaWYgKG9wdGlvbnMuaWQgPT09IDAgfHwgb3B0aW9ucy5pZCkge1xuICAgIGZlYXQuaWQgPSBvcHRpb25zLmlkO1xuICB9XG4gIGlmIChvcHRpb25zLmJib3gpIHtcbiAgICBmZWF0LmJib3ggPSBvcHRpb25zLmJib3g7XG4gIH1cbiAgZmVhdC5wcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCB7fTtcbiAgZmVhdC5nZW9tZXRyeSA9IGdlb207XG4gIHJldHVybiBmZWF0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgR2VvSlNPTiB7QGxpbmsgR2VvbWV0cnl9IGZyb20gYSBHZW9tZXRyeSBzdHJpbmcgdHlwZSAmIGNvb3JkaW5hdGVzLlxuICogRm9yIEdlb21ldHJ5Q29sbGVjdGlvbiB0eXBlIHVzZSBgaGVscGVycy5nZW9tZXRyeUNvbGxlY3Rpb25gXG4gKlxuICogQG5hbWUgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEdlb21ldHJ5IFR5cGVcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHJldHVybnMge0dlb21ldHJ5fSBhIEdlb0pTT04gR2VvbWV0cnlcbiAqIEBleGFtcGxlXG4gKiB2YXIgdHlwZSA9IFwiUG9pbnRcIjtcbiAqIHZhciBjb29yZGluYXRlcyA9IFsxMTAsIDUwXTtcbiAqIHZhciBnZW9tZXRyeSA9IHR1cmYuZ2VvbWV0cnkodHlwZSwgY29vcmRpbmF0ZXMpO1xuICogLy8gPT4gZ2VvbWV0cnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlb21ldHJ5KHR5cGUsIGNvb3JkaW5hdGVzLCBfb3B0aW9ucykge1xuICBpZiAoX29wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIF9vcHRpb25zID0ge307XG4gIH1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcIlBvaW50XCI6XG4gICAgICByZXR1cm4gcG9pbnQoY29vcmRpbmF0ZXMpLmdlb21ldHJ5O1xuICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICByZXR1cm4gbGluZVN0cmluZyhjb29yZGluYXRlcykuZ2VvbWV0cnk7XG4gICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgIHJldHVybiBwb2x5Z29uKGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcbiAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgcmV0dXJuIG11bHRpUG9pbnQoY29vcmRpbmF0ZXMpLmdlb21ldHJ5O1xuICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjpcbiAgICAgIHJldHVybiBtdWx0aUxpbmVTdHJpbmcoY29vcmRpbmF0ZXMpLmdlb21ldHJ5O1xuICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgIHJldHVybiBtdWx0aVBvbHlnb24oY29vcmRpbmF0ZXMpLmdlb21ldHJ5O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodHlwZSArIFwiIGlzIGludmFsaWRcIik7XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBQb2ludH0ge0BsaW5rIEZlYXR1cmV9IGZyb20gYSBQb3NpdGlvbi5cbiAqXG4gKiBAbmFtZSBwb2ludFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb29yZGluYXRlcyBsb25naXR1ZGUsIGxhdGl0dWRlIHBvc2l0aW9uIChlYWNoIGluIGRlY2ltYWwgZGVncmVlcylcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2ludD59IGEgUG9pbnQgZmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludCA9IHR1cmYucG9pbnQoWy03NS4zNDMsIDM5Ljk4NF0pO1xuICpcbiAqIC8vPXBvaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2ludChjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGlmICghY29vcmRpbmF0ZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBpcyByZXF1aXJlZFwiKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoY29vcmRpbmF0ZXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29vcmRpbmF0ZXMgbXVzdCBiZSBhbiBBcnJheVwiKTtcbiAgfVxuICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvb3JkaW5hdGVzIG11c3QgYmUgYXQgbGVhc3QgMiBudW1iZXJzIGxvbmdcIik7XG4gIH1cbiAgaWYgKCFpc051bWJlcihjb29yZGluYXRlc1swXSkgfHwgIWlzTnVtYmVyKGNvb3JkaW5hdGVzWzFdKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvb3JkaW5hdGVzIG11c3QgY29udGFpbiBudW1iZXJzXCIpO1xuICB9XG4gIHZhciBnZW9tID0ge1xuICAgIHR5cGU6IFwiUG9pbnRcIixcbiAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgfTtcbiAgcmV0dXJuIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUG9pbnR9IHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0gZnJvbSBhbiBBcnJheSBvZiBQb2ludCBjb29yZGluYXRlcy5cbiAqXG4gKiBAbmFtZSBwb2ludHNcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIFBvaW50c1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBUcmFuc2xhdGUgdGhlc2UgcHJvcGVydGllcyB0byBlYWNoIEZlYXR1cmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF1cbiAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZUNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlQ29sbGVjdGlvblxuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPFBvaW50Pn0gUG9pbnQgRmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludHMgPSB0dXJmLnBvaW50cyhbXG4gKiAgIFstNzUsIDM5XSxcbiAqICAgWy04MCwgNDVdLFxuICogICBbLTc4LCA1MF1cbiAqIF0pO1xuICpcbiAqIC8vPXBvaW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRzKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKGNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgcmV0dXJuIHBvaW50KGNvb3JkcywgcHJvcGVydGllcyk7XG4gIH0pLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBQb2x5Z29ufSB7QGxpbmsgRmVhdHVyZX0gZnJvbSBhbiBBcnJheSBvZiBMaW5lYXJSaW5ncy5cbiAqXG4gKiBAbmFtZSBwb2x5Z29uXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEFycmF5PG51bWJlcj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgTGluZWFyUmluZ3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2x5Z29uPn0gUG9seWdvbiBGZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHlnb24gPSB0dXJmLnBvbHlnb24oW1tbLTUsIDUyXSwgWy00LCA1Nl0sIFstMiwgNTFdLCBbLTcsIDU0XSwgWy01LCA1Ml1dXSwgeyBuYW1lOiAncG9seTEnIH0pO1xuICpcbiAqIC8vPXBvbHlnb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvbHlnb24oY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBfaSA9IDAsIGNvb3JkaW5hdGVzXzEgPSBjb29yZGluYXRlczsgX2kgPCBjb29yZGluYXRlc18xLmxlbmd0aDsgX2krKykge1xuICAgIHZhciByaW5nID0gY29vcmRpbmF0ZXNfMVtfaV07XG4gICAgaWYgKHJpbmcubGVuZ3RoIDwgNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWFjaCBMaW5lYXJSaW5nIG9mIGEgUG9seWdvbiBtdXN0IGhhdmUgNCBvciBtb3JlIFBvc2l0aW9ucy5cIik7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZ1tyaW5nLmxlbmd0aCAtIDFdLmxlbmd0aDsgaisrKSB7XG4gICAgICAvLyBDaGVjayBpZiBmaXJzdCBwb2ludCBvZiBQb2x5Z29uIGNvbnRhaW5zIHR3byBudW1iZXJzXG4gICAgICBpZiAocmluZ1tyaW5nLmxlbmd0aCAtIDFdW2pdICE9PSByaW5nWzBdW2pdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpcnN0IGFuZCBsYXN0IFBvc2l0aW9uIGFyZSBub3QgZXF1aXZhbGVudC5cIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBnZW9tID0ge1xuICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICB9O1xuICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBQb2x5Z29ufSB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259IGZyb20gYW4gQXJyYXkgb2YgUG9seWdvbiBjb29yZGluYXRlcy5cbiAqXG4gKiBAbmFtZSBwb2x5Z29uc1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBQb2x5Z29uIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZUNvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPn0gUG9seWdvbiBGZWF0dXJlQ29sbGVjdGlvblxuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5Z29ucyA9IHR1cmYucG9seWdvbnMoW1xuICogICBbW1stNSwgNTJdLCBbLTQsIDU2XSwgWy0yLCA1MV0sIFstNywgNTRdLCBbLTUsIDUyXV1dLFxuICogICBbW1stMTUsIDQyXSwgWy0xNCwgNDZdLCBbLTEyLCA0MV0sIFstMTcsIDQ0XSwgWy0xNSwgNDJdXV0sXG4gKiBdKTtcbiAqXG4gKiAvLz1wb2x5Z29uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbnMoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4gZmVhdHVyZUNvbGxlY3Rpb24oY29vcmRpbmF0ZXMubWFwKGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICByZXR1cm4gcG9seWdvbihjb29yZHMsIHByb3BlcnRpZXMpO1xuICB9KSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgTGluZVN0cmluZ30ge0BsaW5rIEZlYXR1cmV9IGZyb20gYW4gQXJyYXkgb2YgUG9zaXRpb25zLlxuICpcbiAqIEBuYW1lIGxpbmVTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIFBvc2l0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBMaW5lU3RyaW5nIEZlYXR1cmVcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGluZXN0cmluZzEgPSB0dXJmLmxpbmVTdHJpbmcoW1stMjQsIDYzXSwgWy0yMywgNjBdLCBbLTI1LCA2NV0sIFstMjAsIDY5XV0sIHtuYW1lOiAnbGluZSAxJ30pO1xuICogdmFyIGxpbmVzdHJpbmcyID0gdHVyZi5saW5lU3RyaW5nKFtbLTE0LCA0M10sIFstMTMsIDQwXSwgWy0xNSwgNDVdLCBbLTEwLCA0OV1dLCB7bmFtZTogJ2xpbmUgMid9KTtcbiAqXG4gKiAvLz1saW5lc3RyaW5nMVxuICogLy89bGluZXN0cmluZzJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVTdHJpbmcoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvb3JkaW5hdGVzIG11c3QgYmUgYW4gYXJyYXkgb2YgdHdvIG9yIG1vcmUgcG9zaXRpb25zXCIpO1xuICB9XG4gIHZhciBnZW9tID0ge1xuICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICB9O1xuICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBMaW5lU3RyaW5nfSB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259IGZyb20gYW4gQXJyYXkgb2YgTGluZVN0cmluZyBjb29yZGluYXRlcy5cbiAqXG4gKiBAbmFtZSBsaW5lU3RyaW5nc1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIExpbmVhclJpbmdzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF1cbiAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZUNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlQ29sbGVjdGlvblxuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPExpbmVTdHJpbmc+fSBMaW5lU3RyaW5nIEZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmVzdHJpbmdzID0gdHVyZi5saW5lU3RyaW5ncyhbXG4gKiAgIFtbLTI0LCA2M10sIFstMjMsIDYwXSwgWy0yNSwgNjVdLCBbLTIwLCA2OV1dLFxuICogICBbWy0xNCwgNDNdLCBbLTEzLCA0MF0sIFstMTUsIDQ1XSwgWy0xMCwgNDldXVxuICogXSk7XG4gKlxuICogLy89bGluZXN0cmluZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVTdHJpbmdzKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKGNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgcmV0dXJuIGxpbmVTdHJpbmcoY29vcmRzLCBwcm9wZXJ0aWVzKTtcbiAgfSksIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBUYWtlcyBvbmUgb3IgbW9yZSB7QGxpbmsgRmVhdHVyZXxGZWF0dXJlc30gYW5kIGNyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259LlxuICpcbiAqIEBuYW1lIGZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0ZlYXR1cmVbXX0gZmVhdHVyZXMgaW5wdXQgZmVhdHVyZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9ufSBGZWF0dXJlQ29sbGVjdGlvbiBvZiBGZWF0dXJlc1xuICogQGV4YW1wbGVcbiAqIHZhciBsb2NhdGlvbkEgPSB0dXJmLnBvaW50KFstNzUuMzQzLCAzOS45ODRdLCB7bmFtZTogJ0xvY2F0aW9uIEEnfSk7XG4gKiB2YXIgbG9jYXRpb25CID0gdHVyZi5wb2ludChbLTc1LjgzMywgMzkuMjg0XSwge25hbWU6ICdMb2NhdGlvbiBCJ30pO1xuICogdmFyIGxvY2F0aW9uQyA9IHR1cmYucG9pbnQoWy03NS41MzQsIDM5LjEyM10sIHtuYW1lOiAnTG9jYXRpb24gQyd9KTtcbiAqXG4gKiB2YXIgY29sbGVjdGlvbiA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICBsb2NhdGlvbkEsXG4gKiAgIGxvY2F0aW9uQixcbiAqICAgbG9jYXRpb25DXG4gKiBdKTtcbiAqXG4gKiAvLz1jb2xsZWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmZWF0dXJlQ29sbGVjdGlvbihmZWF0dXJlcywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHZhciBmYyA9IHtcbiAgICB0eXBlOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCJcbiAgfTtcbiAgaWYgKG9wdGlvbnMuaWQpIHtcbiAgICBmYy5pZCA9IG9wdGlvbnMuaWQ7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYmJveCkge1xuICAgIGZjLmJib3ggPSBvcHRpb25zLmJib3g7XG4gIH1cbiAgZmMuZmVhdHVyZXMgPSBmZWF0dXJlcztcbiAgcmV0dXJuIGZjO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8TXVsdGlMaW5lU3RyaW5nPn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBtdWx0aUxpbmVTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBMaW5lU3RyaW5nc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPE11bHRpTGluZVN0cmluZz59IGEgTXVsdGlMaW5lU3RyaW5nIGZlYXR1cmVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBjb29yZGluYXRlcyBhcmUgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpTGluZSA9IHR1cmYubXVsdGlMaW5lU3RyaW5nKFtbWzAsMF0sWzEwLDEwXV1dKTtcbiAqXG4gKiAvLz1tdWx0aUxpbmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpTGluZVN0cmluZyhjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHZhciBnZW9tID0ge1xuICAgIHR5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsXG4gICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzXG4gIH07XG4gIHJldHVybiBmZWF0dXJlKGdlb20sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8TXVsdGlQb2ludD59IGJhc2VkIG9uIGFcbiAqIGNvb3JkaW5hdGUgYXJyYXkuIFByb3BlcnRpZXMgY2FuIGJlIGFkZGVkIG9wdGlvbmFsbHkuXG4gKlxuICogQG5hbWUgbXVsdGlQb2ludFxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9zaXRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmU8TXVsdGlQb2ludD59IGEgTXVsdGlQb2ludCBmZWF0dXJlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gY29vcmRpbmF0ZXMgYXJlIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aVB0ID0gdHVyZi5tdWx0aVBvaW50KFtbMCwwXSxbMTAsMTBdXSk7XG4gKlxuICogLy89bXVsdGlQdFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlQb2ludChjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHZhciBnZW9tID0ge1xuICAgIHR5cGU6IFwiTXVsdGlQb2ludFwiLFxuICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICB9O1xuICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBGZWF0dXJlPE11bHRpUG9seWdvbj59IGJhc2VkIG9uIGFcbiAqIGNvb3JkaW5hdGUgYXJyYXkuIFByb3BlcnRpZXMgY2FuIGJlIGFkZGVkIG9wdGlvbmFsbHkuXG4gKlxuICogQG5hbWUgbXVsdGlQb2x5Z29uXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEFycmF5PEFycmF5PG51bWJlcj4+Pj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIFBvbHlnb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmU8TXVsdGlQb2x5Z29uPn0gYSBtdWx0aXBvbHlnb24gZmVhdHVyZVxuICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGNvb3JkaW5hdGVzIGFyZSBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKiB2YXIgbXVsdGlQb2x5ID0gdHVyZi5tdWx0aVBvbHlnb24oW1tbWzAsMF0sWzAsMTBdLFsxMCwxMF0sWzEwLDBdLFswLDBdXV1dKTtcbiAqXG4gKiAvLz1tdWx0aVBvbHlcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aVBvbHlnb24oY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICB2YXIgZ2VvbSA9IHtcbiAgICB0eXBlOiBcIk11bHRpUG9seWdvblwiLFxuICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICB9O1xuICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBGZWF0dXJlPEdlb21ldHJ5Q29sbGVjdGlvbj59IGJhc2VkIG9uIGFcbiAqIGNvb3JkaW5hdGUgYXJyYXkuIFByb3BlcnRpZXMgY2FuIGJlIGFkZGVkIG9wdGlvbmFsbHkuXG4gKlxuICogQG5hbWUgZ2VvbWV0cnlDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PEdlb21ldHJ5Pn0gZ2VvbWV0cmllcyBhbiBhcnJheSBvZiBHZW9KU09OIEdlb21ldHJpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxHZW9tZXRyeUNvbGxlY3Rpb24+fSBhIEdlb0pTT04gR2VvbWV0cnlDb2xsZWN0aW9uIEZlYXR1cmVcbiAqIEBleGFtcGxlXG4gKiB2YXIgcHQgPSB0dXJmLmdlb21ldHJ5KFwiUG9pbnRcIiwgWzEwMCwgMF0pO1xuICogdmFyIGxpbmUgPSB0dXJmLmdlb21ldHJ5KFwiTGluZVN0cmluZ1wiLCBbWzEwMSwgMF0sIFsxMDIsIDFdXSk7XG4gKiB2YXIgY29sbGVjdGlvbiA9IHR1cmYuZ2VvbWV0cnlDb2xsZWN0aW9uKFtwdCwgbGluZV0pO1xuICpcbiAqIC8vID0+IGNvbGxlY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyaWVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgdmFyIGdlb20gPSB7XG4gICAgdHlwZTogXCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcbiAgICBnZW9tZXRyaWVzOiBnZW9tZXRyaWVzXG4gIH07XG4gIHJldHVybiBmZWF0dXJlKGdlb20sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBSb3VuZCBudW1iZXIgdG8gcHJlY2lzaW9uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBOdW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFByZWNpc2lvblxuICogQHJldHVybnMge251bWJlcn0gcm91bmRlZCBudW1iZXJcbiAqIEBleGFtcGxlXG4gKiB0dXJmLnJvdW5kKDEyMC40MzIxKVxuICogLy89MTIwXG4gKlxuICogdHVyZi5yb3VuZCgxMjAuNDMyMSwgMilcbiAqIC8vPTEyMC40M1xuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmQobnVtLCBwcmVjaXNpb24pIHtcbiAgaWYgKHByZWNpc2lvbiA9PT0gdm9pZCAwKSB7XG4gICAgcHJlY2lzaW9uID0gMDtcbiAgfVxuICBpZiAocHJlY2lzaW9uICYmICEocHJlY2lzaW9uID49IDApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicHJlY2lzaW9uIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gIH1cbiAgdmFyIG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uIHx8IDApO1xuICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiBtdWx0aXBsaWVyKSAvIG11bHRpcGxpZXI7XG59XG4vKipcbiAqIENvbnZlcnQgYSBkaXN0YW5jZSBtZWFzdXJlbWVudCAoYXNzdW1pbmcgYSBzcGhlcmljYWwgRWFydGgpIGZyb20gcmFkaWFucyB0byBhIG1vcmUgZnJpZW5kbHkgdW5pdC5cbiAqIFZhbGlkIHVuaXRzOiBtaWxlcywgbmF1dGljYWxtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0ZXJzLCBtZXRyZXMsIGtpbG9tZXRlcnMsIGNlbnRpbWV0ZXJzLCBmZWV0XG4gKlxuICogQG5hbWUgcmFkaWFuc1RvTGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFucyBpbiByYWRpYW5zIGFjcm9zcyB0aGUgc3BoZXJlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VuaXRzPVwia2lsb21ldGVyc1wiXSBjYW4gYmUgZGVncmVlcywgcmFkaWFucywgbWlsZXMsIGluY2hlcywgeWFyZHMsIG1ldHJlcyxcbiAqIG1ldGVycywga2lsb21ldHJlcywga2lsb21ldGVycy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRpc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYWRpYW5zVG9MZW5ndGgocmFkaWFucywgdW5pdHMpIHtcbiAgaWYgKHVuaXRzID09PSB2b2lkIDApIHtcbiAgICB1bml0cyA9IFwia2lsb21ldGVyc1wiO1xuICB9XG4gIHZhciBmYWN0b3IgPSBmYWN0b3JzW3VuaXRzXTtcbiAgaWYgKCFmYWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodW5pdHMgKyBcIiB1bml0cyBpcyBpbnZhbGlkXCIpO1xuICB9XG4gIHJldHVybiByYWRpYW5zICogZmFjdG9yO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgZGlzdGFuY2UgbWVhc3VyZW1lbnQgKGFzc3VtaW5nIGEgc3BoZXJpY2FsIEVhcnRoKSBmcm9tIGEgcmVhbC13b3JsZCB1bml0IGludG8gcmFkaWFuc1xuICogVmFsaWQgdW5pdHM6IG1pbGVzLCBuYXV0aWNhbG1pbGVzLCBpbmNoZXMsIHlhcmRzLCBtZXRlcnMsIG1ldHJlcywga2lsb21ldGVycywgY2VudGltZXRlcnMsIGZlZXRcbiAqXG4gKiBAbmFtZSBsZW5ndGhUb1JhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSBpbiByZWFsIHVuaXRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VuaXRzPVwia2lsb21ldGVyc1wiXSBjYW4gYmUgZGVncmVlcywgcmFkaWFucywgbWlsZXMsIGluY2hlcywgeWFyZHMsIG1ldHJlcyxcbiAqIG1ldGVycywga2lsb21ldHJlcywga2lsb21ldGVycy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IHJhZGlhbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aFRvUmFkaWFucyhkaXN0YW5jZSwgdW5pdHMpIHtcbiAgaWYgKHVuaXRzID09PSB2b2lkIDApIHtcbiAgICB1bml0cyA9IFwia2lsb21ldGVyc1wiO1xuICB9XG4gIHZhciBmYWN0b3IgPSBmYWN0b3JzW3VuaXRzXTtcbiAgaWYgKCFmYWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodW5pdHMgKyBcIiB1bml0cyBpcyBpbnZhbGlkXCIpO1xuICB9XG4gIHJldHVybiBkaXN0YW5jZSAvIGZhY3Rvcjtcbn1cbi8qKlxuICogQ29udmVydCBhIGRpc3RhbmNlIG1lYXN1cmVtZW50IChhc3N1bWluZyBhIHNwaGVyaWNhbCBFYXJ0aCkgZnJvbSBhIHJlYWwtd29ybGQgdW5pdCBpbnRvIGRlZ3JlZXNcbiAqIFZhbGlkIHVuaXRzOiBtaWxlcywgbmF1dGljYWxtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0ZXJzLCBtZXRyZXMsIGNlbnRpbWV0ZXJzLCBraWxvbWV0cmVzLCBmZWV0XG4gKlxuICogQG5hbWUgbGVuZ3RoVG9EZWdyZWVzXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgaW4gcmVhbCB1bml0c1xuICogQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1cImtpbG9tZXRlcnNcIl0gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBpbmNoZXMsIHlhcmRzLCBtZXRyZXMsXG4gKiBtZXRlcnMsIGtpbG9tZXRyZXMsIGtpbG9tZXRlcnMuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkZWdyZWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGhUb0RlZ3JlZXMoZGlzdGFuY2UsIHVuaXRzKSB7XG4gIHJldHVybiByYWRpYW5zVG9EZWdyZWVzKGxlbmd0aFRvUmFkaWFucyhkaXN0YW5jZSwgdW5pdHMpKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW55IGJlYXJpbmcgYW5nbGUgZnJvbSB0aGUgbm9ydGggbGluZSBkaXJlY3Rpb24gKHBvc2l0aXZlIGNsb2Nrd2lzZSlcbiAqIGFuZCByZXR1cm5zIGFuIGFuZ2xlIGJldHdlZW4gMC0zNjAgZGVncmVlcyAocG9zaXRpdmUgY2xvY2t3aXNlKSwgMCBiZWluZyB0aGUgbm9ydGggbGluZVxuICpcbiAqIEBuYW1lIGJlYXJpbmdUb0F6aW11dGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBiZWFyaW5nIGFuZ2xlLCBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlc1xuICogQHJldHVybnMge251bWJlcn0gYW5nbGUgYmV0d2VlbiAwIGFuZCAzNjAgZGVncmVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYmVhcmluZ1RvQXppbXV0aChiZWFyaW5nKSB7XG4gIHZhciBhbmdsZSA9IGJlYXJpbmcgJSAzNjA7XG4gIGlmIChhbmdsZSA8IDApIHtcbiAgICBhbmdsZSArPSAzNjA7XG4gIH1cbiAgcmV0dXJuIGFuZ2xlO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhbmdsZSBpbiByYWRpYW5zIHRvIGRlZ3JlZXNcbiAqXG4gKiBAbmFtZSByYWRpYW5zVG9EZWdyZWVzXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFucyBhbmdsZSBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkZWdyZWVzIGJldHdlZW4gMCBhbmQgMzYwIGRlZ3JlZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhZGlhbnNUb0RlZ3JlZXMocmFkaWFucykge1xuICB2YXIgZGVncmVlcyA9IHJhZGlhbnMgJSAoMiAqIE1hdGguUEkpO1xuICByZXR1cm4gZGVncmVlcyAqIDE4MCAvIE1hdGguUEk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIGFuZ2xlIGluIGRlZ3JlZXMgdG8gcmFkaWFuc1xuICpcbiAqIEBuYW1lIGRlZ3JlZXNUb1JhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWdyZWVzIGFuZ2xlIGJldHdlZW4gMCBhbmQgMzYwIGRlZ3JlZXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZ3JlZXNUb1JhZGlhbnMoZGVncmVlcykge1xuICB2YXIgcmFkaWFucyA9IGRlZ3JlZXMgJSAzNjA7XG4gIHJldHVybiByYWRpYW5zICogTWF0aC5QSSAvIDE4MDtcbn1cbi8qKlxuICogQ29udmVydHMgYSBsZW5ndGggdG8gdGhlIHJlcXVlc3RlZCB1bml0LlxuICogVmFsaWQgdW5pdHM6IG1pbGVzLCBuYXV0aWNhbG1pbGVzLCBpbmNoZXMsIHlhcmRzLCBtZXRlcnMsIG1ldHJlcywga2lsb21ldGVycywgY2VudGltZXRlcnMsIGZlZXRcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIHRvIGJlIGNvbnZlcnRlZFxuICogQHBhcmFtIHtVbml0c30gW29yaWdpbmFsVW5pdD1cImtpbG9tZXRlcnNcIl0gb2YgdGhlIGxlbmd0aFxuICogQHBhcmFtIHtVbml0c30gW2ZpbmFsVW5pdD1cImtpbG9tZXRlcnNcIl0gcmV0dXJuZWQgdW5pdFxuICogQHJldHVybnMge251bWJlcn0gdGhlIGNvbnZlcnRlZCBsZW5ndGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRMZW5ndGgobGVuZ3RoLCBvcmlnaW5hbFVuaXQsIGZpbmFsVW5pdCkge1xuICBpZiAob3JpZ2luYWxVbml0ID09PSB2b2lkIDApIHtcbiAgICBvcmlnaW5hbFVuaXQgPSBcImtpbG9tZXRlcnNcIjtcbiAgfVxuICBpZiAoZmluYWxVbml0ID09PSB2b2lkIDApIHtcbiAgICBmaW5hbFVuaXQgPSBcImtpbG9tZXRlcnNcIjtcbiAgfVxuICBpZiAoIShsZW5ndGggPj0gMCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgfVxuICByZXR1cm4gcmFkaWFuc1RvTGVuZ3RoKGxlbmd0aFRvUmFkaWFucyhsZW5ndGgsIG9yaWdpbmFsVW5pdCksIGZpbmFsVW5pdCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgYXJlYSB0byB0aGUgcmVxdWVzdGVkIHVuaXQuXG4gKiBWYWxpZCB1bml0czoga2lsb21ldGVycywga2lsb21ldHJlcywgbWV0ZXJzLCBtZXRyZXMsIGNlbnRpbWV0cmVzLCBtaWxsaW1ldGVycywgYWNyZXMsIG1pbGVzLCB5YXJkcywgZmVldCwgaW5jaGVzLCBoZWN0YXJlc1xuICogQHBhcmFtIHtudW1iZXJ9IGFyZWEgdG8gYmUgY29udmVydGVkXG4gKiBAcGFyYW0ge1VuaXRzfSBbb3JpZ2luYWxVbml0PVwibWV0ZXJzXCJdIG9mIHRoZSBkaXN0YW5jZVxuICogQHBhcmFtIHtVbml0c30gW2ZpbmFsVW5pdD1cImtpbG9tZXRlcnNcIl0gcmV0dXJuZWQgdW5pdFxuICogQHJldHVybnMge251bWJlcn0gdGhlIGNvbnZlcnRlZCBhcmVhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0QXJlYShhcmVhLCBvcmlnaW5hbFVuaXQsIGZpbmFsVW5pdCkge1xuICBpZiAob3JpZ2luYWxVbml0ID09PSB2b2lkIDApIHtcbiAgICBvcmlnaW5hbFVuaXQgPSBcIm1ldGVyc1wiO1xuICB9XG4gIGlmIChmaW5hbFVuaXQgPT09IHZvaWQgMCkge1xuICAgIGZpbmFsVW5pdCA9IFwia2lsb21ldGVyc1wiO1xuICB9XG4gIGlmICghKGFyZWEgPj0gMCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcmVhIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gIH1cbiAgdmFyIHN0YXJ0RmFjdG9yID0gYXJlYUZhY3RvcnNbb3JpZ2luYWxVbml0XTtcbiAgaWYgKCFzdGFydEZhY3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgb3JpZ2luYWwgdW5pdHNcIik7XG4gIH1cbiAgdmFyIGZpbmFsRmFjdG9yID0gYXJlYUZhY3RvcnNbZmluYWxVbml0XTtcbiAgaWYgKCFmaW5hbEZhY3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmluYWwgdW5pdHNcIik7XG4gIH1cbiAgcmV0dXJuIGFyZWEgLyBzdGFydEZhY3RvciAqIGZpbmFsRmFjdG9yO1xufVxuLyoqXG4gKiBpc051bWJlclxuICpcbiAqIEBwYXJhbSB7Kn0gbnVtIE51bWJlciB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUvZmFsc2VcbiAqIEBleGFtcGxlXG4gKiB0dXJmLmlzTnVtYmVyKDEyMylcbiAqIC8vPXRydWVcbiAqIHR1cmYuaXNOdW1iZXIoJ2ZvbycpXG4gKiAvLz1mYWxzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIobnVtKSB7XG4gIHJldHVybiAhaXNOYU4obnVtKSAmJiBudW0gIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkobnVtKTtcbn1cbi8qKlxuICogaXNPYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IGlucHV0IHZhcmlhYmxlIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZS9mYWxzZVxuICogQGV4YW1wbGVcbiAqIHR1cmYuaXNPYmplY3Qoe2VsZXZhdGlvbjogMTB9KVxuICogLy89dHJ1ZVxuICogdHVyZi5pc09iamVjdCgnZm9vJylcbiAqIC8vPWZhbHNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICByZXR1cm4gISFpbnB1dCAmJiBpbnB1dC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufVxuLyoqXG4gKiBWYWxpZGF0ZSBCQm94XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYmJveCBCQm94IHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEB0aHJvd3MgRXJyb3IgaWYgQkJveCBpcyBub3QgdmFsaWRcbiAqIEBleGFtcGxlXG4gKiB2YWxpZGF0ZUJCb3goWy0xODAsIC00MCwgMTEwLCA1MF0pXG4gKiAvLz1PS1xuICogdmFsaWRhdGVCQm94KFstMTgwLCAtNDBdKVxuICogLy89RXJyb3JcbiAqIHZhbGlkYXRlQkJveCgnRm9vJylcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUJCb3goNSlcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUJCb3gobnVsbClcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUJCb3godW5kZWZpbmVkKVxuICogLy89RXJyb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQkJveChiYm94KSB7XG4gIGlmICghYmJveCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImJib3ggaXMgcmVxdWlyZWRcIik7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGJib3gpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmJveCBtdXN0IGJlIGFuIEFycmF5XCIpO1xuICB9XG4gIGlmIChiYm94Lmxlbmd0aCAhPT0gNCAmJiBiYm94Lmxlbmd0aCAhPT0gNikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImJib3ggbXVzdCBiZSBhbiBBcnJheSBvZiA0IG9yIDYgbnVtYmVyc1wiKTtcbiAgfVxuICBiYm94LmZvckVhY2goZnVuY3Rpb24gKG51bSkge1xuICAgIGlmICghaXNOdW1iZXIobnVtKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmJveCBtdXN0IG9ubHkgY29udGFpbiBudW1iZXJzXCIpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIFZhbGlkYXRlIElkXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gaWQgSWQgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHRocm93cyBFcnJvciBpZiBJZCBpcyBub3QgdmFsaWRcbiAqIEBleGFtcGxlXG4gKiB2YWxpZGF0ZUlkKFstMTgwLCAtNDAsIDExMCwgNTBdKVxuICogLy89RXJyb3JcbiAqIHZhbGlkYXRlSWQoWy0xODAsIC00MF0pXG4gKiAvLz1FcnJvclxuICogdmFsaWRhdGVJZCgnRm9vJylcbiAqIC8vPU9LXG4gKiB2YWxpZGF0ZUlkKDUpXG4gKiAvLz1PS1xuICogdmFsaWRhdGVJZChudWxsKVxuICogLy89RXJyb3JcbiAqIHZhbGlkYXRlSWQodW5kZWZpbmVkKVxuICogLy89RXJyb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlSWQoaWQpIHtcbiAgaWYgKCFpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImlkIGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIGlmIChbXCJzdHJpbmdcIiwgXCJudW1iZXJcIl0uaW5kZXhPZih0eXBlb2YgaWQpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImlkIG11c3QgYmUgYSBudW1iZXIgb3IgYSBzdHJpbmdcIik7XG4gIH1cbn0iLCJpbXBvcnQgeyBmZWF0dXJlLCBsaW5lU3RyaW5nLCBpc09iamVjdCwgcG9pbnQgfSBmcm9tICdAdHVyZi9oZWxwZXJzJztcblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgY29vcmRFYWNoXG4gKlxuICogQGNhbGxiYWNrIGNvb3JkRWFjaENhbGxiYWNrXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGN1cnJlbnRDb29yZCBUaGUgY3VycmVudCBjb29yZGluYXRlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb29yZEluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBjb29yZGluYXRlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBnZW9tZXRyeUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBHZW9tZXRyeSBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgY29vcmRpbmF0ZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LmZvckVhY2goKVxuICpcbiAqIEBuYW1lIGNvb3JkRWFjaFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudENvb3JkLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KVxuICogQHBhcmFtIHtib29sZWFufSBbZXhjbHVkZVdyYXBDb29yZD1mYWxzZV0gd2hldGhlciBvciBub3QgdG8gaW5jbHVkZSB0aGUgZmluYWwgY29vcmRpbmF0ZSBvZiBMaW5lYXJSaW5ncyB0aGF0IHdyYXBzIHRoZSByaW5nIGluIGl0cyBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgdHVyZi5wb2ludChbMjYsIDM3XSwge1wiZm9vXCI6IFwiYmFyXCJ9KSxcbiAqICAgdHVyZi5wb2ludChbMzYsIDUzXSwge1wiaGVsbG9cIjogXCJ3b3JsZFwifSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuY29vcmRFYWNoKGZlYXR1cmVzLCBmdW5jdGlvbiAoY3VycmVudENvb3JkLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSB7XG4gKiAgIC8vPWN1cnJlbnRDb29yZFxuICogICAvLz1jb29yZEluZGV4XG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1tdWx0aUZlYXR1cmVJbmRleFxuICogICAvLz1nZW9tZXRyeUluZGV4XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gY29vcmRFYWNoKGdlb2pzb24sIGNhbGxiYWNrLCBleGNsdWRlV3JhcENvb3JkKSB7XG4gIC8vIEhhbmRsZXMgbnVsbCBHZW9tZXRyeSAtLSBTa2lwcyB0aGlzIEdlb0pTT05cbiAgaWYgKGdlb2pzb24gPT09IG51bGwpIHJldHVybjtcbiAgdmFyIGosXG4gICAgayxcbiAgICBsLFxuICAgIGdlb21ldHJ5LFxuICAgIHN0b3BHLFxuICAgIGNvb3JkcyxcbiAgICBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbixcbiAgICB3cmFwU2hyaW5rID0gMCxcbiAgICBjb29yZEluZGV4ID0gMCxcbiAgICBpc0dlb21ldHJ5Q29sbGVjdGlvbixcbiAgICB0eXBlID0gZ2VvanNvbi50eXBlLFxuICAgIGlzRmVhdHVyZUNvbGxlY3Rpb24gPSB0eXBlID09PSBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gICAgaXNGZWF0dXJlID0gdHlwZSA9PT0gXCJGZWF0dXJlXCIsXG4gICAgc3RvcCA9IGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aCA6IDE7XG5cbiAgLy8gVGhpcyBsb2dpYyBtYXkgbG9vayBhIGxpdHRsZSB3ZWlyZC4gVGhlIHJlYXNvbiB3aHkgaXQgaXMgdGhhdCB3YXlcbiAgLy8gaXMgYmVjYXVzZSBpdCdzIHRyeWluZyB0byBiZSBmYXN0LiBHZW9KU09OIHN1cHBvcnRzIG11bHRpcGxlIGtpbmRzXG4gIC8vIG9mIG9iamVjdHMgYXQgaXRzIHJvb3Q6IEZlYXR1cmVDb2xsZWN0aW9uLCBGZWF0dXJlcywgR2VvbWV0cmllcy5cbiAgLy8gVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIGhhbmRsaW5nIGFsbCBvZiB0aGVtLCBhbmQgdGhhdFxuICAvLyBtZWFucyB0aGF0IHNvbWUgb2YgdGhlIGBmb3JgIGxvb3BzIHlvdSBzZWUgYmVsb3cgYWN0dWFsbHkganVzdCBkb24ndCBhcHBseVxuICAvLyB0byBjZXJ0YWluIGlucHV0cy4gRm9yIGluc3RhbmNlLCBpZiB5b3UgZ2l2ZSB0aGlzIGp1c3QgYVxuICAvLyBQb2ludCBnZW9tZXRyeSwgdGhlbiBib3RoIGxvb3BzIGFyZSBzaG9ydC1jaXJjdWl0ZWQgYW5kIGFsbCB3ZSBkb1xuICAvLyBpcyBncmFkdWFsbHkgcmVuYW1lIHRoZSBpbnB1dCB1bnRpbCBpdCdzIGNhbGxlZCAnZ2VvbWV0cnknLlxuICAvL1xuICAvLyBUaGlzIGFsc28gYWltcyB0byBhbGxvY2F0ZSBhcyBmZXcgcmVzb3VyY2VzIGFzIHBvc3NpYmxlOiBqdXN0IGFcbiAgLy8gZmV3IG51bWJlcnMgYW5kIGJvb2xlYW5zLCByYXRoZXIgdGhhbiBhbnkgdGVtcG9yYXJ5IGFycmF5cyBhcyB3b3VsZFxuICAvLyBiZSByZXF1aXJlZCB3aXRoIHRoZSBub3JtYWxpemF0aW9uIGFwcHJvYWNoLlxuICBmb3IgKHZhciBmZWF0dXJlSW5kZXggPSAwOyBmZWF0dXJlSW5kZXggPCBzdG9wOyBmZWF0dXJlSW5kZXgrKykge1xuICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uID0gaXNGZWF0dXJlQ29sbGVjdGlvbiA/IGdlb2pzb24uZmVhdHVyZXNbZmVhdHVyZUluZGV4XS5nZW9tZXRyeSA6IGlzRmVhdHVyZSA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uO1xuICAgIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24gPyBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiIDogZmFsc2U7XG4gICAgc3RvcEcgPSBpc0dlb21ldHJ5Q29sbGVjdGlvbiA/IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLmdlb21ldHJpZXMubGVuZ3RoIDogMTtcbiAgICBmb3IgKHZhciBnZW9tSW5kZXggPSAwOyBnZW9tSW5kZXggPCBzdG9wRzsgZ2VvbUluZGV4KyspIHtcbiAgICAgIHZhciBtdWx0aUZlYXR1cmVJbmRleCA9IDA7XG4gICAgICB2YXIgZ2VvbWV0cnlJbmRleCA9IDA7XG4gICAgICBnZW9tZXRyeSA9IGlzR2VvbWV0cnlDb2xsZWN0aW9uID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllc1tnZW9tSW5kZXhdIDogZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb247XG5cbiAgICAgIC8vIEhhbmRsZXMgbnVsbCBHZW9tZXRyeSAtLSBTa2lwcyB0aGlzIGdlb21ldHJ5XG4gICAgICBpZiAoZ2VvbWV0cnkgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgY29vcmRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICB2YXIgZ2VvbVR5cGUgPSBnZW9tZXRyeS50eXBlO1xuICAgICAgd3JhcFNocmluayA9IGV4Y2x1ZGVXcmFwQ29vcmQgJiYgKGdlb21UeXBlID09PSBcIlBvbHlnb25cIiB8fCBnZW9tVHlwZSA9PT0gXCJNdWx0aVBvbHlnb25cIikgPyAxIDogMDtcbiAgICAgIHN3aXRjaCAoZ2VvbVR5cGUpIHtcbiAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICAgICAgICBpZiAoY2FsbGJhY2soY29vcmRzLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBjb29yZEluZGV4Kys7XG4gICAgICAgICAgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjpcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2soY29vcmRzW2pdLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNvb3JkSW5kZXgrKztcbiAgICAgICAgICAgIGlmIChnZW9tVHlwZSA9PT0gXCJNdWx0aVBvaW50XCIpIG11bHRpRmVhdHVyZUluZGV4Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChnZW9tVHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIpIG11bHRpRmVhdHVyZUluZGV4Kys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjpcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgY29vcmRzW2pdLmxlbmd0aCAtIHdyYXBTaHJpbms7IGsrKykge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2soY29vcmRzW2pdW2tdLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgY29vcmRJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdlb21UeXBlID09PSBcIk11bHRpTGluZVN0cmluZ1wiKSBtdWx0aUZlYXR1cmVJbmRleCsrO1xuICAgICAgICAgICAgaWYgKGdlb21UeXBlID09PSBcIlBvbHlnb25cIikgZ2VvbWV0cnlJbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZ2VvbVR5cGUgPT09IFwiUG9seWdvblwiKSBtdWx0aUZlYXR1cmVJbmRleCsrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZ2VvbWV0cnlJbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgY29vcmRzW2pdLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgIGZvciAobCA9IDA7IGwgPCBjb29yZHNbal1ba10ubGVuZ3RoIC0gd3JhcFNocmluazsgbCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGNvb3Jkc1tqXVtrXVtsXSwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29vcmRJbmRleCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGdlb21ldHJ5SW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG11bHRpRmVhdHVyZUluZGV4Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBqKyspIGlmIChjb29yZEVhY2goZ2VvbWV0cnkuZ2VvbWV0cmllc1tqXSwgY2FsbGJhY2ssIGV4Y2x1ZGVXcmFwQ29vcmQpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gR2VvbWV0cnkgVHlwZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgY29vcmRSZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBjb29yZFJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjdXJyZW50Q29vcmQgVGhlIGN1cnJlbnQgY29vcmRpbmF0ZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gY29vcmRJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgY29vcmRpbmF0ZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBTdGFydHMgYXQgaW5kZXggMCwgaWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkLCBhbmQgYXQgaW5kZXggMSBvdGhlcndpc2UuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aUZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgTXVsdGktRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZ2VvbWV0cnlJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgR2VvbWV0cnkgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogUmVkdWNlIGNvb3JkaW5hdGVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5yZWR1Y2UoKVxuICpcbiAqIEBuYW1lIGNvb3JkUmVkdWNlXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEdlb21ldHJ5fEZlYXR1cmV9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50Q29vcmQsIGNvb3JkSW5kZXgpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHBhcmFtIHtib29sZWFufSBbZXhjbHVkZVdyYXBDb29yZD1mYWxzZV0gd2hldGhlciBvciBub3QgdG8gaW5jbHVkZSB0aGUgZmluYWwgY29vcmRpbmF0ZSBvZiBMaW5lYXJSaW5ncyB0aGF0IHdyYXBzIHRoZSByaW5nIGluIGl0cyBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHRoZSByZWR1Y3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtcImZvb1wiOiBcImJhclwifSksXG4gKiAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtcImhlbGxvXCI6IFwid29ybGRcIn0pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLmNvb3JkUmVkdWNlKGZlYXR1cmVzLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudENvb3JkLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSB7XG4gKiAgIC8vPXByZXZpb3VzVmFsdWVcbiAqICAgLy89Y3VycmVudENvb3JkXG4gKiAgIC8vPWNvb3JkSW5kZXhcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPW11bHRpRmVhdHVyZUluZGV4XG4gKiAgIC8vPWdlb21ldHJ5SW5kZXhcbiAqICAgcmV0dXJuIGN1cnJlbnRDb29yZDtcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBjb29yZFJlZHVjZShnZW9qc29uLCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlLCBleGNsdWRlV3JhcENvb3JkKSB7XG4gIHZhciBwcmV2aW91c1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBjb29yZEVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGN1cnJlbnRDb29yZCwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICAgIGlmIChjb29yZEluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudENvb3JkO2Vsc2UgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRDb29yZCwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCk7XG4gIH0sIGV4Y2x1ZGVXcmFwQ29vcmQpO1xuICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgcHJvcEVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgcHJvcEVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IGN1cnJlbnRQcm9wZXJ0aWVzIFRoZSBjdXJyZW50IFByb3BlcnRpZXMgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgcHJvcGVydGllcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkuZm9yRWFjaCgpXG4gKlxuICogQG5hbWUgcHJvcEVhY2hcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRQcm9wZXJ0aWVzLCBmZWF0dXJlSW5kZXgpXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtoZWxsbzogJ3dvcmxkJ30pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLnByb3BFYWNoKGZlYXR1cmVzLCBmdW5jdGlvbiAoY3VycmVudFByb3BlcnRpZXMsIGZlYXR1cmVJbmRleCkge1xuICogICAvLz1jdXJyZW50UHJvcGVydGllc1xuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBwcm9wRWFjaChnZW9qc29uLCBjYWxsYmFjaykge1xuICB2YXIgaTtcbiAgc3dpdGNoIChnZW9qc29uLnR5cGUpIHtcbiAgICBjYXNlIFwiRmVhdHVyZUNvbGxlY3Rpb25cIjpcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhnZW9qc29uLmZlYXR1cmVzW2ldLnByb3BlcnRpZXMsIGkpID09PSBmYWxzZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiRmVhdHVyZVwiOlxuICAgICAgY2FsbGJhY2soZ2VvanNvbi5wcm9wZXJ0aWVzLCAwKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIHByb3BSZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBwcm9wUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0geyp9IGN1cnJlbnRQcm9wZXJ0aWVzIFRoZSBjdXJyZW50IFByb3BlcnRpZXMgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgcHJvcGVydGllcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QgaW50byBhIHNpbmdsZSB2YWx1ZSxcbiAqIHNpbWlsYXIgdG8gaG93IEFycmF5LnJlZHVjZSB3b3Jrcy4gSG93ZXZlciwgaW4gdGhpcyBjYXNlIHdlIGxhemlseSBydW5cbiAqIHRoZSByZWR1Y3Rpb24sIHNvIGFuIGFycmF5IG9mIGFsbCBwcm9wZXJ0aWVzIGlzIHVubmVjZXNzYXJ5LlxuICpcbiAqIEBuYW1lIHByb3BSZWR1Y2VcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRQcm9wZXJ0aWVzLCBmZWF0dXJlSW5kZXgpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtmb286ICdiYXInfSksXG4gKiAgICAgdHVyZi5wb2ludChbMzYsIDUzXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYucHJvcFJlZHVjZShmZWF0dXJlcywgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRQcm9wZXJ0aWVzLCBmZWF0dXJlSW5kZXgpIHtcbiAqICAgLy89cHJldmlvdXNWYWx1ZVxuICogICAvLz1jdXJyZW50UHJvcGVydGllc1xuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgcmV0dXJuIGN1cnJlbnRQcm9wZXJ0aWVzXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gcHJvcFJlZHVjZShnZW9qc29uLCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBwcmV2aW91c1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBwcm9wRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY3VycmVudFByb3BlcnRpZXMsIGZlYXR1cmVJbmRleCkge1xuICAgIGlmIChmZWF0dXJlSW5kZXggPT09IDAgJiYgaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQpIHByZXZpb3VzVmFsdWUgPSBjdXJyZW50UHJvcGVydGllcztlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50UHJvcGVydGllcywgZmVhdHVyZUluZGV4KTtcbiAgfSk7XG4gIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBmZWF0dXJlRWFjaFxuICpcbiAqIEBjYWxsYmFjayBmZWF0dXJlRWFjaENhbGxiYWNrXG4gKiBAcGFyYW0ge0ZlYXR1cmU8YW55Pn0gY3VycmVudEZlYXR1cmUgVGhlIGN1cnJlbnQgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBmZWF0dXJlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG9cbiAqIEFycmF5LmZvckVhY2guXG4gKlxuICogQG5hbWUgZmVhdHVyZUVhY2hcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgpXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgdHVyZi5wb2ludChbMzYsIDUzXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuZmVhdHVyZUVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4KSB7XG4gKiAgIC8vPWN1cnJlbnRGZWF0dXJlXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGZlYXR1cmVFYWNoKGdlb2pzb24sIGNhbGxiYWNrKSB7XG4gIGlmIChnZW9qc29uLnR5cGUgPT09IFwiRmVhdHVyZVwiKSB7XG4gICAgY2FsbGJhY2soZ2VvanNvbiwgMCk7XG4gIH0gZWxzZSBpZiAoZ2VvanNvbi50eXBlID09PSBcIkZlYXR1cmVDb2xsZWN0aW9uXCIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb2pzb24uZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjYWxsYmFjayhnZW9qc29uLmZlYXR1cmVzW2ldLCBpKSA9PT0gZmFsc2UpIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBmZWF0dXJlUmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgZmVhdHVyZVJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtGZWF0dXJlfSBjdXJyZW50RmVhdHVyZSBUaGUgY3VycmVudCBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogUmVkdWNlIGZlYXR1cmVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5yZWR1Y2UoKS5cbiAqXG4gKiBAbmFtZSBmZWF0dXJlUmVkdWNlXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4KVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgdGhhdCByZXN1bHRzIGZyb20gdGhlIHJlZHVjdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgdHVyZi5wb2ludChbMjYsIDM3XSwge1wiZm9vXCI6IFwiYmFyXCJ9KSxcbiAqICAgdHVyZi5wb2ludChbMzYsIDUzXSwge1wiaGVsbG9cIjogXCJ3b3JsZFwifSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuZmVhdHVyZVJlZHVjZShmZWF0dXJlcywgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgpIHtcbiAqICAgLy89cHJldmlvdXNWYWx1ZVxuICogICAvLz1jdXJyZW50RmVhdHVyZVxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgcmV0dXJuIGN1cnJlbnRGZWF0dXJlXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gZmVhdHVyZVJlZHVjZShnZW9qc29uLCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBwcmV2aW91c1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBmZWF0dXJlRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCkge1xuICAgIGlmIChmZWF0dXJlSW5kZXggPT09IDAgJiYgaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQpIHByZXZpb3VzVmFsdWUgPSBjdXJyZW50RmVhdHVyZTtlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4KTtcbiAgfSk7XG4gIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuXG4vKipcbiAqIEdldCBhbGwgY29vcmRpbmF0ZXMgZnJvbSBhbnkgR2VvSlNPTiBvYmplY3QuXG4gKlxuICogQG5hbWUgY29vcmRBbGxcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRpbmF0ZSBwb3NpdGlvbiBhcnJheVxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICB0dXJmLnBvaW50KFszNiwgNTNdLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdmFyIGNvb3JkcyA9IHR1cmYuY29vcmRBbGwoZmVhdHVyZXMpO1xuICogLy89IFtbMjYsIDM3XSwgWzM2LCA1M11dXG4gKi9cbmZ1bmN0aW9uIGNvb3JkQWxsKGdlb2pzb24pIHtcbiAgdmFyIGNvb3JkcyA9IFtdO1xuICBjb29yZEVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgY29vcmRzLnB1c2goY29vcmQpO1xuICB9KTtcbiAgcmV0dXJuIGNvb3Jkcztcbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgZ2VvbUVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgZ2VvbUVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtHZW9tZXRyeX0gY3VycmVudEdlb21ldHJ5IFRoZSBjdXJyZW50IEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmVQcm9wZXJ0aWVzIFRoZSBjdXJyZW50IEZlYXR1cmUgUHJvcGVydGllcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZlYXR1cmVCQm94IFRoZSBjdXJyZW50IEZlYXR1cmUgQkJveCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGZlYXR1cmVJZCBUaGUgY3VycmVudCBGZWF0dXJlIElkIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBlYWNoIGdlb21ldHJ5IGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5mb3JFYWNoKClcbiAqXG4gKiBAbmFtZSBnZW9tRWFjaFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudEdlb21ldHJ5LCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKVxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgICB0dXJmLnBvaW50KFszNiwgNTNdLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdHVyZi5nZW9tRWFjaChmZWF0dXJlcywgZnVuY3Rpb24gKGN1cnJlbnRHZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZCkge1xuICogICAvLz1jdXJyZW50R2VvbWV0cnlcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPWZlYXR1cmVQcm9wZXJ0aWVzXG4gKiAgIC8vPWZlYXR1cmVCQm94XG4gKiAgIC8vPWZlYXR1cmVJZFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGdlb21FYWNoKGdlb2pzb24sIGNhbGxiYWNrKSB7XG4gIHZhciBpLFxuICAgIGosXG4gICAgZyxcbiAgICBnZW9tZXRyeSxcbiAgICBzdG9wRyxcbiAgICBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbixcbiAgICBpc0dlb21ldHJ5Q29sbGVjdGlvbixcbiAgICBmZWF0dXJlUHJvcGVydGllcyxcbiAgICBmZWF0dXJlQkJveCxcbiAgICBmZWF0dXJlSWQsXG4gICAgZmVhdHVyZUluZGV4ID0gMCxcbiAgICBpc0ZlYXR1cmVDb2xsZWN0aW9uID0gZ2VvanNvbi50eXBlID09PSBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gICAgaXNGZWF0dXJlID0gZ2VvanNvbi50eXBlID09PSBcIkZlYXR1cmVcIixcbiAgICBzdG9wID0gaXNGZWF0dXJlQ29sbGVjdGlvbiA/IGdlb2pzb24uZmVhdHVyZXMubGVuZ3RoIDogMTtcblxuICAvLyBUaGlzIGxvZ2ljIG1heSBsb29rIGEgbGl0dGxlIHdlaXJkLiBUaGUgcmVhc29uIHdoeSBpdCBpcyB0aGF0IHdheVxuICAvLyBpcyBiZWNhdXNlIGl0J3MgdHJ5aW5nIHRvIGJlIGZhc3QuIEdlb0pTT04gc3VwcG9ydHMgbXVsdGlwbGUga2luZHNcbiAgLy8gb2Ygb2JqZWN0cyBhdCBpdHMgcm9vdDogRmVhdHVyZUNvbGxlY3Rpb24sIEZlYXR1cmVzLCBHZW9tZXRyaWVzLlxuICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgaGFuZGxpbmcgYWxsIG9mIHRoZW0sIGFuZCB0aGF0XG4gIC8vIG1lYW5zIHRoYXQgc29tZSBvZiB0aGUgYGZvcmAgbG9vcHMgeW91IHNlZSBiZWxvdyBhY3R1YWxseSBqdXN0IGRvbid0IGFwcGx5XG4gIC8vIHRvIGNlcnRhaW4gaW5wdXRzLiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBnaXZlIHRoaXMganVzdCBhXG4gIC8vIFBvaW50IGdlb21ldHJ5LCB0aGVuIGJvdGggbG9vcHMgYXJlIHNob3J0LWNpcmN1aXRlZCBhbmQgYWxsIHdlIGRvXG4gIC8vIGlzIGdyYWR1YWxseSByZW5hbWUgdGhlIGlucHV0IHVudGlsIGl0J3MgY2FsbGVkICdnZW9tZXRyeScuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBhaW1zIHRvIGFsbG9jYXRlIGFzIGZldyByZXNvdXJjZXMgYXMgcG9zc2libGU6IGp1c3QgYVxuICAvLyBmZXcgbnVtYmVycyBhbmQgYm9vbGVhbnMsIHJhdGhlciB0aGFuIGFueSB0ZW1wb3JhcnkgYXJyYXlzIGFzIHdvdWxkXG4gIC8vIGJlIHJlcXVpcmVkIHdpdGggdGhlIG5vcm1hbGl6YXRpb24gYXBwcm9hY2guXG4gIGZvciAoaSA9IDA7IGkgPCBzdG9wOyBpKyspIHtcbiAgICBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbiA9IGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBnZW9qc29uLmZlYXR1cmVzW2ldLmdlb21ldHJ5IDogaXNGZWF0dXJlID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb247XG4gICAgZmVhdHVyZVByb3BlcnRpZXMgPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gZ2VvanNvbi5mZWF0dXJlc1tpXS5wcm9wZXJ0aWVzIDogaXNGZWF0dXJlID8gZ2VvanNvbi5wcm9wZXJ0aWVzIDoge307XG4gICAgZmVhdHVyZUJCb3ggPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gZ2VvanNvbi5mZWF0dXJlc1tpXS5iYm94IDogaXNGZWF0dXJlID8gZ2VvanNvbi5iYm94IDogdW5kZWZpbmVkO1xuICAgIGZlYXR1cmVJZCA9IGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBnZW9qc29uLmZlYXR1cmVzW2ldLmlkIDogaXNGZWF0dXJlID8gZ2VvanNvbi5pZCA6IHVuZGVmaW5lZDtcbiAgICBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24udHlwZSA9PT0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIiA6IGZhbHNlO1xuICAgIHN0b3BHID0gaXNHZW9tZXRyeUNvbGxlY3Rpb24gPyBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi5nZW9tZXRyaWVzLmxlbmd0aCA6IDE7XG4gICAgZm9yIChnID0gMDsgZyA8IHN0b3BHOyBnKyspIHtcbiAgICAgIGdlb21ldHJ5ID0gaXNHZW9tZXRyeUNvbGxlY3Rpb24gPyBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi5nZW9tZXRyaWVzW2ddIDogZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb247XG5cbiAgICAgIC8vIEhhbmRsZSBudWxsIEdlb21ldHJ5XG4gICAgICBpZiAoZ2VvbWV0cnkgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKG51bGwsIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xuICAgICAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjpcbiAgICAgICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgICAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGdlb21ldHJ5LCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjayhnZW9tZXRyeS5nZW9tZXRyaWVzW2pdLCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEdlb21ldHJ5IFR5cGVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE9ubHkgaW5jcmVhc2UgYGZlYXR1cmVJbmRleGAgcGVyIGVhY2ggZmVhdHVyZVxuICAgIGZlYXR1cmVJbmRleCsrO1xuICB9XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGdlb21SZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBnZW9tUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge0dlb21ldHJ5fSBjdXJyZW50R2VvbWV0cnkgVGhlIGN1cnJlbnQgR2VvbWV0cnkgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gZmVhdHVyZVByb3BlcnRpZXMgVGhlIGN1cnJlbnQgRmVhdHVyZSBQcm9wZXJ0aWVzIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmVhdHVyZUJCb3ggVGhlIGN1cnJlbnQgRmVhdHVyZSBCQm94IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gZmVhdHVyZUlkIFRoZSBjdXJyZW50IEZlYXR1cmUgSWQgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogUmVkdWNlIGdlb21ldHJ5IGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5yZWR1Y2UoKS5cbiAqXG4gKiBAbmFtZSBnZW9tUmVkdWNlXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50R2VvbWV0cnksIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtmb286ICdiYXInfSksXG4gKiAgICAgdHVyZi5wb2ludChbMzYsIDUzXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuZ2VvbVJlZHVjZShmZWF0dXJlcywgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRHZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRHZW9tZXRyeVxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgLy89ZmVhdHVyZVByb3BlcnRpZXNcbiAqICAgLy89ZmVhdHVyZUJCb3hcbiAqICAgLy89ZmVhdHVyZUlkXG4gKiAgIHJldHVybiBjdXJyZW50R2VvbWV0cnlcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBnZW9tUmVkdWNlKGdlb2pzb24sIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgdmFyIHByZXZpb3VzVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGdlb21FYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjdXJyZW50R2VvbWV0cnksIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpIHtcbiAgICBpZiAoZmVhdHVyZUluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudEdlb21ldHJ5O2Vsc2UgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRHZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZCk7XG4gIH0pO1xuICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgZmxhdHRlbkVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgZmxhdHRlbkVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtGZWF0dXJlfSBjdXJyZW50RmVhdHVyZSBUaGUgY3VycmVudCBmbGF0dGVuZWQgZmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aUZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgTXVsdGktRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgZmxhdHRlbmVkIGZlYXR1cmVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0b1xuICogQXJyYXkuZm9yRWFjaC5cbiAqXG4gKiBAbmFtZSBmbGF0dGVuRWFjaFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgICB0dXJmLm11bHRpUG9pbnQoW1s0MCwgMzBdLCBbMzYsIDUzXV0sIHtoZWxsbzogJ3dvcmxkJ30pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLmZsYXR0ZW5FYWNoKGZlYXR1cmVzLCBmdW5jdGlvbiAoY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpIHtcbiAqICAgLy89Y3VycmVudEZlYXR1cmVcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPW11bHRpRmVhdHVyZUluZGV4XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkVhY2goZ2VvanNvbiwgY2FsbGJhY2spIHtcbiAgZ2VvbUVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGdlb21ldHJ5LCBmZWF0dXJlSW5kZXgsIHByb3BlcnRpZXMsIGJib3gsIGlkKSB7XG4gICAgLy8gQ2FsbGJhY2sgZm9yIHNpbmdsZSBnZW9tZXRyeVxuICAgIHZhciB0eXBlID0gZ2VvbWV0cnkgPT09IG51bGwgPyBudWxsIDogZ2VvbWV0cnkudHlwZTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgbnVsbDpcbiAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICAgIGlmIChjYWxsYmFjayhmZWF0dXJlKGdlb21ldHJ5LCBwcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgYmJveDogYmJveCxcbiAgICAgICAgICBpZDogaWRcbiAgICAgICAgfSksIGZlYXR1cmVJbmRleCwgMCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGdlb21UeXBlO1xuXG4gICAgLy8gQ2FsbGJhY2sgZm9yIG11bHRpLWdlb21ldHJ5XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgICBnZW9tVHlwZSA9IFwiUG9pbnRcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6XG4gICAgICAgIGdlb21UeXBlID0gXCJMaW5lU3RyaW5nXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgICAgICBnZW9tVHlwZSA9IFwiUG9seWdvblwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yICh2YXIgbXVsdGlGZWF0dXJlSW5kZXggPSAwOyBtdWx0aUZlYXR1cmVJbmRleCA8IGdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgbXVsdGlGZWF0dXJlSW5kZXgrKykge1xuICAgICAgdmFyIGNvb3JkaW5hdGUgPSBnZW9tZXRyeS5jb29yZGluYXRlc1ttdWx0aUZlYXR1cmVJbmRleF07XG4gICAgICB2YXIgZ2VvbSA9IHtcbiAgICAgICAgdHlwZTogZ2VvbVR5cGUsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlXG4gICAgICB9O1xuICAgICAgaWYgKGNhbGxiYWNrKGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcyksIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGZsYXR0ZW5SZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBmbGF0dGVuUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge0ZlYXR1cmV9IGN1cnJlbnRGZWF0dXJlIFRoZSBjdXJyZW50IEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbXVsdGlGZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIE11bHRpLUZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogUmVkdWNlIGZsYXR0ZW5lZCBmZWF0dXJlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkucmVkdWNlKCkuXG4gKlxuICogQG5hbWUgZmxhdHRlblJlZHVjZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtmb286ICdiYXInfSksXG4gKiAgICAgdHVyZi5tdWx0aVBvaW50KFtbNDAsIDMwXSwgWzM2LCA1M11dLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdHVyZi5mbGF0dGVuUmVkdWNlKGZlYXR1cmVzLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpIHtcbiAqICAgLy89cHJldmlvdXNWYWx1ZVxuICogICAvLz1jdXJyZW50RmVhdHVyZVxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgLy89bXVsdGlGZWF0dXJlSW5kZXhcbiAqICAgcmV0dXJuIGN1cnJlbnRGZWF0dXJlXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gZmxhdHRlblJlZHVjZShnZW9qc29uLCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBwcmV2aW91c1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBmbGF0dGVuRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpIHtcbiAgICBpZiAoZmVhdHVyZUluZGV4ID09PSAwICYmIG11bHRpRmVhdHVyZUluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudEZlYXR1cmU7ZWxzZSBwcmV2aW91c1ZhbHVlID0gY2FsbGJhY2socHJldmlvdXNWYWx1ZSwgY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpO1xuICB9KTtcbiAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIHNlZ21lbnRFYWNoXG4gKlxuICogQGNhbGxiYWNrIHNlZ21lbnRFYWNoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gY3VycmVudFNlZ21lbnQgVGhlIGN1cnJlbnQgU2VnbWVudCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aUZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgTXVsdGktRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZ2VvbWV0cnlJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgR2VvbWV0cnkgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnRJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgU2VnbWVudCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciAyLXZlcnRleCBsaW5lIHNlZ21lbnQgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LmZvckVhY2goKVxuICogKE11bHRpKVBvaW50IGdlb21ldHJpZXMgZG8gbm90IGNvbnRhaW4gc2VnbWVudHMgdGhlcmVmb3JlIHRoZXkgYXJlIGlnbm9yZWQgZHVyaW5nIHRoaXMgb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudFNlZ21lbnQsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgsIHNlZ21lbnRJbmRleClcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5Z29uID0gdHVyZi5wb2x5Z29uKFtbWy01MCwgNV0sIFstNDAsIC0xMF0sIFstNTAsIC0xMF0sIFstNDAsIDVdLCBbLTUwLCA1XV1dKTtcbiAqXG4gKiAvLyBJdGVyYXRlIG92ZXIgR2VvSlNPTiBieSAyLXZlcnRleCBzZWdtZW50c1xuICogdHVyZi5zZWdtZW50RWFjaChwb2x5Z29uLCBmdW5jdGlvbiAoY3VycmVudFNlZ21lbnQsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgsIHNlZ21lbnRJbmRleCkge1xuICogICAvLz1jdXJyZW50U2VnbWVudFxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgLy89bXVsdGlGZWF0dXJlSW5kZXhcbiAqICAgLy89Z2VvbWV0cnlJbmRleFxuICogICAvLz1zZWdtZW50SW5kZXhcbiAqIH0pO1xuICpcbiAqIC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgbnVtYmVyIG9mIHNlZ21lbnRzXG4gKiB2YXIgdG90YWwgPSAwO1xuICogdHVyZi5zZWdtZW50RWFjaChwb2x5Z29uLCBmdW5jdGlvbiAoKSB7XG4gKiAgICAgdG90YWwrKztcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBzZWdtZW50RWFjaChnZW9qc29uLCBjYWxsYmFjaykge1xuICBmbGF0dGVuRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoZmVhdHVyZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCkge1xuICAgIHZhciBzZWdtZW50SW5kZXggPSAwO1xuXG4gICAgLy8gRXhjbHVkZSBudWxsIEdlb21ldHJpZXNcbiAgICBpZiAoIWZlYXR1cmUuZ2VvbWV0cnkpIHJldHVybjtcbiAgICAvLyAoTXVsdGkpUG9pbnQgZ2VvbWV0cmllcyBkbyBub3QgY29udGFpbiBzZWdtZW50cyB0aGVyZWZvcmUgdGhleSBhcmUgaWdub3JlZCBkdXJpbmcgdGhpcyBvcGVyYXRpb24uXG4gICAgdmFyIHR5cGUgPSBmZWF0dXJlLmdlb21ldHJ5LnR5cGU7XG4gICAgaWYgKHR5cGUgPT09IFwiUG9pbnRcIiB8fCB0eXBlID09PSBcIk11bHRpUG9pbnRcIikgcmV0dXJuO1xuXG4gICAgLy8gR2VuZXJhdGUgMi12ZXJ0ZXggbGluZSBzZWdtZW50c1xuICAgIHZhciBwcmV2aW91c0Nvb3JkcztcbiAgICB2YXIgcHJldmlvdXNGZWF0dXJlSW5kZXggPSAwO1xuICAgIHZhciBwcmV2aW91c011bHRpSW5kZXggPSAwO1xuICAgIHZhciBwcmV2R2VvbUluZGV4ID0gMDtcbiAgICBpZiAoY29vcmRFYWNoKGZlYXR1cmUsIGZ1bmN0aW9uIChjdXJyZW50Q29vcmQsIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleENvb3JkLCBtdWx0aVBhcnRJbmRleENvb3JkLCBnZW9tZXRyeUluZGV4KSB7XG4gICAgICAvLyBTaW11bGF0aW5nIGEgbWV0YS5jb29yZFJlZHVjZSgpIHNpbmNlIGByZWR1Y2VgIG9wZXJhdGlvbnMgY2Fubm90IGJlIHN0b3BwZWQgYnkgcmV0dXJuaW5nIGBmYWxzZWBcbiAgICAgIGlmIChwcmV2aW91c0Nvb3JkcyA9PT0gdW5kZWZpbmVkIHx8IGZlYXR1cmVJbmRleCA+IHByZXZpb3VzRmVhdHVyZUluZGV4IHx8IG11bHRpUGFydEluZGV4Q29vcmQgPiBwcmV2aW91c011bHRpSW5kZXggfHwgZ2VvbWV0cnlJbmRleCA+IHByZXZHZW9tSW5kZXgpIHtcbiAgICAgICAgcHJldmlvdXNDb29yZHMgPSBjdXJyZW50Q29vcmQ7XG4gICAgICAgIHByZXZpb3VzRmVhdHVyZUluZGV4ID0gZmVhdHVyZUluZGV4O1xuICAgICAgICBwcmV2aW91c011bHRpSW5kZXggPSBtdWx0aVBhcnRJbmRleENvb3JkO1xuICAgICAgICBwcmV2R2VvbUluZGV4ID0gZ2VvbWV0cnlJbmRleDtcbiAgICAgICAgc2VnbWVudEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnRTZWdtZW50ID0gbGluZVN0cmluZyhbcHJldmlvdXNDb29yZHMsIGN1cnJlbnRDb29yZF0sIGZlYXR1cmUucHJvcGVydGllcyk7XG4gICAgICBpZiAoY2FsbGJhY2soY3VycmVudFNlZ21lbnQsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgsIHNlZ21lbnRJbmRleCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICBzZWdtZW50SW5kZXgrKztcbiAgICAgIHByZXZpb3VzQ29vcmRzID0gY3VycmVudENvb3JkO1xuICAgIH0pID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3Igc2VnbWVudFJlZHVjZVxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzIGRlcGVuZFxuICogb24gd2hldGhlciB0aGUgcmVkdWNlIG1ldGhvZCBoYXMgYW4gaW5pdGlhbFZhbHVlIGFyZ3VtZW50LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCB0byB0aGUgcmVkdWNlIG1ldGhvZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIGluaXRpYWxWYWx1ZS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBub3QgcHJvdmlkZWQ6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogQGNhbGxiYWNrIHNlZ21lbnRSZWR1Y2VDYWxsYmFja1xuICogQHBhcmFtIHsqfSBwcmV2aW91c1ZhbHVlIFRoZSBhY2N1bXVsYXRlZCB2YWx1ZSBwcmV2aW91c2x5IHJldHVybmVkIGluIHRoZSBsYXN0IGludm9jYXRpb25cbiAqIG9mIHRoZSBjYWxsYmFjaywgb3IgaW5pdGlhbFZhbHVlLCBpZiBzdXBwbGllZC5cbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gY3VycmVudFNlZ21lbnQgVGhlIGN1cnJlbnQgU2VnbWVudCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aUZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgTXVsdGktRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZ2VvbWV0cnlJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgR2VvbWV0cnkgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnRJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgU2VnbWVudCBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgMi12ZXJ0ZXggbGluZSBzZWdtZW50IGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5yZWR1Y2UoKVxuICogKE11bHRpKVBvaW50IGdlb21ldHJpZXMgZG8gbm90IGNvbnRhaW4gc2VnbWVudHMgdGhlcmVmb3JlIHRoZXkgYXJlIGlnbm9yZWQgZHVyaW5nIHRoaXMgb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudFNlZ21lbnQsIGN1cnJlbnRJbmRleClcbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gVmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seWdvbiA9IHR1cmYucG9seWdvbihbW1stNTAsIDVdLCBbLTQwLCAtMTBdLCBbLTUwLCAtMTBdLCBbLTQwLCA1XSwgWy01MCwgNV1dXSk7XG4gKlxuICogLy8gSXRlcmF0ZSBvdmVyIEdlb0pTT04gYnkgMi12ZXJ0ZXggc2VnbWVudHNcbiAqIHR1cmYuc2VnbWVudFJlZHVjZShwb2x5Z29uLCBmdW5jdGlvbiAocHJldmlvdXNTZWdtZW50LCBjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KSB7XG4gKiAgIC8vPSBwcmV2aW91c1NlZ21lbnRcbiAqICAgLy89IGN1cnJlbnRTZWdtZW50XG4gKiAgIC8vPSBmZWF0dXJlSW5kZXhcbiAqICAgLy89IG11bHRpRmVhdHVyZUluZGV4XG4gKiAgIC8vPSBnZW9tZXRyeUluZGV4XG4gKiAgIC8vPSBzZWdtZW50SW5kZXhcbiAqICAgcmV0dXJuIGN1cnJlbnRTZWdtZW50XG4gKiB9KTtcbiAqXG4gKiAvLyBDYWxjdWxhdGUgdGhlIHRvdGFsIG51bWJlciBvZiBzZWdtZW50c1xuICogdmFyIGluaXRpYWxWYWx1ZSA9IDBcbiAqIHZhciB0b3RhbCA9IHR1cmYuc2VnbWVudFJlZHVjZShwb2x5Z29uLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSkge1xuICogICAgIHByZXZpb3VzVmFsdWUrKztcbiAqICAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbiAqIH0sIGluaXRpYWxWYWx1ZSk7XG4gKi9cbmZ1bmN0aW9uIHNlZ21lbnRSZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgdmFyIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgc2VnbWVudEVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGN1cnJlbnRTZWdtZW50LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4LCBzZWdtZW50SW5kZXgpIHtcbiAgICBpZiAoc3RhcnRlZCA9PT0gZmFsc2UgJiYgaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQpIHByZXZpb3VzVmFsdWUgPSBjdXJyZW50U2VnbWVudDtlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KTtcbiAgICBzdGFydGVkID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBsaW5lRWFjaFxuICpcbiAqIEBjYWxsYmFjayBsaW5lRWFjaENhbGxiYWNrXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZz59IGN1cnJlbnRMaW5lIFRoZSBjdXJyZW50IExpbmVTdHJpbmd8TGluZWFyUmluZyBiZWluZyBwcm9jZXNzZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkXG4gKiBAcGFyYW0ge251bWJlcn0gbXVsdGlGZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIE11bHRpLUZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkXG4gKiBAcGFyYW0ge251bWJlcn0gZ2VvbWV0cnlJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgR2VvbWV0cnkgYmVpbmcgcHJvY2Vzc2VkXG4gKi9cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgbGluZSBvciByaW5nIGNvb3JkaW5hdGVzIGluIExpbmVTdHJpbmcsIFBvbHlnb24sIE11bHRpTGluZVN0cmluZywgTXVsdGlQb2x5Z29uIEZlYXR1cmVzIG9yIEdlb21ldHJpZXMsXG4gKiBzaW1pbGFyIHRvIEFycmF5LmZvckVhY2guXG4gKlxuICogQG5hbWUgbGluZUVhY2hcbiAqIEBwYXJhbSB7R2VvbWV0cnl8RmVhdHVyZTxMaW5lU3RyaW5nfFBvbHlnb258TXVsdGlMaW5lU3RyaW5nfE11bHRpUG9seWdvbj59IGdlb2pzb24gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChjdXJyZW50TGluZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleClcbiAqIEBleGFtcGxlXG4gKiB2YXIgbXVsdGlMaW5lID0gdHVyZi5tdWx0aUxpbmVTdHJpbmcoW1xuICogICBbWzI2LCAzN10sIFszNSwgNDVdXSxcbiAqICAgW1szNiwgNTNdLCBbMzgsIDUwXSwgWzQxLCA1NV1dXG4gKiBdKTtcbiAqXG4gKiB0dXJmLmxpbmVFYWNoKG11bHRpTGluZSwgZnVuY3Rpb24gKGN1cnJlbnRMaW5lLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSB7XG4gKiAgIC8vPWN1cnJlbnRMaW5lXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1tdWx0aUZlYXR1cmVJbmRleFxuICogICAvLz1nZW9tZXRyeUluZGV4XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gbGluZUVhY2goZ2VvanNvbiwgY2FsbGJhY2spIHtcbiAgLy8gdmFsaWRhdGlvblxuICBpZiAoIWdlb2pzb24pIHRocm93IG5ldyBFcnJvcihcImdlb2pzb24gaXMgcmVxdWlyZWRcIik7XG4gIGZsYXR0ZW5FYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChmZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KSB7XG4gICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkgPT09IG51bGwpIHJldHVybjtcbiAgICB2YXIgdHlwZSA9IGZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcbiAgICB2YXIgY29vcmRzID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICAgIGlmIChjYWxsYmFjayhmZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCAwLCAwKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgICAgICBmb3IgKHZhciBnZW9tZXRyeUluZGV4ID0gMDsgZ2VvbWV0cnlJbmRleCA8IGNvb3Jkcy5sZW5ndGg7IGdlb21ldHJ5SW5kZXgrKykge1xuICAgICAgICAgIGlmIChjYWxsYmFjayhsaW5lU3RyaW5nKGNvb3Jkc1tnZW9tZXRyeUluZGV4XSwgZmVhdHVyZS5wcm9wZXJ0aWVzKSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgbGluZVJlZHVjZVxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzIGRlcGVuZFxuICogb24gd2hldGhlciB0aGUgcmVkdWNlIG1ldGhvZCBoYXMgYW4gaW5pdGlhbFZhbHVlIGFyZ3VtZW50LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCB0byB0aGUgcmVkdWNlIG1ldGhvZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIGluaXRpYWxWYWx1ZS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBub3QgcHJvdmlkZWQ6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogQGNhbGxiYWNrIGxpbmVSZWR1Y2VDYWxsYmFja1xuICogQHBhcmFtIHsqfSBwcmV2aW91c1ZhbHVlIFRoZSBhY2N1bXVsYXRlZCB2YWx1ZSBwcmV2aW91c2x5IHJldHVybmVkIGluIHRoZSBsYXN0IGludm9jYXRpb25cbiAqIG9mIHRoZSBjYWxsYmFjaywgb3IgaW5pdGlhbFZhbHVlLCBpZiBzdXBwbGllZC5cbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gY3VycmVudExpbmUgVGhlIGN1cnJlbnQgTGluZVN0cmluZ3xMaW5lYXJSaW5nIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkXG4gKiBAcGFyYW0ge251bWJlcn0gbXVsdGlGZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIE11bHRpLUZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkXG4gKiBAcGFyYW0ge251bWJlcn0gZ2VvbWV0cnlJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgR2VvbWV0cnkgYmVpbmcgcHJvY2Vzc2VkXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpLlxuICpcbiAqIEBuYW1lIGxpbmVSZWR1Y2VcbiAqIEBwYXJhbSB7R2VvbWV0cnl8RmVhdHVyZTxMaW5lU3RyaW5nfFBvbHlnb258TXVsdGlMaW5lU3RyaW5nfE11bHRpUG9seWdvbj59IGdlb2pzb24gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50TGluZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleClcbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gVmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHRoZSByZWR1Y3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpUG9seSA9IHR1cmYubXVsdGlQb2x5Z29uKFtcbiAqICAgdHVyZi5wb2x5Z29uKFtbWzEyLDQ4XSxbMiw0MV0sWzI0LDM4XSxbMTIsNDhdXSwgW1s5LDQ0XSxbMTMsNDFdLFsxMyw0NV0sWzksNDRdXV0pLFxuICogICB0dXJmLnBvbHlnb24oW1tbNSwgNV0sIFswLCAwXSwgWzIsIDJdLCBbNCwgNF0sIFs1LCA1XV1dKVxuICogXSk7XG4gKlxuICogdHVyZi5saW5lUmVkdWNlKG11bHRpUG9seSwgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRMaW5lLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSB7XG4gKiAgIC8vPXByZXZpb3VzVmFsdWVcbiAqICAgLy89Y3VycmVudExpbmVcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPW11bHRpRmVhdHVyZUluZGV4XG4gKiAgIC8vPWdlb21ldHJ5SW5kZXhcbiAqICAgcmV0dXJuIGN1cnJlbnRMaW5lXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gbGluZVJlZHVjZShnZW9qc29uLCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBwcmV2aW91c1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBsaW5lRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY3VycmVudExpbmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpIHtcbiAgICBpZiAoZmVhdHVyZUluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudExpbmU7ZWxzZSBwcmV2aW91c1ZhbHVlID0gY2FsbGJhY2socHJldmlvdXNWYWx1ZSwgY3VycmVudExpbmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpO1xuICB9KTtcbiAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG59XG5cbi8qKlxuICogRmluZHMgYSBwYXJ0aWN1bGFyIDItdmVydGV4IExpbmVTdHJpbmcgU2VnbWVudCBmcm9tIGEgR2VvSlNPTiB1c2luZyBgQHR1cmYvbWV0YWAgaW5kZXhlcy5cbiAqXG4gKiBOZWdhdGl2ZSBpbmRleGVzIGFyZSBwZXJtaXR0ZWQuXG4gKiBQb2ludCAmIE11bHRpUG9pbnQgd2lsbCBhbHdheXMgcmV0dXJuIG51bGwuXG4gKlxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIEFueSBHZW9KU09OIEZlYXR1cmUgb3IgR2VvbWV0cnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmZlYXR1cmVJbmRleD0wXSBGZWF0dXJlIEluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubXVsdGlGZWF0dXJlSW5kZXg9MF0gTXVsdGktRmVhdHVyZSBJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmdlb21ldHJ5SW5kZXg9MF0gR2VvbWV0cnkgSW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zZWdtZW50SW5kZXg9MF0gU2VnbWVudCBJbmRleFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnByb3BlcnRpZXM9e31dIFRyYW5zbGF0ZSBQcm9wZXJ0aWVzIHRvIG91dHB1dCBMaW5lU3RyaW5nXG4gKiBAcGFyYW0ge0JCb3h9IFtvcHRpb25zLmJib3g9e31dIFRyYW5zbGF0ZSBCQm94IHRvIG91dHB1dCBMaW5lU3RyaW5nXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRpb25zLmlkPXt9XSBUcmFuc2xhdGUgSWQgdG8gb3V0cHV0IExpbmVTdHJpbmdcbiAqIEByZXR1cm5zIHtGZWF0dXJlPExpbmVTdHJpbmc+fSAyLXZlcnRleCBHZW9KU09OIEZlYXR1cmUgTGluZVN0cmluZ1xuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aUxpbmUgPSB0dXJmLm11bHRpTGluZVN0cmluZyhbXG4gKiAgICAgW1sxMCwgMTBdLCBbNTAsIDMwXSwgWzMwLCA0MF1dLFxuICogICAgIFtbLTEwLCAtMTBdLCBbLTUwLCAtMzBdLCBbLTMwLCAtNDBdXVxuICogXSk7XG4gKlxuICogLy8gRmlyc3QgU2VnbWVudCAoZGVmYXVsdHMgYXJlIDApXG4gKiB0dXJmLmZpbmRTZWdtZW50KG11bHRpTGluZSk7XG4gKiAvLyA9PiBGZWF0dXJlPExpbmVTdHJpbmc8W1sxMCwgMTBdLCBbNTAsIDMwXV0+PlxuICpcbiAqIC8vIEZpcnN0IFNlZ21lbnQgb2YgMm5kIE11bHRpIEZlYXR1cmVcbiAqIHR1cmYuZmluZFNlZ21lbnQobXVsdGlMaW5lLCB7bXVsdGlGZWF0dXJlSW5kZXg6IDF9KTtcbiAqIC8vID0+IEZlYXR1cmU8TGluZVN0cmluZzxbWy0xMCwgLTEwXSwgWy01MCwgLTMwXV0+PlxuICpcbiAqIC8vIExhc3QgU2VnbWVudCBvZiBMYXN0IE11bHRpIEZlYXR1cmVcbiAqIHR1cmYuZmluZFNlZ21lbnQobXVsdGlMaW5lLCB7bXVsdGlGZWF0dXJlSW5kZXg6IC0xLCBzZWdtZW50SW5kZXg6IC0xfSk7XG4gKiAvLyA9PiBGZWF0dXJlPExpbmVTdHJpbmc8W1stNTAsIC0zMF0sIFstMzAsIC00MF1dPj5cbiAqL1xuZnVuY3Rpb24gZmluZFNlZ21lbnQoZ2VvanNvbiwgb3B0aW9ucykge1xuICAvLyBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zIGlzIGludmFsaWRcIik7XG4gIHZhciBmZWF0dXJlSW5kZXggPSBvcHRpb25zLmZlYXR1cmVJbmRleCB8fCAwO1xuICB2YXIgbXVsdGlGZWF0dXJlSW5kZXggPSBvcHRpb25zLm11bHRpRmVhdHVyZUluZGV4IHx8IDA7XG4gIHZhciBnZW9tZXRyeUluZGV4ID0gb3B0aW9ucy5nZW9tZXRyeUluZGV4IHx8IDA7XG4gIHZhciBzZWdtZW50SW5kZXggPSBvcHRpb25zLnNlZ21lbnRJbmRleCB8fCAwO1xuXG4gIC8vIEZpbmQgRmVhdHVyZUluZGV4XG4gIHZhciBwcm9wZXJ0aWVzID0gb3B0aW9ucy5wcm9wZXJ0aWVzO1xuICB2YXIgZ2VvbWV0cnk7XG4gIHN3aXRjaCAoZ2VvanNvbi50eXBlKSB7XG4gICAgY2FzZSBcIkZlYXR1cmVDb2xsZWN0aW9uXCI6XG4gICAgICBpZiAoZmVhdHVyZUluZGV4IDwgMCkgZmVhdHVyZUluZGV4ID0gZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggKyBmZWF0dXJlSW5kZXg7XG4gICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCBnZW9qc29uLmZlYXR1cmVzW2ZlYXR1cmVJbmRleF0ucHJvcGVydGllcztcbiAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbi5mZWF0dXJlc1tmZWF0dXJlSW5kZXhdLmdlb21ldHJ5O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkZlYXR1cmVcIjpcbiAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IGdlb2pzb24ucHJvcGVydGllcztcbiAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbi5nZW9tZXRyeTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQb2ludFwiOlxuICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZW9qc29uIGlzIGludmFsaWRcIik7XG4gIH1cblxuICAvLyBGaW5kIFNlZ21lbnRJbmRleFxuICBpZiAoZ2VvbWV0cnkgPT09IG51bGwpIHJldHVybiBudWxsO1xuICB2YXIgY29vcmRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gIHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xuICAgIGNhc2UgXCJQb2ludFwiOlxuICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgaWYgKHNlZ21lbnRJbmRleCA8IDApIHNlZ21lbnRJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBzZWdtZW50SW5kZXggLSAxO1xuICAgICAgcmV0dXJuIGxpbmVTdHJpbmcoW2Nvb3Jkc1tzZWdtZW50SW5kZXhdLCBjb29yZHNbc2VnbWVudEluZGV4ICsgMV1dLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgICAgaWYgKGdlb21ldHJ5SW5kZXggPCAwKSBnZW9tZXRyeUluZGV4ID0gY29vcmRzLmxlbmd0aCArIGdlb21ldHJ5SW5kZXg7XG4gICAgICBpZiAoc2VnbWVudEluZGV4IDwgMCkgc2VnbWVudEluZGV4ID0gY29vcmRzW2dlb21ldHJ5SW5kZXhdLmxlbmd0aCArIHNlZ21lbnRJbmRleCAtIDE7XG4gICAgICByZXR1cm4gbGluZVN0cmluZyhbY29vcmRzW2dlb21ldHJ5SW5kZXhdW3NlZ21lbnRJbmRleF0sIGNvb3Jkc1tnZW9tZXRyeUluZGV4XVtzZWdtZW50SW5kZXggKyAxXV0sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjpcbiAgICAgIGlmIChtdWx0aUZlYXR1cmVJbmRleCA8IDApIG11bHRpRmVhdHVyZUluZGV4ID0gY29vcmRzLmxlbmd0aCArIG11bHRpRmVhdHVyZUluZGV4O1xuICAgICAgaWYgKHNlZ21lbnRJbmRleCA8IDApIHNlZ21lbnRJbmRleCA9IGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF0ubGVuZ3RoICsgc2VnbWVudEluZGV4IC0gMTtcbiAgICAgIHJldHVybiBsaW5lU3RyaW5nKFtjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW3NlZ21lbnRJbmRleF0sIGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bc2VnbWVudEluZGV4ICsgMV1dLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6XG4gICAgICBpZiAobXVsdGlGZWF0dXJlSW5kZXggPCAwKSBtdWx0aUZlYXR1cmVJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBtdWx0aUZlYXR1cmVJbmRleDtcbiAgICAgIGlmIChnZW9tZXRyeUluZGV4IDwgMCkgZ2VvbWV0cnlJbmRleCA9IGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF0ubGVuZ3RoICsgZ2VvbWV0cnlJbmRleDtcbiAgICAgIGlmIChzZWdtZW50SW5kZXggPCAwKSBzZWdtZW50SW5kZXggPSBjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW2dlb21ldHJ5SW5kZXhdLmxlbmd0aCAtIHNlZ21lbnRJbmRleCAtIDE7XG4gICAgICByZXR1cm4gbGluZVN0cmluZyhbY29vcmRzW211bHRpRmVhdHVyZUluZGV4XVtnZW9tZXRyeUluZGV4XVtzZWdtZW50SW5kZXhdLCBjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW2dlb21ldHJ5SW5kZXhdW3NlZ21lbnRJbmRleCArIDFdXSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiZ2VvanNvbiBpcyBpbnZhbGlkXCIpO1xufVxuXG4vKipcbiAqIEZpbmRzIGEgcGFydGljdWxhciBQb2ludCBmcm9tIGEgR2VvSlNPTiB1c2luZyBgQHR1cmYvbWV0YWAgaW5kZXhlcy5cbiAqXG4gKiBOZWdhdGl2ZSBpbmRleGVzIGFyZSBwZXJtaXR0ZWQuXG4gKlxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIEFueSBHZW9KU09OIEZlYXR1cmUgb3IgR2VvbWV0cnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmZlYXR1cmVJbmRleD0wXSBGZWF0dXJlIEluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubXVsdGlGZWF0dXJlSW5kZXg9MF0gTXVsdGktRmVhdHVyZSBJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmdlb21ldHJ5SW5kZXg9MF0gR2VvbWV0cnkgSW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb29yZEluZGV4PTBdIENvb3JkIEluZGV4XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucHJvcGVydGllcz17fV0gVHJhbnNsYXRlIFByb3BlcnRpZXMgdG8gb3V0cHV0IFBvaW50XG4gKiBAcGFyYW0ge0JCb3h9IFtvcHRpb25zLmJib3g9e31dIFRyYW5zbGF0ZSBCQm94IHRvIG91dHB1dCBQb2ludFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0aW9ucy5pZD17fV0gVHJhbnNsYXRlIElkIHRvIG91dHB1dCBQb2ludFxuICogQHJldHVybnMge0ZlYXR1cmU8UG9pbnQ+fSAyLXZlcnRleCBHZW9KU09OIEZlYXR1cmUgUG9pbnRcbiAqIEBleGFtcGxlXG4gKiB2YXIgbXVsdGlMaW5lID0gdHVyZi5tdWx0aUxpbmVTdHJpbmcoW1xuICogICAgIFtbMTAsIDEwXSwgWzUwLCAzMF0sIFszMCwgNDBdXSxcbiAqICAgICBbWy0xMCwgLTEwXSwgWy01MCwgLTMwXSwgWy0zMCwgLTQwXV1cbiAqIF0pO1xuICpcbiAqIC8vIEZpcnN0IFNlZ21lbnQgKGRlZmF1bHRzIGFyZSAwKVxuICogdHVyZi5maW5kUG9pbnQobXVsdGlMaW5lKTtcbiAqIC8vID0+IEZlYXR1cmU8UG9pbnQ8WzEwLCAxMF0+PlxuICpcbiAqIC8vIEZpcnN0IFNlZ21lbnQgb2YgdGhlIDJuZCBNdWx0aS1GZWF0dXJlXG4gKiB0dXJmLmZpbmRQb2ludChtdWx0aUxpbmUsIHttdWx0aUZlYXR1cmVJbmRleDogMX0pO1xuICogLy8gPT4gRmVhdHVyZTxQb2ludDxbLTEwLCAtMTBdPj5cbiAqXG4gKiAvLyBMYXN0IFNlZ21lbnQgb2YgbGFzdCBNdWx0aS1GZWF0dXJlXG4gKiB0dXJmLmZpbmRQb2ludChtdWx0aUxpbmUsIHttdWx0aUZlYXR1cmVJbmRleDogLTEsIGNvb3JkSW5kZXg6IC0xfSk7XG4gKiAvLyA9PiBGZWF0dXJlPFBvaW50PFstMzAsIC00MF0+PlxuICovXG5mdW5jdGlvbiBmaW5kUG9pbnQoZ2VvanNvbiwgb3B0aW9ucykge1xuICAvLyBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zIGlzIGludmFsaWRcIik7XG4gIHZhciBmZWF0dXJlSW5kZXggPSBvcHRpb25zLmZlYXR1cmVJbmRleCB8fCAwO1xuICB2YXIgbXVsdGlGZWF0dXJlSW5kZXggPSBvcHRpb25zLm11bHRpRmVhdHVyZUluZGV4IHx8IDA7XG4gIHZhciBnZW9tZXRyeUluZGV4ID0gb3B0aW9ucy5nZW9tZXRyeUluZGV4IHx8IDA7XG4gIHZhciBjb29yZEluZGV4ID0gb3B0aW9ucy5jb29yZEluZGV4IHx8IDA7XG5cbiAgLy8gRmluZCBGZWF0dXJlSW5kZXhcbiAgdmFyIHByb3BlcnRpZXMgPSBvcHRpb25zLnByb3BlcnRpZXM7XG4gIHZhciBnZW9tZXRyeTtcbiAgc3dpdGNoIChnZW9qc29uLnR5cGUpIHtcbiAgICBjYXNlIFwiRmVhdHVyZUNvbGxlY3Rpb25cIjpcbiAgICAgIGlmIChmZWF0dXJlSW5kZXggPCAwKSBmZWF0dXJlSW5kZXggPSBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aCArIGZlYXR1cmVJbmRleDtcbiAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IGdlb2pzb24uZmVhdHVyZXNbZmVhdHVyZUluZGV4XS5wcm9wZXJ0aWVzO1xuICAgICAgZ2VvbWV0cnkgPSBnZW9qc29uLmZlYXR1cmVzW2ZlYXR1cmVJbmRleF0uZ2VvbWV0cnk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiRmVhdHVyZVwiOlxuICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwgZ2VvanNvbi5wcm9wZXJ0aWVzO1xuICAgICAgZ2VvbWV0cnkgPSBnZW9qc29uLmdlb21ldHJ5O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlBvaW50XCI6XG4gICAgY2FzZSBcIk11bHRpUG9pbnRcIjpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6XG4gICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgICAgZ2VvbWV0cnkgPSBnZW9qc29uO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImdlb2pzb24gaXMgaW52YWxpZFwiKTtcbiAgfVxuXG4gIC8vIEZpbmQgQ29vcmQgSW5kZXhcbiAgaWYgKGdlb21ldHJ5ID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgdmFyIGNvb3JkcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICBzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcbiAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICAgIHJldHVybiBwb2ludChjb29yZHMsIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICBpZiAobXVsdGlGZWF0dXJlSW5kZXggPCAwKSBtdWx0aUZlYXR1cmVJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBtdWx0aUZlYXR1cmVJbmRleDtcbiAgICAgIHJldHVybiBwb2ludChjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgaWYgKGNvb3JkSW5kZXggPCAwKSBjb29yZEluZGV4ID0gY29vcmRzLmxlbmd0aCArIGNvb3JkSW5kZXg7XG4gICAgICByZXR1cm4gcG9pbnQoY29vcmRzW2Nvb3JkSW5kZXhdLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgICAgaWYgKGdlb21ldHJ5SW5kZXggPCAwKSBnZW9tZXRyeUluZGV4ID0gY29vcmRzLmxlbmd0aCArIGdlb21ldHJ5SW5kZXg7XG4gICAgICBpZiAoY29vcmRJbmRleCA8IDApIGNvb3JkSW5kZXggPSBjb29yZHNbZ2VvbWV0cnlJbmRleF0ubGVuZ3RoICsgY29vcmRJbmRleDtcbiAgICAgIHJldHVybiBwb2ludChjb29yZHNbZ2VvbWV0cnlJbmRleF1bY29vcmRJbmRleF0sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjpcbiAgICAgIGlmIChtdWx0aUZlYXR1cmVJbmRleCA8IDApIG11bHRpRmVhdHVyZUluZGV4ID0gY29vcmRzLmxlbmd0aCArIG11bHRpRmVhdHVyZUluZGV4O1xuICAgICAgaWYgKGNvb3JkSW5kZXggPCAwKSBjb29yZEluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XS5sZW5ndGggKyBjb29yZEluZGV4O1xuICAgICAgcmV0dXJuIHBvaW50KGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bY29vcmRJbmRleF0sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgIGlmIChtdWx0aUZlYXR1cmVJbmRleCA8IDApIG11bHRpRmVhdHVyZUluZGV4ID0gY29vcmRzLmxlbmd0aCArIG11bHRpRmVhdHVyZUluZGV4O1xuICAgICAgaWYgKGdlb21ldHJ5SW5kZXggPCAwKSBnZW9tZXRyeUluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XS5sZW5ndGggKyBnZW9tZXRyeUluZGV4O1xuICAgICAgaWYgKGNvb3JkSW5kZXggPCAwKSBjb29yZEluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XVtnZW9tZXRyeUluZGV4XS5sZW5ndGggLSBjb29yZEluZGV4O1xuICAgICAgcmV0dXJuIHBvaW50KGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bZ2VvbWV0cnlJbmRleF1bY29vcmRJbmRleF0sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcImdlb2pzb24gaXMgaW52YWxpZFwiKTtcbn1cbmV4cG9ydCB7IGNvb3JkQWxsLCBjb29yZEVhY2gsIGNvb3JkUmVkdWNlLCBmZWF0dXJlRWFjaCwgZmVhdHVyZVJlZHVjZSwgZmluZFBvaW50LCBmaW5kU2VnbWVudCwgZmxhdHRlbkVhY2gsIGZsYXR0ZW5SZWR1Y2UsIGdlb21FYWNoLCBnZW9tUmVkdWNlLCBsaW5lRWFjaCwgbGluZVJlZHVjZSwgcHJvcEVhY2gsIHByb3BSZWR1Y2UsIHNlZ21lbnRFYWNoLCBzZWdtZW50UmVkdWNlIH07IiwiaW1wb3J0IHsgY29vcmRFYWNoIH0gZnJvbSBcIkB0dXJmL21ldGFcIjtcbi8qKlxuICogVGFrZXMgYSBzZXQgb2YgZmVhdHVyZXMsIGNhbGN1bGF0ZXMgdGhlIGJib3ggb2YgYWxsIGlucHV0IGZlYXR1cmVzLCBhbmQgcmV0dXJucyBhIGJvdW5kaW5nIGJveC5cbiAqXG4gKiBAbmFtZSBiYm94XG4gKiBAcGFyYW0ge0dlb0pTT059IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcmV0dXJucyB7QkJveH0gYmJveCBleHRlbnQgaW4gW21pblgsIG1pblksIG1heFgsIG1heFldIG9yZGVyXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmUgPSB0dXJmLmxpbmVTdHJpbmcoW1stNzQsIDQwXSwgWy03OCwgNDJdLCBbLTgyLCAzNV1dKTtcbiAqIHZhciBiYm94ID0gdHVyZi5iYm94KGxpbmUpO1xuICogdmFyIGJib3hQb2x5Z29uID0gdHVyZi5iYm94UG9seWdvbihiYm94KTtcbiAqXG4gKiAvL2FkZFRvTWFwXG4gKiB2YXIgYWRkVG9NYXAgPSBbbGluZSwgYmJveFBvbHlnb25dXG4gKi9cbmZ1bmN0aW9uIGJib3goZ2VvanNvbikge1xuICB2YXIgcmVzdWx0ID0gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuICBjb29yZEVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgaWYgKHJlc3VsdFswXSA+IGNvb3JkWzBdKSB7XG4gICAgICByZXN1bHRbMF0gPSBjb29yZFswXTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdFsxXSA+IGNvb3JkWzFdKSB7XG4gICAgICByZXN1bHRbMV0gPSBjb29yZFsxXTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdFsyXSA8IGNvb3JkWzBdKSB7XG4gICAgICByZXN1bHRbMl0gPSBjb29yZFswXTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdFszXSA8IGNvb3JkWzFdKSB7XG4gICAgICByZXN1bHRbM10gPSBjb29yZFsxXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuYmJveFtcImRlZmF1bHRcIl0gPSBiYm94O1xuZXhwb3J0IGRlZmF1bHQgYmJveDsiLCJleHBvcnQgZnVuY3Rpb24gY3ViaWNJbih0KSB7XG4gIHJldHVybiB0ICogdCAqIHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gY3ViaWNPdXQodCkge1xuICByZXR1cm4gLS10ICogdCAqIHQgKyAxO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyB0ICogdCAqIHQgOiAodCAtPSAyKSAqIHQgKiB0ICsgMikgLyAyO1xufSIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc0Jyb3dzZXIsIG5vb3AgfSBmcm9tICcuL21pc2MvdXRpbCc7XG52YXIgdXNlTG9jYWxTdG9yYWdlID0gZnVuY3Rpb24gKGtleSwgaW5pdGlhbFZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghaXNCcm93c2VyKSB7XG4gICAgcmV0dXJuIFtpbml0aWFsVmFsdWUsIG5vb3AsIG5vb3BdO1xuICB9XG4gIGlmICgha2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VMb2NhbFN0b3JhZ2Uga2V5IG1heSBub3QgYmUgZmFsc3knKTtcbiAgfVxuICB2YXIgZGVzZXJpYWxpemVyID0gb3B0aW9ucyA/IG9wdGlvbnMucmF3ID8gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IDogb3B0aW9ucy5kZXNlcmlhbGl6ZXIgOiBKU09OLnBhcnNlO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgdmFyIGluaXRpYWxpemVyID0gdXNlUmVmKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHNlcmlhbGl6ZXIgPSBvcHRpb25zID8gb3B0aW9ucy5yYXcgPyBTdHJpbmcgOiBvcHRpb25zLnNlcmlhbGl6ZXIgOiBKU09OLnN0cmluZ2lmeTtcbiAgICAgIHZhciBsb2NhbFN0b3JhZ2VWYWx1ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICBpZiAobG9jYWxTdG9yYWdlVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplcihsb2NhbFN0b3JhZ2VWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0aWFsVmFsdWUgJiYgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBzZXJpYWxpemVyKGluaXRpYWxWYWx1ZSkpO1xuICAgICAgICByZXR1cm4gaW5pdGlhbFZhbHVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF9hKSB7XG4gICAgICAvLyBJZiB1c2VyIGlzIGluIHByaXZhdGUgbW9kZSBvciBoYXMgc3RvcmFnZSByZXN0cmljdGlvblxuICAgICAgLy8gbG9jYWxTdG9yYWdlIGNhbiB0aHJvdy4gSlNPTi5wYXJzZSBhbmQgSlNPTi5zdHJpbmdpZnlcbiAgICAgIC8vIGNhbiB0aHJvdywgdG9vLlxuICAgICAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcbiAgICB9XG4gIH0pO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgdmFyIF9hID0gdXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGluaXRpYWxpemVyLmN1cnJlbnQoa2V5KTtcbiAgICB9KSxcbiAgICBzdGF0ZSA9IF9hWzBdLFxuICAgIHNldFN0YXRlID0gX2FbMV07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICB1c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzZXRTdGF0ZShpbml0aWFsaXplci5jdXJyZW50KGtleSkpO1xuICB9LCBba2V5XSk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICB2YXIgc2V0ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHZhbE9yRnVuYykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSB0eXBlb2YgdmFsT3JGdW5jID09PSAnZnVuY3Rpb24nID8gdmFsT3JGdW5jKHN0YXRlKSA6IHZhbE9yRnVuYztcbiAgICAgIGlmICh0eXBlb2YgbmV3U3RhdGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgICB2YXIgdmFsdWUgPSB2b2lkIDA7XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5yYXcpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5ld1N0YXRlID09PSAnc3RyaW5nJykgdmFsdWUgPSBuZXdTdGF0ZTtlbHNlIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkobmV3U3RhdGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2VyaWFsaXplcikgdmFsdWUgPSBvcHRpb25zLnNlcmlhbGl6ZXIobmV3U3RhdGUpO2Vsc2UgdmFsdWUgPSBKU09OLnN0cmluZ2lmeShuZXdTdGF0ZSk7XG4gICAgICB9IGVsc2UgdmFsdWUgPSBKU09OLnN0cmluZ2lmeShuZXdTdGF0ZSk7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICAgIHNldFN0YXRlKGRlc2VyaWFsaXplcih2YWx1ZSkpO1xuICAgIH0gY2F0Y2ggKF9hKSB7XG4gICAgICAvLyBJZiB1c2VyIGlzIGluIHByaXZhdGUgbW9kZSBvciBoYXMgc3RvcmFnZSByZXN0cmljdGlvblxuICAgICAgLy8gbG9jYWxTdG9yYWdlIGNhbiB0aHJvdy4gQWxzbyBKU09OLnN0cmluZ2lmeSBjYW4gdGhyb3cuXG4gICAgfVxuICB9LCBba2V5LCBzZXRTdGF0ZV0pO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgdmFyIHJlbW92ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgIHNldFN0YXRlKHVuZGVmaW5lZCk7XG4gICAgfSBjYXRjaCAoX2EpIHtcbiAgICAgIC8vIElmIHVzZXIgaXMgaW4gcHJpdmF0ZSBtb2RlIG9yIGhhcyBzdG9yYWdlIHJlc3RyaWN0aW9uXG4gICAgICAvLyBsb2NhbFN0b3JhZ2UgY2FuIHRocm93LlxuICAgIH1cbiAgfSwgW2tleSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIFtzdGF0ZSwgc2V0LCByZW1vdmVdO1xufTtcbmV4cG9ydCBkZWZhdWx0IHVzZUxvY2FsU3RvcmFnZTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB2YXIgZGlzYWR2YW50YWdlZERvdEJpZyA9IFwiRGlzYWR2YW50YWdlRG90LW1vZHVsZS0tZGlzYWR2YW50YWdlZERvdEJpZy0tdUVqK1lcIjtcbmV4cG9ydCB2YXIgZGlzYWR2YW50YWdlZERvdFNtYWxsID0gXCJEaXNhZHZhbnRhZ2VEb3QtbW9kdWxlLS1kaXNhZHZhbnRhZ2VkRG90U21hbGwtLTc1Tm1QXCI7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0ICogYXMgc3R5bGVzIGZyb20gJy4vRGlzYWR2YW50YWdlRG90Lm1vZHVsZS5zY3NzJztcblxuaW50ZXJmYWNlIElEaXNhZHZhbnRhZ2VEb3Qge1xuICBpc0Rpc2FkdmFudGFnZWQ/OiBib29sZWFuIHwgbnVsbDtcbiAgaXNCaWc/OiBib29sZWFuO1xufVxuY29uc3QgRGlzYWR2YW50YWdlRG90ID0gKHtpc0Rpc2FkdmFudGFnZWQgPSBmYWxzZSwgaXNCaWd9OklEaXNhZHZhbnRhZ2VEb3QpID0+IHtcbiAgbGV0IGNvbXB1dGVkQ2xhc3MgPSAnJztcblxuICBpZiAoaXNCaWcpIHtcbiAgICBjb21wdXRlZENsYXNzID0gc3R5bGVzLmRpc2FkdmFudGFnZWREb3RCaWc7XG4gIH0gZWxzZSB7XG4gICAgY29tcHV0ZWRDbGFzcyA9IGlzRGlzYWR2YW50YWdlZCA/IHN0eWxlcy5kaXNhZHZhbnRhZ2VkRG90U21hbGwgOiAnJztcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2NvbXB1dGVkQ2xhc3N9IC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEaXNhZHZhbnRhZ2VEb3Q7XG4iLCJpbXBvcnQgRGlzYWR2YW50YWdlRG90IGZyb20gJy4vRGlzYWR2YW50YWdlRG90JztcblxuZXhwb3J0IGRlZmF1bHQgRGlzYWR2YW50YWdlRG90O1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIGNhdGVnb3J5ID0gXCJDYXRlZ29yeS1tb2R1bGUtLWNhdGVnb3J5LS1RaXlHQlwiO1xuZXhwb3J0IHZhciBjYXRlZ29yeUNvbnRhaW5lciA9IFwiQ2F0ZWdvcnktbW9kdWxlLS1jYXRlZ29yeUNvbnRhaW5lci0taEpReWRcIjtcbmV4cG9ydCB2YXIgZGlzQ2F0ZWdvcnlDb250YWluZXIgPSBcIkNhdGVnb3J5LW1vZHVsZS0tZGlzQ2F0ZWdvcnlDb250YWluZXItLUs3Wml3XCI7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBEaXNhZHZhbnRhZ2VEb3QgZnJvbSAnLi4vRGlzYWR2YW50YWdlRG90JztcblxuaW1wb3J0ICogYXMgc3R5bGVzIGZyb20gJy4vQ2F0ZWdvcnkubW9kdWxlLnNjc3MnO1xuXG5pbnRlcmZhY2UgSUNhdGVnb3J5IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgaXNEaXNhZHZhbnRhZ2VkOiBib29sZWFuIHwgbnVsbDtcbn1cblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBjb250cm9scyB0aGUgQ2F0ZWdvcmllcyBvbiB0aGUgc2lkZSBwYW5lbC5cbiAqXG4gKiBUaGUgY2F0ZWdvcnkgd2lsbCBiZSBzdHlsZWQgZGlmZmVyZW50bHkgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uXG4gKiBpZiB0aGUgY2F0ZWdvcnkgaXMgZGlzYWR2YW50YWdlZCBvciBub3QuIFRoZSBKU1ggaW4gdGhlIHJldHVyblxuICogc3RhdGVtZW50IGlzIGlkZW50aWNhbCBob3dldmVyIGluIHRoZSBnbG9iYWwgQ1NTIGZpbGUsIHdlXG4gKiBvdmVycmlkZSB0aGUgZGlzYWR2YW50YWdlZCBjYXNlIHdpdGggYSBwc3VlZG8tc2VsZWN0b3IgKDpoYXMpIHRoYXRcbiAqIGlzIG5ldy4gSW4gb3JkZXIgdG8gZmFsbGJhY2sgZ3JhY2VmdWxseSBmb3IgYnJvd3NlcnMgdGhhdCBkb1xuICogbm90IHlldCBzdXBwb3J0IHRoZSBcIjpoYXNcIiBwc3VlZG8gc2VsZWN0b3IsIHRoaXMgcmVkdW5kYW50IEpTWFxuICogd2lsbCBhbGxvdyB0aGUgZGlzYWR2YW50YWdlZCBjYXNlIHNob3cgdGhlIG9sZGVyIGNhdGVnb3J5IHN0eWxpbmdcbiAqIHdoaWxlIGJyb3dzZXJzIHRoYXQgZG8gc3VwcG9ydCB0aGUgXCI6aGFzXCIgcHN1ZWRvIHNlbGVjdG9yIHdpbGxcbiAqIHJlbmRlciB0aGUgbmV3ZXIgY2F0ZWdvcnkgc3R5bGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNEaXNhZHZhZ3RhZ2VkXG4gKiBAcmV0dXJuIHtKU1guRWxlbWVudH1cbiAqL1xuY29uc3QgQ2F0ZWdvcnkgPSAoe25hbWUsIGlzRGlzYWR2YW50YWdlZH06SUNhdGVnb3J5KSA9PiB7XG4gIHJldHVybiBpc0Rpc2FkdmFudGFnZWQgPyAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5kaXNDYXRlZ29yeUNvbnRhaW5lcn0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNhdGVnb3J5fT5cbiAgICAgICAge25hbWV9XG4gICAgICA8L2Rpdj5cbiAgICAgIDxEaXNhZHZhbnRhZ2VEb3QgaXNEaXNhZHZhbnRhZ2VkPXtpc0Rpc2FkdmFudGFnZWR9Lz5cbiAgICA8L2Rpdj5cbiAgKSA6IChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNhdGVnb3J5Q29udGFpbmVyfT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY2F0ZWdvcnl9PlxuICAgICAgICB7bmFtZX1cbiAgICAgIDwvZGl2PlxuICAgICAgPERpc2FkdmFudGFnZURvdCBpc0Rpc2FkdmFudGFnZWQ9e2lzRGlzYWR2YW50YWdlZH0vPlxuICAgIDwvZGl2PlxuICApO1xufTtcbmV4cG9ydCBkZWZhdWx0IENhdGVnb3J5O1xuIiwiaW1wb3J0IENhdGVnb3J5IGZyb20gJy4vQ2F0ZWdvcnknO1xuXG5leHBvcnQgZGVmYXVsdCBDYXRlZ29yeTtcbiIsIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxuLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvIGltcGxlbWVudGF0aW9uLiBBbHNvLFxuLy8gZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIChtc0NyeXB0bykgb24gSUUxMS5cbnZhciBnZXRSYW5kb21WYWx1ZXMgPSB0eXBlb2YgY3J5cHRvICE9ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykgfHwgdHlwZW9mIG1zQ3J5cHRvICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0byk7XG52YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgfVxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn0iLCIvKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbnZhciBieXRlVG9IZXggPSBbXTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7IC8vIGpvaW4gdXNlZCB0byBmaXggbWVtb3J5IGlzc3VlIGNhdXNlZCBieSBjb25jYXRlbmF0aW9uOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTc1I2M0XG5cbiAgcmV0dXJuIFtidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJywgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV1dLmpvaW4oJycpO1xufVxuZXhwb3J0IGRlZmF1bHQgYnl0ZXNUb1V1aWQ7IiwiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgYnl0ZXNUb1V1aWQgZnJvbSAnLi9ieXRlc1RvVXVpZC5qcyc7XG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cbiAgcm5kc1s2XSA9IHJuZHNbNl0gJiAweDBmIHwgMHg0MDtcbiAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDsgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG5cbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgKytpaSkge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ1ZiB8fCBieXRlc1RvVXVpZChybmRzKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHY0OyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgdjQgfSBmcm9tICd1dWlkJztcbmZ1bmN0aW9uIG93bktleXMkMihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaSAlIDIgPyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyQyKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG4gIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgIHJlc3VsdDtcbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcbiAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKCFpdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChpdCkgbyA9IGl0O1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHM6IEYsXG4gICAgICAgIG46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0sXG4gICAgICAgIGY6IEZcbiAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuICB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsXG4gICAgZGlkRXJyID0gZmFsc2UsXG4gICAgZXJyO1xuICByZXR1cm4ge1xuICAgIHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGl0ID0gaXQuY2FsbChvKTtcbiAgICB9LFxuICAgIG46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGVwID0gaXQubmV4dCgpO1xuICAgICAgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTtcbiAgICAgIHJldHVybiBzdGVwO1xuICAgIH0sXG4gICAgZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgIGRpZEVyciA9IHRydWU7XG4gICAgICBlcnIgPSBlO1xuICAgIH0sXG4gICAgZjogZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChkaWRFcnIpIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwkYSA9XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZ2xvYmFsLXRoaXMgLS0gc2FmZVxuY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHwgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbmNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8IGNoZWNrKHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCkgfHxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0oKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xudmFyIG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHt9O1xudmFyIGZhaWxzJDkgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbnZhciBmYWlscyQ4ID0gZmFpbHMkOTtcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbnZhciBkZXNjcmlwdG9ycyA9ICFmYWlscyQ4KGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gNztcbiAgICB9XG4gIH0pWzFdICE9IDc7XG59KTtcbnZhciBmYWlscyQ3ID0gZmFpbHMkOTtcbnZhciBmdW5jdGlvbkJpbmROYXRpdmUgPSAhZmFpbHMkNyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG4gIHZhciB0ZXN0ID0gZnVuY3Rpb24gKCkgey8qIGVtcHR5ICovfS5iaW5kKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gdHlwZW9mIHRlc3QgIT0gJ2Z1bmN0aW9uJyB8fCB0ZXN0Lmhhc093blByb3BlcnR5KCdwcm90b3R5cGUnKTtcbn0pO1xudmFyIE5BVElWRV9CSU5EJDIgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG52YXIgY2FsbCQ0ID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG52YXIgZnVuY3Rpb25DYWxsID0gTkFUSVZFX0JJTkQkMiA/IGNhbGwkNC5iaW5kKGNhbGwkNCkgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYWxsJDQuYXBwbHkoY2FsbCQ0LCBhcmd1bWVudHMpO1xufTtcbnZhciBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoe1xuICAxOiAyXG59LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5vYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMiA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xudmFyIE5BVElWRV9CSU5EJDEgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUkMSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBjYWxsJDMgPSBGdW5jdGlvblByb3RvdHlwZSQxLmNhbGw7XG52YXIgdW5jdXJyeVRoaXNXaXRoQmluZCA9IE5BVElWRV9CSU5EJDEgJiYgRnVuY3Rpb25Qcm90b3R5cGUkMS5iaW5kLmJpbmQoY2FsbCQzLCBjYWxsJDMpO1xudmFyIGZ1bmN0aW9uVW5jdXJyeVRoaXNSYXcgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIE5BVElWRV9CSU5EJDEgPyB1bmN1cnJ5VGhpc1dpdGhCaW5kKGZuKSA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbCQzLmFwcGx5KGZuLCBhcmd1bWVudHMpO1xuICB9O1xufTtcbnZhciB1bmN1cnJ5VGhpc1JhdyQxID0gZnVuY3Rpb25VbmN1cnJ5VGhpc1JhdztcbnZhciB0b1N0cmluZyQxID0gdW5jdXJyeVRoaXNSYXckMSh7fS50b1N0cmluZyk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpc1JhdyQxKCcnLnNsaWNlKTtcbnZhciBjbGFzc29mUmF3JDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHN0cmluZ1NsaWNlKHRvU3RyaW5nJDEoaXQpLCA4LCAtMSk7XG59O1xudmFyIGNsYXNzb2ZSYXckMSA9IGNsYXNzb2ZSYXckMjtcbnZhciB1bmN1cnJ5VGhpc1JhdyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXNSYXc7XG52YXIgZnVuY3Rpb25VbmN1cnJ5VGhpcyA9IGZ1bmN0aW9uIChmbikge1xuICAvLyBOYXNob3JuIGJ1ZzpcbiAgLy8gICBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTEyOFxuICAvLyAgIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xMTMwXG4gIGlmIChjbGFzc29mUmF3JDEoZm4pID09PSAnRnVuY3Rpb24nKSByZXR1cm4gdW5jdXJyeVRoaXNSYXcoZm4pO1xufTtcbnZhciB1bmN1cnJ5VGhpcyQ5ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyQ2ID0gZmFpbHMkOTtcbnZhciBjbGFzc29mJDMgPSBjbGFzc29mUmF3JDI7XG52YXIgJE9iamVjdCQzID0gT2JqZWN0O1xudmFyIHNwbGl0ID0gdW5jdXJyeVRoaXMkOSgnJy5zcGxpdCk7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgaW5kZXhlZE9iamVjdCA9IGZhaWxzJDYoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gISRPYmplY3QkMygneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YkMyhpdCkgPT0gJ1N0cmluZycgPyBzcGxpdChpdCwgJycpIDogJE9iamVjdCQzKGl0KTtcbn0gOiAkT2JqZWN0JDM7XG5cbi8vIHdlIGNhbid0IHVzZSBqdXN0IGBpdCA9PSBudWxsYCBzaW5jZSBvZiBgZG9jdW1lbnQuYWxsYCBzcGVjaWFsIGNhc2Vcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtSXNIVE1MRERBLWludGVybmFsLXNsb3QtYWVjXG52YXIgaXNOdWxsT3JVbmRlZmluZWQkMiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IG51bGwgfHwgaXQgPT09IHVuZGVmaW5lZDtcbn07XG52YXIgaXNOdWxsT3JVbmRlZmluZWQkMSA9IGlzTnVsbE9yVW5kZWZpbmVkJDI7XG52YXIgJFR5cGVFcnJvciQ1ID0gVHlwZUVycm9yO1xuXG4vLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkJDEoaXQpKSB0aHJvdyAkVHlwZUVycm9yJDUoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJbmRleGVkT2JqZWN0JDEgPSBpbmRleGVkT2JqZWN0O1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkMjtcbnZhciB0b0luZGV4ZWRPYmplY3QkNCA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdCQxKHJlcXVpcmVPYmplY3RDb2VyY2libGUkMShpdCkpO1xufTtcbnZhciBkb2N1bWVudEFsbCQyID0gdHlwZW9mIGRvY3VtZW50ID09ICdvYmplY3QnICYmIGRvY3VtZW50LmFsbDtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1Jc0hUTUxEREEtaW50ZXJuYWwtc2xvdFxudmFyIElTX0hUTUxEREEgPSB0eXBlb2YgZG9jdW1lbnRBbGwkMiA9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudEFsbCQyICE9PSB1bmRlZmluZWQ7XG52YXIgZG9jdW1lbnRBbGxfMSA9IHtcbiAgYWxsOiBkb2N1bWVudEFsbCQyLFxuICBJU19IVE1MRERBOiBJU19IVE1MRERBXG59O1xudmFyICRkb2N1bWVudEFsbCQxID0gZG9jdW1lbnRBbGxfMTtcbnZhciBkb2N1bWVudEFsbCQxID0gJGRvY3VtZW50QWxsJDEuYWxsO1xuXG4vLyBgSXNDYWxsYWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcbnZhciBpc0NhbGxhYmxlJGMgPSAkZG9jdW1lbnRBbGwkMS5JU19IVE1MRERBID8gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJyB8fCBhcmd1bWVudCA9PT0gZG9jdW1lbnRBbGwkMTtcbn0gOiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nO1xufTtcbnZhciBpc0NhbGxhYmxlJGIgPSBpc0NhbGxhYmxlJGM7XG52YXIgJGRvY3VtZW50QWxsID0gZG9jdW1lbnRBbGxfMTtcbnZhciBkb2N1bWVudEFsbCA9ICRkb2N1bWVudEFsbC5hbGw7XG52YXIgaXNPYmplY3QkNiA9ICRkb2N1bWVudEFsbC5JU19IVE1MRERBID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IGlzQ2FsbGFibGUkYihpdCkgfHwgaXQgPT09IGRvY3VtZW50QWxsO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlJGIoaXQpO1xufTtcbnZhciBnbG9iYWwkOSA9IGdsb2JhbCRhO1xudmFyIGlzQ2FsbGFibGUkYSA9IGlzQ2FsbGFibGUkYztcbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkYShhcmd1bWVudCkgPyBhcmd1bWVudCA6IHVuZGVmaW5lZDtcbn07XG52YXIgZ2V0QnVpbHRJbiQ1ID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWwkOVtuYW1lc3BhY2VdKSA6IGdsb2JhbCQ5W25hbWVzcGFjZV0gJiYgZ2xvYmFsJDlbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcbnZhciB1bmN1cnJ5VGhpcyQ4ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBvYmplY3RJc1Byb3RvdHlwZU9mID0gdW5jdXJyeVRoaXMkOCh7fS5pc1Byb3RvdHlwZU9mKTtcbnZhciBnZXRCdWlsdEluJDQgPSBnZXRCdWlsdEluJDU7XG52YXIgZW5naW5lVXNlckFnZW50ID0gZ2V0QnVpbHRJbiQ0KCduYXZpZ2F0b3InLCAndXNlckFnZW50JykgfHwgJyc7XG52YXIgZ2xvYmFsJDggPSBnbG9iYWwkYTtcbnZhciB1c2VyQWdlbnQgPSBlbmdpbmVVc2VyQWdlbnQ7XG52YXIgcHJvY2VzcyA9IGdsb2JhbCQ4LnByb2Nlc3M7XG52YXIgRGVubyA9IGdsb2JhbCQ4LkRlbm87XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnMgfHwgRGVubyAmJiBEZW5vLnZlcnNpb247XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gIC8vIGluIG9sZCBDaHJvbWUsIHZlcnNpb25zIG9mIFY4IGlzbid0IFY4ID0gQ2hyb21lIC8gMTBcbiAgLy8gYnV0IHRoZWlyIGNvcnJlY3QgdmVyc2lvbnMgYXJlIG5vdCBpbnRlcmVzdGluZyBmb3IgdXNcbiAgdmVyc2lvbiA9IG1hdGNoWzBdID4gMCAmJiBtYXRjaFswXSA8IDQgPyAxIDogKyhtYXRjaFswXSArIG1hdGNoWzFdKTtcbn1cblxuLy8gQnJvd3NlckZTIE5vZGVKUyBgcHJvY2Vzc2AgcG9seWZpbGwgaW5jb3JyZWN0bHkgc2V0IGAudjhgIHRvIGAwLjBgXG4vLyBzbyBjaGVjayBgdXNlckFnZW50YCBldmVuIGlmIGAudjhgIGV4aXN0cywgYnV0IDBcbmlmICghdmVyc2lvbiAmJiB1c2VyQWdlbnQpIHtcbiAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0VkZ2VcXC8oXFxkKykvKTtcbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xuICAgIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICBpZiAobWF0Y2gpIHZlcnNpb24gPSArbWF0Y2hbMV07XG4gIH1cbn1cbnZhciBlbmdpbmVWOFZlcnNpb24gPSB2ZXJzaW9uO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cblxudmFyIFY4X1ZFUlNJT04gPSBlbmdpbmVWOFZlcnNpb247XG52YXIgZmFpbHMkNSA9IGZhaWxzJDk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgc3ltYm9sQ29uc3RydWN0b3JEZXRlY3Rpb24gPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzJDUoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG4gIC8vIGBnZXQtb3duLXByb3BlcnR5LXN5bWJvbHNgIHBvbHlmaWxsIHN5bWJvbHMgY29udmVydGVkIHRvIG9iamVjdCBhcmUgbm90IFN5bWJvbCBpbnN0YW5jZXNcbiAgcmV0dXJuICFTdHJpbmcoc3ltYm9sKSB8fCAhKE9iamVjdChzeW1ib2wpIGluc3RhbmNlb2YgU3ltYm9sKSB8fFxuICAvLyBDaHJvbWUgMzgtNDAgc3ltYm9scyBhcmUgbm90IGluaGVyaXRlZCBmcm9tIERPTSBjb2xsZWN0aW9ucyBwcm90b3R5cGVzIHRvIGluc3RhbmNlc1xuICAhU3ltYm9sLnNoYW0gJiYgVjhfVkVSU0lPTiAmJiBWOF9WRVJTSU9OIDwgNDE7XG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cbnZhciBOQVRJVkVfU1lNQk9MJDEgPSBzeW1ib2xDb25zdHJ1Y3RvckRldGVjdGlvbjtcbnZhciB1c2VTeW1ib2xBc1VpZCA9IE5BVElWRV9TWU1CT0wkMSAmJiAhU3ltYm9sLnNoYW0gJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcbnZhciBnZXRCdWlsdEluJDMgPSBnZXRCdWlsdEluJDU7XG52YXIgaXNDYWxsYWJsZSQ5ID0gaXNDYWxsYWJsZSRjO1xudmFyIGlzUHJvdG90eXBlT2YgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEJDEgPSB1c2VTeW1ib2xBc1VpZDtcbnZhciAkT2JqZWN0JDIgPSBPYmplY3Q7XG52YXIgaXNTeW1ib2wkMiA9IFVTRV9TWU1CT0xfQVNfVUlEJDEgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyICRTeW1ib2wgPSBnZXRCdWlsdEluJDMoJ1N5bWJvbCcpO1xuICByZXR1cm4gaXNDYWxsYWJsZSQ5KCRTeW1ib2wpICYmIGlzUHJvdG90eXBlT2YoJFN5bWJvbC5wcm90b3R5cGUsICRPYmplY3QkMihpdCkpO1xufTtcbnZhciAkU3RyaW5nJDEgPSBTdHJpbmc7XG52YXIgdHJ5VG9TdHJpbmckMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB0cnkge1xuICAgIHJldHVybiAkU3RyaW5nJDEoYXJndW1lbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxufTtcbnZhciBpc0NhbGxhYmxlJDggPSBpc0NhbGxhYmxlJGM7XG52YXIgdHJ5VG9TdHJpbmcgPSB0cnlUb1N0cmluZyQxO1xudmFyICRUeXBlRXJyb3IkNCA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDYWxsYWJsZShhcmd1bWVudCkgaXMgdHJ1ZWBcbnZhciBhQ2FsbGFibGUkMiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDYWxsYWJsZSQ4KGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJDQodHJ5VG9TdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xufTtcbnZhciBhQ2FsbGFibGUkMSA9IGFDYWxsYWJsZSQyO1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQkMjtcblxuLy8gYEdldE1ldGhvZGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxudmFyIGdldE1ldGhvZCQxID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgdmFyIGZ1bmMgPSBWW1BdO1xuICByZXR1cm4gaXNOdWxsT3JVbmRlZmluZWQoZnVuYykgPyB1bmRlZmluZWQgOiBhQ2FsbGFibGUkMShmdW5jKTtcbn07XG52YXIgY2FsbCQyID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzQ2FsbGFibGUkNyA9IGlzQ2FsbGFibGUkYztcbnZhciBpc09iamVjdCQ1ID0gaXNPYmplY3QkNjtcbnZhciAkVHlwZUVycm9yJDMgPSBUeXBlRXJyb3I7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUkMSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkNyhmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkNSh2YWwgPSBjYWxsJDIoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChpc0NhbGxhYmxlJDcoZm4gPSBpbnB1dC52YWx1ZU9mKSAmJiAhaXNPYmplY3QkNSh2YWwgPSBjYWxsJDIoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlJDcoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0JDUodmFsID0gY2FsbCQyKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyAkVHlwZUVycm9yJDMoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xudmFyIHNoYXJlZCQzID0ge1xuICBleHBvcnRzOiB7fVxufTtcbnZhciBnbG9iYWwkNyA9IGdsb2JhbCRhO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSQyID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGRlZmluZVByb3BlcnR5JDIoZ2xvYmFsJDcsIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBnbG9iYWwkN1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBnbG9iYWwkNiA9IGdsb2JhbCRhO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDIgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlJDMgPSBnbG9iYWwkNltTSEFSRURdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5JDIoU0hBUkVELCB7fSk7XG52YXIgc2hhcmVkU3RvcmUgPSBzdG9yZSQzO1xudmFyIHN0b3JlJDIgPSBzaGFyZWRTdG9yZTtcbihzaGFyZWQkMy5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlJDJba2V5XSB8fCAoc3RvcmUkMltrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4yNS41JyxcbiAgbW9kZTogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTQtMjAyMiBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KScsXG4gIGxpY2Vuc2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iL3YzLjI1LjUvTElDRU5TRScsXG4gIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xufSk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkMjtcbnZhciAkT2JqZWN0JDEgPSBPYmplY3Q7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG52YXIgdG9PYmplY3QkMiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gJE9iamVjdCQxKHJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpKTtcbn07XG52YXIgdW5jdXJyeVRoaXMkNyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9PYmplY3QkMSA9IHRvT2JqZWN0JDI7XG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyQ3KHt9Lmhhc093blByb3BlcnR5KTtcblxuLy8gYEhhc093blByb3BlcnR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaGFzb3ducHJvcGVydHlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaGFzb3duIC0tIHNhZmVcbnZhciBoYXNPd25Qcm9wZXJ0eV8xID0gT2JqZWN0Lmhhc093biB8fCBmdW5jdGlvbiBoYXNPd24oaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodG9PYmplY3QkMShpdCksIGtleSk7XG59O1xudmFyIHVuY3VycnlUaGlzJDYgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcbnZhciB0b1N0cmluZyA9IHVuY3VycnlUaGlzJDYoMS4wLnRvU3RyaW5nKTtcbnZhciB1aWQkMiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyB0b1N0cmluZygrK2lkICsgcG9zdGZpeCwgMzYpO1xufTtcbnZhciBnbG9iYWwkNSA9IGdsb2JhbCRhO1xudmFyIHNoYXJlZCQyID0gc2hhcmVkJDMuZXhwb3J0cztcbnZhciBoYXNPd24kNiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdWlkJDEgPSB1aWQkMjtcbnZhciBOQVRJVkVfU1lNQk9MID0gc3ltYm9sQ29uc3RydWN0b3JEZXRlY3Rpb247XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSB1c2VTeW1ib2xBc1VpZDtcbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQkMignd2tzJyk7XG52YXIgU3ltYm9sJDEgPSBnbG9iYWwkNS5TeW1ib2w7XG52YXIgc3ltYm9sRm9yID0gU3ltYm9sJDEgJiYgU3ltYm9sJDFbJ2ZvciddO1xudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEID8gU3ltYm9sJDEgOiBTeW1ib2wkMSAmJiBTeW1ib2wkMS53aXRob3V0U2V0dGVyIHx8IHVpZCQxO1xudmFyIHdlbGxLbm93blN5bWJvbCQ1ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXNPd24kNihXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpIHx8ICEoTkFUSVZFX1NZTUJPTCB8fCB0eXBlb2YgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID09ICdzdHJpbmcnKSkge1xuICAgIHZhciBkZXNjcmlwdGlvbiA9ICdTeW1ib2wuJyArIG5hbWU7XG4gICAgaWYgKE5BVElWRV9TWU1CT0wgJiYgaGFzT3duJDYoU3ltYm9sJDEsIG5hbWUpKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBTeW1ib2wkMVtuYW1lXTtcbiAgICB9IGVsc2UgaWYgKFVTRV9TWU1CT0xfQVNfVUlEICYmIHN5bWJvbEZvcikge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gc3ltYm9sRm9yKGRlc2NyaXB0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gY3JlYXRlV2VsbEtub3duU3ltYm9sKGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXTtcbn07XG52YXIgY2FsbCQxID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzT2JqZWN0JDQgPSBpc09iamVjdCQ2O1xudmFyIGlzU3ltYm9sJDEgPSBpc1N5bWJvbCQyO1xudmFyIGdldE1ldGhvZCA9IGdldE1ldGhvZCQxO1xudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSBvcmRpbmFyeVRvUHJpbWl0aXZlJDE7XG52YXIgd2VsbEtub3duU3ltYm9sJDQgPSB3ZWxsS25vd25TeW1ib2wkNTtcbnZhciAkVHlwZUVycm9yJDIgPSBUeXBlRXJyb3I7XG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sJDQoJ3RvUHJpbWl0aXZlJyk7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG52YXIgdG9QcmltaXRpdmUkMSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICBpZiAoIWlzT2JqZWN0JDQoaW5wdXQpIHx8IGlzU3ltYm9sJDEoaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBleG90aWNUb1ByaW0gPSBnZXRNZXRob2QoaW5wdXQsIFRPX1BSSU1JVElWRSk7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChleG90aWNUb1ByaW0pIHtcbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xuICAgIHJlc3VsdCA9IGNhbGwkMShleG90aWNUb1ByaW0sIGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0JDQocmVzdWx0KSB8fCBpc1N5bWJvbCQxKHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgdGhyb3cgJFR5cGVFcnJvciQyKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcbnZhciB0b1ByaW1pdGl2ZSA9IHRvUHJpbWl0aXZlJDE7XG52YXIgaXNTeW1ib2wgPSBpc1N5bWJvbCQyO1xuXG4vLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcbnZhciB0b1Byb3BlcnR5S2V5JDIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCAnc3RyaW5nJyk7XG4gIHJldHVybiBpc1N5bWJvbChrZXkpID8ga2V5IDoga2V5ICsgJyc7XG59O1xudmFyIGdsb2JhbCQ0ID0gZ2xvYmFsJGE7XG52YXIgaXNPYmplY3QkMyA9IGlzT2JqZWN0JDY7XG52YXIgZG9jdW1lbnQkMSA9IGdsb2JhbCQ0LmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgRVhJU1RTJDEgPSBpc09iamVjdCQzKGRvY3VtZW50JDEpICYmIGlzT2JqZWN0JDMoZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KTtcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTJDEgPyBkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xudmFyIERFU0NSSVBUT1JTJDcgPSBkZXNjcmlwdG9ycztcbnZhciBmYWlscyQ0ID0gZmFpbHMkOTtcbnZhciBjcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDE7XG5cbi8vIFRoYW5rcyB0byBJRTggZm9yIGl0cyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxudmFyIGllOERvbURlZmluZSA9ICFERVNDUklQVE9SUyQ3ICYmICFmYWlscyQ0KGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiA3O1xuICAgIH1cbiAgfSkuYSAhPSA3O1xufSk7XG52YXIgREVTQ1JJUFRPUlMkNiA9IGRlc2NyaXB0b3JzO1xudmFyIGNhbGwgPSBmdW5jdGlvbkNhbGw7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyO1xudmFyIHRvSW5kZXhlZE9iamVjdCQzID0gdG9JbmRleGVkT2JqZWN0JDQ7XG52YXIgdG9Qcm9wZXJ0eUtleSQxID0gdG9Qcm9wZXJ0eUtleSQyO1xudmFyIGhhc093biQ1ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBJRThfRE9NX0RFRklORSQxID0gaWU4RG9tRGVmaW5lO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5vYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZiA9IERFU0NSSVBUT1JTJDYgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0JDMoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDEoUCk7XG4gIGlmIChJRThfRE9NX0RFRklORSQxKSB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7LyogZW1wdHkgKi99XG4gIGlmIChoYXNPd24kNShPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxKCFjYWxsKHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYsIE8sIFApLCBPW1BdKTtcbn07XG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydHkgPSB7fTtcbnZhciBERVNDUklQVE9SUyQ1ID0gZGVzY3JpcHRvcnM7XG52YXIgZmFpbHMkMyA9IGZhaWxzJDk7XG5cbi8vIFY4IH4gQ2hyb21lIDM2LVxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzMzNFxudmFyIHY4UHJvdG90eXBlRGVmaW5lQnVnID0gREVTQ1JJUFRPUlMkNSAmJiBmYWlscyQzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHsvKiBlbXB0eSAqL30sICdwcm90b3R5cGUnLCB7XG4gICAgdmFsdWU6IDQyLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KS5wcm90b3R5cGUgIT0gNDI7XG59KTtcbnZhciBpc09iamVjdCQyID0gaXNPYmplY3QkNjtcbnZhciAkU3RyaW5nID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IkMSA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogVHlwZShhcmd1bWVudCkgaXMgT2JqZWN0YFxudmFyIGFuT2JqZWN0JDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzT2JqZWN0JDIoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkMSgkU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcbnZhciBERVNDUklQVE9SUyQ0ID0gZGVzY3JpcHRvcnM7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBpZThEb21EZWZpbmU7XG52YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUckMSA9IHY4UHJvdG90eXBlRGVmaW5lQnVnO1xudmFyIGFuT2JqZWN0JDMgPSBhbk9iamVjdCQ0O1xudmFyIHRvUHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5JDI7XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBFTlVNRVJBQkxFID0gJ2VudW1lcmFibGUnO1xudmFyIENPTkZJR1VSQUJMRSQxID0gJ2NvbmZpZ3VyYWJsZSc7XG52YXIgV1JJVEFCTEUgPSAnd3JpdGFibGUnO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG5vYmplY3REZWZpbmVQcm9wZXJ0eS5mID0gREVTQ1JJUFRPUlMkNCA/IFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHJDEgPyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0JDMoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdCQzKEF0dHJpYnV0ZXMpO1xuICBpZiAodHlwZW9mIE8gPT09ICdmdW5jdGlvbicgJiYgUCA9PT0gJ3Byb3RvdHlwZScgJiYgJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzICYmIFdSSVRBQkxFIGluIEF0dHJpYnV0ZXMgJiYgIUF0dHJpYnV0ZXNbV1JJVEFCTEVdKSB7XG4gICAgdmFyIGN1cnJlbnQgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnRbV1JJVEFCTEVdKSB7XG4gICAgICBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgICAgIEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogQ09ORklHVVJBQkxFJDEgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFJDFdIDogY3VycmVudFtDT05GSUdVUkFCTEUkMV0sXG4gICAgICAgIGVudW1lcmFibGU6IEVOVU1FUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbRU5VTUVSQUJMRV0gOiBjdXJyZW50W0VOVU1FUkFCTEVdLFxuICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG59IDogJGRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdCQzKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QkMyhBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7LyogZW1wdHkgKi99XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93ICRUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG52YXIgREVTQ1JJUFRPUlMkMyA9IGRlc2NyaXB0b3JzO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDMgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMiA9IERFU0NSSVBUT1JTJDMgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG52YXIgbWFrZUJ1aWx0SW4kMiA9IHtcbiAgZXhwb3J0czoge31cbn07XG52YXIgREVTQ1JJUFRPUlMkMiA9IGRlc2NyaXB0b3JzO1xudmFyIGhhc093biQ0ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMkMiAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIEVYSVNUUyA9IGhhc093biQ0KEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpO1xuLy8gYWRkaXRpb25hbCBwcm90ZWN0aW9uIGZyb20gbWluaWZpZWQgLyBtYW5nbGVkIC8gZHJvcHBlZCBmdW5jdGlvbiBuYW1lc1xudmFyIFBST1BFUiA9IEVYSVNUUyAmJiBmdW5jdGlvbiBzb21ldGhpbmcoKSB7LyogZW1wdHkgKi99Lm5hbWUgPT09ICdzb21ldGhpbmcnO1xudmFyIENPTkZJR1VSQUJMRSA9IEVYSVNUUyAmJiAoIURFU0NSSVBUT1JTJDIgfHwgREVTQ1JJUFRPUlMkMiAmJiBnZXREZXNjcmlwdG9yKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpLmNvbmZpZ3VyYWJsZSk7XG52YXIgZnVuY3Rpb25OYW1lID0ge1xuICBFWElTVFM6IEVYSVNUUyxcbiAgUFJPUEVSOiBQUk9QRVIsXG4gIENPTkZJR1VSQUJMRTogQ09ORklHVVJBQkxFXG59O1xudmFyIHVuY3VycnlUaGlzJDUgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzQ2FsbGFibGUkNiA9IGlzQ2FsbGFibGUkYztcbnZhciBzdG9yZSQxID0gc2hhcmVkU3RvcmU7XG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IHVuY3VycnlUaGlzJDUoRnVuY3Rpb24udG9TdHJpbmcpO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAoIWlzQ2FsbGFibGUkNihzdG9yZSQxLmluc3BlY3RTb3VyY2UpKSB7XG4gIHN0b3JlJDEuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nKGl0KTtcbiAgfTtcbn1cbnZhciBpbnNwZWN0U291cmNlJDIgPSBzdG9yZSQxLmluc3BlY3RTb3VyY2U7XG52YXIgZ2xvYmFsJDMgPSBnbG9iYWwkYTtcbnZhciBpc0NhbGxhYmxlJDUgPSBpc0NhbGxhYmxlJGM7XG52YXIgV2Vha01hcCQxID0gZ2xvYmFsJDMuV2Vha01hcDtcbnZhciB3ZWFrTWFwQmFzaWNEZXRlY3Rpb24gPSBpc0NhbGxhYmxlJDUoV2Vha01hcCQxKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoU3RyaW5nKFdlYWtNYXAkMSkpO1xudmFyIHNoYXJlZCQxID0gc2hhcmVkJDMuZXhwb3J0cztcbnZhciB1aWQgPSB1aWQkMjtcbnZhciBrZXlzID0gc2hhcmVkJDEoJ2tleXMnKTtcbnZhciBzaGFyZWRLZXkkMiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xufTtcbnZhciBoaWRkZW5LZXlzJDQgPSB7fTtcbnZhciBOQVRJVkVfV0VBS19NQVAgPSB3ZWFrTWFwQmFzaWNEZXRlY3Rpb247XG52YXIgZ2xvYmFsJDIgPSBnbG9iYWwkYTtcbnZhciBpc09iamVjdCQxID0gaXNPYmplY3QkNjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyO1xudmFyIGhhc093biQzID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBzaGFyZWQgPSBzaGFyZWRTdG9yZTtcbnZhciBzaGFyZWRLZXkkMSA9IHNoYXJlZEtleSQyO1xudmFyIGhpZGRlbktleXMkMyA9IGhpZGRlbktleXMkNDtcbnZhciBPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCA9ICdPYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZCc7XG52YXIgVHlwZUVycm9yJDEgPSBnbG9iYWwkMi5UeXBlRXJyb3I7XG52YXIgV2Vha01hcCA9IGdsb2JhbCQyLldlYWtNYXA7XG52YXIgc2V0LCBnZXQsIGhhcztcbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QkMShpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yJDEoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZC5zdGF0ZSkge1xuICB2YXIgc3RvcmUgPSBzaGFyZWQuc3RhdGUgfHwgKHNoYXJlZC5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWFzc2lnbiAtLSBwcm90b3R5cGUgbWV0aG9kcyBwcm90ZWN0aW9uICovXG4gIHN0b3JlLmdldCA9IHN0b3JlLmdldDtcbiAgc3RvcmUuaGFzID0gc3RvcmUuaGFzO1xuICBzdG9yZS5zZXQgPSBzdG9yZS5zZXQ7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1hc3NpZ24gLS0gcHJvdG90eXBlIG1ldGhvZHMgcHJvdGVjdGlvbiAqL1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKHN0b3JlLmhhcyhpdCkpIHRocm93IFR5cGVFcnJvciQxKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICBzdG9yZS5zZXQoaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBzdG9yZS5nZXQoaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gc3RvcmUuaGFzKGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSQxKCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzJDNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChoYXNPd24kMyhpdCwgU1RBVEUpKSB0aHJvdyBUeXBlRXJyb3IkMShPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDMoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDMoaXQsIFNUQVRFKTtcbiAgfTtcbn1cbnZhciBpbnRlcm5hbFN0YXRlID0ge1xuICBzZXQ6IHNldCxcbiAgZ2V0OiBnZXQsXG4gIGhhczogaGFzLFxuICBlbmZvcmNlOiBlbmZvcmNlLFxuICBnZXR0ZXJGb3I6IGdldHRlckZvclxufTtcbnZhciBmYWlscyQyID0gZmFpbHMkOTtcbnZhciBpc0NhbGxhYmxlJDQgPSBpc0NhbGxhYmxlJGM7XG52YXIgaGFzT3duJDIgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIERFU0NSSVBUT1JTJDEgPSBkZXNjcmlwdG9ycztcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSA9IGZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XG52YXIgaW5zcGVjdFNvdXJjZSQxID0gaW5zcGVjdFNvdXJjZSQyO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBpbnRlcm5hbFN0YXRlO1xudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5lbmZvcmNlO1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgQ09ORklHVVJBQkxFX0xFTkdUSCA9IERFU0NSSVBUT1JTJDEgJiYgIWZhaWxzJDIoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkkMShmdW5jdGlvbiAoKSB7LyogZW1wdHkgKi99LCAnbGVuZ3RoJywge1xuICAgIHZhbHVlOiA4XG4gIH0pLmxlbmd0aCAhPT0gODtcbn0pO1xudmFyIFRFTVBMQVRFID0gU3RyaW5nKFN0cmluZykuc3BsaXQoJ1N0cmluZycpO1xudmFyIG1ha2VCdWlsdEluJDEgPSBtYWtlQnVpbHRJbiQyLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKFN0cmluZyhuYW1lKS5zbGljZSgwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XG4gICAgbmFtZSA9ICdbJyArIFN0cmluZyhuYW1lKS5yZXBsYWNlKC9eU3ltYm9sXFwoKFteKV0qKVxcKS8sICckMScpICsgJ10nO1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2V0dGVyKSBuYW1lID0gJ2dldCAnICsgbmFtZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXR0ZXIpIG5hbWUgPSAnc2V0ICcgKyBuYW1lO1xuICBpZiAoIWhhc093biQyKHZhbHVlLCAnbmFtZScpIHx8IENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FICYmIHZhbHVlLm5hbWUgIT09IG5hbWUpIHtcbiAgICBpZiAoREVTQ1JJUFRPUlMkMSkgZGVmaW5lUHJvcGVydHkkMSh2YWx1ZSwgJ25hbWUnLCB7XG4gICAgICB2YWx1ZTogbmFtZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO2Vsc2UgdmFsdWUubmFtZSA9IG5hbWU7XG4gIH1cbiAgaWYgKENPTkZJR1VSQUJMRV9MRU5HVEggJiYgb3B0aW9ucyAmJiBoYXNPd24kMihvcHRpb25zLCAnYXJpdHknKSAmJiB2YWx1ZS5sZW5ndGggIT09IG9wdGlvbnMuYXJpdHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQxKHZhbHVlLCAnbGVuZ3RoJywge1xuICAgICAgdmFsdWU6IG9wdGlvbnMuYXJpdHlcbiAgICB9KTtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHRpb25zICYmIGhhc093biQyKG9wdGlvbnMsICdjb25zdHJ1Y3RvcicpICYmIG9wdGlvbnMuY29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChERVNDUklQVE9SUyQxKSBkZWZpbmVQcm9wZXJ0eSQxKHZhbHVlLCAncHJvdG90eXBlJywge1xuICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgLy8gaW4gVjggfiBDaHJvbWUgNTMsIHByb3RvdHlwZXMgb2Ygc29tZSBtZXRob2RzLCBsaWtlIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCwgYXJlIG5vbi13cml0YWJsZVxuICAgIH0gZWxzZSBpZiAodmFsdWUucHJvdG90eXBlKSB2YWx1ZS5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7LyogZW1wdHkgKi99XG4gIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKTtcbiAgaWYgKCFoYXNPd24kMihzdGF0ZSwgJ3NvdXJjZScpKSB7XG4gICAgc3RhdGUuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyA/IG5hbWUgOiAnJyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0ZW5kLW5hdGl2ZSAtLSByZXF1aXJlZFxuRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gbWFrZUJ1aWx0SW4kMShmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkNCh0aGlzKSAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlJDEodGhpcyk7XG59LCAndG9TdHJpbmcnKTtcbnZhciBpc0NhbGxhYmxlJDMgPSBpc0NhbGxhYmxlJGM7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMiA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIG1ha2VCdWlsdEluID0gbWFrZUJ1aWx0SW4kMi5leHBvcnRzO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDEgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xudmFyIGRlZmluZUJ1aWx0SW4kMSA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucy5lbnVtZXJhYmxlO1xuICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uYW1lIDoga2V5O1xuICBpZiAoaXNDYWxsYWJsZSQzKHZhbHVlKSkgbWFrZUJ1aWx0SW4odmFsdWUsIG5hbWUsIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5nbG9iYWwpIHtcbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtlbHNlIGRlZmluZUdsb2JhbFByb3BlcnR5JDEoa2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghb3B0aW9ucy51bnNhZmUpIGRlbGV0ZSBPW2tleV07ZWxzZSBpZiAoT1trZXldKSBzaW1wbGUgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7LyogZW1wdHkgKi99XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7ZWxzZSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQyLmYoTywga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIW9wdGlvbnMubm9uQ29uZmlndXJhYmxlLFxuICAgICAgd3JpdGFibGU6ICFvcHRpb25zLm5vbldyaXRhYmxlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIE87XG59O1xudmFyIG9iamVjdEdldE93blByb3BlcnR5TmFtZXMgPSB7fTtcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxuLy8gYE1hdGgudHJ1bmNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLnRydW5jXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tbWF0aC10cnVuYyAtLSBzYWZlXG52YXIgbWF0aFRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiB0cnVuYyh4KSB7XG4gIHZhciBuID0gK3g7XG4gIHJldHVybiAobiA+IDAgPyBmbG9vciA6IGNlaWwpKG4pO1xufTtcbnZhciB0cnVuYyA9IG1hdGhUcnVuYztcblxuLy8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogdHJ1bmMobnVtYmVyKTtcbn07XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQxID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQyO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiQxID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbnZhciB0b0Fic29sdXRlSW5kZXgkMSA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQxKGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluJDEoaW50ZWdlciwgbGVuZ3RoKTtcbn07XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHRvSW50ZWdlck9ySW5maW5pdHkkMjtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9sZW5ndGhcbnZhciB0b0xlbmd0aCQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4odG9JbnRlZ2VyT3JJbmZpbml0eShhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbnZhciB0b0xlbmd0aCA9IHRvTGVuZ3RoJDE7XG5cbi8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvTGVuZ3RoKG9iai5sZW5ndGgpO1xufTtcbnZhciB0b0luZGV4ZWRPYmplY3QkMiA9IHRvSW5kZXhlZE9iamVjdCQ0O1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHRvQWJzb2x1dGVJbmRleCQxO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDEgPSBsZW5ndGhPZkFycmF5TGlrZSQyO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCQxID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQyKCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkMShPKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcbnZhciBhcnJheUluY2x1ZGVzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCQxKHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZCQxKGZhbHNlKVxufTtcbnZhciB1bmN1cnJ5VGhpcyQ0ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBoYXNPd24kMSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdG9JbmRleGVkT2JqZWN0JDEgPSB0b0luZGV4ZWRPYmplY3QkNDtcbnZhciBpbmRleE9mID0gYXJyYXlJbmNsdWRlcy5pbmRleE9mO1xudmFyIGhpZGRlbktleXMkMiA9IGhpZGRlbktleXMkNDtcbnZhciBwdXNoJDEgPSB1bmN1cnJ5VGhpcyQ0KFtdLnB1c2gpO1xudmFyIG9iamVjdEtleXNJbnRlcm5hbCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JbmRleGVkT2JqZWN0JDEob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pICFoYXNPd24kMShoaWRkZW5LZXlzJDIsIGtleSkgJiYgaGFzT3duJDEoTywga2V5KSAmJiBwdXNoJDEocmVzdWx0LCBrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzT3duJDEoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcHVzaCQxKHJlc3VsdCwga2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG52YXIgZW51bUJ1Z0tleXMkMyA9IFsnY29uc3RydWN0b3InLCAnaGFzT3duUHJvcGVydHknLCAnaXNQcm90b3R5cGVPZicsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICd0b0xvY2FsZVN0cmluZycsICd0b1N0cmluZycsICd2YWx1ZU9mJ107XG52YXIgaW50ZXJuYWxPYmplY3RLZXlzJDEgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG52YXIgZW51bUJ1Z0tleXMkMiA9IGVudW1CdWdLZXlzJDM7XG52YXIgaGlkZGVuS2V5cyQxID0gZW51bUJ1Z0tleXMkMi5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5vYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyQxKE8sIGhpZGRlbktleXMkMSk7XG59O1xudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSBzYWZlXG5vYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0QnVpbHRJbiQyID0gZ2V0QnVpbHRJbiQ1O1xudmFyIHVuY3VycnlUaGlzJDMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBhbk9iamVjdCQyID0gYW5PYmplY3QkNDtcbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyQzKFtdLmNvbmNhdCk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBvd25LZXlzJDEgPSBnZXRCdWlsdEluJDIoJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QkMihpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQoa2V5cywgZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcbnZhciBoYXNPd24gPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIG93bktleXMgPSBvd25LZXlzJDE7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzJDEgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGV4Y2VwdGlvbnMpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlJDEuZjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkgJiYgIShleGNlcHRpb25zICYmIGhhc093bihleGNlcHRpb25zLCBrZXkpKSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH1cbiAgfVxufTtcbnZhciBmYWlscyQxID0gZmFpbHMkOTtcbnZhciBpc0NhbGxhYmxlJDIgPSBpc0NhbGxhYmxlJGM7XG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xudmFyIGlzRm9yY2VkJDEgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZSA6IHZhbHVlID09IE5BVElWRSA/IGZhbHNlIDogaXNDYWxsYWJsZSQyKGRldGVjdGlvbikgPyBmYWlscyQxKGRldGVjdGlvbikgOiAhIWRldGVjdGlvbjtcbn07XG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQkMS5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG59O1xudmFyIGRhdGEgPSBpc0ZvcmNlZCQxLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZCQxLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkJDEuUE9MWUZJTEwgPSAnUCc7XG52YXIgaXNGb3JjZWRfMSA9IGlzRm9yY2VkJDE7XG52YXIgZ2xvYmFsJDEgPSBnbG9iYWwkYTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMjtcbnZhciBkZWZpbmVCdWlsdEluID0gZGVmaW5lQnVpbHRJbiQxO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQxO1xudmFyIGlzRm9yY2VkID0gaXNGb3JjZWRfMTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgICAgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5kb250Q2FsbEdldFNldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiAgb3B0aW9ucy5uYW1lICAgICAgICAgICAtIHRoZSAubmFtZSBvZiB0aGUgZnVuY3Rpb24gaWYgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGtleVxuKi9cbnZhciBfZXhwb3J0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbCQxO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbCQxW1RBUkdFVF0gfHwgZGVmaW5lR2xvYmFsUHJvcGVydHkoVEFSR0VULCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gKGdsb2JhbCQxW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLmRvbnRDYWxsR2V0U2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgICB9XG4gICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgdGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICBkZWZpbmVCdWlsdEluKHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG52YXIgdW5jdXJyeVRoaXMkMiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgYUNhbGxhYmxlID0gYUNhbGxhYmxlJDI7XG52YXIgTkFUSVZFX0JJTkQgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG52YXIgYmluZCQxID0gdW5jdXJyeVRoaXMkMih1bmN1cnJ5VGhpcyQyLmJpbmQpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBmdW5jdGlvbkJpbmRDb250ZXh0ID0gZnVuY3Rpb24gKGZuLCB0aGF0KSB7XG4gIGFDYWxsYWJsZShmbik7XG4gIHJldHVybiB0aGF0ID09PSB1bmRlZmluZWQgPyBmbiA6IE5BVElWRV9CSU5EID8gYmluZCQxKGZuLCB0aGF0KSA6IGZ1bmN0aW9uIC8qIC4uLmFyZ3MgKi9cbiAgKCkge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbnZhciBjbGFzc29mJDIgPSBjbGFzc29mUmF3JDI7XG5cbi8vIGBJc0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNhcnJheVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LWlzYXJyYXkgLS0gc2FmZVxudmFyIGlzQXJyYXkkMSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmd1bWVudCkge1xuICByZXR1cm4gY2xhc3NvZiQyKGFyZ3VtZW50KSA9PSAnQXJyYXknO1xufTtcbnZhciB3ZWxsS25vd25TeW1ib2wkMyA9IHdlbGxLbm93blN5bWJvbCQ1O1xudmFyIFRPX1NUUklOR19UQUckMSA9IHdlbGxLbm93blN5bWJvbCQzKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcbnRlc3RbVE9fU1RSSU5HX1RBRyQxXSA9ICd6JztcbnZhciB0b1N0cmluZ1RhZ1N1cHBvcnQgPSBTdHJpbmcodGVzdCkgPT09ICdbb2JqZWN0IHpdJztcbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSB0b1N0cmluZ1RhZ1N1cHBvcnQ7XG52YXIgaXNDYWxsYWJsZSQxID0gaXNDYWxsYWJsZSRjO1xudmFyIGNsYXNzb2ZSYXcgPSBjbGFzc29mUmF3JDI7XG52YXIgd2VsbEtub3duU3ltYm9sJDIgPSB3ZWxsS25vd25TeW1ib2wkNTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sJDIoJ3RvU3RyaW5nVGFnJyk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gYXJndW1lbnRzO1xufSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgey8qIGVtcHR5ICovfVxufTtcblxuLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxudmFyIGNsYXNzb2YkMSA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9ICRPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgLy8gYnVpbHRpblRhZyBjYXNlXG4gIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pXG4gIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgaXNDYWxsYWJsZSQxKE8uY2FsbGVlKSA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcbnZhciB1bmN1cnJ5VGhpcyQxID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyA9IGZhaWxzJDk7XG52YXIgaXNDYWxsYWJsZSA9IGlzQ2FsbGFibGUkYztcbnZhciBjbGFzc29mID0gY2xhc3NvZiQxO1xudmFyIGdldEJ1aWx0SW4kMSA9IGdldEJ1aWx0SW4kNTtcbnZhciBpbnNwZWN0U291cmNlID0gaW5zcGVjdFNvdXJjZSQyO1xudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7LyogZW1wdHkgKi99O1xudmFyIGVtcHR5ID0gW107XG52YXIgY29uc3RydWN0ID0gZ2V0QnVpbHRJbiQxKCdSZWZsZWN0JywgJ2NvbnN0cnVjdCcpO1xudmFyIGNvbnN0cnVjdG9yUmVnRXhwID0gL15cXHMqKD86Y2xhc3N8ZnVuY3Rpb24pXFxiLztcbnZhciBleGVjID0gdW5jdXJyeVRoaXMkMShjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKTtcbnZhciBJTkNPUlJFQ1RfVE9fU1RSSU5HID0gIWNvbnN0cnVjdG9yUmVnRXhwLmV4ZWMobm9vcCk7XG52YXIgaXNDb25zdHJ1Y3Rvck1vZGVybiA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0cnVjdChub29wLCBlbXB0eSwgYXJndW1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciBpc0NvbnN0cnVjdG9yTGVnYWN5ID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICBpZiAoIWlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAoY2xhc3NvZihhcmd1bWVudCkpIHtcbiAgICBjYXNlICdBc3luY0Z1bmN0aW9uJzpcbiAgICBjYXNlICdHZW5lcmF0b3JGdW5jdGlvbic6XG4gICAgY2FzZSAnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbic6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyB3ZSBjYW4ndCBjaGVjayAucHJvdG90eXBlIHNpbmNlIGNvbnN0cnVjdG9ycyBwcm9kdWNlZCBieSAuYmluZCBoYXZlbid0IGl0XG4gICAgLy8gYEZ1bmN0aW9uI3RvU3RyaW5nYCB0aHJvd3Mgb24gc29tZSBidWlsdC1pdCBmdW5jdGlvbiBpbiBzb21lIGxlZ2FjeSBlbmdpbmVzXG4gICAgLy8gKGZvciBleGFtcGxlLCBgRE9NUXVhZGAgYW5kIHNpbWlsYXIgaW4gRkY0MS0pXG4gICAgcmV0dXJuIElOQ09SUkVDVF9UT19TVFJJTkcgfHwgISFleGVjKGNvbnN0cnVjdG9yUmVnRXhwLCBpbnNwZWN0U291cmNlKGFyZ3VtZW50KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5pc0NvbnN0cnVjdG9yTGVnYWN5LnNoYW0gPSB0cnVlO1xuXG4vLyBgSXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY29uc3RydWN0b3JcbnZhciBpc0NvbnN0cnVjdG9yJDEgPSAhY29uc3RydWN0IHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxlZDtcbiAgcmV0dXJuIGlzQ29uc3RydWN0b3JNb2Rlcm4oaXNDb25zdHJ1Y3Rvck1vZGVybi5jYWxsKSB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihPYmplY3QpIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsZWQgPSB0cnVlO1xuICB9KSB8fCBjYWxsZWQ7XG59KSA/IGlzQ29uc3RydWN0b3JMZWdhY3kgOiBpc0NvbnN0cnVjdG9yTW9kZXJuO1xudmFyIGlzQXJyYXkgPSBpc0FycmF5JDE7XG52YXIgaXNDb25zdHJ1Y3RvciA9IGlzQ29uc3RydWN0b3IkMTtcbnZhciBpc09iamVjdCA9IGlzT2JqZWN0JDY7XG52YXIgd2VsbEtub3duU3ltYm9sJDEgPSB3ZWxsS25vd25TeW1ib2wkNTtcbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sJDEoJ3NwZWNpZXMnKTtcbnZhciAkQXJyYXkgPSBBcnJheTtcblxuLy8gYSBwYXJ0IG9mIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcbnZhciBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXkpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsQXJyYXkpKSB7XG4gICAgQyA9IG9yaWdpbmFsQXJyYXkuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAoaXNDb25zdHJ1Y3RvcihDKSAmJiAoQyA9PT0gJEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtlbHNlIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/ICRBcnJheSA6IEM7XG59O1xudmFyIGFycmF5U3BlY2llc0NvbnN0cnVjdG9yID0gYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IkMTtcblxuLy8gYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxudmFyIGFycmF5U3BlY2llc0NyZWF0ZSQxID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXksIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChhcnJheVNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbEFycmF5KSkobGVuZ3RoID09PSAwID8gMCA6IGxlbmd0aCk7XG59O1xudmFyIGJpbmQgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIHVuY3VycnlUaGlzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBJbmRleGVkT2JqZWN0ID0gaW5kZXhlZE9iamVjdDtcbnZhciB0b09iamVjdCA9IHRvT2JqZWN0JDI7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBsZW5ndGhPZkFycmF5TGlrZSQyO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IGFycmF5U3BlY2llc0NyZWF0ZSQxO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGZvckVhY2gsIG1hcCwgZmlsdGVyLCBzb21lLCBldmVyeSwgZmluZCwgZmluZEluZGV4LCBmaWx0ZXJSZWplY3QgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgSVNfRklMVEVSX1JFSkVDVCA9IFRZUEUgPT0gNztcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQsIHNwZWNpZmljQ3JlYXRlKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJbmRleGVkT2JqZWN0KE8pO1xuICAgIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZChjYWxsYmFja2ZuLCB0aGF0KTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2Uoc2VsZik7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY3JlYXRlID0gc3BlY2lmaWNDcmVhdGUgfHwgYXJyYXlTcGVjaWVzQ3JlYXRlO1xuICAgIHZhciB0YXJnZXQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgfHwgSVNfRklMVEVSX1JFSkVDVCA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbHVlLCByZXN1bHQ7XG4gICAgZm9yICg7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlc3VsdCA9IGJvdW5kRnVuY3Rpb24odmFsdWUsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHRhcmdldFtpbmRleF0gPSByZXN1bHQ7IC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBwdXNoKHRhcmdldCwgdmFsdWUpO1xuICAgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2Ugc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIC8vIGV2ZXJ5XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcHVzaCh0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgICAvLyBmaWx0ZXJSZWplY3RcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0O1xuICB9O1xufTtcbnZhciBhcnJheUl0ZXJhdGlvbiA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxuICBmb3JFYWNoOiBjcmVhdGVNZXRob2QoMCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4gIG1hcDogY3JlYXRlTWV0aG9kKDEpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuICBmaWx0ZXI6IGNyZWF0ZU1ldGhvZCgyKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5zb21lYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29tZVxuICBzb21lOiBjcmVhdGVNZXRob2QoMyksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuICBldmVyeTogY3JlYXRlTWV0aG9kKDQpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kXG4gIGZpbmQ6IGNyZWF0ZU1ldGhvZCg1KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhcbiAgZmluZEluZGV4OiBjcmVhdGVNZXRob2QoNiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyUmVqZWN0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXJyYXktZmlsdGVyaW5nXG4gIGZpbHRlclJlamVjdDogY3JlYXRlTWV0aG9kKDcpXG59O1xudmFyIG9iamVjdERlZmluZVByb3BlcnRpZXMgPSB7fTtcbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG52YXIgZW51bUJ1Z0tleXMkMSA9IGVudW1CdWdLZXlzJDM7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWtleXMgLS0gc2FmZVxudmFyIG9iamVjdEtleXMkMSA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzJDEpO1xufTtcbnZhciBERVNDUklQVE9SUyA9IGRlc2NyaXB0b3JzO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBhbk9iamVjdCQxID0gYW5PYmplY3QkNDtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSB0b0luZGV4ZWRPYmplY3QkNDtcbnZhciBvYmplY3RLZXlzID0gb2JqZWN0S2V5cyQxO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcbm9iamVjdERlZmluZVByb3BlcnRpZXMuZiA9IERFU0NSSVBUT1JTICYmICFWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0JDEoTyk7XG4gIHZhciBwcm9wcyA9IHRvSW5kZXhlZE9iamVjdChQcm9wZXJ0aWVzKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBwcm9wc1trZXldKTtcbiAgcmV0dXJuIE87XG59O1xudmFyIGdldEJ1aWx0SW4gPSBnZXRCdWlsdEluJDU7XG52YXIgaHRtbCQxID0gZ2V0QnVpbHRJbignZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG5cbi8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0IC0tIG9sZCBJRSwgV1NIICovXG5cbnZhciBhbk9iamVjdCA9IGFuT2JqZWN0JDQ7XG52YXIgZGVmaW5lUHJvcGVydGllc01vZHVsZSA9IG9iamVjdERlZmluZVByb3BlcnRpZXM7XG52YXIgZW51bUJ1Z0tleXMgPSBlbnVtQnVnS2V5cyQzO1xudmFyIGhpZGRlbktleXMgPSBoaWRkZW5LZXlzJDQ7XG52YXIgaHRtbCA9IGh0bWwkMTtcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMTtcbnZhciBzaGFyZWRLZXkgPSBzaGFyZWRLZXkkMjtcbnZhciBHVCA9ICc+JztcbnZhciBMVCA9ICc8JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBTQ1JJUFQgPSAnc2NyaXB0JztcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgey8qIGVtcHR5ICovfTtcbnZhciBzY3JpcHRUYWcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIEFjdGl2ZVggT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xuICBhY3RpdmVYRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCcnKSk7XG4gIGFjdGl2ZVhEb2N1bWVudC5jbG9zZSgpO1xuICB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsOyAvLyBhdm9pZCBtZW1vcnkgbGVha1xuICByZXR1cm4gdGVtcDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbn07XG5cbi8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbi8vIGF2b2lkIElFIEdDIGJ1Z1xudmFyIGFjdGl2ZVhEb2N1bWVudDtcbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgYWN0aXZlWERvY3VtZW50ID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7LyogaWdub3JlICovfVxuICBOdWxsUHJvdG9PYmplY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudC5kb21haW4gJiYgYWN0aXZlWERvY3VtZW50ID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIC8vIG9sZCBJRVxuICA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpIDogTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpOyAvLyBXU0hcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XG4gIHJldHVybiBOdWxsUHJvdG9PYmplY3QoKTtcbn07XG5oaWRkZW5LZXlzW0lFX1BST1RPXSA9IHRydWU7XG5cbi8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1jcmVhdGUgLS0gc2FmZVxudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlLmYocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG52YXIgd2VsbEtub3duU3ltYm9sID0gd2VsbEtub3duU3ltYm9sJDU7XG52YXIgY3JlYXRlID0gb2JqZWN0Q3JlYXRlO1xudmFyIGRlZmluZVByb3BlcnR5ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBVTlNDT1BBQkxFUyA9IHdlbGxLbm93blN5bWJvbCgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5pZiAoQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkge1xuICBkZWZpbmVQcm9wZXJ0eShBcnJheVByb3RvdHlwZSwgVU5TQ09QQUJMRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IGNyZWF0ZShudWxsKVxuICB9KTtcbn1cblxuLy8gYWRkIGEga2V5IHRvIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIGFkZFRvVW5zY29wYWJsZXMkMSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcbnZhciAkID0gX2V4cG9ydDtcbnZhciAkZmluZCA9IGFycmF5SXRlcmF0aW9uLmZpbmQ7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IGFkZFRvVW5zY29wYWJsZXMkMTtcbnZhciBGSU5EID0gJ2ZpbmQnO1xudmFyIFNLSVBTX0hPTEVTID0gdHJ1ZTtcblxuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmIChGSU5EIGluIFtdKSBBcnJheSgxKVtGSU5EXShmdW5jdGlvbiAoKSB7XG4gIFNLSVBTX0hPTEVTID0gZmFsc2U7XG59KTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5maW5kYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRcbiQoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6IFNLSVBTX0hPTEVTXG59LCB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcyhGSU5EKTtcbnZhciBDT05TVEFOVCA9IHtcbiAgR0xPQkFMOiB7XG4gICAgSElERTogJ19fcmVhY3RfdG9vbHRpcF9oaWRlX2V2ZW50JyxcbiAgICBSRUJVSUxEOiAnX19yZWFjdF90b29sdGlwX3JlYnVpbGRfZXZlbnQnLFxuICAgIFNIT1c6ICdfX3JlYWN0X3Rvb2x0aXBfc2hvd19ldmVudCdcbiAgfVxufTtcblxuLyoqXG4gKiBTdGF0aWMgbWV0aG9kcyBmb3IgcmVhY3QtdG9vbHRpcFxuICovXG52YXIgZGlzcGF0Y2hHbG9iYWxFdmVudCA9IGZ1bmN0aW9uIGRpc3BhdGNoR2xvYmFsRXZlbnQoZXZlbnROYW1lLCBvcHRzKSB7XG4gIC8vIENvbXBhdGlibGUgd2l0aCBJRVxuICAvLyBAc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjY1OTYxMjMvaW50ZXJuZXQtZXhwbG9yZXItOS0xMC0xMS1ldmVudC1jb25zdHJ1Y3Rvci1kb2VzbnQtd29ya1xuICAvLyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9DdXN0b21FdmVudFxuICB2YXIgZXZlbnQ7XG4gIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnQgPSBuZXcgd2luZG93LkN1c3RvbUV2ZW50KGV2ZW50TmFtZSwge1xuICAgICAgZGV0YWlsOiBvcHRzXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoZXZlbnROYW1lLCBmYWxzZSwgdHJ1ZSwgb3B0cyk7XG4gIH1cbiAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufTtcbmZ1bmN0aW9uIHN0YXRpY01ldGhvZHModGFyZ2V0KSB7XG4gIC8qKlxuICAgKiBIaWRlIGFsbCB0b29sdGlwXG4gICAqIEB0cmlnZ2VyIFJlYWN0VG9vbHRpcC5oaWRlKClcbiAgICovXG4gIHRhcmdldC5oaWRlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGRpc3BhdGNoR2xvYmFsRXZlbnQoQ09OU1RBTlQuR0xPQkFMLkhJREUsIHtcbiAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlYnVpbGQgYWxsIHRvb2x0aXBcbiAgICogQHRyaWdnZXIgUmVhY3RUb29sdGlwLnJlYnVpbGQoKVxuICAgKi9cbiAgdGFyZ2V0LnJlYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZGlzcGF0Y2hHbG9iYWxFdmVudChDT05TVEFOVC5HTE9CQUwuUkVCVUlMRCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3cgc3BlY2lmaWMgdG9vbHRpcFxuICAgKiBAdHJpZ2dlciBSZWFjdFRvb2x0aXAuc2hvdygpXG4gICAqL1xuICB0YXJnZXQuc2hvdyA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBkaXNwYXRjaEdsb2JhbEV2ZW50KENPTlNUQU5ULkdMT0JBTC5TSE9XLCB7XG4gICAgICB0YXJnZXQ6IHRhcmdldFxuICAgIH0pO1xuICB9O1xuICB0YXJnZXQucHJvdG90eXBlLmdsb2JhbFJlYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubW91bnQpIHtcbiAgICAgIHRoaXMudW5iaW5kTGlzdGVuZXIoKTtcbiAgICAgIHRoaXMuYmluZExpc3RlbmVyKCk7XG4gICAgfVxuICB9O1xuICB0YXJnZXQucHJvdG90eXBlLmdsb2JhbFNob3cgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5tb3VudCkge1xuICAgICAgdmFyIGhhc1RhcmdldCA9IGV2ZW50ICYmIGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudGFyZ2V0ICYmIHRydWUgfHwgZmFsc2U7XG4gICAgICAvLyBDcmVhdGUgYSBmYWtlIGV2ZW50LCBzcGVjaWZpYyBzaG93IHdpbGwgbGltaXQgdGhlIHR5cGUgdG8gYHNvbGlkYFxuICAgICAgLy8gb25seSBgZmxvYXRgIHR5cGUgY2FyZXMgZS5jbGllbnRYIGUuY2xpZW50WVxuICAgICAgdGhpcy5zaG93VG9vbHRpcCh7XG4gICAgICAgIGN1cnJlbnRUYXJnZXQ6IGhhc1RhcmdldCAmJiBldmVudC5kZXRhaWwudGFyZ2V0XG4gICAgICB9LCB0cnVlKTtcbiAgICB9XG4gIH07XG4gIHRhcmdldC5wcm90b3R5cGUuZ2xvYmFsSGlkZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICh0aGlzLm1vdW50KSB7XG4gICAgICB2YXIgaGFzVGFyZ2V0ID0gZXZlbnQgJiYgZXZlbnQuZGV0YWlsICYmIGV2ZW50LmRldGFpbC50YXJnZXQgJiYgdHJ1ZSB8fCBmYWxzZTtcbiAgICAgIHRoaXMuaGlkZVRvb2x0aXAoe1xuICAgICAgICBjdXJyZW50VGFyZ2V0OiBoYXNUYXJnZXQgJiYgZXZlbnQuZGV0YWlsLnRhcmdldFxuICAgICAgfSwgaGFzVGFyZ2V0KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRXZlbnRzIHRoYXQgc2hvdWxkIGJlIGJvdW5kIHRvIHRoZSB3aW5kb3dcbiAqL1xuZnVuY3Rpb24gd2luZG93TGlzdGVuZXIodGFyZ2V0KSB7XG4gIHRhcmdldC5wcm90b3R5cGUuYmluZFdpbmRvd0V2ZW50cyA9IGZ1bmN0aW9uIChyZXNpemVIaWRlKSB7XG4gICAgLy8gUmVhY3RUb29sdGlwLmhpZGVcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihDT05TVEFOVC5HTE9CQUwuSElERSwgdGhpcy5nbG9iYWxIaWRlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihDT05TVEFOVC5HTE9CQUwuSElERSwgdGhpcy5nbG9iYWxIaWRlLCBmYWxzZSk7XG5cbiAgICAvLyBSZWFjdFRvb2x0aXAucmVidWlsZFxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKENPTlNUQU5ULkdMT0JBTC5SRUJVSUxELCB0aGlzLmdsb2JhbFJlYnVpbGQpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKENPTlNUQU5ULkdMT0JBTC5SRUJVSUxELCB0aGlzLmdsb2JhbFJlYnVpbGQsIGZhbHNlKTtcblxuICAgIC8vIFJlYWN0VG9vbHRpcC5zaG93XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoQ09OU1RBTlQuR0xPQkFMLlNIT1csIHRoaXMuZ2xvYmFsU2hvdyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoQ09OU1RBTlQuR0xPQkFMLlNIT1csIHRoaXMuZ2xvYmFsU2hvdywgZmFsc2UpO1xuXG4gICAgLy8gUmVzaXplXG4gICAgaWYgKHJlc2l6ZUhpZGUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uV2luZG93UmVzaXplKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uV2luZG93UmVzaXplLCBmYWxzZSk7XG4gICAgfVxuICB9O1xuICB0YXJnZXQucHJvdG90eXBlLnVuYmluZFdpbmRvd0V2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihDT05TVEFOVC5HTE9CQUwuSElERSwgdGhpcy5nbG9iYWxIaWRlKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihDT05TVEFOVC5HTE9CQUwuUkVCVUlMRCwgdGhpcy5nbG9iYWxSZWJ1aWxkKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihDT05TVEFOVC5HTE9CQUwuU0hPVywgdGhpcy5nbG9iYWxTaG93KTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5vbldpbmRvd1Jlc2l6ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGludm9rZWQgYnkgcmVzaXplIGV2ZW50IG9mIHdpbmRvd1xuICAgKi9cbiAgdGFyZ2V0LnByb3RvdHlwZS5vbldpbmRvd1Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMubW91bnQpIHJldHVybjtcbiAgICB0aGlzLmhpZGVUb29sdGlwKCk7XG4gIH07XG59XG5cbi8qKlxuICogQ3VzdG9tIGV2ZW50cyB0byBjb250cm9sIHNob3dpbmcgYW5kIGhpZGluZyBvZiB0b29sdGlwXG4gKlxuICogQGF0dHJpYnV0ZXNcbiAqIC0gYGV2ZW50YCB7U3RyaW5nfVxuICogLSBgZXZlbnRPZmZgIHtTdHJpbmd9XG4gKi9cblxudmFyIGNoZWNrU3RhdHVzID0gZnVuY3Rpb24gY2hlY2tTdGF0dXMoZGF0YUV2ZW50T2ZmLCBlKSB7XG4gIHZhciBzaG93ID0gdGhpcy5zdGF0ZS5zaG93O1xuICB2YXIgaWQgPSB0aGlzLnByb3BzLmlkO1xuICB2YXIgaXNDYXB0dXJlID0gdGhpcy5pc0NhcHR1cmUoZS5jdXJyZW50VGFyZ2V0KTtcbiAgdmFyIGN1cnJlbnRJdGVtID0gZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnY3VycmVudEl0ZW0nKTtcbiAgaWYgKCFpc0NhcHR1cmUpIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGlmIChzaG93ICYmIGN1cnJlbnRJdGVtID09PSAndHJ1ZScpIHtcbiAgICBpZiAoIWRhdGFFdmVudE9mZikgdGhpcy5oaWRlVG9vbHRpcChlKTtcbiAgfSBlbHNlIHtcbiAgICBlLmN1cnJlbnRUYXJnZXQuc2V0QXR0cmlidXRlKCdjdXJyZW50SXRlbScsICd0cnVlJyk7XG4gICAgc2V0VW50YXJnZXRJdGVtcyhlLmN1cnJlbnRUYXJnZXQsIHRoaXMuZ2V0VGFyZ2V0QXJyYXkoaWQpKTtcbiAgICB0aGlzLnNob3dUb29sdGlwKGUpO1xuICB9XG59O1xudmFyIHNldFVudGFyZ2V0SXRlbXMgPSBmdW5jdGlvbiBzZXRVbnRhcmdldEl0ZW1zKGN1cnJlbnRUYXJnZXQsIHRhcmdldEFycmF5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY3VycmVudFRhcmdldCAhPT0gdGFyZ2V0QXJyYXlbaV0pIHtcbiAgICAgIHRhcmdldEFycmF5W2ldLnNldEF0dHJpYnV0ZSgnY3VycmVudEl0ZW0nLCAnZmFsc2UnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0QXJyYXlbaV0uc2V0QXR0cmlidXRlKCdjdXJyZW50SXRlbScsICd0cnVlJyk7XG4gICAgfVxuICB9XG59O1xudmFyIGN1c3RvbUxpc3RlbmVycyA9IHtcbiAgaWQ6ICc5YjY5ZjkyZS1kM2ZlLTQ5OGItYjFiNC1jNWU2M2E1MWIwY2YnLFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLmlkIGluIHRhcmdldCkge1xuICAgICAgdmFyIG1hcCA9IHRhcmdldFt0aGlzLmlkXTtcbiAgICAgIG1hcFtldmVudF0gPSBsaXN0ZW5lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhpcyBpcyB3b3JrYXJvdW5kIGZvciBXZWFrTWFwLCB3aGljaCBpcyBub3Qgc3VwcG9ydGVkIGluIG9sZGVyIGJyb3dzZXJzLCBzdWNoIGFzIElFXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCB0aGlzLmlkLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgZXZlbnQsIGxpc3RlbmVyKVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBnZXQ6IGZ1bmN0aW9uIGdldCh0YXJnZXQsIGV2ZW50KSB7XG4gICAgdmFyIG1hcCA9IHRhcmdldFt0aGlzLmlkXTtcbiAgICBpZiAobWFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBtYXBbZXZlbnRdO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIGN1c3RvbUV2ZW50KHRhcmdldCkge1xuICB0YXJnZXQucHJvdG90eXBlLmlzQ3VzdG9tRXZlbnQgPSBmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5zdGF0ZS5ldmVudDtcbiAgICByZXR1cm4gZXZlbnQgfHwgISFlbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWV2ZW50Jyk7XG4gIH07XG5cbiAgLyogQmluZCBsaXN0ZW5lciBmb3IgY3VzdG9tIGV2ZW50ICovXG4gIHRhcmdldC5wcm90b3R5cGUuY3VzdG9tQmluZExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIF90aGlzJHN0YXRlID0gdGhpcy5zdGF0ZSxcbiAgICAgIGV2ZW50ID0gX3RoaXMkc3RhdGUuZXZlbnQsXG4gICAgICBldmVudE9mZiA9IF90aGlzJHN0YXRlLmV2ZW50T2ZmO1xuICAgIHZhciBkYXRhRXZlbnQgPSBlbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWV2ZW50JykgfHwgZXZlbnQ7XG4gICAgdmFyIGRhdGFFdmVudE9mZiA9IGVsZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtZXZlbnQtb2ZmJykgfHwgZXZlbnRPZmY7XG4gICAgZGF0YUV2ZW50LnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGVsZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBjdXN0b21MaXN0ZW5lcnMuZ2V0KGVsZSwgZXZlbnQpKTtcbiAgICAgIHZhciBjdXN0b21MaXN0ZW5lciA9IGNoZWNrU3RhdHVzLmJpbmQoX3RoaXMsIGRhdGFFdmVudE9mZik7XG4gICAgICBjdXN0b21MaXN0ZW5lcnMuc2V0KGVsZSwgZXZlbnQsIGN1c3RvbUxpc3RlbmVyKTtcbiAgICAgIGVsZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjdXN0b21MaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0pO1xuICAgIGlmIChkYXRhRXZlbnRPZmYpIHtcbiAgICAgIGRhdGFFdmVudE9mZi5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGVsZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBfdGhpcy5oaWRlVG9vbHRpcCk7XG4gICAgICAgIGVsZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBfdGhpcy5oaWRlVG9vbHRpcCwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qIFVuYmluZCBsaXN0ZW5lciBmb3IgY3VzdG9tIGV2ZW50ICovXG4gIHRhcmdldC5wcm90b3R5cGUuY3VzdG9tVW5iaW5kTGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIF90aGlzJHN0YXRlMiA9IHRoaXMuc3RhdGUsXG4gICAgICBldmVudCA9IF90aGlzJHN0YXRlMi5ldmVudCxcbiAgICAgIGV2ZW50T2ZmID0gX3RoaXMkc3RhdGUyLmV2ZW50T2ZmO1xuICAgIHZhciBkYXRhRXZlbnQgPSBldmVudCB8fCBlbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWV2ZW50Jyk7XG4gICAgdmFyIGRhdGFFdmVudE9mZiA9IGV2ZW50T2ZmIHx8IGVsZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtZXZlbnQtb2ZmJyk7XG4gICAgZWxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZGF0YUV2ZW50LCBjdXN0b21MaXN0ZW5lcnMuZ2V0KGVsZSwgZXZlbnQpKTtcbiAgICBpZiAoZGF0YUV2ZW50T2ZmKSBlbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihkYXRhRXZlbnRPZmYsIHRoaXMuaGlkZVRvb2x0aXApO1xuICB9O1xufVxuXG4vKipcbiAqIFV0aWwgbWV0aG9kIHRvIGp1ZGdlIGlmIGl0IHNob3VsZCBmb2xsb3cgY2FwdHVyZSBtb2RlbFxuICovXG5cbmZ1bmN0aW9uIGlzQ2FwdHVyZSh0YXJnZXQpIHtcbiAgdGFyZ2V0LnByb3RvdHlwZS5pc0NhcHR1cmUgPSBmdW5jdGlvbiAoY3VycmVudFRhcmdldCkge1xuICAgIHJldHVybiBjdXJyZW50VGFyZ2V0ICYmIGN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWlzY2FwdHVyZScpID09PSAndHJ1ZScgfHwgdGhpcy5wcm9wcy5pc0NhcHR1cmUgfHwgZmFsc2U7XG4gIH07XG59XG5cbi8qKlxuICogVXRpbCBtZXRob2QgdG8gZ2V0IGVmZmVjdFxuICovXG5cbmZ1bmN0aW9uIGdldEVmZmVjdCh0YXJnZXQpIHtcbiAgdGFyZ2V0LnByb3RvdHlwZS5nZXRFZmZlY3QgPSBmdW5jdGlvbiAoY3VycmVudFRhcmdldCkge1xuICAgIHZhciBkYXRhRWZmZWN0ID0gY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZWZmZWN0Jyk7XG4gICAgcmV0dXJuIGRhdGFFZmZlY3QgfHwgdGhpcy5wcm9wcy5lZmZlY3QgfHwgJ2Zsb2F0JztcbiAgfTtcbn1cblxuLyoqXG4gKiBVdGlsIG1ldGhvZCB0byBnZXQgZWZmZWN0XG4gKi9cbnZhciBtYWtlUHJveHkgPSBmdW5jdGlvbiBtYWtlUHJveHkoZSkge1xuICB2YXIgcHJveHkgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIGUpIHtcbiAgICBpZiAodHlwZW9mIGVba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJveHlba2V5XSA9IGVba2V5XS5iaW5kKGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm94eVtrZXldID0gZVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJveHk7XG59O1xudmFyIGJvZHlMaXN0ZW5lciA9IGZ1bmN0aW9uIGJvZHlMaXN0ZW5lcihjYWxsYmFjaywgb3B0aW9ucywgZSkge1xuICB2YXIgX29wdGlvbnMkcmVzcGVjdEVmZmVjID0gb3B0aW9ucy5yZXNwZWN0RWZmZWN0LFxuICAgIHJlc3BlY3RFZmZlY3QgPSBfb3B0aW9ucyRyZXNwZWN0RWZmZWMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmVzcGVjdEVmZmVjLFxuICAgIF9vcHRpb25zJGN1c3RvbUV2ZW50ID0gb3B0aW9ucy5jdXN0b21FdmVudCxcbiAgICBjdXN0b21FdmVudCA9IF9vcHRpb25zJGN1c3RvbUV2ZW50ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGN1c3RvbUV2ZW50O1xuICB2YXIgaWQgPSB0aGlzLnByb3BzLmlkO1xuICB2YXIgdGlwID0gbnVsbDtcbiAgdmFyIGZvcklkO1xuICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gIHZhciBsYXN0VGFyZ2V0O1xuICAvLyB3YWxrIHVwIHBhcmVudCBjaGFpbiB1bnRpbCB0aXAgaXMgZm91bmRcbiAgLy8gdGhlcmUgaXMgbm8gbWF0Y2ggaWYgcGFyZW50IHZpc2libGUgYXJlYSBpcyBtYXRjaGVkIGJ5IG1vdXNlIHBvc2l0aW9uLCBzbyBzb21lIGNvcm5lciBjYXNlcyBtaWdodCBub3Qgd29yayBhcyBleHBlY3RlZFxuICB3aGlsZSAodGlwID09PSBudWxsICYmIHRhcmdldCAhPT0gbnVsbCkge1xuICAgIGxhc3RUYXJnZXQgPSB0YXJnZXQ7XG4gICAgdGlwID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS10aXAnKSB8fCBudWxsO1xuICAgIGZvcklkID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1mb3InKSB8fCBudWxsO1xuICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHRhcmdldCA9IGxhc3RUYXJnZXQgfHwgZS50YXJnZXQ7XG4gIGlmICh0aGlzLmlzQ3VzdG9tRXZlbnQodGFyZ2V0KSAmJiAhY3VzdG9tRXZlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlzVGFyZ2V0QmVsb25nc1RvVG9vbHRpcCA9IGlkID09IG51bGwgJiYgZm9ySWQgPT0gbnVsbCB8fCBmb3JJZCA9PT0gaWQ7XG4gIGlmICh0aXAgIT0gbnVsbCAmJiAoIXJlc3BlY3RFZmZlY3QgfHwgdGhpcy5nZXRFZmZlY3QodGFyZ2V0KSA9PT0gJ2Zsb2F0JykgJiYgaXNUYXJnZXRCZWxvbmdzVG9Ub29sdGlwKSB7XG4gICAgdmFyIHByb3h5ID0gbWFrZVByb3h5KGUpO1xuICAgIHByb3h5LmN1cnJlbnRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgY2FsbGJhY2socHJveHkpO1xuICB9XG59O1xudmFyIGZpbmRDdXN0b21FdmVudHMgPSBmdW5jdGlvbiBmaW5kQ3VzdG9tRXZlbnRzKHRhcmdldEFycmF5LCBkYXRhQXR0cmlidXRlKSB7XG4gIHZhciBldmVudHMgPSB7fTtcbiAgdGFyZ2V0QXJyYXkuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdmFyIGV2ZW50ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShkYXRhQXR0cmlidXRlKTtcbiAgICBpZiAoZXZlbnQpIGV2ZW50LnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBldmVudHNbZXZlbnRdID0gdHJ1ZTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBldmVudHM7XG59O1xudmFyIGdldEJvZHkgPSBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXTtcbn07XG5mdW5jdGlvbiBib2R5TW9kZSh0YXJnZXQpIHtcbiAgdGFyZ2V0LnByb3RvdHlwZS5pc0JvZHlNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXRoaXMucHJvcHMuYm9keU1vZGU7XG4gIH07XG4gIHRhcmdldC5wcm90b3R5cGUuYmluZEJvZHlMaXN0ZW5lciA9IGZ1bmN0aW9uICh0YXJnZXRBcnJheSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIF90aGlzJHN0YXRlID0gdGhpcy5zdGF0ZSxcbiAgICAgIGV2ZW50ID0gX3RoaXMkc3RhdGUuZXZlbnQsXG4gICAgICBldmVudE9mZiA9IF90aGlzJHN0YXRlLmV2ZW50T2ZmLFxuICAgICAgcG9zc2libGVDdXN0b21FdmVudHMgPSBfdGhpcyRzdGF0ZS5wb3NzaWJsZUN1c3RvbUV2ZW50cyxcbiAgICAgIHBvc3NpYmxlQ3VzdG9tRXZlbnRzT2ZmID0gX3RoaXMkc3RhdGUucG9zc2libGVDdXN0b21FdmVudHNPZmY7XG4gICAgdmFyIGJvZHkgPSBnZXRCb2R5KCk7XG4gICAgdmFyIGN1c3RvbUV2ZW50cyA9IGZpbmRDdXN0b21FdmVudHModGFyZ2V0QXJyYXksICdkYXRhLWV2ZW50Jyk7XG4gICAgdmFyIGN1c3RvbUV2ZW50c09mZiA9IGZpbmRDdXN0b21FdmVudHModGFyZ2V0QXJyYXksICdkYXRhLWV2ZW50LW9mZicpO1xuICAgIGlmIChldmVudCAhPSBudWxsKSBjdXN0b21FdmVudHNbZXZlbnRdID0gdHJ1ZTtcbiAgICBpZiAoZXZlbnRPZmYgIT0gbnVsbCkgY3VzdG9tRXZlbnRzT2ZmW2V2ZW50T2ZmXSA9IHRydWU7XG4gICAgcG9zc2libGVDdXN0b21FdmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIGN1c3RvbUV2ZW50c1tldmVudF0gPSB0cnVlO1xuICAgIH0pO1xuICAgIHBvc3NpYmxlQ3VzdG9tRXZlbnRzT2ZmLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBjdXN0b21FdmVudHNPZmZbZXZlbnRdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICB0aGlzLnVuYmluZEJvZHlMaXN0ZW5lcihib2R5KTtcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5ib2R5TW9kZUxpc3RlbmVycyA9IHt9O1xuICAgIGlmIChldmVudCA9PSBudWxsKSB7XG4gICAgICBsaXN0ZW5lcnMubW91c2VvdmVyID0gYm9keUxpc3RlbmVyLmJpbmQodGhpcywgdGhpcy5zaG93VG9vbHRpcCwge30pO1xuICAgICAgbGlzdGVuZXJzLm1vdXNlbW92ZSA9IGJvZHlMaXN0ZW5lci5iaW5kKHRoaXMsIHRoaXMudXBkYXRlVG9vbHRpcCwge1xuICAgICAgICByZXNwZWN0RWZmZWN0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGxpc3RlbmVycy5tb3VzZW91dCA9IGJvZHlMaXN0ZW5lci5iaW5kKHRoaXMsIHRoaXMuaGlkZVRvb2x0aXAsIHt9KTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2V2ZW50IGluIGN1c3RvbUV2ZW50cykge1xuICAgICAgbGlzdGVuZXJzW19ldmVudF0gPSBib2R5TGlzdGVuZXIuYmluZCh0aGlzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdGFyZ2V0RXZlbnRPZmYgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWV2ZW50LW9mZicpIHx8IGV2ZW50T2ZmO1xuICAgICAgICBjaGVja1N0YXR1cy5jYWxsKF90aGlzLCB0YXJnZXRFdmVudE9mZiwgZSk7XG4gICAgICB9LCB7XG4gICAgICAgIGN1c3RvbUV2ZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2V2ZW50MiBpbiBjdXN0b21FdmVudHNPZmYpIHtcbiAgICAgIGxpc3RlbmVyc1tfZXZlbnQyXSA9IGJvZHlMaXN0ZW5lci5iaW5kKHRoaXMsIHRoaXMuaGlkZVRvb2x0aXAsIHtcbiAgICAgICAgY3VzdG9tRXZlbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKHZhciBfZXZlbnQzIGluIGxpc3RlbmVycykge1xuICAgICAgYm9keS5hZGRFdmVudExpc3RlbmVyKF9ldmVudDMsIGxpc3RlbmVyc1tfZXZlbnQzXSk7XG4gICAgfVxuICB9O1xuICB0YXJnZXQucHJvdG90eXBlLnVuYmluZEJvZHlMaXN0ZW5lciA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgYm9keSA9IGJvZHkgfHwgZ2V0Qm9keSgpO1xuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmJvZHlNb2RlTGlzdGVuZXJzO1xuICAgIGZvciAodmFyIGV2ZW50IGluIGxpc3RlbmVycykge1xuICAgICAgYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbZXZlbnRdKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogVHJhY2tpbmcgdGFyZ2V0IHJlbW92aW5nIGZyb20gRE9NLlxuICogSXQncyBuZWNlc3NhcnkgdG8gaGlkZSB0b29sdGlwIHdoZW4gaXQncyB0YXJnZXQgZGlzYXBwZWFycy5cbiAqIE90aGVyd2lzZSwgdGhlIHRvb2x0aXAgd291bGQgYmUgc2hvd24gZm9yZXZlciB1bnRpbCBhbm90aGVyIHRhcmdldFxuICogaXMgdHJpZ2dlcmVkLlxuICpcbiAqIElmIE11dGF0aW9uT2JzZXJ2ZXIgaXMgbm90IGF2YWlsYWJsZSwgdGhpcyBmZWF0dXJlIGp1c3QgZG9lc24ndCB3b3JrLlxuICovXG5cbi8vIGh0dHBzOi8vaGFja3MubW96aWxsYS5vcmcvMjAxMi8wNS9kb20tbXV0YXRpb25vYnNlcnZlci1yZWFjdGluZy10by1kb20tY2hhbmdlcy13aXRob3V0LWtpbGxpbmctYnJvd3Nlci1wZXJmb3JtYW5jZS9cbnZhciBnZXRNdXRhdGlvbk9ic2VydmVyQ2xhc3MgPSBmdW5jdGlvbiBnZXRNdXRhdGlvbk9ic2VydmVyQ2xhc3MoKSB7XG4gIHJldHVybiB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuTW96TXV0YXRpb25PYnNlcnZlcjtcbn07XG5mdW5jdGlvbiB0cmFja1JlbW92YWwodGFyZ2V0KSB7XG4gIHRhcmdldC5wcm90b3R5cGUuYmluZFJlbW92YWxUcmFja2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBnZXRNdXRhdGlvbk9ic2VydmVyQ2xhc3MoKTtcbiAgICBpZiAoTXV0YXRpb25PYnNlcnZlciA9PSBudWxsKSByZXR1cm47XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKG11dGF0aW9ucykge1xuICAgICAgZm9yICh2YXIgbTEgPSAwOyBtMSA8IG11dGF0aW9ucy5sZW5ndGg7IG0xKyspIHtcbiAgICAgICAgdmFyIG11dGF0aW9uID0gbXV0YXRpb25zW20xXTtcbiAgICAgICAgZm9yICh2YXIgbTIgPSAwOyBtMiA8IG11dGF0aW9uLnJlbW92ZWROb2Rlcy5sZW5ndGg7IG0yKyspIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IG11dGF0aW9uLnJlbW92ZWROb2Rlc1ttMl07XG4gICAgICAgICAgaWYgKGVsZW1lbnQgPT09IF90aGlzLnN0YXRlLmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIF90aGlzLmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh3aW5kb3cuZG9jdW1lbnQsIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIHN1YnRyZWU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnJlbW92YWxUcmFja2VyID0gb2JzZXJ2ZXI7XG4gIH07XG4gIHRhcmdldC5wcm90b3R5cGUudW5iaW5kUmVtb3ZhbFRyYWNrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucmVtb3ZhbFRyYWNrZXIpIHtcbiAgICAgIHRoaXMucmVtb3ZhbFRyYWNrZXIuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5yZW1vdmFsVHJhY2tlciA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb2YgdG9vbHRpcFxuICpcbiAqIEBwYXJhbXNcbiAqIC0gYGVgIHtFdmVudH0gdGhlIGV2ZW50IG9mIGN1cnJlbnQgbW91c2VcbiAqIC0gYHRhcmdldGAge0VsZW1lbnR9IHRoZSBjdXJyZW50VGFyZ2V0IG9mIHRoZSBldmVudFxuICogLSBgbm9kZWAge0RPTX0gdGhlIHJlYWN0LXRvb2x0aXAgb2JqZWN0XG4gKiAtIGBwbGFjZWAge1N0cmluZ30gdG9wIC8gcmlnaHQgLyBib3R0b20gLyBsZWZ0XG4gKiAtIGBlZmZlY3RgIHtTdHJpbmd9IGZsb2F0IC8gc29saWRcbiAqIC0gYG9mZnNldGAge09iamVjdH0gdGhlIG9mZnNldCB0byBkZWZhdWx0IHBvc2l0aW9uXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogLSBgaXNOZXdTdGF0ZWAge0Jvb2x9IHJlcXVpcmVkXG4gKiAtIGBuZXdTdGF0ZWAge09iamVjdH1cbiAqIC0gYHBvc2l0aW9uYCB7T2JqZWN0fSB7bGVmdDoge051bWJlcn0sIHRvcDoge051bWJlcn19XG4gKi9cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKGUsIHRhcmdldCwgbm9kZSwgcGxhY2UsIGRlc2lyZWRQbGFjZSwgZWZmZWN0LCBvZmZzZXQpIHtcbiAgdmFyIF9nZXREaW1lbnNpb25zID0gZ2V0RGltZW5zaW9ucyhub2RlKSxcbiAgICB0aXBXaWR0aCA9IF9nZXREaW1lbnNpb25zLndpZHRoLFxuICAgIHRpcEhlaWdodCA9IF9nZXREaW1lbnNpb25zLmhlaWdodDtcbiAgdmFyIF9nZXREaW1lbnNpb25zMiA9IGdldERpbWVuc2lvbnModGFyZ2V0KSxcbiAgICB0YXJnZXRXaWR0aCA9IF9nZXREaW1lbnNpb25zMi53aWR0aCxcbiAgICB0YXJnZXRIZWlnaHQgPSBfZ2V0RGltZW5zaW9uczIuaGVpZ2h0O1xuICB2YXIgX2dldEN1cnJlbnRPZmZzZXQgPSBnZXRDdXJyZW50T2Zmc2V0KGUsIHRhcmdldCwgZWZmZWN0KSxcbiAgICBtb3VzZVggPSBfZ2V0Q3VycmVudE9mZnNldC5tb3VzZVgsXG4gICAgbW91c2VZID0gX2dldEN1cnJlbnRPZmZzZXQubW91c2VZO1xuICB2YXIgZGVmYXVsdE9mZnNldCA9IGdldERlZmF1bHRQb3NpdGlvbihlZmZlY3QsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIHRpcFdpZHRoLCB0aXBIZWlnaHQpO1xuICB2YXIgX2NhbGN1bGF0ZU9mZnNldCA9IGNhbGN1bGF0ZU9mZnNldChvZmZzZXQpLFxuICAgIGV4dHJhT2Zmc2V0WCA9IF9jYWxjdWxhdGVPZmZzZXQuZXh0cmFPZmZzZXRYLFxuICAgIGV4dHJhT2Zmc2V0WSA9IF9jYWxjdWxhdGVPZmZzZXQuZXh0cmFPZmZzZXRZO1xuICB2YXIgd2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgdmFyIHdpbmRvd0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgdmFyIF9nZXRQYXJlbnQgPSBnZXRQYXJlbnQobm9kZSksXG4gICAgcGFyZW50VG9wID0gX2dldFBhcmVudC5wYXJlbnRUb3AsXG4gICAgcGFyZW50TGVmdCA9IF9nZXRQYXJlbnQucGFyZW50TGVmdDtcblxuICAvLyBHZXQgdGhlIGVkZ2Ugb2Zmc2V0IG9mIHRoZSB0b29sdGlwXG4gIHZhciBnZXRUaXBPZmZzZXRMZWZ0ID0gZnVuY3Rpb24gZ2V0VGlwT2Zmc2V0TGVmdChwbGFjZSkge1xuICAgIHZhciBvZmZzZXRYID0gZGVmYXVsdE9mZnNldFtwbGFjZV0ubDtcbiAgICByZXR1cm4gbW91c2VYICsgb2Zmc2V0WCArIGV4dHJhT2Zmc2V0WDtcbiAgfTtcbiAgdmFyIGdldFRpcE9mZnNldFJpZ2h0ID0gZnVuY3Rpb24gZ2V0VGlwT2Zmc2V0UmlnaHQocGxhY2UpIHtcbiAgICB2YXIgb2Zmc2V0WCA9IGRlZmF1bHRPZmZzZXRbcGxhY2VdLnI7XG4gICAgcmV0dXJuIG1vdXNlWCArIG9mZnNldFggKyBleHRyYU9mZnNldFg7XG4gIH07XG4gIHZhciBnZXRUaXBPZmZzZXRUb3AgPSBmdW5jdGlvbiBnZXRUaXBPZmZzZXRUb3AocGxhY2UpIHtcbiAgICB2YXIgb2Zmc2V0WSA9IGRlZmF1bHRPZmZzZXRbcGxhY2VdLnQ7XG4gICAgcmV0dXJuIG1vdXNlWSArIG9mZnNldFkgKyBleHRyYU9mZnNldFk7XG4gIH07XG4gIHZhciBnZXRUaXBPZmZzZXRCb3R0b20gPSBmdW5jdGlvbiBnZXRUaXBPZmZzZXRCb3R0b20ocGxhY2UpIHtcbiAgICB2YXIgb2Zmc2V0WSA9IGRlZmF1bHRPZmZzZXRbcGxhY2VdLmI7XG4gICAgcmV0dXJuIG1vdXNlWSArIG9mZnNldFkgKyBleHRyYU9mZnNldFk7XG4gIH07XG5cbiAgLy9cbiAgLy8gRnVuY3Rpb25zIHRvIHRlc3Qgd2hldGhlciB0aGUgdG9vbHRpcCdzIHNpZGVzIGFyZSBpbnNpZGVcbiAgLy8gdGhlIGNsaWVudCB3aW5kb3cgZm9yIGEgZ2l2ZW4gb3JpZW50YXRpb24gcFxuICAvL1xuICAvLyAgX19fX19fX19fX19fX1xuICAvLyB8ICAgICAgICAgICAgIHwgPC0tIFJpZ2h0IHNpZGVcbiAgLy8gfCBwID0gJ2xlZnQnICB8XFxcbiAgLy8gfCAgICAgICAgICAgICB8LyAgfFxcXG4gIC8vIHxfX19fX19fX19fX19ffCAgIHxfXFwgIDwtLSBNb3VzZVxuICAvLyAgICAgIC8gXFwgICAgICAgICAgIHxcbiAgLy8gICAgICAgfFxuICAvLyAgICAgICB8XG4gIC8vICBCb3R0b20gc2lkZVxuICAvL1xuICB2YXIgb3V0c2lkZUxlZnQgPSBmdW5jdGlvbiBvdXRzaWRlTGVmdChwKSB7XG4gICAgcmV0dXJuIGdldFRpcE9mZnNldExlZnQocCkgPCAwO1xuICB9O1xuICB2YXIgb3V0c2lkZVJpZ2h0ID0gZnVuY3Rpb24gb3V0c2lkZVJpZ2h0KHApIHtcbiAgICByZXR1cm4gZ2V0VGlwT2Zmc2V0UmlnaHQocCkgPiB3aW5kb3dXaWR0aDtcbiAgfTtcbiAgdmFyIG91dHNpZGVUb3AgPSBmdW5jdGlvbiBvdXRzaWRlVG9wKHApIHtcbiAgICByZXR1cm4gZ2V0VGlwT2Zmc2V0VG9wKHApIDwgMDtcbiAgfTtcbiAgdmFyIG91dHNpZGVCb3R0b20gPSBmdW5jdGlvbiBvdXRzaWRlQm90dG9tKHApIHtcbiAgICByZXR1cm4gZ2V0VGlwT2Zmc2V0Qm90dG9tKHApID4gd2luZG93SGVpZ2h0O1xuICB9O1xuXG4gIC8vIENoZWNrIHdoZXRoZXIgdGhlIHRvb2x0aXAgd2l0aCBvcmllbnRhdGlvbiBwIGlzIGNvbXBsZXRlbHkgaW5zaWRlIHRoZSBjbGllbnQgd2luZG93XG4gIHZhciBvdXRzaWRlID0gZnVuY3Rpb24gb3V0c2lkZShwKSB7XG4gICAgcmV0dXJuIG91dHNpZGVMZWZ0KHApIHx8IG91dHNpZGVSaWdodChwKSB8fCBvdXRzaWRlVG9wKHApIHx8IG91dHNpZGVCb3R0b20ocCk7XG4gIH07XG4gIHZhciBpbnNpZGUgPSBmdW5jdGlvbiBpbnNpZGUocCkge1xuICAgIHJldHVybiAhb3V0c2lkZShwKTtcbiAgfTtcbiAgdmFyIHBsYWNlSXNJbnNpZGUgPSB7XG4gICAgdG9wOiBpbnNpZGUoJ3RvcCcpLFxuICAgIGJvdHRvbTogaW5zaWRlKCdib3R0b20nKSxcbiAgICBsZWZ0OiBpbnNpZGUoJ2xlZnQnKSxcbiAgICByaWdodDogaW5zaWRlKCdyaWdodCcpXG4gIH07XG4gIGZ1bmN0aW9uIGNob29zZSgpIHtcbiAgICB2YXIgYWxsUGxhY2VzID0gZGVzaXJlZFBsYWNlLnNwbGl0KCcsJykuY29uY2F0KHBsYWNlLCBbJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCddKTtcbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoYWxsUGxhY2VzKSxcbiAgICAgIF9zdGVwO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICBpZiAocGxhY2VJc0luc2lkZVtkXSkgcmV0dXJuIGQ7XG4gICAgICB9XG4gICAgICAvLyBpZiBub3RoaW5nIGlzIGluc2lkZSwganVzdCB1c2UgdGhlIG9sZCBwbGFjZS5cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuICAgIHJldHVybiBwbGFjZTtcbiAgfVxuICB2YXIgY2hvc2VuID0gY2hvb3NlKCk7XG4gIHZhciBpc05ld1N0YXRlID0gZmFsc2U7XG4gIHZhciBuZXdQbGFjZTtcbiAgaWYgKGNob3NlbiAmJiBjaG9zZW4gIT09IHBsYWNlKSB7XG4gICAgaXNOZXdTdGF0ZSA9IHRydWU7XG4gICAgbmV3UGxhY2UgPSBjaG9zZW47XG4gIH1cbiAgaWYgKGlzTmV3U3RhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNOZXdTdGF0ZTogdHJ1ZSxcbiAgICAgIG5ld1N0YXRlOiB7XG4gICAgICAgIHBsYWNlOiBuZXdQbGFjZVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc05ld1N0YXRlOiBmYWxzZSxcbiAgICBwb3NpdGlvbjoge1xuICAgICAgbGVmdDogcGFyc2VJbnQoZ2V0VGlwT2Zmc2V0TGVmdChwbGFjZSkgLSBwYXJlbnRMZWZ0LCAxMCksXG4gICAgICB0b3A6IHBhcnNlSW50KGdldFRpcE9mZnNldFRvcChwbGFjZSkgLSBwYXJlbnRUb3AsIDEwKVxuICAgIH1cbiAgfTtcbn1cbnZhciBnZXREaW1lbnNpb25zID0gZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhub2RlKSB7XG4gIHZhciBfbm9kZSRnZXRCb3VuZGluZ0NsaWUgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgIGhlaWdodCA9IF9ub2RlJGdldEJvdW5kaW5nQ2xpZS5oZWlnaHQsXG4gICAgd2lkdGggPSBfbm9kZSRnZXRCb3VuZGluZ0NsaWUud2lkdGg7XG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBwYXJzZUludChoZWlnaHQsIDEwKSxcbiAgICB3aWR0aDogcGFyc2VJbnQod2lkdGgsIDEwKVxuICB9O1xufTtcblxuLy8gR2V0IGN1cnJlbnQgbW91c2Ugb2Zmc2V0XG52YXIgZ2V0Q3VycmVudE9mZnNldCA9IGZ1bmN0aW9uIGdldEN1cnJlbnRPZmZzZXQoZSwgY3VycmVudFRhcmdldCwgZWZmZWN0KSB7XG4gIHZhciBib3VuZGluZ0NsaWVudFJlY3QgPSBjdXJyZW50VGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgdGFyZ2V0VG9wID0gYm91bmRpbmdDbGllbnRSZWN0LnRvcDtcbiAgdmFyIHRhcmdldExlZnQgPSBib3VuZGluZ0NsaWVudFJlY3QubGVmdDtcbiAgdmFyIF9nZXREaW1lbnNpb25zMyA9IGdldERpbWVuc2lvbnMoY3VycmVudFRhcmdldCksXG4gICAgdGFyZ2V0V2lkdGggPSBfZ2V0RGltZW5zaW9uczMud2lkdGgsXG4gICAgdGFyZ2V0SGVpZ2h0ID0gX2dldERpbWVuc2lvbnMzLmhlaWdodDtcbiAgaWYgKGVmZmVjdCA9PT0gJ2Zsb2F0Jykge1xuICAgIHJldHVybiB7XG4gICAgICBtb3VzZVg6IGUuY2xpZW50WCxcbiAgICAgIG1vdXNlWTogZS5jbGllbnRZXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1vdXNlWDogdGFyZ2V0TGVmdCArIHRhcmdldFdpZHRoIC8gMixcbiAgICBtb3VzZVk6IHRhcmdldFRvcCArIHRhcmdldEhlaWdodCAvIDJcbiAgfTtcbn07XG5cbi8vIExpc3QgYWxsIHBvc3NpYmlsaXR5IG9mIHRvb2x0aXAgZmluYWwgb2Zmc2V0XG4vLyBUaGlzIGlzIHVzZWZ1bCBpbiBqdWRnaW5nIGlmIGl0IGlzIG5lY2Vzc2FyeSBmb3IgdG9vbHRpcCB0byBzd2l0Y2ggcG9zaXRpb24gd2hlbiBvdXQgb2Ygd2luZG93XG52YXIgZ2V0RGVmYXVsdFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0RGVmYXVsdFBvc2l0aW9uKGVmZmVjdCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgdGlwV2lkdGgsIHRpcEhlaWdodCkge1xuICB2YXIgdG9wO1xuICB2YXIgcmlnaHQ7XG4gIHZhciBib3R0b207XG4gIHZhciBsZWZ0O1xuICB2YXIgZGlzVG9Nb3VzZSA9IDM7XG4gIHZhciB0cmlhbmdsZUhlaWdodCA9IDI7XG4gIHZhciBjdXJzb3JIZWlnaHQgPSAxMjsgLy8gT3B0aW1pemUgZm9yIGZsb2F0IGJvdHRvbSBvbmx5LCBjYXVzZSB0aGUgY3Vyc29yIHdpbGwgaGlkZSB0aGUgdG9vbHRpcFxuXG4gIGlmIChlZmZlY3QgPT09ICdmbG9hdCcpIHtcbiAgICB0b3AgPSB7XG4gICAgICBsOiAtKHRpcFdpZHRoIC8gMiksXG4gICAgICByOiB0aXBXaWR0aCAvIDIsXG4gICAgICB0OiAtKHRpcEhlaWdodCArIGRpc1RvTW91c2UgKyB0cmlhbmdsZUhlaWdodCksXG4gICAgICBiOiAtZGlzVG9Nb3VzZVxuICAgIH07XG4gICAgYm90dG9tID0ge1xuICAgICAgbDogLSh0aXBXaWR0aCAvIDIpLFxuICAgICAgcjogdGlwV2lkdGggLyAyLFxuICAgICAgdDogZGlzVG9Nb3VzZSArIGN1cnNvckhlaWdodCxcbiAgICAgIGI6IHRpcEhlaWdodCArIGRpc1RvTW91c2UgKyB0cmlhbmdsZUhlaWdodCArIGN1cnNvckhlaWdodFxuICAgIH07XG4gICAgbGVmdCA9IHtcbiAgICAgIGw6IC0odGlwV2lkdGggKyBkaXNUb01vdXNlICsgdHJpYW5nbGVIZWlnaHQpLFxuICAgICAgcjogLWRpc1RvTW91c2UsXG4gICAgICB0OiAtKHRpcEhlaWdodCAvIDIpLFxuICAgICAgYjogdGlwSGVpZ2h0IC8gMlxuICAgIH07XG4gICAgcmlnaHQgPSB7XG4gICAgICBsOiBkaXNUb01vdXNlLFxuICAgICAgcjogdGlwV2lkdGggKyBkaXNUb01vdXNlICsgdHJpYW5nbGVIZWlnaHQsXG4gICAgICB0OiAtKHRpcEhlaWdodCAvIDIpLFxuICAgICAgYjogdGlwSGVpZ2h0IC8gMlxuICAgIH07XG4gIH0gZWxzZSBpZiAoZWZmZWN0ID09PSAnc29saWQnKSB7XG4gICAgdG9wID0ge1xuICAgICAgbDogLSh0aXBXaWR0aCAvIDIpLFxuICAgICAgcjogdGlwV2lkdGggLyAyLFxuICAgICAgdDogLSh0YXJnZXRIZWlnaHQgLyAyICsgdGlwSGVpZ2h0ICsgdHJpYW5nbGVIZWlnaHQpLFxuICAgICAgYjogLSh0YXJnZXRIZWlnaHQgLyAyKVxuICAgIH07XG4gICAgYm90dG9tID0ge1xuICAgICAgbDogLSh0aXBXaWR0aCAvIDIpLFxuICAgICAgcjogdGlwV2lkdGggLyAyLFxuICAgICAgdDogdGFyZ2V0SGVpZ2h0IC8gMixcbiAgICAgIGI6IHRhcmdldEhlaWdodCAvIDIgKyB0aXBIZWlnaHQgKyB0cmlhbmdsZUhlaWdodFxuICAgIH07XG4gICAgbGVmdCA9IHtcbiAgICAgIGw6IC0odGlwV2lkdGggKyB0YXJnZXRXaWR0aCAvIDIgKyB0cmlhbmdsZUhlaWdodCksXG4gICAgICByOiAtKHRhcmdldFdpZHRoIC8gMiksXG4gICAgICB0OiAtKHRpcEhlaWdodCAvIDIpLFxuICAgICAgYjogdGlwSGVpZ2h0IC8gMlxuICAgIH07XG4gICAgcmlnaHQgPSB7XG4gICAgICBsOiB0YXJnZXRXaWR0aCAvIDIsXG4gICAgICByOiB0aXBXaWR0aCArIHRhcmdldFdpZHRoIC8gMiArIHRyaWFuZ2xlSGVpZ2h0LFxuICAgICAgdDogLSh0aXBIZWlnaHQgLyAyKSxcbiAgICAgIGI6IHRpcEhlaWdodCAvIDJcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgdG9wOiB0b3AsXG4gICAgYm90dG9tOiBib3R0b20sXG4gICAgbGVmdDogbGVmdCxcbiAgICByaWdodDogcmlnaHRcbiAgfTtcbn07XG5cbi8vIENvbnNpZGVyIGFkZGl0aW9uYWwgb2Zmc2V0IGludG8gcG9zaXRpb24gY2FsY3VsYXRpb25cbnZhciBjYWxjdWxhdGVPZmZzZXQgPSBmdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXQob2Zmc2V0KSB7XG4gIHZhciBleHRyYU9mZnNldFggPSAwO1xuICB2YXIgZXh0cmFPZmZzZXRZID0gMDtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkob2Zmc2V0KSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICBvZmZzZXQgPSBKU09OLnBhcnNlKG9mZnNldC50b1N0cmluZygpLnJlcGxhY2UoLycvZywgJ1wiJykpO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBvZmZzZXQpIHtcbiAgICBpZiAoa2V5ID09PSAndG9wJykge1xuICAgICAgZXh0cmFPZmZzZXRZIC09IHBhcnNlSW50KG9mZnNldFtrZXldLCAxMCk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdib3R0b20nKSB7XG4gICAgICBleHRyYU9mZnNldFkgKz0gcGFyc2VJbnQob2Zmc2V0W2tleV0sIDEwKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2xlZnQnKSB7XG4gICAgICBleHRyYU9mZnNldFggLT0gcGFyc2VJbnQob2Zmc2V0W2tleV0sIDEwKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgZXh0cmFPZmZzZXRYICs9IHBhcnNlSW50KG9mZnNldFtrZXldLCAxMCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZXh0cmFPZmZzZXRYOiBleHRyYU9mZnNldFgsXG4gICAgZXh0cmFPZmZzZXRZOiBleHRyYU9mZnNldFlcbiAgfTtcbn07XG5cbi8vIEdldCB0aGUgb2Zmc2V0IG9mIHRoZSBwYXJlbnQgZWxlbWVudHNcbnZhciBnZXRQYXJlbnQgPSBmdW5jdGlvbiBnZXRQYXJlbnQoY3VycmVudFRhcmdldCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGN1cnJlbnRUYXJnZXQ7XG4gIHdoaWxlIChjdXJyZW50UGFyZW50KSB7XG4gICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50UGFyZW50KTtcbiAgICAvLyB0cmFuc2Zvcm0gYW5kIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm0gY2hhbmdlIHRoZSBjb250YWluaW5nIGJsb2NrXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfQmxvY2tcbiAgICBpZiAoY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCd0cmFuc2Zvcm0nKSAhPT0gJ25vbmUnIHx8IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnd2lsbC1jaGFuZ2UnKSA9PT0gJ3RyYW5zZm9ybScpIGJyZWFrO1xuICAgIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gIH1cbiAgdmFyIHBhcmVudFRvcCA9IGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgfHwgMDtcbiAgdmFyIHBhcmVudExlZnQgPSBjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCB8fCAwO1xuICByZXR1cm4ge1xuICAgIHBhcmVudFRvcDogcGFyZW50VG9wLFxuICAgIHBhcmVudExlZnQ6IHBhcmVudExlZnRcbiAgfTtcbn07XG5cbi8qKlxuICogVG8gZ2V0IHRoZSB0b29sdGlwIGNvbnRlbnRcbiAqIGl0IG1heSBjb21lcyBmcm9tIGRhdGEtdGlwIG9yIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAqIGl0IHNob3VsZCBzdXBwb3J0IG11bHRpbGluZVxuICpcbiAqIEBwYXJhbXNcbiAqIC0gYHRpcGAge1N0cmluZ30gdmFsdWUgb2YgZGF0YS10aXBcbiAqIC0gYGNoaWxkcmVuYCB7UmVhY3RFbGVtZW50fSB0aGlzLnByb3BzLmNoaWxkcmVuXG4gKiAtIGBtdWx0aWxpbmVgIHtBbnl9IGNvdWxkIGJlIEJvb2wodHJ1ZS9mYWxzZSkgb3IgU3RyaW5nKCd0cnVlJy8nZmFsc2UnKVxuICpcbiAqIEByZXR1cm5cbiAqIC0gU3RyaW5nIG9yIHJlYWN0IGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBUaXBDb250ZW50KHRpcCwgY2hpbGRyZW4sIGdldENvbnRlbnQsIG11bHRpbGluZSkge1xuICBpZiAoY2hpbGRyZW4pIHJldHVybiBjaGlsZHJlbjtcbiAgaWYgKGdldENvbnRlbnQgIT09IHVuZGVmaW5lZCAmJiBnZXRDb250ZW50ICE9PSBudWxsKSByZXR1cm4gZ2V0Q29udGVudDsgLy8gZ2V0Q29udGVudCBjYW4gYmUgMCwgJycsIGV0Yy5cbiAgaWYgKGdldENvbnRlbnQgPT09IG51bGwpIHJldHVybiBudWxsOyAvLyBUaXAgbm90IGV4aXN0IGFuZCBjaGlsZHJlbiBpcyBudWxsIG9yIHVuZGVmaW5lZFxuXG4gIHZhciByZWdleHAgPSAvPGJyXFxzKlxcLz8+LztcbiAgaWYgKCFtdWx0aWxpbmUgfHwgbXVsdGlsaW5lID09PSAnZmFsc2UnIHx8ICFyZWdleHAudGVzdCh0aXApKSB7XG4gICAgLy8gTm8gdHJpbSgpLCBzbyB0aGF0IHVzZXIgY2FuIGtlZXAgdGhlaXIgaW5wdXRcbiAgICByZXR1cm4gdGlwO1xuICB9XG5cbiAgLy8gTXVsdGlsaW5lIHRvb2x0aXAgY29udGVudFxuICByZXR1cm4gdGlwLnNwbGl0KHJlZ2V4cCkubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICBrZXk6IGksXG4gICAgICBjbGFzc05hbWU6IFwibXVsdGktbGluZVwiXG4gICAgfSwgZCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgYXJpYS0gYW5kIHJvbGUgaW4gUmVhY3RUb29sdGlwXG4gKlxuICogQHBhcmFtcyBwcm9wcyB7T2JqZWN0fVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBwYXJzZUFyaWEocHJvcHMpIHtcbiAgdmFyIGFyaWFPYmogPSB7fTtcbiAgT2JqZWN0LmtleXMocHJvcHMpLmZpbHRlcihmdW5jdGlvbiAocHJvcCkge1xuICAgIC8vIGFyaWEteHh4IGFuZCByb2xlIGlzIGFjY2VwdGFibGVcbiAgICByZXR1cm4gLyheYXJpYS1cXHcrJHxecm9sZSQpLy50ZXN0KHByb3ApO1xuICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgYXJpYU9ialtwcm9wXSA9IHByb3BzW3Byb3BdO1xuICB9KTtcbiAgcmV0dXJuIGFyaWFPYmo7XG59XG5cbi8qKlxuICogQ29udmVydCBub2RlbGlzdCB0byBhcnJheVxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvY29yZS9jcmVhdGVBcnJheUZyb21NaXhlZC5qcyNMMjRcbiAqIE5vZGVMaXN0cyBhcmUgZnVuY3Rpb25zIGluIFNhZmFyaVxuICovXG5cbmZ1bmN0aW9uIG5vZGVMaXN0VG9BcnJheShub2RlTGlzdCkge1xuICB2YXIgbGVuZ3RoID0gbm9kZUxpc3QubGVuZ3RoO1xuICBpZiAobm9kZUxpc3QuaGFzT3duUHJvcGVydHkpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobm9kZUxpc3QpO1xuICB9XG4gIHJldHVybiBuZXcgQXJyYXkobGVuZ3RoKS5maWxsKCkubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBub2RlTGlzdFtpbmRleF07XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCkge1xuICByZXR1cm4gJ3QnICsgdjQoKTtcbn1cbnZhciBiYXNlQ3NzID0gXCIuX19yZWFjdF9jb21wb25lbnRfdG9vbHRpcCB7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICBsZWZ0OiAtOTk5ZW07XFxuICBvcGFjaXR5OiAwO1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3MgZWFzZS1vdXQ7XFxuICB0b3A6IC05OTllbTtcXG4gIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIHotaW5kZXg6IDk5OTtcXG59XFxuLl9fcmVhY3RfY29tcG9uZW50X3Rvb2x0aXAuYWxsb3dfaG92ZXIsIC5fX3JlYWN0X2NvbXBvbmVudF90b29sdGlwLmFsbG93X2NsaWNrIHtcXG4gIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcbn1cXG4uX19yZWFjdF9jb21wb25lbnRfdG9vbHRpcDo6YmVmb3JlLCAuX19yZWFjdF9jb21wb25lbnRfdG9vbHRpcDo6YWZ0ZXIge1xcbiAgY29udGVudDogXFxcIlxcXCI7XFxuICB3aWR0aDogMDtcXG4gIGhlaWdodDogMDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuLl9fcmVhY3RfY29tcG9uZW50X3Rvb2x0aXAuc2hvdyB7XFxuICBvcGFjaXR5OiAwLjk7XFxuICBtYXJnaW4tdG9wOiAwO1xcbiAgbWFyZ2luLWxlZnQ6IDA7XFxuICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcbn1cXG4uX19yZWFjdF9jb21wb25lbnRfdG9vbHRpcC5wbGFjZS10b3A6OmJlZm9yZSB7XFxuICBib3R0b206IDA7XFxuICBsZWZ0OiA1MCU7XFxuICBtYXJnaW4tbGVmdDogLTExcHg7XFxufVxcbi5fX3JlYWN0X2NvbXBvbmVudF90b29sdGlwLnBsYWNlLWJvdHRvbTo6YmVmb3JlIHtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDUwJTtcXG4gIG1hcmdpbi1sZWZ0OiAtMTFweDtcXG59XFxuLl9fcmVhY3RfY29tcG9uZW50X3Rvb2x0aXAucGxhY2UtbGVmdDo6YmVmb3JlIHtcXG4gIHJpZ2h0OiAwO1xcbiAgdG9wOiA1MCU7XFxuICBtYXJnaW4tdG9wOiAtOXB4O1xcbn1cXG4uX19yZWFjdF9jb21wb25lbnRfdG9vbHRpcC5wbGFjZS1yaWdodDo6YmVmb3JlIHtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDUwJTtcXG4gIG1hcmdpbi10b3A6IC05cHg7XFxufVxcbi5fX3JlYWN0X2NvbXBvbmVudF90b29sdGlwIC5tdWx0aS1saW5lIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgcGFkZGluZzogMnB4IDA7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVwiO1xuXG4vKipcbiAqIERlZmF1bHQgcG9wLXVwIHN0eWxlIHZhbHVlcyAodGV4dCBjb2xvciwgYmFja2dyb3VuZCBjb2xvcikuXG4gKi9cbnZhciBkZWZhdWx0Q29sb3JzID0ge1xuICBkYXJrOiB7XG4gICAgdGV4dDogJyNmZmYnLFxuICAgIGJhY2tncm91bmQ6ICcjMjIyJyxcbiAgICBib3JkZXI6ICd0cmFuc3BhcmVudCcsXG4gICAgYXJyb3c6ICcjMjIyJ1xuICB9LFxuICBzdWNjZXNzOiB7XG4gICAgdGV4dDogJyNmZmYnLFxuICAgIGJhY2tncm91bmQ6ICcjOERDNTcyJyxcbiAgICBib3JkZXI6ICd0cmFuc3BhcmVudCcsXG4gICAgYXJyb3c6ICcjOERDNTcyJ1xuICB9LFxuICB3YXJuaW5nOiB7XG4gICAgdGV4dDogJyNmZmYnLFxuICAgIGJhY2tncm91bmQ6ICcjRjBBRDRFJyxcbiAgICBib3JkZXI6ICd0cmFuc3BhcmVudCcsXG4gICAgYXJyb3c6ICcjRjBBRDRFJ1xuICB9LFxuICBlcnJvcjoge1xuICAgIHRleHQ6ICcjZmZmJyxcbiAgICBiYWNrZ3JvdW5kOiAnI0JFNjQ2NCcsXG4gICAgYm9yZGVyOiAndHJhbnNwYXJlbnQnLFxuICAgIGFycm93OiAnI0JFNjQ2NCdcbiAgfSxcbiAgaW5mbzoge1xuICAgIHRleHQ6ICcjZmZmJyxcbiAgICBiYWNrZ3JvdW5kOiAnIzMzN0FCNycsXG4gICAgYm9yZGVyOiAndHJhbnNwYXJlbnQnLFxuICAgIGFycm93OiAnIzMzN0FCNydcbiAgfSxcbiAgbGlnaHQ6IHtcbiAgICB0ZXh0OiAnIzIyMicsXG4gICAgYmFja2dyb3VuZDogJyNmZmYnLFxuICAgIGJvcmRlcjogJ3RyYW5zcGFyZW50JyxcbiAgICBhcnJvdzogJyNmZmYnXG4gIH1cbn07XG5mdW5jdGlvbiBnZXREZWZhdWx0UG9wdXBDb2xvcnModHlwZSkge1xuICByZXR1cm4gZGVmYXVsdENvbG9yc1t0eXBlXSA/IF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0Q29sb3JzW3R5cGVdKSA6IHVuZGVmaW5lZDtcbn1cbnZhciBERUZBVUxUX1BBRERJTkcgPSAnOHB4IDIxcHgnO1xudmFyIERFRkFVTFRfUkFESVVTID0ge1xuICB0b29sdGlwOiAzLFxuICBhcnJvdzogMFxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdGhlIHNwZWNpZmljIHRvb2x0aXAgc3R5bGUgZm9yIHVzZSBvbiByZW5kZXIuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVG9vbHRpcFN0eWxlKHV1aWQsIGN1c3RvbUNvbG9ycywgdHlwZSwgaGFzQm9yZGVyLCBwYWRkaW5nLCByYWRpdXMpIHtcbiAgcmV0dXJuIGdlbmVyYXRlU3R5bGUodXVpZCwgZ2V0UG9wdXBDb2xvcnMoY3VzdG9tQ29sb3JzLCB0eXBlLCBoYXNCb3JkZXIpLCBwYWRkaW5nLCByYWRpdXMpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgdG9vbHRpcCBzdHlsZSBydWxlcyBiYXNlZCBvbiB0aGUgZWxlbWVudC1zcGVjaWZpZWQgXCJkYXRhLXR5cGVcIiBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVTdHlsZSh1dWlkLCBjb2xvcnMpIHtcbiAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IERFRkFVTFRfUEFERElORztcbiAgdmFyIHJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogREVGQVVMVF9SQURJVVM7XG4gIHZhciB0ZXh0Q29sb3IgPSBjb2xvcnMudGV4dDtcbiAgdmFyIGJhY2tncm91bmRDb2xvciA9IGNvbG9ycy5iYWNrZ3JvdW5kO1xuICB2YXIgYm9yZGVyQ29sb3IgPSBjb2xvcnMuYm9yZGVyO1xuICB2YXIgYXJyb3dDb2xvciA9IGNvbG9ycy5hcnJvdztcbiAgdmFyIGFycm93UmFkaXVzID0gcmFkaXVzLmFycm93O1xuICB2YXIgdG9vbHRpcFJhZGl1cyA9IHJhZGl1cy50b29sdGlwO1xuICByZXR1cm4gXCJcXG4gIFxcdC5cIi5jb25jYXQodXVpZCwgXCIge1xcblxcdCAgICBjb2xvcjogXCIpLmNvbmNhdCh0ZXh0Q29sb3IsIFwiO1xcblxcdCAgICBiYWNrZ3JvdW5kOiBcIikuY29uY2F0KGJhY2tncm91bmRDb2xvciwgXCI7XFxuXFx0ICAgIGJvcmRlcjogMXB4IHNvbGlkIFwiKS5jb25jYXQoYm9yZGVyQ29sb3IsIFwiO1xcblxcdCAgICBib3JkZXItcmFkaXVzOiBcIikuY29uY2F0KHRvb2x0aXBSYWRpdXMsIFwicHg7XFxuXFx0ICAgIHBhZGRpbmc6IFwiKS5jb25jYXQocGFkZGluZywgXCI7XFxuICBcXHR9XFxuXFxuICBcXHQuXCIpLmNvbmNhdCh1dWlkLCBcIi5wbGFjZS10b3Age1xcbiAgICAgICAgbWFyZ2luLXRvcDogLTEwcHg7XFxuICAgIH1cXG4gICAgLlwiKS5jb25jYXQodXVpZCwgXCIucGxhY2UtdG9wOjpiZWZvcmUge1xcbiAgICAgICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgei1pbmRleDogMjtcXG4gICAgICAgIHdpZHRoOiAyMHB4O1xcbiAgICAgICAgaGVpZ2h0OiAxMnB4O1xcbiAgICB9XFxuICAgIC5cIikuY29uY2F0KHV1aWQsIFwiLnBsYWNlLXRvcDo6YWZ0ZXIge1xcbiAgICAgICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICB3aWR0aDogMTBweDtcXG4gICAgICAgIGhlaWdodDogMTBweDtcXG4gICAgICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiBcIikuY29uY2F0KGFycm93UmFkaXVzLCBcInB4O1xcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgXCIpLmNvbmNhdChib3JkZXJDb2xvciwgXCI7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBcIikuY29uY2F0KGFycm93Q29sb3IsIFwiO1xcbiAgICAgICAgei1pbmRleDogLTI7XFxuICAgICAgICBib3R0b206IC02cHg7XFxuICAgICAgICBsZWZ0OiA1MCU7XFxuICAgICAgICBtYXJnaW4tbGVmdDogLTZweDtcXG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDEzNWRlZyk7XFxuICAgIH1cXG5cXG4gICAgLlwiKS5jb25jYXQodXVpZCwgXCIucGxhY2UtYm90dG9tIHtcXG4gICAgICAgIG1hcmdpbi10b3A6IDEwcHg7XFxuICAgIH1cXG4gICAgLlwiKS5jb25jYXQodXVpZCwgXCIucGxhY2UtYm90dG9tOjpiZWZvcmUge1xcbiAgICAgICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgei1pbmRleDogLTE7XFxuICAgICAgICB3aWR0aDogMThweDtcXG4gICAgICAgIGhlaWdodDogMTBweDtcXG4gICAgfVxcbiAgICAuXCIpLmNvbmNhdCh1dWlkLCBcIi5wbGFjZS1ib3R0b206OmFmdGVyIHtcXG4gICAgICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgd2lkdGg6IDEwcHg7XFxuICAgICAgICBoZWlnaHQ6IDEwcHg7XFxuICAgICAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogXCIpLmNvbmNhdChhcnJvd1JhZGl1cywgXCJweDtcXG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIFwiKS5jb25jYXQoYm9yZGVyQ29sb3IsIFwiO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogXCIpLmNvbmNhdChhcnJvd0NvbG9yLCBcIjtcXG4gICAgICAgIHotaW5kZXg6IC0yO1xcbiAgICAgICAgdG9wOiAtNnB4O1xcbiAgICAgICAgbGVmdDogNTAlO1xcbiAgICAgICAgbWFyZ2luLWxlZnQ6IC02cHg7XFxuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxuICAgIH1cXG5cXG4gICAgLlwiKS5jb25jYXQodXVpZCwgXCIucGxhY2UtbGVmdCB7XFxuICAgICAgICBtYXJnaW4tbGVmdDogLTEwcHg7XFxuICAgIH1cXG4gICAgLlwiKS5jb25jYXQodXVpZCwgXCIucGxhY2UtbGVmdDo6YmVmb3JlIHtcXG4gICAgICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogaW5oZXJpdDtcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIHotaW5kZXg6IC0xO1xcbiAgICAgICAgd2lkdGg6IDEwcHg7XFxuICAgICAgICBoZWlnaHQ6IDE4cHg7XFxuICAgIH1cXG4gICAgLlwiKS5jb25jYXQodXVpZCwgXCIucGxhY2UtbGVmdDo6YWZ0ZXIge1xcbiAgICAgICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICB3aWR0aDogMTBweDtcXG4gICAgICAgIGhlaWdodDogMTBweDtcXG4gICAgICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiBcIikuY29uY2F0KGFycm93UmFkaXVzLCBcInB4O1xcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgXCIpLmNvbmNhdChib3JkZXJDb2xvciwgXCI7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBcIikuY29uY2F0KGFycm93Q29sb3IsIFwiO1xcbiAgICAgICAgei1pbmRleDogLTI7XFxuICAgICAgICByaWdodDogLTZweDtcXG4gICAgICAgIHRvcDogNTAlO1xcbiAgICAgICAgbWFyZ2luLXRvcDogLTZweDtcXG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXG4gICAgfVxcblxcbiAgICAuXCIpLmNvbmNhdCh1dWlkLCBcIi5wbGFjZS1yaWdodCB7XFxuICAgICAgICBtYXJnaW4tbGVmdDogMTBweDtcXG4gICAgfVxcbiAgICAuXCIpLmNvbmNhdCh1dWlkLCBcIi5wbGFjZS1yaWdodDo6YmVmb3JlIHtcXG4gICAgICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogaW5oZXJpdDtcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIHotaW5kZXg6IC0xO1xcbiAgICAgICAgd2lkdGg6IDEwcHg7XFxuICAgICAgICBoZWlnaHQ6IDE4cHg7XFxuICAgIH1cXG4gICAgLlwiKS5jb25jYXQodXVpZCwgXCIucGxhY2UtcmlnaHQ6OmFmdGVyIHtcXG4gICAgICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgd2lkdGg6IDEwcHg7XFxuICAgICAgICBoZWlnaHQ6IDEwcHg7XFxuICAgICAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogXCIpLmNvbmNhdChhcnJvd1JhZGl1cywgXCJweDtcXG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIFwiKS5jb25jYXQoYm9yZGVyQ29sb3IsIFwiO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogXCIpLmNvbmNhdChhcnJvd0NvbG9yLCBcIjtcXG4gICAgICAgIHotaW5kZXg6IC0yO1xcbiAgICAgICAgbGVmdDogLTZweDtcXG4gICAgICAgIHRvcDogNTAlO1xcbiAgICAgICAgbWFyZ2luLXRvcDogLTZweDtcXG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKC0xMzVkZWcpO1xcbiAgICB9XFxuICBcIik7XG59XG5mdW5jdGlvbiBnZXRQb3B1cENvbG9ycyhjdXN0b21Db2xvcnMsIHR5cGUsIGhhc0JvcmRlcikge1xuICB2YXIgdGV4dENvbG9yID0gY3VzdG9tQ29sb3JzLnRleHQ7XG4gIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBjdXN0b21Db2xvcnMuYmFja2dyb3VuZDtcbiAgdmFyIGJvcmRlckNvbG9yID0gY3VzdG9tQ29sb3JzLmJvcmRlcjtcbiAgdmFyIGFycm93Q29sb3IgPSBjdXN0b21Db2xvcnMuYXJyb3cgPyBjdXN0b21Db2xvcnMuYXJyb3cgOiBjdXN0b21Db2xvcnMuYmFja2dyb3VuZDtcbiAgdmFyIGNvbG9ycyA9IGdldERlZmF1bHRQb3B1cENvbG9ycyh0eXBlKTtcbiAgaWYgKHRleHRDb2xvcikge1xuICAgIGNvbG9ycy50ZXh0ID0gdGV4dENvbG9yO1xuICB9XG4gIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICBjb2xvcnMuYmFja2dyb3VuZCA9IGJhY2tncm91bmRDb2xvcjtcbiAgfVxuICBpZiAoaGFzQm9yZGVyKSB7XG4gICAgaWYgKGJvcmRlckNvbG9yKSB7XG4gICAgICBjb2xvcnMuYm9yZGVyID0gYm9yZGVyQ29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9ycy5ib3JkZXIgPSB0eXBlID09PSAnbGlnaHQnID8gJ2JsYWNrJyA6ICd3aGl0ZSc7XG4gICAgfVxuICB9XG4gIGlmIChhcnJvd0NvbG9yKSB7XG4gICAgY29sb3JzLmFycm93ID0gYXJyb3dDb2xvcjtcbiAgfVxuICByZXR1cm4gY29sb3JzO1xufVxudmFyIF9jbGFzcywgX2NsYXNzMjtcblxuLyogUG9seWZpbGwgKi9cbnZhciBSZWFjdFRvb2x0aXAgPSBzdGF0aWNNZXRob2RzKF9jbGFzcyA9IHdpbmRvd0xpc3RlbmVyKF9jbGFzcyA9IGN1c3RvbUV2ZW50KF9jbGFzcyA9IGlzQ2FwdHVyZShfY2xhc3MgPSBnZXRFZmZlY3QoX2NsYXNzID0gYm9keU1vZGUoX2NsYXNzID0gdHJhY2tSZW1vdmFsKF9jbGFzcyA9IChfY2xhc3MyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhSZWFjdFRvb2x0aXAsIF9SZWFjdCRDb21wb25lbnQpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFJlYWN0VG9vbHRpcCk7XG4gIGZ1bmN0aW9uIFJlYWN0VG9vbHRpcChwcm9wcykge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVhY3RUb29sdGlwKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHV1aWQ6IHByb3BzLnV1aWQgfHwgZ2VuZXJhdGVVVUlEKCksXG4gICAgICBwbGFjZTogcHJvcHMucGxhY2UgfHwgJ3RvcCcsXG4gICAgICAvLyBEaXJlY3Rpb24gb2YgdG9vbHRpcFxuICAgICAgZGVzaXJlZFBsYWNlOiBwcm9wcy5wbGFjZSB8fCAndG9wJyxcbiAgICAgIHR5cGU6IHByb3BzLnR5cGUgfHwgJ2RhcmsnLFxuICAgICAgLy8gQ29sb3IgdGhlbWUgb2YgdG9vbHRpcFxuICAgICAgZWZmZWN0OiBwcm9wcy5lZmZlY3QgfHwgJ2Zsb2F0JyxcbiAgICAgIC8vIGZsb2F0IG9yIGZpeGVkXG4gICAgICBzaG93OiBmYWxzZSxcbiAgICAgIGJvcmRlcjogZmFsc2UsXG4gICAgICBib3JkZXJDbGFzczogJ2JvcmRlcicsXG4gICAgICBjdXN0b21Db2xvcnM6IHt9LFxuICAgICAgY3VzdG9tUmFkaXVzOiB7fSxcbiAgICAgIG9mZnNldDoge30sXG4gICAgICBwYWRkaW5nOiBwcm9wcy5wYWRkaW5nLFxuICAgICAgZXh0cmFDbGFzczogJycsXG4gICAgICBodG1sOiBmYWxzZSxcbiAgICAgIGRlbGF5SGlkZTogMCxcbiAgICAgIGRlbGF5U2hvdzogMCxcbiAgICAgIGV2ZW50OiBwcm9wcy5ldmVudCB8fCBudWxsLFxuICAgICAgZXZlbnRPZmY6IHByb3BzLmV2ZW50T2ZmIHx8IG51bGwsXG4gICAgICBjdXJyZW50RXZlbnQ6IG51bGwsXG4gICAgICAvLyBDdXJyZW50IG1vdXNlIGV2ZW50XG4gICAgICBjdXJyZW50VGFyZ2V0OiBudWxsLFxuICAgICAgLy8gQ3VycmVudCB0YXJnZXQgb2YgbW91c2UgZXZlbnRcbiAgICAgIGFyaWFQcm9wczogcGFyc2VBcmlhKHByb3BzKSxcbiAgICAgIC8vIGFyaWEtIGFuZCByb2xlIGF0dHJpYnV0ZXNcbiAgICAgIGlzRW1wdHlUaXA6IGZhbHNlLFxuICAgICAgZGlzYWJsZTogZmFsc2UsXG4gICAgICBwb3NzaWJsZUN1c3RvbUV2ZW50czogcHJvcHMucG9zc2libGVDdXN0b21FdmVudHMgfHwgJycsXG4gICAgICBwb3NzaWJsZUN1c3RvbUV2ZW50c09mZjogcHJvcHMucG9zc2libGVDdXN0b21FdmVudHNPZmYgfHwgJycsXG4gICAgICBvcmlnaW5Ub29sdGlwOiBudWxsLFxuICAgICAgaXNNdWx0aWxpbmU6IGZhbHNlXG4gICAgfTtcbiAgICBfdGhpcy5iaW5kKFsnc2hvd1Rvb2x0aXAnLCAndXBkYXRlVG9vbHRpcCcsICdoaWRlVG9vbHRpcCcsICdoaWRlVG9vbHRpcE9uU2Nyb2xsJywgJ2dldFRvb2x0aXBDb250ZW50JywgJ2dsb2JhbFJlYnVpbGQnLCAnZ2xvYmFsU2hvdycsICdnbG9iYWxIaWRlJywgJ29uV2luZG93UmVzaXplJywgJ21vdXNlT25Ub29sVGlwJ10pO1xuICAgIF90aGlzLm1vdW50ID0gdHJ1ZTtcbiAgICBfdGhpcy5kZWxheVNob3dMb29wID0gbnVsbDtcbiAgICBfdGhpcy5kZWxheUhpZGVMb29wID0gbnVsbDtcbiAgICBfdGhpcy5kZWxheVJlc2hvdyA9IG51bGw7XG4gICAgX3RoaXMuaW50ZXJ2YWxVcGRhdGVDb250ZW50ID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogRm9yIHVuaWZ5IHRoZSBiaW5kIGFuZCB1bmJpbmQgbGlzdGVuZXJcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhSZWFjdFRvb2x0aXAsIFt7XG4gICAga2V5OiBcImJpbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZChtZXRob2RBcnJheSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBtZXRob2RBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgX3RoaXMyW21ldGhvZF0gPSBfdGhpczJbbWV0aG9kXS5iaW5kKF90aGlzMik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgX3RoaXMkcHJvcHMuaW5zZWN1cmU7XG4gICAgICB2YXIgcmVzaXplSGlkZSA9IF90aGlzJHByb3BzLnJlc2l6ZUhpZGUsXG4gICAgICAgIGRpc2FibGVJbnRlcm5hbFN0eWxlID0gX3RoaXMkcHJvcHMuZGlzYWJsZUludGVybmFsU3R5bGU7XG4gICAgICB0aGlzLm1vdW50ID0gdHJ1ZTtcbiAgICAgIHRoaXMuYmluZExpc3RlbmVyKCk7IC8vIEJpbmQgbGlzdGVuZXIgZm9yIHRvb2x0aXBcbiAgICAgIHRoaXMuYmluZFdpbmRvd0V2ZW50cyhyZXNpemVIaWRlKTsgLy8gQmluZCBnbG9iYWwgZXZlbnQgZm9yIHN0YXRpYyBtZXRob2RcblxuICAgICAgaWYgKCFkaXNhYmxlSW50ZXJuYWxTdHlsZSkge1xuICAgICAgICB0aGlzLmluamVjdFN0eWxlcygpOyAvLyBJbmplY3Qgc3R5bGVzIGZvciBlYWNoIERPTSByb290IGhhdmluZyB0b29sdGlwLlxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMubW91bnQgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgdGhpcy51bmJpbmRMaXN0ZW5lcigpO1xuICAgICAgdGhpcy5yZW1vdmVTY3JvbGxMaXN0ZW5lcih0aGlzLnN0YXRlLmN1cnJlbnRUYXJnZXQpO1xuICAgICAgdGhpcy51bmJpbmRXaW5kb3dFdmVudHMoKTtcbiAgICB9XG5cbiAgICAvKiBMb29rIGZvciB0aGUgY2xvc2VzdCBET00gcm9vdCBoYXZpbmcgdG9vbHRpcCBhbmQgaW5qZWN0IHN0eWxlcy4gKi9cbiAgfSwge1xuICAgIGtleTogXCJpbmplY3RTdHlsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5qZWN0U3R5bGVzKCkge1xuICAgICAgdmFyIHRvb2x0aXBSZWYgPSB0aGlzLnRvb2x0aXBSZWY7XG4gICAgICBpZiAoIXRvb2x0aXBSZWYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHBhcmVudE5vZGUgPSB0b29sdGlwUmVmLnBhcmVudE5vZGU7XG4gICAgICB3aGlsZSAocGFyZW50Tm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICB2YXIgZG9tUm9vdDtcbiAgICAgIHN3aXRjaCAocGFyZW50Tm9kZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICAgIGNhc2UgJ0RvY3VtZW50JzpcbiAgICAgICAgY2FzZSAnSFRNTERvY3VtZW50JzpcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgZG9tUm9vdCA9IHBhcmVudE5vZGUuaGVhZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnU2hhZG93Um9vdCc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZG9tUm9vdCA9IHBhcmVudE5vZGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXZlbnQgc3R5bGVzIGR1cGxpY2F0aW9uLlxuICAgICAgaWYgKCFkb21Sb290LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtcmVhY3QtdG9vbHRpcF0nKSkge1xuICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IGJhc2VDc3M7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnZGF0YS1yZWFjdC10b29sdGlwJywgJ3RydWUnKTtcbiAgICAgICAgZG9tUm9vdC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGlmIHRoZSBtb3VzZSBpcyBvbiB0aGUgdG9vbHRpcC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSAtIG1vdXNlIGlzIG9uIHRoZSB0b29sdGlwXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibW91c2VPblRvb2xUaXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91c2VPblRvb2xUaXAoKSB7XG4gICAgICB2YXIgc2hvdyA9IHRoaXMuc3RhdGUuc2hvdztcbiAgICAgIGlmIChzaG93ICYmIHRoaXMudG9vbHRpcFJlZikge1xuICAgICAgICAvKiBvbGQgSUUgb3IgRmlyZWZveCB3b3JrIGFyb3VuZCAqL1xuICAgICAgICBpZiAoIXRoaXMudG9vbHRpcFJlZi5tYXRjaGVzKSB7XG4gICAgICAgICAgLyogb2xkIElFIHdvcmsgYXJvdW5kICovXG4gICAgICAgICAgaWYgKHRoaXMudG9vbHRpcFJlZi5tc01hdGNoZXNTZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy50b29sdGlwUmVmLm1hdGNoZXMgPSB0aGlzLnRvb2x0aXBSZWYubXNNYXRjaGVzU2VsZWN0b3I7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIG9sZCBGaXJlZm94IHdvcmsgYXJvdW5kICovXG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBSZWYubWF0Y2hlcyA9IHRoaXMudG9vbHRpcFJlZi5tb3pNYXRjaGVzU2VsZWN0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRvb2x0aXBSZWYubWF0Y2hlcygnOmhvdmVyJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGljayBvdXQgY29ycmVzcG9uZGVkIHRhcmdldCBlbGVtZW50c1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFRhcmdldEFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRhcmdldEFycmF5KGlkKSB7XG4gICAgICB2YXIgdGFyZ2V0QXJyYXkgPSBbXTtcbiAgICAgIHZhciBzZWxlY3RvcjtcbiAgICAgIGlmICghaWQpIHtcbiAgICAgICAgc2VsZWN0b3IgPSAnW2RhdGEtdGlwXTpub3QoW2RhdGEtZm9yXSknO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVzY2FwZWQgPSBpZC5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKTtcbiAgICAgICAgc2VsZWN0b3IgPSBcIltkYXRhLXRpcF1bZGF0YS1mb3I9XFxcIlwiLmNvbmNhdChlc2NhcGVkLCBcIlxcXCJdXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBTY2FuIGRvY3VtZW50IGZvciBzaGFkb3cgRE9NIGVsZW1lbnRzXG4gICAgICBub2RlTGlzdFRvQXJyYXkoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSkuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnNoYWRvd1Jvb3Q7XG4gICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHRhcmdldEFycmF5ID0gdGFyZ2V0QXJyYXkuY29uY2F0KG5vZGVMaXN0VG9BcnJheShlbGVtZW50LnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRhcmdldEFycmF5LmNvbmNhdChub2RlTGlzdFRvQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kIGxpc3RlbmVyIHRvIHRoZSB0YXJnZXQgZWxlbWVudHNcbiAgICAgKiBUaGVzZSBsaXN0ZW5lcnMgdXNlZCB0byB0cmlnZ2VyIHNob3dpbmcgb3IgaGlkaW5nIHRoZSB0b29sdGlwXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZExpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRMaXN0ZW5lcigpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgIGlkID0gX3RoaXMkcHJvcHMyLmlkLFxuICAgICAgICBnbG9iYWxFdmVudE9mZiA9IF90aGlzJHByb3BzMi5nbG9iYWxFdmVudE9mZixcbiAgICAgICAgaXNDYXB0dXJlID0gX3RoaXMkcHJvcHMyLmlzQ2FwdHVyZTtcbiAgICAgIHZhciB0YXJnZXRBcnJheSA9IHRoaXMuZ2V0VGFyZ2V0QXJyYXkoaWQpO1xuICAgICAgdGFyZ2V0QXJyYXkuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQuZ2V0QXR0cmlidXRlKCdjdXJyZW50SXRlbScpID09PSBudWxsKSB7XG4gICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnY3VycmVudEl0ZW0nLCAnZmFsc2UnKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczMudW5iaW5kQmFzaWNMaXN0ZW5lcih0YXJnZXQpO1xuICAgICAgICBpZiAoX3RoaXMzLmlzQ3VzdG9tRXZlbnQodGFyZ2V0KSkge1xuICAgICAgICAgIF90aGlzMy5jdXN0b21VbmJpbmRMaXN0ZW5lcih0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLmlzQm9keU1vZGUoKSkge1xuICAgICAgICB0aGlzLmJpbmRCb2R5TGlzdGVuZXIodGFyZ2V0QXJyYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0QXJyYXkuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgdmFyIGlzQ2FwdHVyZU1vZGUgPSBfdGhpczMuaXNDYXB0dXJlKHRhcmdldCk7XG4gICAgICAgICAgdmFyIGVmZmVjdCA9IF90aGlzMy5nZXRFZmZlY3QodGFyZ2V0KTtcbiAgICAgICAgICBpZiAoX3RoaXMzLmlzQ3VzdG9tRXZlbnQodGFyZ2V0KSkge1xuICAgICAgICAgICAgX3RoaXMzLmN1c3RvbUJpbmRMaXN0ZW5lcih0YXJnZXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIF90aGlzMy5zaG93VG9vbHRpcCwgaXNDYXB0dXJlTW9kZSk7XG4gICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgX3RoaXMzLnNob3dUb29sdGlwLCBpc0NhcHR1cmVNb2RlKTtcbiAgICAgICAgICBpZiAoZWZmZWN0ID09PSAnZmxvYXQnKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgX3RoaXMzLnVwZGF0ZVRvb2x0aXAsIGlzQ2FwdHVyZU1vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIF90aGlzMy5oaWRlVG9vbHRpcCwgaXNDYXB0dXJlTW9kZSk7XG4gICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBfdGhpczMuaGlkZVRvb2x0aXAsIGlzQ2FwdHVyZU1vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gR2xvYmFsIGV2ZW50IHRvIGhpZGUgdG9vbHRpcFxuICAgICAgaWYgKGdsb2JhbEV2ZW50T2ZmKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGdsb2JhbEV2ZW50T2ZmLCB0aGlzLmhpZGVUb29sdGlwKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZ2xvYmFsRXZlbnRPZmYsIHRoaXMuaGlkZVRvb2x0aXAsIGlzQ2FwdHVyZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyYWNrIHJlbW92YWwgb2YgdGFyZ2V0QXJyYXkgZWxlbWVudHMgZnJvbSBET01cbiAgICAgIHRoaXMuYmluZFJlbW92YWxUcmFja2VyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5iaW5kIGxpc3RlbmVycyBvbiB0YXJnZXQgZWxlbWVudHNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1bmJpbmRMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRMaXN0ZW5lcigpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGlkID0gX3RoaXMkcHJvcHMzLmlkLFxuICAgICAgICBnbG9iYWxFdmVudE9mZiA9IF90aGlzJHByb3BzMy5nbG9iYWxFdmVudE9mZjtcbiAgICAgIGlmICh0aGlzLmlzQm9keU1vZGUoKSkge1xuICAgICAgICB0aGlzLnVuYmluZEJvZHlMaXN0ZW5lcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRhcmdldEFycmF5ID0gdGhpcy5nZXRUYXJnZXRBcnJheShpZCk7XG4gICAgICAgIHRhcmdldEFycmF5LmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgIF90aGlzNC51bmJpbmRCYXNpY0xpc3RlbmVyKHRhcmdldCk7XG4gICAgICAgICAgaWYgKF90aGlzNC5pc0N1c3RvbUV2ZW50KHRhcmdldCkpIF90aGlzNC5jdXN0b21VbmJpbmRMaXN0ZW5lcih0YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChnbG9iYWxFdmVudE9mZikgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZ2xvYmFsRXZlbnRPZmYsIHRoaXMuaGlkZVRvb2x0aXApO1xuICAgICAgdGhpcy51bmJpbmRSZW1vdmFsVHJhY2tlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZSB0aGlzIGJlZm9yZSBiaW5kIGxpc3RlbmVyIGFuZCB1bm1vdW50IHRoZSBjb21wb25lbnRcbiAgICAgKiBpdCBpcyBuZWNlc3NhcnkgdG8gaW52b2tlIHRoaXMgZXZlbiB3aGVuIGJpbmRpbmcgY3VzdG9tIGV2ZW50XG4gICAgICogc28gdGhhdCB0aGUgdG9vbHRpcCBjYW4gc3dpdGNoIGJldHdlZW4gY3VzdG9tIGFuZCBkZWZhdWx0IGxpc3RlbmVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidW5iaW5kQmFzaWNMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRCYXNpY0xpc3RlbmVyKHRhcmdldCkge1xuICAgICAgdmFyIGlzQ2FwdHVyZU1vZGUgPSB0aGlzLmlzQ2FwdHVyZSh0YXJnZXQpO1xuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLnNob3dUb29sdGlwLCBpc0NhcHR1cmVNb2RlKTtcbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLnVwZGF0ZVRvb2x0aXAsIGlzQ2FwdHVyZU1vZGUpO1xuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLmhpZGVUb29sdGlwLCBpc0NhcHR1cmVNb2RlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VG9vbHRpcENvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG9vbHRpcENvbnRlbnQoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgZ2V0Q29udGVudCA9IF90aGlzJHByb3BzNC5nZXRDb250ZW50LFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzNC5jaGlsZHJlbjtcblxuICAgICAgLy8gR2VuZXJhdGUgdG9vbHRpcCBjb250ZW50XG4gICAgICB2YXIgY29udGVudDtcbiAgICAgIGlmIChnZXRDb250ZW50KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGdldENvbnRlbnQpKSB7XG4gICAgICAgICAgY29udGVudCA9IGdldENvbnRlbnRbMF0gJiYgZ2V0Q29udGVudFswXSh0aGlzLnN0YXRlLm9yaWdpblRvb2x0aXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRlbnQgPSBnZXRDb250ZW50KHRoaXMuc3RhdGUub3JpZ2luVG9vbHRpcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBUaXBDb250ZW50KHRoaXMuc3RhdGUub3JpZ2luVG9vbHRpcCwgY2hpbGRyZW4sIGNvbnRlbnQsIHRoaXMuc3RhdGUuaXNNdWx0aWxpbmUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0VtcHR5VGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRW1wdHlUaXAocGxhY2Vob2xkZXIpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgcGxhY2Vob2xkZXIgPT09ICdzdHJpbmcnICYmIHBsYWNlaG9sZGVyID09PSAnJyB8fCBwbGFjZWhvbGRlciA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIG1vdXNlIGVudGVyLCBzaG93IHRoZSB0b29sdGlwXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd1Rvb2x0aXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd1Rvb2x0aXAoZSwgaXNHbG9iYWxDYWxsKSB7XG4gICAgICBpZiAoIXRoaXMudG9vbHRpcFJlZikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNHbG9iYWxDYWxsKSB7XG4gICAgICAgIC8vIERvbid0IHRyaWdnZXIgb3RoZXIgZWxlbWVudHMgYmVsb25ncyB0byBvdGhlciBSZWFjdFRvb2x0aXBcbiAgICAgICAgdmFyIHRhcmdldEFycmF5ID0gdGhpcy5nZXRUYXJnZXRBcnJheSh0aGlzLnByb3BzLmlkKTtcbiAgICAgICAgdmFyIGlzTXlFbGVtZW50ID0gdGFyZ2V0QXJyYXkuc29tZShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZSA9PT0gZS5jdXJyZW50VGFyZ2V0O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFpc015RWxlbWVudCkgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gR2V0IHRoZSB0b29sdGlwIGNvbnRlbnRcbiAgICAgIC8vIGNhbGN1bGF0ZSBpbiB0aGlzIHBocmFzZSBzbyB0aGF0IHRpcCB3aWR0aCBoZWlnaHQgY2FuIGJlIGRldGVjdGVkXG4gICAgICB2YXIgX3RoaXMkcHJvcHM1ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgbXVsdGlsaW5lID0gX3RoaXMkcHJvcHM1Lm11bHRpbGluZSxcbiAgICAgICAgZ2V0Q29udGVudCA9IF90aGlzJHByb3BzNS5nZXRDb250ZW50O1xuICAgICAgdmFyIG9yaWdpblRvb2x0aXAgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXRpcCcpO1xuICAgICAgdmFyIGlzTXVsdGlsaW5lID0gZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1tdWx0aWxpbmUnKSB8fCBtdWx0aWxpbmUgfHwgZmFsc2U7XG5cbiAgICAgIC8vIElmIGl0IGlzIGZvY3VzIGV2ZW50IG9yIGNhbGxlZCBieSBSZWFjdFRvb2x0aXAuc2hvdywgc3dpdGNoIHRvIGBzb2xpZGAgZWZmZWN0XG4gICAgICB2YXIgc3dpdGNoVG9Tb2xpZCA9IGUgaW5zdGFuY2VvZiB3aW5kb3cuRm9jdXNFdmVudCB8fCBpc0dsb2JhbENhbGw7XG5cbiAgICAgIC8vIGlmIGl0IG5lZWRzIHRvIHNraXAgYWRkaW5nIGhpZGUgbGlzdGVuZXIgdG8gc2Nyb2xsXG4gICAgICB2YXIgc2Nyb2xsSGlkZSA9IHRydWU7XG4gICAgICBpZiAoZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1zY3JvbGwtaGlkZScpKSB7XG4gICAgICAgIHNjcm9sbEhpZGUgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXNjcm9sbC1oaWRlJykgPT09ICd0cnVlJztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5zY3JvbGxIaWRlICE9IG51bGwpIHtcbiAgICAgICAgc2Nyb2xsSGlkZSA9IHRoaXMucHJvcHMuc2Nyb2xsSGlkZTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkaW5nIGFyaWEtZGVzY3JpYmVkYnkgdG8gdGFyZ2V0IHRvIG1ha2UgdG9vbHRpcHMgcmVhZCBieSBzY3JlZW4gcmVhZGVyc1xuICAgICAgaWYgKGUgJiYgZS5jdXJyZW50VGFyZ2V0ICYmIGUuY3VycmVudFRhcmdldC5zZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsIHRoaXMucHJvcHMuaWQgfHwgdGhpcy5zdGF0ZS51dWlkKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjb3JyZWN0IHBsYWNlIGlzIHNldFxuICAgICAgdmFyIGRlc2lyZWRQbGFjZSA9IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGxhY2UnKSB8fCB0aGlzLnByb3BzLnBsYWNlIHx8ICd0b3AnO1xuICAgICAgdmFyIGVmZmVjdCA9IHN3aXRjaFRvU29saWQgJiYgJ3NvbGlkJyB8fCB0aGlzLmdldEVmZmVjdChlLmN1cnJlbnRUYXJnZXQpO1xuICAgICAgdmFyIG9mZnNldCA9IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb2Zmc2V0JykgfHwgdGhpcy5wcm9wcy5vZmZzZXQgfHwge307XG4gICAgICB2YXIgcmVzdWx0ID0gZ2V0UG9zaXRpb24oZSwgZS5jdXJyZW50VGFyZ2V0LCB0aGlzLnRvb2x0aXBSZWYsIGRlc2lyZWRQbGFjZS5zcGxpdCgnLCcpWzBdLCBkZXNpcmVkUGxhY2UsIGVmZmVjdCwgb2Zmc2V0KTtcbiAgICAgIGlmIChyZXN1bHQucG9zaXRpb24gJiYgdGhpcy5wcm9wcy5vdmVycmlkZVBvc2l0aW9uKSB7XG4gICAgICAgIHJlc3VsdC5wb3NpdGlvbiA9IHRoaXMucHJvcHMub3ZlcnJpZGVQb3NpdGlvbihyZXN1bHQucG9zaXRpb24sIGUsIGUuY3VycmVudFRhcmdldCwgdGhpcy50b29sdGlwUmVmLCBkZXNpcmVkUGxhY2UsIGRlc2lyZWRQbGFjZSwgZWZmZWN0LCBvZmZzZXQpO1xuICAgICAgfVxuICAgICAgdmFyIHBsYWNlID0gcmVzdWx0LmlzTmV3U3RhdGUgPyByZXN1bHQubmV3U3RhdGUucGxhY2UgOiBkZXNpcmVkUGxhY2Uuc3BsaXQoJywnKVswXTtcblxuICAgICAgLy8gVG8gcHJldmVudCBwcmV2aW91c2x5IGNyZWF0ZWQgdGltZXJzIGZyb20gdHJpZ2dlcmluZ1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICB2YXIgdGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0O1xuICAgICAgdmFyIHJlc2hvd0RlbGF5ID0gdGhpcy5zdGF0ZS5zaG93ID8gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1kZWxheS11cGRhdGUnKSB8fCB0aGlzLnByb3BzLmRlbGF5VXBkYXRlIDogMDtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciB1cGRhdGVTdGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKCkge1xuICAgICAgICBzZWxmLnNldFN0YXRlKHtcbiAgICAgICAgICBvcmlnaW5Ub29sdGlwOiBvcmlnaW5Ub29sdGlwLFxuICAgICAgICAgIGlzTXVsdGlsaW5lOiBpc011bHRpbGluZSxcbiAgICAgICAgICBkZXNpcmVkUGxhY2U6IGRlc2lyZWRQbGFjZSxcbiAgICAgICAgICBwbGFjZTogcGxhY2UsXG4gICAgICAgICAgdHlwZTogdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS10eXBlJykgfHwgc2VsZi5wcm9wcy50eXBlIHx8ICdkYXJrJyxcbiAgICAgICAgICBjdXN0b21Db2xvcnM6IHtcbiAgICAgICAgICAgIHRleHQ6IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGV4dC1jb2xvcicpIHx8IHNlbGYucHJvcHMudGV4dENvbG9yIHx8IG51bGwsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWJhY2tncm91bmQtY29sb3InKSB8fCBzZWxmLnByb3BzLmJhY2tncm91bmRDb2xvciB8fCBudWxsLFxuICAgICAgICAgICAgYm9yZGVyOiB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWJvcmRlci1jb2xvcicpIHx8IHNlbGYucHJvcHMuYm9yZGVyQ29sb3IgfHwgbnVsbCxcbiAgICAgICAgICAgIGFycm93OiB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWFycm93LWNvbG9yJykgfHwgc2VsZi5wcm9wcy5hcnJvd0NvbG9yIHx8IG51bGxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGN1c3RvbVJhZGl1czoge1xuICAgICAgICAgICAgdG9vbHRpcDogdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwLXJhZGl1cycpIHx8IHNlbGYucHJvcHMudG9vbHRpcFJhZGl1cyB8fCAnMycsXG4gICAgICAgICAgICBhcnJvdzogdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1hcnJvdy1yYWRpdXMnKSB8fCBzZWxmLnByb3BzLmFycm93UmFkaXVzIHx8ICcwJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZWZmZWN0OiBlZmZlY3QsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgcGFkZGluZzogdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1wYWRkaW5nJykgfHwgc2VsZi5wcm9wcy5wYWRkaW5nLFxuICAgICAgICAgIGh0bWw6ICh0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWh0bWwnKSA/IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaHRtbCcpID09PSAndHJ1ZScgOiBzZWxmLnByb3BzLmh0bWwpIHx8IGZhbHNlLFxuICAgICAgICAgIGRlbGF5U2hvdzogdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1kZWxheS1zaG93JykgfHwgc2VsZi5wcm9wcy5kZWxheVNob3cgfHwgMCxcbiAgICAgICAgICBkZWxheUhpZGU6IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGVsYXktaGlkZScpIHx8IHNlbGYucHJvcHMuZGVsYXlIaWRlIHx8IDAsXG4gICAgICAgICAgZGVsYXlVcGRhdGU6IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGVsYXktdXBkYXRlJykgfHwgc2VsZi5wcm9wcy5kZWxheVVwZGF0ZSB8fCAwLFxuICAgICAgICAgIGJvcmRlcjogKHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYm9yZGVyJykgPyB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWJvcmRlcicpID09PSAndHJ1ZScgOiBzZWxmLnByb3BzLmJvcmRlcikgfHwgZmFsc2UsXG4gICAgICAgICAgYm9yZGVyQ2xhc3M6IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYm9yZGVyLWNsYXNzJykgfHwgc2VsZi5wcm9wcy5ib3JkZXJDbGFzcyB8fCAnYm9yZGVyJyxcbiAgICAgICAgICBleHRyYUNsYXNzOiB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWNsYXNzJykgfHwgc2VsZi5wcm9wc1tcImNsYXNzXCJdIHx8IHNlbGYucHJvcHMuY2xhc3NOYW1lIHx8ICcnLFxuICAgICAgICAgIGRpc2FibGU6ICh0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXRpcC1kaXNhYmxlJykgPyB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXRpcC1kaXNhYmxlJykgPT09ICd0cnVlJyA6IHNlbGYucHJvcHMuZGlzYWJsZSkgfHwgZmFsc2UsXG4gICAgICAgICAgY3VycmVudFRhcmdldDogdGFyZ2V0XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoc2Nyb2xsSGlkZSkge1xuICAgICAgICAgICAgc2VsZi5hZGRTY3JvbGxMaXN0ZW5lcihzZWxmLnN0YXRlLmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLnVwZGF0ZVRvb2x0aXAoZSk7XG4gICAgICAgICAgaWYgKGdldENvbnRlbnQgJiYgQXJyYXkuaXNBcnJheShnZXRDb250ZW50KSkge1xuICAgICAgICAgICAgc2VsZi5pbnRlcnZhbFVwZGF0ZUNvbnRlbnQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChzZWxmLm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9nZXRDb250ZW50ID0gc2VsZi5wcm9wcy5nZXRDb250ZW50O1xuICAgICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IFRpcENvbnRlbnQob3JpZ2luVG9vbHRpcCwgJycsIF9nZXRDb250ZW50WzBdKCksIGlzTXVsdGlsaW5lKTtcbiAgICAgICAgICAgICAgICB2YXIgaXNFbXB0eVRpcCA9IHNlbGYuaXNFbXB0eVRpcChwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICBpc0VtcHR5VGlwOiBpc0VtcHR5VGlwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBnZXRDb250ZW50WzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZGVsYXkgY2FsbCBpbW1lZGlhdGVseSwgZG9uJ3QgYWxsb3cgZXZlbnRzIHRvIGdldCBpbiBmaXJzdC5cbiAgICAgIGlmIChyZXNob3dEZWxheSkge1xuICAgICAgICB0aGlzLmRlbGF5UmVzaG93ID0gc2V0VGltZW91dCh1cGRhdGVTdGF0ZSwgcmVzaG93RGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIG1vdXNlIGhvdmVyLCB1cGRhdGUgdG9vbCB0aXBcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVUb29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVRvb2x0aXAoZSkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUgPSB0aGlzLnN0YXRlLFxuICAgICAgICBkZWxheVNob3cgPSBfdGhpcyRzdGF0ZS5kZWxheVNob3csXG4gICAgICAgIGRpc2FibGUgPSBfdGhpcyRzdGF0ZS5kaXNhYmxlO1xuICAgICAgdmFyIF90aGlzJHByb3BzNiA9IHRoaXMucHJvcHMsXG4gICAgICAgIGFmdGVyU2hvdyA9IF90aGlzJHByb3BzNi5hZnRlclNob3csXG4gICAgICAgIGRpc2FibGVQcm9wID0gX3RoaXMkcHJvcHM2LmRpc2FibGU7XG4gICAgICB2YXIgcGxhY2Vob2xkZXIgPSB0aGlzLmdldFRvb2x0aXBDb250ZW50KCk7XG4gICAgICB2YXIgZXZlbnRUYXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQgfHwgZS50YXJnZXQ7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBtb3VzZSBpcyBhY3R1YWxseSBvdmVyIHRoZSB0b29sdGlwLCBpZiBzbyBkb24ndCBoaWRlIHRoZSB0b29sdGlwXG4gICAgICBpZiAodGhpcy5tb3VzZU9uVG9vbFRpcCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlIHRvb2x0aXAgaXMgZW1wdHksIGRpc2FibGUgdGhlIHRvb2x0aXBcbiAgICAgIGlmICh0aGlzLmlzRW1wdHlUaXAocGxhY2Vob2xkZXIpIHx8IGRpc2FibGUgfHwgZGlzYWJsZVByb3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGRlbGF5VGltZSA9ICF0aGlzLnN0YXRlLnNob3cgPyBwYXJzZUludChkZWxheVNob3csIDEwKSA6IDA7XG4gICAgICB2YXIgdXBkYXRlU3RhdGUgPSBmdW5jdGlvbiB1cGRhdGVTdGF0ZSgpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGxhY2Vob2xkZXIpICYmIHBsYWNlaG9sZGVyLmxlbmd0aCA+IDAgfHwgcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICB2YXIgaXNJbnZpc2libGUgPSAhX3RoaXM1LnN0YXRlLnNob3c7XG4gICAgICAgICAgX3RoaXM1LnNldFN0YXRlKHtcbiAgICAgICAgICAgIGN1cnJlbnRFdmVudDogZSxcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IGV2ZW50VGFyZ2V0LFxuICAgICAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzNS51cGRhdGVQb3NpdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChpc0ludmlzaWJsZSAmJiBhZnRlclNob3cpIHtcbiAgICAgICAgICAgICAgICBhZnRlclNob3coZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZGVsYXlTaG93TG9vcCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWxheVNob3dMb29wKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWxheVRpbWUpIHtcbiAgICAgICAgdGhpcy5kZWxheVNob3dMb29wID0gc2V0VGltZW91dCh1cGRhdGVTdGF0ZSwgZGVsYXlUaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVsYXlTaG93TG9vcCA9IG51bGw7XG4gICAgICAgIHVwZGF0ZVN0YXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBJZiB3ZSdyZSBtb3VzaW5nIG92ZXIgdGhlIHRvb2x0aXAgcmVtb3ZlIGl0IHdoZW4gd2UgbGVhdmUuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibGlzdGVuRm9yVG9vbHRpcEV4aXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuRm9yVG9vbHRpcEV4aXQoKSB7XG4gICAgICB2YXIgc2hvdyA9IHRoaXMuc3RhdGUuc2hvdztcbiAgICAgIGlmIChzaG93ICYmIHRoaXMudG9vbHRpcFJlZikge1xuICAgICAgICB0aGlzLnRvb2x0aXBSZWYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuaGlkZVRvb2x0aXApO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVMaXN0ZW5lckZvclRvb2x0aXBFeGl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyRm9yVG9vbHRpcEV4aXQoKSB7XG4gICAgICB2YXIgc2hvdyA9IHRoaXMuc3RhdGUuc2hvdztcbiAgICAgIGlmIChzaG93ICYmIHRoaXMudG9vbHRpcFJlZikge1xuICAgICAgICB0aGlzLnRvb2x0aXBSZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuaGlkZVRvb2x0aXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gbW91c2UgbGVhdmUsIGhpZGUgdG9vbHRpcFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImhpZGVUb29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGVUb29sdGlwKGUsIGhhc1RhcmdldCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge1xuICAgICAgICBpc1Njcm9sbDogZmFsc2VcbiAgICAgIH07XG4gICAgICB2YXIgZGlzYWJsZSA9IHRoaXMuc3RhdGUuZGlzYWJsZTtcbiAgICAgIHZhciBpc1Njcm9sbCA9IG9wdGlvbnMuaXNTY3JvbGw7XG4gICAgICB2YXIgZGVsYXlIaWRlID0gaXNTY3JvbGwgPyAwIDogdGhpcy5zdGF0ZS5kZWxheUhpZGU7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM3ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYWZ0ZXJIaWRlID0gX3RoaXMkcHJvcHM3LmFmdGVySGlkZSxcbiAgICAgICAgZGlzYWJsZVByb3AgPSBfdGhpcyRwcm9wczcuZGlzYWJsZTtcbiAgICAgIHZhciBwbGFjZWhvbGRlciA9IHRoaXMuZ2V0VG9vbHRpcENvbnRlbnQoKTtcbiAgICAgIGlmICghdGhpcy5tb3VudCkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuaXNFbXB0eVRpcChwbGFjZWhvbGRlcikgfHwgZGlzYWJsZSB8fCBkaXNhYmxlUHJvcCkgcmV0dXJuOyAvLyBpZiB0aGUgdG9vbHRpcCBpcyBlbXB0eSwgZGlzYWJsZSB0aGUgdG9vbHRpcFxuICAgICAgaWYgKGhhc1RhcmdldCkge1xuICAgICAgICAvLyBEb24ndCB0cmlnZ2VyIG90aGVyIGVsZW1lbnRzIGJlbG9uZ3MgdG8gb3RoZXIgUmVhY3RUb29sdGlwXG4gICAgICAgIHZhciB0YXJnZXRBcnJheSA9IHRoaXMuZ2V0VGFyZ2V0QXJyYXkodGhpcy5wcm9wcy5pZCk7XG4gICAgICAgIHZhciBpc015RWxlbWVudCA9IHRhcmdldEFycmF5LnNvbWUoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUgPT09IGUuY3VycmVudFRhcmdldDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaXNNeUVsZW1lbnQgfHwgIXRoaXMuc3RhdGUuc2hvdykgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBjbGVhbiB1cCBhcmlhLWRlc2NyaWJlZGJ5IHdoZW4gaGlkaW5nIHRvb2x0aXBcbiAgICAgIGlmIChlICYmIGUuY3VycmVudFRhcmdldCAmJiBlLmN1cnJlbnRUYXJnZXQucmVtb3ZlQXR0cmlidXRlKSB7XG4gICAgICAgIGUuY3VycmVudFRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXNldFN0YXRlID0gZnVuY3Rpb24gcmVzZXRTdGF0ZSgpIHtcbiAgICAgICAgdmFyIGlzVmlzaWJsZSA9IF90aGlzNi5zdGF0ZS5zaG93O1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgbW91c2UgaXMgYWN0dWFsbHkgb3ZlciB0aGUgdG9vbHRpcCwgaWYgc28gZG9uJ3QgaGlkZSB0aGUgdG9vbHRpcFxuICAgICAgICBpZiAoX3RoaXM2Lm1vdXNlT25Ub29sVGlwKCkpIHtcbiAgICAgICAgICBfdGhpczYubGlzdGVuRm9yVG9vbHRpcEV4aXQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXM2LnJlbW92ZUxpc3RlbmVyRm9yVG9vbHRpcEV4aXQoKTtcbiAgICAgICAgX3RoaXM2LnNldFN0YXRlKHtcbiAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM2LnJlbW92ZVNjcm9sbExpc3RlbmVyKF90aGlzNi5zdGF0ZS5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICBpZiAoaXNWaXNpYmxlICYmIGFmdGVySGlkZSkge1xuICAgICAgICAgICAgYWZ0ZXJIaWRlKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICBpZiAoZGVsYXlIaWRlKSB7XG4gICAgICAgIHRoaXMuZGVsYXlIaWRlTG9vcCA9IHNldFRpbWVvdXQocmVzZXRTdGF0ZSwgcGFyc2VJbnQoZGVsYXlIaWRlLCAxMCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2Nyb2xsLCBoaWRlIHRvb2x0aXBcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJoaWRlVG9vbHRpcE9uU2Nyb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGVUb29sdGlwT25TY3JvbGwoZXZlbnQsIGhhc1RhcmdldCkge1xuICAgICAgdGhpcy5oaWRlVG9vbHRpcChldmVudCwgaGFzVGFyZ2V0LCB7XG4gICAgICAgIGlzU2Nyb2xsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIHdoZW4gdG9vbHRpcCBzaG93XG4gICAgICogYXV0b21hdGljYWxseSBoaWRlIHRoZSB0b29sdGlwIHdoZW4gc2Nyb2xsaW5nXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkU2Nyb2xsTGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU2Nyb2xsTGlzdGVuZXIoY3VycmVudFRhcmdldCkge1xuICAgICAgdmFyIGlzQ2FwdHVyZU1vZGUgPSB0aGlzLmlzQ2FwdHVyZShjdXJyZW50VGFyZ2V0KTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhpZGVUb29sdGlwT25TY3JvbGwsIGlzQ2FwdHVyZU1vZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVTY3JvbGxMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVTY3JvbGxMaXN0ZW5lcihjdXJyZW50VGFyZ2V0KSB7XG4gICAgICB2YXIgaXNDYXB0dXJlTW9kZSA9IHRoaXMuaXNDYXB0dXJlKGN1cnJlbnRUYXJnZXQpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGlkZVRvb2x0aXBPblNjcm9sbCwgaXNDYXB0dXJlTW9kZSk7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRpb24gdGhlIHBvc2l0aW9uXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oY2FsbGJhY2tBZnRlcikge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUyID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgY3VycmVudEV2ZW50ID0gX3RoaXMkc3RhdGUyLmN1cnJlbnRFdmVudCxcbiAgICAgICAgY3VycmVudFRhcmdldCA9IF90aGlzJHN0YXRlMi5jdXJyZW50VGFyZ2V0LFxuICAgICAgICBwbGFjZSA9IF90aGlzJHN0YXRlMi5wbGFjZSxcbiAgICAgICAgZGVzaXJlZFBsYWNlID0gX3RoaXMkc3RhdGUyLmRlc2lyZWRQbGFjZSxcbiAgICAgICAgZWZmZWN0ID0gX3RoaXMkc3RhdGUyLmVmZmVjdCxcbiAgICAgICAgb2Zmc2V0ID0gX3RoaXMkc3RhdGUyLm9mZnNldDtcbiAgICAgIHZhciBub2RlID0gdGhpcy50b29sdGlwUmVmO1xuICAgICAgdmFyIHJlc3VsdCA9IGdldFBvc2l0aW9uKGN1cnJlbnRFdmVudCwgY3VycmVudFRhcmdldCwgbm9kZSwgcGxhY2UsIGRlc2lyZWRQbGFjZSwgZWZmZWN0LCBvZmZzZXQpO1xuICAgICAgaWYgKHJlc3VsdC5wb3NpdGlvbiAmJiB0aGlzLnByb3BzLm92ZXJyaWRlUG9zaXRpb24pIHtcbiAgICAgICAgcmVzdWx0LnBvc2l0aW9uID0gdGhpcy5wcm9wcy5vdmVycmlkZVBvc2l0aW9uKHJlc3VsdC5wb3NpdGlvbiwgY3VycmVudEV2ZW50LCBjdXJyZW50VGFyZ2V0LCBub2RlLCBwbGFjZSwgZGVzaXJlZFBsYWNlLCBlZmZlY3QsIG9mZnNldCk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmlzTmV3U3RhdGUpIHtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHJldmVyc2UgcGxhY2VtZW50XG4gICAgICAgIHJldHVybiB0aGlzLnNldFN0YXRlKHJlc3VsdC5uZXdTdGF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNy51cGRhdGVQb3NpdGlvbihjYWxsYmFja0FmdGVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2tBZnRlciAmJiB0eXBlb2YgY2FsbGJhY2tBZnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFja0FmdGVyKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0b29sdGlwIHBvc2l0aW9uXG4gICAgICBub2RlLnN0eWxlLmxlZnQgPSByZXN1bHQucG9zaXRpb24ubGVmdCArICdweCc7XG4gICAgICBub2RlLnN0eWxlLnRvcCA9IHJlc3VsdC5wb3NpdGlvbi50b3AgKyAncHgnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENMZWFyIGFsbCBraW5kcyBvZiB0aW1lb3V0IG9mIGludGVydmFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJUaW1lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclRpbWVyKCkge1xuICAgICAgaWYgKHRoaXMuZGVsYXlTaG93TG9vcCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWxheVNob3dMb29wKTtcbiAgICAgICAgdGhpcy5kZWxheVNob3dMb29wID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRlbGF5SGlkZUxvb3ApIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlIaWRlTG9vcCk7XG4gICAgICAgIHRoaXMuZGVsYXlIaWRlTG9vcCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kZWxheVJlc2hvdykge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWxheVJlc2hvdyk7XG4gICAgICAgIHRoaXMuZGVsYXlSZXNob3cgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaW50ZXJ2YWxVcGRhdGVDb250ZW50KSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbFVwZGF0ZUNvbnRlbnQpO1xuICAgICAgICB0aGlzLmludGVydmFsVXBkYXRlQ29udGVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc0N1c3RvbUNvbG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNDdXN0b21Db2xvcnMoKSB7XG4gICAgICB2YXIgX3RoaXM4ID0gdGhpcztcbiAgICAgIHJldHVybiBCb29sZWFuKE9iamVjdC5rZXlzKHRoaXMuc3RhdGUuY3VzdG9tQ29sb3JzKS5maW5kKGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gY29sb3IgIT09ICdib3JkZXInICYmIF90aGlzOC5zdGF0ZS5jdXN0b21Db2xvcnNbY29sb3JdO1xuICAgICAgfSkgfHwgdGhpcy5zdGF0ZS5ib3JkZXIgJiYgdGhpcy5zdGF0ZS5jdXN0b21Db2xvcnNbJ2JvcmRlciddKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuICAgICAgdmFyIF90aGlzJHN0YXRlMyA9IHRoaXMuc3RhdGUsXG4gICAgICAgIGV4dHJhQ2xhc3MgPSBfdGhpcyRzdGF0ZTMuZXh0cmFDbGFzcyxcbiAgICAgICAgaHRtbCA9IF90aGlzJHN0YXRlMy5odG1sLFxuICAgICAgICBhcmlhUHJvcHMgPSBfdGhpcyRzdGF0ZTMuYXJpYVByb3BzLFxuICAgICAgICBkaXNhYmxlID0gX3RoaXMkc3RhdGUzLmRpc2FibGUsXG4gICAgICAgIHV1aWQgPSBfdGhpcyRzdGF0ZTMudXVpZDtcbiAgICAgIHZhciBjb250ZW50ID0gdGhpcy5nZXRUb29sdGlwQ29udGVudCgpO1xuICAgICAgdmFyIGlzRW1wdHlUaXAgPSB0aGlzLmlzRW1wdHlUaXAoY29udGVudCk7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLnByb3BzLmRpc2FibGVJbnRlcm5hbFN0eWxlID8gJycgOiBnZW5lcmF0ZVRvb2x0aXBTdHlsZSh0aGlzLnN0YXRlLnV1aWQsIHRoaXMuc3RhdGUuY3VzdG9tQ29sb3JzLCB0aGlzLnN0YXRlLnR5cGUsIHRoaXMuc3RhdGUuYm9yZGVyLCB0aGlzLnN0YXRlLnBhZGRpbmcsIHRoaXMuc3RhdGUuY3VzdG9tUmFkaXVzKTtcbiAgICAgIHZhciB0b29sdGlwQ2xhc3MgPSAnX19yZWFjdF9jb21wb25lbnRfdG9vbHRpcCcgKyBcIiBcIi5jb25jYXQodGhpcy5zdGF0ZS51dWlkKSArICh0aGlzLnN0YXRlLnNob3cgJiYgIWRpc2FibGUgJiYgIWlzRW1wdHlUaXAgPyAnIHNob3cnIDogJycpICsgKHRoaXMuc3RhdGUuYm9yZGVyID8gJyAnICsgdGhpcy5zdGF0ZS5ib3JkZXJDbGFzcyA6ICcnKSArIFwiIHBsYWNlLVwiLmNvbmNhdCh0aGlzLnN0YXRlLnBsYWNlKSArXG4gICAgICAvLyB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHRcbiAgICAgIFwiIHR5cGUtXCIuY29uY2F0KHRoaXMuaGFzQ3VzdG9tQ29sb3JzKCkgPyAnY3VzdG9tJyA6IHRoaXMuc3RhdGUudHlwZSkgKyAoXG4gICAgICAvLyBkYXJrLCBzdWNjZXNzLCB3YXJuaW5nLCBlcnJvciwgaW5mbywgbGlnaHQsIGN1c3RvbVxuICAgICAgdGhpcy5wcm9wcy5kZWxheVVwZGF0ZSA/ICcgYWxsb3dfaG92ZXInIDogJycpICsgKHRoaXMucHJvcHMuY2xpY2thYmxlID8gJyBhbGxvd19jbGljaycgOiAnJyk7XG4gICAgICB2YXIgV3JhcHBlciA9IHRoaXMucHJvcHMud3JhcHBlcjtcbiAgICAgIGlmIChSZWFjdFRvb2x0aXAuc3VwcG9ydGVkV3JhcHBlcnMuaW5kZXhPZihXcmFwcGVyKSA8IDApIHtcbiAgICAgICAgV3JhcHBlciA9IFJlYWN0VG9vbHRpcC5kZWZhdWx0UHJvcHMud3JhcHBlcjtcbiAgICAgIH1cbiAgICAgIHZhciB3cmFwcGVyQ2xhc3NOYW1lID0gW3Rvb2x0aXBDbGFzcywgZXh0cmFDbGFzc10uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyAnKTtcbiAgICAgIGlmIChodG1sKSB7XG4gICAgICAgIHZhciBodG1sQ29udGVudCA9IFwiXCIuY29uY2F0KGNvbnRlbnQpLmNvbmNhdChzdHlsZSA/IFwiXFxuPHN0eWxlIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj5cIi5jb25jYXQoc3R5bGUsIFwiPC9zdHlsZT5cIikgOiAnJyk7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChXcmFwcGVyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdCh3cmFwcGVyQ2xhc3NOYW1lKSxcbiAgICAgICAgICBpZDogdGhpcy5wcm9wcy5pZCB8fCB1dWlkLFxuICAgICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKF9yZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczkudG9vbHRpcFJlZiA9IF9yZWY7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBhcmlhUHJvcHMsIHtcbiAgICAgICAgICBcImRhdGEtaWRcIjogXCJ0b29sdGlwXCIsXG4gICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICAgIF9faHRtbDogaHRtbENvbnRlbnRcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChXcmFwcGVyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdCh3cmFwcGVyQ2xhc3NOYW1lKSxcbiAgICAgICAgICBpZDogdGhpcy5wcm9wcy5pZCB8fCB1dWlkXG4gICAgICAgIH0sIGFyaWFQcm9wcywge1xuICAgICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKF9yZWYyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM5LnRvb2x0aXBSZWYgPSBfcmVmMjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGF0YS1pZFwiOiBcInRvb2x0aXBcIlxuICAgICAgICB9KSwgc3R5bGUgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB7XG4gICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICAgIF9faHRtbDogc3R5bGVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCJcbiAgICAgICAgfSksIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInByb3BUeXBlc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXVpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gICAgICAgIHBsYWNlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICB0eXBlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBlZmZlY3Q6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIG9mZnNldDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgcGFkZGluZzogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgbXVsdGlsaW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgYm9yZGVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgYm9yZGVyQ2xhc3M6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHRleHRDb2xvcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBib3JkZXJDb2xvcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgYXJyb3dDb2xvcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgYXJyb3dSYWRpdXM6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHRvb2x0aXBSYWRpdXM6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGluc2VjdXJlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgXCJjbGFzc1wiOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBodG1sOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgZGVsYXlIaWRlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBkZWxheVVwZGF0ZTogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgZGVsYXlTaG93OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBldmVudDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgZXZlbnRPZmY6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGlzQ2FwdHVyZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGdsb2JhbEV2ZW50T2ZmOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBnZXRDb250ZW50OiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBhZnRlclNob3c6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBhZnRlckhpZGU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvdmVycmlkZVBvc2l0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgZGlzYWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHNjcm9sbEhpZGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICByZXNpemVIaWRlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgd3JhcHBlcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgYm9keU1vZGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBwb3NzaWJsZUN1c3RvbUV2ZW50czogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcG9zc2libGVDdXN0b21FdmVudHNPZmY6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNsaWNrYWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGRpc2FibGVJbnRlcm5hbFN0eWxlOiBQcm9wVHlwZXMuYm9vbFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgdmFyIGFyaWFQcm9wcyA9IHByZXZTdGF0ZS5hcmlhUHJvcHM7XG4gICAgICB2YXIgbmV3QXJpYVByb3BzID0gcGFyc2VBcmlhKG5leHRQcm9wcyk7XG4gICAgICB2YXIgaXNDaGFuZ2VkID0gT2JqZWN0LmtleXMobmV3QXJpYVByb3BzKS5zb21lKGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICByZXR1cm4gbmV3QXJpYVByb3BzW3Byb3BzXSAhPT0gYXJpYVByb3BzW3Byb3BzXTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpc0NoYW5nZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHByZXZTdGF0ZSksIHt9LCB7XG4gICAgICAgIGFyaWFQcm9wczogbmV3QXJpYVByb3BzXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJlYWN0VG9vbHRpcDtcbn0oUmVhY3QuQ29tcG9uZW50KSwgX2RlZmluZVByb3BlcnR5KF9jbGFzczIsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgaW5zZWN1cmU6IHRydWUsXG4gIHJlc2l6ZUhpZGU6IHRydWUsXG4gIHdyYXBwZXI6ICdkaXYnLFxuICBjbGlja2FibGU6IGZhbHNlXG59KSwgX2RlZmluZVByb3BlcnR5KF9jbGFzczIsIFwic3VwcG9ydGVkV3JhcHBlcnNcIiwgWydkaXYnLCAnc3BhbiddKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzczIsIFwiZGlzcGxheU5hbWVcIiwgJ1JlYWN0VG9vbHRpcCcpLCBfY2xhc3MyKSkgfHwgX2NsYXNzKSB8fCBfY2xhc3MpIHx8IF9jbGFzcykgfHwgX2NsYXNzKSB8fCBfY2xhc3MpIHx8IF9jbGFzcykgfHwgX2NsYXNzO1xuZXhwb3J0IHsgUmVhY3RUb29sdGlwIGFzIGRlZmF1bHQgfTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB2YXIgZGlzSW5kaWNhdG9yVmFsdWUgPSBcIkluZGljYXRvci1tb2R1bGUtLWRpc0luZGljYXRvclZhbHVlLS1EWDBJZ1wiO1xuZXhwb3J0IHZhciBpbmRpY2F0b3JCb3hNYWluID0gXCJJbmRpY2F0b3ItbW9kdWxlLS1pbmRpY2F0b3JCb3hNYWluLS02VDVYdFwiO1xuZXhwb3J0IHZhciBpbmRpY2F0b3JEZXNjID0gXCJJbmRpY2F0b3ItbW9kdWxlLS1pbmRpY2F0b3JEZXNjLS0tRUNUUVwiO1xuZXhwb3J0IHZhciBpbmRpY2F0b3JJbmZvID0gXCJJbmRpY2F0b3ItbW9kdWxlLS1pbmRpY2F0b3JJbmZvLS1wNmxDdVwiO1xuZXhwb3J0IHZhciBpbmRpY2F0b3JOYW1lID0gXCJJbmRpY2F0b3ItbW9kdWxlLS1pbmRpY2F0b3JOYW1lLS1scjNITVwiO1xuZXhwb3J0IHZhciBpbmRpY2F0b3JSb3cgPSBcIkluZGljYXRvci1tb2R1bGUtLWluZGljYXRvclJvdy0tZEVhTmdcIjtcbmV4cG9ydCB2YXIgaW5kaWNhdG9yVmFsdWUgPSBcIkluZGljYXRvci1tb2R1bGUtLWluZGljYXRvclZhbHVlLS1QY1V1M1wiO1xuZXhwb3J0IHZhciBpbmRpY2F0b3JWYWx1ZUNvbCA9IFwiSW5kaWNhdG9yLW1vZHVsZS0taW5kaWNhdG9yVmFsdWVDb2wtLWNpYzFDXCI7XG5leHBvcnQgdmFyIGluZGljYXRvclZhbHVlUm93ID0gXCJJbmRpY2F0b3ItbW9kdWxlLS1pbmRpY2F0b3JWYWx1ZVJvdy0tSWNoRThcIjtcbmV4cG9ydCB2YXIgaW5kaWNhdG9yVmFsdWVTdWJUZXh0ID0gXCJJbmRpY2F0b3ItbW9kdWxlLS1pbmRpY2F0b3JWYWx1ZVN1YlRleHQtLXc5Mnd2XCI7XG5leHBvcnQgdmFyIGluZm8gPSBcIkluZGljYXRvci1tb2R1bGUtLWluZm8tLTV3ZHY1XCI7XG5leHBvcnQgdmFyIGluZm9UaWxkZSA9IFwiSW5kaWNhdG9yLW1vZHVsZS0taW5mb1RpbGRlLS1KU0pXRVwiOyIsImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUdobGFXZG9kRDBpTWpRaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSWdkMmxrZEdnOUlqSTBJajQ4Y0dGMGFDQmtQU0pOTUNBd2FESTBkakkwU0RCNklpQm1hV3hzUFNKdWIyNWxJaTgrUEhCaGRHZ2daRDBpVFRFeUlESkROaTQwT0NBeUlESWdOaTQwT0NBeUlERXljelF1TkRnZ01UQWdNVEFnTVRBZ01UQXROQzQwT0NBeE1DMHhNRk14Tnk0MU1pQXlJREV5SURKNmJURWdNVFZvTFRKMkxUWm9NblkyZW0wd0xUaG9MVEpXTjJneWRqSjZJaTgrUEM5emRtYytcIiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge3VzZUludGx9IGZyb20gJ2dhdHNieS1wbHVnaW4taW50bCc7XG5pbXBvcnQgUmVhY3RUb29sdGlwIGZyb20gJ3JlYWN0LXRvb2x0aXAnO1xuXG5pbXBvcnQge2luZGljYXRvckluZm8sIGluZGljYXRvclR5cGV9IGZyb20gJy4uL0FyZWFEZXRhaWwvQXJlYURldGFpbCc7XG5cbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuL0luZGljYXRvci5tb2R1bGUuc2Nzcyc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vLi4vZGF0YS9jb25zdGFudHMnO1xuaW1wb3J0ICogYXMgRVhQTE9SRV9DT1BZIGZyb20gJy4uLy4uL2RhdGEvY29weS9leHBsb3JlJztcblxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IGluZm9JY29uIGZyb20gJy9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL2luZm8uc3ZnJztcblxuaW50ZXJmYWNlIElJbmRpY2F0b3Ige1xuICBpbmRpY2F0b3I6IGluZGljYXRvckluZm8sXG4gIGlzSW1wdXRlPzogYm9vbGVhbixcbiAgcG9wdWxhdGlvbj86IG51bWJlciB8IHN0cmluZyxcbn1cbmludGVyZmFjZSBJSW5kaWNhdG9yVmFsdWVTdWJUZXh0IHtcbiAgdHlwZTogaW5kaWNhdG9yVHlwZSxcbiAgdmFsdWU6IG51bWJlciB8IG51bGwgfCBib29sZWFuLFxuICBpc0Fib3ZlVGhyZXNoOiBib29sZWFuLFxuICB0aHJlc2hvbGQ6IG51bWJlcixcbn1cblxuaW50ZXJmYWNlIElJbmRpY2F0b3JWYWx1ZSB7XG4gIHR5cGU6IGluZGljYXRvclR5cGUsXG4gIGRpc3BsYXlTdGF0OiBudW1iZXIgfCBudWxsLFxufVxuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHdpbGwgcmVuZGVyIGFuIGluZm8gaWNvbiBpbiB0aGUgaW5kaWNhdG9yIHZhbHVlXG4gKlxuICogQHJldHVybiB7SlNYLkVsZW1lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBJbmRpY2F0b3JJbmZvSWNvbiA9ICh7aXNJbXB1dGUsIHBvcHVsYXRpb259OiBPbWl0PElJbmRpY2F0b3IsICdpbmRpY2F0b3InPikgPT4ge1xuICBjb25zdCBpbnRsID0gdXNlSW50bCgpO1xuICBsZXQgc2hvd1RpbGRlID0gZmFsc2U7XG5cbiAgY29uc3QgZ2V0VG9vbFRpcENvcHkgPSAoKSA9PiB7XG4gICAgaWYgKHBvcHVsYXRpb24gPT09IGNvbnN0YW50cy5NSVNTSU5HX0RBVEFfU1RSSU5HKSB7XG4gICAgICByZXR1cm4gaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5MT1dfSU5DT01FX1RPT0xUSVAuSU1QX1lFU19QT1BfTlVMTCk7XG4gICAgfSBlbHNlIGlmIChwb3B1bGF0aW9uICE9PSBjb25zdGFudHMuTUlTU0lOR19EQVRBX1NUUklORyAmJiBpc0ltcHV0ZSkge1xuICAgICAgc2hvd1RpbGRlID0gdHJ1ZTtcbiAgICAgIHJldHVybiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLkxPV19JTkNPTUVfVE9PTFRJUC5JTVBfWUVTX1BPUF9OT1RfTlVMTCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBsaWJyYXJ5IHJlYWN0LXRvb2x0aXAgY3JlYXRlcyByYW5kb20gRE9NIElEIHdoaWNoIHdpbGwgbm90IGFsbG93IGZvciBzbmFwc2hvdCB0ZXN0aW5nIGFzXG4gICAqIHRoZSBJRHMgY2hhbmdlIG9uIGVhY2ggYnVpbGQuIER1ZSB0byB0aW1lIGNvbnN0cmFpbnRzLCB3ZSBzaW1wbHkgcmVtb3ZlZCB0aGUgQXJlYURldGFpbHMgdGVzdC5cbiAgICogVGhlIEFyZWFEZXRhaWxzIGNvbXBvbmVudCBpcyBtYWRlIHVwIG9mIHN1YiBjb21wb25lbnQgYW5kIGVhY2ggc3ViIGNvbXBvbmVudCBoYXMgdGVzdHMgc28gdGhpc1xuICAgKiBpcyBsb3cgcmlzay5cbiAgICpcbiAgICogVGhpcyBpcyBhIHRlbXBvcmFyeSBzb2x1dGlvbi4gU29tZSBsb25nZXIgdGVybXMgc29sdXRpb25zIG1heSBiZVxuICAgKiAxLiBSZW1vdmUgdGhpcyBsaWJyYXJ5IGFuZCBnZXQgdGhlIFVTV0RTIHRvb2wgdGlwIHRvIHdvcmtcbiAgICogMi4gUmUtZmFjdG9yIHRoZSBhcmVhRGV0YWlsLnRlc3RzLnRzeCBzbmFwc2hvdCB0ZXN0cyB0byBkbyBtb3JlIERPTSBhc3NlcnRpb25zIHJhdGhlciB0aGFuIHNuYXBzaG90c1xuICAgKiAzLiBTb21lIGNvbWJpbmF0aW9uIG9mIHRoZSB0d28uXG4gICAqL1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8UmVhY3RUb29sdGlwXG4gICAgICAgIGlkPVwibG93SW5jb21lSWNvblwiXG4gICAgICAgIG11bHRpbGluZT17dHJ1ZX1cbiAgICAgIC8+XG4gICAgICA8aW1nXG4gICAgICAgIGRhdGEtZm9yPVwibG93SW5jb21lSWNvblwiXG4gICAgICAgIGRhdGEtdGlwPXtnZXRUb29sVGlwQ29weSgpfVxuICAgICAgICBkYXRhLWlzY2FwdHVyZT1cInRydWVcIlxuICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5pbmZvfVxuICAgICAgICBzcmM9e2luZm9JY29ufVxuICAgICAgICBhbHQ9e2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9WQUxVRVMuSU1HX0FMVF9URVhULklORk8pfVxuICAgICAgLz5cbiAgICAgIHtzaG93VGlsZGUgJiYgPHNwYW4gY2xhc3NOYW1lPXtzdHlsZXMuaW5mb1RpbGRlfT57IGAgfiBgIH08L3NwYW4+fVxuICAgIDwvPlxuICApO1xufTtcblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCB3aWxsIGRldGVybWluZSB0aGUgc3ViLXRleHQgb2YgdGhlIGluZGljYXRvcidzIHZhbHVlLCBzb21lIGV4YW1wbGVzIGNvdWxkIGJlXG4gKiAgIFwiYWJvdmUgOTB0aCBwZXJjZW50aWxlXCJcbiAqICAgXCJiZWxvdyAyMCBwZXJjZW50XCJcbiAqICAgXCJkYXRhIGlzIG5vdCBhdmFpbGFibGVcIlxuICpcbiAqIEBwYXJhbSB7SUluZGljYXRvclZhbHVlU3ViVGV4dH0ge31cbiAqIEByZXR1cm4ge0pTWC5FbGVtZW50fVxuICovXG5leHBvcnQgY29uc3QgSW5kaWNhdG9yVmFsdWVTdWJUZXh0ID0gKHt0eXBlLCB2YWx1ZSwgaXNBYm92ZVRocmVzaCwgdGhyZXNob2xkfTpJSW5kaWNhdG9yVmFsdWVTdWJUZXh0KSA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2PlxuICAgICAgICB7RVhQTE9SRV9DT1BZLlNJREVfUEFORUxfVkFMVUVTLlVOQVZBSUxCTEVfTVNHfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAncGVyY2VudCcgfHwgdHlwZSA9PT0gJ3BlcmNlbnRpbGUnKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIHtcbiAgICAgICAgICBpc0Fib3ZlVGhyZXNoID9cbiAgICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9WQUxVRVMuQUJPVkUgOlxuICAgICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX1ZBTFVFUy5CRUxPV1xuICAgICAgICB9XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJlc2hvbGQgP1xuICAgICAgICAgIDxJbmRpY2F0b3JWYWx1ZSB0eXBlPXt0eXBlfSBkaXNwbGF5U3RhdD17dGhyZXNob2xkfS8+IDpcbiAgICAgICAgICA8SW5kaWNhdG9yVmFsdWUgdHlwZT17dHlwZX0gZGlzcGxheVN0YXQ9ezkwfS8+XG4gICAgICAgIH1cbiAgICAgICAge2AgYH1cbiAgICAgICAge1xuICAgICAgICAgIHR5cGUgPT09ICdwZXJjZW50JyA/XG4gICAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfVkFMVUVTLlBFUkNFTlQgOlxuICAgICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX1ZBTFVFUy5QRVJDRU5USUxFXG4gICAgICAgIH1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICg8PjwvPik7XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIHJlYWN0LWkxOG4gbGlicmFyeSBhbGxvdyB0byBhZGQgb3JkaW5hbCBzdWZmaXggKHN0LCBuZCwgcmQsIHRoKSB0byBpbmRpY2F0b3IgdmFsdWVzLlxuICogVGhlIG51bWJlciBhbmQgdGhlIHN1ZmZpeCBpcyBhIHNpbmdsZSBlbnRpdHkuIFdlIGFyZSBsb29raW5nIHRvIGFkZCBzdHlsaW5nIHRvXG4gKiBqdXN0IHRoZSBzdWZmaXggcG9ydGlvbiBpZiB0aGUgdmFsdWUgaXMgYSBwZXJjZW50aWxlLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWRkXG4gKiBhIHN1cGVyc2NyaXB0IHN0eWxpbmcgdG8ganVzdCB0aGUgc3VmZml4IHBvcnRpb24gb2YgcGVyY2VudGlsZSB2YWx1ZXMuXG4gKlxuICogVGhlIGkxOG4gdmFyaWFibGUgbmFtZWQgaTE4bk9yZGluYWxTdWZmaXgsIGluIHRoZSBJbmRpY2F0b3JWYWx1ZSBmdW5jdGlvbiBkZWZpbmVzIHRoZVxuICogdmFyaW91cyBwcmVmaXhlcy4gVGhlIFNwYW5pc2ggdmVyc2lvbiBvZiB0aGUgaTE4biB2YXJpYWJsZSB3b3JrcyBpbiBhIHNpbWlsYXIgbWFubmVyLFxuICogaG93ZXZlciBoYXMgYSBkaWZmZXJlbmNlLiBUaGUgc3VwZXJzY3JpcHRpbmcgaXMgZGlmZmVyZW50IGZvciBTcGFuaXNoLlxuICogSW4gU3BhbmlzaCwgdGhlIHN1ZmZpeCBpcyBhIFwiLmFcIiBhbmQgXCIub1wiLCB3aGVyZSBvbmx5IHRoZSBcImFcIiBhbmQgXCJvXCIgYXJlIHN1cGVyc2NyaXB0ZWQuXG4gKiBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhpcyBjYXNlLlxuICpcbiAqIFZlcmJhdGltIGZyb20gdHJhbnNsYXRpb24gdGVhbTpcbiAqIFdlIHN1Z2dlc3QgY2hhbmdpbmcgdGhpcyB0byB0aGUgU3BhbmlzaCBvcmRpbmFsIG51bWJlciBhYmJyZXZpYXRpb24sIHdoaWNoIGlzIC5vIGZvciBtYXNjdWxpbmVcbiAqIGFuZCAuYSBmb3IgZmVtaW5pbmUgZ2VuZGVyZWQgd29yZHMuICoqKlNpbmNlIHRoaXMgcmFua2luZyBhcHBsaWVzIHRvIHRoZSBjb21tdW5pdGllcyBvZiBmb2N1cyxcbiAqIHdoaWNoIHVzZSBhIGZlbWluaW5lIGdlbmRlciBpbiBTcGFuaXNoLCB3ZSByZWNvbW1lbmQgdGhhdCB0aGUgdGggb3JkaW5hbCBhYmJyZXZpYXRpb24gaW4gRW5nbGlzaFxuICogYmUgc3Vic3RpdHV0ZWQgd2l0aCB0aGUgZmVtaW5pbmUgb3JkaW5hbCBhYmJyZXZpYXRpb24gaW4gU3BhbmlzaDogLmEgIHRocm91Z2hvdXQgdGhlIHRleHQuXG4gKiBFLmcuLCAxOXRoIHdvdWxkIGJlIDE5LmEgaW4gU3BhbmlzaCBhbmQgNjV0aCB3b3VsZCBiZSA2NS5hXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGluZGljYXRvclZhbHVlV2l0aFN1ZmZpeFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3Qgc3VwZXJzY3JpcHRPcmRpbmFsID0gKGluZGljYXRvclZhbHVlV2l0aFN1ZmZpeDpzdHJpbmcpID0+IHtcbiAgLy8gU3BhbmlzaCBjYXNlOlxuICBpZiAoaW5kaWNhdG9yVmFsdWVXaXRoU3VmZml4LmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICBjb25zdCBvcmRpbmFsU3VmZml4ID0gaW5kaWNhdG9yVmFsdWVXaXRoU3VmZml4LmNoYXJBdChpbmRpY2F0b3JWYWx1ZVdpdGhTdWZmaXgubGVuZ3RoIC0gMSk7XG4gICAgY29uc3QgaW5kaWNhdG9yVmFsdWUgPSBpbmRpY2F0b3JWYWx1ZVdpdGhTdWZmaXguc2xpY2UoMCwgLTEpO1xuXG4gICAgcmV0dXJuIDw+e2luZGljYXRvclZhbHVlfTxzdXAgc3R5bGU9e3t0b3A6ICctMC4yZW0nfX0+e29yZGluYWxTdWZmaXh9PC9zdXA+PC8+O1xuICB9XG5cbiAgLy8gRW5nbGlzaCBjYXNlOlxuICBjb25zdCB2YWx1ZVJlZ0V4ID0gL1swLTldezEsMn0vO1xuICBjb25zdCBzdWZmaXhSZWdFeCA9IC9bYS16XXsyfS87IC8vIGllLCAoc3QsIG5kLCByZCwgdGgpXG4gIGNvbnN0IGluZGljYXRvclZhbHVlID0gdmFsdWVSZWdFeC5leGVjKGluZGljYXRvclZhbHVlV2l0aFN1ZmZpeCk7XG4gIGNvbnN0IG9yZGluYWxTdWZmaXggPSBzdWZmaXhSZWdFeC5leGVjKGluZGljYXRvclZhbHVlV2l0aFN1ZmZpeCk7XG5cbiAgcmV0dXJuIDw+e2luZGljYXRvclZhbHVlfTxzdXAgc3R5bGU9e3t0b3A6ICctMC4yZW0nfX0+e29yZGluYWxTdWZmaXh9PC9zdXA+PC8+O1xufTtcblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCB3aWxsIHJldHVybiB0aGUgaW5kaWNhdG9ycydzIHZhbHVlLiBUaGUgdmFsdWUgZGVwZW5kcyBvbiB0aGVcbiAqIGluZGljYXRvciB0eXBlLiBFYWNoIHR5cGUgcmVuZGVycyBhIGRpZmZlcmVudCBVSS5cbiAqXG4gKiBAcmV0dXJuIHtKU1guRWxlbWVudCB8IG51bGx9XG4gKi9cbmV4cG9ydCBjb25zdCBJbmRpY2F0b3JWYWx1ZSA9ICh7dHlwZSwgZGlzcGxheVN0YXR9OklJbmRpY2F0b3JWYWx1ZSkgPT4ge1xuICBjb25zdCBpbnRsID0gdXNlSW50bCgpO1xuXG4gIGlmIChkaXNwbGF5U3RhdCA9PT0gbnVsbCkgcmV0dXJuIDw+e2NvbnN0YW50cy5NSVNTSU5HX0RBVEFfU1RSSU5HfTwvPjtcblxuICBpZiAodHlwZSA9PT0gJ3BlcmNlbnQnIHx8IHR5cGUgPT09ICdwZXJjZW50aWxlJykge1xuICAgIC8vIEluIHRoaXMgY2FzZSB3ZSB3aWxsIHNob3cgbm8gdmFsdWUgYW5kIGFuIGljb24gb25seVxuXG4gICAgaWYgKHR5cGUgPT09ICdwZXJjZW50Jykge1xuICAgICAgLy8gSWYgdGhlIHR5cGUgaXMgcGVyY2VudCwgcmV0dXJuIHRoZSBpbnRsIHBlcmNlbnQgZm9ybWF0XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8c3Bhbj5cbiAgICAgICAgICB7aW50bC5mb3JtYXROdW1iZXIoXG4gICAgICAgICAgICAgIGRpc3BsYXlTdGF0LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3R5bGU6ICd1bml0JyxcbiAgICAgICAgICAgICAgICB1bml0OiAncGVyY2VudCcsXG4gICAgICAgICAgICAgICAgdW5pdERpc3BsYXk6ICdzaG9ydCcsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgKX1cbiAgICAgICAgPC9zcGFuPlxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgIC8vIElmIHRoZSB0eXBlIGlzIHBlcmNlbnRpbGUsIGNyZWF0ZSB0aGUgaW50bCBvcmRpbmFsIGFuZCByZXR1cm4gaXQgYXMgYSBzdXBlcnNjcmlwdFxuICAgICAgY29uc3QgaTE4bk9yZGluYWxTdWZmaXg6IHN0cmluZyA9IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogJ2V4cGxvcmUubWFwLnBhZ2Uuc2lkZS5wYW5lbC5pbmRpY2F0b3IucGVyY2VudGlsZS52YWx1ZS5vcmRpbmFsLnN1ZmZpeCcsXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBOYXZpZ2F0ZSB0byB0aGUgZXhwbG9yZSB0aGUgdG9vbCBwYWdlLiBDbGljayBvbiB0aGUgbWFwLiBUaGUgc2lkZSBwYW5lbCB3aWxsIHNob3cgY2F0ZWdvcmllcy4gT3BlbiBhIGNhdGVnb3J5LiBUaGlzIHdpbGwgZGVmaW5lIHRoZSBpbmRpY2F0b3IgdmFsdWUncyBvcmRpbmFsIHN1ZmZpeC4gRm9yIGV4YW1wbGUgdGhlIHN0IGluIDkxc3QsIHRoZSByZCBpbiAyM3JkLCBhbmQgdGhlIHRoIGluIDI2dGgsIGV0Yy5gLFxuICAgICAgICAgICAgZGVmYXVsdE1lc3NhZ2U6IGBcbiAgICAgICAge2luZGljYXRvclZhbHVlLCBzZWxlY3RvcmRpbmFsLCBcbiAgICAgICAgICBvbmUgeyNzdH0gXG4gICAgICAgICAgdHdvIHsjbmR9XG4gICAgICAgICAgZmV3IHsjcmR9IFxuICAgICAgICAgIG90aGVyIHsjdGh9XG4gICAgICAgIH1cbiAgICAgICAgYCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGluZGljYXRvclZhbHVlOiBkaXNwbGF5U3RhdCxcbiAgICAgICAgICB9LFxuICAgICAgKTtcbiAgICAgIHJldHVybiBzdXBlcnNjcmlwdE9yZGluYWwoaTE4bk9yZGluYWxTdWZmaXgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyB3aGVuIHRoZSB0eXBlID09PSBib29sZWFuIHRoZSBkaXNwbGF5IHN0YXQgd2lsbCBiZSBlaXRoZXIgMTAwICh0cnVlKSBvciAwIChmYWxzZSlcbiAgICByZXR1cm4gZGlzcGxheVN0YXQgPT09IDAgP1xuICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfU1BBQ0VSUy5OTyA6XG4gICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9TUEFDRVJTLllFUztcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCB3aWxsIHJldHVybiB0aGUgbGlzdCBlbGVtZW50IHdoaWNoIHdpbGwgYmUgdGhlIGluZGljYXRvciByb3cgaW4gdGhlIHNpZGUgcGFuZWxcbiAqXG4gKiBAcGFyYW0ge0lJbmRpY2F0b3J9IGluZGljYXRvclxuICogQHJldHVybiB7SlNYLkVsZW1lbnR9XG4gKi9cbmNvbnN0IEluZGljYXRvciA9ICh7aW5kaWNhdG9yLCBpc0ltcHV0ZSwgcG9wdWxhdGlvbn06SUluZGljYXRvcikgPT4ge1xuICAvKipcbiAgICogVGhlIGluZGljYXRvciB2YWx1ZSBjb3VsZCBiZSBhIG51bWJlciB8IGJvb2xlYW4gfCBudWxsLiBJbiBhbGwgY2FzZXMgd2UgY29lcmNlIHRvIG51bWJlclxuICAgKiBiZWZvcmUgZmxvb3JpbmcuXG4gICAqXG4gICAqIEluIHRoZSBjYXNlIHdoZXJlIGluZGljYXRvci52YWx1ZSBpcyBhIGJvb2xlYW4sIHRoZSBkaXNwbGF5U3RhdCB3aWxsIGJlIGVpdGhlciAxMDAgb3IgMCwgZGVwZW5kaW5nXG4gICAqIG9uIGlmIGluZGljYXRvci52YWx1ZSBpcyB0cnVlIG9yIGZhbHNlIHJlc3BlY3RpdmVseS5cbiAgICpcbiAgICogVG9kbzogVGhlIHdheSB0aGUgZGlzcGxheVN0YXQgaGFuZGxlcyB0aGUgYm9vbGVhbiBpbmRpY2F0b3JzIHNob3VsZCBiZSByZWZhY3RvcmVkXG4gICAqL1xuICBjb25zdCBkaXNwbGF5U3RhdCA9IGluZGljYXRvci52YWx1ZSAhPT0gbnVsbCA/IE1hdGguZmxvb3IoTnVtYmVyKGluZGljYXRvci52YWx1ZSkgKiAxMDApIDogbnVsbDtcblxuICAvLyBJZiB0aGUgdGhyZXNob2xkIGV4aXN0cywgc2V0IGl0LCBvdGhlcndpc2Ugc2V0IGl0IHRvIHRoZSBkZWZhdWx0IHZhbHVlXG4gIGNvbnN0IHRocmVzaG9sZCA9IGluZGljYXRvci50aHJlc2hvbGQgPyBpbmRpY2F0b3IudGhyZXNob2xkIDogY29uc3RhbnRzLkRFRkFVTFRfVEhSRVNIT0xEX1BFUkNFTlRJTEU7XG5cbiAgLy8gQSBib29sZWFuIHRvIHJlcHJlc2VudCBpZiB0aGUgaW5kaWNhdG9yIGlzIGFib3ZlIG9yIGJlbG93IHRoZSB0aHJlc2hvbGRcbiAgY29uc3QgaXNBYm92ZVRocmVzaCA9IGRpc3BsYXlTdGF0ICE9PSBudWxsICYmIGRpc3BsYXlTdGF0ID49IHRocmVzaG9sZCA/IHRydWUgOiBmYWxzZTtcblxuICAvLyBTaG93IGFuIGluZm8gaWNvbiBvbiB0aGUgbG93IGljb21lIGluZGljYXRvciBpZjpcbiAgY29uc3Qgc2hvd0xvd0luY29tZUluZm9JY29uID0gKFxuICAgIChpbmRpY2F0b3IubGFiZWwgPT09ICdMb3cgaW5jb21lJyAmJiAoaXNJbXB1dGUpKSB8fFxuICAgIChpbmRpY2F0b3IubGFiZWwgPT09ICdMb3cgaW5jb21lJyAmJiBwb3B1bGF0aW9uID09PSBjb25zdGFudHMuTUlTU0lOR19EQVRBX1NUUklORyAmJiAhaXNJbXB1dGUpXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8bGlcbiAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmluZGljYXRvckJveE1haW59XG4gICAgICBkYXRhLWN5PXsnaW5kaWNhdG9yQm94J31cbiAgICAgIGRhdGEtdGVzdGlkPSdpbmRpY2F0b3ItYm94Jz5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaW5kaWNhdG9yUm93fT5cblxuICAgICAgICB7LyogSW5kaWNhdG9yIG5hbWUgYW5kIGRlc2NyaXB0aW9uKi99XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaW5kaWNhdG9yTmFtZX0+XG4gICAgICAgICAge2luZGljYXRvci5sYWJlbH1cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmluZGljYXRvckRlc2N9PlxuICAgICAgICAgICAge2luZGljYXRvci5kZXNjcmlwdGlvbn1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgey8qIEluZGljYXRvciB2YWx1ZSwgaWNvbiBhbmQgc3VidGV4dCAqL31cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5pbmRpY2F0b3JWYWx1ZUNvbH0+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5pbmRpY2F0b3JWYWx1ZVJvd30+XG5cbiAgICAgICAgICAgIHsvKiBJbmRpY2F0b3IgaW5mbyBpY29uICovfVxuICAgICAgICAgICAgeyBzaG93TG93SW5jb21lSW5mb0ljb24gJiZcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5pbmRpY2F0b3JJbmZvfT5cbiAgICAgICAgICAgICAgICA8SW5kaWNhdG9ySW5mb0ljb25cbiAgICAgICAgICAgICAgICAgIGlzSW1wdXRlPXtpc0ltcHV0ZX1cbiAgICAgICAgICAgICAgICAgIHBvcHVsYXRpb249e3BvcHVsYXRpb259XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHsvKiBJbmRpY2F0b3IgdmFsdWUgKi99XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17aW5kaWNhdG9yLmlzRGlzYWR2YWd0YWdlZCA/XG4gICAgICAgICAgICAgIHN0eWxlcy5kaXNJbmRpY2F0b3JWYWx1ZSA6IHN0eWxlcy5pbmRpY2F0b3JWYWx1ZX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPEluZGljYXRvclZhbHVlXG4gICAgICAgICAgICAgICAgdHlwZT17aW5kaWNhdG9yLnR5cGV9XG4gICAgICAgICAgICAgICAgZGlzcGxheVN0YXQ9e2Rpc3BsYXlTdGF0fVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIHsvKiBJbmRpY2F0b3Igc3ViLXRleHQgKi99XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5pbmRpY2F0b3JWYWx1ZVN1YlRleHR9PlxuICAgICAgICAgICAgPEluZGljYXRvclZhbHVlU3ViVGV4dFxuICAgICAgICAgICAgICB2YWx1ZT17ZGlzcGxheVN0YXR9XG4gICAgICAgICAgICAgIGlzQWJvdmVUaHJlc2g9e2lzQWJvdmVUaHJlc2h9XG4gICAgICAgICAgICAgIHRocmVzaG9sZD17dGhyZXNob2xkfVxuICAgICAgICAgICAgICB0eXBlPXtpbmRpY2F0b3IudHlwZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2xpPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSW5kaWNhdG9yO1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIGRvbnV0Q29weUNvbnRhaW5lciA9IFwiRG9udXRDb3B5LW1vZHVsZS0tZG9udXRDb3B5Q29udGFpbmVyLS1yWmMyblwiO1xuZXhwb3J0IHZhciBkb251dFJvdyA9IFwiRG9udXRDb3B5LW1vZHVsZS0tZG9udXRSb3ctLXVNR08rXCI7XG5leHBvcnQgdmFyIGRvbnV0Um93TGFiZWwgPSBcIkRvbnV0Q29weS1tb2R1bGUtLWRvbnV0Um93TGFiZWwtLUgyWml4XCI7XG5leHBvcnQgdmFyIGludmVydCA9IFwiRG9udXRDb3B5LW1vZHVsZS0taW52ZXJ0LS1JdG1DZ1wiO1xuZXhwb3J0IHZhciBub0ludmVydCA9IFwiRG9udXRDb3B5LW1vZHVsZS0tbm9JbnZlcnQtLVdmRUROXCI7XG5leHBvcnQgdmFyIHN1YlRleHRDb250YWluZXIgPSBcIkRvbnV0Q29weS1tb2R1bGUtLXN1YlRleHRDb250YWluZXItLXJPRWhtXCI7XG5leHBvcnQgdmFyIHZhbHVlU3ViVGV4dENvbnRhaW5lciA9IFwiRG9udXRDb3B5LW1vZHVsZS0tdmFsdWVTdWJUZXh0Q29udGFpbmVyLS0tbnRLMFwiOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge3VzZUludGx9IGZyb20gJ2dhdHNieS1wbHVnaW4taW50bCc7XG5cbmltcG9ydCB7SW5kaWNhdG9yVmFsdWUsIEluZGljYXRvclZhbHVlU3ViVGV4dH0gZnJvbSAnLi4vSW5kaWNhdG9yL0luZGljYXRvcic7XG5cbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuL0RvbnV0Q29weS5tb2R1bGUuc2Nzcyc7XG5cbmltcG9ydCAqIGFzIEVYUExPUkVfQ09QWSBmcm9tICcuLi8uLi9kYXRhL2NvcHkvZXhwbG9yZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSURvbnV0Q29weVByb3BzIHtcbiAgaXNBZGphY2VudDogYm9vbGVhblxuICBwb3ZlcnR5QmVsb3cyMDBQZXJjZW50aWxlOiBudW1iZXIgfCBudWxsXG59XG5cbmNvbnN0IERvbnV0Q29weSA9ICh7aXNBZGphY2VudCwgcG92ZXJ0eUJlbG93MjAwUGVyY2VudGlsZX06IElEb251dENvcHlQcm9wcykgPT4ge1xuICBjb25zdCBpbnRsID0gdXNlSW50bCgpO1xuICBjb25zdCBwb3ZCZWwyMDBQZXJjZW50aWxlID0gcG92ZXJ0eUJlbG93MjAwUGVyY2VudGlsZSA/XG4gICAgcGFyc2VGbG9hdCgocG92ZXJ0eUJlbG93MjAwUGVyY2VudGlsZSoxMDApLnRvRml4ZWQoKSkgOiBudWxsO1xuICBjb25zdCB0aHJlc2hvbGQgPSA1MDtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZG9udXRDb3B5Q29udGFpbmVyfT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZG9udXRSb3d9PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmRvbnV0Um93TGFiZWx9PntpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLkRPTlVUX0NPUFkuQ09NUF9TVVJSKX08L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2lzQWRqYWNlbnQgPyBzdHlsZXMuaW52ZXJ0IDogJyd9PlxuICAgICAgICAgIHtpc0FkamFjZW50ID8gRVhQTE9SRV9DT1BZLkNPTU1VTklUWS5PRl9GT0NVUyA6IEVYUExPUkVfQ09QWS5DT01NVU5JVFkuTk9UX09GX0ZPQ1VTfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5kb251dFJvd30+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZG9udXRSb3dMYWJlbH0+e2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuRE9OVVRfQ09QWS5BREpfTE9XX0lOQyl9PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudmFsdWVTdWJUZXh0Q29udGFpbmVyfT5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17XG4gICAgICAgICAgICBpc0FkamFjZW50ICYmIHBvdkJlbDIwMFBlcmNlbnRpbGUgJiZcbiAgICAgICAgICAgIHBvdkJlbDIwMFBlcmNlbnRpbGUgPj0gdGhyZXNob2xkID8gc3R5bGVzLmludmVydCA6IHN0eWxlcy5ub0ludmVydH0+XG4gICAgICAgICAgICA8SW5kaWNhdG9yVmFsdWVcbiAgICAgICAgICAgICAgdHlwZT17J3BlcmNlbnRpbGUnfVxuICAgICAgICAgICAgICBkaXNwbGF5U3RhdD17cG92QmVsMjAwUGVyY2VudGlsZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zdWJUZXh0Q29udGFpbmVyfT5cbiAgICAgICAgICAgIDxJbmRpY2F0b3JWYWx1ZVN1YlRleHRcbiAgICAgICAgICAgICAgdmFsdWU9e3BvdkJlbDIwMFBlcmNlbnRpbGV9XG4gICAgICAgICAgICAgIGlzQWJvdmVUaHJlc2g9e3BvdkJlbDIwMFBlcmNlbnRpbGUgJiYgcG92QmVsMjAwUGVyY2VudGlsZSA+PSB0aHJlc2hvbGQgPyB0cnVlIDogZmFsc2V9XG4gICAgICAgICAgICAgIHRocmVzaG9sZD17dGhyZXNob2xkfVxuICAgICAgICAgICAgICB0eXBlPXsncGVyY2VudGlsZSd9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRG9udXRDb3B5O1xuIiwiaW1wb3J0IERvbnV0Q29weSBmcm9tICcuL0RvbnV0Q29weSc7XG5leHBvcnQgZGVmYXVsdCBEb251dENvcHk7XG4iLCJpbXBvcnQgSW5kaWNhdG9yIGZyb20gJy4vSW5kaWNhdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgSW5kaWNhdG9yO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0ICogYXMgRVhQTE9SRV9DT1BZIGZyb20gJy4uLy4uL2RhdGEvY29weS9leHBsb3JlJztcblxuaW50ZXJmYWNlIElQcmlvcml0aXphdGlvbkNvcHkge1xuICB0b3RhbENhdGVnb3JpZXNQcmlvcml0aXplZDogbnVtYmVyXG4gIHRvdGFsQnVyZGVuc1ByaW9yaXRpemVkOiBudW1iZXJcbiAgaXNBZGphY2VuY3lUaHJlc2hNZXQ6IGJvb2xlYW4sXG4gIGlzQWRqYWNlbmN5TG93SW5jb21lOiBib29sZWFuLFxuICBpc0lzbGFuZExvd0luY29tZTogYm9vbGVhbixcbiAgaXNHcmFuZGZhdGhlcmVkOiBib29sZWFuLFxuICB0cmliYWxDb3VudEFLOiBudW1iZXIgfCBudWxsLFxuICB0cmliYWxDb3VudFVTOiBudWxsLCAvLyB3aGVuIHRoaXMgc2lnbmFsIGlzIHN1cHBvcnRlZCBhZGQgbnVtYmVyIHR5cGVcbiAgcGVyY2VudFRyYWN0VHJpYmFsOiBudW1iZXIgfCBudWxsXG59O1xuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHJldHVybnMgdGhlIHByaW9yaXR6YXRpb24gY29weS5cbiAqXG4gKiBUaGUgdHJ1dGggdGFibGUgdGhhdCB0cmFja3MgYWxsIHRoZSBzdGF0ZXMgZm9yIHRoaXMgbG9naWMgaXMgY2FwdHVyZWQgaW4gdGhlIHNoYXJlZCBkb2NcbiAqIGNhbGxlZCBcIkluZGljYXRvcnMgZm9yIFVJIGFuZCBCRSBTaWduYWxzXCIuIFRoZSBTaGVldCBpcyBjYWxsZWQgXCJEaXNhZHYgQ29weSB2NCBwMVwiLiBUaGlzXG4gKiBzcHJlYWRzaGVldCBpcyBhIGdpYW50IHRydXRoIHRhYmxlIHdpdGggYWxsIHBvc3NpYmxlIEJFIHNpZ25hbCBjb21iaW5hdGlvbnMgYW5kIHdoYXQgdGhlXG4gKiBhcHByb3BwcmlhdGUgY29weSBzaG91bGQgYmUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsQ2F0ZWdvcmllc1ByaW9yaXRpemVkXG4gKiBAcGFyYW0ge251bWJlcn0gdG90YWxCdXJkZW5zUHJpb3JpdGl6ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNBZGphY2VuY3lUaHJlc2hNZXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNBZGphY2VuY3lMb3dJbmNvbWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNJc2xhbmRMb3dJbmNvbWVcbiAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbH0gdHJpYmFsQ291bnRBS1xuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSB0cmliYWxDb3VudFVTXG4gKiBAcGFyYW0ge251bWJlciB8IG51bGx9IHBlcmNlbnRUcmFjdFRyaWJhbFxuICogQHJldHVybiB7SlNYfVxuICovXG5jb25zdCBQcmlvcml0aXphdGlvbkNvcHkgPVxuICAgKHt0b3RhbENhdGVnb3JpZXNQcmlvcml0aXplZCxcbiAgICAgdG90YWxCdXJkZW5zUHJpb3JpdGl6ZWQsXG4gICAgIGlzQWRqYWNlbmN5VGhyZXNoTWV0LFxuICAgICBpc0FkamFjZW5jeUxvd0luY29tZSxcbiAgICAgaXNHcmFuZGZhdGhlcmVkLFxuICAgICBpc0lzbGFuZExvd0luY29tZSxcbiAgICAgdHJpYmFsQ291bnRBSyxcbiAgICAgdHJpYmFsQ291bnRVUyxcbiAgICAgcGVyY2VudFRyYWN0VHJpYmFsLFxuICAgfTpJUHJpb3JpdGl6YXRpb25Db3B5KSA9PiB7XG4gICAgIGxldCBwcmlvQ29weVJlbmRlcmVkID0gbnVsbDtcblxuICAgICBpZiAoaXNHcmFuZGZhdGhlcmVkKSB7XG4gICAgICAgcHJpb0NvcHlSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5QUklPUklUSVpBVElPTl9DT1BZLlBSSU9fR1JBTkRGQVRIRVJFRF9MSTtcbiAgICAgLy8gaWYgMVxuICAgICB9IGVsc2UgaWYgKHRvdGFsQ2F0ZWdvcmllc1ByaW9yaXRpemVkID09PSAwKSB7XG4gICAgICAgLy8gaWYgMS0xXG4gICAgICAgaWYgKGlzQWRqYWNlbmN5VGhyZXNoTWV0ICYmIGlzQWRqYWNlbmN5TG93SW5jb21lKSB7XG4gICAgICAgICBwcmlvQ29weVJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLlBSSU9SSVRJWkFUSU9OX0NPUFkuUFJJT19TVVJSX0xJO1xuICAgICAgICAgLy8gaWYgMS0yXG4gICAgICAgfSBlbHNlIGlmIChpc0lzbGFuZExvd0luY29tZSkge1xuICAgICAgICAgcHJpb0NvcHlSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5QUklPUklUSVpBVElPTl9DT1BZLlBSSU9fSVNMQU5EX0xJO1xuICAgICAgICAgLy8gaWYgMS0zXG4gICAgICAgfSBlbHNlIGlmIChpc0FkamFjZW5jeVRocmVzaE1ldCAmJiAhaXNBZGphY2VuY3lMb3dJbmNvbWUpIHtcbiAgICAgICAgIC8vIGlmIDEtMi0xXG4gICAgICAgICBpZiAoIHRyaWJhbENvdW50QUsgPT09IG51bGwgJiYgdHJpYmFsQ291bnRVUyA9PT0gbnVsbCkge1xuICAgICAgICAgICAvLyBpZiAxLTItMS0xXG4gICAgICAgICAgIGlmIChwZXJjZW50VHJhY3RUcmliYWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICBwcmlvQ29weVJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLlBSSU9SSVRJWkFUSU9OX0NPUFkuTk9UX1BSSU9fU1VSUl9MSTtcbiAgICAgICAgICAgICAvLyBpZiAxLTItMS0yXG4gICAgICAgICAgIH0gZWxzZSBpZiAocGVyY2VudFRyYWN0VHJpYmFsID09PSAwKSB7XG4gICAgICAgICAgICAgcHJpb0NvcHlSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5QUklPUklUSVpBVElPTl9DT1BZLlBBUl9QUklPX1NVUlJfTk9fTEk7XG4gICAgICAgICAgICAgLy8gaWYgMS0yLTEtM1xuICAgICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnRUcmFjdFRyaWJhbCA+PSAxKSB7XG4gICAgICAgICAgICAgcHJpb0NvcHlSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5QUklPUklUSVpBVElPTl9DT1BZLlBBUl9QUklPX1NVUlJfTk9fTEk7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgLy8gaWYgMS0yLTJcbiAgICAgICAgIH0gZWxzZSBpZiAodHJpYmFsQ291bnRBSyAhPT0gbnVsbCAmJiB0cmliYWxDb3VudEFLID49IDEpIHtcbiAgICAgICAgICAgcHJpb0NvcHlSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5QUklPUklUSVpBVElPTl9DT1BZLlBBUl9QUklPX1NVUlJfTk9fTEk7XG4gICAgICAgICB9XG4gICAgICAgICAvLyBpZiAxLTNcbiAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIShpc0FkamFjZW5jeVRocmVzaE1ldCAmJiBpc0FkamFjZW5jeUxvd0luY29tZSkgJiZcbiAgICAgICAgICB0cmliYWxDb3VudEFLID09PSBudWxsICYmXG4gICAgICAgICAgdHJpYmFsQ291bnRVUyA9PT0gbnVsbCAmJlxuICAgICAgICAgIHBlcmNlbnRUcmFjdFRyaWJhbCA9PT0gbnVsbFxuICAgICAgICkge1xuICAgICAgICAgLy8gaWYgMS0zLTFcbiAgICAgICAgIGlmICh0b3RhbEJ1cmRlbnNQcmlvcml0aXplZCA9PT0gMCkge1xuICAgICAgICAgICBwcmlvQ29weVJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLlBSSU9SSVRJWkFUSU9OX0NPUFkuTk9UX1BSSU87XG4gICAgICAgICAgIC8vIGlmIDEtMy0yXG4gICAgICAgICB9IGVsc2UgaWYgKHRvdGFsQnVyZGVuc1ByaW9yaXRpemVkID09PSAxKSB7XG4gICAgICAgICAgIHByaW9Db3B5UmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuUFJJT1JJVElaQVRJT05fQ09QWS5OT1RfUFJJT18xQlVSO1xuICAgICAgICAgICAvLyBpZiAxLTMtM1xuICAgICAgICAgfSBlbHNlIGlmICh0b3RhbEJ1cmRlbnNQcmlvcml0aXplZCA+IDEpIHtcbiAgICAgICAgICAgcHJpb0NvcHlSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5QUklPUklUSVpBVElPTl9DT1BZLk5PVF9QUklPX05CVVI7XG4gICAgICAgICB9XG4gICAgICAgICAvLyBpZiAxLTRcbiAgICAgICB9IGVsc2UgaWYgKCEoaXNBZGphY2VuY3lUaHJlc2hNZXQgJiYgaXNBZGphY2VuY3lMb3dJbmNvbWUpKSB7XG4gICAgICAgICAvLyBpZiAxLTQtMVxuICAgICAgICAgaWYgKFxuICAgICAgICAgICAodHJpYmFsQ291bnRBSyAhPT0gbnVsbCAmJiB0cmliYWxDb3VudEFLID49IDEpICYmXG4gICAgICAgICh0cmliYWxDb3VudFVTICE9PSBudWxsICYmIHRyaWJhbENvdW50VVMgPj0gMSlcbiAgICAgICAgICkge1xuICAgICAgICAgICBwcmlvQ29weVJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9BS1VTQ29weSh0cmliYWxDb3VudEFLLCB0cmliYWxDb3VudFVTKTtcbiAgICAgICAgICAgLy8gaWYgMS00LTJcbiAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICh0cmliYWxDb3VudEFLICE9PSBudWxsICYmIHRyaWJhbENvdW50QUsgPj0gMSkgJiZcbiAgICAgICAgdHJpYmFsQ291bnRVUyA9PT0gbnVsbFxuICAgICAgICAgKSB7XG4gICAgICAgICAgIHByaW9Db3B5UmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuZ2V0UHJpb0FOVkNvcHkodHJpYmFsQ291bnRBSyk7XG4gICAgICAgICAgIC8vIGlmIDEtNC0zXG4gICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAodHJpYmFsQ291bnRVUyAhPT0gbnVsbCAmJiB0cmliYWxDb3VudFVTID49IDEpICYmXG4gICAgICAgIHRyaWJhbENvdW50QUsgPT09IG51bGxcbiAgICAgICAgICkge1xuICAgICAgICAgICBpZiAocGVyY2VudFRyYWN0VHJpYmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgcHJpb0NvcHlSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5nZXRQcmlvRlJUUG9pbnRzQ29weShgJHt0cmliYWxDb3VudFVTfWApO1xuICAgICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnRUcmFjdFRyaWJhbCA9PT0gMCkge1xuICAgICAgICAgICAgIHByaW9Db3B5UmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuZ2V0UHJpb0ZSVENvcHkoYGxlc3MgdGhhbiAxJWApO1xuICAgICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnRUcmFjdFRyaWJhbCA+PSAxKSB7XG4gICAgICAgICAgICAgcHJpb0NvcHlSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5nZXRQcmlvRlJUQ29weShgJHtwZXJjZW50VHJhY3RUcmliYWx9JWApO1xuICAgICAgICAgICB9XG4gICAgICAgICAvLyAxLTQtNFxuICAgICAgICAgfSBlbHNlIGlmICh0cmliYWxDb3VudFVTID09PSBudWxsICYmIHRyaWJhbENvdW50QUsgPT09IG51bGwpIHtcbiAgICAgICAgICAgaWYgKHBlcmNlbnRUcmFjdFRyaWJhbCA9PT0gMCkge1xuICAgICAgICAgICAgIHByaW9Db3B5UmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuZ2V0UHJpb0ZSVENvcHkoYGxlc3MgdGhhbiAxJWApO1xuICAgICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnRUcmFjdFRyaWJhbCAhPT0gbnVsbCAmJiBwZXJjZW50VHJhY3RUcmliYWwgPj0gMSApIHtcbiAgICAgICAgICAgICBwcmlvQ29weVJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9GUlRDb3B5KGAke3BlcmNlbnRUcmFjdFRyaWJhbH0lYCk7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgICAgLy8gaWYgMlxuICAgICB9IGVsc2UgaWYgKHRvdGFsQ2F0ZWdvcmllc1ByaW9yaXRpemVkID4gMCkge1xuICAgICAgIGlmICh0b3RhbEJ1cmRlbnNQcmlvcml0aXplZCA9PT0gMCkge1xuICAgICAgIH0gZWxzZSBpZiAodG90YWxCdXJkZW5zUHJpb3JpdGl6ZWQgPT09IDEpIHtcbiAgICAgICAgIHByaW9Db3B5UmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuZ2V0UHJpb05CdXJkZW5Db3B5KGAxYCk7XG4gICAgICAgfSBlbHNlIGlmICh0b3RhbEJ1cmRlbnNQcmlvcml0aXplZCA+IDEpIHtcbiAgICAgICAgIHByaW9Db3B5UmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuZ2V0UHJpb05CdXJkZW5Db3B5KGBtb3JlIHRoYW4gMWApO1xuICAgICAgIH1cbiAgICAgfTtcblxuICAgICByZXR1cm4gcHJpb0NvcHlSZW5kZXJlZCAmJiA8cD57cHJpb0NvcHlSZW5kZXJlZH08L3A+O1xuICAgfTtcblxuZXhwb3J0IGRlZmF1bHQgUHJpb3JpdGl6YXRpb25Db3B5O1xuIiwiaW1wb3J0IFByaW9yaXRpemF0aW9uQ29weSBmcm9tICcuL1ByaW9yaXRpemF0aW9uQ29weSc7XG5leHBvcnQgZGVmYXVsdCBQcmlvcml0aXphdGlvbkNvcHk7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgKiBhcyBFWFBMT1JFX0NPUFkgZnJvbSAnLi4vLi4vZGF0YS9jb3B5L2V4cGxvcmUnO1xuXG5pbnRlcmZhY2UgSVByaW9yaXRpemF0aW9uQ29weTIge1xuICB0b3RhbENhdGVnb3JpZXNQcmlvcml0aXplZDogbnVtYmVyXG4gIHRvdGFsQnVyZGVuc1ByaW9yaXRpemVkPzogbnVtYmVyXG4gIGlzQWRqYWNlbmN5VGhyZXNoTWV0OiBib29sZWFuLFxuICBpc0FkamFjZW5jeUxvd0luY29tZTogYm9vbGVhbixcbiAgdHJpYmFsQ291bnRBSzogbnVtYmVyIHwgbnVsbCxcbiAgdHJpYmFsQ291bnRVUzogbnVsbCwgLy8gd2hlbiB0aGlzIHNpZ25hbCBpcyBzdXBwb3J0ZWQgYWRkIG51bWJlciB0eXBlXG4gIHBlcmNlbnRUcmFjdFRyaWJhbDogbnVtYmVyIHwgbnVsbFxufTtcblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCByZXR1cm5zIHRoZSBwcmlvcml0emF0aW9uIGNvcHkuXG4gKlxuICogVGhlIHRydXRoIHRhYmxlIGZvciB0aGlzIGxvZ2ljIGlzIGNhcHR1cmVkIGluIHRoZSBzaGFyZWQgZG9jIGNhbGxlZCBcIkluZGljYXRvcnMgZm9yXG4gKiBVSSBhbmQgQkUgU2lnbmFsc1wiLiBUaGUgU2hlZXQgbmFtZSBpcyBcIkRpc2FkdiBDb3B5IHAyIHY1XCIuIFRoaXMgc2hlZXQgaXMgYSBjb3B5IG9mIHRoZVxuICogdGhlIGZ1bGwgdGFibGUgaW4gU2hlZXQgXCJEaXNhZHYgQ29weSB2NCBwMVwiLCB3aGljaCBpcyB0aGUgZnVsbCB0cnV0aCB0YWJsZSBpbiBsb2dpY2FsIG9yZGVyLlxuICogVGhlIHAyIHY0IHNoZWV0IGNvcGllcyB0aGUgZnVsbCB0cnV0aCB0YWJsZSBhbmQgc29ydHMgYnkgdGhlIGNvbHVtbiAnc2Vjb25kIHBhcmFncmFwaCcgdG9cbiAqIGZpbmQgdGhlIGFwcHJvcHJpYXRlIGxvZ2ljYWwgZ3JvdXBpbmcgZm9yIHRoZSBzZWNvbmQgcGFyYWdyYXBoLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbENhdGVnb3JpZXNQcmlvcml0aXplZFxuICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsQnVyZGVuc1ByaW9yaXRpemVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzQWRqYWNlbmN5VGhyZXNoTWV0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzQWRqYWNlbmN5TG93SW5jb21lXG4gKiBAcGFyYW0ge251bWJlciB8IG51bGx9IHRyaWJhbENvdW50QUtcbiAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbH0gdHJpYmFsQ291bnRVU1xuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBwZXJjZW50VHJhY3RUcmliYWxcbiAqIEByZXR1cm4ge0pTWH1cbiAqL1xuY29uc3QgUHJpb3JpdGl6YXRpb25Db3B5MiA9XG4gICAoe3RvdGFsQ2F0ZWdvcmllc1ByaW9yaXRpemVkLFxuICAgICBpc0FkamFjZW5jeVRocmVzaE1ldCxcbiAgICAgaXNBZGphY2VuY3lMb3dJbmNvbWUsXG4gICAgIHRyaWJhbENvdW50QUssXG4gICAgIHRyaWJhbENvdW50VVMsXG4gICAgIHBlcmNlbnRUcmFjdFRyaWJhbCxcbiAgIH06SVByaW9yaXRpemF0aW9uQ29weTIpID0+IHtcbiAgICAgbGV0IHByaW9Db3B5MlJlbmRlcmVkID0gbnVsbDtcblxuICAgICAvLyBpZiAxXG4gICAgIGlmIChcbiAgICAgICAodG90YWxDYXRlZ29yaWVzUHJpb3JpdGl6ZWQgPT09IDAgJiYgKGlzQWRqYWNlbmN5VGhyZXNoTWV0ICYmIGlzQWRqYWNlbmN5TG93SW5jb21lKSkgfHxcbiAgICAgICh0b3RhbENhdGVnb3JpZXNQcmlvcml0aXplZCA+PSAxKVxuICAgICApIHtcbiAgICAgICAvLyBpZiAxLTFcbiAgICAgICBpZiAoXG4gICAgICAgICB0cmliYWxDb3VudEFLID09PSBudWxsICYmXG4gICAgICAgICh0cmliYWxDb3VudFVTICE9PSBudWxsICYmIHRyaWJhbENvdW50VVMgPj0gMSkgJiZcbiAgICAgICAgKHBlcmNlbnRUcmFjdFRyaWJhbCAhPT0gbnVsbCAmJiBwZXJjZW50VHJhY3RUcmliYWwgPj0gMSlcbiAgICAgICApIHtcbiAgICAgICAgIHByaW9Db3B5MlJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9QZXJjQW5kTnVtUG9pbnRzQWxzb0NvcHkoYCR7cGVyY2VudFRyYWN0VHJpYmFsfSVgLCB0cmliYWxDb3VudFVTKTtcbiAgICAgICAvLyBpZiAxLTJcbiAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgdHJpYmFsQ291bnRBSyA9PT0gbnVsbCAmJlxuICAgICAgICB0cmliYWxDb3VudFVTID09PSBudWxsICYmXG4gICAgICAgIChwZXJjZW50VHJhY3RUcmliYWwgIT09IG51bGwgJiYgcGVyY2VudFRyYWN0VHJpYmFsID49IDEpXG4gICAgICAgKSB7XG4gICAgICAgICBwcmlvQ29weTJSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5nZXRQcmlvRlJUQ29weShgJHtwZXJjZW50VHJhY3RUcmliYWx9JWAsIHRydWUpO1xuICAgICAgIC8vIGlmIDEtM1xuICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICB0cmliYWxDb3VudEFLID09PSBudWxsICYmXG4gICAgICAgICh0cmliYWxDb3VudFVTICE9PSBudWxsICYmIHRyaWJhbENvdW50VVMgPj0gMSkgJiZcbiAgICAgICAgKHBlcmNlbnRUcmFjdFRyaWJhbCAhPT0gbnVsbCAmJiBwZXJjZW50VHJhY3RUcmliYWwgPT0gMClcbiAgICAgICApIHtcbiAgICAgICAgIHByaW9Db3B5MlJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9QZXJjQW5kTnVtUG9pbnRzQWxzb0NvcHkoYGxlc3MgdGhhbiAxJWAsIHRyaWJhbENvdW50VVMpO1xuICAgICAgIC8vIGlmIDEtNFxuICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICB0cmliYWxDb3VudEFLID09PSBudWxsICYmXG4gICAgICAgIHRyaWJhbENvdW50VVMgPT09IG51bGwgJiZcbiAgICAgICAgKHBlcmNlbnRUcmFjdFRyaWJhbCAhPT0gbnVsbCAmJiBwZXJjZW50VHJhY3RUcmliYWwgPT0gMClcbiAgICAgICApIHtcbiAgICAgICAgIHByaW9Db3B5MlJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9GUlRDb3B5KGBsZXNzIHRoYW4gMSVgLCB0cnVlKTtcbiAgICAgICAvLyBpZiAxLTVcbiAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgKHRyaWJhbENvdW50QUsgIT09IG51bGwgJiYgdHJpYmFsQ291bnRBSyA+PSAxKSAmJlxuICAgICAgICB0cmliYWxDb3VudFVTID09PSBudWxsICYmXG4gICAgICAgIHBlcmNlbnRUcmFjdFRyaWJhbCA9PT0gbnVsbFxuICAgICAgICkge1xuICAgICAgICAgcHJpb0NvcHkyUmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuZ2V0UHJpb0FOVkNvcHkodHJpYmFsQ291bnRBSywgdHJ1ZSk7XG4gICAgICAgLy8gaWYgMS02XG4gICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICh0cmliYWxDb3VudEFLICE9PSBudWxsICYmIHRyaWJhbENvdW50QUsgPj0gMSkgJiZcbiAgICAgICAgKHRyaWJhbENvdW50VVMgIT09IG51bGwgJiYgdHJpYmFsQ291bnRVUyA+PSAxKVxuICAgICAgICkge1xuICAgICAgICAgcHJpb0NvcHkyUmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuZ2V0UHJpb0FLVVNDb3B5KHRyaWJhbENvdW50QUssIHRyaWJhbENvdW50VVMsIHRydWUpO1xuICAgICAgICAgLy8gaWYgMS03XG4gICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICFpc0FkamFjZW5jeVRocmVzaE1ldCAmJiBpc0FkamFjZW5jeUxvd0luY29tZSAmJlxuICAgICAgICh0cmliYWxDb3VudEFLICE9PSBudWxsICYmIHRyaWJhbENvdW50QUsgPj0gMSkgJiZcbiAgICAgICAocGVyY2VudFRyYWN0VHJpYmFsICE9PSBudWxsICYmIHBlcmNlbnRUcmFjdFRyaWJhbCA+PSAxKVxuICAgICAgICkge1xuICAgICAgICAgcHJpb0NvcHkyUmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuZ2V0UHJpb0ZSVENvcHkoYCR7cGVyY2VudFRyYWN0VHJpYmFsfSVgLCB0cnVlKTtcbiAgICAgICAgIC8vIGlmIDEtOFxuICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAodG90YWxDYXRlZ29yaWVzUHJpb3JpdGl6ZWQgPj0gMSkgJiZcbiAgICAgICAgIHRyaWJhbENvdW50QUsgPT0gbnVsbCAmJlxuICAgICAgICAgKHRyaWJhbENvdW50VVMgIT09IG51bGwgJiYgdHJpYmFsQ291bnRVUyA+PSAxKSAmJlxuICAgICAgICAgcGVyY2VudFRyYWN0VHJpYmFsID09IG51bGxcbiAgICAgICApIHtcbiAgICAgICAgIHByaW9Db3B5MlJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9GUlRQb2ludHNDb3B5KHRyaWJhbENvdW50VVMsIHRydWUpO1xuICAgICAgICAgLy8gaWYgMS05XG4gICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgIHRvdGFsQ2F0ZWdvcmllc1ByaW9yaXRpemVkID49IDEgJiZcbiAgICAgICAodHJpYmFsQ291bnRBSyAhPT0gbnVsbCAmJiB0cmliYWxDb3VudEFLID49IDEpICYmXG4gICAgICAgKHBlcmNlbnRUcmFjdFRyaWJhbCAhPT0gbnVsbCAmJiBwZXJjZW50VHJhY3RUcmliYWwgPT0gMClcbiAgICAgICApIHtcbiAgICAgICAgIHByaW9Db3B5MlJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9GUlRDb3B5KGBsZXNzIHRoYW4gMSVgLCB0cnVlKTtcbiAgICAgICAgIC8vIGlmIDEtMTBcbiAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgdG90YWxDYXRlZ29yaWVzUHJpb3JpdGl6ZWQgPj0gMSAmJlxuICAgICAgICh0cmliYWxDb3VudEFLICE9PSBudWxsICYmIHRyaWJhbENvdW50QUsgPj0gMSkgJiZcbiAgICAgICAocGVyY2VudFRyYWN0VHJpYmFsICE9PSBudWxsICYmIHBlcmNlbnRUcmFjdFRyaWJhbCA+PSAxKVxuICAgICAgICkge1xuICAgICAgICAgcHJpb0NvcHkyUmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuZ2V0UHJpb0ZSVENvcHkoYCR7cGVyY2VudFRyYWN0VHJpYmFsfSVgLCB0cnVlKTtcbiAgICAgICB9XG4gICAgICAgLy8gaWYgMlxuICAgICB9IGVsc2UgaWYgKFxuICAgICAgIHRvdGFsQ2F0ZWdvcmllc1ByaW9yaXRpemVkID09PSAwICYmXG4gICAgICBpc0FkamFjZW5jeVRocmVzaE1ldCAmJiAhaXNBZGphY2VuY3lMb3dJbmNvbWUgJiZcbiAgICAgIHRyaWJhbENvdW50QUsgPT09IG51bGwgJiYgdHJpYmFsQ291bnRVUyA9PT0gbnVsbFxuICAgICApIHtcbiAgICAgICAvLyBpZiAyLTFcbiAgICAgICBpZiAocGVyY2VudFRyYWN0VHJpYmFsICE9PSBudWxsICYmIHBlcmNlbnRUcmFjdFRyaWJhbCA9PSAwKSB7XG4gICAgICAgICBwcmlvQ29weTJSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5nZXRQcmlvRlJUQ29weShgbGVzcyB0aGFuIDElYCwgZmFsc2UpO1xuICAgICAgICAgLy8gaWYgMi0yXG4gICAgICAgfSBlbHNlIGlmIChwZXJjZW50VHJhY3RUcmliYWwgIT09IG51bGwgJiYgcGVyY2VudFRyYWN0VHJpYmFsID49IDEpIHtcbiAgICAgICAgIHByaW9Db3B5MlJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9GUlRDb3B5KGAke3BlcmNlbnRUcmFjdFRyaWJhbH0lYCwgZmFsc2UpO1xuICAgICAgIH1cbiAgICAgICAvLyBpZiAzLTFcbiAgICAgfSBlbHNlIGlmIChcbiAgICAgICB0b3RhbENhdGVnb3JpZXNQcmlvcml0aXplZCA9PT0gMCAmJlxuICAgICAgKGlzQWRqYWNlbmN5VGhyZXNoTWV0ICYmICFpc0FkamFjZW5jeUxvd0luY29tZSkgJiZcbiAgICAgIHRyaWJhbENvdW50QUsgPT09IG51bGwgJiZcbiAgICAgICh0cmliYWxDb3VudFVTICE9PSBudWxsICYmIHRyaWJhbENvdW50VVMgPj0gMSkgJiZcbiAgICAgIChwZXJjZW50VHJhY3RUcmliYWwgIT09IG51bGwgJiYgcGVyY2VudFRyYWN0VHJpYmFsID09IDApXG4gICAgICkge1xuICAgICAgIHByaW9Db3B5MlJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9GUlRQb2ludHNDb3B5KHRyaWJhbENvdW50VVMsIGZhbHNlKTtcbiAgICAgICAvLyBpZiAzLTJcbiAgICAgfSBlbHNlIGlmIChcbiAgICAgICB0b3RhbENhdGVnb3JpZXNQcmlvcml0aXplZCA9PT0gMCAmJlxuICAgICAgKGlzQWRqYWNlbmN5VGhyZXNoTWV0ICYmICFpc0FkamFjZW5jeUxvd0luY29tZSkgJiZcbiAgICAgIHRyaWJhbENvdW50QUsgPT09IG51bGwgJiZcbiAgICAgICh0cmliYWxDb3VudFVTICE9PSBudWxsICYmIHRyaWJhbENvdW50VVMgPj0gMSkgJiZcbiAgICAgIChwZXJjZW50VHJhY3RUcmliYWwgIT09IG51bGwgJiYgcGVyY2VudFRyYWN0VHJpYmFsID49IDEpXG4gICAgICkge1xuICAgICAgIHByaW9Db3B5MlJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9GUlRQb2ludHNDb3B5KHRyaWJhbENvdW50VVMsIGZhbHNlKTtcbiAgICAgICAvLyBpZiAzLTNcbiAgICAgfSBlbHNlIGlmIChcbiAgICAgICAodG90YWxDYXRlZ29yaWVzUHJpb3JpdGl6ZWQgPT09IDAgJiYgIShpc0FkamFjZW5jeVRocmVzaE1ldCAmJiBpc0FkamFjZW5jeUxvd0luY29tZSkpICYmXG4gICAgICB0cmliYWxDb3VudEFLID09PSBudWxsICYmXG4gICAgICAodHJpYmFsQ291bnRVUyAhPT0gbnVsbCAmJiB0cmliYWxDb3VudFVTID49IDEpICYmXG4gICAgICAocGVyY2VudFRyYWN0VHJpYmFsICE9PSBudWxsICYmIHBlcmNlbnRUcmFjdFRyaWJhbCA+PSAwKVxuICAgICApIHtcbiAgICAgICBwcmlvQ29weTJSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5nZXRQcmlvRlJUUG9pbnRzQ29weSh0cmliYWxDb3VudFVTLCB0cnVlKTtcbiAgICAgICAvLyBpZiA0XG4gICAgIH0gZWxzZSBpZiAoXG4gICAgICAgdG90YWxDYXRlZ29yaWVzUHJpb3JpdGl6ZWQgPT09IDAgJiZcbiAgICAgIGlzQWRqYWNlbmN5VGhyZXNoTWV0ICYmICFpc0FkamFjZW5jeUxvd0luY29tZSAmJlxuICAgICAgKHRyaWJhbENvdW50QUsgIT09IG51bGwgJiYgdHJpYmFsQ291bnRBSyA+PSAxKVxuICAgICApIHtcbiAgICAgICBwcmlvQ29weTJSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5nZXRQcmlvQU5WQ29weSh0cmliYWxDb3VudEFLLCBmYWxzZSk7XG4gICAgIH1cblxuICAgICByZXR1cm4gcHJpb0NvcHkyUmVuZGVyZWQgJiYgPHA+e3ByaW9Db3B5MlJlbmRlcmVkfTwvcD47XG4gICB9O1xuXG5leHBvcnQgZGVmYXVsdCBQcmlvcml0aXphdGlvbkNvcHkyO1xuIiwiaW1wb3J0IFByaW9yaXRpemF0aW9uQ29weTIgZnJvbSAnLi9Qcmlvcml0aXphdGlvbkNvcHkyJztcbmV4cG9ydCBkZWZhdWx0IFByaW9yaXRpemF0aW9uQ29weTI7XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB2YXIgZGVtb2dyYXBoaWNIZWFkaW5nID0gXCJUcmFjdERlbW9ncmFwaGljcy1tb2R1bGUtLWRlbW9ncmFwaGljSGVhZGluZy0tSUNZbCtcIjtcbmV4cG9ydCB2YXIgZGVtb2dyYXBoaWNJdGVtID0gXCJUcmFjdERlbW9ncmFwaGljcy1tb2R1bGUtLWRlbW9ncmFwaGljSXRlbS0tMTZtWXFcIjtcbmV4cG9ydCB2YXIgZGVtb2dyYXBoaWNzQ29udGFpbmVyID0gXCJUcmFjdERlbW9ncmFwaGljcy1tb2R1bGUtLWRlbW9ncmFwaGljc0NvbnRhaW5lci0tRjhoTEpcIjtcbmV4cG9ydCB2YXIgZGVtb2dyYXBoaWNzVGl0bGUgPSBcIlRyYWN0RGVtb2dyYXBoaWNzLW1vZHVsZS0tZGVtb2dyYXBoaWNzVGl0bGUtLUZKdFVBXCI7XG5leHBvcnQgdmFyIHNob3dIaWRlSWNvbiA9IFwiVHJhY3REZW1vZ3JhcGhpY3MtbW9kdWxlLS1zaG93SGlkZUljb24tLVlqTW9iXCI7XG5leHBvcnQgdmFyIHNob3dIaWRlVGV4dCA9IFwiVHJhY3REZW1vZ3JhcGhpY3MtbW9kdWxlLS1zaG93SGlkZVRleHQtLVZSSHZMXCI7IiwiaW1wb3J0IFJlYWN0LCB7dXNlU3RhdGV9IGZyb20gJ3JlYWN0JztcblxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IGV4cGFuZEljb24gZnJvbSAnL25vZGVfbW9kdWxlcy91c3dkcy9kaXN0L2ltZy91c2EtaWNvbnMvZXhwYW5kX21vcmUuc3ZnJztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBjb2xsYXBzZUljb24gZnJvbSAnL25vZGVfbW9kdWxlcy91c3dkcy9kaXN0L2ltZy91c2EtaWNvbnMvZXhwYW5kX2xlc3Muc3ZnJztcblxuaW1wb3J0ICogYXMgc3R5bGVzIGZyb20gJy4vVHJhY3REZW1vZ3JhcGhpY3MubW9kdWxlLnNjc3MnO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4uLy4uL2RhdGEvY29uc3RhbnRzJztcbmltcG9ydCAqIGFzIEVYUExPUkVfQ09QWSBmcm9tICcuLi8uLi9kYXRhL2NvcHkvZXhwbG9yZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVRyYWN0RGVtb2dyYXBoaWNzUHJvcHMge1xuICBwcm9wZXJ0aWVzOiBjb25zdGFudHMuSjQwUHJvcGVydGllc1xufVxuXG5pbnRlcmZhY2UgSURlbW9ncmFwaGljc0RhdGEge1xuICByYWNlOiBbUmVhY3QuUmVhY3RFbGVtZW50LCBudW1iZXJdW10sXG4gIGFnZTogW1JlYWN0LlJlYWN0RWxlbWVudCwgbnVtYmVyXVtdLFxufVxuXG5pbnRlcmZhY2UgSUo0MEFjY29yZGlvbkl0ZW0ge1xuICBpZDogc3RyaW5nLFxuICB0aXRsZTogUmVhY3QuUmVhY3RFbGVtZW50LFxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3RFbGVtZW50XG59XG5cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgY3JlYXRlIHRoZSBjdXN0b20gQWNjb3JkaW9uIGl0ZW0uIFRoaXMgd2lsbCBiZSB1c2VkXG4gKiBmb3IgdGhlIHJhY2UgYW5kIGFnZSBkZW1vZ3JhcGhpYyBVSSBlbGVtZW50c1xuICpcbiAqIEBwYXJhbSB7SUo0MEFjY29yZGlvbkl0ZW19IHByb3BzXG4gKiBAcmV0dXJuIHtKU1guRWxlbWVudH1cbiAqL1xuY29uc3QgSjQwQWNjb3JkaW9uSXRlbSA9ICh7aWQsIHRpdGxlLCBjaGlsZHJlbn06SUo0MEFjY29yZGlvbkl0ZW0pID0+IHtcbiAgY29uc3QgW2lzRXhwYW5kZWQsIHNldElzRXhwYW5kZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8aDYgY2xhc3NOYW1lPXtzdHlsZXMuZGVtb2dyYXBoaWNIZWFkaW5nfT5cbiAgICAgICAge3RpdGxlfVxuICAgICAgICA8c3Bhbj5cbiAgICAgICAgICB7JygnfVxuICAgICAgICAgIDxhXG4gICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5zaG93SGlkZVRleHQgPyBgdXNhLWxpbmsgJHtzdHlsZXMuc2hvd0hpZGVUZXh0fWAgOiBgdXNhLWxpbmtgfVxuICAgICAgICAgICAgaWQ9e2Ake2lkfS1oZWFkZXJgfVxuICAgICAgICAgICAgYXJpYS1jb250cm9scz17YCR7aWR9LXBhbmVsYH1cbiAgICAgICAgICAgIGFyaWEtZXhwYW5kZWQ9e2lzRXhwYW5kZWR9XG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRJc0V4cGFuZGVkKCFpc0V4cGFuZGVkKX1cbiAgICAgICAgICAgIHRhYkluZGV4PXswfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtpc0V4cGFuZGVkID9cbiAgICAgICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0RFTU9HUkFQSElDUy5ISURFX0RFTU9HUkFQSElDUyA6XG4gICAgICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9ERU1PR1JBUEhJQ1MuU0hPV19ERU1PR1JBUEhJQ1N9XG4gICAgICAgICAgPC9hPlxuICAgICAgICAgIHsgaXNFeHBhbmRlZCA/XG4gICAgICAgICAgPGltZ1xuICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuc2hvd0hpZGVJY29ufVxuICAgICAgICAgICAgc3JjPXtjb2xsYXBzZUljb259XG4gICAgICAgICAgICBhbHQ9eydjb2xsYXBzZSBpY29uJ31cbiAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldElzRXhwYW5kZWQoIWlzRXhwYW5kZWQpfVxuICAgICAgICAgIC8+IDpcbiAgICAgICAgICA8aW1nXG4gICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5zaG93SGlkZUljb259XG4gICAgICAgICAgICBzcmM9e2V4cGFuZEljb259XG4gICAgICAgICAgICBhbHQ9eydleHBhbmQgaWNvbid9XG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRJc0V4cGFuZGVkKCFpc0V4cGFuZGVkKX1cbiAgICAgICAgICAvPlxuICAgICAgICAgIH1cbiAgICAgICAgICB7JyknfVxuICAgICAgICA8L3NwYW4+XG5cbiAgICAgIDwvaDY+XG5cbiAgICAgIDxzZWN0aW9uXG4gICAgICAgIGlkPXtgJHtpZH0tcGFuZWxgfVxuICAgICAgICBhcmlhLWxhYmVsbGVkYnk9e2Ake2lkfS1oZWFkZXJgfVxuICAgICAgICBoaWRkZW49eyFpc0V4cGFuZGVkfVxuICAgICAgPntjaGlsZHJlbn08L3NlY3Rpb24+XG4gICAgPC8+XG4gICk7XG59O1xuXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGNyZWF0ZSBlYWNoIGxpbmUgaXRlbSBvbiB0aGUgbGlzdCBvZiBkZW1vZ3JhcGhpY3NcbiAqXG4gKiBAcGFyYW0ge1tdfSBkZW1vZ3JhcGhpY0RhdGFcbiAqIEByZXR1cm4ge0pTWC5FbGVtZW50fVxuICovXG5jb25zdCBkZW1vZ3JhcGhpY0l0ZW1HZW4gPSAoZGVtb2dyYXBoaWNEYXRhOiBbXSkgPT4ge1xuICByZXR1cm4gZGVtb2dyYXBoaWNEYXRhLm1hcCgoZWwsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYga2V5PXtpbmRleH0gY2xhc3NOYW1lPXtzdHlsZXMuZGVtb2dyYXBoaWNJdGVtfT5cbiAgICAgICAgPHNwYW4+eyBlbFswXSB9PC9zcGFuPlxuICAgICAgICB7dHlwZW9mIGVsWzFdID09PSAnbnVtYmVyJyA/XG4gICAgICAgIDxzcGFuPntgJHtlbFsxXX0lYH08L3NwYW4+IDpcbiAgICAgICAgPHNwYW4+e2Ake2VsWzFdfWB9PC9zcGFuPiB9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBudW1lcmljIHZhbHVlIG9mIGVhY2ggZGVtb2dyYXBoaWMuIFRha2luZyBpbnRvXG4gKiBhY2NvdW50IGNhc2VzIHdoZW4gdGhlIGRhdGEgaXMgdW5kZWZpbmVkIG9yIGlzIG51bGxcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5jb25zdCBkaXNwbGF5U3RhdCA9IChzdGF0OiBudW1iZXIpID0+IHtcbiAgaWYgKHN0YXQgPT09IHVuZGVmaW5lZCB8fCBzdGF0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICctLSc7XG4gIH0gZWxzZSBpZiAoc3RhdCA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIE51bWJlcihNYXRoLmZsb29yKHN0YXQgKiAxMDApKTtcbn07XG5cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgY3JlYXRlIHRoZSBkYXRhIHN0cnVjdHVyZSBmb3IgdGhlIGRlbW9ncmFwaGljcyBkYXRhXG4gKlxuICogQHBhcmFtIHtjb25zdGFudHMuSjQwUHJvcGVydGllc30gcHJvcGVydGllc1xuICogQHJldHVybiB7SURlbW9ncmFwaGljc0RhdGF9XG4gKi9cbmNvbnN0IGdldERlbW9ncmFwaGljc0RhdGEgPSAocHJvcGVydGllczpjb25zdGFudHMuSjQwUHJvcGVydGllcyk6SURlbW9ncmFwaGljc0RhdGEgPT4gKFxuICB7XG4gICAgcmFjZTogW1xuICAgICAgW1xuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9ERU1PR1JBUEhJQ1MuREVNT19OT05fSElTUEFOSUNfV0hJVEUsXG4gICAgICAgIGRpc3BsYXlTdGF0KHByb3BlcnRpZXNbY29uc3RhbnRzLkRFTU9fTk9OX0hJU1BBTklDX1dISVRFXSksXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9ERU1PR1JBUEhJQ1MuREVNT19CTEFDSyxcbiAgICAgICAgZGlzcGxheVN0YXQocHJvcGVydGllc1tjb25zdGFudHMuREVNT19CTEFDS10pLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfREVNT0dSQVBISUNTLkRFTU9fQU1FUklDQU5fSU5ESUFOLFxuICAgICAgICBkaXNwbGF5U3RhdChwcm9wZXJ0aWVzW2NvbnN0YW50cy5ERU1PX0FNRVJJQ0FOX0lORElBTl0pLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfREVNT0dSQVBISUNTLkRFTU9fQVNJQU4sXG4gICAgICAgIGRpc3BsYXlTdGF0KHByb3BlcnRpZXNbY29uc3RhbnRzLkRFTU9fQVNJQU5dKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0RFTU9HUkFQSElDUy5ERU1PX0hBV0FJSUFOLFxuICAgICAgICBkaXNwbGF5U3RhdChwcm9wZXJ0aWVzW2NvbnN0YW50cy5ERU1PX0hBV0FJSUFOXSksXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9ERU1PR1JBUEhJQ1MuREVNT19PVEhFUl9SQUNFLFxuICAgICAgICBkaXNwbGF5U3RhdChwcm9wZXJ0aWVzW2NvbnN0YW50cy5ERU1PX09USEVSX1JBQ0VdKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0RFTU9HUkFQSElDUy5ERU1PX1RXT19PUl9NT1JFX1JBQ0VTLFxuICAgICAgICBkaXNwbGF5U3RhdChwcm9wZXJ0aWVzW2NvbnN0YW50cy5ERU1PX1RXT19PUl9NT1JFX1JBQ0VTXSksXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9ERU1PR1JBUEhJQ1MuREVNT19ISVNQQU5JQyxcbiAgICAgICAgZGlzcGxheVN0YXQocHJvcGVydGllc1tjb25zdGFudHMuREVNT19ISVNQQU5JQ10pLFxuICAgICAgXSxcbiAgICBdLFxuICAgIGFnZTogW1xuICAgICAgW1xuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9ERU1PR1JBUEhJQ1MuREVNT19BR0VfVU5ERVJfMTAsXG4gICAgICAgIGRpc3BsYXlTdGF0KHByb3BlcnRpZXNbY29uc3RhbnRzLkRFTU9fQUdFX1VOREVSXzEwXSksXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9ERU1PR1JBUEhJQ1MuREVNT19BR0VfTUlELFxuICAgICAgICBkaXNwbGF5U3RhdChwcm9wZXJ0aWVzW2NvbnN0YW50cy5ERU1PX0FHRV9NSURdKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0RFTU9HUkFQSElDUy5ERU1PX0FHRV9PVkVSXzY1LFxuICAgICAgICBkaXNwbGF5U3RhdChwcm9wZXJ0aWVzW2NvbnN0YW50cy5ERU1PX0FHRV9PVkVSXzY0XSksXG4gICAgICBdLFxuICAgIF0sXG4gIH0pO1xuXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgbWFpbiBjb21wb25lbnQgZm9yIHRoaXMgZmlsZS4gSXQgYWNjZXB0cyB0aGUgc2VsZWN0ZWQgZmVhdHVyZVxuICogYXMgYSBwcm9wIGFuZCByZXR1cm4gdGhlIGRlbW9ncmFwaGljcyBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtJVHJhY3REZW1vZ3JhcGhpY3NQcm9wc30gcHJvcHNcbiAqIEByZXR1cm4ge0pTWC5FbGVtZW50fVxuICovXG5jb25zdCBUcmFjdERlbW9ncmFwaGljcyA9ICh7cHJvcGVydGllc306IElUcmFjdERlbW9ncmFwaGljc1Byb3BzKSA9PiB7XG4gIGNvbnN0IHtyYWNlLCBhZ2V9ID0gZ2V0RGVtb2dyYXBoaWNzRGF0YShwcm9wZXJ0aWVzKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZGVtb2dyYXBoaWNzQ29udGFpbmVyfT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZGVtb2dyYXBoaWNzVGl0bGV9PlxuICAgICAgICB7RVhQTE9SRV9DT1BZLlNJREVfUEFORUxfREVNT0dSQVBISUNTLlRJVExFfVxuICAgICAgPC9kaXY+XG4gICAgICA8PlxuICAgICAgICA8SjQwQWNjb3JkaW9uSXRlbSBpZD17J3JhY2UnfSB0aXRsZT17RVhQTE9SRV9DT1BZLlNJREVfUEFORUxfREVNT0dSQVBISUNTLlJBQ0VfVElUTEV9PlxuICAgICAgICAgIHtkZW1vZ3JhcGhpY0l0ZW1HZW4ocmFjZSl9XG4gICAgICAgIDwvSjQwQWNjb3JkaW9uSXRlbT5cbiAgICAgICAgPEo0MEFjY29yZGlvbkl0ZW0gaWQ9eydhZ2UnfSB0aXRsZT17RVhQTE9SRV9DT1BZLlNJREVfUEFORUxfREVNT0dSQVBISUNTLkFHRV9USVRMRX0+XG4gICAgICAgICAge2RlbW9ncmFwaGljSXRlbUdlbihhZ2UpfVxuICAgICAgICA8L0o0MEFjY29yZGlvbkl0ZW0+XG4gICAgICA8Lz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRyYWN0RGVtb2dyYXBoaWNzO1xuIiwiaW1wb3J0IFRyYWN0RGVtb2dyYXBoaWNzIGZyb20gJy4vVHJhY3REZW1vZ3JhcGhpY3MnO1xuZXhwb3J0IGRlZmF1bHQgVHJhY3REZW1vZ3JhcGhpY3M7XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB2YXIgdHJhY3RJbmZvQ29udGFpbmVyID0gXCJUcmFjdEluZm8tbW9kdWxlLS10cmFjdEluZm9Db250YWluZXItLXVQaEVXXCI7XG5leHBvcnQgdmFyIHRyYWN0SW5mb0xhYmVsID0gXCJUcmFjdEluZm8tbW9kdWxlLS10cmFjdEluZm9MYWJlbC0tbVkxMnFcIjsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHt1c2VJbnRsfSBmcm9tICdnYXRzYnktcGx1Z2luLWludGwnO1xuXG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi9UcmFjdEluZm8ubW9kdWxlLnNjc3MnO1xuaW1wb3J0ICogYXMgRVhQTE9SRV9DT1BZIGZyb20gJy4uLy4uL2RhdGEvY29weS9leHBsb3JlJztcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi8uLi9kYXRhL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVRyYWN0SW5mb1Byb3BzIHtcbiAgYmxvY2tHcm91cDogc3RyaW5nLFxuICBjb3VudHlOYW1lOiBzdHJpbmcsXG4gIHN0YXRlTmFtZTogc3RyaW5nLFxuICBwb3B1bGF0aW9uOiBudW1iZXIsXG4gIHNpZGVQYW5lbFN0YXRlOiBzdHJpbmcsXG59XG5cbmNvbnN0IFRyYWN0SW5mbyA9ICh7YmxvY2tHcm91cCwgY291bnR5TmFtZSwgc3RhdGVOYW1lLCBwb3B1bGF0aW9uLCBzaWRlUGFuZWxTdGF0ZX06IElUcmFjdEluZm9Qcm9wcykgPT4ge1xuICBjb25zdCBpbnRsID0gdXNlSW50bCgpO1xuXG4gIHJldHVybiAoXG4gICAgPHVsIGNsYXNzTmFtZT17c3R5bGVzLnRyYWN0SW5mb0NvbnRhaW5lcn0+XG4gICAgICA8bGk+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT17c3R5bGVzLnRyYWN0SW5mb0xhYmVsfT5cbiAgICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0NCR19JTkZPLkNFTlNVU19JTkZPX1RJVExFKX1cbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9saT5cbiAgICAgIDxsaT5cbiAgICAgICAgPHNwYW4+XG4gICAgICAgICAge2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9DQkdfSU5GTy5DRU5TVVNfQkxPQ0tfR1JPVVApfVxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIDxzcGFuPntgICR7YmxvY2tHcm91cH1gfTwvc3Bhbj5cbiAgICAgIDwvbGk+XG4gICAgICA8bGk+XG4gICAgICAgIDxzcGFuPlxuICAgICAgICAgIHtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfQ0JHX0lORk8uQ09VTlRZKX1cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICA8c3Bhbj57YCAke2NvdW50eU5hbWV9YH08L3NwYW4+XG4gICAgICA8L2xpPlxuICAgICAgPGxpPlxuICAgICAgICA8c3Bhbj5cbiAgICAgICAgICB7c2lkZVBhbmVsU3RhdGUgIT09IGNvbnN0YW50cy5TSURFX1BBTkVMX1NUQVRFX1ZBTFVFUy5OQVRJT04gP1xuICAgICAgICAgICAgICBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfQ0JHX0lORk8uVEVSUklUT1JZKSA6XG4gICAgICAgICAgICAgIGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9DQkdfSU5GTy5TVEFURSlcbiAgICAgICAgICB9XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPHNwYW4+e2AgJHtzdGF0ZU5hbWV9YH08L3NwYW4+XG4gICAgICA8L2xpPlxuICAgICAgPGxpPlxuICAgICAgICA8c3Bhbj5cbiAgICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0NCR19JTkZPLlBPUFVMQVRJT04pfVxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIDxzcGFuPntgICR7cG9wdWxhdGlvbi50b0xvY2FsZVN0cmluZygpfWB9PC9zcGFuPlxuICAgICAgPC9saT5cbiAgICA8L3VsPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVHJhY3RJbmZvO1xuIiwiaW1wb3J0IFRyYWN0SW5mbyBmcm9tICcuL1RyYWN0SW5mbyc7XG5leHBvcnQgZGVmYXVsdCBUcmFjdEluZm87XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB2YXIgaW52ZXJ0ID0gXCJUcmFjdFByaW9yaXRpemF0aW9uLW1vZHVsZS0taW52ZXJ0LS1vdXdGY1wiOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuL1RyYWN0UHJpb3JpdGl6YXRpb24ubW9kdWxlLnNjc3MnO1xuXG5pbXBvcnQgKiBhcyBFWFBMT1JFX0NPUFkgZnJvbSAnLi4vLi4vZGF0YS9jb3B5L2V4cGxvcmUnO1xuXG5pbnRlcmZhY2UgSVRyYWN0UHJpb3JpdGl6YXRpb24ge1xuICBzY29yZU5Db21tdW5pdGllczogYm9vbGVhbixcbiAgdHJpYmFsQ291bnRBSzogbnVtYmVyIHwgbnVsbCxcbiAgdHJpYmFsQ291bnRVUzogbnVtYmVyIHwgbnVsbCxcbiAgcGVyY2VudFRyYWN0VHJpYmFsOiBudW1iZXIgfCBudWxsLFxufVxuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHdpbGwgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBkZXNpZ25hdGlvbiBmb3IgdGhlIHRyYWN0J3MgcHJpb3JpdGl6YXRpb25cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNjb3JlTkNvbW11bml0aWVzXG4gKiBAcGFyYW0ge251bWJlciB8IG51bGx9IHRyaWJhbENvdW50QUtcbiAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbH0gdHJpYmFsQ291bnRVU1xuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBwZXJjZW50VHJhY3RUcmliYWxcbiAqIEByZXR1cm4ge0pTWH1cbiAqL1xuY29uc3QgVHJhY3RQcmlvcml0aXphdGlvbiA9IChcbiAgICB7c2NvcmVOQ29tbXVuaXRpZXMsXG4gICAgICB0cmliYWxDb3VudEFLLFxuICAgICAgdHJpYmFsQ291bnRVUyxcbiAgICAgIHBlcmNlbnRUcmFjdFRyaWJhbH06SVRyYWN0UHJpb3JpdGl6YXRpb24pID0+IHtcbiAgaWYgKHNjb3JlTkNvbW11bml0aWVzID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIDxoMyBjbGFzc05hbWU9e3N0eWxlcy5pbnZlcnR9PntFWFBMT1JFX0NPUFkuQ09NTVVOSVRZLk9GX0ZPQ1VTfTwvaDM+O1xuICB9IGVsc2Uge1xuICAgIGlmIChwZXJjZW50VHJhY3RUcmliYWwgPT09IG51bGwgJiYgdHJpYmFsQ291bnRBSyA9PT0gbnVsbCAmJiB0cmliYWxDb3VudFVTID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gPGgzPntFWFBMT1JFX0NPUFkuQ09NTVVOSVRZLk5PVF9PRl9GT0NVU308L2gzPjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDxoMyBjbGFzc05hbWU9e3N0eWxlcy5pbnZlcnR9PntFWFBMT1JFX0NPUFkuQ09NTVVOSVRZLlBBUlRJQUx9PC9oMz47XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBUcmFjdFByaW9yaXRpemF0aW9uO1xuIiwiaW1wb3J0IFRyYWN0UHJpb3JpdGl6YXRpb24gZnJvbSAnLi9UcmFjdFByaW9yaXRpemF0aW9uJztcbmV4cG9ydCBkZWZhdWx0IFRyYWN0UHJpb3JpdGl6YXRpb247XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB2YXIgYXJlYURldGFpbENvbnRhaW5lciA9IFwiYXJlYURldGFpbC1tb2R1bGUtLWFyZWFEZXRhaWxDb250YWluZXItLWk4UzRjXCI7XG5leHBvcnQgdmFyIGJ1dHRvbkNvbnRhaW5lciA9IFwiYXJlYURldGFpbC1tb2R1bGUtLWJ1dHRvbkNvbnRhaW5lci0tMW03amdcIjtcbmV4cG9ydCB2YXIgYnV0dG9uVGV4dCA9IFwiYXJlYURldGFpbC1tb2R1bGUtLWJ1dHRvblRleHQtLWdLdVgzXCI7XG5leHBvcnQgdmFyIGNhdGVnb3JpemF0aW9uID0gXCJhcmVhRGV0YWlsLW1vZHVsZS0tY2F0ZWdvcml6YXRpb24tLUl3eU9HXCI7XG5leHBvcnQgdmFyIGNhdGVnb3J5SGVhZGVyID0gXCJhcmVhRGV0YWlsLW1vZHVsZS0tY2F0ZWdvcnlIZWFkZXItLTc0THVvXCI7XG5leHBvcnQgdmFyIGNhdGVnb3J5U3BhY2VyID0gXCJhcmVhRGV0YWlsLW1vZHVsZS0tY2F0ZWdvcnlTcGFjZXItLXR0MGQ1XCI7XG5leHBvcnQgdmFyIGNlbnN1c0xhYmVsID0gXCJhcmVhRGV0YWlsLW1vZHVsZS0tY2Vuc3VzTGFiZWwtLUp2cEZWXCI7XG5leHBvcnQgdmFyIGNlbnN1c1JvdyA9IFwiYXJlYURldGFpbC1tb2R1bGUtLWNlbnN1c1Jvdy0tQzlRUHVcIjtcbmV4cG9ydCB2YXIgY2Vuc3VzVGV4dCA9IFwiYXJlYURldGFpbC1tb2R1bGUtLWNlbnN1c1RleHQtLURON3Z2XCI7XG5leHBvcnQgdmFyIGNvbW11bml0eU9mRm9jdXMgPSBcImFyZWFEZXRhaWwtbW9kdWxlLS1jb21tdW5pdHlPZkZvY3VzLS1FMlk0elwiO1xuZXhwb3J0IHZhciBpc0luRm9jdXMgPSBcImFyZWFEZXRhaWwtbW9kdWxlLS1pc0luRm9jdXMtLWNNVTlTXCI7XG5leHBvcnQgdmFyIHByaW9Db3B5ID0gXCJhcmVhRGV0YWlsLW1vZHVsZS0tcHJpb0NvcHktLThvekc1XCI7XG5leHBvcnQgdmFyIHNlbmRGZWVkYmFja0J0biA9IFwiYXJlYURldGFpbC1tb2R1bGUtLXNlbmRGZWVkYmFja0J0bi0teXpVN1BcIjtcbmV4cG9ydCB2YXIgc2VuZEZlZWRiYWNrTGluayA9IFwiYXJlYURldGFpbC1tb2R1bGUtLXNlbmRGZWVkYmFja0xpbmstLXczTm9qXCI7XG5leHBvcnQgdmFyIHNob3dDYXRlZ29yaWVzRXhjZWVkID0gXCJhcmVhRGV0YWlsLW1vZHVsZS0tc2hvd0NhdGVnb3JpZXNFeGNlZWQtLWJ1bUkxXCI7XG5leHBvcnQgdmFyIHRlc3RTaWduYWxzID0gXCJhcmVhRGV0YWlsLW1vZHVsZS0tdGVzdFNpZ25hbHMtLXlZaHFSXCI7XG5leHBvcnQgdmFyIHZlcnNpb25JbmZvID0gXCJhcmVhRGV0YWlsLW1vZHVsZS0tdmVyc2lvbkluZm8tLUhOSDBPXCI7IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIGludmVydCA9IFwiSXNsYW5kQ29weS1tb2R1bGUtLWludmVydC0tV2FiRFRcIjtcbmV4cG9ydCB2YXIgaXNsYW5kQ29weUNvbnRhaW5lciA9IFwiSXNsYW5kQ29weS1tb2R1bGUtLWlzbGFuZENvcHlDb250YWluZXItLXJDQldvXCI7XG5leHBvcnQgdmFyIGlzbGFuZFJvdyA9IFwiSXNsYW5kQ29weS1tb2R1bGUtLWlzbGFuZFJvdy0tVTZmblJcIjtcbmV4cG9ydCB2YXIgaXNsYW5kUm93TGFiZWwgPSBcIklzbGFuZENvcHktbW9kdWxlLS1pc2xhbmRSb3dMYWJlbC0tMFdza2dcIjtcbmV4cG9ydCB2YXIgbm9JbnZlcnQgPSBcIklzbGFuZENvcHktbW9kdWxlLS1ub0ludmVydC0tMjNXYVNcIjtcbmV4cG9ydCB2YXIgc3ViVGV4dENvbnRhaW5lciA9IFwiSXNsYW5kQ29weS1tb2R1bGUtLXN1YlRleHRDb250YWluZXItLVdBUTVJXCI7XG5leHBvcnQgdmFyIHZhbHVlQ29udGFpbmVyID0gXCJJc2xhbmRDb3B5LW1vZHVsZS0tdmFsdWVDb250YWluZXItLVh5dmZUXCI7XG5leHBvcnQgdmFyIHZhbHVlU3ViVGV4dENvbnRhaW5lciA9IFwiSXNsYW5kQ29weS1tb2R1bGUtLXZhbHVlU3ViVGV4dENvbnRhaW5lci0tWStEUTJcIjsiLCJpbXBvcnQge3VzZUludGx9IGZyb20gJ2dhdHNieS1wbHVnaW4taW50bCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQge0luZGljYXRvclZhbHVlLCBJbmRpY2F0b3JWYWx1ZVN1YlRleHR9IGZyb20gJy4uL0luZGljYXRvci9JbmRpY2F0b3InO1xuXG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi9Jc2xhbmRDb3B5Lm1vZHVsZS5zY3NzJztcblxuaW1wb3J0ICogYXMgRVhQTE9SRV9DT1BZIGZyb20gJy4uLy4uL2RhdGEvY29weS9leHBsb3JlJztcblxuZXhwb3J0IGludGVyZmFjZSBJSXNsYW5kQ29weVByb3BzIHtcbiAgcG92ZXJ0eVBlcmNlbnRpbGU6IG51bWJlciB8IG51bGxcbn1cblxuY29uc3QgSXNsYW5kQ29weSA9ICh7cG92ZXJ0eVBlcmNlbnRpbGV9OiBJSXNsYW5kQ29weVByb3BzKSA9PiB7XG4gIGNvbnN0IGludGwgPSB1c2VJbnRsKCk7XG4gIGNvbnN0IHBlcmNlbnRpbGVXaG9sZSA9IHBvdmVydHlQZXJjZW50aWxlID9cbiAgICBwYXJzZUZsb2F0KChwb3ZlcnR5UGVyY2VudGlsZSoxMDApLnRvRml4ZWQoKSkgOiBudWxsO1xuICBjb25zdCB0aHJlc2hvbGQgPSA2NTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaXNsYW5kQ29weUNvbnRhaW5lcn0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmlzbGFuZFJvd30+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaXNsYW5kUm93TGFiZWx9PlxuICAgICAgICAgIHtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLklTTEFORF9DT1BZLkxPV19JTkMpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy52YWx1ZVN1YlRleHRDb250YWluZXJ9PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtzdHlsZXMudmFsdWVDb250YWluZXJ9XG4gICAgICAgICAgICAkeyBwZXJjZW50aWxlV2hvbGUgJiYgcGVyY2VudGlsZVdob2xlID49IHRocmVzaG9sZCA/XG4gICAgICAgICAgICAgIHN0eWxlcy5pbnZlcnQgOlxuICAgICAgICAgICAgICBzdHlsZXMubm9JbnZlcnQgfVxuICAgICAgICAgIGB9PlxuICAgICAgICAgICAgPEluZGljYXRvclZhbHVlXG4gICAgICAgICAgICAgIHR5cGU9eydwZXJjZW50aWxlJ31cbiAgICAgICAgICAgICAgZGlzcGxheVN0YXQ9e3BlcmNlbnRpbGVXaG9sZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zdWJUZXh0Q29udGFpbmVyfT5cbiAgICAgICAgICAgIDxJbmRpY2F0b3JWYWx1ZVN1YlRleHRcbiAgICAgICAgICAgICAgdmFsdWU9e3BlcmNlbnRpbGVXaG9sZX1cbiAgICAgICAgICAgICAgaXNBYm92ZVRocmVzaD17cGVyY2VudGlsZVdob2xlICYmIHBlcmNlbnRpbGVXaG9sZSA+PSB0aHJlc2hvbGQgPyB0cnVlIDogZmFsc2V9XG4gICAgICAgICAgICAgIHRocmVzaG9sZD17dGhyZXNob2xkfVxuICAgICAgICAgICAgICB0eXBlPXsncGVyY2VudGlsZSd9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSXNsYW5kQ29weTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIHF1b3RlcyAqL1xuLy8gRXh0ZXJuYWwgTGliczpcbmltcG9ydCB7QWNjb3JkaW9uLCBCdXR0b24sIEljb259IGZyb20gXCJAdHJ1c3N3b3Jrcy9yZWFjdC11c3dkc1wiO1xuaW1wb3J0IHtNZXNzYWdlRGVzY3JpcHRvciwgdXNlSW50bH0gZnJvbSBcImdhdHNieS1wbHVnaW4taW50bFwiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBDb21wb25lbnRzOlxuaW1wb3J0IENhdGVnb3J5IGZyb20gXCIuLi9DYXRlZ29yeVwiO1xuaW1wb3J0IERvbnV0Q29weSBmcm9tIFwiLi4vRG9udXRDb3B5XCI7XG5pbXBvcnQgSW5kaWNhdG9yIGZyb20gXCIuLi9JbmRpY2F0b3JcIjtcbmltcG9ydCBQcmlvcml0aXphdGlvbkNvcHkgZnJvbSBcIi4uL1ByaW9yaXRpemF0aW9uQ29weVwiO1xuaW1wb3J0IFByaW9yaXRpemF0aW9uQ29weTIgZnJvbSBcIi4uL1ByaW9yaXRpemF0aW9uQ29weTJcIjtcbmltcG9ydCBUcmFjdERlbW9ncmFwaGljcyBmcm9tIFwiLi4vVHJhY3REZW1vZ3JhcGhpY3NcIjtcbmltcG9ydCBUcmFjdEluZm8gZnJvbSBcIi4uL1RyYWN0SW5mb1wiO1xuaW1wb3J0IFRyYWN0UHJpb3JpdGl6YXRpb24gZnJvbSBcIi4uL1RyYWN0UHJpb3JpdGl6YXRpb25cIjtcblxuLy8gU3R5bGVzIGFuZCBjb25zdGFudHNcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tIFwiLi4vLi4vZGF0YS9jb25zdGFudHNcIjtcbmltcG9ydCAqIGFzIEVYUExPUkVfQ09QWSBmcm9tIFwiLi4vLi4vZGF0YS9jb3B5L2V4cGxvcmVcIjtcbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tIFwiLi9hcmVhRGV0YWlsLm1vZHVsZS5zY3NzXCI7XG5cbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBJc2xhbmRDb3B5IGZyb20gXCIuLi9Jc2xhbmRDb3B5L0lzbGFuZENvcHlcIjtcblxuaW50ZXJmYWNlIElBcmVhRGV0YWlsUHJvcHMge1xuICBwcm9wZXJ0aWVzOiBjb25zdGFudHMuSjQwUHJvcGVydGllcztcbiAgaGFzaDogc3RyaW5nW107XG59XG5cbi8qKlxuICogVGhlcmUgYXJlIGEgNCBkaWZmZXJlbnQgaW5kaWNhdG9yIHR5cGVzLiBFYWNoIGluZGljYXRvciB0eXBlIHdpbGwgcmVuZGVyIGluIHRoZSBVSSBkaWZmZXJlbnRseS5cbiAqXG4gKiBwZXJjZW50aWxlIC0gaXMgdGhlIG1ham9yaXR5IG9mIGluZGljYXRvcnNcbiAqIHBlcmNlbnRzIC0gYSBmZXcgaW5kaWNhdG9ycyBmYWxsIGludG8gdGhpcyB0eXBlXG4gKiBib29sZWFuIC0gMyBpbmRpY2F0b3JzIGFyZSBvZiBib29sZWFuIHR5cGVcbiAqICAgIC0gaGlzdG9yaWMgcmVkbGluaW5nXG4gKiAgICAtIGFiYW5kb25lZCBsYW5kIG1pbmVzXG4gKiAgICAtIEZVRFNcbiAqXG4gKi9cbmV4cG9ydCB0eXBlIGluZGljYXRvclR5cGUgPSBcInBlcmNlbnRpbGVcIiB8IFwicGVyY2VudFwiIHwgXCJib29sZWFuXCI7XG5cbi8qKlxuICogVGhpcyBpbnRlcmZhY2UgaXMgdXNlZCBhcyBkZWZpbmUgdGhlIHZhcmlvdXMgZmllbGRzIGZvciBlYWNoIGluZGljYXRvciBpbiB0aGUgc2lkZSBwYW5lbFxuICogIGxhYmVsOiB0aGUgaW5kaWNhdG9yIGxhYmVsIG9yIHRpdGxlXG4gKiAgZGVzY3JpcHRpb246IHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgaW5kaWNhdG9yIHVzZWQgaW4gdGhlIHNpZGUgcGFuZWxcbiAqICB0eXBlOiBzZWUgaW5kaWNhdG9yVHlwZSBhYm92ZVxuICogIHZhbHVlOiB0aGUgbnVtYmVyIGZyb20gdGhlIGdlb0pTT04gdGlsZS4gSWYgdGlsZSBkb2Vzbid0IGV4aXN0IGl0IGdldCBhIG51bGwgdmFsdWUuIENvdWxkIGJlIGJvb2xlYW4gYWxzb1xuICogIGlzRGlzYWR2YWd0YWdlZDogdGhlIGZsYWcgZnJvbSB0aGUgZ2VvSlNPTiB0aWxlXG4gKiAgdGhyZXNob2xkOiBhIGN1c3RvbSB2YWx1ZSBvZiB0aHJlc2hvbGQgZm9yIGNlcnRhaW4gaW5kaWNhdG9yc1xuICogICovXG5leHBvcnQgaW50ZXJmYWNlIGluZGljYXRvckluZm8ge1xuICBsYWJlbDogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICB0eXBlOiBpbmRpY2F0b3JUeXBlO1xuICB2YWx1ZTogbnVtYmVyIHwgYm9vbGVhbiB8IG51bGw7XG4gIGlzRGlzYWR2YWd0YWdlZDogYm9vbGVhbjtcbiAgdGhyZXNob2xkPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIFRoaXMgaW50ZXJmYWNlIGlzIHVzZWQgYXMgZGVmaW5lIHRoZSB2YXJpb3VzIGZpZWxkcyBmb3IgY2F0ZWdvcnkgaW4gdGhlIHNpZGUgcGFuZWxcbiAqIGlkOiBkaXN0aWN0IGlkXG4gKiB0aXRsZVRleHQ6IGRpc3BsYXkgdGV4dCBmb3IgdGhlIGNhdGVnb3J5IHRpdGxlXG4gKiBpbmRpY2F0b3JzOiBhbiBhcnJheSBvZiBpbmRpY2F0b3JzXG4gKiBzb2Npb0VjSW5kaWNhdG9yczogYW4gYXJyYXkgb2Ygc29jaW9lY29ub21pYyBpbmRpY2F0b3JzXG4gKiBpc0Rpc2FkdmFndGFnZWQ6IGJvb2xlYW4gdG8gaW5kaWNhdGUgaWYgdGhlIGNhdGVnb3J5IGlzIGRpc2FkdmFudGFnZWRcbiAqIGlzRXhjZWVkMU1vcmVCdXJkZW46IGJvb2xlYW4gdG8gaW5kaWNhdGUgaWYgdGhlIGNhdGVnb3J5IGV4Y2VlZHMgbW9yZSB0aGFuIG9uZSBidXJkZW5cbiAqIGlzRXhjZWVkQm90aFNvY2lvQnVyZGVuczogYm9vbGVhbiB0byBpbmRpY2F0ZSBpZiB0aGUgY2F0ZWdvcnkgZXhjZWVkcyBib3RoIHNvY2lvLWVjbyBidXJkZW5zXG4gKiAgKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUNhdGVnb3J5IHtcbiAgaWQ6IHN0cmluZztcbiAgdGl0bGVUZXh0OiBzdHJpbmc7XG4gIGluZGljYXRvcnM6IGluZGljYXRvckluZm9bXTtcbiAgc29jaW9FY0luZGljYXRvcnM6IGluZGljYXRvckluZm9bXTtcbiAgaXNEaXNhZHZhZ3RhZ2VkOiBib29sZWFuIHwgbnVsbDtcbiAgaXNFeGNlZWQxTW9yZUJ1cmRlbjogYm9vbGVhbiB8IG51bGw7XG4gIGlzRXhjZWVkQm90aFNvY2lvQnVyZGVuczogYm9vbGVhbiB8IG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBmaWx0ZXIgd2lsbCByZW1vdmUgaW5kaWNhdG9ycyBmcm9tIGFwcGVhcmluZyBpbiB0aGUgc2lkZSBwYW5lbCBieSByZXR1cm5pbmdcbiAqIHRoZSBmaWx0ZXIgZnVuY3Rpb24gKGN1cnJ5aW5nKS4gVGhlcmUgaXMgMSB1c2UgY2FzZS4gSXQgY2FuIGFjY2VwdCBhbnkgaW5kaWNhdG9yIG5hbWVcbiAqIGFzIGFuIGlucHV0LlxuICpcbiAqIDEuIEZvciBIaXN0b3JpYyB1bmRlcmludmVzdG1lbnQgaWYgdGhlIHZhbHVlIGlzIG51bGxcbiAqXG4gKiBSZWNvbW1lbmRhdGlvbiBpcyB0byB1c2UgYSBzZXBhcmF0ZSBmaWx0ZXIgZm9yIGVhY2ggaW5kaWNhdG9yIHRoYXQgbmVlZHMgZmlsdGVyaW5nLlxuICpcbiAqIEBwYXJhbSB7TWVzc2FnZURlc2NyaXB0b3J9IGxhYmVsIC0gYWxsb3dzIHRvIHJlLXVzZSB0aGlzIGZpbHRlciBmb3IgYW55IG51bWJlciBvZiBpbmRpY2F0b3JzXG4gKiBAcmV0dXJuIHtpbmRpY2F0b3JJbmZvfVxuICovXG5leHBvcnQgY29uc3QgaW5kaWNhdG9yRmlsdGVyID0gKGxhYmVsOiBNZXNzYWdlRGVzY3JpcHRvcikgPT4ge1xuICBjb25zdCBpbnRsID0gdXNlSW50bCgpO1xuXG4gIHJldHVybiAoaW5kaWNhdG9yOiBpbmRpY2F0b3JJbmZvKSA9PlxuICAgIGluZGljYXRvci5sYWJlbCAhPT0gaW50bC5mb3JtYXRNZXNzYWdlKGxhYmVsKSB8fFxuICAgIChpbmRpY2F0b3IubGFiZWwgPT0gaW50bC5mb3JtYXRNZXNzYWdlKGxhYmVsKSAmJiBpbmRpY2F0b3IudmFsdWUgIT0gbnVsbCk7XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSB0aGUgdHJpYmFsIGFyZWEgcGVyY2VudGFnZSB2YWx1ZSB0byBkaXNwbGF5IHdoZW4gYSB0cmFjdCBpcyBzZWxlY3RlZFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0cmliYWxQZXJjZW50UmF3XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRUcmliYWxQZXJjZW50VmFsdWUgPSAodHJpYmFsUGVyY2VudFJhdzogbnVtYmVyKSA9PiB7XG4gIGlmICh0cmliYWxQZXJjZW50UmF3ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYCBub25lYDtcbiAgfVxuXG4gIGlmICh0cmliYWxQZXJjZW50UmF3ID09PSAwKSB7XG4gICAgLy8gdGVzdCB0cmFjdCA9ICM5LjAzLzQyLjkyNDIvLTk4LjgwMTVcbiAgICByZXR1cm4gYCBsZXNzIHRoYW4gMSVgO1xuICB9XG5cbiAgaWYgKHRyaWJhbFBlcmNlbnRSYXcgJiYgdHJpYmFsUGVyY2VudFJhdyA+IDApIHtcbiAgICByZXR1cm4gYCAke3BhcnNlRmxvYXQoKHRyaWJhbFBlcmNlbnRSYXcgKiAxMDApLnRvRml4ZWQoKSl9ICVgO1xuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIG1haW4gY29tcG9uZW50LiBJdCB3aWxsIHJlbmRlciB0aGUgZW50aXJlIHNpZGUgcGFuZWwgYW5kIHNob3cgdGhlIGRldGFpbHNcbiAqIG9mIHRoZSBhcmVhL2ZlYXR1cmUgdGhhdCBpcyBzZWxlY3RlZC5cbiAqXG4gKiBAcGFyYW0ge0lBcmVhRGV0YWlsUHJvcHN9IHt9XG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5jb25zdCBBcmVhRGV0YWlsID0gKHtwcm9wZXJ0aWVzfTogSUFyZWFEZXRhaWxQcm9wcykgPT4ge1xuICBjb25zdCBpbnRsID0gdXNlSW50bCgpO1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGluZGljYXRvcnMgZm9yIGEgZ2l2ZW4gY2F0ZWdvcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCB0aGUgY2F0ZWdvcnkgSURcbiAgICogQHBhcmFtIHtpbmRpY2F0b3JJbmZvW119IGluZGljYXRvcnMgdGhlIGluZGljYXRvcnMgdG8gc2V0IGZvciB0aGUgY2F0ZWdvcnkuXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGNhdGVnb3J5IElEIGRvZXMgbm90IGV4aXN0XG4gICAqL1xuICBjb25zdCBzZXRDYXRlZ29yeUluZGljYXRvcnMgPSAoaWQ6IHN0cmluZywgaW5kaWNhdG9yczogaW5kaWNhdG9ySW5mb1tdKSA9PiB7XG4gICAgY29uc3QgY2F0ID0gY2F0ZWdvcmllcy5maW5kKChjYXRlZ29yeSkgPT4gY2F0ZWdvcnkuaWQgPT09IGlkKTtcbiAgICBpZiAoY2F0KSBjYXQuaW5kaWNhdG9ycyA9IGluZGljYXRvcnM7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gc2lkZSBwYW5lbCBjYXRlZ29yeSBJRCAnICsgaWQpO1xuICB9O1xuXG4gIC8vIGNvbnNvbGUubG9nIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBjZW5zdXMgdGhhdCBpcyBzZWxlY3RlZDpcbiAgY29uc29sZS5sb2coXG4gICAgICBcIkJFIHNpZ25hbHMgZm9yIHRyYWN0IChsYXN0IG9uZSBpcyB0aGUgdHJhY3QgY3VycmVudGx5IHNlbGVjdGVkKTogXCIsXG4gICAgICBwcm9wZXJ0aWVzLFxuICApO1xuXG4gIC8vIGNvbnNvbGUubG9nIGFyb3VuZCB0aGUgZG9udXQsIGFkamFjZW5jeSBhbmQgdHJpYmFsIGluZm86XG4gIGNvbnNvbGUubG9nKFxuICAgICAgXCJJbmNvbWUgaW1wdXRlZD8gXCIsXG4gICAgcHJvcGVydGllc1tjb25zdGFudHMuSU1QVVRFX0ZMQUddID09PSBcIjBcIiA/IFwiIE5PXCIgOiBcIiBZRVNcIixcbiAgKTtcbiAgY29uc29sZS5sb2coXG4gICAgICBcIkFkamFjZW5jeSBpbmRpY2F0b3I/IFwiLFxuICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkFESkFDRU5DWV9FWENFRURTX1RIUkVTSF0gPyBcIiBZRVNcIiA6IFwiIE5PXCIsXG4gICk7XG4gIGNvbnNvbGUubG9nKFxuICAgICAgXCIlIG9mIHRyYWN0IHRyaWJhbDogXCIsXG4gICAgICBnZXRUcmliYWxQZXJjZW50VmFsdWUocHJvcGVydGllc1tjb25zdGFudHMuVFJJQkFMX0FSRUFTX1BFUkNFTlRBR0VdKSxcbiAgKTtcbiAgY29uc29sZS5sb2coXG4gICAgICBcIlRyaWJhbCBjb3VudCBpbiBBSzogXCIsXG4gICAgcHJvcGVydGllc1tjb25zdGFudHMuVFJJQkFMX0FSRUFTX0NPVU5UX0FLXSA+PSAxID9cbiAgICAgIGAgJHtwcm9wZXJ0aWVzW2NvbnN0YW50cy5UUklCQUxfQVJFQVNfQ09VTlRfQUtdfWAgOlxuICAgICAgYCBudWxsYCxcbiAgKTtcbiAgY29uc29sZS5sb2coXG4gICAgICBcIlRyaWJhbCBjb3VudCBpbiBDT05VUzogXCIsXG4gICAgcHJvcGVydGllc1tjb25zdGFudHMuVFJJQkFMX0FSRUFTX0NPVU5UX0NPTlVTXSA+PSAxID9cbiAgICAgIGAgJHtwcm9wZXJ0aWVzW2NvbnN0YW50cy5UUklCQUxfQVJFQVNfQ09VTlRfQ09OVVNdfWAgOlxuICAgICAgYCBudWxsYCxcbiAgKTtcblxuICAvLyBGaXggY29uc3RhbnRzLk1JU1NJTkdfREFUQV9TVFJJTkcgaW1wb3J0XG4gIGNvbnN0IGJsb2NrR3JvdXAgPSBwcm9wZXJ0aWVzW2NvbnN0YW50cy5HRU9JRF9QUk9QRVJUWV0gP1xuICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkdFT0lEX1BST1BFUlRZXSA6XG4gICAgY29uc3RhbnRzLk1JU1NJTkdfREFUQV9TVFJJTkc7XG4gIGNvbnN0IHBvcHVsYXRpb24gPSBwcm9wZXJ0aWVzW2NvbnN0YW50cy5UT1RBTF9QT1BVTEFUSU9OXSA/XG4gICAgcHJvcGVydGllc1tjb25zdGFudHMuVE9UQUxfUE9QVUxBVElPTl0gOlxuICAgIGNvbnN0YW50cy5NSVNTSU5HX0RBVEFfU1RSSU5HO1xuICBjb25zdCBjb3VudHlOYW1lID0gcHJvcGVydGllc1tjb25zdGFudHMuQ09VTlRZX05BTUVdID9cbiAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5DT1VOVFlfTkFNRV0gOlxuICAgIGNvbnN0YW50cy5NSVNTSU5HX0RBVEFfU1RSSU5HO1xuICBjb25zdCBzdGF0ZU5hbWUgPSBwcm9wZXJ0aWVzW2NvbnN0YW50cy5TVEFURV9OQU1FXSA/XG4gICAgcHJvcGVydGllc1tjb25zdGFudHMuU1RBVEVfTkFNRV0gOlxuICAgIGNvbnN0YW50cy5NSVNTSU5HX0RBVEFfU1RSSU5HO1xuXG4gIGNvbnN0IHNpZGVQYW5lbFN0YXRlID0gcHJvcGVydGllc1tjb25zdGFudHMuU0lERV9QQU5FTF9TVEFURV07XG4gIGNvbnN0IHBlcmNlbnRUcmFjdFRyaWJhbCA9XG4gICAgcHJvcGVydGllc1tjb25zdGFudHMuVFJJQkFMX0FSRUFTX1BFUkNFTlRBR0VdID49IDAgP1xuICAgICAgcGFyc2VGbG9hdChcbiAgICAgICAgICAocHJvcGVydGllc1tjb25zdGFudHMuVFJJQkFMX0FSRUFTX1BFUkNFTlRBR0VdICogMTAwKS50b0ZpeGVkKCksXG4gICAgICApIDpcbiAgICAgIG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSB3b3JrZm9yY2UgZGV2ZWxvcG1lbnQgY2F0ZWdvcnkgaGFzIHNvbWUgaW5kaWNhdG9ycyB3aG8ncyBzb3VyY2Ugd2lsbCB2YXJ5IGRlcGVuZGluZyBvbiB3aGljaFxuICAgKiB0ZXJyaXRvcnkgaXMgc2VsZWN0ZWQuIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHVzIHRvIGNoYW5nZSB0aGUgc291cmNlIG9mIHdvcmtmb3JjZSBkZXZlbG9wbWVudCBpbmRpY2F0b3JzXG4gICAqIGRlcGVuZGluZyBvbiB3aGljaCB0ZXJyaXRvcnkgd2FzIHNlbGVjdGVkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbmRpY2F0b3JOYW1lXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBjb25zdCBnZXRXb3JrRm9yY2VJbmRpY2F0b3JWYWx1ZSA9IChpbmRpY2F0b3JOYW1lOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoc2lkZVBhbmVsU3RhdGUgPT09IGNvbnN0YW50cy5TSURFX1BBTkVMX1NUQVRFX1ZBTFVFUy5JU0xBTkRfQVJFQVMpIHtcbiAgICAgIGlmIChpbmRpY2F0b3JOYW1lID09PSBcImxvd01lZEluY1wiKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgICAgY29uc3RhbnRzLklTTEFORF9BUkVBU19MT1dfTUVESUFOX0lOQ09NRV9MT1dfSFNfRURVX1BFUkNFTlRJTEVfRklFTEQsXG4gICAgICAgICkgP1xuICAgICAgICAgIHByb3BlcnRpZXNbXG4gICAgICAgICAgICAgIGNvbnN0YW50c1xuICAgICAgICAgICAgICAgICAgLklTTEFORF9BUkVBU19MT1dfTUVESUFOX0lOQ09NRV9MT1dfSFNfRURVX1BFUkNFTlRJTEVfRklFTERcbiAgICAgICAgICBdIDpcbiAgICAgICAgICBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGluZGljYXRvck5hbWUgPT09IFwidW5lbXBsb3lcIikge1xuICAgICAgICByZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgIGNvbnN0YW50cy5JU0xBTkRfQVJFQVNfVU5FTVBMT1lNRU5UX0xPV19IU19FRFVfUEVSQ0VOVElMRV9GSUVMRCxcbiAgICAgICAgKSA/XG4gICAgICAgICAgcHJvcGVydGllc1tcbiAgICAgICAgICAgICAgY29uc3RhbnRzLklTTEFORF9BUkVBU19VTkVNUExPWU1FTlRfTE9XX0hTX0VEVV9QRVJDRU5USUxFX0ZJRUxEXG4gICAgICAgICAgXSA6XG4gICAgICAgICAgbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRpY2F0b3JOYW1lID09PSBcInBvdmVydHlcIikge1xuICAgICAgICByZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgIGNvbnN0YW50cy5JU0xBTkRfQVJFQVNfUE9WRVJUWV9MT1dfSFNfRURVX1BFUkNFTlRJTEVfRklFTEQsXG4gICAgICAgICkgP1xuICAgICAgICAgIHByb3BlcnRpZXNbXG4gICAgICAgICAgICAgIGNvbnN0YW50cy5JU0xBTkRfQVJFQVNfUE9WRVJUWV9MT1dfSFNfRURVX1BFUkNFTlRJTEVfRklFTERcbiAgICAgICAgICBdIDpcbiAgICAgICAgICBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGluZGljYXRvck5hbWUgPT09IFwiaGlnaFNjaG9vbFwiKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgICAgY29uc3RhbnRzLklTTEFORF9BUkVBU19IU19FRFVfUEVSQ0VOVEFHRV9GSUVMRCxcbiAgICAgICAgKSA/XG4gICAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNMQU5EX0FSRUFTX0hTX0VEVV9QRVJDRU5UQUdFX0ZJRUxEXSA6XG4gICAgICAgICAgbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5kaWNhdG9yTmFtZSA9PT0gXCJsb3dNZWRJbmNcIikge1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnRzLkxPV19NRURJQU5fSU5DT01FX1BFUkNFTlRJTEUpID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuTE9XX01FRElBTl9JTkNPTUVfUEVSQ0VOVElMRV0gOlxuICAgICAgICBudWxsO1xuICAgIH1cbiAgICBpZiAoaW5kaWNhdG9yTmFtZSA9PT0gXCJ1bmVtcGxveVwiKSB7XG4gICAgICByZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICBjb25zdGFudHMuVU5FTVBMT1lNRU5UX1BST1BFUlRZX1BFUkNFTlRJTEUsXG4gICAgICApID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuVU5FTVBMT1lNRU5UX1BST1BFUlRZX1BFUkNFTlRJTEVdIDpcbiAgICAgICAgbnVsbDtcbiAgICB9XG4gICAgaWYgKGluZGljYXRvck5hbWUgPT09IFwicG92ZXJ0eVwiKSB7XG4gICAgICByZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuUE9WRVJUWV9CRUxPV18xMDBfUEVSQ0VOVElMRSkgP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5QT1ZFUlRZX0JFTE9XXzEwMF9QRVJDRU5USUxFXSA6XG4gICAgICAgIG51bGw7XG4gICAgfVxuICAgIGlmIChpbmRpY2F0b3JOYW1lID09PSBcImhpZ2hTY2hvb2xcIikge1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXG4gICAgICAgICAgY29uc3RhbnRzLkhJR0hfU0NIT09MX1BST1BFUlRZX1BFUkNFTlRJTEUsXG4gICAgICApID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSElHSF9TQ0hPT0xfUFJPUEVSVFlfUEVSQ0VOVElMRV0gOlxuICAgICAgICBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhlIHdvcmtmb3JjZSBkZXZlbG9wbWVudCBjYXRlZ29yeSBoYXMgc29tZSBpbmRpY2F0b3JzIHdobydzIGRpc2FkdmFudGFnZWQgYm9vbGVhblxuICAgKiB3aWxsIHZhcnkgZGVwZW5kaW5nIG9uIHdoaWNoIHRlcnJpdG9yeSBpcyBzZWxlY3RlZC4gVGhpcyBmdW5jdGlvbiBhbGxvd3MgdXMgdG8gY2hhbmdlXG4gICAqIHRoZSBib29sZWFuIG9mIHdvcmtmb3JjZSBkZXZlbG9wbWVudCBpbmRpY2F0b3JzIGRlcGVuZGluZyBvbiB3aGljaCB0ZXJyaXRvcnkgd2FzIHNlbGVjdGVkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbmRpY2F0b3JOYW1lXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBjb25zdCBnZXRXb3JrRm9yY2VJbmRpY2F0b3JJc0Rpc2FkdiA9IChpbmRpY2F0b3JOYW1lOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoc2lkZVBhbmVsU3RhdGUgPT09IGNvbnN0YW50cy5TSURFX1BBTkVMX1NUQVRFX1ZBTFVFUy5JU0xBTkRfQVJFQVMpIHtcbiAgICAgIGlmIChpbmRpY2F0b3JOYW1lID09PSBcImxvd01lZEluY1wiKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgICAgY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9JU0xBTkRfQVJFQV9MT1dfTUVESUFOX0lOQ09NRSxcbiAgICAgICAgKSA/XG4gICAgICAgICAgcHJvcGVydGllc1tcbiAgICAgICAgICAgICAgY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9JU0xBTkRfQVJFQV9MT1dfTUVESUFOX0lOQ09NRVxuICAgICAgICAgIF0gOlxuICAgICAgICAgIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoaW5kaWNhdG9yTmFtZSA9PT0gXCJ1bmVtcGxveVwiKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgICAgY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9JU0xBTkRfQVJFQV9VTkVNUExPWU1FTlQsXG4gICAgICAgICkgP1xuICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9JU0xBTkRfQVJFQV9VTkVNUExPWU1FTlRdIDpcbiAgICAgICAgICBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGluZGljYXRvck5hbWUgPT09IFwicG92ZXJ0eVwiKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgICAgY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9JU0xBTkRfQVJFQV9CRUxPV18xMDBfUE9WRVJUWSxcbiAgICAgICAgKSA/XG4gICAgICAgICAgcHJvcGVydGllc1tcbiAgICAgICAgICAgICAgY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9JU0xBTkRfQVJFQV9CRUxPV18xMDBfUE9WRVJUWVxuICAgICAgICAgIF0gOlxuICAgICAgICAgIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoaW5kaWNhdG9yTmFtZSA9PT0gXCJoaWdoU2Nob29sXCIpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnRzLklTTEFORF9BUkVBX0xPV19IU19FRFUpID9cbiAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU0xBTkRfQVJFQV9MT1dfSFNfRURVXSA6XG4gICAgICAgICAgbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5kaWNhdG9yTmFtZSA9PT0gXCJsb3dNZWRJbmNcIikge1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXG4gICAgICAgICAgY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9MT1dfTUVESUFOX0lOQ09NRSxcbiAgICAgICkgP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfTE9XX01FRElBTl9JTkNPTUVdIDpcbiAgICAgICAgbnVsbDtcbiAgICB9XG4gICAgaWYgKGluZGljYXRvck5hbWUgPT09IFwidW5lbXBsb3lcIikge1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXG4gICAgICAgICAgY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9VTkVNUExPWU1FTlQsXG4gICAgICApID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX1VORU1QTE9ZTUVOVF0gOlxuICAgICAgICBudWxsO1xuICAgIH1cbiAgICBpZiAoaW5kaWNhdG9yTmFtZSA9PT0gXCJwb3ZlcnR5XCIpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgIGNvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfQkVMT1dfMTAwX1BPVkVSVFksXG4gICAgICApID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0JFTE9XXzEwMF9QT1ZFUlRZXSA6XG4gICAgICAgIG51bGw7XG4gICAgfVxuICAgIGlmIChpbmRpY2F0b3JOYW1lID09PSBcImhpZ2hTY2hvb2xcIikge1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXG4gICAgICAgICAgY29uc3RhbnRzLklTX0xPV19IU19FRFVDQVRJT05fTE9XX0hJR0hFUl9FRF9QUklPUklUSVpFRCxcbiAgICAgICkgP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19MT1dfSFNfRURVQ0FUSU9OX0xPV19ISUdIRVJfRURfUFJJT1JJVElaRURdIDpcbiAgICAgICAgbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERlZmluZSBlYWNoIGluZGljYXRvciBpbiB0aGUgc2lkZSBwYW5lbCB3aXRoIGNvbnN0YW50cyBmcm9tIGNvcHkgZmlsZSAoZm9yIGludGwpXG4gICAqXG4gICAqIEluZGljYXRvcnMgYXJlIGdyb3VwZWQgYnkgY2F0ZWdvcnlcbiAgICovXG5cbiAgLy8gQ2xpbWF0ZSBjYXRlZ29yeVxuICBjb25zdCBleHBBZ0xvc3M6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLkVYUF9BR19MT1NTKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uRVhQX0FHX0xPU1MsXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuRVhQX0FHUklDVUxUVVJFX0xPU1NfUEVSQ0VOVElMRSkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuRVhQX0FHUklDVUxUVVJFX0xPU1NfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9FWFBfQUdSX0xPU1NdID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9FWFBfQUdSX0xPU1NdIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IGV4cEJsZExvc3M6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLkVYUF9CTERfTE9TUyksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLkVYUF9CTERfTE9TUyxcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5FWFBfQlVJTERJTkdfTE9TU19QRVJDRU5USUxFKSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5FWFBfQlVJTERJTkdfTE9TU19QRVJDRU5USUxFXSA6XG4gICAgICBudWxsLFxuICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0VYUF9CTERfTE9TU10gP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0VYUF9CTERfTE9TU10gOlxuICAgICAgbnVsbCxcbiAgfTtcbiAgY29uc3QgZXhwUG9wTG9zczogaW5kaWNhdG9ySW5mbyA9IHtcbiAgICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuRVhQX1BPUF9MT1NTKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uRVhQX1BPUF9MT1NTLFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50aWxlXCIsXG4gICAgdmFsdWU6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnRzLkVYUF9QT1BVTEFUSU9OX0xPU1NfUEVSQ0VOVElMRSkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuRVhQX1BPUFVMQVRJT05fTE9TU19QRVJDRU5USUxFXSA6XG4gICAgICBudWxsLFxuICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0VYUF9QT1BfTE9TU10gP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0VYUF9QT1BfTE9TU10gOlxuICAgICAgbnVsbCxcbiAgfTtcbiAgY29uc3QgZmxvb2Rpbmc6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLkZMT09ESU5HKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uRkxPT0RJTkcsXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuRkxPT0RJTkdfUEVSQ0VOVElMRSkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuRkxPT0RJTkdfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZMT09ESU5HXSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GTE9PRElOR10gOlxuICAgICAgbnVsbCxcbiAgfTtcbiAgY29uc3Qgd2lsZGZpcmU6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLldJTERGSVJFKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uV0lMREZJUkUsXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuV0lMREZJUkVfUEVSQ0VOVElMRSkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuV0lMREZJUkVfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX1dJTERGSVJFXSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9XSUxERklSRV0gOlxuICAgICAgbnVsbCxcbiAgfTtcbiAgY29uc3QgbG93SW5jOiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5MT1dfSU5DT01FKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uTE9XX0lOQ09NRSxcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5QT1ZFUlRZX0JFTE9XXzIwMF9QRVJDRU5USUxFKSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5QT1ZFUlRZX0JFTE9XXzIwMF9QRVJDRU5USUxFXSA6XG4gICAgICBudWxsLFxuICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfRkVERVJBTF9QT1ZFUlRZX0xFVkVMXzIwMF0gP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRkVERVJBTF9QT1ZFUlRZX0xFVkVMXzIwMF0gOlxuICAgICAgbnVsbCxcbiAgICB0aHJlc2hvbGQ6IDY1LFxuICB9O1xuICAvLyBjb25zdCBoaWdoZXJFZDogaW5kaWNhdG9ySW5mbyA9IHtcbiAgLy8gICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuSElHSF9FRCksXG4gIC8vICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uSElHSF9FRCksXG4gIC8vICAgdHlwZTogJ3BlcmNlbnQnLFxuICAvLyAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5OT05fSElHSEVSX0VEX1BFUkNFTlRJTEUpID9cbiAgLy8gICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLk5PTl9ISUdIRVJfRURfUEVSQ0VOVElMRV0gOiBudWxsLFxuICAvLyAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfSElHSEVSX0VEX1BFUkNFTlRJTEVdID9cbiAgLy8gICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0hJR0hFUl9FRF9QRVJDRU5USUxFXSA6IG51bGwsXG4gIC8vICAgdGhyZXNob2xkOiA4MCxcbiAgLy8gfTtcblxuICAvLyBFbmVyZ3kgY2F0ZWdvcnlcbiAgY29uc3QgZW5lcmd5Q29zdDogaW5kaWNhdG9ySW5mbyA9IHtcbiAgICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuRU5FUkdZX0NPU1QpLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5FTkVSR1lfQ09TVCxcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5FTkVSR1lfUEVSQ0VOVElMRSkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuRU5FUkdZX1BFUkNFTlRJTEVdIDpcbiAgICAgIG51bGwsXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfRU5FUkdZX0JVUkRFTl0gP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0VORVJHWV9CVVJERU5dIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IHBtMjU6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLlBNXzJfNSksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLlBNXzJfNSxcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5QTTI1X1BFUkNFTlRJTEUpID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlBNMjVfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9QTTI1XSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfUE0yNV0gOlxuICAgICAgbnVsbCxcbiAgfTtcblxuICAvLyBIZWFsdGggY2F0ZWdvcnlcbiAgY29uc3QgYXN0aG1hOiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5BU1RITUEpLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5BU1RITUEsXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuQVNUSE1BX1BFUkNFTlRJTEUpID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkFTVEhNQV9QRVJDRU5USUxFXSA6XG4gICAgICBudWxsLFxuICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0FTVEhNQV0gP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0FTVEhNQV0gOlxuICAgICAgbnVsbCxcbiAgfTtcbiAgY29uc3QgZGlhYmV0ZXM6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLkRJQUJFVEVTKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uRElBQkVURVMsXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuRElBQkVURVNfUEVSQ0VOVElMRSkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuRElBQkVURVNfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9ESUFCRVRFU10gP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0RJQUJFVEVTXSA6XG4gICAgICBudWxsLFxuICB9O1xuICBjb25zdCBoZWFydERpc2Vhc2U6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLkhFQVJUX0RJU0VBU0UpLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5IRUFSVF9ESVNFQVNFLFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50aWxlXCIsXG4gICAgdmFsdWU6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnRzLkhFQVJUX1BFUkNFTlRJTEUpID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkhFQVJUX1BFUkNFTlRJTEVdIDpcbiAgICAgIG51bGwsXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfSEVBUlRfRElTRUFTRV0gP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0hFQVJUX0RJU0VBU0VdIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IGxpZmVFeHBlY3Q6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLkxJRkVfRVhQRUNUKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uTE9XX0xJRkVfRVhQRUNULFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50aWxlXCIsXG4gICAgdmFsdWU6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnRzLkxJRkVfUEVSQ0VOVElMRSkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuTElGRV9QRVJDRU5USUxFXSA6XG4gICAgICBudWxsLFxuICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0xPV19MSUZFX0VYUF0gP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0xPV19MSUZFX0VYUF0gOlxuICAgICAgbnVsbCxcbiAgfTtcblxuICAvLyBIb3VzaW5nIGNhdGVnb3J5XG4gIGNvbnN0IGhpc3RvcmljVW5kZXJpbnZlc3Q6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5ISVNUX1VOREVSSU5WRVNULFxuICAgICksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLkhJU1RfVU5ERVJJTlZFU1QsXG4gICAgKSxcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgY29uc3RhbnRzLkhJU1RPUklDX1VOREVSSU5WRVNUTUVOVF9FWENFRURfVEhSRVNILFxuICAgICkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSElTVE9SSUNfVU5ERVJJTlZFU1RNRU5UX0VYQ0VFRF9USFJFU0hdID09PVxuICAgICAgICBjb25zdGFudHMuSElTVE9SSUNfVU5ERVJJTlZFU1RNRU5UX1JBV19ZRVMgP1xuICAgICAgICB0cnVlIDpcbiAgICAgICAgZmFsc2UgOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6XG4gICAgICBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgIGNvbnN0YW50cy5ISVNUT1JJQ19VTkRFUklOVkVTVE1FTlRfRVhDRUVEX1RIUkVTSCxcbiAgICAgICkgJiZcbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkhJU1RPUklDX1VOREVSSU5WRVNUTUVOVF9FWENFRURfVEhSRVNIXSA9PT1cbiAgICAgICAgY29uc3RhbnRzLkhJU1RPUklDX1VOREVSSU5WRVNUTUVOVF9SQVdfWUVTID9cbiAgICAgICAgdHJ1ZSA6XG4gICAgICAgIGZhbHNlLFxuICB9O1xuICBjb25zdCBob3VzZUNvc3Q6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLkhPVVNFX0NPU1QpLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5IT1VTRV9DT1NULFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50aWxlXCIsXG4gICAgdmFsdWU6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXG4gICAgICAgIGNvbnN0YW50cy5IT1VTSU5HX0JVUkRFTl9QUk9QRVJUWV9QRVJDRU5USUxFLFxuICAgICkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSE9VU0lOR19CVVJERU5fUFJPUEVSVFlfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9IT1VTRV9CVVJERU5dID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9IT1VTRV9CVVJERU5dIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IGxhY2tHcmVlblNwYWNlOiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuTEFDS19HUkVFTl9TUEFDRSxcbiAgICApLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5MQUNLX0dSRUVOX1NQQUNFLFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50aWxlXCIsXG4gICAgdmFsdWU6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnRzLklNUEVSVklPVVNfUEVSQ0VOVElMRSkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSU1QRVJWSU9VU19QRVJDRU5USUxFXSA6XG4gICAgICBudWxsLFxuICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfSU1QRVJWSU9VU10gP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfSU1QRVJWSU9VU10gOlxuICAgICAgbnVsbCxcbiAgfTtcbiAgY29uc3QgbGFja1BsdW1iaW5nOiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5MQUNLX1BMVU1CSU5HKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uTEFDS19QTFVNQklORyxcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5LSVRDSEVOX1BMVU1CX1BFUkNFTlRJTEUpID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLktJVENIRU5fUExVTUJfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0tJVENIRU5fUExVTUJdID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0tJVENIRU5fUExVTUJdIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IGxlYWRQYWludDogaW5kaWNhdG9ySW5mbyA9IHtcbiAgICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuTEVBRF9QQUlOVCksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLkxFQURfUEFJTlQsXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuTEVBRF9QQUlOVF9QRVJDRU5USUxFKSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5MRUFEX1BBSU5UX1BFUkNFTlRJTEVdIDpcbiAgICAgIG51bGwsXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW1xuICAgICAgICBjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0xFQURfUEFJTlRfQU5EX01FRElBTl9IT01FX1ZBTFxuICAgIF0gP1xuICAgICAgcHJvcGVydGllc1tcbiAgICAgICAgICBjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0xFQURfUEFJTlRfQU5EX01FRElBTl9IT01FX1ZBTFxuICAgICAgXSA6XG4gICAgICBudWxsLFxuICB9O1xuXG4gIC8vIFBvbGx1dGlvbiBjYXRlZ2VvcnlcbiAgY29uc3QgYWJhbmRvbk1pbmVzOiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5BQkFORE9OX01JTkVTKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uQUJBTkRPTl9NSU5FUyxcbiAgICApLFxuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFxuICAgICAgICBjb25zdGFudHMuQUJBTkRPTl9MQU5EX01JTkVTX0VYQ0VFRFNfVEhSRVNILFxuICAgICkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuQUJBTkRPTl9MQU5EX01JTkVTX0VYQ0VFRFNfVEhSRVNIXSA6XG4gICAgICBudWxsLFxuICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgY29uc3RhbnRzLkFCQU5ET05fTEFORF9NSU5FU19FWENFRURTX1RIUkVTSCxcbiAgICApID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkFCQU5ET05fTEFORF9NSU5FU19FWENFRURTX1RIUkVTSF0gOlxuICAgICAgbnVsbCxcbiAgfTtcbiAgY29uc3QgZm9ybWVyRGVmU2l0ZXM6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5GT1JNRVJfREVGX1NJVEVTLFxuICAgICksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLkZPUk1FUl9ERUZfU0lURVMsXG4gICAgKSxcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAvLyBkb3VibGUgZXF1YWxpdHkgaXMgdXNlZCBpbiB0aGlzIGluc3RhbmNlIGFzIGl0IHNlZW1zIHRoYXQgRlVEU19SQVcgY291bGQgYmUgXCIxXCIgb3IgMSBmcm9tIHRoZSBCRVxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5GT1JNRVJfREVGX1NJVEVTX1JBV19WQUxVRSkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuRk9STUVSX0RFRl9TSVRFU19SQVdfVkFMVUVdID09XG4gICAgICAgIGNvbnN0YW50cy5GVURTX1JBV19ZRVMgP1xuICAgICAgICB0cnVlIDpcbiAgICAgICAgZmFsc2UgOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXG4gICAgICAgIGNvbnN0YW50cy5GT1JNRVJfREVGX1NJVEVTX0VYQ0VFRFNfVEhSRVNILFxuICAgICkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuRk9STUVSX0RFRl9TSVRFU19FWENFRURTX1RIUkVTSF0gOlxuICAgICAgbnVsbCxcbiAgfTtcbiAgY29uc3QgcHJveEhhejogaW5kaWNhdG9ySW5mbyA9IHtcbiAgICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuUFJPWF9IQVopLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5QUk9YX0hBWixcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5QUk9YSU1JVFlfVFNERl9TSVRFU19QRVJDRU5USUxFKSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5QUk9YSU1JVFlfVFNERl9TSVRFU19QRVJDRU5USUxFXSA6XG4gICAgICBudWxsLFxuICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0hBWkFSRF9XQVNURV0gP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0hBWkFSRF9XQVNURV0gOlxuICAgICAgbnVsbCxcbiAgfTtcbiAgY29uc3QgcHJveFJNUDogaW5kaWNhdG9ySW5mbyA9IHtcbiAgICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuUFJPWF9STVApLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5QUk9YX1JNUCxcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5QUk9YSU1JVFlfUk1QX1NJVEVTX1BFUkNFTlRJTEUpID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlBST1hJTUlUWV9STVBfU0lURVNfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9STVBdID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9STVBdIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IHByb3hOUEw6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLlBST1hfTlBMKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uUFJPWF9OUEwsXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuUFJPWElNSVRZX05QTF9TSVRFU19QRVJDRU5USUxFKSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5QUk9YSU1JVFlfTlBMX1NJVEVTX1BFUkNFTlRJTEVdIDpcbiAgICAgIG51bGwsXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfU1VQRVJGVU5EXSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfU1VQRVJGVU5EXSA6XG4gICAgICBudWxsLFxuICB9O1xuXG4gIC8vIFRyYW5zcG90YXRpb24gY2F0ZWdvcnlcbiAgY29uc3QgZGllc2VsUGFydE1hdHRlcjogaW5kaWNhdG9ySW5mbyA9IHtcbiAgICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLkRJRVNFTF9QQVJUSUNVTEFURV9NQVRURVIsXG4gICAgKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uRElFU0VMX1BBUlRJQ1VMQVRFX01BVFRFUixcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5ESUVTRUxfTUFUVEVSX1BFUkNFTlRJTEUpID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkRJRVNFTF9NQVRURVJfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9ESUVTRUxfUE1dID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9ESUVTRUxfUE1dIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IGJhcnJpZXJUcmFuc3BvcnQ6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLkJBUlJJRVJfVFJBTlMpLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5CQVJSSUVSX1RSQU5TLFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50aWxlXCIsXG4gICAgdmFsdWU6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnRzLlRSQVZFTF9ESVNBRFZfUEVSQ0VOVElMRSkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuVFJBVkVMX0RJU0FEVl9QRVJDRU5USUxFXSA6XG4gICAgICBudWxsLFxuICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfVFJBVkVMX0RJU0FEVl0gP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfVFJBVkVMX0RJU0FEVl0gOlxuICAgICAgbnVsbCxcbiAgfTtcbiAgY29uc3QgdHJhZmZpY1ZvbHVtZTogaW5kaWNhdG9ySW5mbyA9IHtcbiAgICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLlRSQUZGSUNfVk9MVU1FLFxuICAgICksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLlRSQUZGSUNfVk9MVU1FLFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50aWxlXCIsXG4gICAgdmFsdWU6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnRzLlRSQUZGSUNfUEVSQ0VOVElMRSkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuVFJBRkZJQ19QRVJDRU5USUxFXSA6XG4gICAgICBudWxsLFxuICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX1RSQUZGSUNfUFJPWF0gP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX1RSQUZGSUNfUFJPWF0gOlxuICAgICAgbnVsbCxcbiAgfTtcblxuICAvLyBXYXRlciBjYXRlZ29yeVxuICBjb25zdCBsZWFreVRhbmtzOiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5MRUFLWV9UQU5LUyksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLkxFQUtZX1RBTktTLFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50aWxlXCIsXG4gICAgdmFsdWU6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnRzLkxFQUtZX1VOREVSX1BFUkNFTlRJTEUpID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkxFQUtZX1VOREVSX1BFUkNFTlRJTEVdIDpcbiAgICAgIG51bGwsXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9MRUFLWV9VTkRFUl0gP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfTEVBS1lfVU5ERVJdIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IHdhc3RlV2F0ZXI6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLldBU1RFX1dBVEVSKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uV0FTVEVfV0FURVIsXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuV0FTVEVXQVRFUl9QRVJDRU5USUxFKSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5XQVNURVdBVEVSX1BFUkNFTlRJTEVdIDpcbiAgICAgIG51bGwsXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfV0FTVEVXQVRFUl0gP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX1dBU1RFV0FURVJdIDpcbiAgICAgIG51bGwsXG4gIH07XG5cbiAgLy8gV29ya2ZvcmNlIGRldiBjYXRlZ29yeVxuICBjb25zdCBsaW5nSXNvOiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5MSU5HX0lTTyksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLkxJTkdfSVNPLFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50aWxlXCIsXG4gICAgdmFsdWU6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXG4gICAgICAgIGNvbnN0YW50cy5MSU5HVUlTVElDX0lTT0xBVElPTl9QUk9QRVJUWV9QRVJDRU5USUxFLFxuICAgICkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuTElOR1VJU1RJQ19JU09MQVRJT05fUFJPUEVSVFlfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9MSU5HVUlTSVRJQ19JU09dID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9MSU5HVUlTSVRJQ19JU09dIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IGxvd01lZEluYzogaW5kaWNhdG9ySW5mbyA9IHtcbiAgICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuTE9XX01FRF9JTkMpLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5MT1dfTUVEX0lOQ09NRSxcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBnZXRXb3JrRm9yY2VJbmRpY2F0b3JWYWx1ZShcImxvd01lZEluY1wiKSxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IGdldFdvcmtGb3JjZUluZGljYXRvcklzRGlzYWR2KFwibG93TWVkSW5jXCIpLFxuICB9O1xuICBjb25zdCB1bmVtcGxveTogaW5kaWNhdG9ySW5mbyA9IHtcbiAgICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuVU5FTVBMT1kpLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5VTkVNUExPWSxcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBnZXRXb3JrRm9yY2VJbmRpY2F0b3JWYWx1ZShcInVuZW1wbG95XCIpLFxuICAgIGlzRGlzYWR2YWd0YWdlZDogZ2V0V29ya0ZvcmNlSW5kaWNhdG9ySXNEaXNhZHYoXCJ1bmVtcGxveVwiKSxcbiAgfTtcbiAgY29uc3QgcG92ZXJ0eTogaW5kaWNhdG9ySW5mbyA9IHtcbiAgICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuUE9WRVJUWSksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLlBPVkVSVFksXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogZ2V0V29ya0ZvcmNlSW5kaWNhdG9yVmFsdWUoXCJwb3ZlcnR5XCIpLFxuICAgIGlzRGlzYWR2YWd0YWdlZDogZ2V0V29ya0ZvcmNlSW5kaWNhdG9ySXNEaXNhZHYoXCJwb3ZlcnR5XCIpLFxuICB9O1xuICBjb25zdCBoaWdoU2Nob29sOiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5ISUdIX1NDTCksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLkhJR0hfU0tMLFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50XCIsXG4gICAgdmFsdWU6IGdldFdvcmtGb3JjZUluZGljYXRvclZhbHVlKFwiaGlnaFNjaG9vbFwiKSxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IGdldFdvcmtGb3JjZUluZGljYXRvcklzRGlzYWR2KFwiaGlnaFNjaG9vbFwiKSxcbiAgICB0aHJlc2hvbGQ6IDEwLFxuICB9O1xuXG4gIC8qKlxuICAgKiBBZ2dyZWdhdGUgaW5kaWNhdG9ycyBiYXNlZCBvbiBjYXRlZ29yaWVzXG4gICAqXG4gICAqIFRoZSBpbmRpY2F0b3JzIHByb3BlcnR5IG11c3QgYmUgYW4gYXJyYXkgd2l0aCBsYXN0IHR3byBlbGVtZW50cyBiZWluZyB0aGVcbiAgICogc29jaW9lY29ub21pYyBidXJkZW5zLlxuICAgKi9cbiAgbGV0IGNhdGVnb3JpZXM6IElDYXRlZ29yeVtdID0gW1xuICAgIHtcbiAgICAgIGlkOiBcImNsaW1hdGUtY2hhbmdlXCIsXG4gICAgICB0aXRsZVRleHQ6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9DQVRFR09SWS5DTElNQVRFKSxcbiAgICAgIGluZGljYXRvcnM6IFtleHBBZ0xvc3MsIGV4cEJsZExvc3MsIGV4cFBvcExvc3MsIGZsb29kaW5nLCB3aWxkZmlyZV0sXG4gICAgICBzb2Npb0VjSW5kaWNhdG9yczogW2xvd0luY10sXG4gICAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0NMSU1BVEVfRkFDVE9SX0RJU0FEVkFOVEFHRURdID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfQ0xJTUFURV9GQUNUT1JfRElTQURWQU5UQUdFRF0gOlxuICAgICAgICBudWxsLFxuICAgICAgaXNFeGNlZWQxTW9yZUJ1cmRlbjogcHJvcGVydGllc1tcbiAgICAgICAgICBjb25zdGFudHMuSVNfQ0xJTUFURV9FWENFRURfT05FX09SX01PUkVfSU5ESUNBVE9SU1xuICAgICAgXSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0NMSU1BVEVfRVhDRUVEX09ORV9PUl9NT1JFX0lORElDQVRPUlNdIDpcbiAgICAgICAgbnVsbCxcbiAgICAgIGlzRXhjZWVkQm90aFNvY2lvQnVyZGVuczogcHJvcGVydGllc1tcbiAgICAgICAgICBjb25zdGFudHMuSVNfRVhDRUVEX0JPVEhfU09DSU9fSU5ESUNBVE9SU1xuICAgICAgXSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRF9CT1RIX1NPQ0lPX0lORElDQVRPUlNdIDpcbiAgICAgICAgbnVsbCxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBcImNsZWFuLWVuZXJneVwiLFxuICAgICAgdGl0bGVUZXh0OiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfQ0FURUdPUlkuQ0xFQU5fRU5FUkdZLFxuICAgICAgKSxcbiAgICAgIGluZGljYXRvcnM6IFtlbmVyZ3lDb3N0LCBwbTI1XSxcbiAgICAgIHNvY2lvRWNJbmRpY2F0b3JzOiBbbG93SW5jXSxcbiAgICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfRU5FUkdZX0ZBQ1RPUl9ESVNBRFZBTlRBR0VEXSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VORVJHWV9GQUNUT1JfRElTQURWQU5UQUdFRF0gOlxuICAgICAgICBudWxsLFxuICAgICAgaXNFeGNlZWQxTW9yZUJ1cmRlbjogcHJvcGVydGllc1tcbiAgICAgICAgICBjb25zdGFudHMuSVNfRU5FUkdZX0VYQ0VFRF9PTkVfT1JfTU9SRV9JTkRJQ0FUT1JTXG4gICAgICBdID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRU5FUkdZX0VYQ0VFRF9PTkVfT1JfTU9SRV9JTkRJQ0FUT1JTXSA6XG4gICAgICAgIG51bGwsXG4gICAgICBpc0V4Y2VlZEJvdGhTb2Npb0J1cmRlbnM6IHByb3BlcnRpZXNbXG4gICAgICAgICAgY29uc3RhbnRzLklTX0VYQ0VFRF9CT1RIX1NPQ0lPX0lORElDQVRPUlNcbiAgICAgIF0gP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURfQk9USF9TT0NJT19JTkRJQ0FUT1JTXSA6XG4gICAgICAgIG51bGwsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogXCJoZWFsdGgtYnVyZGVuc1wiLFxuICAgICAgdGl0bGVUZXh0OiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfQ0FURUdPUlkuSEVBTFRIX0JVUkRFTixcbiAgICAgICksXG4gICAgICBpbmRpY2F0b3JzOiBbYXN0aG1hLCBkaWFiZXRlcywgaGVhcnREaXNlYXNlLCBsaWZlRXhwZWN0XSxcbiAgICAgIHNvY2lvRWNJbmRpY2F0b3JzOiBbbG93SW5jXSxcbiAgICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfSEVBTFRIX0ZBQ1RPUl9ESVNBRFZBTlRBR0VEXSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0hFQUxUSF9GQUNUT1JfRElTQURWQU5UQUdFRF0gOlxuICAgICAgICBudWxsLFxuICAgICAgaXNFeGNlZWQxTW9yZUJ1cmRlbjogcHJvcGVydGllc1tcbiAgICAgICAgICBjb25zdGFudHMuSVNfSEVBTFRIX0VYQ0VFRF9PTkVfT1JfTU9SRV9JTkRJQ0FUT1JTXG4gICAgICBdID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfSEVBTFRIX0VYQ0VFRF9PTkVfT1JfTU9SRV9JTkRJQ0FUT1JTXSA6XG4gICAgICAgIG51bGwsXG4gICAgICBpc0V4Y2VlZEJvdGhTb2Npb0J1cmRlbnM6IHByb3BlcnRpZXNbXG4gICAgICAgICAgY29uc3RhbnRzLklTX0VYQ0VFRF9CT1RIX1NPQ0lPX0lORElDQVRPUlNcbiAgICAgIF0gP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURfQk9USF9TT0NJT19JTkRJQ0FUT1JTXSA6XG4gICAgICAgIG51bGwsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogXCJzdXN0YWluLWhvdXNlXCIsXG4gICAgICB0aXRsZVRleHQ6IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9DQVRFR09SWS5TVVNUQUlOX0hPVVNFLFxuICAgICAgKSxcbiAgICAgIGluZGljYXRvcnM6IFtcbiAgICAgICAgaGlzdG9yaWNVbmRlcmludmVzdCxcbiAgICAgICAgaG91c2VDb3N0LFxuICAgICAgICBsYWNrR3JlZW5TcGFjZSxcbiAgICAgICAgbGFja1BsdW1iaW5nLFxuICAgICAgICBsZWFkUGFpbnQsXG4gICAgICBdLFxuICAgICAgc29jaW9FY0luZGljYXRvcnM6IFtsb3dJbmNdLFxuICAgICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19IT1VTSU5HX0ZBQ1RPUl9ESVNBRFZBTlRBR0VEXSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0hPVVNJTkdfRkFDVE9SX0RJU0FEVkFOVEFHRURdIDpcbiAgICAgICAgbnVsbCxcbiAgICAgIGlzRXhjZWVkMU1vcmVCdXJkZW46IHByb3BlcnRpZXNbXG4gICAgICAgICAgY29uc3RhbnRzLklTX0hPVVNJTkdfRVhDRUVEX09ORV9PUl9NT1JFX0lORElDQVRPUlNcbiAgICAgIF0gP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19IT1VTSU5HX0VYQ0VFRF9PTkVfT1JfTU9SRV9JTkRJQ0FUT1JTXSA6XG4gICAgICAgIG51bGwsXG4gICAgICBpc0V4Y2VlZEJvdGhTb2Npb0J1cmRlbnM6IHByb3BlcnRpZXNbXG4gICAgICAgICAgY29uc3RhbnRzLklTX0VYQ0VFRF9CT1RIX1NPQ0lPX0lORElDQVRPUlNcbiAgICAgIF0gP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURfQk9USF9TT0NJT19JTkRJQ0FUT1JTXSA6XG4gICAgICAgIG51bGwsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogXCJsZWctcG9sbHV0ZVwiLFxuICAgICAgdGl0bGVUZXh0OiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfQ0FURUdPUlkuTEVHX1BPTExVVEUsXG4gICAgICApLFxuICAgICAgaW5kaWNhdG9yczogW2FiYW5kb25NaW5lcywgZm9ybWVyRGVmU2l0ZXMsIHByb3hIYXosIHByb3hSTVAsIHByb3hOUExdLFxuICAgICAgc29jaW9FY0luZGljYXRvcnM6IFtsb3dJbmNdLFxuICAgICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19QT0xMVVRJT05fRkFDVE9SX0RJU0FEVkFOVEFHRURdID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfUE9MTFVUSU9OX0ZBQ1RPUl9ESVNBRFZBTlRBR0VEXSA6XG4gICAgICAgIG51bGwsXG4gICAgICBpc0V4Y2VlZDFNb3JlQnVyZGVuOiBwcm9wZXJ0aWVzW1xuICAgICAgICAgIGNvbnN0YW50cy5JU19QT0xMVVRJT05fRVhDRUVEX09ORV9PUl9NT1JFX0lORElDQVRPUlNcbiAgICAgIF0gP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19QT0xMVVRJT05fRVhDRUVEX09ORV9PUl9NT1JFX0lORElDQVRPUlNdIDpcbiAgICAgICAgbnVsbCxcbiAgICAgIGlzRXhjZWVkQm90aFNvY2lvQnVyZGVuczogcHJvcGVydGllc1tcbiAgICAgICAgICBjb25zdGFudHMuSVNfRVhDRUVEX0JPVEhfU09DSU9fSU5ESUNBVE9SU1xuICAgICAgXSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRF9CT1RIX1NPQ0lPX0lORElDQVRPUlNdIDpcbiAgICAgICAgbnVsbCxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBcImNsZWFuLXRyYW5zcG9ydFwiLFxuICAgICAgdGl0bGVUZXh0OiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfQ0FURUdPUlkuQ0xFQU5fVFJBTlNQT1JULFxuICAgICAgKSxcbiAgICAgIGluZGljYXRvcnM6IFtkaWVzZWxQYXJ0TWF0dGVyLCBiYXJyaWVyVHJhbnNwb3J0LCB0cmFmZmljVm9sdW1lXSxcbiAgICAgIHNvY2lvRWNJbmRpY2F0b3JzOiBbbG93SW5jXSxcbiAgICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfVFJBTlNQT1JUX0ZBQ1RPUl9ESVNBRFZBTlRBR0VEXSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX1RSQU5TUE9SVF9GQUNUT1JfRElTQURWQU5UQUdFRF0gOlxuICAgICAgICBudWxsLFxuICAgICAgaXNFeGNlZWQxTW9yZUJ1cmRlbjogcHJvcGVydGllc1tcbiAgICAgICAgICBjb25zdGFudHMuSVNfVFJBTlNQT1JUX0VYQ0VFRF9PTkVfT1JfTU9SRV9JTkRJQ0FUT1JTXG4gICAgICBdID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfVFJBTlNQT1JUX0VYQ0VFRF9PTkVfT1JfTU9SRV9JTkRJQ0FUT1JTXSA6XG4gICAgICAgIG51bGwsXG4gICAgICBpc0V4Y2VlZEJvdGhTb2Npb0J1cmRlbnM6IHByb3BlcnRpZXNbXG4gICAgICAgICAgY29uc3RhbnRzLklTX0VYQ0VFRF9CT1RIX1NPQ0lPX0lORElDQVRPUlNcbiAgICAgIF0gP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURfQk9USF9TT0NJT19JTkRJQ0FUT1JTXSA6XG4gICAgICAgIG51bGwsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogXCJjbGVhbi13YXRlclwiLFxuICAgICAgdGl0bGVUZXh0OiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfQ0FURUdPUlkuQ0xFQU5fV0FURVIsXG4gICAgICApLFxuICAgICAgaW5kaWNhdG9yczogW2xlYWt5VGFua3MsIHdhc3RlV2F0ZXJdLFxuICAgICAgc29jaW9FY0luZGljYXRvcnM6IFtsb3dJbmNdLFxuICAgICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19XQVRFUl9GQUNUT1JfRElTQURWQU5UQUdFRF0gP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19XQVRFUl9GQUNUT1JfRElTQURWQU5UQUdFRF0gOlxuICAgICAgICBudWxsLFxuICAgICAgaXNFeGNlZWQxTW9yZUJ1cmRlbjogcHJvcGVydGllc1tcbiAgICAgICAgICBjb25zdGFudHMuSVNfV0FURVJfRVhDRUVEX09ORV9PUl9NT1JFX0lORElDQVRPUlNcbiAgICAgIF0gP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19XQVRFUl9FWENFRURfT05FX09SX01PUkVfSU5ESUNBVE9SU10gOlxuICAgICAgICBudWxsLFxuICAgICAgaXNFeGNlZWRCb3RoU29jaW9CdXJkZW5zOiBwcm9wZXJ0aWVzW1xuICAgICAgICAgIGNvbnN0YW50cy5JU19FWENFRURfQk9USF9TT0NJT19JTkRJQ0FUT1JTXG4gICAgICBdID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEX0JPVEhfU09DSU9fSU5ESUNBVE9SU10gOlxuICAgICAgICBudWxsLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IFwid29yay1kZXZcIixcbiAgICAgIHRpdGxlVGV4dDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0NBVEVHT1JZLldPUktfREVWKSxcbiAgICAgIGluZGljYXRvcnM6IFtsaW5nSXNvLCBsb3dNZWRJbmMsIHBvdmVydHksIHVuZW1wbG95XSxcbiAgICAgIHNvY2lvRWNJbmRpY2F0b3JzOiBbaGlnaFNjaG9vbF0sXG4gICAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX1dPUktGT1JDRV9GQUNUT1JfRElTQURWQU5UQUdFRF0gP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19XT1JLRk9SQ0VfRkFDVE9SX0RJU0FEVkFOVEFHRURdIDpcbiAgICAgICAgbnVsbCxcbiAgICAgIGlzRXhjZWVkMU1vcmVCdXJkZW46IHByb3BlcnRpZXNbXG4gICAgICAgICAgY29uc3RhbnRzLklTX1dPUktGT1JDRV9FWENFRURfT05FX09SX01PUkVfSU5ESUNBVE9SU1xuICAgICAgXSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX1dPUktGT1JDRV9FWENFRURfT05FX09SX01PUkVfSU5ESUNBVE9SU10gOlxuICAgICAgICBudWxsLFxuICAgICAgaXNFeGNlZWRCb3RoU29jaW9CdXJkZW5zOiBwcm9wZXJ0aWVzW1xuICAgICAgICAgIGNvbnN0YW50cy5JU19XT1JLRk9SQ0VfRVhDRUVEX0JPVEhfU09DSU9fSU5ESUNBVE9SU1xuICAgICAgXSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX1dPUktGT1JDRV9FWENFRURfQk9USF9TT0NJT19JTkRJQ0FUT1JTXSA6XG4gICAgICAgIG51bGwsXG4gICAgfSxcbiAgXTtcblxuICAvKipcbiAgICogTW9kaWZ5IHRoZSBjYXRlZ29yeSBhcnJheSBkZXBlbmRpbmcgb24gdGhlIHNpZGVQYW5lbFN0YXRlIGZpZWxkLiBUaGlzIGZpZWxkIGNvbWVzIGZyb20gdGhlIGJhY2tlbmRcbiAgICogYW5kIGlzIGNhbGxlZCBVSV9FWFAuXG4gICAqXG4gICAqIFRoaXMgc2lkZVBhbmVsU3RhdGUgaGFzIDMgdmFsdWVzOyBuYW1lbHksIE5hdGlvbiwgUHVlcnRvIFJpY28gYW5kIElzbGFuZCBBcmVhcy5cbiAgICovXG4gIGlmIChzaWRlUGFuZWxTdGF0ZSA9PT0gY29uc3RhbnRzLlNJREVfUEFORUxfU1RBVEVfVkFMVUVTLlBVRVJUT19SSUNPKSB7XG4gICAgLy8gUmUtZGVmaW5lIHdoaWNoIGJ1cmRlbnMgc2hvdyB1cCBmb3IgZWFjaCBjYXRlZ29yeTpcblxuICAgIHNldENhdGVnb3J5SW5kaWNhdG9ycygnY2xpbWF0ZS1jaGFuZ2UnLCBbZmxvb2RpbmddKTtcbiAgICBzZXRDYXRlZ29yeUluZGljYXRvcnMoJ2NsZWFuLWVuZXJneScsIFtlbmVyZ3lDb3N0XSk7XG4gICAgc2V0Q2F0ZWdvcnlJbmRpY2F0b3JzKCdzdXN0YWluLWhvdXNlJywgW2hpc3RvcmljVW5kZXJpbnZlc3QsIGhvdXNlQ29zdCwgbGFja1BsdW1iaW5nLCBsZWFkUGFpbnRdKTtcbiAgICBzZXRDYXRlZ29yeUluZGljYXRvcnMoJ2xlZy1wb2xsdXRlJywgW3Byb3hIYXosIHByb3hSTVAsIHByb3hOUExdKTtcbiAgICBzZXRDYXRlZ29yeUluZGljYXRvcnMoJ2NsZWFuLXRyYW5zcG9ydCcsIFtkaWVzZWxQYXJ0TWF0dGVyLCB0cmFmZmljVm9sdW1lXSk7XG4gICAgc2V0Q2F0ZWdvcnlJbmRpY2F0b3JzKCd3b3JrLWRldicsIFtsb3dNZWRJbmMsIHBvdmVydHksIHVuZW1wbG95XSk7XG4gIH1cblxuICBpZiAoc2lkZVBhbmVsU3RhdGUgPT09IGNvbnN0YW50cy5TSURFX1BBTkVMX1NUQVRFX1ZBTFVFUy5JU0xBTkRfQVJFQVMpIHtcbiAgICAvLyBGb3IgSXNsYW5kIEFyZWFzIC0gb25seSBzaG93IHdvcmtmb3JjZSBkZXYgY2F0ZWdvcnlcbiAgICBjYXRlZ29yaWVzID0gY2F0ZWdvcmllcy5maWx0ZXIoKGNhdGVnb3J5KSA9PiBjYXRlZ29yeS5pZCA9PT0gXCJ3b3JrLWRldlwiKTtcbiAgICAvLyBGb3IgSXNsYW5kIEFyZWFzIC0gcmVtb3ZlIHRoZSBsaW5ndWlzdGljIElzb2xhdGlvblxuICAgIGNhdGVnb3JpZXNbMF0uaW5kaWNhdG9ycyA9IFtsb3dNZWRJbmMsIHVuZW1wbG95LCBwb3ZlcnR5XTtcbiAgfVxuXG4gIGNvbnN0IGlzVGVycml0b3J5ID0gY29uc3RhbnRzLlRJTEVTX0lTTEFORF9BUkVBX0ZJUFNfQ09ERVMuc29tZSgoY29kZSkgPT4ge1xuICAgIHJldHVybiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5HRU9JRF9QUk9QRVJUWV0uc3RhcnRzV2l0aChjb2RlKTtcbiAgfSk7XG5cbiAgY29uc3QgaXNHcmFuZGZhdGhlcmVkID0gcHJvcGVydGllc1tjb25zdGFudHMuSVNfR1JBTkRGQVRIRVJFRF07XG4gIC8vIFNob3cgRG9udXQgaW5mb3JtYXRpb24gIWlzR3JhbmRmYXRoZXJlZFxuICBjb25zdCBzaG93RG9udXRDb3B5ID0gIWlzR3JhbmRmYXRoZXJlZCAmJlxuICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkFESkFDRU5DWV9FWENFRURTX1RIUkVTSF0gJiZcbiAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5UT1RBTF9OVU1CRVJfT0ZfRElTQURWQU5UQUdFX0lORElDQVRPUlNdID09PSAwO1xuICBjb25zdCBzaG93SXNsYW5kQ29weSA9IGlzVGVycml0b3J5ICYmICFzaG93RG9udXRDb3B5O1xuXG4gIC8vIEZvciB0ZXJyaXRvcmllcyB3ZSB1c2UgdGhlIHBvdmVydHkgcGVyY2VudGlsZSBmcm9tIHRoZSBjZW5zdXMgZGVjZW5uaWFsIGRhdGFcbiAgY29uc3QgcG92ZXJ5UGVyY2VudGlsZSA9IGlzVGVycml0b3J5ID9cbiAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5DRU5TVVNfREVDRU5OSUFMX1BPVkVSVFlfTEVTU19USEFOXzIwMF9GUExfUEVSQ0VOVElMRV0gOlxuICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlBPVkVSVFlfQkVMT1dfMjAwX1BFUkNFTlRJTEVdID4gMCA/XG4gICAgcHJvcGVydGllc1tjb25zdGFudHMuUE9WRVJUWV9CRUxPV18yMDBfUEVSQ0VOVElMRV0gOlxuICAgIG51bGw7XG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIEFjY29yaWRpb25JdGVtcyBieSBtYXBwaW5nIG92ZXIgdGhlIGNhdGVnb3JpZXMgYXJyYXkuIEluIHRoaXMgYXJyYXkgd2UgZGVmaW5lIHRoZVxuICAgKiB2YXJpb3VzIGluZGljYXRvcnMgZm9yIGEgc3BlY2lmaWMgY2F0ZWdvcnkuIFRoaXMgaXMgYW4gYXJyYXkgd2hpY2ggdGhlbiBtYXBzIG92ZXIgdGhlXG4gICAqIDxJbmRpY2F0b3IgLz4gY29tcG9uZW50IHRvIHJlbmRlciB0aGUgYWN0dWFsIEluZGljYXRvclxuICAgKi9cbiAgY29uc3QgY2F0ZWdvcnlJdGVtcyA9IGNhdGVnb3JpZXMubWFwKChjYXRlZ29yeSkgPT4gKHtcbiAgICBpZDogY2F0ZWdvcnkuaWQsXG5cbiAgICAvKlxuICAgIEFzIG9mIHRydXNzd29ya3MgMy4wLjAsIHRoZXJlIHdlcmUgc29tZSBicmVha2luZyBjaGFuZ2VzLiBUaGlzIG5ldyBwcm9wIG9mIGhlYWRpbmdMZXZlbFxuICAgIGlzIHJlcXVpcmVkLCBob3dldmVyLCB0aGUgdGl0bGUgcHJvcCBpcyBhbHJlYWR5IGRlZmluaW5nIHRoZSBjYXRlZ29yeSBzdHlsaW5nLCBzbyB0aGlzXG4gICAgaXMgcGxhY2VkIGhlcmUgdG8gc2F0aXNmeSB0aGUgcmVxdWlyZW1lbnQgb2YgdGhlIEFjY29yZGlvbkl0ZW1zIEFQSSwgaG93ZXZlciBpdCdzIG5vdFxuICAgIGJlaW5nIHVzZWQuXG5cbiAgICBDYXN0aW5nICdoNCcgYXMgY29uc3QgYmVjYXVzZSBpdCBuZWVkcyB0byBiZSBhIGhlYWRpbmcgdHlwZSBhcyBzcGVjaWZpZWQgSGVhZGluZ0xldmVsLlxuICAgICovXG4gICAgaGVhZGluZ0xldmVsOiBcImg0XCIgYXMgY29uc3QsXG5cbiAgICB0aXRsZTogKFxuICAgICAgPENhdGVnb3J5XG4gICAgICAgIG5hbWU9e2NhdGVnb3J5LnRpdGxlVGV4dH1cbiAgICAgICAgaXNEaXNhZHZhbnRhZ2VkPXtjYXRlZ29yeS5pc0Rpc2FkdmFndGFnZWR9XG4gICAgICAvPlxuICAgICksXG4gICAgY29udGVudDogKFxuICAgICAgPD5cbiAgICAgICAgey8qIEluZGljYXRvcnMgLSBmaWx0ZXJzIHRoZW4gbWFwICovfVxuICAgICAgICB7Y2F0ZWdvcnkuaW5kaWNhdG9yc1xuICAgICAgICAgICAgLm1hcCgoaW5kaWNhdG9yOiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIDxJbmRpY2F0b3Iga2V5PXtgaW5kJHtpbmRleH1gfSBpbmRpY2F0b3I9e2luZGljYXRvcn0gLz47XG4gICAgICAgICAgICB9KX1cblxuICAgICAgICB7LyogQU5EICovfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNhdGVnb3J5U3BhY2VyfT5cbiAgICAgICAgICB7RVhQTE9SRV9DT1BZLlNJREVfUEFORUxfU1BBQ0VSUy5BTkR9XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIHsvKiBzb2Npb2Vjb25vbWljIGluZGljYXRvcnMgKi99XG4gICAgICAgIHtjYXRlZ29yeS5zb2Npb0VjSW5kaWNhdG9ycy5tYXAoKGluZGljYXRvcjogYW55LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxJbmRpY2F0b3JcbiAgICAgICAgICAgICAga2V5PXtgaW5kJHtpbmRleH1gfVxuICAgICAgICAgICAgICBpbmRpY2F0b3I9e2luZGljYXRvcn1cbiAgICAgICAgICAgICAgaXNJbXB1dGU9e1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklNUFVURV9GTEFHXSA9PT0gXCIwXCIgPyBmYWxzZSA6IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwb3B1bGF0aW9uPXtwb3B1bGF0aW9ufVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApO1xuICAgICAgICB9KX1cbiAgICAgIDwvPlxuICAgICksXG4gICAgZXhwYW5kZWQ6IGZhbHNlLFxuICB9KSk7XG5cbiAgcmV0dXJuIChcbiAgICA8YXNpZGUgY2xhc3NOYW1lPXtzdHlsZXMuYXJlYURldGFpbENvbnRhaW5lcn0gZGF0YS1jeT17XCJhc2lkZVwifT5cbiAgICAgIHsvKiBUcmFjdCBJbmZvICovfVxuICAgICAgPFRyYWN0SW5mb1xuICAgICAgICBibG9ja0dyb3VwPXtibG9ja0dyb3VwfVxuICAgICAgICBjb3VudHlOYW1lPXtjb3VudHlOYW1lfVxuICAgICAgICBzdGF0ZU5hbWU9e3N0YXRlTmFtZX1cbiAgICAgICAgcG9wdWxhdGlvbj17cG9wdWxhdGlvbn1cbiAgICAgICAgc2lkZVBhbmVsU3RhdGU9e3Byb3BlcnRpZXNbY29uc3RhbnRzLlNJREVfUEFORUxfU1RBVEVdfVxuICAgICAgLz5cblxuICAgICAgey8qIERlbW9ncmFwaGljcyAqL31cbiAgICAgIDxUcmFjdERlbW9ncmFwaGljcyBwcm9wZXJ0aWVzPXtwcm9wZXJ0aWVzfSAvPlxuXG4gICAgICB7LyogRGlzYWR2YW50YWdlZD8gKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNhdGVnb3JpemF0aW9ufT5cbiAgICAgICAgey8qIFF1ZXN0aW9ucyBhc2tpbmcgaWYgZGlzYWR2YW50YWdlZD8gKi99XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaXNJbkZvY3VzfT5cbiAgICAgICAgICB7RVhQTE9SRV9DT1BZLkNPTU1VTklUWS5JU19GT0NVU31cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgey8qIFlFUywgTk8gb3IgUEFSVElBTExZIGRpc2FkdmFudGFnZWQgICovfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNvbW11bml0eU9mRm9jdXN9PlxuICAgICAgICAgIDxUcmFjdFByaW9yaXRpemF0aW9uXG4gICAgICAgICAgICBzY29yZU5Db21tdW5pdGllcz17XG4gICAgICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlNDT1JFX05fQ09NTVVOSVRJRVNdID09PSB0cnVlID9cbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5TQ09SRV9OX0NPTU1VTklUSUVTXSA6XG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWJhbENvdW50QUs9e1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5UUklCQUxfQVJFQVNfQ09VTlRfQUtdID49IDEgP1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlRSSUJBTF9BUkVBU19DT1VOVF9BS10gOlxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWJhbENvdW50VVM9e1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5UUklCQUxfQVJFQVNfQ09VTlRfQ09OVVNdID49IDEgP1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlRSSUJBTF9BUkVBU19DT1VOVF9DT05VU10gOlxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlcmNlbnRUcmFjdFRyaWJhbD17cGVyY2VudFRyYWN0VHJpYmFsfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucHJpb0NvcHl9PlxuICAgICAgICAgIDxQcmlvcml0aXphdGlvbkNvcHlcbiAgICAgICAgICAgIHRvdGFsQ2F0ZWdvcmllc1ByaW9yaXRpemVkPXtcbiAgICAgICAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuQ09VTlRfT0ZfQ0FURUdPUklFU19ESVNBRFZdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3RhbEJ1cmRlbnNQcmlvcml0aXplZD17XG4gICAgICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlRPVEFMX05VTUJFUl9PRl9ESVNBRFZBTlRBR0VfSU5ESUNBVE9SU11cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzQWRqYWNlbmN5VGhyZXNoTWV0PXtcbiAgICAgICAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuQURKQUNFTkNZX0VYQ0VFRFNfVEhSRVNIXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNBZGphY2VuY3lMb3dJbmNvbWU9e1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5BREpBQ0VOQ1lfTE9XX0lOQ09NRV9FWENFRURTX1RIUkVTSF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzSXNsYW5kTG93SW5jb21lPXtcbiAgICAgICAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRkVERVJBTF9QT1ZFUlRZX0xFVkVMXzIwMF0gJiZcbiAgICAgICAgICAgICAgY29uc3RhbnRzLlRJTEVTX0lTTEFORF9BUkVBX0ZJUFNfQ09ERVMuc29tZSgoY29kZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5HRU9JRF9QUk9QRVJUWV0uc3RhcnRzV2l0aChjb2RlKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWJhbENvdW50QUs9e1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5UUklCQUxfQVJFQVNfQ09VTlRfQUtdID49IDEgP1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlRSSUJBTF9BUkVBU19DT1VOVF9BS10gOlxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWJhbENvdW50VVM9e1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5UUklCQUxfQVJFQVNfQ09VTlRfQ09OVVNdID49IDEgP1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlRSSUJBTF9BUkVBU19DT1VOVF9DT05VU10gOlxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlcmNlbnRUcmFjdFRyaWJhbD17cGVyY2VudFRyYWN0VHJpYmFsfVxuICAgICAgICAgICAgaXNHcmFuZGZhdGhlcmVkPXtcbiAgICAgICAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfR1JBTkRGQVRIRVJFRF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxQcmlvcml0aXphdGlvbkNvcHkyXG4gICAgICAgICAgICB0b3RhbENhdGVnb3JpZXNQcmlvcml0aXplZD17XG4gICAgICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkNPVU5UX09GX0NBVEVHT1JJRVNfRElTQURWXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNBZGphY2VuY3lUaHJlc2hNZXQ9e1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5BREpBQ0VOQ1lfRVhDRUVEU19USFJFU0hdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0FkamFjZW5jeUxvd0luY29tZT17XG4gICAgICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkFESkFDRU5DWV9MT1dfSU5DT01FX0VYQ0VFRFNfVEhSRVNIXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpYmFsQ291bnRBSz17XG4gICAgICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlRSSUJBTF9BUkVBU19DT1VOVF9BS10gPj0gMSA/XG4gICAgICAgICAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuVFJJQkFMX0FSRUFTX0NPVU5UX0FLXSA6XG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpYmFsQ291bnRVUz17XG4gICAgICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlRSSUJBTF9BUkVBU19DT1VOVF9DT05VU10gPj0gMSA/XG4gICAgICAgICAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuVFJJQkFMX0FSRUFTX0NPVU5UX0NPTlVTXSA6XG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVyY2VudFRyYWN0VHJpYmFsPXtwZXJjZW50VHJhY3RUcmliYWx9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAge3Nob3dJc2xhbmRDb3B5ICYmXG4gICAgICAgIDxJc2xhbmRDb3B5IHBvdmVydHlQZXJjZW50aWxlPXtwb3ZlcnlQZXJjZW50aWxlfSAvPn1cbiAgICAgIHtzaG93RG9udXRDb3B5ICYmXG4gICAgICAgIDxEb251dENvcHlcbiAgICAgICAgICBpc0FkamFjZW50PXtwcm9wZXJ0aWVzW2NvbnN0YW50cy5BREpBQ0VOQ1lfRVhDRUVEU19USFJFU0hdfVxuICAgICAgICAgIHBvdmVydHlCZWxvdzIwMFBlcmNlbnRpbGU9e3BvdmVyeVBlcmNlbnRpbGV9XG4gICAgICAgIC8+XG4gICAgICB9XG5cbiAgICAgIHsvKiBTZW5kIEZlZWRiYWNrIGJ1dHRvbiAqL31cbiAgICAgIDxhXG4gICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnNlbmRGZWVkYmFja0xpbmt9XG4gICAgICAgIGhyZWY9e1xuICAgICAgICAgIGludGwubG9jYWxlID09PSBgZXNgID9cbiAgICAgICAgICAgIGAke2NvbnN0YW50cy5DRU5TVVNfVFJBQ1RfU1VSVkVZX0xJTktTLkVTfT90cmFjdGlkPSR7YmxvY2tHcm91cH1gIDpcbiAgICAgICAgICAgIGAke2NvbnN0YW50cy5DRU5TVVNfVFJBQ1RfU1VSVkVZX0xJTktTLkVOfT90cmFjdGlkPSR7YmxvY2tHcm91cH1gXG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0PXtcIl9ibGFua1wifVxuICAgICAgICByZWw9XCJub3JlZmVycmVyXCJcbiAgICAgID5cbiAgICAgICAgPEJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3NOYW1lPXtzdHlsZXMuc2VuZEZlZWRiYWNrQnRufT5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJ1dHRvbkNvbnRhaW5lcn0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJ1dHRvblRleHR9PlxuICAgICAgICAgICAgICB7RVhQTE9SRV9DT1BZLkNPTU1VTklUWS5TRU5EX0ZFRURCQUNLLlRJVExFfVxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxJY29uLkxhdW5jaCBhcmlhLWxhYmVsPXtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLkNPTU1VTklUWS5TRU5EX0ZFRURCQUNLLklNR19JQ09OLkFMVF9UQUcpfSAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L0J1dHRvbj5cbiAgICAgIDwvYT5cblxuICAgICAgey8qIEFsbCBjYXRlZ29yeSBhY2NvcmRpb25zIGluIHRoaXMgY29tcG9uZW50ICovfVxuICAgICAgezxBY2NvcmRpb24gbXVsdGlzZWxlY3RhYmxlPXt0cnVlfSBpdGVtcz17Y2F0ZWdvcnlJdGVtc30gY2xhc3NOYW1lPVwiLUFyZWFEZXRhaWxcIiAvPn1cblxuICAgICAgey8qIE1ldGhvZG9sb2d5IHZlcnNpb24gKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnZlcnNpb25JbmZvfT5cbiAgICAgICAge0VYUExPUkVfQ09QWS5TSURFX1BBTkVMX1ZFUlNJT04uVElUTEV9XG4gICAgICA8L2Rpdj5cbiAgICA8L2FzaWRlPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQXJlYURldGFpbDtcbiIsImltcG9ydCBBcmVhRGV0YWlsIGZyb20gJy4vQXJlYURldGFpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IEFyZWFEZXRhaWw7XG5cbiIsImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUdobGFXZG9kRDBpTWpRaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSWdkMmxrZEdnOUlqSTBJajQ4Y0dGMGFDQmtQU0pOTUNBd2FESTBkakkwU0RCNklpQm1hV3hzUFNKdWIyNWxJaTgrUEhCaGRHZ2daRDBpVFRFNUlERXphQzAyZGpab0xUSjJMVFpJTlhZdE1tZzJWalZvTW5ZMmFEWjJNbm9pTHo0OEwzTjJaejQ9XCIiLCJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlHaGxhV2RvZEQwaU1qUWlJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lnZDJsa2RHZzlJakkwSWo0OGNHRjBhQ0JrUFNKTk1DQXdhREkwZGpJMFNEQjZJaUJtYVd4c1BTSnViMjVsSWk4K1BIQmhkR2dnWkQwaVRURTFMalVnTVRSb0xTNDNPV3d0TGpJNExTNHlOME14TlM0ME1TQXhNaTQxT1NBeE5pQXhNUzR4TVNBeE5pQTVMalVnTVRZZ05TNDVNU0F4TXk0d09TQXpJRGt1TlNBelV6TWdOUzQ1TVNBeklEa3VOU0ExTGpreElERTJJRGt1TlNBeE5tTXhMall4SURBZ015NHdPUzB1TlRrZ05DNHlNeTB4TGpVM2JDNHlOeTR5T0hZdU56bHNOU0EwTGprNVRESXdMalE1SURFNWJDMDBMams1TFRWNmJTMDJJREJETnk0d01TQXhOQ0ExSURFeExqazVJRFVnT1M0MVV6Y3VNREVnTlNBNUxqVWdOU0F4TkNBM0xqQXhJREUwSURrdU5TQXhNUzQ1T1NBeE5DQTVMalVnTVRSNklpOCtQQzl6ZG1jK1wiIiwiZXhwb3J0IGRlZmF1bHQgXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJR2hsYVdkb2REMGlNalFpSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJZ2QybGtkR2c5SWpJMElqNDhjR0YwYUNCa1BTSk5NQ0F3YURJMGRqSTBTREI2SWlCbWFXeHNQU0p1YjI1bElpOCtQSEJoZEdnZ1pEMGlUVEV5SURoakxUSXVNakVnTUMwMElERXVOemt0TkNBMGN6RXVOemtnTkNBMElEUWdOQzB4TGpjNUlEUXROQzB4TGpjNUxUUXROQzAwZW0wNExqazBJRE5qTFM0ME5pMDBMakUzTFRNdU56Y3ROeTQwT0MwM0xqazBMVGN1T1RSV01XZ3RNbll5TGpBMlF6WXVPRE1nTXk0MU1pQXpMalV5SURZdU9ETWdNeTR3TmlBeE1VZ3hkakpvTWk0d05tTXVORFlnTkM0eE55QXpMamMzSURjdU5EZ2dOeTQ1TkNBM0xqazBWakl6YURKMkxUSXVNRFpqTkM0eE55MHVORFlnTnk0ME9DMHpMamMzSURjdU9UUXROeTQ1TkVneU0zWXRNbWd0TWk0d05ucE5NVElnTVRsakxUTXVPRGNnTUMwM0xUTXVNVE10TnkwM2N6TXVNVE10TnlBM0xUY2dOeUF6TGpFeklEY2dOeTB6TGpFeklEY3ROeUEzZWlJdlBqd3ZjM1puUGc9PVwiIiwiZXhwb3J0IGRlZmF1bHQgXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJR2hsYVdkb2REMGlNalFpSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJZ2QybGtkR2c5SWpJMElqNDhjR0YwYUNCa1BTSk5NQ0F3YURJMGRqSTBTREI2SWlCbWFXeHNQU0p1YjI1bElpOCtQSEJoZEdnZ1pEMGlUVEUySURFeFl6RXVOallnTUNBeUxqazVMVEV1TXpRZ01pNDVPUzB6VXpFM0xqWTJJRFVnTVRZZ05XTXRNUzQyTmlBd0xUTWdNUzR6TkMweklETnpNUzR6TkNBeklETWdNM3B0TFRnZ01HTXhMalkySURBZ01pNDVPUzB4TGpNMElESXVPVGt0TTFNNUxqWTJJRFVnT0NBMVF6WXVNelFnTlNBMUlEWXVNelFnTlNBNGN6RXVNelFnTXlBeklETjZiVEFnTW1NdE1pNHpNeUF3TFRjZ01TNHhOeTAzSURNdU5WWXhPV2d4TkhZdE1pNDFZekF0TWk0ek15MDBMalkzTFRNdU5TMDNMVE11TlhwdE9DQXdZeTB1TWprZ01DMHVOakl1TURJdExqazNMakExSURFdU1UWXVPRFFnTVM0NU55QXhMamszSURFdU9UY2dNeTQwTlZZeE9XZzJkaTB5TGpWak1DMHlMak16TFRRdU5qY3RNeTQxTFRjdE15NDFlaUl2UGp3dmMzWm5QZz09XCIiLCJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlHaGxhV2RvZEQwaU1qUWlJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lnZDJsa2RHZzlJakkwSWo0OGNHRjBhQ0JrUFNKTk1DQXdhREkwZGpJMFNEQjZJaUJtYVd4c1BTSnViMjVsSWk4K1BIQmhkR2dnWkQwaVRUa2dNVFpvTm5ZdE5tZzBiQzAzTFRjdE55QTNhRFI2YlMwMElESm9NVFIyTWtnMWVpSXZQand2YzNablBnPT1cIiIsImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUdobGFXZG9kRDBpTWpRaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSWdkMmxrZEdnOUlqSTBJajQ4Y0dGMGFDQmtQU0pOTUNBd2FESTBkakkwU0RCNklpQm1hV3hzUFNKdWIyNWxJaTgrUEhCaGRHZ2daRDBpVFRrZ01UWXVNVGRNTkM0NE15QXhNbXd0TVM0ME1pQXhMalF4VERrZ01Ua2dNakVnTjJ3dE1TNDBNUzB4TGpReGVpSXZQand2YzNablBnPT1cIiIsImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhacFpYZENiM2c5SWpBZ01DQXhNemt1T0RjZ01UUXlMamMwSWo0OFpHVm1jejQ4YzNSNWJHVStMbU5zY3kweGUyWnBiR3c2STJabVpqdDlMbU5zY3kweWUyWnBiR3c2SXpJek1XWXlNRHQ5TG1Oc2N5MHplMlpwYkd3NkkySmpZbVZqWVR0OUxtTnNjeTAwZTJacGJHdzZJekJqTXpVMU5qdDlQQzl6ZEhsc1pUNDhMMlJsWm5NK1BHY2dhV1E5SWt4aGVXVnlYeklpSUdSaGRHRXRibUZ0WlQwaVRHRjVaWElnTWlJK1BHY2dhV1E5SWt4aGVXVnlYekV0TWlJZ1pHRjBZUzF1WVcxbFBTSk1ZWGxsY2lBeElqNDhjR0YwYUNCamJHRnpjejBpWTJ4ekxURWlJR1E5SWsweE1Ea3VNRGtzT0RndU1qVm9MVEl1TWpoc0xUTXlMakl4TGpnMFl5MHlMakUwTGpBMkxUTXNMamcxTFRNc01pNDVkalEzTGpRMll6QXNNaXd4TERJdU9UUXNNeXd5TGpremNUTXhMakl0TGpFc05qSXVNemd0TGpJMll6SXVNRFlzTUN3eUxqZzVMUzQ0Tml3eUxqZzVMVEl1T1RSV056VXVPRFZqTUMweUxqRXpMUzQ0T0MwekxUTXRNMGd4TVRJdU1EbGpMVEl1TVRnc01DMHpMQzQ0TkMwekxETmFUVFEzTGpFMkxESTRMamczVmpNdU1UVmpNQzB5TGpNeUxTNDNOeTB6TGpFekxUTXRNeTR4TTBnelF6RXNNQ3d1TURVdU9EWXVNRFlzTWk0M09WRXVNVGNzTXpRc0xqTXhMRFkxTGpJNVl6QXNNaTR4TVM0M09Td3lMamd4TERNc01pNDROa2cyTnk0d09XTXlMalUxTERBc015NHlPUzB1TmpFc015NHpMVEl1T0RKV016RXVOamRqTUMweUxTNDRNeTB5TGpjNExUSXVPRFV0TWk0M09FZzBOeTR4TmxwdE5TNHhOQzB5TkdnNE1pNDFNWFkyTTJnMExqYzFWak11TXpGak1DMHlMalU0TFM0M015MHpMakk1TFRNdU16WXRNeTR5T1VnMU1pNHpXbTB0TkRjdU1UWXNNVE16ZGkwMk5rZ3VNelYyTmpjdU0yTXdMREl1T0RjdU56RXNNeTQxTnl3ekxqWXNNeTQxTjBnMk5pNDJNVll4TXpoYUlpOCtQSEJoZEdnZ1kyeGhjM005SW1Oc2N5MHlJaUJrUFNKTk16a3VORFFzTlM0d05uWXROVWd4TXpZdU1tTXlMall6TERBc015NHpOaTQzTkN3ekxqTTJMRE11TkRGV09ETXVOekpvTFRRdU56VldOUzR3TmxvaUx6NDhjR0YwYUNCamJHRnpjejBpWTJ4ekxUSWlJR1E5SWswMUxqRTBMREV6Tnk0NVNEYzJMakkxZGpRdU56bElOR010TWk0NE9Td3dMVE11TmkwdU55MHpMall0TXk0MU4xWTJOUzQwTWtnMUxqRTBXaUl2UGp4d1lYUm9JR05zWVhOelBTSmpiSE10TXlJZ1pEMGlUVGMyTGpVMExEa3pMamc1WXk0Mk15d3dMREV1TVRVdExqQTVMREV1TmpjdExqRnNNekV1T1RFdExqY3hZekl1TkRRc01Dd3lMakl5TFM0M055d3lMak16TFRNdU1qZ3VNVFF0TXk0ME9TNHlMVGNzTGpNdE1UQXVORGNzTUMwdU5UTXNNUzR4TFRFc01TNHhOUzB4TGpZemFESXhkall3U0RjMkxqVTBXaUl2UGp4d1lYUm9JR05zWVhOelBTSmpiSE10TXlJZ1pEMGlUVFkxTGpVeExETXpMalkzVmpZekxqUXhTRFl1TmpaakxURXVORGNzTUMweExqYzRMUzQxTFRFdU56Z3RNUzQ0TkZZMUxqUTRRVEl1TVRJc01pNHhNaXd3TERBc01TdzFMRFF1T0RsSU5ESXVOREZXTXpBdU5EVmpNQ3d5TGpNNExqYzVMRE11TVRnc015NHhOQ3d6TGpFNGFESXdXaUl2UGp4d1lYUm9JR05zWVhOelBTSmpiSE10TkNJZ1pEMGlUVEV3T0M0NU1TdzRPQzR6TWxZM05TNDRNMk13TFRJdU1UVXVPRFl0TXl3ekxUTm9NalF1TlRoak1pNHhOQ3d3TERNc0xqZzRMRE1zTTNZMk15NDJNbU13TERJdU1Ea3RMamd5TERNdE1pNDRPQ3d6Y1Mwek1Td3VNVFV0TmpJdU1Ea3VNalZqTFRJc01DMHpMUzQ1TVMwekxUSXVPVFJXT1RJdU1EbGpNQzB5TGpBM0xqZ3lMVEl1T0RVc015MHlMamt4UXpnMUxqSTNMRGc0TGpnM0xERXdOeTQ0TERnNExqTXlMREV3T0M0NU1TdzRPQzR6TWxwdExUTXlMalFzTlM0MU9YWTBNeTQ0YURVNExqRTBkaTAyTUVneE1UTXVOekZqTUN3dU5UZ3RMakV6TERFdU1URXRMakUxTERFdU5qTXRMakVzTXk0ME9TMHVNVFlzTnkwdU15d3hNQzQwTmkwdU1Td3lMalV5TFM0NE9Dd3pMakl6TFRNdU16RXNNeTR5T1d3dE16RXVOell1TnkweExqWTRMakV5V2lJdlBqeHdZWFJvSUdOc1lYTnpQU0pqYkhNdE5DSWdaRDBpVFRRM0xqRTJMREk0TGpnM1NEWTNMalZqTWl3d0xESXVPRFF1Tnpnc01pNDROU3d5TGpjNFZqWTFMak14WXpBc01pNHlNUzB1TnpVc01pNDRNaTB6TGpNc01pNDRNa2d6TGpJMVl5MHlMakUyTERBdE1pNDVOQzB1TnpVdE15MHlMamcyVVM0eExETTBMREFzTWk0M04wTXdMQzQ0TkM0NU1Td3dMREl1T1N3d1NEUTBMakZqTWk0eU5Td3dMRE1zTGpneExETXNNeTR4TTFZeU5pNDROVnB0TVRndU16VXNOQzQ0YUMweU1HTXRNaTR6TlN3d0xUTXVNVFF0TGpndE15NHhOQzB6TGpFNFZqUXVPVE5JTkM0NU1XTXdMQzR5T0MwdU1EY3VORFF0TGpBM0xqVTVWall4TGpZeFl6QXNNUzR6TkM0ek1Td3hMamcwTERFdU56Z3NNUzQ0TkhFeU9DNDJNUzB1TURnc05UY3VNaklzTUdneExqWXpXaUl2UGp3dlp6NDhMMmMrUEM5emRtYytcIiIsImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhacFpYZENiM2c5SWpBZ01DQXhPRGN1T0RjZ01USTVMamdpUGp4a1pXWnpQanh6ZEhsc1pUNHVZMnh6TFRGN1ptbHNiRG9qWm1abU8zMDhMM04wZVd4bFBqd3ZaR1ZtY3o0OFp5QnBaRDBpVEdGNVpYSmZNaUlnWkdGMFlTMXVZVzFsUFNKTVlYbGxjaUF5SWo0OFp5QnBaRDBpVEdGNVpYSmZNUzB5SWlCa1lYUmhMVzVoYldVOUlreGhlV1Z5SURFaVBqeG5JR2xrUFNKWVRWQndNa291ZEdsbUlqNDhjR0YwYUNCa1BTSk5NakF1T0RZc01USTFMak5oTkM0eE1TdzBMakV4TERBc01Dd3dMRE11TnpVdE1TNDRNU3d4TXpJdU5pd3hNekl1Tml3d0xEQXNNQ3d5TkMwME9TNDJORU0xTVM0eE9DdzJNeTQxTlN3MU15dzFNeTR3Tnl3MU5TNHlOU3cwTWk0M1l6SXRPUzR5TWl3MExqWXRNVGd1TWpnc01UQXVOalF0TWpVdU56bEROelF1TVRrc05pNDJMRGcwTGpZNUxTNHhOQ3c1T0M0ekxEQmpNVFl1TXpZdU1UZ3NNamd1TVRZc09DNHpPU3d6TlM0NE1pd3lNaTQxT0N3MExqRXpMRGN1TmpRc05TNDBNeXd4Tmk0eE5pdzJMalE0TERJMExqWTJMRElzTVRVdU9Td3pMalkyTERNeExqZzBMRGt1TkRFc05EZEJNVEkyTGpFMkxERXlOaTR4Tml3d0xEQXNNQ3d4TmpZc01USXpMalEyWVRRc05Dd3dMREFzTUN3ekxqY3hMREV1T0RaTk16VXVNak1zTVRJMUxqRm9NVEl3TGpWakxTNHpNaTB1TlRndExqUTRMUzQ1TkMwdU55MHhMakkyWVRFeU5DNDJOaXd4TWpRdU5qWXNNQ3d3TERFdE1Ua3VPUzAwT1M0MU0yTXRNUzQzT1MweE1DNDBOeTB5TGpreExUSXhMVFF1TlRFdE16RXVOVFV0TVM0d05TMDJMamt6TFRJdU56Z3RNVE11TmpZdE5pNDNOQzB4T1M0Mk1rTXhNVFl1T1RNc01USXVOeXd4TURNdU56a3NOeXc1TWk0ekxEa3VPVFJqTFRFeExqSTFMREl1T1MweE9TNHhNaXd4TUMweU15NDNMREl3TGpZNVF6WTBMallzTkRBc05qTXVNVGtzTlRBdU1TdzJNUzR6TVN3Mk1DdzFPQ3czTnk0Mk55dzFNeXc1TkM0M05DdzBOQzR4Tnl3eE1UQXVORGdzTkRFdU16Y3NNVEUxTGpNNUxETTRMakl6TERFeU1DNHhMRE0xTGpJekxERXlOUzR4V2lJdlBqeHdZWFJvSUdOc1lYTnpQU0pqYkhNdE1TSWdaRDBpVFRNMUxqSXpMREV5TlM0eFl6TXVNRGN0TlN3MkxqRTRMVGt1TnpFc09DNDVOQzB4TkM0Mk1rTTFNeXc1TkM0M05DdzFOeTQ1TkN3M055NDJOeXcyTVM0eU15dzJNR014TGpnNExUa3VPVFFzTXk0eU5TMHlNQ3czTGpJNUxUSTVMalF4UXpjekxqRXNNakFzT0RFc01USXVPRFFzT1RJdU1qSXNPUzQ1TkdNeE1TNDBPUzB6TERJMExqWXpMREl1TnpZc016RXVOVGdzTVRNdU1pdzBMRFlzTlM0Mk9Td3hNaTQyT1N3MkxqYzBMREU1TGpZeUxERXVOaXd4TUM0MUxESXVOeklzTWpFdU1EZ3NOQzQxTVN3ek1TNDFOVUV4TWpRdU5qWXNNVEkwTGpZMkxEQXNNQ3d3TERFMU5Td3hNak11T0RSakxqSXlMak15TGpNNExqWTRMamNzTVM0eU5sb2lMejQ4TDJjK1BISmxZM1FnZVQwaU1USXdMamdpSUhkcFpIUm9QU0l4T0RjdU9EY2lJR2hsYVdkb2REMGlPU0l2UGp3dlp6NDhMMmMrUEM5emRtYytcIiIsImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhacFpYZENiM2c5SWpBZ01DQXhOVGN1TURNZ01UVTJMamt5SWo0OFp5QnBaRDBpVEdGNVpYSmZNaUlnWkdGMFlTMXVZVzFsUFNKTVlYbGxjaUF5SWo0OFp5QnBaRDBpVEdGNVpYSmZNUzB5SWlCa1lYUmhMVzVoYldVOUlreGhlV1Z5SURFaVBqeHdZWFJvSUdROUlrMDVOQzQwTVN3eE1qWXVPRFZvTFM0NU5Hd3RNeTQwTkN3d1ZqYzVZekF0TlM0NU5DMHpMak0yTFRFd0xqTXhMVGt0TVRFdU5qbGhNVGd1TkN3eE9DNDBMREFzTUN3d0xUUXRMak0xU0RNMUxqZzVURE13TGpJc05qZHNMUzR3T0MwekxqUkRNamt1TkRJc016UXVOVElzTlRJdU1qWXNNaXc1TUM0ek5pNHdPV0UyTXk0ek9TdzJNeTR6T1N3d0xEQXNNU3cyTmk0MU9TdzJNQ3cyTkN3Mk5Dd3dMREFzTVN3d0xEY3VNRFlzTmpNdU1qWXNOak11TWpZc01Dd3dMREV0TmpJdU5URXNOVGt1TnpKYVRUYzNMalUzTERZd1lUSTBMalk1TERJMExqWTVMREFzTUN3eExEVXNMalV4YkM0eE1Td3dRemt4TGpVeExEWXlMalkwTERrM0xEWTVMamN6TERrM0xEYzVkalF3TGpjNFlUVTJMak15TERVMkxqTXlMREFzTUN3d0xEVXlMamt0TlRNdU1EY3NOVGN1TXpnc05UY3VNemdzTUN3d0xEQXNNQzAyTGpJNVFUVTJMak00TERVMkxqTTRMREFzTUN3d0xEa3dMamN5TERjdU1EaEROVGd1TXl3NExqY3hMRE00TGpNeExETTFMakUxTERNM0xqRTJMRFl3U0RjM0xqVTNXaUl2UGp4d1lYUm9JR1E5SWswMk9Dd3hOVFl1T1RKb01FRTJPQzR5T1N3Mk9DNHlPU3d3TERBc01Td3hMalV5TERFd01pNDFMRGd6TGpJMExEZ3pMakkwTERBc01Dd3hMQzR6TkN3NU1pNDVReTR5TlN3NU1TNDRMakUyTERrd0xqWTVMakEyTERnNUxqWmhPQzQxTWl3NExqVXlMREFzTUN3eExESXVNVE10Tmk0M09FRTVMakk1TERrdU1qa3NNQ3d3TERFc09TNDBNU3c0TUdNeUxqYzBMakEyTERVdU5UUXNNQ3c0TGpJMExEQnNOQzR5TERCSU5qY3VOak5qTkM0d09Td3dMRFl1T1RJc01TNDFOU3c0TGpNNUxEUXVOakpCTVRBdU5Ea3NNVEF1TkRrc01Dd3dMREVzTnpjc09EbDJNVEF1TjJNd0xESXVNVFlzTUN3MExqVTFMREFzT0M0NE9IWXpPUzR6TjJFNExqUTBMRGd1TkRRc01Dd3dMREV0T1N3NVdtMHROVGd1TnpndE56QmhNaTQwT0N3eUxqUTRMREFzTUN3d0xURXVPRFF1TmpGQk1TNDJNeXd4TGpZekxEQXNNQ3d3TERjc09EZ3VPRGhqTGpFeExERXVNVGN1TWpFc01pNHpNUzR6TERNdU5EVmhOelF1TkRJc056UXVORElzTUN3d0xEQXNNUzR3Tml3NExqYzJRVFl4TGpZc05qRXVOaXd3TERBc01DdzJPQ3d4TkRrdU9USmhNaTQwTERJdU5Dd3dMREFzTUN3eExqWXpMUzQwTERJdU5ETXNNaTQwTXl3d0xEQXNNQ3d1TkMweExqWldNVEE0TGpVMVl6QXROQzR6TXl3d0xUWXVOek1zTUMwNExqZzVWamc1WVRNdU16RXNNeTR6TVN3d0xEQXNNQzB1TXpJdE1TNDBNbU10TGpFeExTNHlNeTB1TWprdExqWXhMVEl1TURZdExqWXhTREUzTGpkakxUSXVOelVzTUMwMUxqWXNNQzA0TGpRekxEQmFJaTgrUEM5blBqd3ZaejQ4TDNOMlp6ND1cIiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHZhciBzaWRlUGFuZWxJbmZvQ29udGFpbmVyID0gXCJTaWRlUGFuZWxJbmZvLW1vZHVsZS0tc2lkZVBhbmVsSW5mb0NvbnRhaW5lci0tejBXTzZcIjtcbmV4cG9ydCB2YXIgc2lkZVBhbmVsSW5mb0hlYWRpbmcgPSBcIlNpZGVQYW5lbEluZm8tbW9kdWxlLS1zaWRlUGFuZWxJbmZvSGVhZGluZy0tSXF5RDBcIjtcbmV4cG9ydCB2YXIgc2lkZVBhbmVsSW5mb0ljb24gPSBcIlNpZGVQYW5lbEluZm8tbW9kdWxlLS1zaWRlUGFuZWxJbmZvSWNvbi0tRnZSckxcIjtcbmV4cG9ydCB2YXIgc2lkZVBhbmVsSW5mb1RpdGxlID0gXCJTaWRlUGFuZWxJbmZvLW1vZHVsZS0tc2lkZVBhbmVsSW5mb1RpdGxlLS1Sb3pkWlwiOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge3VzZUludGx9IGZyb20gJ2dhdHNieS1wbHVnaW4taW50bCc7XG5pbXBvcnQge3VzZVdpbmRvd1NpemV9IGZyb20gJ3JlYWN0LXVzZSc7XG5cbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBwbHVzSWNvbiBmcm9tICcvbm9kZV9tb2R1bGVzL3Vzd2RzL2Rpc3QvaW1nL3VzYS1pY29ucy9hZGQuc3ZnJztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBzZWFyY2hJY29uIGZyb20gJy9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL3NlYXJjaC5zdmcnO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IGxvY2F0ZUljb24gZnJvbSAnL25vZGVfbW9kdWxlcy91c3dkcy9kaXN0L2ltZy91c2EtaWNvbnMvbXlfbG9jYXRpb24uc3ZnJztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBwZW9wbGVJY29uIGZyb20gJy9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL3Blb3BsZS5zdmcnO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IGZpbGVVcEljb24gZnJvbSAnL25vZGVfbW9kdWxlcy91c3dkcy9kaXN0L2ltZy91c2EtaWNvbnMvZmlsZV91cGxvYWQuc3ZnJztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBjaGVja0ljb24gZnJvbSAnL25vZGVfbW9kdWxlcy91c3dkcy9kaXN0L2ltZy91c2EtaWNvbnMvY2hlY2suc3ZnJztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBwdXp6bGVJY29uIGZyb20gJy4uLy4uL2ltYWdlcy9zaWRlUGFuZWxJY29ucy9wdXp6bGUuc3ZnJztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBiZWxsQ3VydmVJY29uIGZyb20gJy4uLy4uL2ltYWdlcy9zaWRlUGFuZWxJY29ucy9iZWxsLWN1cnZlLnN2Zyc7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgY2Vuc3VzRG90SWNvbiBmcm9tICcuLi8uLi9pbWFnZXMvc2lkZVBhbmVsSWNvbnMvY2Vuc3VzLXRyYWN0LnN2Zyc7XG4vLyBAdHMtaWdub3JlXG4vLyBpbXBvcnQgdHJpYmFsRG90SWNvbiBmcm9tICcuLi8uLi9pbWFnZXMvc2lkZVBhbmVsSWNvbnMvdHJpYmFsLXRyYWN0LnN2Zyc7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgcGllQ2hhcnRJY29uIGZyb20gJy4uLy4uL2ltYWdlcy9zaWRlUGFuZWxJY29ucy9waWUtY2hhcnQuc3ZnJztcbi8vIEB0cy1pZ25vcmVcbi8vIGltcG9ydCBoYW5kUG9pbnRJY29uIGZyb20gJy4uLy4uL2ltYWdlcy9zaWRlUGFuZWxJY29ucy9tb3VzZS1oYW5kLXBvaW50LnN2Zyc7XG5cbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuL1NpZGVQYW5lbEluZm8ubW9kdWxlLnNjc3MnO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4uLy4uL2RhdGEvY29uc3RhbnRzJztcbmltcG9ydCAqIGFzIEVYUExPUkVfQ09QWSBmcm9tICcuLi8uLi9kYXRhL2NvcHkvZXhwbG9yZSc7XG5cbmNvbnN0IFNpZGVQYW5lbEluZm8gPSAoKSA9PiB7XG4gIGNvbnN0IGludGwgPSB1c2VJbnRsKCk7XG4gIGNvbnN0IHt3aWR0aDogd2luZG93V2lkdGh9ID0gdXNlV2luZG93U2l6ZSgpO1xuXG4gIHJldHVybiAoXG4gICAgPGFzaWRlIGNsYXNzTmFtZT17c3R5bGVzLnNpZGVQYW5lbEluZm9Db250YWluZXJ9PlxuXG4gICAgICB7LyogSGVhZGluZyAxICovfVxuICAgICAgPGhlYWRlciB0YWJJbmRleD17MH0gY2xhc3NOYW1lPXtzdHlsZXMuc2lkZVBhbmVsSW5mb1RpdGxlfT5cbiAgICAgICAge2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUSUFMX1NUQVRFLkhFQURJTkcxKX1cbiAgICAgIDwvaGVhZGVyPlxuXG4gICAgICB7LyogUGFyYWdyYXBoIDEgKi99XG4gICAgICA8cCB0YWJJbmRleD17MH0+XG4gICAgICAgIHtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5JVElBTF9TVEFURS5QQVJBMV9QQVJUMSl9XG4gICAgICAgIHtcbiAgICAgICAgICB3aW5kb3dXaWR0aCA+IGNvbnN0YW50cy5VU1dEU19CUkVBS1BPSU5UUy5NT0JJTEVfTEcgJiZcbiAgICAgICAgICA8aW1nIHRhYkluZGV4PXswfSBjbGFzc05hbWU9e3N0eWxlcy5zaWRlUGFuZWxJbmZvSWNvbn0gc3JjPXtwbHVzSWNvbn1cbiAgICAgICAgICAgIGFsdD17aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRfU1RBVEVfSUNPTl9BTFRfVEVYVC5QTFVTKX1cbiAgICAgICAgICAvPlxuICAgICAgICB9XG4gICAgICAgIHtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5JVElBTF9TVEFURS5QQVJBMV9QQVJUMil9XG4gICAgICAgIHtcbiAgICAgICAgICB3aW5kb3dXaWR0aCA+IGNvbnN0YW50cy5VU1dEU19CUkVBS1BPSU5UUy5NT0JJTEVfTEcgJiZcbiAgICAgICAgICA8aW1nIHRhYkluZGV4PXswfSBjbGFzc05hbWU9e3N0eWxlcy5zaWRlUGFuZWxJbmZvSWNvbn0gc3JjPXtzZWFyY2hJY29ufVxuICAgICAgICAgICAgYWx0PXtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5JVF9TVEFURV9JQ09OX0FMVF9URVhULlNFQVJDSCl9XG4gICAgICAgICAgLz5cbiAgICAgICAgfVxuICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRJQUxfU1RBVEUuUEFSQTFfUEFSVDMpfVxuICAgICAgICB7XG4gICAgICAgICAgd2luZG93V2lkdGggPiBjb25zdGFudHMuVVNXRFNfQlJFQUtQT0lOVFMuTU9CSUxFX0xHICYmXG4gICAgICAgICAgPGltZyB0YWJJbmRleD17MH0gY2xhc3NOYW1lPXtzdHlsZXMuc2lkZVBhbmVsSW5mb0ljb259IHNyYz17bG9jYXRlSWNvbn1cbiAgICAgICAgICAgIGFsdD17aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRfU1RBVEVfSUNPTl9BTFRfVEVYVC5MT0NBVEUpfVxuICAgICAgICAgIC8+XG4gICAgICAgIH1cbiAgICAgICAge2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUSUFMX1NUQVRFLlBBUkExX1BBUlQ0KX1cbiAgICAgICAgey8qIHtcbiAgICAgICAgICB3aW5kb3dXaWR0aCA+IGNvbnN0YW50cy5VU1dEU19CUkVBS1BPSU5UUy5NT0JJTEVfTEcgJiZcbiAgICAgICAgICA8aW1nIHRhYkluZGV4PXswfSBjbGFzc05hbWU9e3N0eWxlcy5zaWRlUGFuZWxJbmZvSWNvbn0gc3JjPXtoYW5kUG9pbnRJY29ufVxuICAgICAgICAgICAgYWx0PXtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5JVF9TVEFURV9JQ09OX0FMVF9URVhULk1PVVNFKX1cbiAgICAgICAgICAvPlxuICAgICAgICB9ICovfVxuICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRJQUxfU1RBVEUuUEFSQTFfUEFSVDUpfVxuICAgICAgPC9wPlxuXG4gICAgICB7LyogSGVhZGluZyAyICovfVxuICAgICAgPHAgdGFiSW5kZXg9ezB9IGNsYXNzTmFtZT17c3R5bGVzLnNpZGVQYW5lbEluZm9IZWFkaW5nfT5cbiAgICAgICAge2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUSUFMX1NUQVRFLkhFQURJTkcyKX1cbiAgICAgIDwvcD5cblxuICAgICAgey8qIFBhcmFncmFwaCAyICovfVxuICAgICAgPHAgdGFiSW5kZXg9ezB9PlxuICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRJQUxfU1RBVEUuUEFSQTJfUEFSVDEpfVxuICAgICAgICB7XG4gICAgICAgICAgd2luZG93V2lkdGggPiBjb25zdGFudHMuVVNXRFNfQlJFQUtQT0lOVFMuTU9CSUxFX0xHICYmXG4gICAgICAgICAgPGltZyB0YWJJbmRleD17MH0gY2xhc3NOYW1lPXtzdHlsZXMuc2lkZVBhbmVsSW5mb0ljb259IHNyYz17cHV6emxlSWNvbn1cbiAgICAgICAgICAgIGFsdD17aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRfU1RBVEVfSUNPTl9BTFRfVEVYVC5UUkFDVCl9XG4gICAgICAgICAgLz5cbiAgICAgICAgfVxuICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRJQUxfU1RBVEUuUEFSQTJfUEFSVDIpfVxuICAgICAgICB7XG4gICAgICAgICAgd2luZG93V2lkdGggPiBjb25zdGFudHMuVVNXRFNfQlJFQUtQT0lOVFMuTU9CSUxFX0xHICYmXG4gICAgICAgICAgPGltZyB0YWJJbmRleD17MH0gY2xhc3NOYW1lPXtzdHlsZXMuc2lkZVBhbmVsSW5mb0ljb259IHNyYz17cGVvcGxlSWNvbn1cbiAgICAgICAgICAgIGFsdD17aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRfU1RBVEVfSUNPTl9BTFRfVEVYVC5QRU9QTEUpfVxuICAgICAgICAgIC8+XG4gICAgICAgIH1cbiAgICAgICAge2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUSUFMX1NUQVRFLlBBUkEyX1BBUlQzKX1cbiAgICAgIDwvcD5cblxuICAgICAgey8qIFBhcmFncmFwaCAzICovfVxuICAgICAge1xuICAgICAgICB3aW5kb3dXaWR0aCA+IGNvbnN0YW50cy5VU1dEU19CUkVBS1BPSU5UUy5NT0JJTEVfTEcgJiZcbiAgICAgICAgPHAgdGFiSW5kZXg9ezB9PlxuICAgICAgICAgIHtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5JVElBTF9TVEFURS5QQVJBM19QQVJUMSl9XG4gICAgICAgICAgPGltZyB0YWJJbmRleD17MH0gY2xhc3NOYW1lPXtzdHlsZXMuc2lkZVBhbmVsSW5mb0ljb259IHNyYz17Y2Vuc3VzRG90SWNvbn1cbiAgICAgICAgICAgIGFsdD17aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRfU1RBVEVfSUNPTl9BTFRfVEVYVC5EQUNfQ0lSQ0xFKX1cbiAgICAgICAgICAvPlxuICAgICAgICAgIHtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5JVElBTF9TVEFURS5QQVJBM19QQVJUMil9XG4gICAgICAgIDwvcD5cbiAgICAgIH1cblxuICAgICAgey8qIFBhcmFncmFwaCA0ICovfVxuICAgICAge1xuICAgICAgICB3aW5kb3dXaWR0aCA+IGNvbnN0YW50cy5VU1dEU19CUkVBS1BPSU5UUy5NT0JJTEVfTEcgJiZcbiAgICAgICAgPHAgdGFiSW5kZXg9ezB9PlxuICAgICAgICAgIHtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5JVElBTF9TVEFURS5QQVJBNF9QQVJUMSl9XG4gICAgICAgICAgPGltZyB0YWJJbmRleD17MH0gY2xhc3NOYW1lPXtzdHlsZXMuc2lkZVBhbmVsSW5mb0ljb259IHNyYz17YmVsbEN1cnZlSWNvbn1cbiAgICAgICAgICAgIGFsdD17aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRfU1RBVEVfSUNPTl9BTFRfVEVYVC5CRUxMX0NVUlZFKX1cbiAgICAgICAgICAvPlxuICAgICAgICAgIHtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5JVElBTF9TVEFURS5QQVJBNF9QQVJUMil9XG4gICAgICAgIDwvcD5cbiAgICAgIH1cblxuICAgICAgey8qIFBhcmFncmFwaCA1ICovfVxuICAgICAge1xuICAgICAgICB3aW5kb3dXaWR0aCA+IGNvbnN0YW50cy5VU1dEU19CUkVBS1BPSU5UUy5NT0JJTEVfTEcgJiZcbiAgICAgICA8cCB0YWJJbmRleD17MH0+XG4gICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRJQUxfU1RBVEUuUEFSQTVfUEFSVDEpfVxuICAgICAgICAgPGltZyB0YWJJbmRleD17MH0gY2xhc3NOYW1lPXtzdHlsZXMuc2lkZVBhbmVsSW5mb0ljb259IHNyYz17ZmlsZVVwSWNvbn1cbiAgICAgICAgICAgYWx0PXtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5JVF9TVEFURV9JQ09OX0FMVF9URVhULkZJTEVfVVApfVxuICAgICAgICAgLz5cbiAgICAgICAgIHtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5JVElBTF9TVEFURS5QQVJBNV9QQVJUMil9XG4gICAgICAgICA8aW1nIHRhYkluZGV4PXswfSBjbGFzc05hbWU9e3N0eWxlcy5zaWRlUGFuZWxJbmZvSWNvbn0gc3JjPXtwaWVDaGFydEljb259XG4gICAgICAgICAgIGFsdD17aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRfU1RBVEVfSUNPTl9BTFRfVEVYVC5QSUVfQ0hBUlQpfVxuICAgICAgICAgLz5cbiAgICAgICAgIHtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5JVElBTF9TVEFURS5QQVJBNV9QQVJUMyl9XG4gICAgICAgICA8aW1nIHRhYkluZGV4PXswfSBjbGFzc05hbWU9e3N0eWxlcy5zaWRlUGFuZWxJbmZvSWNvbn0gc3JjPXtjaGVja0ljb259XG4gICAgICAgICAgIGFsdD17aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRfU1RBVEVfSUNPTl9BTFRfVEVYVC5DSEVDSyl9XG4gICAgICAgICAvPlxuICAgICAgICAge2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUSUFMX1NUQVRFLlBBUkE1X1BBUlQ0KX1cbiAgICAgICA8L3A+XG4gICAgICB9XG5cbiAgICAgIHsvKiBQYXJhZ3JhcGggNiAqL31cbiAgICAgIHtcbiAgICAgICAgd2luZG93V2lkdGggPiBjb25zdGFudHMuVVNXRFNfQlJFQUtQT0lOVFMuTU9CSUxFX0xHICYmXG4gICAgICAgIDxwIHRhYkluZGV4PXswfT5cbiAgICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRJQUxfU1RBVEUuUEFSQTZfUEFSVDEpfVxuICAgICAgICAgIDxpbWcgdGFiSW5kZXg9ezB9IGNsYXNzTmFtZT17c3R5bGVzLnNpZGVQYW5lbEluZm9JY29ufSBzcmM9e2NlbnN1c0RvdEljb259XG4gICAgICAgICAgICBhbHQ9e2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUX1NUQVRFX0lDT05fQUxUX1RFWFQuREFDX0NJUkNMRSl9XG4gICAgICAgICAgLz5cbiAgICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRJQUxfU1RBVEUuUEFSQTZfUEFSVDIpfVxuICAgICAgICA8L3A+XG4gICAgICB9XG4gICAgPC9hc2lkZT5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNpZGVQYW5lbEluZm87XG4iLCJpbXBvcnQgU2lkZVBhbmVsSW5mbyBmcm9tICcuL1NpZGVQYW5lbEluZm8nO1xuXG5leHBvcnQgZGVmYXVsdCBTaWRlUGFuZWxJbmZvO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBBcmVhRGV0YWlsIGZyb20gJy4vQXJlYURldGFpbCc7XG5pbXBvcnQgU2lkZVBhbmVsSW5mbyBmcm9tICcuL1NpZGVQYW5lbEluZm8nO1xuXG5pbnRlcmZhY2UgSU1hcEluZm9QYW5lbFByb3BzIHtcbiAgICBjbGFzc05hbWU6IHN0cmluZyxcbiAgICBmZWF0dXJlUHJvcGVydGllczogeyBba2V5OnN0cmluZ106IHN0cmluZyB8IG51bWJlciB9IHwgdW5kZWZpbmVkLFxuICAgIGhhc2g6IHN0cmluZ1tdLFxuICB9XG5cbmNvbnN0IE1hcEluZm9QYW5lbCA9ICh7XG4gIGNsYXNzTmFtZSxcbiAgZmVhdHVyZVByb3BlcnRpZXMsXG4gIGhhc2gsXG59OklNYXBJbmZvUGFuZWxQcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9ID5cbiAgICAgIHsvKlxuICAgICAgVGhlIHRlcnRpYXJ5IGNvbmRpdGlvbmFsIHN0YXRlbWVudCBiZWxvdyB3aWxsIGNvbnRyb2wgdGhlIHNpZGUgcGFuZWwgc3RhdGUuIEN1cnJlbnRseVxuICAgICAgdGhlcmUgYXJlIHR3byBzdGF0ZXMsIG5hbWVseSBzaG93aW5nIHRoZSBBcmVhRGV0YWlsIG9yIFNpZGVQYW5lbEluZm8uIFdoZW4gYSBmZWF0dXJlXG4gICAgICBpcyBzZWxlY3RlZCwgc2hvdyB0aGUgQXJlYURldGFpbC4gV2hlbiBub3Qgc2VsZWN0ZWQgc2hvdyBTaWRlUGFuZWxJbmZvXG4gICAgICAgKi99XG4gICAgICB7KGZlYXR1cmVQcm9wZXJ0aWVzKSA/XG4gICAgICAgICAgPEFyZWFEZXRhaWxcbiAgICAgICAgICAgIHByb3BlcnRpZXM9e2ZlYXR1cmVQcm9wZXJ0aWVzfVxuICAgICAgICAgICAgaGFzaD17aGFzaH1cbiAgICAgICAgICAvPiA6XG4gICAgICAgICAgPFNpZGVQYW5lbEluZm8gLz5cbiAgICAgIH1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1hcEluZm9QYW5lbDtcbiIsIi8qKlxuICogSW5kZXhlcyBmb3IgYWxsIHN1YnN0cmluZyBzZWFyY2hlcyAoZS5nLiB0aGUgdGVybSBcImNhdFwiIGlzIGluZGV4ZWQgYXMgXCJjXCIsIFwiY2FcIiwgXCJjYXRcIiwgXCJhXCIsIFwiYXRcIiwgYW5kIFwidFwiKS5cbiAqL1xudmFyIEFsbFN1YnN0cmluZ3NJbmRleFN0cmF0ZWd5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQWxsU3Vic3RyaW5nc0luZGV4U3RyYXRlZ3koKSB7fVxuICB2YXIgX3Byb3RvID0gQWxsU3Vic3RyaW5nc0luZGV4U3RyYXRlZ3kucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY3NcbiAgICovXG4gIF9wcm90by5leHBhbmRUb2tlbiA9IGZ1bmN0aW9uIGV4cGFuZFRva2VuKHRva2VuKSB7XG4gICAgdmFyIGV4cGFuZGVkVG9rZW5zID0gW107XG4gICAgdmFyIHN0cmluZztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdG9rZW4ubGVuZ3RoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIHN0cmluZyA9ICcnO1xuICAgICAgZm9yICh2YXIgaiA9IGk7IGogPCBsZW5ndGg7ICsraikge1xuICAgICAgICBzdHJpbmcgKz0gdG9rZW4uY2hhckF0KGopO1xuICAgICAgICBleHBhbmRlZFRva2Vucy5wdXNoKHN0cmluZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHBhbmRlZFRva2VucztcbiAgfTtcbiAgcmV0dXJuIEFsbFN1YnN0cmluZ3NJbmRleFN0cmF0ZWd5O1xufSgpO1xuXG4vKipcbiAqIEluZGV4ZXMgZm9yIGV4YWN0IHdvcmQgbWF0Y2hlcy5cbiAqL1xudmFyIEV4YWN0V29yZEluZGV4U3RyYXRlZ3kgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFeGFjdFdvcmRJbmRleFN0cmF0ZWd5KCkge31cbiAgdmFyIF9wcm90byA9IEV4YWN0V29yZEluZGV4U3RyYXRlZ3kucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY3NcbiAgICovXG4gIF9wcm90by5leHBhbmRUb2tlbiA9IGZ1bmN0aW9uIGV4cGFuZFRva2VuKHRva2VuKSB7XG4gICAgcmV0dXJuIHRva2VuID8gW3Rva2VuXSA6IFtdO1xuICB9O1xuICByZXR1cm4gRXhhY3RXb3JkSW5kZXhTdHJhdGVneTtcbn0oKTtcblxuLyoqXG4gKiBJbmRleGVzIGZvciBwcmVmaXggc2VhcmNoZXMgKGUuZy4gdGhlIHRlcm0gXCJjYXRcIiBpcyBpbmRleGVkIGFzIFwiY1wiLCBcImNhXCIsIGFuZCBcImNhdFwiIGFsbG93aW5nIHByZWZpeCBzZWFyY2ggbG9va3VwcykuXG4gKi9cbnZhciBQcmVmaXhJbmRleFN0cmF0ZWd5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUHJlZml4SW5kZXhTdHJhdGVneSgpIHt9XG4gIHZhciBfcHJvdG8gPSBQcmVmaXhJbmRleFN0cmF0ZWd5LnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NzXG4gICAqL1xuICBfcHJvdG8uZXhwYW5kVG9rZW4gPSBmdW5jdGlvbiBleHBhbmRUb2tlbih0b2tlbikge1xuICAgIHZhciBleHBhbmRlZFRva2VucyA9IFtdO1xuICAgIHZhciBzdHJpbmcgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdG9rZW4ubGVuZ3RoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIHN0cmluZyArPSB0b2tlbi5jaGFyQXQoaSk7XG4gICAgICBleHBhbmRlZFRva2Vucy5wdXNoKHN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiBleHBhbmRlZFRva2VucztcbiAgfTtcbiAgcmV0dXJuIFByZWZpeEluZGV4U3RyYXRlZ3k7XG59KCk7XG5cbi8qKlxuICogRW5mb3JjZXMgY2FzZS1zZW5zaXRpdmUgdGV4dCBtYXRjaGVzLlxuICovXG52YXIgQ2FzZVNlbnNpdGl2ZVNhbml0aXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENhc2VTZW5zaXRpdmVTYW5pdGl6ZXIoKSB7fVxuICB2YXIgX3Byb3RvID0gQ2FzZVNlbnNpdGl2ZVNhbml0aXplci5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jc1xuICAgKi9cbiAgX3Byb3RvLnNhbml0aXplID0gZnVuY3Rpb24gc2FuaXRpemUodGV4dCkge1xuICAgIHJldHVybiB0ZXh0ID8gdGV4dC50cmltKCkgOiAnJztcbiAgfTtcbiAgcmV0dXJuIENhc2VTZW5zaXRpdmVTYW5pdGl6ZXI7XG59KCk7XG5cbi8qKlxuICogU2FuaXRpemVzIHRleHQgYnkgY29udmVydGluZyB0byBhIGxvY2FsZS1mcmllbmRseSBsb3dlci1jYXNlIHZlcnNpb24gYW5kIHRyaW1pbmcgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS5cbiAqL1xudmFyIExvd2VyQ2FzZVNhbml0aXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExvd2VyQ2FzZVNhbml0aXplcigpIHt9XG4gIHZhciBfcHJvdG8gPSBMb3dlckNhc2VTYW5pdGl6ZXIucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY3NcbiAgICovXG4gIF9wcm90by5zYW5pdGl6ZSA9IGZ1bmN0aW9uIHNhbml0aXplKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dCA/IHRleHQudG9Mb2NhbGVMb3dlckNhc2UoKS50cmltKCkgOiAnJztcbiAgfTtcbiAgcmV0dXJuIExvd2VyQ2FzZVNhbml0aXplcjtcbn0oKTtcblxuLyoqXG4gKiBGaW5kIGFuZCByZXR1cm4gYSBuZXN0ZWQgb2JqZWN0IHZhbHVlLlxuICpcbiAqIEBwYXJhbSBvYmplY3QgdG8gY3Jhd2xcbiAqIEBwYXJhbSBwYXRoIFByb3BlcnR5IHBhdGhcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGdldE5lc3RlZEZpZWxkVmFsdWUob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBwYXRoIHx8IFtdO1xuICBvYmplY3QgPSBvYmplY3QgfHwge307XG4gIHZhciB2YWx1ZSA9IG9iamVjdDsgLy8gd2FsayBkb3duIHRoZSBwcm9wZXJ0eSBwYXRoXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsdWUgPSB2YWx1ZVtwYXRoW2ldXTtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBTZWFyY2ggaW5kZXggY2FwYWJsZSBvZiByZXR1cm5pbmcgcmVzdWx0cyBtYXRjaGluZyBhIHNldCBvZiB0b2tlbnMgYW5kIHJhbmtlZCBhY2NvcmRpbmcgdG8gVEYtSURGLlxuICovXG52YXIgVGZJZGZTZWFyY2hJbmRleCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRmSWRmU2VhcmNoSW5kZXgodWlkRmllbGROYW1lKSB7XG4gICAgdGhpcy5fdWlkRmllbGROYW1lID0gdWlkRmllbGROYW1lO1xuICAgIHRoaXMuX3Rva2VuVG9JZGZDYWNoZSA9IHt9O1xuICAgIHRoaXMuX3Rva2VuTWFwID0ge307XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jc1xuICAgKi9cblxuICB2YXIgX3Byb3RvID0gVGZJZGZTZWFyY2hJbmRleC5wcm90b3R5cGU7XG4gIF9wcm90by5pbmRleERvY3VtZW50ID0gZnVuY3Rpb24gaW5kZXhEb2N1bWVudCh0b2tlbiwgdWlkLCBkb2MpIHtcbiAgICB0aGlzLl90b2tlblRvSWRmQ2FjaGUgPSB7fTsgLy8gTmV3IGluZGV4IGludmFsaWRhdGVzIHByZXZpb3VzIElERiBjYWNoZXNcblxuICAgIHZhciB0b2tlbk1hcCA9IHRoaXMuX3Rva2VuTWFwO1xuICAgIHZhciB0b2tlbkRhdHVtO1xuICAgIGlmICh0eXBlb2YgdG9rZW5NYXBbdG9rZW5dICE9PSAnb2JqZWN0Jykge1xuICAgICAgdG9rZW5NYXBbdG9rZW5dID0gdG9rZW5EYXR1bSA9IHtcbiAgICAgICAgJG51bURvY3VtZW50T2NjdXJyZW5jZXM6IDAsXG4gICAgICAgICR0b3RhbE51bU9jY3VycmVuY2VzOiAxLFxuICAgICAgICAkdWlkTWFwOiB7fVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9rZW5EYXR1bSA9IHRva2VuTWFwW3Rva2VuXTtcbiAgICAgIHRva2VuRGF0dW0uJHRvdGFsTnVtT2NjdXJyZW5jZXMrKztcbiAgICB9XG4gICAgdmFyIHVpZE1hcCA9IHRva2VuRGF0dW0uJHVpZE1hcDtcbiAgICBpZiAodHlwZW9mIHVpZE1hcFt1aWRdICE9PSAnb2JqZWN0Jykge1xuICAgICAgdG9rZW5EYXR1bS4kbnVtRG9jdW1lbnRPY2N1cnJlbmNlcysrO1xuICAgICAgdWlkTWFwW3VpZF0gPSB7XG4gICAgICAgICRkb2N1bWVudDogZG9jLFxuICAgICAgICAkbnVtVG9rZW5PY2N1cnJlbmNlczogMVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdWlkTWFwW3VpZF0uJG51bVRva2VuT2NjdXJyZW5jZXMrKztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jc1xuICAgKi87XG4gIF9wcm90by5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2godG9rZW5zLCBjb3JwdXMpIHtcbiAgICB2YXIgdWlkVG9Eb2N1bWVudE1hcCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIHZhciB0b2tlbk1ldGFkYXRhID0gdGhpcy5fdG9rZW5NYXBbdG9rZW5dOyAvLyBTaG9ydCBjaXJjdWl0IGlmIG5vIG1hdGNoZXMgd2VyZSBmb3VuZCBmb3IgYW55IGdpdmVuIHRva2VuLlxuXG4gICAgICBpZiAoIXRva2VuTWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0b2tlbk1ldGFkYXRhLiR1aWRNYXApO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgbnVtS2V5cyA9IGtleXMubGVuZ3RoOyBqIDwgbnVtS2V5czsgaisrKSB7XG4gICAgICAgICAgdmFyIHVpZCA9IGtleXNbal07XG4gICAgICAgICAgdWlkVG9Eb2N1bWVudE1hcFt1aWRdID0gdG9rZW5NZXRhZGF0YS4kdWlkTWFwW3VpZF0uJGRvY3VtZW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHVpZFRvRG9jdW1lbnRNYXApO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgbnVtS2V5cyA9IGtleXMubGVuZ3RoOyBqIDwgbnVtS2V5czsgaisrKSB7XG4gICAgICAgICAgdmFyIHVpZCA9IGtleXNbal07XG4gICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbk1ldGFkYXRhLiR1aWRNYXBbdWlkXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB1aWRUb0RvY3VtZW50TWFwW3VpZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBkb2N1bWVudHMgPSBbXTtcbiAgICBmb3IgKHZhciB1aWQgaW4gdWlkVG9Eb2N1bWVudE1hcCkge1xuICAgICAgZG9jdW1lbnRzLnB1c2godWlkVG9Eb2N1bWVudE1hcFt1aWRdKTtcbiAgICB9XG4gICAgdmFyIGNhbGN1bGF0ZVRmSWRmID0gdGhpcy5fY3JlYXRlQ2FsY3VsYXRlVGZJZGYoKTsgLy8gUmV0dXJuIGRvY3VtZW50cyBzb3J0ZWQgYnkgVEYtSURGXG5cbiAgICByZXR1cm4gZG9jdW1lbnRzLnNvcnQoZnVuY3Rpb24gKGRvY3VtZW50QSwgZG9jdW1lbnRCKSB7XG4gICAgICByZXR1cm4gY2FsY3VsYXRlVGZJZGYodG9rZW5zLCBkb2N1bWVudEIsIGNvcnB1cykgLSBjYWxjdWxhdGVUZklkZih0b2tlbnMsIGRvY3VtZW50QSwgY29ycHVzKTtcbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLl9jcmVhdGVDYWxjdWxhdGVJZGYgPSBmdW5jdGlvbiBfY3JlYXRlQ2FsY3VsYXRlSWRmKCkge1xuICAgIHZhciB0b2tlbk1hcCA9IHRoaXMuX3Rva2VuTWFwO1xuICAgIHZhciB0b2tlblRvSWRmQ2FjaGUgPSB0aGlzLl90b2tlblRvSWRmQ2FjaGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNhbGN1bGF0ZUlkZih0b2tlbiwgZG9jdW1lbnRzKSB7XG4gICAgICBpZiAoIXRva2VuVG9JZGZDYWNoZVt0b2tlbl0pIHtcbiAgICAgICAgdmFyIG51bURvY3VtZW50c1dpdGhUb2tlbiA9IHR5cGVvZiB0b2tlbk1hcFt0b2tlbl0gIT09ICd1bmRlZmluZWQnID8gdG9rZW5NYXBbdG9rZW5dLiRudW1Eb2N1bWVudE9jY3VycmVuY2VzIDogMDtcbiAgICAgICAgdG9rZW5Ub0lkZkNhY2hlW3Rva2VuXSA9IDEgKyBNYXRoLmxvZyhkb2N1bWVudHMubGVuZ3RoIC8gKDEgKyBudW1Eb2N1bWVudHNXaXRoVG9rZW4pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2tlblRvSWRmQ2FjaGVbdG9rZW5dO1xuICAgIH07XG4gIH07XG4gIF9wcm90by5fY3JlYXRlQ2FsY3VsYXRlVGZJZGYgPSBmdW5jdGlvbiBfY3JlYXRlQ2FsY3VsYXRlVGZJZGYoKSB7XG4gICAgdmFyIHRva2VuTWFwID0gdGhpcy5fdG9rZW5NYXA7XG4gICAgdmFyIHVpZEZpZWxkTmFtZSA9IHRoaXMuX3VpZEZpZWxkTmFtZTtcbiAgICB2YXIgY2FsY3VsYXRlSWRmID0gdGhpcy5fY3JlYXRlQ2FsY3VsYXRlSWRmKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNhbGN1bGF0ZVRmSWRmKHRva2VucywgZG9jdW1lbnQsIGRvY3VtZW50cykge1xuICAgICAgdmFyIHNjb3JlID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICB2YXIgaW52ZXJzZURvY3VtZW50RnJlcXVlbmN5ID0gY2FsY3VsYXRlSWRmKHRva2VuLCBkb2N1bWVudHMpO1xuICAgICAgICBpZiAoaW52ZXJzZURvY3VtZW50RnJlcXVlbmN5ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIGludmVyc2VEb2N1bWVudEZyZXF1ZW5jeSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVpZDtcbiAgICAgICAgaWYgKHVpZEZpZWxkTmFtZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgdWlkID0gZG9jdW1lbnQgJiYgZ2V0TmVzdGVkRmllbGRWYWx1ZShkb2N1bWVudCwgdWlkRmllbGROYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1aWQgPSBkb2N1bWVudCAmJiBkb2N1bWVudFt1aWRGaWVsZE5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXJtRnJlcXVlbmN5ID0gdHlwZW9mIHRva2VuTWFwW3Rva2VuXSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRva2VuTWFwW3Rva2VuXS4kdWlkTWFwW3VpZF0gIT09ICd1bmRlZmluZWQnID8gdG9rZW5NYXBbdG9rZW5dLiR1aWRNYXBbdWlkXS4kbnVtVG9rZW5PY2N1cnJlbmNlcyA6IDA7XG4gICAgICAgIHNjb3JlICs9IHRlcm1GcmVxdWVuY3kgKiBpbnZlcnNlRG9jdW1lbnRGcmVxdWVuY3k7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NvcmU7XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIFRmSWRmU2VhcmNoSW5kZXg7XG59KCk7XG5cbi8qKlxuICogU2VhcmNoIGluZGV4IGNhcGFibGUgb2YgcmV0dXJuaW5nIHJlc3VsdHMgbWF0Y2hpbmcgYSBzZXQgb2YgdG9rZW5zIGJ1dCB3aXRob3V0IGFueSBtZWFuaW5nZnVsIHJhbmsgb3Igb3JkZXIuXG4gKi9cbnZhciBVbm9yZGVyZWRTZWFyY2hJbmRleCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFVub3JkZXJlZFNlYXJjaEluZGV4KCkge1xuICAgIHRoaXMuX3Rva2VuVG9VaWRUb0RvY3VtZW50TWFwID0ge307XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jc1xuICAgKi9cblxuICB2YXIgX3Byb3RvID0gVW5vcmRlcmVkU2VhcmNoSW5kZXgucHJvdG90eXBlO1xuICBfcHJvdG8uaW5kZXhEb2N1bWVudCA9IGZ1bmN0aW9uIGluZGV4RG9jdW1lbnQodG9rZW4sIHVpZCwgZG9jKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl90b2tlblRvVWlkVG9Eb2N1bWVudE1hcFt0b2tlbl0gIT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLl90b2tlblRvVWlkVG9Eb2N1bWVudE1hcFt0b2tlbl0gPSB7fTtcbiAgICB9XG4gICAgdGhpcy5fdG9rZW5Ub1VpZFRvRG9jdW1lbnRNYXBbdG9rZW5dW3VpZF0gPSBkb2M7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jc1xuICAgKi87XG4gIF9wcm90by5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2godG9rZW5zLCBjb3JwdXMpIHtcbiAgICB2YXIgaW50ZXJzZWN0aW5nRG9jdW1lbnRNYXAgPSB7fTtcbiAgICB2YXIgdG9rZW5Ub1VpZFRvRG9jdW1lbnRNYXAgPSB0aGlzLl90b2tlblRvVWlkVG9Eb2N1bWVudE1hcDtcbiAgICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICB2YXIgZG9jdW1lbnRNYXAgPSB0b2tlblRvVWlkVG9Eb2N1bWVudE1hcFt0b2tlbl07IC8vIFNob3J0IGNpcmN1aXQgaWYgbm8gbWF0Y2hlcyB3ZXJlIGZvdW5kIGZvciBhbnkgZ2l2ZW4gdG9rZW4uXG5cbiAgICAgIGlmICghZG9jdW1lbnRNYXApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkb2N1bWVudE1hcCk7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBudW1LZXlzID0ga2V5cy5sZW5ndGg7IGogPCBudW1LZXlzOyBqKyspIHtcbiAgICAgICAgICB2YXIgdWlkID0ga2V5c1tqXTtcbiAgICAgICAgICBpbnRlcnNlY3RpbmdEb2N1bWVudE1hcFt1aWRdID0gZG9jdW1lbnRNYXBbdWlkXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhpbnRlcnNlY3RpbmdEb2N1bWVudE1hcCk7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBudW1LZXlzID0ga2V5cy5sZW5ndGg7IGogPCBudW1LZXlzOyBqKyspIHtcbiAgICAgICAgICB2YXIgdWlkID0ga2V5c1tqXTtcbiAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50TWFwW3VpZF0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBkZWxldGUgaW50ZXJzZWN0aW5nRG9jdW1lbnRNYXBbdWlkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhpbnRlcnNlY3RpbmdEb2N1bWVudE1hcCk7XG4gICAgdmFyIGRvY3VtZW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBudW1LZXlzID0ga2V5cy5sZW5ndGg7IGkgPCBudW1LZXlzOyBpKyspIHtcbiAgICAgIHZhciB1aWQgPSBrZXlzW2ldO1xuICAgICAgZG9jdW1lbnRzLnB1c2goaW50ZXJzZWN0aW5nRG9jdW1lbnRNYXBbdWlkXSk7XG4gICAgfVxuICAgIHJldHVybiBkb2N1bWVudHM7XG4gIH07XG4gIHJldHVybiBVbm9yZGVyZWRTZWFyY2hJbmRleDtcbn0oKTtcbnZhciBSRUdFWCA9IC9bXmEtetCwLdGP0ZEwLTlcXC0nXSsvaTtcbi8qKlxuICogU2ltcGxlIHRva2VuaXplciB0aGF0IHNwbGl0cyBzdHJpbmdzIG9uIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgbm9uLWVtcHR5IHN1YnN0cmluZ3MuXG4gKi9cblxudmFyIFNpbXBsZVRva2VuaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNpbXBsZVRva2VuaXplcigpIHt9XG4gIHZhciBfcHJvdG8gPSBTaW1wbGVUb2tlbml6ZXIucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY3NcbiAgICovXG4gIF9wcm90by50b2tlbml6ZSA9IGZ1bmN0aW9uIHRva2VuaXplKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5zcGxpdChSRUdFWCkuZmlsdGVyKGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9IC8vIEZpbHRlciBlbXB0eSB0b2tlbnNcbiAgICApO1xuICB9O1xuICByZXR1cm4gU2ltcGxlVG9rZW5pemVyO1xufSgpO1xuXG4vKipcbiAqIFN0ZW1taW5nIGlzIHRoZSBwcm9jZXNzIG9mIHJlZHVjaW5nIHNlYXJjaCB0b2tlbnMgdG8gdGhlaXIgcm9vdCAob3Igc3RlbSkgc28gdGhhdCBzZWFyY2hlcyBmb3IgZGlmZmVyZW50IGZvcm1zIG9mIGFcbiAqIHdvcmQgd2lsbCBtYXRjaC4gRm9yIGV4YW1wbGUgXCJzZWFyY2hcIiwgXCJzZWFyY2hpbmdcIiBhbmQgXCJzZWFyY2hlZFwiIGFyZSBhbGwgcmVkdWNlZCB0byB0aGUgc3RlbSBcInNlYXJjaFwiLlxuICpcbiAqIDxwPlRoaXMgc3RlbW1pbmcgdG9rZW5pemVyIGNvbnZlcnRzIHRva2VucyAod29yZHMpIHRvIHRoZWlyIHN0ZW0gZm9ybXMgYmVmb3JlIHJldHVybmluZyB0aGVtLiBJdCByZXF1aXJlcyBhblxuICogZXh0ZXJuYWwgc3RlbW1pbmcgZnVuY3Rpb24gdG8gYmUgcHJvdmlkZWQ7IGZvciB0aGlzIHB1cnBvc2UgSSByZWNvbW1lbmQgdGhlIE5QTSAncG9ydGVyLXN0ZW1tZXInIGxpYnJhcnkuXG4gKlxuICogPHA+Rm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIGh0dHAgOiAvL3RhcnRhcnVzLm9yZy9+bWFydGluL1BvcnRlclN0ZW1tZXIvXG4gKi9cbnZhciBTdGVtbWluZ1Rva2VuaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHN0ZW1taW5nRnVuY3Rpb24gRnVuY3Rpb24gY2FwYWJsZSBvZiBhY2NlcHRpbmcgYSB3b3JkIGFuZCByZXR1cm5pbmcgaXRzIHN0ZW0uXG4gICAqIEBwYXJhbSBkZWNvcmF0ZWRJbmRleFN0cmF0ZWd5IEluZGV4IHN0cmF0ZWd5IHRvIGJlIHJ1biBhZnRlciBhbGwgc3RvcCB3b3JkcyBoYXZlIGJlZW4gcmVtb3ZlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFN0ZW1taW5nVG9rZW5pemVyKHN0ZW1taW5nRnVuY3Rpb24sIGRlY29yYXRlZFRva2VuaXplcikge1xuICAgIHRoaXMuX3N0ZW1taW5nRnVuY3Rpb24gPSBzdGVtbWluZ0Z1bmN0aW9uO1xuICAgIHRoaXMuX3Rva2VuaXplciA9IGRlY29yYXRlZFRva2VuaXplcjtcbiAgfVxuICAvKipcbiAgICogQGluaGVyaXREb2NzXG4gICAqL1xuXG4gIHZhciBfcHJvdG8gPSBTdGVtbWluZ1Rva2VuaXplci5wcm90b3R5cGU7XG4gIF9wcm90by50b2tlbml6ZSA9IGZ1bmN0aW9uIHRva2VuaXplKHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9rZW5pemVyLnRva2VuaXplKHRleHQpLm1hcCh0aGlzLl9zdGVtbWluZ0Z1bmN0aW9uKTtcbiAgfTtcbiAgcmV0dXJuIFN0ZW1taW5nVG9rZW5pemVyO1xufSgpO1xuXG4vKipcbiAqIFN0b3Agd29yZHMgbGlzdCBjb3BpZWQgZnJvbSBMdW5yIEpTLlxuICovXG52YXIgU3RvcFdvcmRzTWFwID0ge1xuICBhOiB0cnVlLFxuICBhYmxlOiB0cnVlLFxuICBhYm91dDogdHJ1ZSxcbiAgYWNyb3NzOiB0cnVlLFxuICBhZnRlcjogdHJ1ZSxcbiAgYWxsOiB0cnVlLFxuICBhbG1vc3Q6IHRydWUsXG4gIGFsc286IHRydWUsXG4gIGFtOiB0cnVlLFxuICBhbW9uZzogdHJ1ZSxcbiAgYW46IHRydWUsXG4gIGFuZDogdHJ1ZSxcbiAgYW55OiB0cnVlLFxuICBhcmU6IHRydWUsXG4gIGFzOiB0cnVlLFxuICBhdDogdHJ1ZSxcbiAgYmU6IHRydWUsXG4gIGJlY2F1c2U6IHRydWUsXG4gIGJlZW46IHRydWUsXG4gIGJ1dDogdHJ1ZSxcbiAgYnk6IHRydWUsXG4gIGNhbjogdHJ1ZSxcbiAgY2Fubm90OiB0cnVlLFxuICBjb3VsZDogdHJ1ZSxcbiAgZGVhcjogdHJ1ZSxcbiAgZGlkOiB0cnVlLFxuICAnZG8nOiB0cnVlLFxuICBkb2VzOiB0cnVlLFxuICBlaXRoZXI6IHRydWUsXG4gICdlbHNlJzogdHJ1ZSxcbiAgZXZlcjogdHJ1ZSxcbiAgZXZlcnk6IHRydWUsXG4gICdmb3InOiB0cnVlLFxuICBmcm9tOiB0cnVlLFxuICAnZ2V0JzogdHJ1ZSxcbiAgZ290OiB0cnVlLFxuICBoYWQ6IHRydWUsXG4gIGhhczogdHJ1ZSxcbiAgaGF2ZTogdHJ1ZSxcbiAgaGU6IHRydWUsXG4gIGhlcjogdHJ1ZSxcbiAgaGVyczogdHJ1ZSxcbiAgaGltOiB0cnVlLFxuICBoaXM6IHRydWUsXG4gIGhvdzogdHJ1ZSxcbiAgaG93ZXZlcjogdHJ1ZSxcbiAgaTogdHJ1ZSxcbiAgJ2lmJzogdHJ1ZSxcbiAgJ2luJzogdHJ1ZSxcbiAgaW50bzogdHJ1ZSxcbiAgaXM6IHRydWUsXG4gIGl0OiB0cnVlLFxuICBpdHM6IHRydWUsXG4gIGp1c3Q6IHRydWUsXG4gIGxlYXN0OiB0cnVlLFxuICBcImxldFwiOiB0cnVlLFxuICBsaWtlOiB0cnVlLFxuICBsaWtlbHk6IHRydWUsXG4gIG1heTogdHJ1ZSxcbiAgbWU6IHRydWUsXG4gIG1pZ2h0OiB0cnVlLFxuICBtb3N0OiB0cnVlLFxuICBtdXN0OiB0cnVlLFxuICBteTogdHJ1ZSxcbiAgbmVpdGhlcjogdHJ1ZSxcbiAgbm86IHRydWUsXG4gIG5vcjogdHJ1ZSxcbiAgbm90OiB0cnVlLFxuICBvZjogdHJ1ZSxcbiAgb2ZmOiB0cnVlLFxuICBvZnRlbjogdHJ1ZSxcbiAgb246IHRydWUsXG4gIG9ubHk6IHRydWUsXG4gIG9yOiB0cnVlLFxuICBvdGhlcjogdHJ1ZSxcbiAgb3VyOiB0cnVlLFxuICBvd246IHRydWUsXG4gIHJhdGhlcjogdHJ1ZSxcbiAgc2FpZDogdHJ1ZSxcbiAgc2F5OiB0cnVlLFxuICBzYXlzOiB0cnVlLFxuICBzaGU6IHRydWUsXG4gIHNob3VsZDogdHJ1ZSxcbiAgc2luY2U6IHRydWUsXG4gIHNvOiB0cnVlLFxuICBzb21lOiB0cnVlLFxuICB0aGFuOiB0cnVlLFxuICB0aGF0OiB0cnVlLFxuICB0aGU6IHRydWUsXG4gIHRoZWlyOiB0cnVlLFxuICB0aGVtOiB0cnVlLFxuICB0aGVuOiB0cnVlLFxuICB0aGVyZTogdHJ1ZSxcbiAgdGhlc2U6IHRydWUsXG4gIHRoZXk6IHRydWUsXG4gICd0aGlzJzogdHJ1ZSxcbiAgdGlzOiB0cnVlLFxuICB0bzogdHJ1ZSxcbiAgdG9vOiB0cnVlLFxuICB0d2FzOiB0cnVlLFxuICB1czogdHJ1ZSxcbiAgd2FudHM6IHRydWUsXG4gIHdhczogdHJ1ZSxcbiAgd2U6IHRydWUsXG4gIHdlcmU6IHRydWUsXG4gIHdoYXQ6IHRydWUsXG4gIHdoZW46IHRydWUsXG4gIHdoZXJlOiB0cnVlLFxuICB3aGljaDogdHJ1ZSxcbiAgJ3doaWxlJzogdHJ1ZSxcbiAgd2hvOiB0cnVlLFxuICB3aG9tOiB0cnVlLFxuICB3aHk6IHRydWUsXG4gIHdpbGw6IHRydWUsXG4gICd3aXRoJzogdHJ1ZSxcbiAgd291bGQ6IHRydWUsXG4gIHlldDogdHJ1ZSxcbiAgeW91OiB0cnVlLFxuICB5b3VyOiB0cnVlXG59OyAvLyBQcmV2ZW50IGZhbHNlIHBvc2l0aXZlcyBmb3IgaW5oZXJpdGVkIHByb3BlcnRpZXNcblxuU3RvcFdvcmRzTWFwLmNvbnN0cnVjdG9yID0gZmFsc2U7XG5TdG9wV29yZHNNYXAuaGFzT3duUHJvcGVydHkgPSBmYWxzZTtcblN0b3BXb3Jkc01hcC5pc1Byb3RvdHlwZU9mID0gZmFsc2U7XG5TdG9wV29yZHNNYXAucHJvcGVydHlJc0VudW1lcmFibGUgPSBmYWxzZTtcblN0b3BXb3Jkc01hcC50b0xvY2FsZVN0cmluZyA9IGZhbHNlO1xuU3RvcFdvcmRzTWFwLnRvU3RyaW5nID0gZmFsc2U7XG5TdG9wV29yZHNNYXAudmFsdWVPZiA9IGZhbHNlO1xuXG4vKipcbiAqIFN0b3Agd29yZHMgYXJlIHZlcnkgY29tbW9uIChlLmcuIFwiYVwiLCBcImFuZFwiLCBcInRoZVwiKSBhbmQgYXJlIG9mdGVuIG5vdCBzZW1hbnRpY2FsbHkgbWVhbmluZ2Z1bCBpbiB0aGUgY29udGV4dCBvZiBhXG4gKiBzZWFyY2guIFRoaXMgdG9rZW5pemVyIHJlbW92ZXMgc3RvcCB3b3JkcyBmcm9tIGEgc2V0IG9mIHRva2VucyBiZWZvcmUgcGFzc2luZyB0aGUgcmVtYWluaW5nIHRva2VucyBhbG9uZyBmb3JcbiAqIGluZGV4aW5nIG9yIHNlYXJjaGluZyBwdXJwb3Nlcy5cbiAqL1xuXG52YXIgU3RvcFdvcmRzVG9rZW5pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gZGVjb3JhdGVkSW5kZXhTdHJhdGVneSBJbmRleCBzdHJhdGVneSB0byBiZSBydW4gYWZ0ZXIgYWxsIHN0b3Agd29yZHMgaGF2ZSBiZWVuIHJlbW92ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBTdG9wV29yZHNUb2tlbml6ZXIoZGVjb3JhdGVkVG9rZW5pemVyKSB7XG4gICAgdGhpcy5fdG9rZW5pemVyID0gZGVjb3JhdGVkVG9rZW5pemVyO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY3NcbiAgICovXG5cbiAgdmFyIF9wcm90byA9IFN0b3BXb3Jkc1Rva2VuaXplci5wcm90b3R5cGU7XG4gIF9wcm90by50b2tlbml6ZSA9IGZ1bmN0aW9uIHRva2VuaXplKHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9rZW5pemVyLnRva2VuaXplKHRleHQpLmZpbHRlcihmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgIHJldHVybiAhU3RvcFdvcmRzTWFwW3Rva2VuXTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIFN0b3BXb3Jkc1Rva2VuaXplcjtcbn0oKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbi8qKlxuICogU2ltcGxlIGNsaWVudC1zaWRlIHNlYXJjaGluZyB3aXRoaW4gYSBzZXQgb2YgZG9jdW1lbnRzLlxuICpcbiAqIDxwPkRvY3VtZW50cyBjYW4gYmUgc2VhcmNoZWQgYnkgYW55IG51bWJlciBvZiBmaWVsZHMuIEluZGV4aW5nIGFuZCBzZWFyY2ggc3RyYXRlZ2llcyBhcmUgaGlnaGx5IGN1c3RvbWl6YWJsZS5cbiAqL1xudmFyIFNlYXJjaCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBBcnJheSBjb250YWluaW5nIGVpdGhlciBhIHByb3BlcnR5IG5hbWUgb3IgYSBwYXRoIChsaXN0IG9mIHByb3BlcnR5IG5hbWVzKSB0byBhIG5lc3RlZCB2YWx1ZVxuICAgKi9cblxuICAvKipcbiAgICogQ29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB1aWRGaWVsZE5hbWUgRmllbGQgY29udGFpbmluZyB2YWx1ZXMgdGhhdCB1bmlxdWVseSBpZGVudGlmeSBzZWFyY2ggZG9jdW1lbnRzOyB0aGlzIGZpZWxkJ3MgdmFsdWVzIGFyZSB1c2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgdG8gZW5zdXJlIHRoYXQgYSBzZWFyY2ggcmVzdWx0IHNldCBkb2VzIG5vdCBjb250YWluIGR1cGxpY2F0ZSBvYmplY3RzLlxuICAgKi9cbiAgZnVuY3Rpb24gU2VhcmNoKHVpZEZpZWxkTmFtZSkge1xuICAgIGlmICghdWlkRmllbGROYW1lKSB7XG4gICAgICB0aHJvdyBFcnJvcignanMtc2VhcmNoIHJlcXVpcmVzIGEgdWlkIGZpZWxkIG5hbWUgY29uc3RydWN0b3IgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIHRoaXMuX3VpZEZpZWxkTmFtZSA9IHVpZEZpZWxkTmFtZTsgLy8gU2V0IGRlZmF1bHQvcmVjb21tZW5kZWQgc3RyYXRlZ2llc1xuXG4gICAgdGhpcy5faW5kZXhTdHJhdGVneSA9IG5ldyBQcmVmaXhJbmRleFN0cmF0ZWd5KCk7XG4gICAgdGhpcy5fc2VhcmNoSW5kZXggPSBuZXcgVGZJZGZTZWFyY2hJbmRleCh1aWRGaWVsZE5hbWUpO1xuICAgIHRoaXMuX3Nhbml0aXplciA9IG5ldyBMb3dlckNhc2VTYW5pdGl6ZXIoKTtcbiAgICB0aGlzLl90b2tlbml6ZXIgPSBuZXcgU2ltcGxlVG9rZW5pemVyKCk7XG4gICAgdGhpcy5fZG9jdW1lbnRzID0gW107XG4gICAgdGhpcy5fc2VhcmNoYWJsZUZpZWxkcyA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBpbmRleCBzdHJhdGVneS5cbiAgICogQHBhcmFtIHZhbHVlIEN1c3RvbSBpbmRleCBzdHJhdGVneVxuICAgKiBAdGhyb3dzIEVycm9yIGlmIGRvY3VtZW50cyBoYXZlIGFscmVhZHkgYmVlbiBpbmRleGVkIGJ5IHRoaXMgc2VhcmNoIGluc3RhbmNlXG4gICAqL1xuXG4gIHZhciBfcHJvdG8gPSBTZWFyY2gucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBBZGQgYSBzZWFyY2hhYmxlIGRvY3VtZW50IHRvIHRoZSBpbmRleC4gRG9jdW1lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGluZGV4ZWQgZm9yIHNlYXJjaC5cbiAgICogQHBhcmFtIGRvY3VtZW50XG4gICAqL1xuICBfcHJvdG8uYWRkRG9jdW1lbnQgPSBmdW5jdGlvbiBhZGREb2N1bWVudChkb2N1bWVudCkge1xuICAgIHRoaXMuYWRkRG9jdW1lbnRzKFtkb2N1bWVudF0pO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIHNlYXJjaGFibGUgZG9jdW1lbnRzIHRvIHRoZSBpbmRleC4gRG9jdW1lbnRzIHdpbGwgYXV0b21hdGljYWxseSBiZSBpbmRleGVkIGZvciBzZWFyY2guXG4gICAqIEBwYXJhbSBkb2N1bWVudFxuICAgKi87XG4gIF9wcm90by5hZGREb2N1bWVudHMgPSBmdW5jdGlvbiBhZGREb2N1bWVudHMoZG9jdW1lbnRzKSB7XG4gICAgdGhpcy5fZG9jdW1lbnRzID0gdGhpcy5fZG9jdW1lbnRzLmNvbmNhdChkb2N1bWVudHMpO1xuICAgIHRoaXMuaW5kZXhEb2N1bWVudHNfKGRvY3VtZW50cywgdGhpcy5fc2VhcmNoYWJsZUZpZWxkcyk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBzZWFyY2hhYmxlIGZpZWxkIHRvIHRoZSBpbmRleC4gRXhpc3RpbmcgZG9jdW1lbnRzIHdpbGwgYXV0b21hdGljYWxseSBiZSBpbmRleGVkIHVzaW5nIHRoaXMgbmV3IGZpZWxkLlxuICAgKlxuICAgKiBAcGFyYW0gZmllbGQgU2VhcmNoYWJsZSBmaWVsZCBvciBmaWVsZCBwYXRoLiBQYXNzIGEgc3RyaW5nIHRvIGluZGV4IGEgdG9wLWxldmVsIGZpZWxkIGFuZCBhbiBhcnJheSBvZiBzdHJpbmdzIGZvciBuZXN0ZWQgZmllbGRzLlxuICAgKi87XG4gIF9wcm90by5hZGRJbmRleCA9IGZ1bmN0aW9uIGFkZEluZGV4KGZpZWxkKSB7XG4gICAgdGhpcy5fc2VhcmNoYWJsZUZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICB0aGlzLmluZGV4RG9jdW1lbnRzXyh0aGlzLl9kb2N1bWVudHMsIFtmaWVsZF0pO1xuICB9XG4gIC8qKlxuICAgKiBTZWFyY2ggYWxsIGRvY3VtZW50cyBmb3Igb25lcyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIHF1ZXJ5IHRleHQuXG4gICAqIEBwYXJhbSBxdWVyeVxuICAgKiBAcmV0dXJucyB7QXJyYXk8T2JqZWN0Pn1cbiAgICovO1xuICBfcHJvdG8uc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoKHF1ZXJ5KSB7XG4gICAgdmFyIHRva2VucyA9IHRoaXMuX3Rva2VuaXplci50b2tlbml6ZSh0aGlzLl9zYW5pdGl6ZXIuc2FuaXRpemUocXVlcnkpKTtcbiAgICByZXR1cm4gdGhpcy5fc2VhcmNoSW5kZXguc2VhcmNoKHRva2VucywgdGhpcy5fZG9jdW1lbnRzKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIGRvY3VtZW50c1xuICAgKiBAcGFyYW0gX3NlYXJjaGFibGVGaWVsZHMgQXJyYXkgY29udGFpbmluZyBwcm9wZXJ0eSBuYW1lcyBhbmQgcGF0aHMgKGxpc3RzIG9mIHByb3BlcnR5IG5hbWVzKSB0byBuZXN0ZWQgdmFsdWVzXG4gICAqIEBwcml2YXRlXG4gICAqLztcbiAgX3Byb3RvLmluZGV4RG9jdW1lbnRzXyA9IGZ1bmN0aW9uIGluZGV4RG9jdW1lbnRzXyhkb2N1bWVudHMsIF9zZWFyY2hhYmxlRmllbGRzKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBpbmRleFN0cmF0ZWd5ID0gdGhpcy5faW5kZXhTdHJhdGVneTtcbiAgICB2YXIgc2FuaXRpemVyID0gdGhpcy5fc2FuaXRpemVyO1xuICAgIHZhciBzZWFyY2hJbmRleCA9IHRoaXMuX3NlYXJjaEluZGV4O1xuICAgIHZhciB0b2tlbml6ZXIgPSB0aGlzLl90b2tlbml6ZXI7XG4gICAgdmFyIHVpZEZpZWxkTmFtZSA9IHRoaXMuX3VpZEZpZWxkTmFtZTtcbiAgICBmb3IgKHZhciBkaSA9IDAsIG51bURvY3VtZW50cyA9IGRvY3VtZW50cy5sZW5ndGg7IGRpIDwgbnVtRG9jdW1lbnRzOyBkaSsrKSB7XG4gICAgICB2YXIgZG9jID0gZG9jdW1lbnRzW2RpXTtcbiAgICAgIHZhciB1aWQ7XG4gICAgICBpZiAodWlkRmllbGROYW1lIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgdWlkID0gZ2V0TmVzdGVkRmllbGRWYWx1ZShkb2MsIHVpZEZpZWxkTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1aWQgPSBkb2NbdWlkRmllbGROYW1lXTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHNmaSA9IDAsIG51bVNlYXJjaGFibGVGaWVsZHMgPSBfc2VhcmNoYWJsZUZpZWxkcy5sZW5ndGg7IHNmaSA8IG51bVNlYXJjaGFibGVGaWVsZHM7IHNmaSsrKSB7XG4gICAgICAgIHZhciBmaWVsZFZhbHVlO1xuICAgICAgICB2YXIgc2VhcmNoYWJsZUZpZWxkID0gX3NlYXJjaGFibGVGaWVsZHNbc2ZpXTtcbiAgICAgICAgaWYgKHNlYXJjaGFibGVGaWVsZCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgZmllbGRWYWx1ZSA9IGdldE5lc3RlZEZpZWxkVmFsdWUoZG9jLCBzZWFyY2hhYmxlRmllbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpZWxkVmFsdWUgPSBkb2Nbc2VhcmNoYWJsZUZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBmaWVsZFZhbHVlICE9PSAnc3RyaW5nJyAmJiBmaWVsZFZhbHVlLnRvU3RyaW5nKSB7XG4gICAgICAgICAgZmllbGRWYWx1ZSA9IGZpZWxkVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZpZWxkVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIGZpZWxkVG9rZW5zID0gdG9rZW5pemVyLnRva2VuaXplKHNhbml0aXplci5zYW5pdGl6ZShmaWVsZFZhbHVlKSk7XG4gICAgICAgICAgZm9yICh2YXIgZnRpID0gMCwgbnVtRmllbGRWYWx1ZXMgPSBmaWVsZFRva2Vucy5sZW5ndGg7IGZ0aSA8IG51bUZpZWxkVmFsdWVzOyBmdGkrKykge1xuICAgICAgICAgICAgdmFyIGZpZWxkVG9rZW4gPSBmaWVsZFRva2Vuc1tmdGldO1xuICAgICAgICAgICAgdmFyIGV4cGFuZGVkVG9rZW5zID0gaW5kZXhTdHJhdGVneS5leHBhbmRUb2tlbihmaWVsZFRva2VuKTtcbiAgICAgICAgICAgIGZvciAodmFyIGV0aSA9IDAsIG51bW1FeHBhbmRlZFRva2VucyA9IGV4cGFuZGVkVG9rZW5zLmxlbmd0aDsgZXRpIDwgbnVtbUV4cGFuZGVkVG9rZW5zOyBldGkrKykge1xuICAgICAgICAgICAgICB2YXIgZXhwYW5kZWRUb2tlbiA9IGV4cGFuZGVkVG9rZW5zW2V0aV07XG4gICAgICAgICAgICAgIHNlYXJjaEluZGV4LmluZGV4RG9jdW1lbnQoZXhwYW5kZWRUb2tlbiwgdWlkLCBkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX2NyZWF0ZUNsYXNzKFNlYXJjaCwgW3tcbiAgICBrZXk6IFwiaW5kZXhTdHJhdGVneVwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0lJbmRleFN0cmF0ZWd5IGNhbm5vdCBiZSBzZXQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2luZGV4U3RyYXRlZ3kgPSB2YWx1ZTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2luZGV4U3RyYXRlZ3k7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHRleHQgc2FuaXRpemluZyBzdHJhdGVneS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgQ3VzdG9tIHRleHQgc2FuaXRpemluZyBzdHJhdGVneVxuICAgICAqIEB0aHJvd3MgRXJyb3IgaWYgZG9jdW1lbnRzIGhhdmUgYWxyZWFkeSBiZWVuIGluZGV4ZWQgYnkgdGhpcyBzZWFyY2ggaW5zdGFuY2VcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzYW5pdGl6ZXJcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdJU2FuaXRpemVyIGNhbm5vdCBiZSBzZXQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Nhbml0aXplciA9IHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2FuaXRpemVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBzZWFyY2ggaW5kZXggc3RyYXRlZ3kuXG4gICAgICogQHBhcmFtIHZhbHVlIEN1c3RvbSBzZWFyY2ggaW5kZXggc3RyYXRlZ3lcbiAgICAgKiBAdGhyb3dzIEVycm9yIGlmIGRvY3VtZW50cyBoYXZlIGFscmVhZHkgYmVlbiBpbmRleGVkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2VhcmNoSW5kZXhcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdJU2VhcmNoSW5kZXggY2Fubm90IGJlIHNldCBhZnRlciBpbml0aWFsaXphdGlvbicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2VhcmNoSW5kZXggPSB2YWx1ZTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlYXJjaEluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCB0ZXh0IHRva2VuaXppbmcgc3RyYXRlZ3kuXG4gICAgICogQHBhcmFtIHZhbHVlIEN1c3RvbSB0ZXh0IHRva2VuaXppbmcgc3RyYXRlZ3lcbiAgICAgKiBAdGhyb3dzIEVycm9yIGlmIGRvY3VtZW50cyBoYXZlIGFscmVhZHkgYmVlbiBpbmRleGVkIGJ5IHRoaXMgc2VhcmNoIGluc3RhbmNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9rZW5pemVyXCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICB0aHJvdyBFcnJvcignSVRva2VuaXplciBjYW5ub3QgYmUgc2V0IGFmdGVyIGluaXRpYWxpemF0aW9uJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl90b2tlbml6ZXIgPSB2YWx1ZTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuaXplcjtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNlYXJjaDtcbn0oKTtcblxuLyoqXG4gKiBUaGlzIHV0aWxpdHkgaGlnaGxpZ2h0cyB0aGUgb2NjdXJyZW5jZXMgb2YgdG9rZW5zIHdpdGhpbiBhIHN0cmluZyBvZiB0ZXh0LiBJdCBjYW4gYmUgdXNlZCB0byBnaXZlIHZpc3VhbCBpbmRpY2F0b3JzXG4gKiBvZiBtYXRjaCBjcml0ZXJpYSB3aXRoaW4gc2VhcmNoYWJsZSBmaWVsZHMuXG4gKlxuICogPHA+Rm9yIHBlcmZvcm1hbmNlIHB1cnBvc2VzIHRoaXMgaGlnaGxpZ2h0ZXIgb25seSB3b3JrcyB3aXRoIGZ1bGwtd29yZCBvciBwcmVmaXggdG9rZW4gaW5kZXhlcy5cbiAqL1xudmFyIFRva2VuSGlnaGxpZ2h0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRfaW5kZXhTdHJhdGVneSBJbmRleCBzdHJhdGVneSB1c2VkIGJ5IFNlYXJjaFxuICAgKiBAcGFyYW0gb3B0X3Nhbml0aXplciBTYW5pdGl6ZXIgdXNlZCBieSBTZWFyY2hcbiAgICogQHBhcmFtIG9wdF93cmFwcGVyVGFnTmFtZSBPcHRpb25hbCB3cmFwcGVyIHRhZyBuYW1lOyBkZWZhdWx0cyB0byAnbWFyaycgKGUuZy4gPG1hcms+KVxuICAgKi9cbiAgZnVuY3Rpb24gVG9rZW5IaWdobGlnaHRlcihvcHRfaW5kZXhTdHJhdGVneSwgb3B0X3Nhbml0aXplciwgb3B0X3dyYXBwZXJUYWdOYW1lKSB7XG4gICAgdGhpcy5faW5kZXhTdHJhdGVneSA9IG9wdF9pbmRleFN0cmF0ZWd5IHx8IG5ldyBQcmVmaXhJbmRleFN0cmF0ZWd5KCk7XG4gICAgdGhpcy5fc2FuaXRpemVyID0gb3B0X3Nhbml0aXplciB8fCBuZXcgTG93ZXJDYXNlU2FuaXRpemVyKCk7XG4gICAgdGhpcy5fd3JhcHBlclRhZ05hbWUgPSBvcHRfd3JhcHBlclRhZ05hbWUgfHwgJ21hcmsnO1xuICB9XG4gIC8qKlxuICAgKiBIaWdobGlnaHRzIHRva2VuIG9jY3VycmVuY2VzIHdpdGhpbiBhIHN0cmluZyBieSB3cmFwcGluZyB0aGVtIHdpdGggYSBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHRleHQgZS5nLiBcImpvaG4gd2F5bmVcIlxuICAgKiBAcGFyYW0gdG9rZW5zIGUuZy4gW1wid2FcIl1cbiAgICogQHJldHVybnMge3N0cmluZ30gZS5nLiBcImpvaG4gPG1hcms+d2E8L21hcms+eW5lXCJcbiAgICovXG5cbiAgdmFyIF9wcm90byA9IFRva2VuSGlnaGxpZ2h0ZXIucHJvdG90eXBlO1xuICBfcHJvdG8uaGlnaGxpZ2h0ID0gZnVuY3Rpb24gaGlnaGxpZ2h0KHRleHQsIHRva2Vucykge1xuICAgIHZhciB0YWdzTGVuZ3RoID0gdGhpcy5fd3JhcFRleHQoJycpLmxlbmd0aDtcbiAgICB2YXIgdG9rZW5EaWN0aW9uYXJ5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgLy8gQ3JlYXRlIGEgdG9rZW4gbWFwIGZvciBlYXNpZXIgbG9va3VwIGJlbG93LlxuXG4gICAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdGhpcy5fc2FuaXRpemVyLnNhbml0aXplKHRva2Vuc1tpXSk7XG4gICAgICB2YXIgZXhwYW5kZWRUb2tlbnMgPSB0aGlzLl9pbmRleFN0cmF0ZWd5LmV4cGFuZFRva2VuKHRva2VuKTtcbiAgICAgIGZvciAodmFyIGogPSAwLCBudW1FeHBhbmRlZFRva2VucyA9IGV4cGFuZGVkVG9rZW5zLmxlbmd0aDsgaiA8IG51bUV4cGFuZGVkVG9rZW5zOyBqKyspIHtcbiAgICAgICAgdmFyIGV4cGFuZGVkVG9rZW4gPSBleHBhbmRlZFRva2Vuc1tqXTtcbiAgICAgICAgaWYgKCF0b2tlbkRpY3Rpb25hcnlbZXhwYW5kZWRUb2tlbl0pIHtcbiAgICAgICAgICB0b2tlbkRpY3Rpb25hcnlbZXhwYW5kZWRUb2tlbl0gPSBbdG9rZW5dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2VuRGljdGlvbmFyeVtleHBhbmRlZFRva2VuXS5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gVHJhY2sgYWN0dWFsQ3VycmVudFdvcmQgYW5kIHNhbml0aXplZEN1cnJlbnRXb3JkIHNlcGFyYXRlbHkgaW4gY2FzZSB3ZSBlbmNvdW50ZXIgbmVzdGVkIHRhZ3MuXG5cbiAgICB2YXIgYWN0dWFsQ3VycmVudFdvcmQgPSAnJztcbiAgICB2YXIgc2FuaXRpemVkQ3VycmVudFdvcmQgPSAnJztcbiAgICB2YXIgY3VycmVudFdvcmRTdGFydEluZGV4ID0gMDsgLy8gTm90ZSB0aGlzIGFzc3VtZXMgZWl0aGVyIHByZWZpeCBvciBmdWxsIHdvcmQgbWF0Y2hpbmcuXG5cbiAgICBmb3IgKHZhciBpID0gMCwgdGV4dExlbmd0aCA9IHRleHQubGVuZ3RoOyBpIDwgdGV4dExlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hhcmFjdGVyID0gdGV4dC5jaGFyQXQoaSk7XG4gICAgICBpZiAoY2hhcmFjdGVyID09PSAnICcpIHtcbiAgICAgICAgYWN0dWFsQ3VycmVudFdvcmQgPSAnJztcbiAgICAgICAgc2FuaXRpemVkQ3VycmVudFdvcmQgPSAnJztcbiAgICAgICAgY3VycmVudFdvcmRTdGFydEluZGV4ID0gaSArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3R1YWxDdXJyZW50V29yZCArPSBjaGFyYWN0ZXI7XG4gICAgICAgIHNhbml0aXplZEN1cnJlbnRXb3JkICs9IHRoaXMuX3Nhbml0aXplci5zYW5pdGl6ZShjaGFyYWN0ZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuRGljdGlvbmFyeVtzYW5pdGl6ZWRDdXJyZW50V29yZF0gJiYgdG9rZW5EaWN0aW9uYXJ5W3Nhbml0aXplZEN1cnJlbnRXb3JkXS5pbmRleE9mKHNhbml0aXplZEN1cnJlbnRXb3JkKSA+PSAwKSB7XG4gICAgICAgIGFjdHVhbEN1cnJlbnRXb3JkID0gdGhpcy5fd3JhcFRleHQoYWN0dWFsQ3VycmVudFdvcmQpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgY3VycmVudFdvcmRTdGFydEluZGV4KSArIGFjdHVhbEN1cnJlbnRXb3JkICsgdGV4dC5zdWJzdHJpbmcoaSArIDEpO1xuICAgICAgICBpICs9IHRhZ3NMZW5ndGg7XG4gICAgICAgIHRleHRMZW5ndGggKz0gdGFnc0xlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB0ZXh0IHRvIHdyYXBcbiAgICogQHJldHVybnMgVGV4dCB3cmFwcGVkIGJ5IHdyYXBwZXIgdGFnIChlLmcuIFwiZm9vXCIgYmVjb21lcyBcIjxtYXJrPmZvbzwvbWFyaz5cIilcbiAgICogQHByaXZhdGVcbiAgICovO1xuICBfcHJvdG8uX3dyYXBUZXh0ID0gZnVuY3Rpb24gX3dyYXBUZXh0KHRleHQpIHtcbiAgICB2YXIgdGFnTmFtZSA9IHRoaXMuX3dyYXBwZXJUYWdOYW1lO1xuICAgIHJldHVybiBcIjxcIiArIHRhZ05hbWUgKyBcIj5cIiArIHRleHQgKyBcIjwvXCIgKyB0YWdOYW1lICsgXCI+XCI7XG4gIH07XG4gIHJldHVybiBUb2tlbkhpZ2hsaWdodGVyO1xufSgpO1xuZXhwb3J0IHsgQWxsU3Vic3RyaW5nc0luZGV4U3RyYXRlZ3ksIENhc2VTZW5zaXRpdmVTYW5pdGl6ZXIsIEV4YWN0V29yZEluZGV4U3RyYXRlZ3ksIExvd2VyQ2FzZVNhbml0aXplciwgUHJlZml4SW5kZXhTdHJhdGVneSwgU2VhcmNoLCBTaW1wbGVUb2tlbml6ZXIsIFN0ZW1taW5nVG9rZW5pemVyLCBTdG9wV29yZHNNYXAsIFN0b3BXb3Jkc1Rva2VuaXplciwgVGZJZGZTZWFyY2hJbmRleCwgVG9rZW5IaWdobGlnaHRlciwgVW5vcmRlcmVkU2VhcmNoSW5kZXggfTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB2YXIgaGlkZU1lc3NhZ2UgPSBcIk1hcFNlYXJjaE1lc3NhZ2UtbW9kdWxlLS1oaWRlTWVzc2FnZS0tOUxPVXVcIjtcbmV4cG9ydCB2YXIgc2hvd01lc3NhZ2UgPSBcIk1hcFNlYXJjaE1lc3NhZ2UtbW9kdWxlLS1zaG93TWVzc2FnZS0tZWF0TXVcIjsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHt1c2VJbnRsfSBmcm9tICdnYXRzYnktcGx1Z2luLWludGwnO1xuXG5pbXBvcnQgKiBhcyBFWFBMT1JFX0NPUFkgZnJvbSAnLi4vLi4vZGF0YS9jb3B5L2V4cGxvcmUnO1xuaW1wb3J0ICogYXMgc3R5bGVzIGZyb20gJy4vTWFwU2VhcmNoTWVzc2FnZS5tb2R1bGUuc2Nzcyc7XG5cbmludGVyZmFjZSBJU2VhcmNoTWVzc2FnZSB7XG4gICAgaXNTZWFyY2hSZXN1bHRzTnVsbDogYm9vbGVhbjtcbn07XG5cbmNvbnN0IE1hcFNlYXJjaE1lc3NhZ2UgPSAoe2lzU2VhcmNoUmVzdWx0c051bGx9OklTZWFyY2hNZXNzYWdlKSA9PiB7XG4gIGNvbnN0IGludGwgPSB1c2VJbnRsKCk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17aXNTZWFyY2hSZXN1bHRzTnVsbCA/IHN0eWxlcy5zaG93TWVzc2FnZSA6IHN0eWxlcy5oaWRlTWVzc2FnZX0+XG4gICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5NQVAuU0VBUkNIX1JFU1VMVFNfRU1QVFlfTUVTU0FHRSl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBNYXBTZWFyY2hNZXNzYWdlO1xuIiwiaW1wb3J0IE1hcFNlYXJjaE1lc3NhZ2UgZnJvbSAnLi9NYXBTZWFyY2hNZXNzYWdlJztcblxuZXhwb3J0IGRlZmF1bHQgTWFwU2VhcmNoTWVzc2FnZTtcbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbmltcG9ydCBSZWFjdCwge3VzZUVmZmVjdCwgdXNlU3RhdGV9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7TG5nTGF0Qm91bmRzTGlrZX0gZnJvbSAnbWFwbGlicmUtZ2wnO1xuaW1wb3J0IHt1c2VJbnRsfSBmcm9tICdnYXRzYnktcGx1Z2luLWludGwnO1xuaW1wb3J0IHtTZWFyY2h9IGZyb20gJ0B0cnVzc3dvcmtzL3JlYWN0LXVzd2RzJztcbmltcG9ydCB7dXNlV2luZG93U2l6ZX0gZnJvbSAncmVhY3QtdXNlJztcbmltcG9ydCAqIGFzIEpzU2VhcmNoIGZyb20gJ2pzLXNlYXJjaCc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vLi4vZGF0YS9jb25zdGFudHMnO1xuXG5pbXBvcnQgTWFwU2VhcmNoTWVzc2FnZSBmcm9tICcuLi9NYXBTZWFyY2hNZXNzYWdlJztcblxuaW1wb3J0ICogYXMgc3R5bGVzIGZyb20gJy4vTWFwU2VhcmNoLm1vZHVsZS5zY3NzJztcbmltcG9ydCAqIGFzIEVYUExPUkVfQ09QWSBmcm9tICcuLi8uLi9kYXRhL2NvcHkvZXhwbG9yZSc7XG5cbmludGVyZmFjZSBJTWFwU2VhcmNoIHtcbiAgZ29Ub1BsYWNlKGJvdW5kczogTG5nTGF0Qm91bmRzTGlrZSwgaXNUZXJyaXRvcnk6IGJvb2xlYW4sIHNlbGVjdFRyYWN0SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCk6dm9pZDtcbn1cblxuaW50ZXJmYWNlIElTZWFyY2hUcmFjdFJlY29yZCB7XG4gIEdFT0lEMTA6IHN0cmluZztcbiAgSU5UUFRMQVQxMDogc3RyaW5nO1xuICBJTlRQVExPTjEwOiBzdHJpbmc7XG59XG5cbmNvbnN0IE1hcFNlYXJjaCA9ICh7Z29Ub1BsYWNlfTpJTWFwU2VhcmNoKSA9PiB7XG4gIC8vIFN0YXRlIHRvIGhvbGQgaWYgdGhlIHNlYXJjaCByZXN1bHRzIGFyZSBlbXB0eSBvciBub3Q6XG4gIGNvbnN0IFtpc1NlYXJjaFJlc3VsdHNOdWxsLCBzZXRJc1NlYXJjaFJlc3VsdHNOdWxsXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgaW50bCA9IHVzZUludGwoKTtcblxuICAvKipcbiAgICogQXQgY29tcGlsZS10aW1lLCB0aGUgd2lkdGgvaGVpZ2h0IHJldHVybmVkIGJ5IHVzZVdpbmRvd1NpemUgd2lsbCBiZSBYLiBXaGVuIHRoZSBjbGllbnQgcmVxdWVzdHMgdGhlXG4gICAqIGFwcCBvbiBydW4tdGltZSBmcm9tIENETiwgYW5kIHRoZSBhcHAgaHlkcmF0ZXMsIHJlY29uY2lsYXRpb24gbm8gbG9uZ2VyIG9jY3VycyBhbmQgdGhlIGNsaWVudCBpcyBmb3JjZWRcbiAgICogdG8gdXNlIFguXG4gICAqXG4gICAqIFRvIGF2b2lkIHRoaXMsIHdlIHNldCB0aGUgcGxhY2Vob2xkZXIgdGV4dCBhcyBhIHN0YXRlIHZhcmlhYmxlLiBXZSBhbHNvIGNyZWF0ZSBhIHVzZUVmZmVjdCB0aGF0IHVwZGF0ZXNcbiAgICogdGhhdCBzdGF0ZSB3aGVuZW52ZXIgdGhlIHdpZHRoIGNoYW5nZXMuXG4gICAqXG4gICAqL1xuICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB1c2VXaW5kb3dTaXplKCk7XG4gIGNvbnN0IFtwbGFjZWhvbGRlclRleHQsIHNldFBsYWNlaG9sZGVyVGV4dF09IHVzZVN0YXRlKEVYUExPUkVfQ09QWS5NQVAuU0VBUkNIX1BMQUNFSE9MREVSKTtcbiAgY29uc3QgW3RyYWN0U2VhcmNoLCBzZXRUcmFjdFNlYXJjaF0gPSB1c2VTdGF0ZTxKc1NlYXJjaC5TZWFyY2ggfCBudWxsPihudWxsKTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgdHJhY3Qgc2VhcmNoIGRhdGEgYW5kIGxvYWRzIGluIHRoZSBzdGF0ZS5cbiAgICovXG4gIGNvbnN0IGdldFRyYWN0U2VhcmNoRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBzZWFyY2hEYXRhVXJsID0gYCR7Y29uc3RhbnRzLlRJTEVfQkFTRV9VUkx9LyR7Y29uc3RhbnRzLk1BUF9UUkFDVF9TRUFSQ0hfUEFUSH1gO1xuICAgIGZldGNoKHNlYXJjaERhdGFVcmwpXG4gICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c1RleHR9IGVycm9yIHdpdGggc3RhdHVzIGNvZGUgb2YgJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgIC8vIFdlIHVzZSBKc1NlYXJjaCB0byBtYWtlIGl0IGVhc3kgdG8gbG9hZCBhbmQgcXVpY2sgdG8gc2VhcmNoLlxuICAgICAgICAgIGNvbnN0IHNlYXJjaCA9IG5ldyBKc1NlYXJjaC5TZWFyY2goJ0dFT0lEMTAnKTtcbiAgICAgICAgICBzZWFyY2guaW5kZXhTdHJhdGVneSA9IG5ldyBKc1NlYXJjaC5FeGFjdFdvcmRJbmRleFN0cmF0ZWd5KCk7XG4gICAgICAgICAgc2VhcmNoLmFkZEluZGV4KCdHRU9JRDEwJyk7XG4gICAgICAgICAgc2VhcmNoLmFkZERvY3VtZW50cyhkYXRhKTtcbiAgICAgICAgICBzZXRUcmFjdFNlYXJjaChzZWFyY2gpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuYWJsZSB0byByZWFkIHNlYXJjaCB0cmFjdCB0YWJsZTonLCBlcnJvcikpO1xuICB9O1xuXG4gIHVzZUVmZmVjdCggKCkgPT4ge1xuICAgd2lkdGggPiBoZWlnaHQgPyBzZXRQbGFjZWhvbGRlclRleHQoRVhQTE9SRV9DT1BZLk1BUC5TRUFSQ0hfUExBQ0VIT0xERVIpOiBzZXRQbGFjZWhvbGRlclRleHQoRVhQTE9SRV9DT1BZLk1BUC5TRUFSQ0hfUExBQ0VIT0xERVJfTU9CSUxFKTtcbiAgfSwgW3dpZHRoXSk7XG5cbiAgdXNlRWZmZWN0KCgpPT57XG4gICAgZ2V0VHJhY3RTZWFyY2hEYXRhKCk7XG4gIH0sIFtdKTtcblxuICAvKipcbiAgICogU2VhcmNocyBmb3IgYSBnaXZlbiBDZW5zdXMgdHJhY3QgSUQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFjdCB0aGUgMTEgZGlnaXQgdHJhY3QgSUQgYXMgYSBzdHJpbmdcbiAgICovXG4gIGNvbnN0IHNlYXJjaEZvclRyYWN0ID0gYXN5bmMgKHRyYWN0OiBzdHJpbmcpID0+IHtcbiAgICAvLyBXZSBjcmVhdGUgYSBib3VuZGluZyBib3gganVzdCB0byBnZXQgdGhlIHRyYWN0IGluIHRoZSB2aWV3IGJveC5cbiAgICAvLyBUaGUgc2l6ZSBpcyBub3QgaW1wb3J0YW50LlxuICAgIGNvbnN0IEJPVU5ESU5HX0JPWF9TSVpFX0REID0gMC4yO1xuXG4gICAgLy8gQ29udmVydCAxMCBkaWdpdCB0cmFjdHMgdG8gMTEuXG4gICAgY29uc3Qgbm9ybWFsaXplZFRyYWN0SWQgPSB0cmFjdC5sZW5ndGggPT0gMTAgPyAnMCcgKyB0cmFjdCA6IHRyYWN0O1xuXG4gICAgc2V0SXNTZWFyY2hSZXN1bHRzTnVsbCh0cnVlKTtcblxuICAgIGlmICh0cmFjdFNlYXJjaCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdHJhY3RTZWFyY2guc2VhcmNoKG5vcm1hbGl6ZWRUcmFjdElkKTtcbiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBzZWFyY2hUcmFjdFJlY29yZCA9IHJlc3VsdFswXSBhcyBJU2VhcmNoVHJhY3RSZWNvcmQ7XG4gICAgICAgIGNvbnN0IGxhdCA9IE51bWJlcihzZWFyY2hUcmFjdFJlY29yZC5JTlRQVExBVDEwKTtcbiAgICAgICAgY29uc3QgbG9uID0gTnVtYmVyKHNlYXJjaFRyYWN0UmVjb3JkLklOVFBUTE9OMTApO1xuICAgICAgICBjb25zdCBib3VuZGluZ0JveCA9IFtcbiAgICAgICAgICAobGF0IC0gKEJPVU5ESU5HX0JPWF9TSVpFX0REIC8gMikpLnRvU3RyaW5nKCksXG4gICAgICAgICAgKGxhdCArIChCT1VORElOR19CT1hfU0laRV9ERCAvIDIpKS50b1N0cmluZygpLFxuICAgICAgICAgIChsb24gLSAoQk9VTkRJTkdfQk9YX1NJWkVfREQgLyAyKSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAobG9uICsgKEJPVU5ESU5HX0JPWF9TSVpFX0REIC8gMikpLnRvU3RyaW5nKCksXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IFtsYXRNaW4sIGxhdE1heCwgbG9uZ01pbiwgbG9uZ01heF0gPSBib3VuZGluZ0JveDtcbiAgICAgICAgc2V0SXNTZWFyY2hSZXN1bHRzTnVsbChmYWxzZSk7XG5cbiAgICAgICAgLy8gTm93IG1vdmUgdGhlIG1hcCBhbmQgc2VsZWN0IHRoZSB0cmFjdC5cbiAgICAgICAgZ29Ub1BsYWNlKFtbTnVtYmVyKGxvbmdNaW4pLCBOdW1iZXIobGF0TWluKV0sIFtOdW1iZXIobG9uZ01heCksIE51bWJlcihsYXRNYXgpXV0sIGZhbHNlLCBub3JtYWxpemVkVHJhY3RJZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZWFyY2hzIGZvciBhIGdpdmVuIGxvY2F0aW9uIHN1Y2ggYXMgYWRkcmVzcywgemlwLCBldGMuIFRoaXMgbWV0aG9kIHdpbGxcbiAgICogd2lsbCBmZXRjaCBkYXRhIGZyb20gdGhlIFBTTSBBUEkgYW5kIHJldHVybiB0aGUgcmVzdWx0cyBhcyBKU09OIGFuZFxuICAgKiByZXN1bHRzIHRvIFVTIG9ubHkuIElmIHRoZSBkYXRhIGlzIHZhbGlkLCBkZXN0cnVjdHVyZSB0aGUgYm91bmRpbmdCb3hcbiAgICogdmFsdWVzIGZyb20gdGhlIHNlYXJjaCByZXN1bHRzLiBGaW5hbGx5LCBpcyBwYW5zIHRoZSBtYXAgdG8gdGhlIGxvY2F0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoVGVybSB0aGUgbG9jYXRpb24gdG8gc2VhcmNoIGZvclxuICAgKi9cbiAgY29uc3Qgc2VhcmNoRm9yTG9jYXRpb24gPSBhc3luYyAoc2VhcmNoVGVybTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qgc2VhcmNoUmVzdWx0cyA9IGF3YWl0IGZldGNoKFxuICAgICAgICBgaHR0cHM6Ly9ub21pbmF0aW0ub3BlbnN0cmVldG1hcC5vcmcvc2VhcmNoP3E9JHtzZWFyY2hUZXJtfSZmb3JtYXQ9anNvbiZjb3VudHJ5Y29kZXM9dXNgLFxuICAgICAgICB7XG4gICAgICAgICAgbW9kZTogJ2NvcnMnLFxuICAgICAgICB9KVxuICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05ldHdvcmsgcmVzcG9uc2Ugd2FzIG5vdCBPSycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVGhlcmUgaGFzIGJlZW4gYSBwcm9ibGVtIHdpdGggeW91ciBmZXRjaCBvcGVyYXRpb246JywgZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICBjb25zb2xlLmxvZygnTm9taW5hdHVtIHNlYXJjaCByZXN1bHRzOiAnLCBzZWFyY2hSZXN1bHRzKTtcblxuICAgIC8vIElmIHJlc3VsdHMgYXJlIHZhbGlkLCBzZXQgaXNTZWFyY2hSZXN1bHRzTnVsbCB0byBmYWxzZSBhbmQgcGFuIG1hcCB0byBsb2NhdGlvbjpcbiAgICBpZiAoc2VhcmNoUmVzdWx0cyAmJiBzZWFyY2hSZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHNldElzU2VhcmNoUmVzdWx0c051bGwoZmFsc2UpO1xuICAgICAgY29uc3QgW2xhdE1pbiwgbGF0TWF4LCBsb25nTWluLCBsb25nTWF4XSA9IHNlYXJjaFJlc3VsdHNbMF0uYm91bmRpbmdib3g7XG4gICAgICBnb1RvUGxhY2UoW1tOdW1iZXIobG9uZ01pbiksIE51bWJlcihsYXRNaW4pXSwgW051bWJlcihsb25nTWF4KSwgTnVtYmVyKGxhdE1heCldXSwgZmFsc2UsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldElzU2VhcmNoUmVzdWx0c051bGwodHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgIFNlYXJjaGVzIGZvciBhIGdpdmVuIHNlYXJjaCB0ZXJtIHVwb24gY2xpY2tpbmcgb24gdGhlIHNlYXJjaCBidXR0b24uXG4gICAgQHBhcmFtIHtSZWFjdC5Gb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50Pn0gZXZlbnQgdGhlIGNsaWNrIGV2ZW50XG4gICovXG4gIGNvbnN0IG9uU2VhcmNoSGFuZGxlciA9IGFzeW5jIChldmVudDogUmVhY3QuRm9ybUV2ZW50PEhUTUxGb3JtRWxlbWVudD4pID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgY29uc3Qgc2VhcmNoVGVybSA9IChldmVudC5jdXJyZW50VGFyZ2V0LmVsZW1lbnRzLm5hbWVkSXRlbSgnc2VhcmNoJykgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWU7XG5cbiAgICAvLyBJZiB0aGUgc2VhcmNoIHRlcm0gYSBDZW5zdXMgdHJhY3RcbiAgICBjb25zdCBpc1RyYWN0ID0gL15cXGR7MTAsMTF9JC8udGVzdChzZWFyY2hUZXJtKTtcbiAgICBpZiAoaXNUcmFjdCkge1xuICAgICAgc2VhcmNoRm9yVHJhY3Qoc2VhcmNoVGVybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlYXJjaEZvckxvY2F0aW9uKHNlYXJjaFRlcm0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubWFwU2VhcmNoQ29udGFpbmVyfT5cbiAgICAgIDxNYXBTZWFyY2hNZXNzYWdlIGlzU2VhcmNoUmVzdWx0c051bGw9e2lzU2VhcmNoUmVzdWx0c051bGx9IC8+XG4gICAgICA8U2VhcmNoXG4gICAgICAgIHBsYWNlaG9sZGVyPXtpbnRsLmZvcm1hdE1lc3NhZ2UocGxhY2Vob2xkZXJUZXh0KX1cbiAgICAgICAgc2l6ZT1cInNtYWxsXCJcbiAgICAgICAgb25TdWJtaXQ9eyhlKSA9PiBvblNlYXJjaEhhbmRsZXIoZSl9XG4gICAgICAvPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwU2VhcmNoO1xuIiwiaW1wb3J0IE1hcFNlYXJjaCBmcm9tICcuL01hcFNlYXJjaCc7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcFNlYXJjaDtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge1NvdXJjZSwgTGF5ZXJ9IGZyb20gJ3JlYWN0LW1hcC1nbCc7XG5pbXBvcnQge01hcEdlb0pTT05GZWF0dXJlfSBmcm9tICdtYXBsaWJyZS1nbCc7XG5cbi8vIENvbnRleHRzOlxuaW1wb3J0IHt1c2VGbGFnc30gZnJvbSAnLi4vLi4vY29udGV4dHMvRmxhZ0NvbnRleHQnO1xuXG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vLi4vZGF0YS9jb25zdGFudHMnO1xuaW1wb3J0ICogYXMgQ09NTU9OX0NPUFkgZnJvbSAnLi4vLi4vZGF0YS9jb3B5L2NvbW1vbic7XG5cbmludGVyZmFjZSBJTWFwVHJhY3RMYXllcnMge1xuICAgIHNlbGVjdGVkRmVhdHVyZXM6IE1hcEdlb0pTT05GZWF0dXJlW10gfCB1bmRlZmluZWQsXG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGRldGVybWluZSB0aGUgVVJMIGZvciB0aGUgbWFwIHRpbGVzLiBJdCB3aWxsIHJlYWQgaW4gYSBzdHJpbmcgdGhhdCB3aWxsIGRlc2lnbmF0ZSBlaXRoZXJcbiAqIGhpZ2ggb3IgbG93IHRpbGVzLiBJdCB3aWxsIGFsbG93IHRvIG92ZXJpZGUgdGhlIFVSTCB0byB0aGUgcGlwZWxpbmUgc3RhZ2luZyB0aWxlIFVSTCB2aWEgZmVhdHVyZSBmbGFnLlxuICogTGFzdGx5LCBpdCBhbGxvd3MgdG8gc2V0IHRoZSB0aWxlcyB0byBiZSBsb2NhbCBvciB2aWEgdGhlIENETiBhcyB3ZWxsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aWxlc2V0TmFtZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgZmVhdHVyZVVSTEZvclRpbGVzZXROYW1lID0gKHRpbGVzZXROYW1lOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBmbGFncyA9IHVzZUZsYWdzKCk7XG5cbiAgY29uc3QgcGlwZWxpbmVTdGFnaW5nQmFzZVVSTCA9IHByb2Nlc3MuZW52LkdBVFNCWV9DRE5fVElMRVNfQkFTRV9VUkwgK2AvZGF0YS1waXBlbGluZS1zdGFnaW5nYDtcbiAgY29uc3QgWFlaX1NVRkZJWCA9ICd7en0ve3h9L3t5fS5wYmYnO1xuXG4gIGlmICgnc3RhZ2VfaGFzaCcgaW4gZmxhZ3MpIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgc3RhZ2VfaGFzaCBpcyB2YWxpZFxuICAgIGNvbnN0IHJlZ2V4ID0gL15bMC05XXs0fVxcL1thLWYwLTldezQwfSQvO1xuICAgIGlmICghcmVnZXgudGVzdChmbGFnc1snc3RhZ2VfaGFzaCddKSkge1xuICAgICAgY29uc29sZS5lcnJvcihDT01NT05fQ09QWS5DT05TT0xFX0VSUk9SLlNUQUdFX1VSTCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke3BpcGVsaW5lU3RhZ2luZ0Jhc2VVUkx9LyR7ZmxhZ3NbJ3N0YWdlX2hhc2gnXX0vZGF0YS9zY29yZS90aWxlcy8ke3RpbGVzZXROYW1lfS8ke1hZWl9TVUZGSVh9YDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGUgZmVhdHVyZSB0aWxlIGJhc2UgVVJMIGFuZCBwYXRoIGNhbiBlaXRoZXIgcG9pbnQgbG9jYWxseSBvciB0aGUgQ0ROLlxuICAgIC8vIFRoaXMgaXMgc2VsZWN0ZWQgYmFzZWQgb24gdGhlIERBVEFfU09VUkNFIGVudiB2YXJpYWJsZS5cbiAgICBjb25zdCBmZWF0dXJlVGlsZUJhc2VVUkwgPSBjb25zdGFudHMuVElMRV9CQVNFX1VSTDtcbiAgICBjb25zdCBmZWF0dXJlVGlsZVBhdGggPSBjb25zdGFudHMuVElMRV9QQVRIO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIGZlYXR1cmVUaWxlQmFzZVVSTCxcbiAgICAgIGZlYXR1cmVUaWxlUGF0aCxcbiAgICAgIHByb2Nlc3MuZW52LkdBVFNCWV9NQVBfVElMRVNfUEFUSCxcbiAgICAgIHRpbGVzZXROYW1lLFxuICAgICAgWFlaX1NVRkZJWCxcbiAgICBdLmpvaW4oJy8nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCB3aWxsIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgc291cmNlIGFuZCBsYXllcnMgZm9yIHRoZSBjZW5zdXMgbGF5ZXIgb24gdGhlXG4gKiBtYXAuXG4gKlxuICogVGhlcmUgYXJlIHR3byB1c2UgY2FzZXMgaGVyZSwgZWcsIHdoZW4gdGhlIE1hcEJveCB0b2tlbiBpcyBvciBpc24ndCBwcm92aWRlZC4gV2hlbiB0aGUgdG9rZW5cbiAqIGlzIG5vdCBwcm92aWRlZCwgdGhlIG9wZW4tc291cmNlIG1hcCB3aWxsIGJlIHJlbmRlcmVkLiBXaGVuIHRoZSBvcGVuLXNvdXJjZSBtYXAgaXMgcmVuZGVyZWRcbiAqIG9ubHkgdGhlIGludGVyYWN0aXZlIGxheWVycyBhcmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNvbXBvbmVudC4gVGhlIHJlYXNvbiBiZWluZyBpcyB0aGF0IHRoZVxuICogb3RoZXIgbGF5ZXJzIGFyZSBzdXBwbGllZCBieSBoZSBnZXRPU0Jhc2VNYXAgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IHNlbGVjdGVkRmVhdHVyZUlkXG4gKiBAcGFyYW0ge01hcEdlb0pTT05GZWF0dXJlIHwgdW5kZWZpbmVkfSBzZWxlY3RlZEZlYXR1cmVcbiAqIEByZXR1cm4ge1N0eWxlfVxuICovXG5jb25zdCBNYXBUcmFjdExheWVycyA9ICh7XG4gIHNlbGVjdGVkRmVhdHVyZXMsXG59OiBJTWFwVHJhY3RMYXllcnMpID0+IHtcbiAgY29uc3Qgc2VsZWN0ZWRGZWF0dXJlSWRzID0gc2VsZWN0ZWRGZWF0dXJlcyA/IChzZWxlY3RlZEZlYXR1cmVzLm1hcCgoZmVhdCkgPT4gZmVhdC5pZCkpIDogWycnXTtcbiAgY29uc3QgZmlsdGVyID0gWydpbicsIGNvbnN0YW50cy5HRU9JRF9QUk9QRVJUWSwgLi4uc2VsZWN0ZWRGZWF0dXJlSWRzXTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8U291cmNlXG4gICAgICAgIGlkPXtjb25zdGFudHMuTE9XX1pPT01fU09VUkNFX05BTUV9XG4gICAgICAgIHR5cGU9XCJ2ZWN0b3JcIlxuICAgICAgICBwcm9tb3RlSWQ9e2NvbnN0YW50cy5HRU9JRF9QUk9QRVJUWX1cbiAgICAgICAgdGlsZXM9e1tmZWF0dXJlVVJMRm9yVGlsZXNldE5hbWUoJ2xvdycpXX1cbiAgICAgICAgbWF4em9vbT17Y29uc3RhbnRzLkdMT0JBTF9NQVhfWk9PTV9MT1d9XG4gICAgICAgIG1pbnpvb209e2NvbnN0YW50cy5HTE9CQUxfTUlOX1pPT01fTE9XfVxuICAgICAgPlxuXG4gICAgICAgIHsvKiBMb3cgem9vbSBsYXllciAoc3RhdGljKSAtIHByaW9yaXRpemVkIGZlYXR1cmVzIG9ubHkgKi99XG4gICAgICAgIDxMYXllclxuICAgICAgICAgIGlkPXtjb25zdGFudHMuTE9XX1pPT01fTEFZRVJfSUR9XG4gICAgICAgICAgc291cmNlLWxheWVyPXtjb25zdGFudHMuU0NPUkVfU09VUkNFX0xBWUVSfVxuICAgICAgICAgIGZpbHRlcj17Wyc+JywgY29uc3RhbnRzLlNDT1JFX1BST1BFUlRZX0xPVywgY29uc3RhbnRzLlNDT1JFX0JPVU5EQVJZX1RIUkVTSE9MRF19XG4gICAgICAgICAgdHlwZT0nZmlsbCdcbiAgICAgICAgICBwYWludD17e1xuICAgICAgICAgICAgJ2ZpbGwtY29sb3InOiBjb25zdGFudHMuUFJJT1JJVElaRURfRkVBVFVSRV9GSUxMX0NPTE9SLFxuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IGNvbnN0YW50cy5MT1dfWk9PTV9QUklPUklUSVpFRF9GRUFUVVJFX0ZJTExfT1BBQ0lUWX19XG4gICAgICAgICAgbWF4em9vbT17Y29uc3RhbnRzLkdMT0JBTF9NQVhfWk9PTV9MT1d9XG4gICAgICAgICAgbWluem9vbT17Y29uc3RhbnRzLkdMT0JBTF9NSU5fWk9PTV9MT1d9XG4gICAgICAgIC8+XG4gICAgICA8L1NvdXJjZT5cblxuICAgICAgey8qIFRoZSBoaWdoIHpvb20gc291cmNlICovfVxuICAgICAgPFNvdXJjZVxuICAgICAgICBpZD17Y29uc3RhbnRzLkhJR0hfWk9PTV9TT1VSQ0VfTkFNRX1cbiAgICAgICAgdHlwZT1cInZlY3RvclwiXG4gICAgICAgIHByb21vdGVJZD17Y29uc3RhbnRzLkdFT0lEX1BST1BFUlRZfVxuICAgICAgICB0aWxlcz17W2ZlYXR1cmVVUkxGb3JUaWxlc2V0TmFtZSgnaGlnaCcpXX1cbiAgICAgICAgbWF4em9vbT17Y29uc3RhbnRzLkdMT0JBTF9NQVhfWk9PTV9ISUdIfVxuICAgICAgICBtaW56b29tPXtjb25zdGFudHMuR0xPQkFMX01JTl9aT09NX0hJR0h9XG4gICAgICA+XG5cbiAgICAgICAgey8qIEhpZ2ggem9vbSBsYXllciAoc3RhdGljKSAtIG5vbi1wcmlvcml0aXplZCBmZWF0dXJlcyBvbmx5ICovfVxuICAgICAgICA8TGF5ZXJcbiAgICAgICAgICBpZD17Y29uc3RhbnRzLkhJR0hfWk9PTV9MQVlFUl9JRH1cbiAgICAgICAgICBzb3VyY2UtbGF5ZXI9e2NvbnN0YW50cy5TQ09SRV9TT1VSQ0VfTEFZRVJ9XG4gICAgICAgICAgZmlsdGVyPXtbJz09JywgY29uc3RhbnRzLlNDT1JFX1BST1BFUlRZX0hJR0gsIGZhbHNlXX1cbiAgICAgICAgICB0eXBlPSdmaWxsJ1xuICAgICAgICAgIHBhaW50PXt7XG4gICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogY29uc3RhbnRzLk5PTl9QUklPUklUSVpFRF9GRUFUVVJFX0ZJTExfT1BBQ0lUWSxcbiAgICAgICAgICB9fVxuICAgICAgICAgIG1pbnpvb209e2NvbnN0YW50cy5HTE9CQUxfTUlOX1pPT01fSElHSH1cbiAgICAgICAgLz5cblxuICAgICAgICB7LyogSGlnaCB6b29tIGxheWVyIChzdGF0aWMpIC0gcHJpb3JpdGl6ZWQgZmVhdHVyZXMgb25seSAqL31cbiAgICAgICAgPExheWVyXG4gICAgICAgICAgaWQ9e2NvbnN0YW50cy5QUklPUklUSVpFRF9ISUdIX1pPT01fTEFZRVJfSUR9XG4gICAgICAgICAgc291cmNlLWxheWVyPXtjb25zdGFudHMuU0NPUkVfU09VUkNFX0xBWUVSfVxuICAgICAgICAgIGZpbHRlcj17Wyc9PScsIGNvbnN0YW50cy5TQ09SRV9QUk9QRVJUWV9ISUdILCB0cnVlXX1cbiAgICAgICAgICB0eXBlPSdmaWxsJ1xuICAgICAgICAgIHBhaW50PXt7XG4gICAgICAgICAgICAnZmlsbC1jb2xvcic6IGNvbnN0YW50cy5QUklPUklUSVpFRF9GRUFUVVJFX0ZJTExfQ09MT1IsXG4gICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogY29uc3RhbnRzLkhJR0hfWk9PTV9QUklPUklUSVpFRF9GRUFUVVJFX0ZJTExfT1BBQ0lUWSxcbiAgICAgICAgICB9fVxuICAgICAgICAgIG1pbnpvb209e2NvbnN0YW50cy5HTE9CQUxfTUlOX1pPT01fSElHSH1cbiAgICAgICAgLz5cblxuICAgICAgICB7LyogSGlnaCB6b29tIGxheWVyIChzdGF0aWMpIC0gZ3JhbmRmYXRoZXJlZCBmZWF0dXJlcyBvbmx5ICovfVxuICAgICAgICA8TGF5ZXJcbiAgICAgICAgICBpZD17Y29uc3RhbnRzLkdSQU5ERkFUSEVSRURfSElHSF9aT09NX0xBWUVSX0lEfVxuICAgICAgICAgIHNvdXJjZS1sYXllcj17Y29uc3RhbnRzLlNDT1JFX1NPVVJDRV9MQVlFUn1cbiAgICAgICAgICBmaWx0ZXI9e1snPT0nLCBjb25zdGFudHMuSVNfR1JBTkRGQVRIRVJFRCwgdHJ1ZV19XG4gICAgICAgICAgdHlwZT0nZmlsbCdcbiAgICAgICAgICBwYWludD17e1xuICAgICAgICAgICAgJ2ZpbGwtY29sb3InOiBjb25zdGFudHMuR1JBTkRGQVRIRVJFRF9GRUFUVVJFX0ZJTExfQ09MT1IsXG4gICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogY29uc3RhbnRzLkhJR0hfWk9PTV9QUklPUklUSVpFRF9GRUFUVVJFX0ZJTExfT1BBQ0lUWSxcbiAgICAgICAgICB9fVxuICAgICAgICAgIG1pbnpvb209e2NvbnN0YW50cy5HTE9CQUxfTUlOX1pPT01fSElHSH1cbiAgICAgICAgLz5cblxuICAgICAgICB7LyogSGlnaCB6b29tIGxheWVyIChzdGF0aWMpIC0gY29udHJvbHMgdGhlIGJvcmRlciBiZXR3ZWVuIGZlYXR1cmVzICovfVxuICAgICAgICA8TGF5ZXJcbiAgICAgICAgICBpZD17Y29uc3RhbnRzLkZFQVRVUkVfQk9SREVSX0xBWUVSX0lEfVxuICAgICAgICAgIHNvdXJjZS1sYXllcj17Y29uc3RhbnRzLlNDT1JFX1NPVVJDRV9MQVlFUn1cbiAgICAgICAgICB0eXBlPSdsaW5lJ1xuICAgICAgICAgIHBhaW50PXt7XG4gICAgICAgICAgICAnbGluZS1jb2xvcic6IGNvbnN0YW50cy5GRUFUVVJFX0JPUkRFUl9DT0xPUixcbiAgICAgICAgICAgICdsaW5lLXdpZHRoJzogY29uc3RhbnRzLkZFQVRVUkVfQk9SREVSX1dJRFRILFxuICAgICAgICAgICAgJ2xpbmUtb3BhY2l0eSc6IGNvbnN0YW50cy5GRUFUVVJFX0JPUkRFUl9PUEFDSVRZLFxuICAgICAgICAgIH19XG4gICAgICAgICAgbWF4em9vbT17Y29uc3RhbnRzLkdMT0JBTF9NQVhfWk9PTV9GRUFUVVJFX0JPUkRFUn1cbiAgICAgICAgICBtaW56b29tPXtjb25zdGFudHMuR0xPQkFMX01JTl9aT09NX0ZFQVRVUkVfQk9SREVSfVxuICAgICAgICAvPlxuXG4gICAgICAgIHsvKiBIaWdoIHpvb20gbGF5ZXIgKGR5bmFtaWMpIC0gYm9yZGVyIHN0eWxpbmcgYXJvdW5kIHRoZSBzZWxlY3RlZCBmZWF0dXJlICovfVxuICAgICAgICA8TGF5ZXJcbiAgICAgICAgICBpZD17Y29uc3RhbnRzLlNFTEVDVEVEX0ZFQVRVUkVfQk9SREVSX0xBWUVSX0lEfVxuICAgICAgICAgIHNvdXJjZS1sYXllcj17Y29uc3RhbnRzLlNDT1JFX1NPVVJDRV9MQVlFUn1cbiAgICAgICAgICBmaWx0ZXI9e2ZpbHRlcn0gLy8gVGhpcyBmaWx0ZXIgZmlsdGVycyBvdXQgYWxsIG90aGVyIGZlYXR1cmVzIGV4Y2VwdCB0aGUgc2VsZWN0ZWQgZmVhdHVyZS5cbiAgICAgICAgICB0eXBlPSdsaW5lJ1xuICAgICAgICAgIHBhaW50PXt7XG4gICAgICAgICAgICAnbGluZS1jb2xvcic6IGNvbnN0YW50cy5TRUxFQ1RFRF9GRUFUVVJFX0JPUkRFUl9DT0xPUixcbiAgICAgICAgICAgICdsaW5lLXdpZHRoJzogY29uc3RhbnRzLlNFTEVDVEVEX0ZFQVRVUkVfQk9SREVSX1dJRFRILFxuICAgICAgICAgIH19XG4gICAgICAgICAgbWluem9vbT17Y29uc3RhbnRzLkdMT0JBTF9NSU5fWk9PTV9ISUdIfVxuICAgICAgICAvPlxuICAgICAgPC9Tb3VyY2U+XG4gICAgPC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBNYXBUcmFjdExheWVycztcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge1NvdXJjZSwgTGF5ZXJ9IGZyb20gJ3JlYWN0LW1hcC1nbCc7XG5cbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi8uLi9kYXRhL2NvbnN0YW50cyc7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGRldGVybWluZSB0aGUgVVJMIGZvciB0aGUgdHJpYmFsIHRpbGVzLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgdHJpYmFsVVJMID0gKCk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGZlYXR1cmVUaWxlQmFzZVVSTCA9IGNvbnN0YW50cy5USUxFX0JBU0VfVVJMO1xuICBjb25zdCBmZWF0dXJlVGlsZVBhdGggPSBjb25zdGFudHMuR0FUU0JZX0RBVEFfUElQRUxJTkVfVFJJQkFMX1BBVEg7XG4gIGNvbnN0IFhZWl9TVUZGSVggPSAne3p9L3t4fS97eX0ucGJmJztcblxuICByZXR1cm4gW1xuICAgIGZlYXR1cmVUaWxlQmFzZVVSTCxcbiAgICBmZWF0dXJlVGlsZVBhdGgsXG4gICAgcHJvY2Vzcy5lbnYuR0FUU0JZX01BUF9USUxFU19QQVRILFxuICAgIFhZWl9TVUZGSVgsXG4gIF0uam9pbignLycpO1xufTtcblxuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHdpbGwgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBzb3VyY2UgYW5kIGxheWVycyBmb3IgdGhlIHRyaWJhbCBsYXllciBvbiB0aGVcbiAqIG1hcC5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIHVzZSBjYXNlcyBoZXJlLCBlZywgd2hlbiB0aGUgTWFwQm94IHRva2VuIGlzIG9yIGlzbid0IHByb3ZpZGVkLiBXaGVuIHRoZSB0b2tlblxuICogaXMgbm90IHByb3ZpZGVkLCB0aGUgb3Blbi1zb3VyY2UgbWFwIHdpbGwgYmUgcmVuZGVyZWQuIFdoZW4gdGhlIG9wZW4tc291cmNlIG1hcCBpcyByZW5kZXJlZFxuICogb25seSB0aGUgaW50ZXJhY3RpdmUgbGF5ZXJzIGFyZSByZXR1cm5lZCBmcm9tIHRoaXMgY29tcG9uZW50LiBUaGUgcmVhc29uIGJlaW5nIGlzIHRoYXQgdGhlXG4gKiBvdGhlciBsYXllcnMgYXJlIHN1cHBsaWVkIGJ5IGhlIGdldE9TQmFzZU1hcCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gc2VsZWN0ZWRGZWF0dXJlSWRcbiAqIEBwYXJhbSB7TWFwR2VvSlNPTkZlYXR1cmUgfCB1bmRlZmluZWR9IHNlbGVjdGVkRmVhdHVyZVxuICogQHJldHVybiB7U3R5bGV9XG4gKi9cbmNvbnN0IE1hcFRyaWJhbExheWVyID0gKCkgPT4ge1xuICByZXR1cm4gKFxuXG4gICAgLy8gSW4gdGhpcyBjYXNlIHRoZSBNYXBCb3ggdG9rZW4gaXMgZm91bmQgYW5kIEFMTCBzb3VyY2UocykvbGF5ZXIocykgYXJlIHJldHVybmVkLlxuICAgIDxTb3VyY2VcbiAgICAgIGlkPXtjb25zdGFudHMuVFJJQkFMX1NPVVJDRV9OQU1FfVxuICAgICAgdHlwZT1cInZlY3RvclwiXG4gICAgICBwcm9tb3RlSWQ9e2NvbnN0YW50cy5UUklCQUxfSUR9XG4gICAgICB0aWxlcz17W3RyaWJhbFVSTCgpXX1cbiAgICA+XG5cbiAgICAgIHsvKiBUcmliYWwgbGF5ZXIgKi99XG4gICAgICA8TGF5ZXJcbiAgICAgICAgaWQ9e2NvbnN0YW50cy5UUklCQUxfTEFZRVJfSUR9XG4gICAgICAgIHNvdXJjZS1sYXllcj17Y29uc3RhbnRzLlRSSUJBTF9TT1VSQ0VfTEFZRVJ9XG4gICAgICAgIHR5cGU9J2ZpbGwnXG4gICAgICAgIHBhaW50PXt7XG4gICAgICAgICAgJ2ZpbGwtY29sb3InOiBjb25zdGFudHMuUFJJT1JJVElaRURfRkVBVFVSRV9GSUxMX0NPTE9SLFxuICAgICAgICAgICdmaWxsLW9wYWNpdHknOiBjb25zdGFudHMuVFJJQkFMX0ZFQVRVUkVfRklMTF9PUEFDSVRZfX1cbiAgICAgICAgbWluem9vbT17Y29uc3RhbnRzLlRSSUJBTF9NSU5fWk9PTX1cbiAgICAgICAgbWF4em9vbT17Y29uc3RhbnRzLlRSSUJBTF9NQVhfWk9PTX1cbiAgICAgIC8+XG5cbiAgICAgIHsvKiBUcmliYWwgbGF5ZXIgLSBjb250cm9scyB0aGUgYm9yZGVyIGJldHdlZW4gZmVhdHVyZXMgKi99XG4gICAgICA8TGF5ZXJcbiAgICAgICAgaWQ9e2NvbnN0YW50cy5GRUFUVVJFX0JPUkRFUl9MQVlFUl9JRH1cbiAgICAgICAgc291cmNlLWxheWVyPXtjb25zdGFudHMuVFJJQkFMX1NPVVJDRV9MQVlFUn1cbiAgICAgICAgdHlwZT0nbGluZSdcbiAgICAgICAgcGFpbnQ9e3tcbiAgICAgICAgICAnbGluZS1jb2xvcic6IGNvbnN0YW50cy5GRUFUVVJFX0JPUkRFUl9DT0xPUixcbiAgICAgICAgICAnbGluZS13aWR0aCc6IGNvbnN0YW50cy5GRUFUVVJFX0JPUkRFUl9XSURUSCxcbiAgICAgICAgICAnbGluZS1vcGFjaXR5JzogY29uc3RhbnRzLkZFQVRVUkVfQk9SREVSX09QQUNJVFksXG4gICAgICAgIH19XG4gICAgICAgIG1pbnpvb209e2NvbnN0YW50cy5UUklCQUxfTUlOX1pPT019XG4gICAgICAgIG1heHpvb209e2NvbnN0YW50cy5UUklCQUxfTUFYX1pPT019XG4gICAgICAvPlxuXG4gICAgICB7LyogQWxhc2thIGxheWVyICovfVxuICAgICAgPExheWVyXG4gICAgICAgIGlkPXtjb25zdGFudHMuVFJJQkFMX0FMQVNLQV9QT0lOVFNfTEFZRVJfSUR9XG4gICAgICAgIHNvdXJjZS1sYXllcj17Y29uc3RhbnRzLlRSSUJBTF9TT1VSQ0VfTEFZRVJ9XG4gICAgICAgIGZpbHRlcj17Wyc9PScsIFsnZ2VvbWV0cnktdHlwZSddLCAnUG9pbnQnXX1cbiAgICAgICAgdHlwZT0nY2lyY2xlJ1xuICAgICAgICBwYWludD17e1xuICAgICAgICAgICdjaXJjbGUtcmFkaXVzJzogY29uc3RhbnRzLlRSSUJBTF9BTEFTS0FfQ0lSQ0xFX1JBRElVUyxcbiAgICAgICAgICAnY2lyY2xlLWNvbG9yJzogY29uc3RhbnRzLlRSSUJBTF9BTEFTS0FfQ0lSQ0xFX0ZJTExfQ09MT1IsXG4gICAgICAgICAgJ2NpcmNsZS1vcGFjaXR5JzogY29uc3RhbnRzLlRSSUJBTF9GRUFUVVJFX0ZJTExfT1BBQ0lUWSxcbiAgICAgICAgICAnY2lyY2xlLXN0cm9rZS1jb2xvcic6IGNvbnN0YW50cy5UUklCQUxfQk9SREVSX0NPTE9SLFxuICAgICAgICAgICdjaXJjbGUtc3Ryb2tlLXdpZHRoJzogY29uc3RhbnRzLkFMQUtTQV9QT0lOVFNfU1RST0tFX1dJRFRILFxuICAgICAgICAgICdjaXJjbGUtc3Ryb2tlLW9wYWNpdHknOiBjb25zdGFudHMuRkVBVFVSRV9CT1JERVJfT1BBQ0lUWSxcbiAgICAgICAgfX1cbiAgICAgICAgbWluem9vbT17Y29uc3RhbnRzLkFMQVNLQV9NSU5fWk9PTX1cbiAgICAgICAgbWF4em9vbT17Y29uc3RhbnRzLkFMQVNLQV9NQVhfWk9PTX1cbiAgICAgIC8+XG5cbiAgICAgIHsvKiBUcmliYWwgbGFiZWxzIGxheWVyICovfVxuICAgICAgPExheWVyXG4gICAgICAgIGlkPXtjb25zdGFudHMuVFJJQkFMX0xBQkVMU19MQVlFUl9JRH1cbiAgICAgICAgc291cmNlLWxheWVyPXtjb25zdGFudHMuVFJJQkFMX1NPVVJDRV9MQVlFUn1cbiAgICAgICAgdHlwZT0nc3ltYm9sJ1xuICAgICAgICBsYXlvdXQ9e3tcbiAgICAgICAgICAndGV4dC1maWVsZCc6IFtcbiAgICAgICAgICAgICdjYXNlJyxcbiAgICAgICAgICAgIFsnaW4nLCAnIExBUicsIFsnZ2V0JywgY29uc3RhbnRzLkxBTkRfQVJFQV9OQU1FXV0sXG4gICAgICAgICAgICBbJ3NsaWNlJywgWydnZXQnLCBjb25zdGFudHMuTEFORF9BUkVBX05BTUVdLCAwLCBbJy0nLCBbJ2xlbmd0aCcsIFsnZ2V0JywgY29uc3RhbnRzLkxBTkRfQVJFQV9OQU1FXV0sIDRdXSxcbiAgICAgICAgICAgIFsnaW4nLCAnIElSQScsIFsnZ2V0JywgY29uc3RhbnRzLkxBTkRfQVJFQV9OQU1FXV0sXG4gICAgICAgICAgICBbJ3NsaWNlJywgWydnZXQnLCBjb25zdGFudHMuTEFORF9BUkVBX05BTUVdLCAwLCBbJy0nLCBbJ2xlbmd0aCcsIFsnZ2V0JywgY29uc3RhbnRzLkxBTkRfQVJFQV9OQU1FXV0sIDRdXSxcbiAgICAgICAgICAgIFsnaW4nLCAnIFRTQScsIFsnZ2V0JywgY29uc3RhbnRzLkxBTkRfQVJFQV9OQU1FXV0sXG4gICAgICAgICAgICBbJ3NsaWNlJywgWydnZXQnLCBjb25zdGFudHMuTEFORF9BUkVBX05BTUVdLCAwLCBbJy0nLCBbJ2xlbmd0aCcsIFsnZ2V0JywgY29uc3RhbnRzLkxBTkRfQVJFQV9OQU1FXV0sIDRdXSxcbiAgICAgICAgICAgIFsnZ2V0JywgY29uc3RhbnRzLkxBTkRfQVJFQV9OQU1FXSxcbiAgICAgICAgICBdLFxuICAgICAgICAgICd0ZXh0LWFuY2hvcic6ICd0b3AnLFxuICAgICAgICAgICd0ZXh0LW9mZnNldCc6IFswLCAxXSxcbiAgICAgICAgICAndGV4dC1zaXplJzogMTIsXG4gICAgICAgICAgJ3RleHQtYWxsb3ctb3ZlcmxhcCc6IGZhbHNlLFxuICAgICAgICAgICd0ZXh0LWlnbm9yZS1wbGFjZW1lbnQnOiBmYWxzZSxcbiAgICAgICAgfX1cbiAgICAgICAgcGFpbnQ9e3tcbiAgICAgICAgICAndGV4dC1jb2xvcic6ICcjMzMzMzMzJyxcbiAgICAgICAgICAndGV4dC1oYWxvLWNvbG9yJzogJyNGRkZGRkYnLFxuICAgICAgICAgICd0ZXh0LWhhbG8td2lkdGgnOiAxLjUsXG4gICAgICAgIH19XG4gICAgICAgIG1pbnpvb209e2NvbnN0YW50cy5UUklCQUxfTUlOX1pPT019XG4gICAgICAgIG1heHpvb209e2NvbnN0YW50cy5UUklCQUxfTUFYX1pPT019XG4gICAgICAvPlxuICAgIDwvU291cmNlPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwVHJpYmFsTGF5ZXI7XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB2YXIgdGVycml0b3J5Rm9jdXNDb250YWluZXIgPSBcInRlcnJpdG9yeUZvY3VzQ29udHJvbC1tb2R1bGUtLXRlcnJpdG9yeUZvY3VzQ29udGFpbmVyLS1YNUExNFwiOyIsImltcG9ydCB7dXNlSW50bH0gZnJvbSAnZ2F0c2J5LXBsdWdpbi1pbnRsJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge01hcEV2ZW50fSBmcm9tICdyZWFjdC1tYXAtZ2wnO1xuXG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi90ZXJyaXRvcnlGb2N1c0NvbnRyb2wubW9kdWxlLnNjc3MnO1xuaW1wb3J0ICogYXMgRVhQTE9SRV9DT1BZIGZyb20gJy4uL2RhdGEvY29weS9leHBsb3JlJztcblxuaW50ZXJmYWNlIElUZXJyaXRvcnlGb2N1c0NvbnRyb2wge1xuICBvbkNsaWNrKGV2ZW50OiBNYXBFdmVudCB8IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEJ1dHRvbkVsZW1lbnQ+KTp2b2lkO1xufVxuXG5cbmNvbnN0IFRlcnJpdG9yeUZvY3VzQ29udHJvbCA9ICh7b25DbGlja306IElUZXJyaXRvcnlGb2N1c0NvbnRyb2wpID0+IHtcbiAgY29uc3QgaW50bCA9IHVzZUludGwoKTtcblxuICBjb25zdCB0ZXJyaXRvcmllcyA9IFtcbiAgICB7XG4gICAgICBzaG9ydDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5NQVAuTE9XRVI0OF9TSE9SVCksXG4gICAgICBsb25nOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLk1BUC5MT1dFUjQ4X0xPTkcpLFxuICAgIH0sXG4gICAge1xuICAgICAgc2hvcnQ6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuTUFQLkFMQVNLQV9TSE9SVCksXG4gICAgICBsb25nOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLk1BUC5BTEFTS0FfTE9ORyksXG4gICAgfSxcbiAgICB7XG4gICAgICBzaG9ydDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5NQVAuSEFXQUlJX1NIT1JUKSxcbiAgICAgIGxvbmc6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuTUFQLkhBV0FJSV9MT05HKSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHNob3J0OiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLk1BUC5QUl9TSE9SVCksXG4gICAgICBsb25nOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLk1BUC5QUl9MT05HKSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHNob3J0OiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLk1BUC5HVV9TSE9SVCksXG4gICAgICBsb25nOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLk1BUC5HVV9MT05HKSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHNob3J0OiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLk1BUC5BU19TSE9SVCksXG4gICAgICBsb25nOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLk1BUC5BU19MT05HKSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHNob3J0OiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLk1BUC5NUF9TSE9SVCksXG4gICAgICBsb25nOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLk1BUC5NUF9MT05HKSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHNob3J0OiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLk1BUC5WSV9TSE9SVCksXG4gICAgICBsb25nOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLk1BUC5WSV9MT05HKSxcbiAgICB9LFxuICBdO1xuICAvLyB0aGUgb2Zmc2V0IGZvciB0aGlzIGFycmF5IHNob3VsZCBtYXAgdGhlIHRlcnJpdG9yaWVzIHZhcmlhYmxlXG4gIGNvbnN0IHRlcnJpdG9yaWVzSWNvbkNsYXNzTmFtZSA9IFtcbiAgICAnbWFwYm94Z2wtY3RybC16b29tLXRvLTQ4JyxcbiAgICAnbWFwYm94Z2wtY3RybC16b29tLXRvLWFrJyxcbiAgICAnbWFwYm94Z2wtY3RybC16b29tLXRvLWhpJyxcbiAgICAnbWFwYm94Z2wtY3RybC16b29tLXRvLXByJyxcbiAgICAnbWFwYm94Z2wtY3RybC16b29tLXRvLWd1JyxcbiAgICAnbWFwYm94Z2wtY3RybC16b29tLXRvLWFzJyxcbiAgICAnbWFwYm94Z2wtY3RybC16b29tLXRvLW1wJyxcbiAgICAnbWFwYm94Z2wtY3RybC16b29tLXRvLXZpJyxcbiAgXTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudGVycml0b3J5Rm9jdXNDb250YWluZXJ9PlxuICAgICAgPGRpdiBjbGFzc05hbWU9eydtYXBib3hnbC1jdHJsIG1hcGJveGdsLWN0cmwtZ3JvdXAnfT5cbiAgICAgICAge3RlcnJpdG9yaWVzLm1hcCgodGVycml0b3J5LCBpbmRleCkgPT5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBpZD17dGVycml0b3J5LnNob3J0fVxuICAgICAgICAgICAga2V5PXt0ZXJyaXRvcnkuc2hvcnR9XG4gICAgICAgICAgICAvLyBvbkNsaWNrQ2FwdHVyZT17KGUpID0+IG9uQ2xpY2tUZXJyaXRvcnlGb2N1c0J1dHRvbihlKX1cbiAgICAgICAgICAgIG9uQ2xpY2tDYXB0dXJlPXsoZSkgPT4gb25DbGljayhlKX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17J21hcGJveGdsLWN0cmwtaWNvbiAnICsgdGVycml0b3JpZXNJY29uQ2xhc3NOYW1lW2luZGV4XX1cbiAgICAgICAgICAgIHRpdGxlPXt0ZXJyaXRvcmllc1tpbmRleF0ubG9uZ31cbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e2ludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZDogJ21hcC50ZXJyaXRvcnlGb2N1cy5mb2N1c09uJyxcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHRNZXNzYWdlOiAnRm9jdXMgb24ge3RlcnJpdG9yeX0nLFxuICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdGb2N1cyBvbiB0aGUgYm91bmRzIG9mIGEgc3BlY2lmaWMgdGVycml0b3J5JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRlcnJpdG9yeTogdGVycml0b3J5LmxvbmcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICl9PlxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXsnbWFwYm94Z2wtY3RybC1pY29uJ30gYXJpYS1oaWRkZW49e3RydWV9Lz5cbiAgICAgICAgICA8L2J1dHRvbj4sXG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRlcnJpdG9yeUZvY3VzQ29udHJvbDtcblxuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIGZ1bGxzY3JlZW5Db250cm9sID0gXCJKNDBNYXAtbW9kdWxlLS1mdWxsc2NyZWVuQ29udHJvbC0tZ2JZTzBcIjtcbmV4cG9ydCB2YXIgZ2VvbG9jYXRlQm94ID0gXCJKNDBNYXAtbW9kdWxlLS1nZW9sb2NhdGVCb3gtLTVIblNFXCI7XG5leHBvcnQgdmFyIGdlb2xvY2F0ZU1lc3NhZ2UgPSBcIko0ME1hcC1tb2R1bGUtLWdlb2xvY2F0ZU1lc3NhZ2UtLWpEMUdQXCI7XG5leHBvcnQgdmFyIGdlb2xvY2F0ZU1lc3NhZ2VIaWRlID0gXCJKNDBNYXAtbW9kdWxlLS1nZW9sb2NhdGVNZXNzYWdlSGlkZS0tTVU4QnpcIjtcbmV4cG9ydCB2YXIgajQwTWFwID0gXCJKNDBNYXAtbW9kdWxlLS1qNDBNYXAtLURGcjZFXCI7XG5leHBvcnQgdmFyIGo0MFBvcHVwID0gXCJKNDBNYXAtbW9kdWxlLS1qNDBQb3B1cC0tS0xwWExcIjtcbmV4cG9ydCB2YXIgbWFwSGVhZGVyUm93ID0gXCJKNDBNYXAtbW9kdWxlLS1tYXBIZWFkZXJSb3ctLStjdE8tXCI7XG5leHBvcnQgdmFyIG1hcEluZm9QYW5lbCA9IFwiSjQwTWFwLW1vZHVsZS0tbWFwSW5mb1BhbmVsLS1XZEk5ZVwiO1xuZXhwb3J0IHZhciBuYXZpZ2F0aW9uQ29udHJvbCA9IFwiSjQwTWFwLW1vZHVsZS0tbmF2aWdhdGlvbkNvbnRyb2wtLTZ1VU03XCI7IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIGNyZWF0ZVJlcG9ydEJ1dHRvbiA9IFwiQ3JlYXRlUmVwb3J0UGFuZWwtbW9kdWxlLS1jcmVhdGVSZXBvcnRCdXR0b24tLStVc2RzXCI7XG5leHBvcnQgdmFyIGNyZWF0ZVJlcG9ydENvbnRhaW5lciA9IFwiQ3JlYXRlUmVwb3J0UGFuZWwtbW9kdWxlLS1jcmVhdGVSZXBvcnRDb250YWluZXItLXlGajl6XCI7XG5leHBvcnQgdmFyIHN0YXJ0T3ZlciA9IFwiQ3JlYXRlUmVwb3J0UGFuZWwtbW9kdWxlLS1zdGFydE92ZXItLTlzWnVTXCI7XG5leHBvcnQgdmFyIHRyYWN0TGlzdENvbnRhaW5lciA9IFwiQ3JlYXRlUmVwb3J0UGFuZWwtbW9kdWxlLS10cmFjdExpc3RDb250YWluZXItLW8ybmVyXCI7XG5leHBvcnQgdmFyIHRyYWN0TGlzdEl0ZW0gPSBcIkNyZWF0ZVJlcG9ydFBhbmVsLW1vZHVsZS0tdHJhY3RMaXN0SXRlbS0tSk1DYjRcIjtcbmV4cG9ydCB2YXIgdHJhY3RMaXN0SXRlbURlbGV0ZSA9IFwiQ3JlYXRlUmVwb3J0UGFuZWwtbW9kdWxlLS10cmFjdExpc3RJdGVtRGVsZXRlLS1CUzg4V1wiO1xuZXhwb3J0IHZhciB0cmFjdExpc3RJdGVtSGlnaGxpZ2h0ID0gXCJDcmVhdGVSZXBvcnRQYW5lbC1tb2R1bGUtLXRyYWN0TGlzdEl0ZW1IaWdobGlnaHQtLW54WGx5XCI7IiwiZXhwb3J0IGRlZmF1bHQgXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJR2hsYVdkb2REMGlNalFpSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJZ2QybGtkR2c5SWpJMElqNDhjR0YwYUNCa1BTSk5NQ0F3YURJMGRqSTBTREI2SWlCbWFXeHNQU0p1YjI1bElpOCtQSEJoZEdnZ1pEMGlUVEU1SURZdU5ERk1NVGN1TlRrZ05TQXhNaUF4TUM0MU9TQTJMalF4SURVZ05TQTJMalF4SURFd0xqVTVJREV5SURVZ01UY3VOVGtnTmk0ME1TQXhPU0F4TWlBeE15NDBNU0F4Tnk0MU9TQXhPU0F4T1NBeE55NDFPU0F4TXk0ME1TQXhNbm9pTHo0OEwzTjJaejQ9XCIiLCJpbXBvcnQgUmVhY3QsIHt1c2VFZmZlY3QsIHVzZVN0YXRlfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQge01hcEdlb0pTT05GZWF0dXJlfSBmcm9tICdtYXBsaWJyZS1nbCc7XG5pbXBvcnQge0J1dHRvbiwgQWxlcnQsIEdyaWR9IGZyb20gJ0B0cnVzc3dvcmtzL3JlYWN0LXVzd2RzJztcbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuL0NyZWF0ZVJlcG9ydFBhbmVsLm1vZHVsZS5zY3NzJztcblxuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4uLy4uL2RhdGEvY29uc3RhbnRzJztcblxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IGRlbGV0ZUljb24gZnJvbSAnL25vZGVfbW9kdWxlcy91c3dkcy9kaXN0L2ltZy91c2EtaWNvbnMvY2xvc2Uuc3ZnJztcblxuaW50ZXJmYWNlIElDcmVhdGVSZXBvcnRQYW5lbCB7XG4gIGRlbGV0ZVRyYWN0SGFuZGxlcjogKGZlYXR1cmU6IE1hcEdlb0pTT05GZWF0dXJlKSA9PiB2b2lkLFxuICBjbGFzc05hbWU6IHN0cmluZyxcbiAgZXhpdEhhbmRsZXI6ICgpID0+IHZvaWQsXG4gIGZlYXR1cmVMaXN0OiBNYXBHZW9KU09ORmVhdHVyZVtdLFxuICBtYXhOdW1UcmFjdHM6IG51bWJlcixcbiAgc2hvd1Rvb01hbnlUcmFjdHNBbGVydDogYm9vbGVhbixcbn1cblxuY29uc3QgQ3JlYXRlUmVwb3J0UGFuZWwgPSAoe1xuICBjbGFzc05hbWUsXG4gIGZlYXR1cmVMaXN0LFxuICBtYXhOdW1UcmFjdHMsXG4gIHNob3dUb29NYW55VHJhY3RzQWxlcnQsXG4gIGRlbGV0ZVRyYWN0SGFuZGxlcixcbiAgZXhpdEhhbmRsZXIsXG59OiBJQ3JlYXRlUmVwb3J0UGFuZWwsXG4pID0+IHtcbiAgY29uc3QgW251bVByZXZUcmFjdHMsIHNldE51bVByZXZUcmFjdHNdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIElmIGFkZGluZyBhIHRyYWN0IHRoZW4gc2Nyb2xsIHRvIHRoZSBib3R0b20gb2YgdGhlIHRyYWN0IGxpc3QgdG8gYWx3YXlzIHNob3cgdGhlIGxhc3QgYWRkZWQgdHJhY3RcbiAgICBpZiAobnVtUHJldlRyYWN0cyA8IGZlYXR1cmVMaXN0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2o0MC1jcmVhdGUtcmVwb3J0LXRyYWN0LWxpc3QnKTtcbiAgICAgIGlmIChjb250YWluZXIpIGNvbnRhaW5lci5zY3JvbGxUb3AgPSBjb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xuICAgIH1cbiAgICBzZXROdW1QcmV2VHJhY3RzKGZlYXR1cmVMaXN0Lmxlbmd0aCk7XG4gIH0sIFtmZWF0dXJlTGlzdCwgbnVtUHJldlRyYWN0c10pO1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGhlIGNyZWF0aW9uIG9mIGEgcmVwb3J0LlxuICAgKi9cbiAgY29uc3QgaGFuZGxlQ3JlYXRlUmVwb3J0ID0gKCkgPT4ge1xuICAgIGlmIChmZWF0dXJlTGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIFRPRE86IE9uZSB0cmFjdCByZXBvcnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogTXVsdGkgdHJhY3QgcmVwb3J0XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBpZD0nY3JlYXRlLXJlcG9ydC1wYW5lbCcgY2xhc3NOYW1lPXtjbGFzc05hbWV9PlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jcmVhdGVSZXBvcnRDb250YWluZXJ9PlxuICAgICAgICA8aDQ+Q3JlYXRlIFJlcG9ydDwvaDQ+XG4gICAgICAgIHtzaG93VG9vTWFueVRyYWN0c0FsZXJ0ID9cbiAgICAgICAgICA8QWxlcnQgdHlwZT0nZXJyb3InIHNsaW0gaGVhZGluZ0xldmVsPSdoNCc+XG4gICAgICAgICAgICBZb3UgY2FuIG9ubHkgc2VsZWN0IHVwIHRvIHttYXhOdW1UcmFjdHN9IHRyYWN0cyBmb3IgYSByZXBvcnQuXG4gICAgICAgICAgPC9BbGVydD4gOlxuICAgICAgICAgIDxBbGVydCB0eXBlPSdpbmZvJyBzbGltIGhlYWRpbmdMZXZlbD0naDQnPlxuICAgICAgICAgICAgU2VsZWN0IDxzdHJvbmc+dXAgdG8ge21heE51bVRyYWN0c308L3N0cm9uZz4gdHJhY3RzIGluIHRoZSBtYXBcbiAgICAgICAgICA8L0FsZXJ0PlxuICAgICAgICB9XG4gICAgICAgIDxwPlxuICAgICAgICAgIDxzcGFuPjxzdHJvbmc+e2ZlYXR1cmVMaXN0Lmxlbmd0aH0gdHJhY3R7ZmVhdHVyZUxpc3QubGVuZ3RoID09PSAxID8gJycgOiAncyd9PC9zdHJvbmc+IHNlbGVjdGVkPC9zcGFuPlxuICAgICAgICA8L3A+XG4gICAgICAgIDxkaXYgaWQ9J2o0MC1jcmVhdGUtcmVwb3J0LXRyYWN0LWxpc3QnIGNsYXNzTmFtZT17c3R5bGVzLnRyYWN0TGlzdENvbnRhaW5lcn0+XG4gICAgICAgICAge2ZlYXR1cmVMaXN0Lm1hcCgoaXRlbSwgaW5kZXgpID0+IChcbiAgICAgICAgICAgIDxHcmlkIHJvdyBrZXk9e2luZGV4fVxuICAgICAgICAgICAgICBjbGFzc05hbWU9e2luZGV4ID09PSBmZWF0dXJlTGlzdC5sZW5ndGggLSAxID8gc3R5bGVzLnRyYWN0TGlzdEl0ZW1IaWdobGlnaHQgOiBzdHlsZXMudHJhY3RMaXN0SXRlbX0+XG4gICAgICAgICAgICAgIDxHcmlkIGNvbD1cImF1dG9cIj5cbiAgICAgICAgICAgICAgICB7aXRlbS5pZH0sIHtpdGVtLnByb3BlcnRpZXNbY29uc3RhbnRzLlNUQVRFX05BTUVdfTwvR3JpZD5cbiAgICAgICAgICAgICAgPEdyaWQgY29sPVwiZmlsbFwiIC8+XG4gICAgICAgICAgICAgIDxHcmlkIGNvbD1cImF1dG9cIiBjbGFzc05hbWU9e3N0eWxlcy50cmFjdExpc3RJdGVtRGVsZXRlfT5cbiAgICAgICAgICAgICAgICA8QnV0dG9uIHR5cGU9J2J1dHRvbicgdW5zdHlsZWRcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGRlbGV0ZVRyYWN0SGFuZGxlcihpdGVtKX0+XG4gICAgICAgICAgICAgICAgICA8aW1nIHRhYkluZGV4PXswfSBzcmM9e2RlbGV0ZUljb259XG4gICAgICAgICAgICAgICAgICAgIGFsdD0nTmVlZCBhbHQgbWVzc2FnZSdcbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgIDwvR3JpZD5cbiAgICAgICAgICAgIDwvR3JpZD5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY3JlYXRlUmVwb3J0QnV0dG9ufSA+XG4gICAgICAgICAgPEJ1dHRvbiB0eXBlPSdidXR0b24nIG9uQ2xpY2s9e2hhbmRsZUNyZWF0ZVJlcG9ydH1cbiAgICAgICAgICAgIGRpc2FibGVkPXtmZWF0dXJlTGlzdC5sZW5ndGggPT0gMH0+Q3JlYXRlIFJlcG9ydDwvQnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zdGFydE92ZXJ9PlxuICAgICAgICAgIDxCdXR0b24gdHlwZT0nYnV0dG9uJyB1bnN0eWxlZCBvbkNsaWNrPXtleGl0SGFuZGxlcn0+U3RhcnQgT3ZlcjwvQnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ3JlYXRlUmVwb3J0UGFuZWw7XG4iLCJpbXBvcnQgQ3JlYXRlUmVwb3J0UGFuZWwgZnJvbSAnLi9DcmVhdGVSZXBvcnRQYW5lbCc7XG5cbmV4cG9ydCBkZWZhdWx0IENyZWF0ZVJlcG9ydFBhbmVsO1xuIiwiLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vLyBFeHRlcm5hbCBMaWJzOlxuaW1wb3J0IFJlYWN0LCB7dXNlUmVmLCB1c2VTdGF0ZX0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtNYXAsIE1hcEdlb0pTT05GZWF0dXJlLCBMbmdMYXRCb3VuZHNMaWtlfSBmcm9tICdtYXBsaWJyZS1nbCc7XG5pbXBvcnQgUmVhY3RNYXBHTCwge1xuICBNYXBFdmVudCxcbiAgVmlld3BvcnRQcm9wcyxcbiAgV2ViTWVyY2F0b3JWaWV3cG9ydCxcbiAgTmF2aWdhdGlvbkNvbnRyb2wsXG4gIEdlb2xvY2F0ZUNvbnRyb2wsXG4gIFBvcHVwLFxuICBGbHlUb0ludGVycG9sYXRvcixcbiAgRnVsbHNjcmVlbkNvbnRyb2wsXG4gIE1hcFJlZixcbn0gZnJvbSAncmVhY3QtbWFwLWdsJztcbmltcG9ydCB7dXNlSW50bH0gZnJvbSAnZ2F0c2J5LXBsdWdpbi1pbnRsJztcbmltcG9ydCBiYm94IGZyb20gJ0B0dXJmL2Jib3gnO1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMtZWFzZSc7XG5pbXBvcnQge2lzTW9iaWxlfSBmcm9tICdyZWFjdC1kZXZpY2UtZGV0ZWN0JztcbmltcG9ydCB7R3JpZH0gZnJvbSAnQHRydXNzd29ya3MvcmVhY3QtdXN3ZHMnO1xuaW1wb3J0IHt1c2VXaW5kb3dTaXplLCB1c2VMb2NhbFN0b3JhZ2V9IGZyb20gJ3JlYWN0LXVzZSc7XG5cbi8vIENvbnRleHRzOlxuaW1wb3J0IHt1c2VGbGFnc30gZnJvbSAnLi4vY29udGV4dHMvRmxhZ0NvbnRleHQnO1xuXG4vLyBDb21wb25lbnRzOlxuaW1wb3J0IEFyZWFEZXRhaWwgZnJvbSAnLi9BcmVhRGV0YWlsJztcbmltcG9ydCBNYXBJbmZvUGFuZWwgZnJvbSAnLi9tYXBJbmZvUGFuZWwnO1xuaW1wb3J0IE1hcFNlYXJjaCBmcm9tICcuL01hcFNlYXJjaCc7XG5pbXBvcnQgTWFwVHJhY3RMYXllcnMgZnJvbSAnLi9NYXBUcmFjdExheWVycy9NYXBUcmFjdExheWVycyc7XG5pbXBvcnQgTWFwVHJpYmFsTGF5ZXIgZnJvbSAnLi9NYXBUcmliYWxMYXllcnMvTWFwVHJpYmFsTGF5ZXJzJztcbmltcG9ydCBUZXJyaXRvcnlGb2N1c0NvbnRyb2wgZnJvbSAnLi90ZXJyaXRvcnlGb2N1c0NvbnRyb2wnO1xuXG4vLyBTdHlsZXMgYW5kIGNvbnN0YW50c1xuaW1wb3J0ICdtYXBsaWJyZS1nbC9kaXN0L21hcGxpYnJlLWdsLmNzcyc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vZGF0YS9jb25zdGFudHMnO1xuaW1wb3J0ICogYXMgc3R5bGVzIGZyb20gJy4vSjQwTWFwLm1vZHVsZS5zY3NzJztcbmltcG9ydCAqIGFzIEVYUExPUkVfQ09QWSBmcm9tICcuLi9kYXRhL2NvcHkvZXhwbG9yZSc7XG5pbXBvcnQgQ3JlYXRlUmVwb3J0UGFuZWwgZnJvbSAnLi9DcmVhdGVSZXBvcnRQYW5lbCc7XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgQ3lwcmVzcz86IG9iamVjdDtcbiAgICB1bmRlcmx5aW5nTWFwOiBNYXA7XG4gIH1cbn1cblxuaW50ZXJmYWNlIElKNDBJbnRlcmZhY2Uge1xuICBsb2NhdGlvbjogTG9jYXRpb247XG59O1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgSURldGFpbFZpZXdJbnRlcmZhY2Uge1xuICBsYXRpdHVkZTogbnVtYmVyXG4gIGxvbmdpdHVkZTogbnVtYmVyXG4gIHpvb206IG51bWJlclxuICBwcm9wZXJ0aWVzOiBjb25zdGFudHMuSjQwUHJvcGVydGllcyxcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgSU1hcEZlYXR1cmUge1xuICBpZDogc3RyaW5nO1xuICBnZW9tZXRyeTogYW55O1xuICBwcm9wZXJ0aWVzOiBhbnk7XG4gIHR5cGU6IHN0cmluZztcbn1cblxuY29uc3QgTUFYX1NFTEVDVEVEX1RSQUNUUyA9IDIwO1xuXG5jb25zdCBKNDBNYXAgPSAoe2xvY2F0aW9ufTogSUo0MEludGVyZmFjZSkgPT4ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHpvb20sIGFuZCB0aGUgbWFwJ3MgY2VudGVyIHBvaW50IChsYXQsIGxuZykgdmlhIHRoZSBVUkwgaGFzaCAje3p9L3tsYXR9L3tsb25nfVxuICAgKiB3aGVyZVxuICAgKiAgQFRPRE86IFRoZXNlIHZhbHVlcyBkbyBub3QgdXBkYXRlIHdoZW4gem9vbWluZyBpbi9vdXQuIENvdWxkIGV4cGxhaW4gYSBudW1iZXIgb2YgY3lwcmVzcyBidWdzXG4gICAqICByZWZlcmVuY2UgdG8gdGlja2V0ICMxNTUwXG4gICAqXG4gICAqICAgIHogPSB6b29tXG4gICAqICAgIGxhdCA9IG1hcCBjZW50ZXIncyBsYXRpdHVkZVxuICAgKiAgICBsb25nID0gbWFwIGNlbnRlcidzIGxvbmdpdHVkZVxuICAgKi9cbiAgY29uc3QgW3pvb20sIGxhdCwgbG5nXSA9IGxvY2F0aW9uLmhhc2guc2xpY2UoMSkuc3BsaXQoJy8nKTtcblxuICAvKipcbiAgICogSWYgdGhlIFVSTCBoYXMgbm8gI3t6fS97bGF0fS97bG9uZ30gc3BlY2lmaWVkIGluIHRoZSBoYXNoLCB0aGVuIHNldCB0aGUgbWFwJ3MgaW50aWFsIHZpZXdwb3J0IHN0YXRlXG4gICAqIHRvIHVzZSBjb25zdGFudHMuIFRoaXMgaXMgc28gdGhhdCB3ZSBjYW4gbG9hZCBVUkxzIHdpdGggY2VydGFpbiB6b29tL2xhdC9sb25nIHNwZWNpZmllZDpcbiAgICovXG4gIGNvbnN0IFt2aWV3cG9ydCwgc2V0Vmlld3BvcnRdID0gdXNlU3RhdGU8Vmlld3BvcnRQcm9wcz4oe1xuICAgIGxhdGl0dWRlOiBsYXQgJiYgcGFyc2VGbG9hdChsYXQpID8gcGFyc2VGbG9hdChsYXQpIDogY29uc3RhbnRzLkRFRkFVTFRfQ0VOVEVSWzBdLFxuICAgIGxvbmdpdHVkZTogbG5nICYmIHBhcnNlRmxvYXQobG5nKSA/IHBhcnNlRmxvYXQobG5nKSA6IGNvbnN0YW50cy5ERUZBVUxUX0NFTlRFUlsxXSxcbiAgICB6b29tOiB6b29tICYmIHBhcnNlRmxvYXQoem9vbSkgPyBwYXJzZUZsb2F0KHpvb20pIDogY29uc3RhbnRzLkdMT0JBTF9NSU5fWk9PTSxcbiAgfSk7XG5cbiAgY29uc3QgW3NlbGVjdGVkRmVhdHVyZXMsIHNldFNlbGVjdGVkRmVhdHVyZXNdID0gdXNlU3RhdGU8TWFwR2VvSlNPTkZlYXR1cmVbXT4oW10pO1xuICBjb25zdCBbZGV0YWlsVmlld0RhdGEsIHNldERldGFpbFZpZXdEYXRhXSA9IHVzZVN0YXRlPElEZXRhaWxWaWV3SW50ZXJmYWNlPigpO1xuICBjb25zdCBbdHJhbnNpdGlvbkluUHJvZ3Jlc3MsIHNldFRyYW5zaXRpb25JblByb2dyZXNzXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW2dlb2xvY2F0aW9uSW5Qcm9ncmVzcywgc2V0R2VvbG9jYXRpb25JblByb2dyZXNzXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW2lzTW9iaWxlTWFwU3RhdGUsIHNldElzTW9iaWxlTWFwU3RhdGVdID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICBjb25zdCBbaW5NdWx0aVNlbGVjdE1vZGUsIHNldEluTXVsdGlTZWxlY3RNb2RlXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW3Nob3dUb29NYW55VHJhY3RzQWxlcnQsIHNldFNob3dUb29NYW55VHJhY3RzQWxlcnRdID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICBjb25zdCBbc2VsZWN0VHJhY3RJZCwgc2V0U2VsZWN0VHJhY3RJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG4gIGNvbnN0IHt3aWR0aDogd2luZG93V2lkdGh9ID0gdXNlV2luZG93U2l6ZSgpO1xuXG4gIC8qKlxuICAgKiBTdG9yZSB0aGUgZ2VvbG9jYXRpb24gbG9jayBzdGF0ZSBpbiBsb2NhbCBzdG9yYWdlLiBUaGUgR2VvbG9jYXRpb24gY29tcG9uZW50IGZyb20gTWFwQm94IGRvZXMgbm90XG4gICAqIGV4cG9zZSAoQVBJKSB2YXJpb3VzIGdlb2xvY2F0aW9uIGxvY2svdW5sb2NrIHN0YXRlcyBpbiB0aGUgdmVyc2lvbiB3ZSBhcmUgdXNpbmcuIFRoaXMgbWFrZXMgaXRcbiAgICogY2hhbGxlbmdpbmcgdG8gY2hhbmdlIHRoZSBVSSBzdGF0ZSB0byBtYXRjaCB0aGUgR2VvbG9jYXRpb24gc3RhdGUuIEEgd29yayBhcm91bmQgaXMgdG8gc3RvcmUgdGhlXG4gICAqIGdlb2xvY2F0aW9uIFwibG9ja2VkXCIgc3RhdGUgaW4gbG9jYWwgc3RvcmFnZS4gVGhlIGxvY2FsIHN0b3JhZ2Ugc3RhdGUgd2lsbCB0aGVuIGJlIHVzZWQgdG8gc2hvdyB0aGVcbiAgICogXCJGaW5kaW5nIGxvY2F0aW9uXCIgbWVzc2FnZS4gVGhlIGxvY2FsIHN0b3JhZ2Ugd2lsbCBiZSByZW1vdmVkIGV2ZXJ5dGltZSB0aGUgbWFwIGlzIHJlbG9hZGVkLlxuICAgKlxuICAgKiBUaGUgXCJGaW5kaW5nIGxvY2F0aW9uXCIgbWVzc2FnZSBvbmx5IGFwcGxpZXMgZm9yIGRlc2t0b3AgbGF5b3V0cy5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIGNvbnN0IFtpc0dlb2xvY2F0ZUxvY2tlZCwgc2V0SXNHZW9sb2NhdGVMb2NrZWQsIHJlbW92ZUdlb2xvY2F0ZUxvY2tdID0gdXNlTG9jYWxTdG9yYWdlKCdpcy1nZW9sb2NhdGUtbG9ja2VkJywgZmFsc2UsIHtyYXc6IHRydWV9KTtcblxuICBjb25zdCBtYXBSZWYgPSB1c2VSZWY8TWFwUmVmPihudWxsKTtcbiAgY29uc3QgZmxhZ3MgPSB1c2VGbGFncygpO1xuICBjb25zdCBpbnRsID0gdXNlSW50bCgpO1xuXG4gIGNvbnN0IHpvb21MYXRMbmdIYXNoID0gbWFwUmVmLmN1cnJlbnQ/LmdldE1hcCgpLl9oYXNoLl9nZXRDdXJyZW50SGFzaCgpO1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJvdW5kaW5nIGJveCBmb3Igb25lIG9yIG1vcmUgZmVhdHVyZXMuXG4gICAqIEBwYXJhbSBmZWF0dXJlTGlzdCB0aGUgbGlzdCBvZiBmZWF0dXJlc1xuICAgKiBAcmV0dXJucyB0aGUgYm91bmRpbmcgYm94XG4gICAqL1xuICBjb25zdCBnZXRGZWF0dXJlc0Jib3ggPSAoZmVhdHVyZUxpc3Q6IE1hcEdlb0pTT05GZWF0dXJlW10pOiBudW1iZXJbXSA9PiB7XG4gICAgaWYgKGZlYXR1cmVMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmZWF0dXJlTGlzdCBtdXN0IGJlIGEgbm9uLWVtcHR5IGFycmF5IHRvIGdldCBhIGJvdW5kaW5nIGJveC4nKTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgYSBtYXggYW5kIG1pbiBsYXQvbG9uIGZyb20gYWxsIHRoZSBzZWxlY3RlZCBmZWF0dXJlcy5cbiAgICBjb25zdCBtaW5MbmdMaXN0OiBudW1iZXJbXSA9IFtdO1xuICAgIGNvbnN0IG1pbkxhdExpc3Q6IG51bWJlcltdID0gW107XG4gICAgY29uc3QgbWF4TG5nTGlzdDogbnVtYmVyW10gPSBbXTtcbiAgICBjb25zdCBtYXhMYXRMaXN0OiBudW1iZXJbXSA9IFtdO1xuICAgIGZlYXR1cmVMaXN0LmZvckVhY2goKGZlYXR1cmUpID0+IHtcbiAgICAgIGNvbnN0IFtmZWF0TWluTG5nLCBmZWF0TWluTGF0LCBmZWF0TWF4TG5nLCBmZWF0TWF4TGF0XSA9IGJib3goZmVhdHVyZSk7XG4gICAgICBtaW5MbmdMaXN0LnB1c2goZmVhdE1pbkxuZyk7XG4gICAgICBtaW5MYXRMaXN0LnB1c2goZmVhdE1pbkxhdCk7XG4gICAgICBtYXhMbmdMaXN0LnB1c2goZmVhdE1heExuZyk7XG4gICAgICBtYXhMYXRMaXN0LnB1c2goZmVhdE1heExhdCk7XG4gICAgfSk7XG4gICAgY29uc3QgbWluTG5nOiBudW1iZXIgPSBNYXRoLm1pbiguLi5taW5MbmdMaXN0KTtcbiAgICBjb25zdCBtaW5MYXQ6IG51bWJlciA9IE1hdGgubWF4KC4uLm1pbkxhdExpc3QpO1xuICAgIGNvbnN0IG1heExuZzogbnVtYmVyID0gTWF0aC5tYXgoLi4ubWF4TG5nTGlzdCk7XG4gICAgY29uc3QgbWF4TGF0OiBudW1iZXIgPSBNYXRoLm1pbiguLi5tYXhMYXRMaXN0KTtcbiAgICByZXR1cm4gW21pbkxuZywgbWluTGF0LCBtYXhMbmcsIG1heExhdF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN0YXRlIHdpdGggdGhlIGxpc3Qgb2Ygc2VsZWN0ZWQgZmVhdHVyZXMuIFRoaXMgZnVuY3Rpb24gd2lsbDpcbiAgICogICAtIEFkZCB0aGUgZmVhdHVyZSB0byB0aGUgbGlzdCBpZiBpbiBtdWx0aSBzZWxlY3QgYW5kIHRoZSBmZWF0dXJlIGRvZXMgbm90IGFscmVhZHkgZXhpc3RcbiAgICogICAtIFJlbW92ZSB0aGUgZmVhdHVyZSBmcm9tIHRoZSBsaXN0IGlmIGluIG11bHRpIHNlbGVjdCBhbmQgdGhlIGZlYXR1cmUgZG9lcyBhbHJlYWR5IGV4aXN0XG4gICAqIEBwYXJhbSBmZWF0dXJlIHRoZSBmZWF0dXJlIHRvIGFkZCBvciByZW1vdmVcbiAgICogQHBhcmFtIGlzTXVsdGlTZWxlY3QgdHJ1ZSBpZiBpbiBtdWx0aXNlbGVjdCBtb2RlXG4gICAqIEByZXR1cm5zIHRoZSBsaXN0IG9mIHplcm8gb3IgbW9yZSBmZWF0dXJlc1xuICAgKi9cbiAgY29uc3QgdXBkYXRlU2VsZWN0ZWRGZWF0dXJlcyA9IChmZWF0dXJlOiBNYXBHZW9KU09ORmVhdHVyZSwgaXNNdWx0aVNlbGVjdDogYm9vbGVhbik6IE1hcEdlb0pTT05GZWF0dXJlW10gPT4ge1xuICAgIGlmICghZmVhdHVyZSkgcmV0dXJuIHNlbGVjdGVkRmVhdHVyZXM7XG5cbiAgICAvLyBJZiB0aGUgZmVhdHVyZSBpcyBpbiB0aGUgbGlzdCB0aGVuIHJlbW92ZSBpdCBhcyBpdCBpcyBiZWluZyBkZXNlbGVjdGVkXG4gICAgY29uc3QgZXhpc3RzID0gc2VsZWN0ZWRGZWF0dXJlcy5zb21lKChpdGVtKSA9PiBpdGVtLmlkID09PSBmZWF0dXJlLmlkKTtcbiAgICBsZXQgZmVhdHVyZUxpc3Q6IE1hcEdlb0pTT05GZWF0dXJlW10gPSBzZWxlY3RlZEZlYXR1cmVzO1xuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIGZlYXR1cmVMaXN0ID0gc2VsZWN0ZWRGZWF0dXJlcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uaWQgIT09IGZlYXR1cmUuaWQpO1xuICAgICAgc2V0U2hvd1Rvb01hbnlUcmFjdHNBbGVydChmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChzZWxlY3RlZEZlYXR1cmVzLmxlbmd0aCA8IE1BWF9TRUxFQ1RFRF9UUkFDVFMpIHtcbiAgICAgIC8vIEFkZCB0aGUgZmVhdHVyZSB0byB0aGUgbGlzdCBpZiBpbiBtdWx0aSBzZWxlY3QsIG90aGVyd2lzZSByZXBsYWNlIHRoZSBsaXN0XG4gICAgICAvLyB3aXRoIGp1c3QgdGhpcyBvbmUgZmVhdHVyZS5cbiAgICAgIGZlYXR1cmVMaXN0ID0gaXNNdWx0aVNlbGVjdCA/XG4gICAgICAgIFsuLi5zZWxlY3RlZEZlYXR1cmVzLCBmZWF0dXJlXSA6XG4gICAgICAgIFtmZWF0dXJlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0U2hvd1Rvb01hbnlUcmFjdHNBbGVydCh0cnVlKTtcbiAgICB9XG4gICAgc2V0U2VsZWN0ZWRGZWF0dXJlcyhmZWF0dXJlTGlzdCk7XG5cbiAgICBpZiAoIWluTXVsdGlTZWxlY3RNb2RlKSB7XG4gICAgICAvLyBUdXJuIG9uIG11bHRpIHNlbGVjdCBtb2RlIGFueSB0aW1lIHdlIHNlbGVjdCBtb3JlIHRoYW4gb25lIHRyYWN0LlxuICAgICAgc2V0SW5NdWx0aVNlbGVjdE1vZGUoZmVhdHVyZUxpc3QubGVuZ3RoID4gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZlYXR1cmVMaXN0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZWxlY3RzIHRoZSBwcm92aWRlZCBmZWF0dXJlIG9uIHRoZSBtYXAuXG4gICAqIEBwYXJhbSBmZWF0dXJlIHRoZSBmZWF0dXJlIHRvIHNlbGVjdFxuICAgKiBAcGFyYW0gaXNNdWx0aVNlbGVjdEtleURvd24gdHJ1ZSBpZiB0aGUgbXVsdGkgc2VsZWN0IGtleSBpcyBkb3duXG4gICAqL1xuICBjb25zdCBzZWxlY3RGZWF0dXJlc09uTWFwID0gKGZlYXR1cmU6IElNYXBGZWF0dXJlLCBpc011bHRpU2VsZWN0S2V5RG93bjogYm9vbGVhbiA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgZmVhdHVyZXNMaXN0ID0gdXBkYXRlU2VsZWN0ZWRGZWF0dXJlcyhmZWF0dXJlLCBpc011bHRpU2VsZWN0S2V5RG93biB8fCBpbk11bHRpU2VsZWN0TW9kZSk7XG4gICAgaWYgKGZlYXR1cmVzTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBbbWluTG5nLCBtaW5MYXQsIG1heExuZywgbWF4TGF0XSA9IGdldEZlYXR1cmVzQmJveChmZWF0dXJlc0xpc3QpO1xuXG4gICAgICAvLyBHbyB0byBhcmVhIG9mIHRoZSBzZWxlY3RlZCBmZWF0dXJlKHMpXG4gICAgICBnb1RvUGxhY2UoW1xuICAgICAgICBbbWluTG5nLCBtaW5MYXRdLFxuICAgICAgICBbbWF4TG5nLCBtYXhMYXRdLFxuICAgICAgXSk7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGZvbGxvd2luZyBsb2dpYyBpcyB1c2VkIGZvciB0aGUgcG9wdXAgZm9yIHRoZSBmdWxsc2NyZWVuIGZlYXR1cmVcbiAgICAgICAqL1xuICAgICAgLy8gQ3JlYXRlIGEgbmV3IHZpZXdwb3J0IHVzaW5nIHRoZSBjdXJyZW50IHZpZXdwb3J0IGRpbW5lc2lvbnM6XG4gICAgICBjb25zdCBuZXdWaWV3UG9ydCA9IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHtoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCEsIHdpZHRoOiB2aWV3cG9ydC53aWR0aCF9KTtcblxuICAgICAgLy8gRml0IHRoZSB2aWV3cG9ydCB0byB0aGUgbmV3IGJvdW5kcyBhbmQgcmV0dXJuIGEgbG9uZywgbGF0IGFuZCB6b29tOlxuICAgICAgY29uc3Qge2xvbmdpdHVkZSwgbGF0aXR1ZGUsIHpvb219ID0gbmV3Vmlld1BvcnQuZml0Qm91bmRzKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIFttaW5MbmcsIG1pbkxhdF0sXG4gICAgICAgICAgICBbbWF4TG5nLCBtYXhMYXRdLFxuICAgICAgICAgIF0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgcGFkZGluZzogNDAsXG4gICAgICAgICAgfSxcbiAgICAgICk7XG5cbiAgICAgIC8vIFNhdmUgdGhlIHBvcHVwSW5mb1xuICAgICAgY29uc3QgcG9wdXBJbmZvID0ge1xuICAgICAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICAgICAgbGF0aXR1ZGU6IGxhdGl0dWRlLFxuICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICBwcm9wZXJ0aWVzOiBmZWF0dXJlLnByb3BlcnRpZXMsXG4gICAgICB9O1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIERldGFpbGVkVmlldyBzdGF0ZSB2YXJpYWJsZSB3aXRoIHRoZSBuZXcgcG9wdXBJbmZvIG9iamVjdDpcbiAgICAgIHNldERldGFpbFZpZXdEYXRhKHBvcHVwSW5mbyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5kIEZ1bGxzY3JlZW4gZmVhdHVyZSBzcGVjaWZpYyBsb2dpY1xuICAgICAgICovXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICogVGhpcyBvbkNsaWNrIGV2ZW50IGhhbmRsZXIgd2lsbCBsaXN0ZW4gYW5kIGhhbmRsZSBjbGlja3Mgb24gdGhlIG1hcC4gSXQgd2lsbCBsaXN0ZW4gZm9yIGNsaWNrcyBvbiB0aGVcbiAqIHRlcnJpdG9yeSBjb250cm9scyBhbmQgaXQgd2lsbCBsaXN0ZW4gdG8gY2xpY2tzIG9uIHRoZSBtYXAuXG4gKlxuICogSXQgd2lsbCBOT1QgbGlzdGVuIHRvIGNsaWNrcyBpbnRvIHRoZSBzZWFyY2ggZmllbGQgb3IgdGhlIHpvb20gY29udHJvbHMuIFRoZXNlIGNsaWNrSGFuZGxlcnMgYXJlXG4gKiBjYXB0dXJlZCBpbiB0aGVpciBvd24gcmVzcGVjdGl2ZSBjb21wb25lbnRzLlxuICovXG4gIGNvbnN0IG9uQ2xpY2sgPSAoZXZlbnQ6IE1hcEV2ZW50IHwgUmVhY3QuTW91c2VFdmVudDxIVE1MQnV0dG9uRWxlbWVudD4pID0+IHtcbiAgICAvLyBTdG9wIGFsbCBwcm9wYWdhdGlvbiAvIGJ1YmJsaW5nIC8gY2FwdHVyaW5nXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAoZXZlbnQgYXMgUmVhY3QuTW91c2VFdmVudDxIVE1MQnV0dG9uRWxlbWVudD4pLnN0b3BQcm9wYWdhdGlvbj8uKCk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgY2xpY2sgaXMgZm9yIHRlcnJpdG9yaWVzLiBHaXZlbiB0aGUgdGVycml0b3JpZXMgY29tcG9uZW50J3MgZGVzaWduLCBpdCBjYW4gYmVcbiAgICAvLyBndWFyYW50ZWVkIHRoYXQgZWFjaCB0ZXJyaXRvcnkgY29udHJvbCB3aWxsIGhhdmUgYW4gaWQuIFdlIHVzZSB0aGlzIElEIHRvIGRldGVybWluZVxuICAgIC8vIGlmIHRoZSBjbGljayBpcyBjb21pbmcgZnJvbSBhIHRlcnJpdG9yeSBjb250cm9sXG4gICAgaWYgKGV2ZW50LnRhcmdldCAmJiAoZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5pZCkge1xuICAgICAgY29uc3QgYnV0dG9uSUQgPSBldmVudC50YXJnZXQgJiYgKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCkuaWQ7XG5cbiAgICAgIHN3aXRjaCAoYnV0dG9uSUQpIHtcbiAgICAgICAgY2FzZSAnNDgnOlxuICAgICAgICAgIGdvVG9QbGFjZShjb25zdGFudHMuTE9XRVJfNDhfQk9VTkRTLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQUsnOlxuICAgICAgICAgIGdvVG9QbGFjZShjb25zdGFudHMuQUxBU0tBX0JPVU5EUywgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0hJJzpcbiAgICAgICAgICBnb1RvUGxhY2UoY29uc3RhbnRzLkhBV0FJSV9CT1VORFMsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdQUic6XG4gICAgICAgICAgZ29Ub1BsYWNlKGNvbnN0YW50cy5QVUVSVE9fUklDT19CT1VORFMsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdHVSc6XG4gICAgICAgICAgZ29Ub1BsYWNlKGNvbnN0YW50cy5HVUFNX0JPVU5EUywgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FTJzpcbiAgICAgICAgICBnb1RvUGxhY2UoY29uc3RhbnRzLkFNRVJJQ0FOX1NBTU9BX0JPVU5EUywgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01QJzpcbiAgICAgICAgICBnb1RvUGxhY2UoY29uc3RhbnRzLk1BUklBTkFfSVNMQU5EX0JPVU5EUywgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1ZJJzpcbiAgICAgICAgICBnb1RvUGxhY2UoY29uc3RhbnRzLlVTX1ZJUkdJTl9JU0xBTkRTX0JPVU5EUywgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV2ZW50LnRhcmdldCAmJiAoZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5ub2RlTmFtZSA9PSAnRElWJykge1xuICAgICAgLy8gVGhpcyBlbHNlIGNsYXVzZSB3aWxsIGZpcmUgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIG1hcCBhbmQgd2lsbCBpZ25vcmUgb3RoZXIgY29udHJvbHNcbiAgICAgIC8vIHN1Y2ggYXMgdGhlIHNlYXJjaCBib3ggYW5kIGJ1dHRvbnMuXG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IGZlYXR1cmUgPSBldmVudC5mZWF0dXJlcyAmJiBldmVudC5mZWF0dXJlc1swXTtcblxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgc2VsZWN0RmVhdHVyZXNPbk1hcChmZWF0dXJlLCBldmVudC5zcmNFdmVudC5jdHJsS2V5KTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgb25Mb2FkID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuQ3lwcmVzcyAmJiBtYXBSZWYuY3VycmVudCkge1xuICAgICAgd2luZG93LnVuZGVybHlpbmdNYXAgPSBtYXBSZWYuY3VycmVudC5nZXRNYXAoKTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIG1hcCBsb2FkcyByZW1vdmUgdGhlIGdlb2xvY2F0ZSBsb2NrIGJvb2xlYW4gaW4gbG9jYWwgc3RvcmFnZVxuICAgIHJlbW92ZUdlb2xvY2F0ZUxvY2soKTtcblxuICAgIGlmIChpc01vYmlsZSkgc2V0SXNNb2JpbGVNYXBTdGF0ZSh0cnVlKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgbW92ZSB0aGUgbWFwICh3aXRoIGVhc2luZykgdG8gdGhlIGdpdmVuIGxhdC9sb25nIGJvdW5kcy5cbiAgICpcbiAgICogV2hlbiBhIHVzZXIgY2xpY2tzIG9uIGEgdHJhY3RzIHZzIGEgdGVycml0b3J5IGJ1dHRvbiwgdGhlIHpvb20gbGV2ZWwgcmV0dXJuZWQgYnkgdGhlIGZpdEJvdW5kc1xuICAgKiBmdW5jdGlvbiBkaWZmZXIuIEdpdmVuIHRoYXQgd2Ugd2FudCB0byBoYW5kbGUgdGhlIHpvb20gZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIHRoZXNlIHR3byBjYXNlcywgd2VcbiAgICogaW50cm9kdWNlIGEgYm9vbGVhbiwgaXNUZXJyaXRvcnkgdGhhdCB3aWxsIGFsbG93IHRoZSB6b29tIGxldmVsIHRvIGJlIHNldCBkZXBlbmRpbmcgb24gd2hhdCB0aGUgdXNlclxuICAgKiBpcyBpbnRlcmFjdGluZyB3aXRoLCBuYW1lbHkgYSB0cmFjdCB2cyBhIHRlcnJpdG9yeSBidXR0b24uXG4gICAqXG4gICAqIEBwYXJhbSB7TG5nTGF0Qm91bmRzTGlrZX0gYm91bmRzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNUZXJyaXRvcnlcbiAgICovXG4gIGNvbnN0IGdvVG9QbGFjZSA9IChib3VuZHM6IExuZ0xhdEJvdW5kc0xpa2UsIGlzVGVycml0b3J5ID0gZmFsc2UsIHNlbGVjdFRyYWN0SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCkgPT4ge1xuICAgIGNvbnN0IG5ld1ZpZXdQb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoe2hlaWdodDogdmlld3BvcnQuaGVpZ2h0ISwgd2lkdGg6IHZpZXdwb3J0LndpZHRoIX0pO1xuICAgIGNvbnN0IHtsb25naXR1ZGUsIGxhdGl0dWRlLCB6b29tfSA9IG5ld1ZpZXdQb3J0LmZpdEJvdW5kcyhcbiAgICAgIGJvdW5kcyBhcyBbW251bWJlciwgbnVtYmVyXSwgW251bWJlciwgbnVtYmVyXV0sIHtcbiAgICAgIC8vIHBhZGRpbmc6IDIwMCwgIC8vIHJlbW92aW5nIHBhZGRpbmcgYW5kIG9mZnNldCBpbiBmYXZvciBvZiBhIHpvb20gb2Zmc2V0IGJlbG93XG4gICAgICAvLyBvZmZzZXQ6IFswLCAtMTAwXSxcbiAgICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBzb21lIHRyYWN0cyBhcmUgc2VsZWN0ZWQsIHRoZXkgZW5kIHVwIHRvbyBmYXIgem9vbWVkIGluLCBjYXVzaW5nIHNvbWUgY2Vuc3VzIHRyYWN0cyB0b1xuICAgICAqIG9ubHkgc2hvdyBhIHBvcnRpb24gb2YgdGhlIHRyYWN0IGluIHRoZSB2aWV3cG9ydC4gV2UgcmVkdWNlIHRoZSB6b29tIGxldmVsIGJ5IDEgdG8gYWxsb3dcbiAgICAgKiBtb3JlIHNwYWNlIGFyb3VuZCB0aGUgc2VsZWN0ZWQgdHJhY3QuXG4gICAgICpcbiAgICAgKiBHaXZlbiB0aGF0IHRoZSBoaWdoIHpvb20gdGlsZXMgb25seSBnbyB0byB6b29tIGxldmVsIDUsIGlmIHRoZSBjb3JyZWN0ZWQgem9vbSBsZXZlbCAoem9vbSAtIDEpIGlzXG4gICAgICogbGVzcyB0aGFuIE1JTl9aT09NX0ZFQVRVUkVfQk9SREVSLCB0aGVuIHdlIGZsb29yIHRoZSB6b29tIHRvIE1JTl9aT09NX0ZFQVRVUkVfQk9SREVSICsgLjEgKHdoaWNoXG4gICAgICogaXMgNS4xIGFzIG9mIHRoaXMgY29tbWVudClcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgIGNvbnN0IGZlYXR1cmVTZWxlY3Rpb25ab29tTGV2ZWwgPSAoem9vbSAtIDEpIDwgY29uc3RhbnRzLkdMT0JBTF9NSU5fWk9PTV9GRUFUVVJFX0JPUkRFUiArIC4xID9cbiAgICAgIGNvbnN0YW50cy5HTE9CQUxfTUlOX1pPT01fRkVBVFVSRV9CT1JERVIgOlxuICAgICAgem9vbSAtIDE7XG5cbiAgICBzZXRWaWV3cG9ydCh7XG4gICAgICAuLi52aWV3cG9ydCxcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgem9vbTogaXNUZXJyaXRvcnkgPyB6b29tIDogZmVhdHVyZVNlbGVjdGlvblpvb21MZXZlbCxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogMTAwMCxcbiAgICAgIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IG5ldyBGbHlUb0ludGVycG9sYXRvcigpLFxuICAgICAgdHJhbnNpdGlvbkVhc2luZzogZDMuZWFzZUN1YmljLFxuICAgIH0pO1xuXG4gICAgLy8gU2V0IHRoZSB0cmFjdCBJRCB0byBiZSBzZWxlY3RlZCBpZiBhbnkuXG4gICAgc2V0U2VsZWN0VHJhY3RJZChzZWxlY3RUcmFjdElkKTtcbiAgfTtcblxuICBjb25zdCBvblRyYW5zaXRpb25TdGFydCA9ICgpID0+IHtcbiAgICBzZXRUcmFuc2l0aW9uSW5Qcm9ncmVzcyh0cnVlKTtcbiAgfTtcblxuICBjb25zdCBvblRyYW5zaXRpb25FbmQgPSAoKSA9PiB7XG4gICAgc2V0VHJhbnNpdGlvbkluUHJvZ3Jlc3MoZmFsc2UpO1xuXG4gICAgLypcbiAgICBJZiB0aGVyZSBpcyBhIHRyYWN0IElEIHRvIGJlIHNlbGVjdGVkIHRoZW4gZG8gc28gb25jZSB0aGUgbWFwIGhhcyBmaW5pc2hlZCBtb3ZpbmcuXG4gICAgTm90ZSB0aGF0IHNldHRpbmcgdGhlIHZpZXdwb2ludCB0byBtb3ZlIHRoZSBtYXAgYXMgZG9uZSBpbiB0aGlzIGNvbXBvbmVudCBkb2VzIG5vdFxuICAgIHRyaWdnZXIgYSBtb3ZlZW5kIG9yIGlkbGUgZXZlbnQgbGlrZSB3aGVuIHVzaW5nIGZseVRvIG9yIGVhc2VUby5cbiAgICAqL1xuICAgIGlmIChzZWxlY3RUcmFjdElkKSB7XG4gICAgICAvLyBTZWFyY2ggZm9yIGZlYXR1cmVzIGluIHRoZSBtYXAgdGhhdCBoYXZlIHRoZSB0cmFjdCBJRC5cbiAgICAgIGNvbnN0IGdlb2lkU2VhcmNoUmVzdWx0cyA9IG1hcFJlZi5jdXJyZW50Py5nZXRNYXAoKVxuICAgICAgICAgIC5xdWVyeVNvdXJjZUZlYXR1cmVzKGNvbnN0YW50cy5ISUdIX1pPT01fU09VUkNFX05BTUUsIHtcbiAgICAgICAgICAgIHNvdXJjZUxheWVyOiBjb25zdGFudHMuU0NPUkVfU09VUkNFX0xBWUVSLFxuICAgICAgICAgICAgdmFsaWRhdGU6IHRydWUsXG4gICAgICAgICAgICBmaWx0ZXI6IFsnPT0nLCBjb25zdGFudHMuR0VPSURfUFJPUEVSVFksIHNlbGVjdFRyYWN0SWRdLFxuICAgICAgICAgIH0pO1xuICAgICAgaWYgKGdlb2lkU2VhcmNoUmVzdWx0cyAmJiBnZW9pZFNlYXJjaFJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBUT0RPLCBzdXBwb3J0IHNlYXJjaGluZyBmb3IgYSBsaXN0IG9mIHRyYWN0c1xuICAgICAgICBzZWxlY3RGZWF0dXJlc09uTWFwKGdlb2lkU2VhcmNoUmVzdWx0c1swXSk7XG4gICAgICB9XG4gICAgICBzZXRTZWxlY3RUcmFjdElkKHVuZGVmaW5lZCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uR2VvbG9jYXRlID0gKCkgPT4ge1xuICAgIHNldEdlb2xvY2F0aW9uSW5Qcm9ncmVzcyhmYWxzZSk7XG5cbiAgICAvLyBzZXQgbG9jYWwgc3RvcmFnZSB0aGF0IGxvY2F0aW9uIHdhcyBsb2NrZWQgb24gdGhpcyBhcHAgYXQgc29tZSBwb2ludFxuICAgIHNldElzR2VvbG9jYXRlTG9ja2VkKHRydWUpO1xuICB9O1xuXG4gIGNvbnN0IG9uQ2xpY2tHZW9sb2NhdGUgPSAoKSA9PiB7XG4gICAgc2V0R2VvbG9jYXRpb25JblByb2dyZXNzKHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVyIGZvciB3aGVuIHRoZXJlIGlzIGEgY2hhbmdlIGluIHRoZSBtdWx0aSBzZWxlY3Qgc2lkZSBwYW5lbC5cbiAgICogQHBhcmFtIGZlYXR1cmUgdGhlIGZlYXR1cmUgdGhhdCB3YXMgYWRkZWQgb3IgcmVtb3ZlZFxuICAgKi9cbiAgY29uc3Qgb25SZXBvcnREZWxldGVUcmFjdCA9IChmZWF0dXJlOiBNYXBHZW9KU09ORmVhdHVyZSkgPT4ge1xuICAgIHVwZGF0ZVNlbGVjdGVkRmVhdHVyZXMoZmVhdHVyZSwgdHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZXIgZm9yIHdoZW4gdGhlIG11bHRpIHNlbGVjdCBpcyBmaW5pc2hlZC5cbiAgICovXG4gIGNvbnN0IG9uUmVwb3J0RXhpdCA9ICgpID0+IHtcbiAgICAvLyBDbGVhciBldmVyeXRoaW5nXG4gICAgc2V0U2VsZWN0ZWRGZWF0dXJlcyhbXSk7XG4gICAgc2V0RGV0YWlsVmlld0RhdGEodW5kZWZpbmVkKTtcbiAgICBzZXRJbk11bHRpU2VsZWN0TW9kZShmYWxzZSk7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPEdyaWQgZGVza3RvcD17e2NvbDogOX19IGNsYXNzTmFtZT17c3R5bGVzLmo0ME1hcH0+XG4gICAgICAgIHsvKipcbiAgICAgICAgICogTm90ZTpcbiAgICAgICAgICogVGhlIE1hcFNlYXJjaCBjb21wb25lbnQgaXMgbm8gbG9uZ2VyIHVzZWQgaW4gdGhpcyBsb2NhdGlvbi4gSXQgaGFzIGJlZW4gbW92ZWQgaW5zaWRlIHRoZVxuICAgICAgICAgKiA8UmVhY3RNYXBHTD4gY29tcG9uZW50IGl0c2VsZi5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgd2FzIG9yaWdpbmFsbHkgd3JhcHBlZCBpbiBhIGRpdiBpbiBvcmRlciB0byBhbGxvdyB0aGlzIGZlYXR1cmVcbiAgICAgICAgICogdG8gYmUgYmVoaW5kIGEgZmVhdHVyZSBmbGFnLiBUaGlzIHdhcyBjYXVzaW5nIGEgYnVnIGZvciBNYXBTZWFyY2ggdG8gcmVuZGVyXG4gICAgICAgICAqIGNvcnJlY3RseSBpbiBhIHByb2R1Y3Rpb24gYnVpbGQuIExlYXZpbmcgdGhpcyBjb21tZW50IGhlcmUgaW4gY2FzZSBmdXR1cmUgZmxhZ3MgYXJlXG4gICAgICAgICAqIG5lZWRlZCBpbiB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiB0aGUgTWFwU2VhcmNoIGNvbXBvbmVudCBpcyBwbGFjZWQgYmVoaW5kIGEgZmVhdHVyZSBmbGFnIHdpdGhvdXQgYSBkaXYgd3JhcHBpbmdcbiAgICAgICAgICogTWFwU2VhcmNoLCB0aGUgcHJvZHVjdGlvbiBidWlsZCB3aWxsIGluamVjdCBDU1MgZHVlIHRvIHRoZSBudWxsIGluIHRoZSBmYWxzZSBjb25kaXRpb25hbFxuICAgICAgICAgKiBjYXNlLiBBbnkgY2hhbmdlcyB0byB0aGlzIChpZSwgY2hhbmdlcyB0byBNYXBTZWFyY2ggb3IgcmVtb3ZpbmcgZmVhdHVyZSBmbGFnLCBldGMpLCBzaG91bGRcbiAgICAgICAgICogYmUgdGVzdGVkIHdpdGggYSBwcm9kdWN0aW9uIGJ1aWxkIHZpYTpcbiAgICAgICAgICogICAtIG5wbSBydW4gY2xlYW4gJiYgbnBtIHJ1biBidWlsZCAmJiBucG0gcnVuIHNlcnZlXG4gICAgICAgICAqXG4gICAgICAgICAqIHRvIGVuc3VyZSB0aGUgcHJvZHVjdGlvbiBidWlsZCB3b3JrcyBhbmQgdGhhdCBNYXBTZWFyY2ggYW5kIHRoZSBtYXAgKFJlYWN0TWFwR0wpIHJlbmRlciBjb3JyZWN0bHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFueSBjb21wb25lbnQgZGVjbGFyYXRpb25zIG91dHNpZGUgdGhlIDxSZWFjdE1hcEdMPiBjb21wb25lbnQgbWF5IGJlIHN1c2NlcHRpYmxlIHRvIHRoaXMgYnVnLlxuICAgICAgICAgKi99XG5cbiAgICAgICAgey8qKlxuICAgICAgICAgKiBUaGUgUmVhY3RNYXBHTCBjb21wb25lbnQncyBwcm9wcyBhcmUgZ3JvdXBlZCBieSB0aGUgQVBJJ3MgZG9jdW1lbnRhdGlvbi4gVGhlIGNvbXBvbmVudCBhbHNvIGhhc1xuICAgICAgICAgKiBzb21lIGNoaWxkcmVuLlxuICAgICAgICAgKi99XG4gICAgICAgIDxSZWFjdE1hcEdMXG4gICAgICAgICAgLy8gKioqKioqIEluaXRpYWxpemF0aW9uIHByb3BzOiAqKioqKipcbiAgICAgICAgICAvLyBhY2Nlc3MgdG9rZW4gaXMgajQwU3R5bGVzUmVhZFRva2VuXG4gICAgICAgICAgbWFwYm94QXBpQWNjZXNzVG9rZW49e1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTUFQQk9YX1NUWUxFU19SRUFEX1RPS0VOID9cbiAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTUFQQk9YX1NUWUxFU19SRUFEX1RPS0VOIDogJyd9XG5cbiAgICAgICAgICAvLyAqKioqKiogTWFwIHN0YXRlIHByb3BzOiAqKioqKipcbiAgICAgICAgICAvLyBodHRwOi8vdmlzZ2wuZ2l0aHViLmlvL3JlYWN0LW1hcC1nbC9kb2NzL2FwaS1yZWZlcmVuY2UvaW50ZXJhY3RpdmUtbWFwI21hcC1zdGF0ZVxuICAgICAgICAgIHsuLi52aWV3cG9ydH1cbiAgICAgICAgICBtYXBTdHlsZT17XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5NQVBCT1hfU1RZTEVTX1JFQURfVE9LRU4gP1xuICAgICAgICAgICAgICAnbWFwYm94Oi8vc3R5bGVzL2p1c3RpY2U0MC9jbDlnMzBxaDcwMDBwMTVsOWNwMWZ0dzE2JyA6XG4gICAgICAgICAgICAgICdodHRwczovL2Jhc2VtYXBzLmNhcnRvY2RuLmNvbS9nbC92b3lhZ2VyLWdsLXN0eWxlL3N0eWxlLmpzb24nXG4gICAgICAgICAgfVxuICAgICAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgICAgICAgLy8gQWp1c3RpbmcgdGhpcyBoZWlnaHQgd2l0aCBhIGNvbmRpdGlvbmFsIHN0YXRlbWVudCB3aWxsIG5vdCByZW5kZXIgdGhlIG1hcCBvbiBzdGFnaW5nLlxuICAgICAgICAgIC8vIFRoZSByZWFzb24gZm9yIHRoaXMgaXNzdWUgaXMgdW5rbm93bi4gQ29uc2lkZXIgc3R5bGluZyB0aGUgcGFyZW50IGNvbnRhaW5lciB2aWEgU0FTUy5cbiAgICAgICAgICBoZWlnaHQ9XCIxMDAlXCJcbiAgICAgICAgICBtYXBPcHRpb25zPXt7aGFzaDogdHJ1ZX19XG5cblxuICAgICAgICAgIC8vICoqKioqKiBJbnRlcmFjdGlvbiBvcHRpb24gcHJvcHM6ICoqKioqKlxuICAgICAgICAgIC8vIGh0dHA6Ly92aXNnbC5naXRodWIuaW8vcmVhY3QtbWFwLWdsL2RvY3MvYXBpLXJlZmVyZW5jZS9pbnRlcmFjdGl2ZS1tYXAjaW50ZXJhY3Rpb24tb3B0aW9uc1xuICAgICAgICAgIG1heFpvb209e2NvbnN0YW50cy5HTE9CQUxfTUFYX1pPT019XG4gICAgICAgICAgbWluWm9vbT17Y29uc3RhbnRzLkdMT0JBTF9NSU5fWk9PTX1cbiAgICAgICAgICBkcmFnUm90YXRlPXtmYWxzZX1cbiAgICAgICAgICB0b3VjaFJvdGF0ZT17ZmFsc2V9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVySWRzPXtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgY29uc3RhbnRzLkhJR0hfWk9PTV9MQVlFUl9JRCxcbiAgICAgICAgICAgICAgY29uc3RhbnRzLlBSSU9SSVRJWkVEX0hJR0hfWk9PTV9MQVlFUl9JRCxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG5cblxuICAgICAgICAgIC8vICoqKioqKiBDYWxsYmFjayBwcm9wczogKioqKioqXG4gICAgICAgICAgLy8gaHR0cDovL3Zpc2dsLmdpdGh1Yi5pby9yZWFjdC1tYXAtZ2wvZG9jcy9hcGktcmVmZXJlbmNlL2ludGVyYWN0aXZlLW1hcCNjYWxsYmFja3NcbiAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlPXtzZXRWaWV3cG9ydH1cbiAgICAgICAgICBvbkNsaWNrPXtvbkNsaWNrfVxuICAgICAgICAgIG9uTG9hZD17b25Mb2FkfVxuICAgICAgICAgIG9uVHJhbnNpdGlvblN0YXJ0PXtvblRyYW5zaXRpb25TdGFydH1cbiAgICAgICAgICBvblRyYW5zaXRpb25FbmQ9e29uVHJhbnNpdGlvbkVuZH1cbiAgICAgICAgICByZWY9e21hcFJlZn1cbiAgICAgICAgICBkYXRhLWN5PXsncmVhY3RNYXBHTCd9XG4gICAgICAgID5cblxuICAgICAgICAgIHsgLyogVHJpYmFsIGxheWVyIGlzIGJha2VkIGludG8gTWFwYm94IHNvdXJjZSxcbiAgICAgICAgICAgICAqIG9ubHkgcmVuZGVyIGhlcmUgaWYgd2UncmUgbm90IHVzaW5nIHRoYXRcbiAgICAgICAgICAgICAqKi9cbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk1BUEJPWF9TVFlMRVNfUkVBRF9UT0tFTiB8fFxuICAgICAgICAgICAgPE1hcFRyaWJhbExheWVyIC8+XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgPE1hcFRyYWN0TGF5ZXJzXG4gICAgICAgICAgICBzZWxlY3RlZEZlYXR1cmVzPXtzZWxlY3RlZEZlYXR1cmVzfVxuICAgICAgICAgIC8+XG5cbiAgICAgICAgICB7LyogVGhpcyBpcyB0aGUgZmlyc3Qgb3ZlcmxheWVkIHJvdyBvbiB0aGUgbWFwOiBTZWFyY2ggYW5kIEdlb2xvY2F0aW9uICovfVxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubWFwSGVhZGVyUm93fT5cbiAgICAgICAgICAgIDxNYXBTZWFyY2ggZ29Ub1BsYWNlPXtnb1RvUGxhY2V9IC8+XG5cbiAgICAgICAgICAgIHsvKiBHZW9sb2NhdGUgSWNvbiAqL31cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZ2VvbG9jYXRlQm94fT5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHdpbmRvd1dpZHRoID4gY29uc3RhbnRzLlVTV0RTX0JSRUFLUE9JTlRTLk1PQklMRV9MRyAtIDEgJiZcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17XG4gICAgICAgICAgICAgICAgICAoZ2VvbG9jYXRpb25JblByb2dyZXNzICYmICFpc0dlb2xvY2F0ZUxvY2tlZCkgP1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMuZ2VvbG9jYXRlTWVzc2FnZSA6XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5nZW9sb2NhdGVNZXNzYWdlSGlkZVxuICAgICAgICAgICAgICAgIH0+XG4gICAgICAgICAgICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5NQVAuR0VPTE9DX01TR19MT0NBVElORyl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgPEdlb2xvY2F0ZUNvbnRyb2xcbiAgICAgICAgICAgICAgICBwb3NpdGlvbk9wdGlvbnM9e3tlbmFibGVIaWdoQWNjdXJhY3k6IHRydWV9fVxuICAgICAgICAgICAgICAgIG9uR2VvbG9jYXRlPXtvbkdlb2xvY2F0ZX1cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtvbkNsaWNrR2VvbG9jYXRlfVxuICAgICAgICAgICAgICAgIHRyYWNrVXNlckxvY2F0aW9uPXt3aW5kb3dXaWR0aCA8IGNvbnN0YW50cy5VU1dEU19CUkVBS1BPSU5UUy5NT0JJTEVfTEd9XG4gICAgICAgICAgICAgICAgc2hvd1VzZXJIZWFkaW5nPXt3aW5kb3dXaWR0aCA8IGNvbnN0YW50cy5VU1dEU19CUkVBS1BPSU5UUy5NT0JJTEVfTEd9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgey8qIFRoaXMgaXMgdGhlIHNlY29uZCByb3cgb3ZlcmxheWVkIG9uIHRoZSBtYXAsIGl0IHdpbGwgYWRkIHRoZSBuYXZpZ2F0aW9uIGNvbnRyb2xzXG4gICAgICAgICAgb2YgdGhlIHpvb20gaW4gYW5kIHpvb20gb3V0IGJ1dHRvbnMgKi99XG4gICAgICAgICAge3dpbmRvd1dpZHRoID4gY29uc3RhbnRzLlVTV0RTX0JSRUFLUE9JTlRTLk1PQklMRV9MRyAmJiA8TmF2aWdhdGlvbkNvbnRyb2xcbiAgICAgICAgICAgIHNob3dDb21wYXNzPXtmYWxzZX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLm5hdmlnYXRpb25Db250cm9sfVxuICAgICAgICAgIC8+fVxuXG4gICAgICAgICAgey8qIFRoaXMgaXMgdGhlIHRoaXJkIHJvdyBvdmVybGF5ZWQgb24gdGhlIG1hcCwgaXQgd2lsbCBzaG93IHNob3J0Y3V0IGJ1dHRvbnMgdG9cbiAgICAgICAgICBwYW4vem9vbSB0byBVUyB0ZXJyaXRvcmllcyAqL31cbiAgICAgICAgICB7d2luZG93V2lkdGggPiBjb25zdGFudHMuVVNXRFNfQlJFQUtQT0lOVFMuTU9CSUxFX0xHICYmXG4gICAgICAgICAgICA8VGVycml0b3J5Rm9jdXNDb250cm9sIG9uQ2xpY2s9e29uQ2xpY2t9IC8+fVxuXG4gICAgICAgICAgey8qIEVuYWJsZSBmdWxsc2NyZWVuIHBvcC11cCBiZWhpbmQgYSBmZWF0dXJlIGZsYWcgKi99XG4gICAgICAgICAgeygnZnMnIGluIGZsYWdzICYmIGRldGFpbFZpZXdEYXRhICYmICF0cmFuc2l0aW9uSW5Qcm9ncmVzcykgJiYgKFxuICAgICAgICAgICAgPFBvcHVwXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmo0MFBvcHVwfVxuICAgICAgICAgICAgICB0aXBTaXplPXs1fVxuICAgICAgICAgICAgICBhbmNob3I9XCJ0b3BcIlxuICAgICAgICAgICAgICBsb25naXR1ZGU9e2RldGFpbFZpZXdEYXRhLmxvbmdpdHVkZSF9XG4gICAgICAgICAgICAgIGxhdGl0dWRlPXtkZXRhaWxWaWV3RGF0YS5sYXRpdHVkZSF9XG4gICAgICAgICAgICAgIGNsb3NlT25DbGljaz17dHJ1ZX1cbiAgICAgICAgICAgICAgb25DbG9zZT17c2V0RGV0YWlsVmlld0RhdGF9XG4gICAgICAgICAgICAgIGNhcHR1cmVTY3JvbGw9e3RydWV9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxBcmVhRGV0YWlsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllcz17ZGV0YWlsVmlld0RhdGEucHJvcGVydGllc31cbiAgICAgICAgICAgICAgICBoYXNoPXt6b29tTGF0TG5nSGFzaH1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvUG9wdXA+XG4gICAgICAgICAgKX1cbiAgICAgICAgICB7J2ZzJyBpbiBmbGFncyA/IDxGdWxsc2NyZWVuQ29udHJvbCBjbGFzc05hbWU9e3N0eWxlcy5mdWxsc2NyZWVuQ29udHJvbH0gLz4gOiAnJ31cblxuICAgICAgICA8L1JlYWN0TWFwR0w+XG4gICAgICA8L0dyaWQ+XG5cbiAgICAgIDxHcmlkIGRlc2t0b3A9e3tjb2w6IDN9fT5cbiAgICAgICAge2luTXVsdGlTZWxlY3RNb2RlID9cbiAgICAgICAgICA8Q3JlYXRlUmVwb3J0UGFuZWxcbiAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLm1hcEluZm9QYW5lbH1cbiAgICAgICAgICAgIGZlYXR1cmVMaXN0PXtzZWxlY3RlZEZlYXR1cmVzfVxuICAgICAgICAgICAgZGVsZXRlVHJhY3RIYW5kbGVyPXtvblJlcG9ydERlbGV0ZVRyYWN0fVxuICAgICAgICAgICAgZXhpdEhhbmRsZXI9e29uUmVwb3J0RXhpdH1cbiAgICAgICAgICAgIG1heE51bVRyYWN0cz17TUFYX1NFTEVDVEVEX1RSQUNUU31cbiAgICAgICAgICAgIHNob3dUb29NYW55VHJhY3RzQWxlcnQ9e3Nob3dUb29NYW55VHJhY3RzQWxlcnR9XG4gICAgICAgICAgLz4gOlxuICAgICAgICAgIDxNYXBJbmZvUGFuZWxcbiAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLm1hcEluZm9QYW5lbH1cbiAgICAgICAgICAgIGZlYXR1cmVQcm9wZXJ0aWVzPXtkZXRhaWxWaWV3RGF0YT8ucHJvcGVydGllc31cbiAgICAgICAgICAgIGhhc2g9e3pvb21MYXRMbmdIYXNofVxuICAgICAgICAgIC8+XG4gICAgICAgIH1cbiAgICAgIDwvR3JpZD5cbiAgICA8Lz5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEo0ME1hcDtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge3VzZUludGx9IGZyb20gJ2dhdHNieS1wbHVnaW4taW50bCc7XG5pbXBvcnQge0dyaWR9IGZyb20gJ0B0cnVzc3dvcmtzL3JlYWN0LXVzd2RzJztcblxuaW1wb3J0IEV4cGxvcmVEYXRhQm94IGZyb20gJy4uL2NvbXBvbmVudHMvRXhwbG9yZURhdGFCb3gnO1xuaW1wb3J0IEo0ME1hcCBmcm9tICcuLi9jb21wb25lbnRzL0o0ME1hcCc7XG5pbXBvcnQgSjQwTWFpbkdyaWRDb250YWluZXIgZnJvbSAnLi4vY29tcG9uZW50cy9KNDBNYWluR3JpZENvbnRhaW5lcic7XG5pbXBvcnQgTGF5b3V0IGZyb20gJy4uL2NvbXBvbmVudHMvbGF5b3V0JztcbmltcG9ydCBEYXRhc2V0c0J1dHRvbiBmcm9tICcuLi9jb21wb25lbnRzL0RhdGFzZXRzQnV0dG9uJztcblxuaW1wb3J0ICogYXMgRVhQTE9SRV9DT1BZIGZyb20gJy4uL2RhdGEvY29weS9leHBsb3JlJztcbmltcG9ydCB7REFUQV9TVVJWRVlfTElOS1N9IGZyb20gJy4uL2RhdGEvY29uc3RhbnRzJztcblxuaW50ZXJmYWNlIElNYXBQYWdlUHJvcHMge1xuICBsb2NhdGlvbjogTG9jYXRpb247XG59XG5cbmNvbnN0IEV4cG9yZVRvb2xQYWdlID0gKHtsb2NhdGlvbn06IElNYXBQYWdlUHJvcHMpID0+IHtcbiAgLy8gV2UgdGVtcG9yYXJpbHkgcmVtb3ZlZCBNYXBDb250cm9scywgd2hpY2ggd291bGQgZW5hYmxlIHlvdSB0byBgc2V0RmVhdHVyZXNgIGFsc28sIGZvciBub3dcbiAgLy8gICBXZSB3aWxsIGJyaW5nIGJhY2sgbGF0ZXIgd2hlbiB3ZSBoYXZlIGludGVyYWN0aXZlIGNvbnRyb2xzLlxuICBjb25zdCBpbnRsID0gdXNlSW50bCgpO1xuXG5cbiAgcmV0dXJuICg8TGF5b3V0IGxvY2F0aW9uPXtsb2NhdGlvbn0gdGl0bGU9e2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuUEFHRV9JTlRSTy5QQUdFX1RJTEUpfT5cblxuICAgIDxKNDBNYWluR3JpZENvbnRhaW5lcj5cblxuICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPXsncGFnZS1oZWFkaW5nJ30+XG4gICAgICAgIDxoMT57aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5QQUdFX0lOVFJPLlBBR0VfSEVBRElORyl9PC9oMT5cbiAgICAgICAgPERhdGFzZXRzQnV0dG9uIGhyZWY9IHtpbnRsLmxvY2FsZSA9PT0gJ2VzJyA/IERBVEFfU1VSVkVZX0xJTktTLkVTIDogREFUQV9TVVJWRVlfTElOS1MuRU59IC8+XG4gICAgICA8L3NlY3Rpb24+XG5cbiAgICAgIDxHcmlkIHJvdyBnYXAgY2xhc3NOYW1lPXsnajQwLW1iNS1tdDMnfT5cblxuICAgICAgICB7LyogR3JhZHVhbGx5IGluY3JlYXNlIHdpZHRoIG9mIHRoZSBHcmlkIGFzIHRoZSB3aWR0aCBkZWNyZWFzZXMgZnJvbSBkZXNrdG9wIHRvIG1vYmlsZSovfVxuICAgICAgICB7LyogZGVza3RvcCA9IDcgY29sdW1ucywgdGFibGV0ID0gMTAgY29sdW1ucyBhbmQgbW9iaWxlID0gMTIgY29sdW1ucyAoZnVsbCB3aWR0aCkgKi99XG4gICAgICAgIDxHcmlkIGRlc2t0b3A9e3tjb2w6IDh9fSB0YWJsZXQ9e3tjb2w6IDEwfX0gY29sPXsxMn0+XG4gICAgICAgICAgPHA+XG4gICAgICAgICAgICB7RVhQTE9SRV9DT1BZLlBBR0VfREVTQ1JJUFRJT04xfVxuICAgICAgICAgIDwvcD5cbiAgICAgICAgICA8cD5cbiAgICAgICAgICAgIHtFWFBMT1JFX0NPUFkuUEFHRV9ERVNDUklQVElPTjJ9XG4gICAgICAgICAgPC9wPlxuICAgICAgICA8L0dyaWQ+XG4gICAgICAgIDxHcmlkIGRlc2t0b3A9e3tjb2w6IDR9fSB0YWJsZXQ9e3tjb2w6IDEwfX0gY29sPXsxMn0+XG4gICAgICAgICAgPEV4cGxvcmVEYXRhQm94IC8+XG4gICAgICAgIDwvR3JpZD5cbiAgICAgIDwvR3JpZD5cbiAgICA8L0o0ME1haW5HcmlkQ29udGFpbmVyPlxuXG4gICAgPEo0ME1haW5HcmlkQ29udGFpbmVyPlxuICAgICAgPEdyaWQgcm93PlxuICAgICAgICA8SjQwTWFwIGxvY2F0aW9uPXtsb2NhdGlvbn0vPlxuICAgICAgPC9HcmlkPlxuICAgIDwvSjQwTWFpbkdyaWRDb250YWluZXI+XG5cbiAgICA8SjQwTWFpbkdyaWRDb250YWluZXI+XG4gICAgICA8R3JpZCBkZXNrdG9wPXt7Y29sOiA3fX0gdGFibGV0PXt7Y29sOiAxMH19IGNvbD17MTJ9PlxuICAgICAgICA8aDI+e0VYUExPUkVfQ09QWS5OT1RFX09OX1RFUlJJVE9SSUVTLklOVFJPfTwvaDI+XG4gICAgICAgIDxwPntFWFBMT1JFX0NPUFkuTk9URV9PTl9URVJSSVRPUklFUy5QQVJBXzB9PC9wPlxuICAgICAgICA8cD57RVhQTE9SRV9DT1BZLk5PVEVfT05fVEVSUklUT1JJRVMuUEFSQV8xfTwvcD5cbiAgICAgICAgPHA+e0VYUExPUkVfQ09QWS5OT1RFX09OX1RFUlJJVE9SSUVTLlBBUkFfMn08L3A+XG4gICAgICA8L0dyaWQ+XG5cbiAgICAgIDxHcmlkIGRlc2t0b3A9e3tjb2w6IDd9fSB0YWJsZXQ9e3tjb2w6IDEwfX0gY29sPXsxMn0+XG4gICAgICAgIDxoMj57RVhQTE9SRV9DT1BZLk5PVEVfT05fVFJJQkFMX05BVElPTlMuSU5UUk99PC9oMj5cbiAgICAgICAgPHA+e0VYUExPUkVfQ09QWS5OT1RFX09OX1RSSUJBTF9OQVRJT05TLlBBUkFfMX08L3A+XG4gICAgICAgIDxwPntFWFBMT1JFX0NPUFkuTk9URV9PTl9UUklCQUxfTkFUSU9OUy5QQVJBXzJ9PC9wPlxuICAgICAgPC9HcmlkPlxuICAgIDwvSjQwTWFpbkdyaWRDb250YWluZXI+XG5cbiAgPC9MYXlvdXQ+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFeHBvcmVUb29sUGFnZTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlN1bW1hcnlCb3giLCJTdW1tYXJ5Qm94Q29udGVudCIsIlN1bW1hcnlCb3hIZWFkaW5nIiwidXNlSW50bCIsIkVYUExPUkVfQ09QWSIsInN0eWxlcyIsImZpbGVEb3duSWNvbiIsIkV4cGxvcmVEYXRhQm94IiwiX3JlZiIsImludGwiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwic3VtbWFyeUJveENvbnRhaW5lciIsImhlYWRpbmdMZXZlbCIsImZvcm1hdE1lc3NhZ2UiLCJFWFBMT1JFX0RBVEFfQk9YIiwiVElUTEUiLCJ0YWJJbmRleCIsInNyYyIsImFsdCIsIlNJREVfUEFORUxfSU5JVF9TVEFURV9JQ09OX0FMVF9URVhUIiwiUExVUyIsIkVYUExPUkVfREFUQV9CT1hfQk9EWSIsIkRpc2FkdmFudGFnZURvdCIsImlzRGlzYWR2YW50YWdlZCIsImlzQmlnIiwiY29tcHV0ZWRDbGFzcyIsImRpc2FkdmFudGFnZWREb3RCaWciLCJkaXNhZHZhbnRhZ2VkRG90U21hbGwiLCJDYXRlZ29yeSIsIm5hbWUiLCJkaXNDYXRlZ29yeUNvbnRhaW5lciIsImNhdGVnb3J5IiwiY2F0ZWdvcnlDb250YWluZXIiLCJSZWFjdFRvb2x0aXAiLCJjb25zdGFudHMiLCJpbmZvSWNvbiIsIkluZGljYXRvckluZm9JY29uIiwiaXNJbXB1dGUiLCJwb3B1bGF0aW9uIiwic2hvd1RpbGRlIiwiZ2V0VG9vbFRpcENvcHkiLCJNSVNTSU5HX0RBVEFfU1RSSU5HIiwiTE9XX0lOQ09NRV9UT09MVElQIiwiSU1QX1lFU19QT1BfTlVMTCIsIklNUF9ZRVNfUE9QX05PVF9OVUxMIiwiRnJhZ21lbnQiLCJpZCIsIm11bHRpbGluZSIsImluZm8iLCJTSURFX1BBTkVMX1ZBTFVFUyIsIklNR19BTFRfVEVYVCIsIklORk8iLCJpbmZvVGlsZGUiLCJJbmRpY2F0b3JWYWx1ZVN1YlRleHQiLCJfcmVmMiIsInR5cGUiLCJ2YWx1ZSIsImlzQWJvdmVUaHJlc2giLCJ0aHJlc2hvbGQiLCJVTkFWQUlMQkxFX01TRyIsIkFCT1ZFIiwiQkVMT1ciLCJJbmRpY2F0b3JWYWx1ZSIsImRpc3BsYXlTdGF0IiwiUEVSQ0VOVCIsIlBFUkNFTlRJTEUiLCJzdXBlcnNjcmlwdE9yZGluYWwiLCJpbmRpY2F0b3JWYWx1ZVdpdGhTdWZmaXgiLCJpbmRleE9mIiwib3JkaW5hbFN1ZmZpeCIsImNoYXJBdCIsImxlbmd0aCIsImluZGljYXRvclZhbHVlIiwic2xpY2UiLCJzdHlsZSIsInRvcCIsInZhbHVlUmVnRXgiLCJzdWZmaXhSZWdFeCIsImV4ZWMiLCJfcmVmMyIsImZvcm1hdE51bWJlciIsInVuaXQiLCJ1bml0RGlzcGxheSIsImkxOG5PcmRpbmFsU3VmZml4IiwiZGVzY3JpcHRpb24iLCJkZWZhdWx0TWVzc2FnZSIsIlNJREVfUEFORUxfU1BBQ0VSUyIsIk5PIiwiWUVTIiwiSW5kaWNhdG9yIiwiX3JlZjQiLCJpbmRpY2F0b3IiLCJNYXRoIiwiZmxvb3IiLCJOdW1iZXIiLCJERUZBVUxUX1RIUkVTSE9MRF9QRVJDRU5USUxFIiwic2hvd0xvd0luY29tZUluZm9JY29uIiwibGFiZWwiLCJpbmRpY2F0b3JCb3hNYWluIiwiaW5kaWNhdG9yUm93IiwiaW5kaWNhdG9yTmFtZSIsImluZGljYXRvckRlc2MiLCJpbmRpY2F0b3JWYWx1ZUNvbCIsImluZGljYXRvclZhbHVlUm93IiwiaW5kaWNhdG9ySW5mbyIsImlzRGlzYWR2YWd0YWdlZCIsImRpc0luZGljYXRvclZhbHVlIiwiaW5kaWNhdG9yVmFsdWVTdWJUZXh0IiwiRG9udXRDb3B5IiwiaXNBZGphY2VudCIsInBvdmVydHlCZWxvdzIwMFBlcmNlbnRpbGUiLCJwb3ZCZWwyMDBQZXJjZW50aWxlIiwicGFyc2VGbG9hdCIsInRvRml4ZWQiLCJkb251dENvcHlDb250YWluZXIiLCJkb251dFJvdyIsImRvbnV0Um93TGFiZWwiLCJET05VVF9DT1BZIiwiQ09NUF9TVVJSIiwiaW52ZXJ0IiwiQ09NTVVOSVRZIiwiT0ZfRk9DVVMiLCJOT1RfT0ZfRk9DVVMiLCJBREpfTE9XX0lOQyIsInZhbHVlU3ViVGV4dENvbnRhaW5lciIsIm5vSW52ZXJ0Iiwic3ViVGV4dENvbnRhaW5lciIsIlByaW9yaXRpemF0aW9uQ29weSIsInRvdGFsQ2F0ZWdvcmllc1ByaW9yaXRpemVkIiwidG90YWxCdXJkZW5zUHJpb3JpdGl6ZWQiLCJpc0FkamFjZW5jeVRocmVzaE1ldCIsImlzQWRqYWNlbmN5TG93SW5jb21lIiwiaXNHcmFuZGZhdGhlcmVkIiwiaXNJc2xhbmRMb3dJbmNvbWUiLCJ0cmliYWxDb3VudEFLIiwidHJpYmFsQ291bnRVUyIsInBlcmNlbnRUcmFjdFRyaWJhbCIsInByaW9Db3B5UmVuZGVyZWQiLCJQUklPUklUSVpBVElPTl9DT1BZIiwiUFJJT19HUkFOREZBVEhFUkVEX0xJIiwiUFJJT19TVVJSX0xJIiwiUFJJT19JU0xBTkRfTEkiLCJOT1RfUFJJT19TVVJSX0xJIiwiUEFSX1BSSU9fU1VSUl9OT19MSSIsIk5PVF9QUklPIiwiTk9UX1BSSU9fMUJVUiIsIk5PVF9QUklPX05CVVIiLCJnZXRQcmlvQUtVU0NvcHkiLCJnZXRQcmlvQU5WQ29weSIsImdldFByaW9GUlRQb2ludHNDb3B5IiwiZ2V0UHJpb0ZSVENvcHkiLCJnZXRQcmlvTkJ1cmRlbkNvcHkiLCJQcmlvcml0aXphdGlvbkNvcHkyIiwicHJpb0NvcHkyUmVuZGVyZWQiLCJnZXRQcmlvUGVyY0FuZE51bVBvaW50c0Fsc29Db3B5IiwidXNlU3RhdGUiLCJleHBhbmRJY29uIiwiY29sbGFwc2VJY29uIiwiSjQwQWNjb3JkaW9uSXRlbSIsInRpdGxlIiwiY2hpbGRyZW4iLCJpc0V4cGFuZGVkIiwic2V0SXNFeHBhbmRlZCIsImRlbW9ncmFwaGljSGVhZGluZyIsInNob3dIaWRlVGV4dCIsIm9uQ2xpY2siLCJTSURFX1BBTkVMX0RFTU9HUkFQSElDUyIsIkhJREVfREVNT0dSQVBISUNTIiwiU0hPV19ERU1PR1JBUEhJQ1MiLCJzaG93SGlkZUljb24iLCJoaWRkZW4iLCJkZW1vZ3JhcGhpY0l0ZW1HZW4iLCJkZW1vZ3JhcGhpY0RhdGEiLCJtYXAiLCJlbCIsImluZGV4Iiwia2V5IiwiZGVtb2dyYXBoaWNJdGVtIiwic3RhdCIsInVuZGVmaW5lZCIsImdldERlbW9ncmFwaGljc0RhdGEiLCJwcm9wZXJ0aWVzIiwicmFjZSIsIkRFTU9fTk9OX0hJU1BBTklDX1dISVRFIiwiREVNT19CTEFDSyIsIkRFTU9fQU1FUklDQU5fSU5ESUFOIiwiREVNT19BU0lBTiIsIkRFTU9fSEFXQUlJQU4iLCJERU1PX09USEVSX1JBQ0UiLCJERU1PX1RXT19PUl9NT1JFX1JBQ0VTIiwiREVNT19ISVNQQU5JQyIsImFnZSIsIkRFTU9fQUdFX1VOREVSXzEwIiwiREVNT19BR0VfTUlEIiwiREVNT19BR0VfT1ZFUl82NSIsIkRFTU9fQUdFX09WRVJfNjQiLCJUcmFjdERlbW9ncmFwaGljcyIsImRlbW9ncmFwaGljc0NvbnRhaW5lciIsImRlbW9ncmFwaGljc1RpdGxlIiwiUkFDRV9USVRMRSIsIkFHRV9USVRMRSIsIlRyYWN0SW5mbyIsImJsb2NrR3JvdXAiLCJjb3VudHlOYW1lIiwic3RhdGVOYW1lIiwic2lkZVBhbmVsU3RhdGUiLCJ0cmFjdEluZm9Db250YWluZXIiLCJ0cmFjdEluZm9MYWJlbCIsIlNJREVfUEFORUxfQ0JHX0lORk8iLCJDRU5TVVNfSU5GT19USVRMRSIsIkNFTlNVU19CTE9DS19HUk9VUCIsIkNPVU5UWSIsIlNJREVfUEFORUxfU1RBVEVfVkFMVUVTIiwiTkFUSU9OIiwiVEVSUklUT1JZIiwiU1RBVEUiLCJQT1BVTEFUSU9OIiwidG9Mb2NhbGVTdHJpbmciLCJUcmFjdFByaW9yaXRpemF0aW9uIiwic2NvcmVOQ29tbXVuaXRpZXMiLCJQQVJUSUFMIiwiSXNsYW5kQ29weSIsInBvdmVydHlQZXJjZW50aWxlIiwicGVyY2VudGlsZVdob2xlIiwiaXNsYW5kQ29weUNvbnRhaW5lciIsImlzbGFuZFJvdyIsImlzbGFuZFJvd0xhYmVsIiwiSVNMQU5EX0NPUFkiLCJMT1dfSU5DIiwidmFsdWVDb250YWluZXIiLCJBY2NvcmRpb24iLCJCdXR0b24iLCJJY29uIiwiaW5kaWNhdG9yRmlsdGVyIiwiZ2V0VHJpYmFsUGVyY2VudFZhbHVlIiwidHJpYmFsUGVyY2VudFJhdyIsIkFyZWFEZXRhaWwiLCJzZXRDYXRlZ29yeUluZGljYXRvcnMiLCJpbmRpY2F0b3JzIiwiY2F0IiwiY2F0ZWdvcmllcyIsImZpbmQiLCJFcnJvciIsImNvbnNvbGUiLCJsb2ciLCJJTVBVVEVfRkxBRyIsIkFESkFDRU5DWV9FWENFRURTX1RIUkVTSCIsIlRSSUJBTF9BUkVBU19QRVJDRU5UQUdFIiwiVFJJQkFMX0FSRUFTX0NPVU5UX0FLIiwiVFJJQkFMX0FSRUFTX0NPVU5UX0NPTlVTIiwiR0VPSURfUFJPUEVSVFkiLCJUT1RBTF9QT1BVTEFUSU9OIiwiQ09VTlRZX05BTUUiLCJTVEFURV9OQU1FIiwiU0lERV9QQU5FTF9TVEFURSIsImdldFdvcmtGb3JjZUluZGljYXRvclZhbHVlIiwiSVNMQU5EX0FSRUFTIiwiaGFzT3duUHJvcGVydHkiLCJJU0xBTkRfQVJFQVNfTE9XX01FRElBTl9JTkNPTUVfTE9XX0hTX0VEVV9QRVJDRU5USUxFX0ZJRUxEIiwiSVNMQU5EX0FSRUFTX1VORU1QTE9ZTUVOVF9MT1dfSFNfRURVX1BFUkNFTlRJTEVfRklFTEQiLCJJU0xBTkRfQVJFQVNfUE9WRVJUWV9MT1dfSFNfRURVX1BFUkNFTlRJTEVfRklFTEQiLCJJU0xBTkRfQVJFQVNfSFNfRURVX1BFUkNFTlRBR0VfRklFTEQiLCJMT1dfTUVESUFOX0lOQ09NRV9QRVJDRU5USUxFIiwiVU5FTVBMT1lNRU5UX1BST1BFUlRZX1BFUkNFTlRJTEUiLCJQT1ZFUlRZX0JFTE9XXzEwMF9QRVJDRU5USUxFIiwiSElHSF9TQ0hPT0xfUFJPUEVSVFlfUEVSQ0VOVElMRSIsImdldFdvcmtGb3JjZUluZGljYXRvcklzRGlzYWR2IiwiSVNfRVhDRUVEU19USFJFU0hfRk9SX0lTTEFORF9BUkVBX0xPV19NRURJQU5fSU5DT01FIiwiSVNfRVhDRUVEU19USFJFU0hfRk9SX0lTTEFORF9BUkVBX1VORU1QTE9ZTUVOVCIsIklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9JU0xBTkRfQVJFQV9CRUxPV18xMDBfUE9WRVJUWSIsIklTTEFORF9BUkVBX0xPV19IU19FRFUiLCJJU19FWENFRURTX1RIUkVTSF9GT1JfTE9XX01FRElBTl9JTkNPTUUiLCJJU19FWENFRURTX1RIUkVTSF9GT1JfVU5FTVBMT1lNRU5UIiwiSVNfRVhDRUVEU19USFJFU0hfRk9SX0JFTE9XXzEwMF9QT1ZFUlRZIiwiSVNfTE9XX0hTX0VEVUNBVElPTl9MT1dfSElHSEVSX0VEX1BSSU9SSVRJWkVEIiwiZXhwQWdMb3NzIiwiU0lERV9QQU5FTF9JTkRJQ0FUT1JTIiwiRVhQX0FHX0xPU1MiLCJTSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTiIsIkVYUF9BR1JJQ1VMVFVSRV9MT1NTX1BFUkNFTlRJTEUiLCJJU19FWENFRURTX1RIUkVTSF9GT1JfRVhQX0FHUl9MT1NTIiwiZXhwQmxkTG9zcyIsIkVYUF9CTERfTE9TUyIsIkVYUF9CVUlMRElOR19MT1NTX1BFUkNFTlRJTEUiLCJJU19FWENFRURTX1RIUkVTSF9GT1JfRVhQX0JMRF9MT1NTIiwiZXhwUG9wTG9zcyIsIkVYUF9QT1BfTE9TUyIsIkVYUF9QT1BVTEFUSU9OX0xPU1NfUEVSQ0VOVElMRSIsIklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9FWFBfUE9QX0xPU1MiLCJmbG9vZGluZyIsIkZMT09ESU5HIiwiRkxPT0RJTkdfUEVSQ0VOVElMRSIsIklTX0VYQ0VFRFNfVEhSRVNIX0ZMT09ESU5HIiwid2lsZGZpcmUiLCJXSUxERklSRSIsIldJTERGSVJFX1BFUkNFTlRJTEUiLCJJU19FWENFRURTX1RIUkVTSF9XSUxERklSRSIsImxvd0luYyIsIkxPV19JTkNPTUUiLCJQT1ZFUlRZX0JFTE9XXzIwMF9QRVJDRU5USUxFIiwiSVNfRkVERVJBTF9QT1ZFUlRZX0xFVkVMXzIwMCIsImVuZXJneUNvc3QiLCJFTkVSR1lfQ09TVCIsIkVORVJHWV9QRVJDRU5USUxFIiwiSVNfRVhDRUVEU19USFJFU0hfRk9SX0VORVJHWV9CVVJERU4iLCJwbTI1IiwiUE1fMl81IiwiUE0yNV9QRVJDRU5USUxFIiwiSVNfRVhDRUVEU19USFJFU0hfRk9SX1BNMjUiLCJhc3RobWEiLCJBU1RITUEiLCJBU1RITUFfUEVSQ0VOVElMRSIsIklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9BU1RITUEiLCJkaWFiZXRlcyIsIkRJQUJFVEVTIiwiRElBQkVURVNfUEVSQ0VOVElMRSIsIklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9ESUFCRVRFUyIsImhlYXJ0RGlzZWFzZSIsIkhFQVJUX0RJU0VBU0UiLCJIRUFSVF9QRVJDRU5USUxFIiwiSVNfRVhDRUVEU19USFJFU0hfRk9SX0hFQVJUX0RJU0VBU0UiLCJsaWZlRXhwZWN0IiwiTElGRV9FWFBFQ1QiLCJMT1dfTElGRV9FWFBFQ1QiLCJMSUZFX1BFUkNFTlRJTEUiLCJJU19FWENFRURTX1RIUkVTSF9GT1JfTE9XX0xJRkVfRVhQIiwiaGlzdG9yaWNVbmRlcmludmVzdCIsIkhJU1RfVU5ERVJJTlZFU1QiLCJISVNUT1JJQ19VTkRFUklOVkVTVE1FTlRfRVhDRUVEX1RIUkVTSCIsIkhJU1RPUklDX1VOREVSSU5WRVNUTUVOVF9SQVdfWUVTIiwiaG91c2VDb3N0IiwiSE9VU0VfQ09TVCIsIkhPVVNJTkdfQlVSREVOX1BST1BFUlRZX1BFUkNFTlRJTEUiLCJJU19FWENFRURTX1RIUkVTSF9GT1JfSE9VU0VfQlVSREVOIiwibGFja0dyZWVuU3BhY2UiLCJMQUNLX0dSRUVOX1NQQUNFIiwiSU1QRVJWSU9VU19QRVJDRU5USUxFIiwiSVNfRVhDRUVEU19USFJFU0hfSU1QRVJWSU9VUyIsImxhY2tQbHVtYmluZyIsIkxBQ0tfUExVTUJJTkciLCJLSVRDSEVOX1BMVU1CX1BFUkNFTlRJTEUiLCJJU19FWENFRURTX1RIUkVTSF9LSVRDSEVOX1BMVU1CIiwibGVhZFBhaW50IiwiTEVBRF9QQUlOVCIsIkxFQURfUEFJTlRfUEVSQ0VOVElMRSIsIklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9MRUFEX1BBSU5UX0FORF9NRURJQU5fSE9NRV9WQUwiLCJhYmFuZG9uTWluZXMiLCJBQkFORE9OX01JTkVTIiwiQUJBTkRPTl9MQU5EX01JTkVTX0VYQ0VFRFNfVEhSRVNIIiwiZm9ybWVyRGVmU2l0ZXMiLCJGT1JNRVJfREVGX1NJVEVTIiwiRk9STUVSX0RFRl9TSVRFU19SQVdfVkFMVUUiLCJGVURTX1JBV19ZRVMiLCJGT1JNRVJfREVGX1NJVEVTX0VYQ0VFRFNfVEhSRVNIIiwicHJveEhheiIsIlBST1hfSEFaIiwiUFJPWElNSVRZX1RTREZfU0lURVNfUEVSQ0VOVElMRSIsIklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9IQVpBUkRfV0FTVEUiLCJwcm94Uk1QIiwiUFJPWF9STVAiLCJQUk9YSU1JVFlfUk1QX1NJVEVTX1BFUkNFTlRJTEUiLCJJU19FWENFRURTX1RIUkVTSF9GT1JfUk1QIiwicHJveE5QTCIsIlBST1hfTlBMIiwiUFJPWElNSVRZX05QTF9TSVRFU19QRVJDRU5USUxFIiwiSVNfRVhDRUVEU19USFJFU0hfRk9SX1NVUEVSRlVORCIsImRpZXNlbFBhcnRNYXR0ZXIiLCJESUVTRUxfUEFSVElDVUxBVEVfTUFUVEVSIiwiRElFU0VMX01BVFRFUl9QRVJDRU5USUxFIiwiSVNfRVhDRUVEU19USFJFU0hfRk9SX0RJRVNFTF9QTSIsImJhcnJpZXJUcmFuc3BvcnQiLCJCQVJSSUVSX1RSQU5TIiwiVFJBVkVMX0RJU0FEVl9QRVJDRU5USUxFIiwiSVNfRVhDRUVEU19USFJFU0hfVFJBVkVMX0RJU0FEViIsInRyYWZmaWNWb2x1bWUiLCJUUkFGRklDX1ZPTFVNRSIsIlRSQUZGSUNfUEVSQ0VOVElMRSIsIklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9UUkFGRklDX1BST1giLCJsZWFreVRhbmtzIiwiTEVBS1lfVEFOS1MiLCJMRUFLWV9VTkRFUl9QRVJDRU5USUxFIiwiSVNfRVhDRUVEU19USFJFU0hfTEVBS1lfVU5ERVIiLCJ3YXN0ZVdhdGVyIiwiV0FTVEVfV0FURVIiLCJXQVNURVdBVEVSX1BFUkNFTlRJTEUiLCJJU19FWENFRURTX1RIUkVTSF9GT1JfV0FTVEVXQVRFUiIsImxpbmdJc28iLCJMSU5HX0lTTyIsIkxJTkdVSVNUSUNfSVNPTEFUSU9OX1BST1BFUlRZX1BFUkNFTlRJTEUiLCJJU19FWENFRURTX1RIUkVTSF9GT1JfTElOR1VJU0lUSUNfSVNPIiwibG93TWVkSW5jIiwiTE9XX01FRF9JTkMiLCJMT1dfTUVEX0lOQ09NRSIsInVuZW1wbG95IiwiVU5FTVBMT1kiLCJwb3ZlcnR5IiwiUE9WRVJUWSIsImhpZ2hTY2hvb2wiLCJISUdIX1NDTCIsIkhJR0hfU0tMIiwidGl0bGVUZXh0IiwiU0lERV9QQU5FTF9DQVRFR09SWSIsIkNMSU1BVEUiLCJzb2Npb0VjSW5kaWNhdG9ycyIsIklTX0NMSU1BVEVfRkFDVE9SX0RJU0FEVkFOVEFHRUQiLCJpc0V4Y2VlZDFNb3JlQnVyZGVuIiwiSVNfQ0xJTUFURV9FWENFRURfT05FX09SX01PUkVfSU5ESUNBVE9SUyIsImlzRXhjZWVkQm90aFNvY2lvQnVyZGVucyIsIklTX0VYQ0VFRF9CT1RIX1NPQ0lPX0lORElDQVRPUlMiLCJDTEVBTl9FTkVSR1kiLCJJU19FTkVSR1lfRkFDVE9SX0RJU0FEVkFOVEFHRUQiLCJJU19FTkVSR1lfRVhDRUVEX09ORV9PUl9NT1JFX0lORElDQVRPUlMiLCJIRUFMVEhfQlVSREVOIiwiSVNfSEVBTFRIX0ZBQ1RPUl9ESVNBRFZBTlRBR0VEIiwiSVNfSEVBTFRIX0VYQ0VFRF9PTkVfT1JfTU9SRV9JTkRJQ0FUT1JTIiwiU1VTVEFJTl9IT1VTRSIsIklTX0hPVVNJTkdfRkFDVE9SX0RJU0FEVkFOVEFHRUQiLCJJU19IT1VTSU5HX0VYQ0VFRF9PTkVfT1JfTU9SRV9JTkRJQ0FUT1JTIiwiTEVHX1BPTExVVEUiLCJJU19QT0xMVVRJT05fRkFDVE9SX0RJU0FEVkFOVEFHRUQiLCJJU19QT0xMVVRJT05fRVhDRUVEX09ORV9PUl9NT1JFX0lORElDQVRPUlMiLCJDTEVBTl9UUkFOU1BPUlQiLCJJU19UUkFOU1BPUlRfRkFDVE9SX0RJU0FEVkFOVEFHRUQiLCJJU19UUkFOU1BPUlRfRVhDRUVEX09ORV9PUl9NT1JFX0lORElDQVRPUlMiLCJDTEVBTl9XQVRFUiIsIklTX1dBVEVSX0ZBQ1RPUl9ESVNBRFZBTlRBR0VEIiwiSVNfV0FURVJfRVhDRUVEX09ORV9PUl9NT1JFX0lORElDQVRPUlMiLCJXT1JLX0RFViIsIklTX1dPUktGT1JDRV9GQUNUT1JfRElTQURWQU5UQUdFRCIsIklTX1dPUktGT1JDRV9FWENFRURfT05FX09SX01PUkVfSU5ESUNBVE9SUyIsIklTX1dPUktGT1JDRV9FWENFRURfQk9USF9TT0NJT19JTkRJQ0FUT1JTIiwiUFVFUlRPX1JJQ08iLCJmaWx0ZXIiLCJpc1RlcnJpdG9yeSIsIlRJTEVTX0lTTEFORF9BUkVBX0ZJUFNfQ09ERVMiLCJzb21lIiwiY29kZSIsInN0YXJ0c1dpdGgiLCJJU19HUkFOREZBVEhFUkVEIiwic2hvd0RvbnV0Q29weSIsIlRPVEFMX05VTUJFUl9PRl9ESVNBRFZBTlRBR0VfSU5ESUNBVE9SUyIsInNob3dJc2xhbmRDb3B5IiwicG92ZXJ5UGVyY2VudGlsZSIsIkNFTlNVU19ERUNFTk5JQUxfUE9WRVJUWV9MRVNTX1RIQU5fMjAwX0ZQTF9QRVJDRU5USUxFIiwiY2F0ZWdvcnlJdGVtcyIsImNvbnRlbnQiLCJjYXRlZ29yeVNwYWNlciIsIkFORCIsImV4cGFuZGVkIiwiYXJlYURldGFpbENvbnRhaW5lciIsImNhdGVnb3JpemF0aW9uIiwiaXNJbkZvY3VzIiwiSVNfRk9DVVMiLCJjb21tdW5pdHlPZkZvY3VzIiwiU0NPUkVfTl9DT01NVU5JVElFUyIsInByaW9Db3B5IiwiQ09VTlRfT0ZfQ0FURUdPUklFU19ESVNBRFYiLCJBREpBQ0VOQ1lfTE9XX0lOQ09NRV9FWENFRURTX1RIUkVTSCIsInNlbmRGZWVkYmFja0xpbmsiLCJocmVmIiwibG9jYWxlIiwiQ0VOU1VTX1RSQUNUX1NVUlZFWV9MSU5LUyIsIkVTIiwiRU4iLCJ0YXJnZXQiLCJyZWwiLCJzZW5kRmVlZGJhY2tCdG4iLCJidXR0b25Db250YWluZXIiLCJidXR0b25UZXh0IiwiU0VORF9GRUVEQkFDSyIsIkxhdW5jaCIsIklNR19JQ09OIiwiQUxUX1RBRyIsIm11bHRpc2VsZWN0YWJsZSIsIml0ZW1zIiwidmVyc2lvbkluZm8iLCJTSURFX1BBTkVMX1ZFUlNJT04iLCJ1c2VXaW5kb3dTaXplIiwicGx1c0ljb24iLCJzZWFyY2hJY29uIiwibG9jYXRlSWNvbiIsInBlb3BsZUljb24iLCJmaWxlVXBJY29uIiwiY2hlY2tJY29uIiwicHV6emxlSWNvbiIsImJlbGxDdXJ2ZUljb24iLCJjZW5zdXNEb3RJY29uIiwicGllQ2hhcnRJY29uIiwiU2lkZVBhbmVsSW5mbyIsIndpZHRoIiwid2luZG93V2lkdGgiLCJzaWRlUGFuZWxJbmZvQ29udGFpbmVyIiwic2lkZVBhbmVsSW5mb1RpdGxlIiwiU0lERV9QQU5FTF9JTklUSUFMX1NUQVRFIiwiSEVBRElORzEiLCJQQVJBMV9QQVJUMSIsIlVTV0RTX0JSRUFLUE9JTlRTIiwiTU9CSUxFX0xHIiwic2lkZVBhbmVsSW5mb0ljb24iLCJQQVJBMV9QQVJUMiIsIlNFQVJDSCIsIlBBUkExX1BBUlQzIiwiTE9DQVRFIiwiUEFSQTFfUEFSVDQiLCJQQVJBMV9QQVJUNSIsInNpZGVQYW5lbEluZm9IZWFkaW5nIiwiSEVBRElORzIiLCJQQVJBMl9QQVJUMSIsIlRSQUNUIiwiUEFSQTJfUEFSVDIiLCJQRU9QTEUiLCJQQVJBMl9QQVJUMyIsIlBBUkEzX1BBUlQxIiwiREFDX0NJUkNMRSIsIlBBUkEzX1BBUlQyIiwiUEFSQTRfUEFSVDEiLCJCRUxMX0NVUlZFIiwiUEFSQTRfUEFSVDIiLCJQQVJBNV9QQVJUMSIsIkZJTEVfVVAiLCJQQVJBNV9QQVJUMiIsIlBJRV9DSEFSVCIsIlBBUkE1X1BBUlQzIiwiQ0hFQ0siLCJQQVJBNV9QQVJUNCIsIlBBUkE2X1BBUlQxIiwiUEFSQTZfUEFSVDIiLCJNYXBJbmZvUGFuZWwiLCJmZWF0dXJlUHJvcGVydGllcyIsImhhc2giLCJNYXBTZWFyY2hNZXNzYWdlIiwiaXNTZWFyY2hSZXN1bHRzTnVsbCIsInNob3dNZXNzYWdlIiwiaGlkZU1lc3NhZ2UiLCJNQVAiLCJTRUFSQ0hfUkVTVUxUU19FTVBUWV9NRVNTQUdFIiwidXNlRWZmZWN0IiwiU2VhcmNoIiwiSnNTZWFyY2giLCJNYXBTZWFyY2giLCJnb1RvUGxhY2UiLCJzZXRJc1NlYXJjaFJlc3VsdHNOdWxsIiwiaGVpZ2h0IiwicGxhY2Vob2xkZXJUZXh0Iiwic2V0UGxhY2Vob2xkZXJUZXh0IiwiU0VBUkNIX1BMQUNFSE9MREVSIiwidHJhY3RTZWFyY2giLCJzZXRUcmFjdFNlYXJjaCIsImdldFRyYWN0U2VhcmNoRGF0YSIsInNlYXJjaERhdGFVcmwiLCJUSUxFX0JBU0VfVVJMIiwiTUFQX1RSQUNUX1NFQVJDSF9QQVRIIiwiZmV0Y2giLCJ0aGVuIiwicmVzcG9uc2UiLCJvayIsImpzb24iLCJzdGF0dXNUZXh0Iiwic3RhdHVzIiwiZGF0YSIsInNlYXJjaCIsImluZGV4U3RyYXRlZ3kiLCJFeGFjdFdvcmRJbmRleFN0cmF0ZWd5IiwiYWRkSW5kZXgiLCJhZGREb2N1bWVudHMiLCJjYXRjaCIsImVycm9yIiwiU0VBUkNIX1BMQUNFSE9MREVSX01PQklMRSIsInNlYXJjaEZvclRyYWN0IiwidHJhY3QiLCJCT1VORElOR19CT1hfU0laRV9ERCIsIm5vcm1hbGl6ZWRUcmFjdElkIiwicmVzdWx0Iiwic2VhcmNoVHJhY3RSZWNvcmQiLCJsYXQiLCJJTlRQVExBVDEwIiwibG9uIiwiSU5UUFRMT04xMCIsImJvdW5kaW5nQm94IiwidG9TdHJpbmciLCJsYXRNaW4iLCJsYXRNYXgiLCJsb25nTWluIiwibG9uZ01heCIsInNlYXJjaEZvckxvY2F0aW9uIiwic2VhcmNoVGVybSIsInNlYXJjaFJlc3VsdHMiLCJtb2RlIiwiYm91bmRpbmdib3giLCJvblNlYXJjaEhhbmRsZXIiLCJldmVudCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiY3VycmVudFRhcmdldCIsImVsZW1lbnRzIiwibmFtZWRJdGVtIiwiaXNUcmFjdCIsInRlc3QiLCJtYXBTZWFyY2hDb250YWluZXIiLCJwbGFjZWhvbGRlciIsInNpemUiLCJvblN1Ym1pdCIsImUiLCJTb3VyY2UiLCJMYXllciIsInVzZUZsYWdzIiwiQ09NTU9OX0NPUFkiLCJmZWF0dXJlVVJMRm9yVGlsZXNldE5hbWUiLCJ0aWxlc2V0TmFtZSIsImZsYWdzIiwicGlwZWxpbmVTdGFnaW5nQmFzZVVSTCIsInByb2Nlc3MiLCJlbnYiLCJHQVRTQllfQ0ROX1RJTEVTX0JBU0VfVVJMIiwiWFlaX1NVRkZJWCIsInJlZ2V4IiwiQ09OU09MRV9FUlJPUiIsIlNUQUdFX1VSTCIsImZlYXR1cmVUaWxlQmFzZVVSTCIsImZlYXR1cmVUaWxlUGF0aCIsIlRJTEVfUEFUSCIsIkdBVFNCWV9NQVBfVElMRVNfUEFUSCIsImpvaW4iLCJNYXBUcmFjdExheWVycyIsInNlbGVjdGVkRmVhdHVyZXMiLCJzZWxlY3RlZEZlYXR1cmVJZHMiLCJmZWF0IiwiY29uY2F0IiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiTE9XX1pPT01fU09VUkNFX05BTUUiLCJwcm9tb3RlSWQiLCJ0aWxlcyIsIm1heHpvb20iLCJHTE9CQUxfTUFYX1pPT01fTE9XIiwibWluem9vbSIsIkdMT0JBTF9NSU5fWk9PTV9MT1ciLCJMT1dfWk9PTV9MQVlFUl9JRCIsIlNDT1JFX1NPVVJDRV9MQVlFUiIsIlNDT1JFX1BST1BFUlRZX0xPVyIsIlNDT1JFX0JPVU5EQVJZX1RIUkVTSE9MRCIsInBhaW50IiwiUFJJT1JJVElaRURfRkVBVFVSRV9GSUxMX0NPTE9SIiwiTE9XX1pPT01fUFJJT1JJVElaRURfRkVBVFVSRV9GSUxMX09QQUNJVFkiLCJISUdIX1pPT01fU09VUkNFX05BTUUiLCJHTE9CQUxfTUFYX1pPT01fSElHSCIsIkdMT0JBTF9NSU5fWk9PTV9ISUdIIiwiSElHSF9aT09NX0xBWUVSX0lEIiwiU0NPUkVfUFJPUEVSVFlfSElHSCIsIk5PTl9QUklPUklUSVpFRF9GRUFUVVJFX0ZJTExfT1BBQ0lUWSIsIlBSSU9SSVRJWkVEX0hJR0hfWk9PTV9MQVlFUl9JRCIsIkhJR0hfWk9PTV9QUklPUklUSVpFRF9GRUFUVVJFX0ZJTExfT1BBQ0lUWSIsIkdSQU5ERkFUSEVSRURfSElHSF9aT09NX0xBWUVSX0lEIiwiR1JBTkRGQVRIRVJFRF9GRUFUVVJFX0ZJTExfQ09MT1IiLCJGRUFUVVJFX0JPUkRFUl9MQVlFUl9JRCIsIkZFQVRVUkVfQk9SREVSX0NPTE9SIiwiRkVBVFVSRV9CT1JERVJfV0lEVEgiLCJGRUFUVVJFX0JPUkRFUl9PUEFDSVRZIiwiR0xPQkFMX01BWF9aT09NX0ZFQVRVUkVfQk9SREVSIiwiR0xPQkFMX01JTl9aT09NX0ZFQVRVUkVfQk9SREVSIiwiU0VMRUNURURfRkVBVFVSRV9CT1JERVJfTEFZRVJfSUQiLCJTRUxFQ1RFRF9GRUFUVVJFX0JPUkRFUl9DT0xPUiIsIlNFTEVDVEVEX0ZFQVRVUkVfQk9SREVSX1dJRFRIIiwidHJpYmFsVVJMIiwiR0FUU0JZX0RBVEFfUElQRUxJTkVfVFJJQkFMX1BBVEgiLCJNYXBUcmliYWxMYXllciIsIlRSSUJBTF9TT1VSQ0VfTkFNRSIsIlRSSUJBTF9JRCIsIlRSSUJBTF9MQVlFUl9JRCIsIlRSSUJBTF9TT1VSQ0VfTEFZRVIiLCJUUklCQUxfRkVBVFVSRV9GSUxMX09QQUNJVFkiLCJUUklCQUxfTUlOX1pPT00iLCJUUklCQUxfTUFYX1pPT00iLCJUUklCQUxfQUxBU0tBX1BPSU5UU19MQVlFUl9JRCIsIlRSSUJBTF9BTEFTS0FfQ0lSQ0xFX1JBRElVUyIsIlRSSUJBTF9BTEFTS0FfQ0lSQ0xFX0ZJTExfQ09MT1IiLCJUUklCQUxfQk9SREVSX0NPTE9SIiwiQUxBS1NBX1BPSU5UU19TVFJPS0VfV0lEVEgiLCJBTEFTS0FfTUlOX1pPT00iLCJBTEFTS0FfTUFYX1pPT00iLCJUUklCQUxfTEFCRUxTX0xBWUVSX0lEIiwibGF5b3V0IiwiTEFORF9BUkVBX05BTUUiLCJUZXJyaXRvcnlGb2N1c0NvbnRyb2wiLCJ0ZXJyaXRvcmllcyIsInNob3J0IiwiTE9XRVI0OF9TSE9SVCIsImxvbmciLCJMT1dFUjQ4X0xPTkciLCJBTEFTS0FfU0hPUlQiLCJBTEFTS0FfTE9ORyIsIkhBV0FJSV9TSE9SVCIsIkhBV0FJSV9MT05HIiwiUFJfU0hPUlQiLCJQUl9MT05HIiwiR1VfU0hPUlQiLCJHVV9MT05HIiwiQVNfU0hPUlQiLCJBU19MT05HIiwiTVBfU0hPUlQiLCJNUF9MT05HIiwiVklfU0hPUlQiLCJWSV9MT05HIiwidGVycml0b3JpZXNJY29uQ2xhc3NOYW1lIiwidGVycml0b3J5Rm9jdXNDb250YWluZXIiLCJ0ZXJyaXRvcnkiLCJvbkNsaWNrQ2FwdHVyZSIsIkFsZXJ0IiwiR3JpZCIsImRlbGV0ZUljb24iLCJDcmVhdGVSZXBvcnRQYW5lbCIsImZlYXR1cmVMaXN0IiwibWF4TnVtVHJhY3RzIiwic2hvd1Rvb01hbnlUcmFjdHNBbGVydCIsImRlbGV0ZVRyYWN0SGFuZGxlciIsImV4aXRIYW5kbGVyIiwibnVtUHJldlRyYWN0cyIsInNldE51bVByZXZUcmFjdHMiLCJjb250YWluZXIiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwic2Nyb2xsVG9wIiwic2Nyb2xsSGVpZ2h0IiwiaGFuZGxlQ3JlYXRlUmVwb3J0IiwiY3JlYXRlUmVwb3J0Q29udGFpbmVyIiwic2xpbSIsInRyYWN0TGlzdENvbnRhaW5lciIsIml0ZW0iLCJyb3ciLCJ0cmFjdExpc3RJdGVtSGlnaGxpZ2h0IiwidHJhY3RMaXN0SXRlbSIsImNvbCIsInRyYWN0TGlzdEl0ZW1EZWxldGUiLCJ1bnN0eWxlZCIsImNyZWF0ZVJlcG9ydEJ1dHRvbiIsImRpc2FibGVkIiwic3RhcnRPdmVyIiwidXNlUmVmIiwiUmVhY3RNYXBHTCIsIldlYk1lcmNhdG9yVmlld3BvcnQiLCJOYXZpZ2F0aW9uQ29udHJvbCIsIkdlb2xvY2F0ZUNvbnRyb2wiLCJQb3B1cCIsIkZseVRvSW50ZXJwb2xhdG9yIiwiRnVsbHNjcmVlbkNvbnRyb2wiLCJiYm94IiwiZDMiLCJpc01vYmlsZSIsInVzZUxvY2FsU3RvcmFnZSIsIk1BWF9TRUxFQ1RFRF9UUkFDVFMiLCJKNDBNYXAiLCJfbWFwUmVmJGN1cnJlbnQiLCJsb2NhdGlvbiIsInpvb20iLCJsbmciLCJzcGxpdCIsInZpZXdwb3J0Iiwic2V0Vmlld3BvcnQiLCJsYXRpdHVkZSIsIkRFRkFVTFRfQ0VOVEVSIiwibG9uZ2l0dWRlIiwiR0xPQkFMX01JTl9aT09NIiwic2V0U2VsZWN0ZWRGZWF0dXJlcyIsImRldGFpbFZpZXdEYXRhIiwic2V0RGV0YWlsVmlld0RhdGEiLCJ0cmFuc2l0aW9uSW5Qcm9ncmVzcyIsInNldFRyYW5zaXRpb25JblByb2dyZXNzIiwiZ2VvbG9jYXRpb25JblByb2dyZXNzIiwic2V0R2VvbG9jYXRpb25JblByb2dyZXNzIiwiaXNNb2JpbGVNYXBTdGF0ZSIsInNldElzTW9iaWxlTWFwU3RhdGUiLCJpbk11bHRpU2VsZWN0TW9kZSIsInNldEluTXVsdGlTZWxlY3RNb2RlIiwic2V0U2hvd1Rvb01hbnlUcmFjdHNBbGVydCIsInNlbGVjdFRyYWN0SWQiLCJzZXRTZWxlY3RUcmFjdElkIiwiaXNHZW9sb2NhdGVMb2NrZWQiLCJzZXRJc0dlb2xvY2F0ZUxvY2tlZCIsInJlbW92ZUdlb2xvY2F0ZUxvY2siLCJyYXciLCJtYXBSZWYiLCJ6b29tTGF0TG5nSGFzaCIsImN1cnJlbnQiLCJnZXRNYXAiLCJfaGFzaCIsIl9nZXRDdXJyZW50SGFzaCIsImdldEZlYXR1cmVzQmJveCIsIm1pbkxuZ0xpc3QiLCJtaW5MYXRMaXN0IiwibWF4TG5nTGlzdCIsIm1heExhdExpc3QiLCJmb3JFYWNoIiwiZmVhdHVyZSIsImZlYXRNaW5MbmciLCJmZWF0TWluTGF0IiwiZmVhdE1heExuZyIsImZlYXRNYXhMYXQiLCJwdXNoIiwibWluTG5nIiwibWluIiwiYXBwbHkiLCJtaW5MYXQiLCJtYXgiLCJtYXhMbmciLCJtYXhMYXQiLCJ1cGRhdGVTZWxlY3RlZEZlYXR1cmVzIiwiaXNNdWx0aVNlbGVjdCIsImV4aXN0cyIsInNlbGVjdEZlYXR1cmVzT25NYXAiLCJpc011bHRpU2VsZWN0S2V5RG93biIsImZlYXR1cmVzTGlzdCIsIm5ld1ZpZXdQb3J0IiwiZml0Qm91bmRzIiwicGFkZGluZyIsInBvcHVwSW5mbyIsIl9zdG9wUHJvcGFnYXRpb24iLCJjYWxsIiwiYnV0dG9uSUQiLCJMT1dFUl80OF9CT1VORFMiLCJBTEFTS0FfQk9VTkRTIiwiSEFXQUlJX0JPVU5EUyIsIlBVRVJUT19SSUNPX0JPVU5EUyIsIkdVQU1fQk9VTkRTIiwiQU1FUklDQU5fU0FNT0FfQk9VTkRTIiwiTUFSSUFOQV9JU0xBTkRfQk9VTkRTIiwiVVNfVklSR0lOX0lTTEFORFNfQk9VTkRTIiwibm9kZU5hbWUiLCJmZWF0dXJlcyIsInNyY0V2ZW50IiwiY3RybEtleSIsIm9uTG9hZCIsIndpbmRvdyIsIkN5cHJlc3MiLCJ1bmRlcmx5aW5nTWFwIiwiYm91bmRzIiwiZmVhdHVyZVNlbGVjdGlvblpvb21MZXZlbCIsInRyYW5zaXRpb25EdXJhdGlvbiIsInRyYW5zaXRpb25JbnRlcnBvbGF0b3IiLCJ0cmFuc2l0aW9uRWFzaW5nIiwiZWFzZUN1YmljIiwib25UcmFuc2l0aW9uU3RhcnQiLCJvblRyYW5zaXRpb25FbmQiLCJfbWFwUmVmJGN1cnJlbnQyIiwiZ2VvaWRTZWFyY2hSZXN1bHRzIiwicXVlcnlTb3VyY2VGZWF0dXJlcyIsInNvdXJjZUxheWVyIiwidmFsaWRhdGUiLCJvbkdlb2xvY2F0ZSIsIm9uQ2xpY2tHZW9sb2NhdGUiLCJvblJlcG9ydERlbGV0ZVRyYWN0Iiwib25SZXBvcnRFeGl0IiwiZGVza3RvcCIsImo0ME1hcCIsIk9iamVjdCIsImFzc2lnbiIsIm1hcGJveEFwaUFjY2Vzc1Rva2VuIiwiTUFQQk9YX1NUWUxFU19SRUFEX1RPS0VOIiwibWFwU3R5bGUiLCJtYXBPcHRpb25zIiwibWF4Wm9vbSIsIkdMT0JBTF9NQVhfWk9PTSIsIm1pblpvb20iLCJkcmFnUm90YXRlIiwidG91Y2hSb3RhdGUiLCJpbnRlcmFjdGl2ZUxheWVySWRzIiwib25WaWV3cG9ydENoYW5nZSIsInJlZiIsIm1hcEhlYWRlclJvdyIsImdlb2xvY2F0ZUJveCIsImdlb2xvY2F0ZU1lc3NhZ2UiLCJnZW9sb2NhdGVNZXNzYWdlSGlkZSIsIkdFT0xPQ19NU0dfTE9DQVRJTkciLCJwb3NpdGlvbk9wdGlvbnMiLCJlbmFibGVIaWdoQWNjdXJhY3kiLCJ0cmFja1VzZXJMb2NhdGlvbiIsInNob3dVc2VySGVhZGluZyIsInNob3dDb21wYXNzIiwibmF2aWdhdGlvbkNvbnRyb2wiLCJqNDBQb3B1cCIsInRpcFNpemUiLCJhbmNob3IiLCJjbG9zZU9uQ2xpY2siLCJvbkNsb3NlIiwiY2FwdHVyZVNjcm9sbCIsImZ1bGxzY3JlZW5Db250cm9sIiwibWFwSW5mb1BhbmVsIiwiSjQwTWFpbkdyaWRDb250YWluZXIiLCJMYXlvdXQiLCJEYXRhc2V0c0J1dHRvbiIsIkRBVEFfU1VSVkVZX0xJTktTIiwiRXhwb3JlVG9vbFBhZ2UiLCJQQUdFX0lOVFJPIiwiUEFHRV9USUxFIiwiUEFHRV9IRUFESU5HIiwiZ2FwIiwidGFibGV0IiwiUEFHRV9ERVNDUklQVElPTjEiLCJQQUdFX0RFU0NSSVBUSU9OMiIsIk5PVEVfT05fVEVSUklUT1JJRVMiLCJJTlRSTyIsIlBBUkFfMCIsIlBBUkFfMSIsIlBBUkFfMiIsIk5PVEVfT05fVFJJQkFMX05BVElPTlMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///31254\n")},95477:function(__unused_webpack_module,__webpack_exports__){"use strict";eval('/* harmony default export */ __webpack_exports__.A = ("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTEyIDhsLTYgNiAxLjQxIDEuNDFMMTIgMTAuODNsNC41OSA0LjU4TDE4IDE0eiIvPjwvc3ZnPg==");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTU0NzcuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0RBQWUsb0JBQW9CLGdRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL2V4cGFuZF9sZXNzLnN2Zz9jNWRjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUdobGFXZG9kRDBpTWpRaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSWdkMmxrZEdnOUlqSTBJajQ4Y0dGMGFDQmtQU0pOTUNBd2FESTBkakkwU0RCNklpQm1hV3hzUFNKdWIyNWxJaTgrUEhCaGRHZ2daRDBpVFRFeUlEaHNMVFlnTmlBeExqUXhJREV1TkRGTU1USWdNVEF1T0ROc05DNDFPU0EwTGpVNFRERTRJREUwZWlJdlBqd3ZjM1puUGc9PVwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///95477\n')},17709:function(__unused_webpack_module,__webpack_exports__){"use strict";eval('/* harmony default export */ __webpack_exports__.A = ("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE2LjU5IDguNTlMMTIgMTMuMTcgNy40MSA4LjU5IDYgMTBsNiA2IDYtNnoiLz48L3N2Zz4=");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc3MDkuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0RBQWUsb0JBQW9CLDRQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL2V4cGFuZF9tb3JlLnN2Zz9iZDczIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUdobGFXZG9kRDBpTWpRaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSWdkMmxrZEdnOUlqSTBJajQ4Y0dGMGFDQmtQU0pOTUNBd2FESTBkakkwU0RCNklpQm1hV3hzUFNKdWIyNWxJaTgrUEhCaGRHZ2daRDBpVFRFMkxqVTVJRGd1TlRsTU1USWdNVE11TVRjZ055NDBNU0E0TGpVNUlEWWdNVEJzTmlBMklEWXRObm9pTHo0OEwzTjJaejQ9XCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17709\n')}}]);