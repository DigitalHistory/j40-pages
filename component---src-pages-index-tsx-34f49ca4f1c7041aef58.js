(self.webpackChunkjustice40_tool=self.webpackChunkjustice40_tool||[]).push([[245],{75645:function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function (window, document, exportName, undefined) {\n  'use strict';\n\n  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n  var TEST_ELEMENT = document.createElement('div');\n  var TYPE_FUNCTION = 'function';\n  var round = Math.round;\n  var abs = Math.abs;\n  var now = Date.now;\n\n  /**\n   * set a timeout with a given scope\n   * @param {Function} fn\n   * @param {Number} timeout\n   * @param {Object} context\n   * @returns {number}\n   */\n  function setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n  }\n\n  /**\n   * if the argument is an array, we want to execute the fn on each entry\n   * if it aint an array we don't want to do a thing.\n   * this is used by all the methods that accept a single and array argument.\n   * @param {*|Array} arg\n   * @param {String} fn\n   * @param {Object} [context]\n   * @returns {Boolean}\n   */\n  function invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n      each(arg, context[fn], context);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * walk objects and arrays\n   * @param {Object} obj\n   * @param {Function} iterator\n   * @param {Object} context\n   */\n  function each(obj, iterator, context) {\n    var i;\n    if (!obj) {\n      return;\n    }\n    if (obj.forEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n      i = 0;\n      while (i < obj.length) {\n        iterator.call(context, obj[i], i, obj);\n        i++;\n      }\n    } else {\n      for (i in obj) {\n        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n      }\n    }\n  }\n\n  /**\n   * wrap a method with a deprecation warning and stack trace\n   * @param {Function} method\n   * @param {String} name\n   * @param {String} message\n   * @returns {Function} A new function wrapping the supplied method.\n   */\n  function deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function () {\n      var e = new Error('get-stack-trace');\n      var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n      var log = window.console && (window.console.warn || window.console.log);\n      if (log) {\n        log.call(window.console, deprecationMessage, stack);\n      }\n      return method.apply(this, arguments);\n    };\n  }\n\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} target\n   * @param {...Object} objects_to_assign\n   * @returns {Object} target\n   */\n  var assign;\n  if (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n      var output = Object(target);\n      for (var index = 1; index < arguments.length; index++) {\n        var source = arguments[index];\n        if (source !== undefined && source !== null) {\n          for (var nextKey in source) {\n            if (source.hasOwnProperty(nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n      return output;\n    };\n  } else {\n    assign = Object.assign;\n  }\n\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} dest\n   * @param {Object} src\n   * @param {Boolean} [merge=false]\n   * @returns {Object} dest\n   */\n  var extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n      if (!merge || merge && dest[keys[i]] === undefined) {\n        dest[keys[i]] = src[keys[i]];\n      }\n      i++;\n    }\n    return dest;\n  }, 'extend', 'Use `assign`.');\n\n  /**\n   * merge the values from src in the dest.\n   * means that properties that exist in dest will not be overwritten by src\n   * @param {Object} dest\n   * @param {Object} src\n   * @returns {Object} dest\n   */\n  var merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n  }, 'merge', 'Use `assign`.');\n\n  /**\n   * simple class inheritance\n   * @param {Function} child\n   * @param {Function} base\n   * @param {Object} [properties]\n   */\n  function inherit(child, base, properties) {\n    var baseP = base.prototype,\n      childP;\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n    if (properties) {\n      assign(childP, properties);\n    }\n  }\n\n  /**\n   * simple function bind\n   * @param {Function} fn\n   * @param {Object} context\n   * @returns {Function}\n   */\n  function bindFn(fn, context) {\n    return function boundFn() {\n      return fn.apply(context, arguments);\n    };\n  }\n\n  /**\n   * let a boolean value also be a function that must return a boolean\n   * this first item in args will be used as the context\n   * @param {Boolean|Function} val\n   * @param {Array} [args]\n   * @returns {Boolean}\n   */\n  function boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n      return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n  }\n\n  /**\n   * use the val2 when val1 is undefined\n   * @param {*} val1\n   * @param {*} val2\n   * @returns {*}\n   */\n  function ifUndefined(val1, val2) {\n    return val1 === undefined ? val2 : val1;\n  }\n\n  /**\n   * addEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n  function addEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.addEventListener(type, handler, false);\n    });\n  }\n\n  /**\n   * removeEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n  function removeEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.removeEventListener(type, handler, false);\n    });\n  }\n\n  /**\n   * find if a node is in the given parent\n   * @method hasParent\n   * @param {HTMLElement} node\n   * @param {HTMLElement} parent\n   * @return {Boolean} found\n   */\n  function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n      node = node.parentNode;\n    }\n    return false;\n  }\n\n  /**\n   * small indexOf wrapper\n   * @param {String} str\n   * @param {String} find\n   * @returns {Boolean} found\n   */\n  function inStr(str, find) {\n    return str.indexOf(find) > -1;\n  }\n\n  /**\n   * split string on whitespace\n   * @param {String} str\n   * @returns {Array} words\n   */\n  function splitStr(str) {\n    return str.trim().split(/\\s+/g);\n  }\n\n  /**\n   * find if a array contains the object using indexOf or a simple polyFill\n   * @param {Array} src\n   * @param {String} find\n   * @param {String} [findByKey]\n   * @return {Boolean|Number} false when not found, or the index\n   */\n  function inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n      return src.indexOf(find);\n    } else {\n      var i = 0;\n      while (i < src.length) {\n        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n          return i;\n        }\n        i++;\n      }\n      return -1;\n    }\n  }\n\n  /**\n   * convert array-like objects to real arrays\n   * @param {Object} obj\n   * @returns {Array}\n   */\n  function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  }\n\n  /**\n   * unique array with objects based on a key (like 'id') or just by the array's value\n   * @param {Array} src [{id:1},{id:2},{id:1}]\n   * @param {String} [key]\n   * @param {Boolean} [sort=False]\n   * @returns {Array} [{id:1},{id:2}]\n   */\n  function uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n    while (i < src.length) {\n      var val = key ? src[i][key] : src[i];\n      if (inArray(values, val) < 0) {\n        results.push(src[i]);\n      }\n      values[i] = val;\n      i++;\n    }\n    if (sort) {\n      if (!key) {\n        results = results.sort();\n      } else {\n        results = results.sort(function sortUniqueArray(a, b) {\n          return a[key] > b[key];\n        });\n      }\n    }\n    return results;\n  }\n\n  /**\n   * get the prefixed property\n   * @param {Object} obj\n   * @param {String} property\n   * @returns {String|Undefined} prefixed\n   */\n  function prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n      prefix = VENDOR_PREFIXES[i];\n      prop = prefix ? prefix + camelProp : property;\n      if (prop in obj) {\n        return prop;\n      }\n      i++;\n    }\n    return undefined;\n  }\n\n  /**\n   * get a unique id\n   * @returns {number} uniqueId\n   */\n  var _uniqueId = 1;\n  function uniqueId() {\n    return _uniqueId++;\n  }\n\n  /**\n   * get the window object of an element\n   * @param {HTMLElement} element\n   * @returns {DocumentView|Window}\n   */\n  function getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return doc.defaultView || doc.parentWindow || window;\n  }\n  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n  var SUPPORT_TOUCH = 'ontouchstart' in window;\n  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n  var INPUT_TYPE_TOUCH = 'touch';\n  var INPUT_TYPE_PEN = 'pen';\n  var INPUT_TYPE_MOUSE = 'mouse';\n  var INPUT_TYPE_KINECT = 'kinect';\n  var COMPUTE_INTERVAL = 25;\n  var INPUT_START = 1;\n  var INPUT_MOVE = 2;\n  var INPUT_END = 4;\n  var INPUT_CANCEL = 8;\n  var DIRECTION_NONE = 1;\n  var DIRECTION_LEFT = 2;\n  var DIRECTION_RIGHT = 4;\n  var DIRECTION_UP = 8;\n  var DIRECTION_DOWN = 16;\n  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n  var PROPS_XY = ['x', 'y'];\n  var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n  /**\n   * create new input type manager\n   * @param {Manager} manager\n   * @param {Function} callback\n   * @returns {Input}\n   * @constructor\n   */\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n    this.init();\n  }\n  Input.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function () {},\n    /**\n     * bind the events\n     */\n    init: function () {\n      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n    /**\n     * unbind the events\n     */\n    destroy: function () {\n      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n  };\n\n  /**\n   * create new input type manager\n   * called by the Manager constructor\n   * @param {Hammer} manager\n   * @returns {Input}\n   */\n  function createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n    if (inputClass) {\n      Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n      Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n      Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n      Type = MouseInput;\n    } else {\n      Type = TouchMouseInput;\n    }\n    return new Type(manager, inputHandler);\n  }\n\n  /**\n   * handle input events\n   * @param {Manager} manager\n   * @param {String} eventType\n   * @param {Object} input\n   */\n  function inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n    if (isFirst) {\n      manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n    manager.recognize(input);\n    manager.session.prevInput = input;\n  }\n\n  /**\n   * extend the data with some usable properties like scale, rotate, velocity etc\n   * @param {Object} manager\n   * @param {Object} input\n   */\n  function computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n      session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n      session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n      session.firstMultiple = false;\n    }\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n    input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n      target = input.srcEvent.target;\n    }\n    input.target = target;\n  }\n  function computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n      prevDelta = session.prevDelta = {\n        x: prevInput.deltaX || 0,\n        y: prevInput.deltaY || 0\n      };\n      offset = session.offsetDelta = {\n        x: center.x,\n        y: center.y\n      };\n    }\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n  }\n\n  /**\n   * velocity is calculated every x ms\n   * @param {Object} session\n   * @param {Object} input\n   */\n  function computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n      deltaTime = input.timeStamp - last.timeStamp,\n      velocity,\n      velocityX,\n      velocityY,\n      direction;\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n      var deltaX = input.deltaX - last.deltaX;\n      var deltaY = input.deltaY - last.deltaY;\n      var v = getVelocity(deltaTime, deltaX, deltaY);\n      velocityX = v.x;\n      velocityY = v.y;\n      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n      direction = getDirection(deltaX, deltaY);\n      session.lastInterval = input;\n    } else {\n      // use latest velocity info if it doesn't overtake a minimum period\n      velocity = last.velocity;\n      velocityX = last.velocityX;\n      velocityY = last.velocityY;\n      direction = last.direction;\n    }\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n  }\n\n  /**\n   * create a simple clone from the input used for storage of firstInput and firstMultiple\n   * @param {Object} input\n   * @returns {Object} clonedInputData\n   */\n  function simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n      pointers[i] = {\n        clientX: round(input.pointers[i].clientX),\n        clientY: round(input.pointers[i].clientY)\n      };\n      i++;\n    }\n    return {\n      timeStamp: now(),\n      pointers: pointers,\n      center: getCenter(pointers),\n      deltaX: input.deltaX,\n      deltaY: input.deltaY\n    };\n  }\n\n  /**\n   * get the center of all the pointers\n   * @param {Array} pointers\n   * @return {Object} center contains `x` and `y` properties\n   */\n  function getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n      return {\n        x: round(pointers[0].clientX),\n        y: round(pointers[0].clientY)\n      };\n    }\n    var x = 0,\n      y = 0,\n      i = 0;\n    while (i < pointersLength) {\n      x += pointers[i].clientX;\n      y += pointers[i].clientY;\n      i++;\n    }\n    return {\n      x: round(x / pointersLength),\n      y: round(y / pointersLength)\n    };\n  }\n\n  /**\n   * calculate the velocity between two points. unit is in px per ms.\n   * @param {Number} deltaTime\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Object} velocity `x` and `y`\n   */\n  function getVelocity(deltaTime, x, y) {\n    return {\n      x: x / deltaTime || 0,\n      y: y / deltaTime || 0\n    };\n  }\n\n  /**\n   * get the direction between two points\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Number} direction\n   */\n  function getDirection(x, y) {\n    if (x === y) {\n      return DIRECTION_NONE;\n    }\n    if (abs(x) >= abs(y)) {\n      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  }\n\n  /**\n   * calculate the absolute distance between two points\n   * @param {Object} p1 {x, y}\n   * @param {Object} p2 {x, y}\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} distance\n   */\n  function getDistance(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n      y = p2[props[1]] - p1[props[1]];\n    return Math.sqrt(x * x + y * y);\n  }\n\n  /**\n   * calculate the angle between two coordinates\n   * @param {Object} p1\n   * @param {Object} p2\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} angle\n   */\n  function getAngle(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n      y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n  }\n\n  /**\n   * calculate the rotation degrees between two pointersets\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} rotation\n   */\n  function getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n  }\n\n  /**\n   * calculate the scale factor between two pointersets\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} scale\n   */\n  function getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n  }\n  var MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n  };\n  var MOUSE_ELEMENT_EVENTS = 'mousedown';\n  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n  /**\n   * Mouse events input\n   * @constructor\n   * @extends Input\n   */\n  function MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n  }\n  inherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n      var eventType = MOUSE_INPUT_MAP[ev.type];\n\n      // on start we want to have the left mouse button down\n      if (eventType & INPUT_START && ev.button === 0) {\n        this.pressed = true;\n      }\n      if (eventType & INPUT_MOVE && ev.which !== 1) {\n        eventType = INPUT_END;\n      }\n\n      // mouse must be down\n      if (!this.pressed) {\n        return;\n      }\n      if (eventType & INPUT_END) {\n        this.pressed = false;\n      }\n      this.callback(this.manager, eventType, {\n        pointers: [ev],\n        changedPointers: [ev],\n        pointerType: INPUT_TYPE_MOUSE,\n        srcEvent: ev\n      });\n    }\n  });\n  var POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n  };\n\n  // in IE10 the pointer types is defined as an enum\n  var IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n  };\n  var POINTER_ELEMENT_EVENTS = 'pointerdown';\n  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n  // IE10 has prefixed support, and case-sensitive\n  if (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n  }\n\n  /**\n   * Pointer events input\n   * @constructor\n   * @extends Input\n   */\n  function PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n    Input.apply(this, arguments);\n    this.store = this.manager.session.pointerEvents = [];\n  }\n  inherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n      var store = this.store;\n      var removePointer = false;\n      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n      var isTouch = pointerType == INPUT_TYPE_TOUCH;\n\n      // get index of the event in the store\n      var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n      // start and mouse must be down\n      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n        if (storeIndex < 0) {\n          store.push(ev);\n          storeIndex = store.length - 1;\n        }\n      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        removePointer = true;\n      }\n\n      // it not found, so the pointer hasn't been down (so it's probably a hover)\n      if (storeIndex < 0) {\n        return;\n      }\n\n      // update the event in the store\n      store[storeIndex] = ev;\n      this.callback(this.manager, eventType, {\n        pointers: store,\n        changedPointers: [ev],\n        pointerType: pointerType,\n        srcEvent: ev\n      });\n      if (removePointer) {\n        // remove from the store\n        store.splice(storeIndex, 1);\n      }\n    }\n  });\n  var SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n  /**\n   * Touch events input\n   * @constructor\n   * @extends Input\n   */\n  function SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n    Input.apply(this, arguments);\n  }\n  inherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n      var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n      // should we handle the touch events?\n      if (type === INPUT_START) {\n        this.started = true;\n      }\n      if (!this.started) {\n        return;\n      }\n      var touches = normalizeSingleTouches.call(this, ev, type);\n\n      // when done, reset the started state\n      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n        this.started = false;\n      }\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n  function normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n    return [all, changed];\n  }\n  var TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n  /**\n   * Multi-user touch events input\n   * @constructor\n   * @extends Input\n   */\n  function TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n    Input.apply(this, arguments);\n  }\n  inherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n      var type = TOUCH_INPUT_MAP[ev.type];\n      var touches = getTouches.call(this, ev, type);\n      if (!touches) {\n        return;\n      }\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n  function getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n      targetIds[allTouches[0].identifier] = true;\n      return [allTouches, allTouches];\n    }\n    var i,\n      targetTouches,\n      changedTouches = toArray(ev.changedTouches),\n      changedTargetTouches = [],\n      target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function (touch) {\n      return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n      i = 0;\n      while (i < targetTouches.length) {\n        targetIds[targetTouches[i].identifier] = true;\n        i++;\n      }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n      if (targetIds[changedTouches[i].identifier]) {\n        changedTargetTouches.push(changedTouches[i]);\n      }\n\n      // cleanup removed touches\n      if (type & (INPUT_END | INPUT_CANCEL)) {\n        delete targetIds[changedTouches[i].identifier];\n      }\n      i++;\n    }\n    if (!changedTargetTouches.length) {\n      return;\n    }\n    return [\n    // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n  }\n\n  /**\n   * Combined touch and mouse input\n   *\n   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n   * This because touch devices also emit mouse events while doing a touch.\n   *\n   * @constructor\n   * @extends Input\n   */\n\n  var DEDUP_TIMEOUT = 2500;\n  var DEDUP_DISTANCE = 25;\n  function TouchMouseInput() {\n    Input.apply(this, arguments);\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n    this.primaryTouch = null;\n    this.lastTouches = [];\n  }\n  inherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n      var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,\n        isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;\n      if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n        return;\n      }\n\n      // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n      if (isTouch) {\n        recordTouches.call(this, inputEvent, inputData);\n      } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n        return;\n      }\n      this.callback(manager, inputEvent, inputData);\n    },\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    }\n  });\n  function recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n      this.primaryTouch = eventData.changedPointers[0].identifier;\n      setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      setLastTouch.call(this, eventData);\n    }\n  }\n  function setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n    if (touch.identifier === this.primaryTouch) {\n      var lastTouch = {\n        x: touch.clientX,\n        y: touch.clientY\n      };\n      this.lastTouches.push(lastTouch);\n      var lts = this.lastTouches;\n      var removeLastTouch = function () {\n        var i = lts.indexOf(lastTouch);\n        if (i > -1) {\n          lts.splice(i, 1);\n        }\n      };\n      setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n  }\n  function isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX,\n      y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n      var t = this.lastTouches[i];\n      var dx = Math.abs(x - t.x),\n        dy = Math.abs(y - t.y);\n      if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n  // magical touchAction value\n  var TOUCH_ACTION_COMPUTE = 'compute';\n  var TOUCH_ACTION_AUTO = 'auto';\n  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n  var TOUCH_ACTION_NONE = 'none';\n  var TOUCH_ACTION_PAN_X = 'pan-x';\n  var TOUCH_ACTION_PAN_Y = 'pan-y';\n  var TOUCH_ACTION_MAP = getTouchActionProps();\n\n  /**\n   * Touch Action\n   * sets the touchAction property or uses the js alternative\n   * @param {Manager} manager\n   * @param {String} value\n   * @constructor\n   */\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  TouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function (value) {\n      // find out the touch-action by the event handlers\n      if (value == TOUCH_ACTION_COMPUTE) {\n        value = this.compute();\n      }\n      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n      }\n      this.actions = value.toLowerCase().trim();\n    },\n    /**\n     * just re-set the touchAction value\n     */\n    update: function () {\n      this.set(this.manager.options.touchAction);\n    },\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function () {\n      var actions = [];\n      each(this.manager.recognizers, function (recognizer) {\n        if (boolOrFn(recognizer.options.enable, [recognizer])) {\n          actions = actions.concat(recognizer.getTouchAction());\n        }\n      });\n      return cleanTouchActions(actions.join(' '));\n    },\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function (input) {\n      var srcEvent = input.srcEvent;\n      var direction = input.offsetDirection;\n\n      // if the touch action did prevented once this session\n      if (this.manager.session.prevented) {\n        srcEvent.preventDefault();\n        return;\n      }\n      var actions = this.actions;\n      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n      if (hasNone) {\n        //do not prevent defaults if this is a tap gesture\n\n        var isTapPointer = input.pointers.length === 1;\n        var isTapMovement = input.distance < 2;\n        var isTapTouchTime = input.deltaTime < 250;\n        if (isTapPointer && isTapMovement && isTapTouchTime) {\n          return;\n        }\n      }\n      if (hasPanX && hasPanY) {\n        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n        return;\n      }\n      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n        return this.preventSrc(srcEvent);\n      }\n    },\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function (srcEvent) {\n      this.manager.session.prevented = true;\n      srcEvent.preventDefault();\n    }\n  };\n\n  /**\n   * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n   * @param {String} actions\n   * @returns {*}\n   */\n  function cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n      return TOUCH_ACTION_NONE;\n    }\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n      return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n      return TOUCH_ACTION_MANIPULATION;\n    }\n    return TOUCH_ACTION_AUTO;\n  }\n  function getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n      return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n      // If css.supports is not supported but there is native touch-action assume it supports\n      // all values. This is the case for IE 10 and 11.\n      touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n  }\n\n  /**\n   * Recognizer flow explained; *\n   * All recognizers have the initial state of POSSIBLE when a input session starts.\n   * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n   * Example session for mouse-input: mousedown -> mousemove -> mouseup\n   *\n   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n   * which determines with state it should be.\n   *\n   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n   * POSSIBLE to give it another change on the next cycle.\n   *\n   *               Possible\n   *                  |\n   *            +-----+---------------+\n   *            |                     |\n   *      +-----+-----+               |\n   *      |           |               |\n   *   Failed      Cancelled          |\n   *                          +-------+------+\n   *                          |              |\n   *                      Recognized       Began\n   *                                         |\n   *                                      Changed\n   *                                         |\n   *                                  Ended/Recognized\n   */\n  var STATE_POSSIBLE = 1;\n  var STATE_BEGAN = 2;\n  var STATE_CHANGED = 4;\n  var STATE_ENDED = 8;\n  var STATE_RECOGNIZED = STATE_ENDED;\n  var STATE_CANCELLED = 16;\n  var STATE_FAILED = 32;\n\n  /**\n   * Recognizer\n   * Every recognizer needs to extend from this class.\n   * @constructor\n   * @param {Object} options\n   */\n  function Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n    this.id = uniqueId();\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  Recognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function (options) {\n      assign(this.options, options);\n\n      // also update the touchAction, in case something changed about the directions/enabled state\n      this.manager && this.manager.touchAction.update();\n      return this;\n    },\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n        return this;\n      }\n      var simultaneous = this.simultaneous;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      if (!simultaneous[otherRecognizer.id]) {\n        simultaneous[otherRecognizer.id] = otherRecognizer;\n        otherRecognizer.recognizeWith(this);\n      }\n      return this;\n    },\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n        return this;\n      }\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      delete this.simultaneous[otherRecognizer.id];\n      return this;\n    },\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n        return this;\n      }\n      var requireFail = this.requireFail;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      if (inArray(requireFail, otherRecognizer) === -1) {\n        requireFail.push(otherRecognizer);\n        otherRecognizer.requireFailure(this);\n      }\n      return this;\n    },\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n        return this;\n      }\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      var index = inArray(this.requireFail, otherRecognizer);\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n      return this;\n    },\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function () {\n      return this.requireFail.length > 0;\n    },\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function (otherRecognizer) {\n      return !!this.simultaneous[otherRecognizer.id];\n    },\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function (input) {\n      var self = this;\n      var state = this.state;\n      function emit(event) {\n        self.manager.emit(event, input);\n      }\n\n      // 'panstart' and 'panmove'\n      if (state < STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n      emit(self.options.event); // simple 'eventName' events\n\n      if (input.additionalEvent) {\n        // additional event(panleft, panright, pinchin, pinchout...)\n        emit(input.additionalEvent);\n      }\n\n      // panend and pancancel\n      if (state >= STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n    },\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function (input) {\n      if (this.canEmit()) {\n        return this.emit(input);\n      }\n      // it's failing anyway\n      this.state = STATE_FAILED;\n    },\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function () {\n      var i = 0;\n      while (i < this.requireFail.length) {\n        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n          return false;\n        }\n        i++;\n      }\n      return true;\n    },\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function (inputData) {\n      // make a new copy of the inputData\n      // so we can change the inputData without messing up the other recognizers\n      var inputDataClone = assign({}, inputData);\n\n      // is is enabled and allow recognizing?\n      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n        this.reset();\n        this.state = STATE_FAILED;\n        return;\n      }\n\n      // reset when we've reached the end\n      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n        this.state = STATE_POSSIBLE;\n      }\n      this.state = this.process(inputDataClone);\n\n      // the recognizer has recognized a gesture\n      // so trigger an event\n      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n        this.tryEmit(inputDataClone);\n      }\n    },\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function (inputData) {},\n    // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function () {},\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function () {}\n  };\n\n  /**\n   * get a usable string, used as event postfix\n   * @param {Const} state\n   * @returns {String} state\n   */\n  function stateStr(state) {\n    if (state & STATE_CANCELLED) {\n      return 'cancel';\n    } else if (state & STATE_ENDED) {\n      return 'end';\n    } else if (state & STATE_CHANGED) {\n      return 'move';\n    } else if (state & STATE_BEGAN) {\n      return 'start';\n    }\n    return '';\n  }\n\n  /**\n   * direction cons to string\n   * @param {Const} direction\n   * @returns {String}\n   */\n  function directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n      return 'down';\n    } else if (direction == DIRECTION_UP) {\n      return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n      return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n      return 'right';\n    }\n    return '';\n  }\n\n  /**\n   * get a recognizer by name if it is bound to a manager\n   * @param {Recognizer|String} otherRecognizer\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer}\n   */\n  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n      return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n  }\n\n  /**\n   * This recognizer is just used as a base for the simple attribute recognizers.\n   * @constructor\n   * @extends Recognizer\n   */\n  function AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n  }\n  inherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n      /**\n       * @type {Number}\n       * @default 1\n       */\n      pointers: 1\n    },\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function (input) {\n      var optionPointers = this.options.pointers;\n      return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function (input) {\n      var state = this.state;\n      var eventType = input.eventType;\n      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n      var isValid = this.attrTest(input);\n\n      // on cancel input and we've recognized before, return STATE_CANCELLED\n      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n        return state | STATE_CANCELLED;\n      } else if (isRecognized || isValid) {\n        if (eventType & INPUT_END) {\n          return state | STATE_ENDED;\n        } else if (!(state & STATE_BEGAN)) {\n          return STATE_BEGAN;\n        }\n        return state | STATE_CHANGED;\n      }\n      return STATE_FAILED;\n    }\n  });\n\n  /**\n   * Pan\n   * Recognized when the pointer is down and moved in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n    this.pX = null;\n    this.pY = null;\n  }\n  inherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    },\n    getTouchAction: function () {\n      var direction = this.options.direction;\n      var actions = [];\n      if (direction & DIRECTION_HORIZONTAL) {\n        actions.push(TOUCH_ACTION_PAN_Y);\n      }\n      if (direction & DIRECTION_VERTICAL) {\n        actions.push(TOUCH_ACTION_PAN_X);\n      }\n      return actions;\n    },\n    directionTest: function (input) {\n      var options = this.options;\n      var hasMoved = true;\n      var distance = input.distance;\n      var direction = input.direction;\n      var x = input.deltaX;\n      var y = input.deltaY;\n\n      // lock to axis?\n      if (!(direction & options.direction)) {\n        if (options.direction & DIRECTION_HORIZONTAL) {\n          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          hasMoved = x != this.pX;\n          distance = Math.abs(input.deltaX);\n        } else {\n          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n          hasMoved = y != this.pY;\n          distance = Math.abs(input.deltaY);\n        }\n      }\n      input.direction = direction;\n      return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n    attrTest: function (input) {\n      return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n    },\n    emit: function (input) {\n      this.pX = input.deltaX;\n      this.pY = input.deltaY;\n      var direction = directionStr(input.direction);\n      if (direction) {\n        input.additionalEvent = this.options.event + direction;\n      }\n      this._super.emit.call(this, input);\n    }\n  });\n\n  /**\n   * Pinch\n   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n  inherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function () {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function (input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n    emit: function (input) {\n      if (input.scale !== 1) {\n        var inOut = input.scale < 1 ? 'in' : 'out';\n        input.additionalEvent = this.options.event + inOut;\n      }\n      this._super.emit.call(this, input);\n    }\n  });\n\n  /**\n   * Press\n   * Recognized when the pointer is down for x ms without any movement.\n   * @constructor\n   * @extends Recognizer\n   */\n  function PressRecognizer() {\n    Recognizer.apply(this, arguments);\n    this._timer = null;\n    this._input = null;\n  }\n  inherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9 // a minimal movement is ok, but keep it low\n    },\n    getTouchAction: function () {\n      return [TOUCH_ACTION_AUTO];\n    },\n    process: function (input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTime = input.deltaTime > options.time;\n      this._input = input;\n\n      // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n        this.reset();\n      } else if (input.eventType & INPUT_START) {\n        this.reset();\n        this._timer = setTimeoutContext(function () {\n          this.state = STATE_RECOGNIZED;\n          this.tryEmit();\n        }, options.time, this);\n      } else if (input.eventType & INPUT_END) {\n        return STATE_RECOGNIZED;\n      }\n      return STATE_FAILED;\n    },\n    reset: function () {\n      clearTimeout(this._timer);\n    },\n    emit: function (input) {\n      if (this.state !== STATE_RECOGNIZED) {\n        return;\n      }\n      if (input && input.eventType & INPUT_END) {\n        this.manager.emit(this.options.event + 'up', input);\n      } else {\n        this._input.timeStamp = now();\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n\n  /**\n   * Rotate\n   * Recognized when two or more pointer are moving in a circular motion.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n  inherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function () {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function (input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n  });\n\n  /**\n   * Swipe\n   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n  inherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    },\n    getTouchAction: function () {\n      return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n    attrTest: function (input) {\n      var direction = this.options.direction;\n      var velocity;\n      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n        velocity = input.overallVelocity;\n      } else if (direction & DIRECTION_HORIZONTAL) {\n        velocity = input.overallVelocityX;\n      } else if (direction & DIRECTION_VERTICAL) {\n        velocity = input.overallVelocityY;\n      }\n      return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n    emit: function (input) {\n      var direction = directionStr(input.offsetDirection);\n      if (direction) {\n        this.manager.emit(this.options.event + direction, input);\n      }\n      this.manager.emit(this.options.event, input);\n    }\n  });\n\n  /**\n   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n   * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n   * a single tap.\n   *\n   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n   * multi-taps being recognized.\n   * @constructor\n   * @extends Recognizer\n   */\n  function TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n  inherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n    getTouchAction: function () {\n      return [TOUCH_ACTION_MANIPULATION];\n    },\n    process: function (input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTouchTime = input.deltaTime < options.time;\n      this.reset();\n      if (input.eventType & INPUT_START && this.count === 0) {\n        return this.failTimeout();\n      }\n\n      // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n      if (validMovement && validTouchTime && validPointers) {\n        if (input.eventType != INPUT_END) {\n          return this.failTimeout();\n        }\n        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n        this.pTime = input.timeStamp;\n        this.pCenter = input.center;\n        if (!validMultiTap || !validInterval) {\n          this.count = 1;\n        } else {\n          this.count += 1;\n        }\n        this._input = input;\n\n        // if tap count matches we have recognized it,\n        // else it has began recognizing...\n        var tapCount = this.count % options.taps;\n        if (tapCount === 0) {\n          // no failing requirements, immediately trigger the tap event\n          // or wait as long as the multitap interval to trigger\n          if (!this.hasRequireFailures()) {\n            return STATE_RECOGNIZED;\n          } else {\n            this._timer = setTimeoutContext(function () {\n              this.state = STATE_RECOGNIZED;\n              this.tryEmit();\n            }, options.interval, this);\n            return STATE_BEGAN;\n          }\n        }\n      }\n      return STATE_FAILED;\n    },\n    failTimeout: function () {\n      this._timer = setTimeoutContext(function () {\n        this.state = STATE_FAILED;\n      }, this.options.interval, this);\n      return STATE_FAILED;\n    },\n    reset: function () {\n      clearTimeout(this._timer);\n    },\n    emit: function () {\n      if (this.state == STATE_RECOGNIZED) {\n        this._input.tapCount = this.count;\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n\n  /**\n   * Simple way to create a manager with a default set of recognizers.\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n  function Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n  }\n\n  /**\n   * @const {string}\n   */\n  Hammer.VERSION = '2.0.7';\n\n  /**\n   * default settings\n   * @namespace\n   */\n  Hammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n    // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n    [RotateRecognizer, {\n      enable: false\n    }], [PinchRecognizer, {\n      enable: false\n    }, ['rotate']], [SwipeRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }], [PanRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }, ['swipe']], [TapRecognizer], [TapRecognizer, {\n      event: 'doubletap',\n      taps: 2\n    }, ['tap']], [PressRecognizer]],\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n      /**\n       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userSelect: 'none',\n      /**\n       * Disable the Windows Phone grippers when pressing an element.\n       * @type {String}\n       * @default 'none'\n       */\n      touchSelect: 'none',\n      /**\n       * Disables the default callout shown when you touch and hold a touch target.\n       * On iOS, when you touch and hold a touch target such as a link, Safari displays\n       * a callout containing information about the link. This property allows you to disable that callout.\n       * @type {String}\n       * @default 'none'\n       */\n      touchCallout: 'none',\n      /**\n       * Specifies whether zooming is enabled. Used by IE10>\n       * @type {String}\n       * @default 'none'\n       */\n      contentZooming: 'none',\n      /**\n       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userDrag: 'none',\n      /**\n       * Overrides the highlight color shown when the user taps a link or a JavaScript\n       * clickable element in iOS. This property obeys the alpha value, if specified.\n       * @type {String}\n       * @default 'rgba(0,0,0,0)'\n       */\n      tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n  };\n  var STOP = 1;\n  var FORCED_STOP = 2;\n\n  /**\n   * Manager\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n  function Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = this.add(new item[0](item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  Manager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function (options) {\n      assign(this.options, options);\n\n      // Options that need a little more setup\n      if (options.touchAction) {\n        this.touchAction.update();\n      }\n      if (options.inputTarget) {\n        // Clean up existing event listeners and reinitialize\n        this.input.destroy();\n        this.input.target = options.inputTarget;\n        this.input.init();\n      }\n      return this;\n    },\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function (force) {\n      this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function (inputData) {\n      var session = this.session;\n      if (session.stopped) {\n        return;\n      }\n\n      // run the touch-action polyfill\n      this.touchAction.preventDefaults(inputData);\n      var recognizer;\n      var recognizers = this.recognizers;\n\n      // this holds the recognizer that is being recognized.\n      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n      // if no recognizer is detecting a thing, it is set to `null`\n      var curRecognizer = session.curRecognizer;\n\n      // reset when the last recognizer is recognized\n      // or when we're in a new session\n      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n        curRecognizer = session.curRecognizer = null;\n      }\n      var i = 0;\n      while (i < recognizers.length) {\n        recognizer = recognizers[i];\n\n        // find out if we are allowed try to recognize the input for this one.\n        // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n        //      that is being recognized.\n        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n        //      this can be setup with the `recognizeWith()` method on the recognizer.\n        if (session.stopped !== FORCED_STOP && (\n        // 1\n        !curRecognizer || recognizer == curRecognizer ||\n        // 2\n        recognizer.canRecognizeWith(curRecognizer))) {\n          // 3\n          recognizer.recognize(inputData);\n        } else {\n          recognizer.reset();\n        }\n\n        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n        // current active recognizer. but only if we don't already have an active recognizer\n        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n          curRecognizer = session.curRecognizer = recognizer;\n        }\n        i++;\n      }\n    },\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function (recognizer) {\n      if (recognizer instanceof Recognizer) {\n        return recognizer;\n      }\n      var recognizers = this.recognizers;\n      for (var i = 0; i < recognizers.length; i++) {\n        if (recognizers[i].options.event == recognizer) {\n          return recognizers[i];\n        }\n      }\n      return null;\n    },\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function (recognizer) {\n      if (invokeArrayArg(recognizer, 'add', this)) {\n        return this;\n      }\n\n      // remove existing\n      var existing = this.get(recognizer.options.event);\n      if (existing) {\n        this.remove(existing);\n      }\n      this.recognizers.push(recognizer);\n      recognizer.manager = this;\n      this.touchAction.update();\n      return recognizer;\n    },\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function (recognizer) {\n      if (invokeArrayArg(recognizer, 'remove', this)) {\n        return this;\n      }\n      recognizer = this.get(recognizer);\n\n      // let's make sure this recognizer exists\n      if (recognizer) {\n        var recognizers = this.recognizers;\n        var index = inArray(recognizers, recognizer);\n        if (index !== -1) {\n          recognizers.splice(index, 1);\n          this.touchAction.update();\n        }\n      }\n      return this;\n    },\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function (events, handler) {\n      if (events === undefined) {\n        return;\n      }\n      if (handler === undefined) {\n        return;\n      }\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        handlers[event] = handlers[event] || [];\n        handlers[event].push(handler);\n      });\n      return this;\n    },\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function (events, handler) {\n      if (events === undefined) {\n        return;\n      }\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        if (!handler) {\n          delete handlers[event];\n        } else {\n          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n        }\n      });\n      return this;\n    },\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function (event, data) {\n      // we also want to trigger dom events\n      if (this.options.domEvents) {\n        triggerDomEvent(event, data);\n      }\n\n      // no handlers, so skip it all\n      var handlers = this.handlers[event] && this.handlers[event].slice();\n      if (!handlers || !handlers.length) {\n        return;\n      }\n      data.type = event;\n      data.preventDefault = function () {\n        data.srcEvent.preventDefault();\n      };\n      var i = 0;\n      while (i < handlers.length) {\n        handlers[i](data);\n        i++;\n      }\n    },\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function () {\n      this.element && toggleCssProps(this, false);\n      this.handlers = {};\n      this.session = {};\n      this.input.destroy();\n      this.element = null;\n    }\n  };\n\n  /**\n   * add/remove the css properties as defined in manager.options.cssProps\n   * @param {Manager} manager\n   * @param {Boolean} add\n   */\n  function toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n      return;\n    }\n    var prop;\n    each(manager.options.cssProps, function (value, name) {\n      prop = prefixed(element.style, name);\n      if (add) {\n        manager.oldCssProps[prop] = element.style[prop];\n        element.style[prop] = value;\n      } else {\n        element.style[prop] = manager.oldCssProps[prop] || '';\n      }\n    });\n    if (!add) {\n      manager.oldCssProps = {};\n    }\n  }\n\n  /**\n   * trigger dom event\n   * @param {String} event\n   * @param {Object} data\n   */\n  function triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n  }\n  assign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n  });\n\n  // this prevents errors when Hammer is loaded in the presence of an AMD\n  //  style loader but by script tag, not by the loader.\n  var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line\n  freeGlobal.Hammer = Hammer;\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return Hammer;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, document, 'Hammer');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUSxJQUFJO0FBQ3pCLGFBQWEsUUFBUSxJQUFJO0FBQ3pCLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0NBQWdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxxR0FBcUc7QUFDckc7QUFDQSxNQUFNLElBQTBDO0FBQ2hELElBQUksbUNBQU87QUFDWDtBQUNBLEtBQUs7QUFBQSxrR0FBQztBQUNOLElBQUksS0FBSyxFQUlOO0FBQ0gsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL2hhbW1lcmpzL2hhbW1lci5qcz9lYmZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBIYW1tZXIuSlMgLSB2Mi4wLjcgLSAyMDE2LTA0LTIyXG4gKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNiBKb3JpayBUYW5nZWxkZXI7XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cbihmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgZXhwb3J0TmFtZSwgdW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgVkVORE9SX1BSRUZJWEVTID0gWycnLCAnd2Via2l0JywgJ01veicsICdNUycsICdtcycsICdvJ107XG4gIHZhciBURVNUX0VMRU1FTlQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIFRZUEVfRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xuICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICB2YXIgYWJzID0gTWF0aC5hYnM7XG4gIHZhciBub3cgPSBEYXRlLm5vdztcblxuICAvKipcbiAgICogc2V0IGEgdGltZW91dCB3aXRoIGEgZ2l2ZW4gc2NvcGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRpbWVvdXRDb250ZXh0KGZuLCB0aW1lb3V0LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoYmluZEZuKGZuLCBjb250ZXh0KSwgdGltZW91dCk7XG4gIH1cblxuICAvKipcbiAgICogaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5LCB3ZSB3YW50IHRvIGV4ZWN1dGUgdGhlIGZuIG9uIGVhY2ggZW50cnlcbiAgICogaWYgaXQgYWludCBhbiBhcnJheSB3ZSBkb24ndCB3YW50IHRvIGRvIGEgdGhpbmcuXG4gICAqIHRoaXMgaXMgdXNlZCBieSBhbGwgdGhlIG1ldGhvZHMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYW5kIGFycmF5IGFyZ3VtZW50LlxuICAgKiBAcGFyYW0geyp8QXJyYXl9IGFyZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZm5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiB3YWxrIG9iamVjdHMgYW5kIGFycmF5c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICBmdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgaTtcbiAgICBpZiAoIW9iaikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcbiAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoaSkgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHdyYXAgYSBtZXRob2Qgd2l0aCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgYW5kIHN0YWNrIHRyYWNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHdyYXBwaW5nIHRoZSBzdXBwbGllZCBtZXRob2QuXG4gICAqL1xuICBmdW5jdGlvbiBkZXByZWNhdGUobWV0aG9kLCBuYW1lLCBtZXNzYWdlKSB7XG4gICAgdmFyIGRlcHJlY2F0aW9uTWVzc2FnZSA9ICdERVBSRUNBVEVEIE1FVEhPRDogJyArIG5hbWUgKyAnXFxuJyArIG1lc3NhZ2UgKyAnIEFUIFxcbic7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdnZXQtc3RhY2stdHJhY2UnKTtcbiAgICAgIHZhciBzdGFjayA9IGUgJiYgZS5zdGFjayA/IGUuc3RhY2sucmVwbGFjZSgvXlteXFwoXSs/W1xcbiRdL2dtLCAnJykucmVwbGFjZSgvXlxccythdFxccysvZ20sICcnKS5yZXBsYWNlKC9eT2JqZWN0Ljxhbm9ueW1vdXM+XFxzKlxcKC9nbSwgJ3thbm9ueW1vdXN9KClAJykgOiAnVW5rbm93biBTdGFjayBUcmFjZSc7XG4gICAgICB2YXIgbG9nID0gd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLndhcm4gfHwgd2luZG93LmNvbnNvbGUubG9nKTtcbiAgICAgIGlmIChsb2cpIHtcbiAgICAgICAgbG9nLmNhbGwod2luZG93LmNvbnNvbGUsIGRlcHJlY2F0aW9uTWVzc2FnZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogZXh0ZW5kIG9iamVjdC5cbiAgICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IG9iamVjdHNfdG9fYXNzaWduXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHRhcmdldFxuICAgKi9cbiAgdmFyIGFzc2lnbjtcbiAgaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICAgIH1cbiAgICAgIHZhciBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG4gIH1cblxuICAvKipcbiAgICogZXh0ZW5kIG9iamVjdC5cbiAgICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAgICovXG4gIHZhciBleHRlbmQgPSBkZXByZWNhdGUoZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHtcbiAgICAgIGlmICghbWVyZ2UgfHwgbWVyZ2UgJiYgZGVzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9LCAnZXh0ZW5kJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuICAvKipcbiAgICogbWVyZ2UgdGhlIHZhbHVlcyBmcm9tIHNyYyBpbiB0aGUgZGVzdC5cbiAgICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIHRoYXQgZXhpc3QgaW4gZGVzdCB3aWxsIG5vdCBiZSBvdmVyd3JpdHRlbiBieSBzcmNcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gICAqL1xuICB2YXIgbWVyZ2UgPSBkZXByZWNhdGUoZnVuY3Rpb24gbWVyZ2UoZGVzdCwgc3JjKSB7XG4gICAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xuICB9LCAnbWVyZ2UnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG4gIC8qKlxuICAgKiBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXG4gICAqL1xuICBmdW5jdGlvbiBpbmhlcml0KGNoaWxkLCBiYXNlLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGJhc2VQID0gYmFzZS5wcm90b3R5cGUsXG4gICAgICBjaGlsZFA7XG4gICAgY2hpbGRQID0gY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUCk7XG4gICAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgY2hpbGRQLl9zdXBlciA9IGJhc2VQO1xuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICBhc3NpZ24oY2hpbGRQLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIGxldCBhIGJvb2xlYW4gdmFsdWUgYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgbXVzdCByZXR1cm4gYSBib29sZWFuXG4gICAqIHRoaXMgZmlyc3QgaXRlbSBpbiBhcmdzIHdpbGwgYmUgdXNlZCBhcyB0aGUgY29udGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHZhbFxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnc11cbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBib29sT3JGbih2YWwsIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PSBUWVBFX0ZVTkNUSU9OKSB7XG4gICAgICByZXR1cm4gdmFsLmFwcGx5KGFyZ3MgPyBhcmdzWzBdIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICAvKipcbiAgICogdXNlIHRoZSB2YWwyIHdoZW4gdmFsMSBpcyB1bmRlZmluZWRcbiAgICogQHBhcmFtIHsqfSB2YWwxXG4gICAqIEBwYXJhbSB7Kn0gdmFsMlxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGZ1bmN0aW9uIGlmVW5kZWZpbmVkKHZhbDEsIHZhbDIpIHtcbiAgICByZXR1cm4gdmFsMSA9PT0gdW5kZWZpbmVkID8gdmFsMiA6IHZhbDE7XG4gIH1cblxuICAvKipcbiAgICogYWRkRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlbW92ZUV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGEgbm9kZSBpcyBpbiB0aGUgZ2l2ZW4gcGFyZW50XG4gICAqIEBtZXRob2QgaGFzUGFyZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gICAqL1xuICBmdW5jdGlvbiBoYXNQYXJlbnQobm9kZSwgcGFyZW50KSB7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGlmIChub2RlID09IHBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzbWFsbCBpbmRleE9mIHdyYXBwZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gZm91bmRcbiAgICovXG4gIGZ1bmN0aW9uIGluU3RyKHN0ciwgZmluZCkge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihmaW5kKSA+IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIHNwbGl0IHN0cmluZyBvbiB3aGl0ZXNwYWNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICogQHJldHVybnMge0FycmF5fSB3b3Jkc1xuICAgKi9cbiAgZnVuY3Rpb24gc3BsaXRTdHIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCkuc3BsaXQoL1xccysvZyk7XG4gIH1cblxuICAvKipcbiAgICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxuICAgKiBAcGFyYW0ge0FycmF5fSBzcmNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXG4gICAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gICAqL1xuICBmdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XG4gICAgaWYgKHNyYy5pbmRleE9mICYmICFmaW5kQnlLZXkpIHtcbiAgICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChmaW5kQnlLZXkgJiYgc3JjW2ldW2ZpbmRCeUtleV0gPT0gZmluZCB8fCAhZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogY29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gcmVhbCBhcnJheXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBmdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIHVuaXF1ZSBhcnJheSB3aXRoIG9iamVjdHMgYmFzZWQgb24gYSBrZXkgKGxpa2UgJ2lkJykgb3IganVzdCBieSB0aGUgYXJyYXkncyB2YWx1ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzcmMgW3tpZDoxfSx7aWQ6Mn0se2lkOjF9XVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc29ydD1GYWxzZV1cbiAgICogQHJldHVybnMge0FycmF5fSBbe2lkOjF9LHtpZDoyfV1cbiAgICovXG4gIGZ1bmN0aW9uIHVuaXF1ZUFycmF5KHNyYywga2V5LCBzb3J0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgdmFyIHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xuICAgICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xuICAgICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlc1tpXSA9IHZhbDtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgaWYgKHNvcnQpIHtcbiAgICAgIGlmICgha2V5KSB7XG4gICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoZnVuY3Rpb24gc29ydFVuaXF1ZUFycmF5KGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYVtrZXldID4gYltrZXldO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSBwcmVmaXhlZCBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfFVuZGVmaW5lZH0gcHJlZml4ZWRcbiAgICovXG4gIGZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcbiAgICB2YXIgcHJlZml4LCBwcm9wO1xuICAgIHZhciBjYW1lbFByb3AgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xuICAgICAgcHJlZml4ID0gVkVORE9SX1BSRUZJWEVTW2ldO1xuICAgICAgcHJvcCA9IHByZWZpeCA/IHByZWZpeCArIGNhbWVsUHJvcCA6IHByb3BlcnR5O1xuICAgICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBhIHVuaXF1ZSBpZFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSB1bmlxdWVJZFxuICAgKi9cbiAgdmFyIF91bmlxdWVJZCA9IDE7XG4gIGZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICAgIHJldHVybiBfdW5pcXVlSWQrKztcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0V2luZG93Rm9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgdmFyIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBlbGVtZW50O1xuICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyB8fCB3aW5kb3c7XG4gIH1cbiAgdmFyIE1PQklMRV9SRUdFWCA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWQvaTtcbiAgdmFyIFNVUFBPUlRfVE9VQ0ggPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XG4gIHZhciBTVVBQT1JUX1BPSU5URVJfRVZFTlRTID0gcHJlZml4ZWQod2luZG93LCAnUG9pbnRlckV2ZW50JykgIT09IHVuZGVmaW5lZDtcbiAgdmFyIFNVUFBPUlRfT05MWV9UT1VDSCA9IFNVUFBPUlRfVE9VQ0ggJiYgTU9CSUxFX1JFR0VYLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBJTlBVVF9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbiAgdmFyIElOUFVUX1RZUEVfUEVOID0gJ3Blbic7XG4gIHZhciBJTlBVVF9UWVBFX01PVVNFID0gJ21vdXNlJztcbiAgdmFyIElOUFVUX1RZUEVfS0lORUNUID0gJ2tpbmVjdCc7XG4gIHZhciBDT01QVVRFX0lOVEVSVkFMID0gMjU7XG4gIHZhciBJTlBVVF9TVEFSVCA9IDE7XG4gIHZhciBJTlBVVF9NT1ZFID0gMjtcbiAgdmFyIElOUFVUX0VORCA9IDQ7XG4gIHZhciBJTlBVVF9DQU5DRUwgPSA4O1xuICB2YXIgRElSRUNUSU9OX05PTkUgPSAxO1xuICB2YXIgRElSRUNUSU9OX0xFRlQgPSAyO1xuICB2YXIgRElSRUNUSU9OX1JJR0hUID0gNDtcbiAgdmFyIERJUkVDVElPTl9VUCA9IDg7XG4gIHZhciBESVJFQ1RJT05fRE9XTiA9IDE2O1xuICB2YXIgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fTEVGVCB8IERJUkVDVElPTl9SSUdIVDtcbiAgdmFyIERJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9VUCB8IERJUkVDVElPTl9ET1dOO1xuICB2YXIgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMO1xuICB2YXIgUFJPUFNfWFkgPSBbJ3gnLCAneSddO1xuICB2YXIgUFJPUFNfQ0xJRU5UX1hZID0gWydjbGllbnRYJywgJ2NsaWVudFknXTtcblxuICAvKipcbiAgICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtJbnB1dH1cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBJbnB1dChtYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRUYXJnZXQ7XG5cbiAgICAvLyBzbWFsbGVyIHdyYXBwZXIgYXJvdW5kIHRoZSBoYW5kbGVyLCBmb3IgdGhlIHNjb3BlIGFuZCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbWFuYWdlcixcbiAgICAvLyBzbyB3aGVuIGRpc2FibGVkIHRoZSBpbnB1dCBldmVudHMgYXJlIGNvbXBsZXRlbHkgYnlwYXNzZWQuXG4gICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xuICAgICAgICBzZWxmLmhhbmRsZXIoZXYpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cbiAgSW5wdXQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNob3VsZCBoYW5kbGUgdGhlIGlucHV0RXZlbnQgZGF0YSBhbmQgdHJpZ2dlciB0aGUgY2FsbGJhY2tcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uICgpIHt9LFxuICAgIC8qKlxuICAgICAqIGJpbmQgdGhlIGV2ZW50c1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZXZFbCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgIHRoaXMuZXZUYXJnZXQgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICB0aGlzLmV2V2luICYmIGFkZEV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHVuYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5ldkVsICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgdGhpcy5ldlRhcmdldCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgIHRoaXMuZXZXaW4gJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAgICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gICAqIEByZXR1cm5zIHtJbnB1dH1cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUlucHV0SW5zdGFuY2UobWFuYWdlcikge1xuICAgIHZhciBUeXBlO1xuICAgIHZhciBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG4gICAgaWYgKGlucHV0Q2xhc3MpIHtcbiAgICAgIFR5cGUgPSBpbnB1dENsYXNzO1xuICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9QT0lOVEVSX0VWRU5UUykge1xuICAgICAgVHlwZSA9IFBvaW50ZXJFdmVudElucHV0O1xuICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9PTkxZX1RPVUNIKSB7XG4gICAgICBUeXBlID0gVG91Y2hJbnB1dDtcbiAgICB9IGVsc2UgaWYgKCFTVVBQT1JUX1RPVUNIKSB7XG4gICAgICBUeXBlID0gTW91c2VJbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgVHlwZSA9IFRvdWNoTW91c2VJbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUeXBlKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogaGFuZGxlIGlucHV0IGV2ZW50c1xuICAgKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG4gIGZ1bmN0aW9uIGlucHV0SGFuZGxlcihtYW5hZ2VyLCBldmVudFR5cGUsIGlucHV0KSB7XG4gICAgdmFyIHBvaW50ZXJzTGVuID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoO1xuICAgIHZhciBjaGFuZ2VkUG9pbnRlcnNMZW4gPSBpbnB1dC5jaGFuZ2VkUG9pbnRlcnMubGVuZ3RoO1xuICAgIHZhciBpc0ZpcnN0ID0gZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgcG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDA7XG4gICAgdmFyIGlzRmluYWwgPSBldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiBwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMDtcbiAgICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xuICAgIGlucHV0LmlzRmluYWwgPSAhIWlzRmluYWw7XG4gICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xuICAgIH1cblxuICAgIC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gICAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG4gICAgaW5wdXQuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuXG4gICAgLy8gY29tcHV0ZSBzY2FsZSwgcm90YXRpb24gZXRjXG4gICAgY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCk7XG5cbiAgICAvLyBlbWl0IHNlY3JldCBldmVudFxuICAgIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuICAgIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcbiAgICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XG4gIH1cblxuICAvKipcbiAgICogZXh0ZW5kIHRoZSBkYXRhIHdpdGggc29tZSB1c2FibGUgcHJvcGVydGllcyBsaWtlIHNjYWxlLCByb3RhdGUsIHZlbG9jaXR5IGV0Y1xuICAgKiBAcGFyYW0ge09iamVjdH0gbWFuYWdlclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpIHtcbiAgICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcbiAgICB2YXIgcG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycztcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXG4gICAgaWYgKCFzZXNzaW9uLmZpcnN0SW5wdXQpIHtcbiAgICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9XG5cbiAgICAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID4gMSAmJiAhc2Vzc2lvbi5maXJzdE11bHRpcGxlKSB7XG4gICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gICAgfSBlbHNlIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBmaXJzdElucHV0ID0gc2Vzc2lvbi5maXJzdElucHV0O1xuICAgIHZhciBmaXJzdE11bHRpcGxlID0gc2Vzc2lvbi5maXJzdE11bHRpcGxlO1xuICAgIHZhciBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyID0gZ2V0Q2VudGVyKHBvaW50ZXJzKTtcbiAgICBpbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICBpbnB1dC5kZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBmaXJzdElucHV0LnRpbWVTdGFtcDtcbiAgICBpbnB1dC5hbmdsZSA9IGdldEFuZ2xlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XG4gICAgaW5wdXQub2Zmc2V0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcbiAgICB2YXIgb3ZlcmFsbFZlbG9jaXR5ID0gZ2V0VmVsb2NpdHkoaW5wdXQuZGVsdGFUaW1lLCBpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WCA9IG92ZXJhbGxWZWxvY2l0eS54O1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVkgPSBvdmVyYWxsVmVsb2NpdHkueTtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHkgPSBhYnMob3ZlcmFsbFZlbG9jaXR5LngpID4gYWJzKG92ZXJhbGxWZWxvY2l0eS55KSA/IG92ZXJhbGxWZWxvY2l0eS54IDogb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gICAgaW5wdXQuc2NhbGUgPSBmaXJzdE11bHRpcGxlID8gZ2V0U2NhbGUoZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMTtcbiAgICBpbnB1dC5yb3RhdGlvbiA9IGZpcnN0TXVsdGlwbGUgPyBnZXRSb3RhdGlvbihmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAwO1xuICAgIGlucHV0Lm1heFBvaW50ZXJzID0gIXNlc3Npb24ucHJldklucHV0ID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogaW5wdXQucG9pbnRlcnMubGVuZ3RoID4gc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycztcbiAgICBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpO1xuXG4gICAgLy8gZmluZCB0aGUgY29ycmVjdCB0YXJnZXRcbiAgICB2YXIgdGFyZ2V0ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIGlmIChoYXNQYXJlbnQoaW5wdXQuc3JjRXZlbnQudGFyZ2V0LCB0YXJnZXQpKSB7XG4gICAgICB0YXJnZXQgPSBpbnB1dC5zcmNFdmVudC50YXJnZXQ7XG4gICAgfVxuICAgIGlucHV0LnRhcmdldCA9IHRhcmdldDtcbiAgfVxuICBmdW5jdGlvbiBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCkge1xuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG4gICAgdmFyIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgfHwge307XG4gICAgdmFyIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhIHx8IHt9O1xuICAgIHZhciBwcmV2SW5wdXQgPSBzZXNzaW9uLnByZXZJbnB1dCB8fCB7fTtcbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9TVEFSVCB8fCBwcmV2SW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9FTkQpIHtcbiAgICAgIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhID0ge1xuICAgICAgICB4OiBwcmV2SW5wdXQuZGVsdGFYIHx8IDAsXG4gICAgICAgIHk6IHByZXZJbnB1dC5kZWx0YVkgfHwgMFxuICAgICAgfTtcbiAgICAgIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgPSB7XG4gICAgICAgIHg6IGNlbnRlci54LFxuICAgICAgICB5OiBjZW50ZXIueVxuICAgICAgfTtcbiAgICB9XG4gICAgaW5wdXQuZGVsdGFYID0gcHJldkRlbHRhLnggKyAoY2VudGVyLnggLSBvZmZzZXQueCk7XG4gICAgaW5wdXQuZGVsdGFZID0gcHJldkRlbHRhLnkgKyAoY2VudGVyLnkgLSBvZmZzZXQueSk7XG4gIH1cblxuICAvKipcbiAgICogdmVsb2NpdHkgaXMgY2FsY3VsYXRlZCBldmVyeSB4IG1zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKi9cbiAgZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGxhc3QgPSBzZXNzaW9uLmxhc3RJbnRlcnZhbCB8fCBpbnB1dCxcbiAgICAgIGRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGxhc3QudGltZVN0YW1wLFxuICAgICAgdmVsb2NpdHksXG4gICAgICB2ZWxvY2l0eVgsXG4gICAgICB2ZWxvY2l0eVksXG4gICAgICBkaXJlY3Rpb247XG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgdmFyIGRlbHRhWCA9IGlucHV0LmRlbHRhWCAtIGxhc3QuZGVsdGFYO1xuICAgICAgdmFyIGRlbHRhWSA9IGlucHV0LmRlbHRhWSAtIGxhc3QuZGVsdGFZO1xuICAgICAgdmFyIHYgPSBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICAgIHZlbG9jaXR5WSA9IHYueTtcbiAgICAgIHZlbG9jaXR5ID0gYWJzKHYueCkgPiBhYnModi55KSA/IHYueCA6IHYueTtcbiAgICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG4gICAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXG4gICAgICB2ZWxvY2l0eSA9IGxhc3QudmVsb2NpdHk7XG4gICAgICB2ZWxvY2l0eVggPSBsYXN0LnZlbG9jaXR5WDtcbiAgICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xuICAgICAgZGlyZWN0aW9uID0gbGFzdC5kaXJlY3Rpb247XG4gICAgfVxuICAgIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgaW5wdXQudmVsb2NpdHlYID0gdmVsb2NpdHlYO1xuICAgIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogY3JlYXRlIGEgc2ltcGxlIGNsb25lIGZyb20gdGhlIGlucHV0IHVzZWQgZm9yIHN0b3JhZ2Ugb2YgZmlyc3RJbnB1dCBhbmQgZmlyc3RNdWx0aXBsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICogQHJldHVybnMge09iamVjdH0gY2xvbmVkSW5wdXREYXRhXG4gICAqL1xuICBmdW5jdGlvbiBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCkge1xuICAgIC8vIG1ha2UgYSBzaW1wbGUgY29weSBvZiB0aGUgcG9pbnRlcnMgYmVjYXVzZSB3ZSB3aWxsIGdldCBhIHJlZmVyZW5jZSBpZiB3ZSBkb24ndFxuICAgIC8vIHdlIG9ubHkgbmVlZCBjbGllbnRYWSBmb3IgdGhlIGNhbGN1bGF0aW9uc1xuICAgIHZhciBwb2ludGVycyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCkge1xuICAgICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICAgIGNsaWVudFg6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFgpLFxuICAgICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgICAgfTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRpbWVTdGFtcDogbm93KCksXG4gICAgICBwb2ludGVyczogcG9pbnRlcnMsXG4gICAgICBjZW50ZXI6IGdldENlbnRlcihwb2ludGVycyksXG4gICAgICBkZWx0YVg6IGlucHV0LmRlbHRhWCxcbiAgICAgIGRlbHRhWTogaW5wdXQuZGVsdGFZXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50ZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGB4YCBhbmQgYHlgIHByb3BlcnRpZXNcbiAgICovXG4gIGZ1bmN0aW9uIGdldENlbnRlcihwb2ludGVycykge1xuICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcblxuICAgIC8vIG5vIG5lZWQgdG8gbG9vcCB3aGVuIG9ubHkgb25lIHRvdWNoXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRYKSxcbiAgICAgICAgeTogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WSlcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciB4ID0gMCxcbiAgICAgIHkgPSAwLFxuICAgICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBwb2ludGVyc0xlbmd0aCkge1xuICAgICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xuICAgICAgeSArPSBwb2ludGVyc1tpXS5jbGllbnRZO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeDogcm91bmQoeCAvIHBvaW50ZXJzTGVuZ3RoKSxcbiAgICAgIHk6IHJvdW5kKHkgLyBwb2ludGVyc0xlbmd0aClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gICAqL1xuICBmdW5jdGlvbiBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCAvIGRlbHRhVGltZSB8fCAwLFxuICAgICAgeTogeSAvIGRlbHRhVGltZSB8fCAwXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cbiAgICovXG4gIGZ1bmN0aW9uIGdldERpcmVjdGlvbih4LCB5KSB7XG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcbiAgICB9XG4gICAgaWYgKGFicyh4KSA+PSBhYnMoeSkpIHtcbiAgICAgIHJldHVybiB4IDwgMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgIH1cbiAgICByZXR1cm4geSA8IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIGFic29sdXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcDFcbiAgICogQHBhcmFtIHtPYmplY3R9IHAyXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAgICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QW5nbGUocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgfVxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxuICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdLCBQUk9QU19DTElFTlRfWFkpICsgZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdLCBQUk9QU19DTElFTlRfWFkpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gICAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAgICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSwgUFJPUFNfQ0xJRU5UX1hZKSAvIGdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbiAgfVxuICB2YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xuICAgIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gICAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIG1vdXNldXA6IElOUFVUX0VORFxuICB9O1xuICB2YXIgTU9VU0VfRUxFTUVOVF9FVkVOVFMgPSAnbW91c2Vkb3duJztcbiAgdmFyIE1PVVNFX1dJTkRPV19FVkVOVFMgPSAnbW91c2Vtb3ZlIG1vdXNldXAnO1xuXG4gIC8qKlxuICAgKiBNb3VzZSBldmVudHMgaW5wdXRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIElucHV0XG4gICAqL1xuICBmdW5jdGlvbiBNb3VzZUlucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IE1PVVNFX0VMRU1FTlRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBNT1VTRV9XSU5ET1dfRVZFTlRTO1xuICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlOyAvLyBtb3VzZWRvd24gc3RhdGVcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgaW5oZXJpdChNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNRWhhbmRsZXIoZXYpIHtcbiAgICAgIHZhciBldmVudFR5cGUgPSBNT1VTRV9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgIC8vIG9uIHN0YXJ0IHdlIHdhbnQgdG8gaGF2ZSB0aGUgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggIT09IDEpIHtcbiAgICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xuICAgICAgfVxuXG4gICAgICAvLyBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICAgIGlmICghdGhpcy5wcmVzc2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgIHBvaW50ZXJzOiBbZXZdLFxuICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX01PVVNFLFxuICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHZhciBQT0lOVEVSX0lOUFVUX01BUCA9IHtcbiAgICBwb2ludGVyZG93bjogSU5QVVRfU1RBUlQsXG4gICAgcG9pbnRlcm1vdmU6IElOUFVUX01PVkUsXG4gICAgcG9pbnRlcnVwOiBJTlBVVF9FTkQsXG4gICAgcG9pbnRlcmNhbmNlbDogSU5QVVRfQ0FOQ0VMLFxuICAgIHBvaW50ZXJvdXQ6IElOUFVUX0NBTkNFTFxuICB9O1xuXG4gIC8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXG4gIHZhciBJRTEwX1BPSU5URVJfVFlQRV9FTlVNID0ge1xuICAgIDI6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgMzogSU5QVVRfVFlQRV9QRU4sXG4gICAgNDogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICA1OiBJTlBVVF9UWVBFX0tJTkVDVCAvLyBzZWUgaHR0cHM6Ly90d2l0dGVyLmNvbS9qYWNvYnJvc3NpL3N0YXR1cy80ODA1OTY0Mzg0ODk4OTA4MTZcbiAgfTtcbiAgdmFyIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAncG9pbnRlcmRvd24nO1xuICB2YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJztcblxuICAvLyBJRTEwIGhhcyBwcmVmaXhlZCBzdXBwb3J0LCBhbmQgY2FzZS1zZW5zaXRpdmVcbiAgaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCAmJiAhd2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAnTVNQb2ludGVyRG93bic7XG4gICAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2ludGVyIGV2ZW50cyBpbnB1dFxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgSW5wdXRcbiAgICovXG4gIGZ1bmN0aW9uIFBvaW50ZXJFdmVudElucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IFBPSU5URVJfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuc3RvcmUgPSB0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wb2ludGVyRXZlbnRzID0gW107XG4gIH1cbiAgaW5oZXJpdChQb2ludGVyRXZlbnRJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gUEVoYW5kbGVyKGV2KSB7XG4gICAgICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmYWxzZTtcbiAgICAgIHZhciBldmVudFR5cGVOb3JtYWxpemVkID0gZXYudHlwZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ21zJywgJycpO1xuICAgICAgdmFyIGV2ZW50VHlwZSA9IFBPSU5URVJfSU5QVVRfTUFQW2V2ZW50VHlwZU5vcm1hbGl6ZWRdO1xuICAgICAgdmFyIHBvaW50ZXJUeXBlID0gSUUxMF9QT0lOVEVSX1RZUEVfRU5VTVtldi5wb2ludGVyVHlwZV0gfHwgZXYucG9pbnRlclR5cGU7XG4gICAgICB2YXIgaXNUb3VjaCA9IHBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0g7XG5cbiAgICAgIC8vIGdldCBpbmRleCBvZiB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICB2YXIgc3RvcmVJbmRleCA9IGluQXJyYXkoc3RvcmUsIGV2LnBvaW50ZXJJZCwgJ3BvaW50ZXJJZCcpO1xuXG4gICAgICAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXG4gICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKGV2LmJ1dHRvbiA9PT0gMCB8fCBpc1RvdWNoKSkge1xuICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgICBzdG9yZS5wdXNoKGV2KTtcbiAgICAgICAgICBzdG9yZUluZGV4ID0gc3RvcmUubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICByZW1vdmVQb2ludGVyID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaXQgbm90IGZvdW5kLCBzbyB0aGUgcG9pbnRlciBoYXNuJ3QgYmVlbiBkb3duIChzbyBpdCdzIHByb2JhYmx5IGEgaG92ZXIpXG4gICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB1cGRhdGUgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgICAgc3RvcmVbc3RvcmVJbmRleF0gPSBldjtcbiAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgcG9pbnRlcnM6IHN0b3JlLFxuICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICB9KTtcbiAgICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XG4gICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxuICAgICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxuICB9O1xuICB2YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XG4gIHZhciBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbiAgLyoqXG4gICAqIFRvdWNoIGV2ZW50cyBpbnB1dFxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgSW5wdXRcbiAgICovXG4gIGZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIGluaGVyaXQoU2luZ2xlVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBURWhhbmRsZXIoZXYpIHtcbiAgICAgIHZhciB0eXBlID0gU0lOR0xFX1RPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgICAgLy8gc2hvdWxkIHdlIGhhbmRsZSB0aGUgdG91Y2ggZXZlbnRzP1xuICAgICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdG91Y2hlcyA9IG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG5cbiAgICAgIC8vIHdoZW4gZG9uZSwgcmVzZXQgdGhlIHN0YXJ0ZWQgc3RhdGVcbiAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgdG91Y2hlc1swXS5sZW5ndGggLSB0b3VjaGVzWzFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtUb3VjaElucHV0fVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICAgKi9cbiAgZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGwgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgYWxsID0gdW5pcXVlQXJyYXkoYWxsLmNvbmNhdChjaGFuZ2VkKSwgJ2lkZW50aWZpZXInLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIFthbGwsIGNoYW5nZWRdO1xuICB9XG4gIHZhciBUT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxuICB9O1xuICB2YXIgVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbiAgLyoqXG4gICAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBJbnB1dFxuICAgKi9cbiAgZnVuY3Rpb24gVG91Y2hJbnB1dCgpIHtcbiAgICB0aGlzLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICB0aGlzLnRhcmdldElkcyA9IHt9O1xuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgaW5oZXJpdChUb3VjaElucHV0LCBJbnB1dCwge1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1URWhhbmRsZXIoZXYpIHtcbiAgICAgIHZhciB0eXBlID0gVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuICAgICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtUb3VjaElucHV0fVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGxUb3VjaGVzID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICB2YXIgdGFyZ2V0SWRzID0gdGhpcy50YXJnZXRJZHM7XG5cbiAgICAvLyB3aGVuIHRoZXJlIGlzIG9ubHkgb25lIHRvdWNoLCB0aGUgcHJvY2VzcyBjYW4gYmUgc2ltcGxpZmllZFxuICAgIGlmICh0eXBlICYgKElOUFVUX1NUQVJUIHwgSU5QVVRfTU9WRSkgJiYgYWxsVG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRhcmdldElkc1thbGxUb3VjaGVzWzBdLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBbYWxsVG91Y2hlcywgYWxsVG91Y2hlc107XG4gICAgfVxuICAgIHZhciBpLFxuICAgICAgdGFyZ2V0VG91Y2hlcyxcbiAgICAgIGNoYW5nZWRUb3VjaGVzID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyksXG4gICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyA9IFtdLFxuICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG5cbiAgICAvLyBnZXQgdGFyZ2V0IHRvdWNoZXMgZnJvbSB0b3VjaGVzXG4gICAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XG4gICAgfSk7XG5cbiAgICAvLyBjb2xsZWN0IHRvdWNoZXNcbiAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgY2hhbmdlZCB0b3VjaGVzIHRvIG9ubHkgY29udGFpbiB0b3VjaGVzIHRoYXQgZXhpc3QgaW4gdGhlIGNvbGxlY3RlZCB0YXJnZXQgaWRzXG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgIGlmICh0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMucHVzaChjaGFuZ2VkVG91Y2hlc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNsZWFudXAgcmVtb3ZlZCB0b3VjaGVzXG4gICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIGlmICghY2hhbmdlZFRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXG4gICAgdW5pcXVlQXJyYXkodGFyZ2V0VG91Y2hlcy5jb25jYXQoY2hhbmdlZFRhcmdldFRvdWNoZXMpLCAnaWRlbnRpZmllcicsIHRydWUpLCBjaGFuZ2VkVGFyZ2V0VG91Y2hlc107XG4gIH1cblxuICAvKipcbiAgICogQ29tYmluZWQgdG91Y2ggYW5kIG1vdXNlIGlucHV0XG4gICAqXG4gICAqIFRvdWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGVuIG1vdXNlLCBhbmQgd2hpbGUgdG91Y2hpbmcgbm8gbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkLlxuICAgKiBUaGlzIGJlY2F1c2UgdG91Y2ggZGV2aWNlcyBhbHNvIGVtaXQgbW91c2UgZXZlbnRzIHdoaWxlIGRvaW5nIGEgdG91Y2guXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBJbnB1dFxuICAgKi9cblxuICB2YXIgREVEVVBfVElNRU9VVCA9IDI1MDA7XG4gIHZhciBERURVUF9ESVNUQU5DRSA9IDI1O1xuICBmdW5jdGlvbiBUb3VjaE1vdXNlSW5wdXQoKSB7XG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgaGFuZGxlciA9IGJpbmRGbih0aGlzLmhhbmRsZXIsIHRoaXMpO1xuICAgIHRoaXMudG91Y2ggPSBuZXcgVG91Y2hJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuICAgIHRoaXMubW91c2UgPSBuZXcgTW91c2VJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuICAgIHRoaXMucHJpbWFyeVRvdWNoID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb3VjaGVzID0gW107XG4gIH1cbiAgaW5oZXJpdChUb3VjaE1vdXNlSW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGFuZCB0b3VjaCBldmVudHNcbiAgICAgKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dEV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRNRWhhbmRsZXIobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKSB7XG4gICAgICB2YXIgaXNUb3VjaCA9IGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICBpc01vdXNlID0gaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfTU9VU0U7XG4gICAgICBpZiAoaXNNb3VzZSAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHdoZW4gd2UncmUgaW4gYSB0b3VjaCBldmVudCwgcmVjb3JkIHRvdWNoZXMgdG8gIGRlLWR1cGUgc3ludGhldGljIG1vdXNlIGV2ZW50XG4gICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICByZWNvcmRUb3VjaGVzLmNhbGwodGhpcywgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZSAmJiBpc1N5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgaW5wdXREYXRhKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxiYWNrKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubW91c2UuZGVzdHJveSgpO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIHJlY29yZFRvdWNoZXMoZXZlbnRUeXBlLCBldmVudERhdGEpIHtcbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgIHRoaXMucHJpbWFyeVRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXS5pZGVudGlmaWVyO1xuICAgICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRMYXN0VG91Y2goZXZlbnREYXRhKSB7XG4gICAgdmFyIHRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXTtcbiAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5wcmltYXJ5VG91Y2gpIHtcbiAgICAgIHZhciBsYXN0VG91Y2ggPSB7XG4gICAgICAgIHg6IHRvdWNoLmNsaWVudFgsXG4gICAgICAgIHk6IHRvdWNoLmNsaWVudFlcbiAgICAgIH07XG4gICAgICB0aGlzLmxhc3RUb3VjaGVzLnB1c2gobGFzdFRvdWNoKTtcbiAgICAgIHZhciBsdHMgPSB0aGlzLmxhc3RUb3VjaGVzO1xuICAgICAgdmFyIHJlbW92ZUxhc3RUb3VjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGkgPSBsdHMuaW5kZXhPZihsYXN0VG91Y2gpO1xuICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgbHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNldFRpbWVvdXQocmVtb3ZlTGFzdFRvdWNoLCBERURVUF9USU1FT1VUKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNTeW50aGV0aWNFdmVudChldmVudERhdGEpIHtcbiAgICB2YXIgeCA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRYLFxuICAgICAgeSA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRZO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sYXN0VG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHQgPSB0aGlzLmxhc3RUb3VjaGVzW2ldO1xuICAgICAgdmFyIGR4ID0gTWF0aC5hYnMoeCAtIHQueCksXG4gICAgICAgIGR5ID0gTWF0aC5hYnMoeSAtIHQueSk7XG4gICAgICBpZiAoZHggPD0gREVEVVBfRElTVEFOQ0UgJiYgZHkgPD0gREVEVVBfRElTVEFOQ0UpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcbiAgdmFyIE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDtcblxuICAvLyBtYWdpY2FsIHRvdWNoQWN0aW9uIHZhbHVlXG4gIHZhciBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcbiAgdmFyIFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xuICB2YXIgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiA9ICdtYW5pcHVsYXRpb24nOyAvLyBub3QgaW1wbGVtZW50ZWRcbiAgdmFyIFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xuICB2YXIgVE9VQ0hfQUNUSU9OX1BBTl9YID0gJ3Bhbi14JztcbiAgdmFyIFRPVUNIX0FDVElPTl9QQU5fWSA9ICdwYW4teSc7XG4gIHZhciBUT1VDSF9BQ1RJT05fTUFQID0gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpO1xuXG4gIC8qKlxuICAgKiBUb3VjaCBBY3Rpb25cbiAgICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFRvdWNoQWN0aW9uKG1hbmFnZXIsIHZhbHVlKSB7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLnNldCh2YWx1ZSk7XG4gIH1cbiAgVG91Y2hBY3Rpb24ucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWUgb24gdGhlIGVsZW1lbnQgb3IgZW5hYmxlIHRoZSBwb2x5ZmlsbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAvLyBmaW5kIG91dCB0aGUgdG91Y2gtYWN0aW9uIGJ5IHRoZSBldmVudCBoYW5kbGVyc1xuICAgICAgaWYgKHZhbHVlID09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5jb21wdXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoTkFUSVZFX1RPVUNIX0FDVElPTiAmJiB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZSAmJiBUT1VDSF9BQ1RJT05fTUFQW3ZhbHVlXSkge1xuICAgICAgICB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZVtQUkVGSVhFRF9UT1VDSF9BQ1RJT05dID0gdmFsdWU7XG4gICAgICB9XG4gICAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGp1c3QgcmUtc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZVxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcmVjb2duaXplcidzIHNldHRpbmdzXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBjb21wdXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgZWFjaCh0aGlzLm1hbmFnZXIucmVjb2duaXplcnMsIGZ1bmN0aW9uIChyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChib29sT3JGbihyZWNvZ25pemVyLm9wdGlvbnMuZW5hYmxlLCBbcmVjb2duaXplcl0pKSB7XG4gICAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMuam9pbignICcpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0czogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICB2YXIgc3JjRXZlbnQgPSBpbnB1dC5zcmNFdmVudDtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247XG5cbiAgICAgIC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxuICAgICAgaWYgKHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCkge1xuICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgIHZhciBoYXNOb25lID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1ldO1xuICAgICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWF07XG4gICAgICBpZiAoaGFzTm9uZSkge1xuICAgICAgICAvL2RvIG5vdCBwcmV2ZW50IGRlZmF1bHRzIGlmIHRoaXMgaXMgYSB0YXAgZ2VzdHVyZVxuXG4gICAgICAgIHZhciBpc1RhcFBvaW50ZXIgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IDE7XG4gICAgICAgIHZhciBpc1RhcE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCAyO1xuICAgICAgICB2YXIgaXNUYXBUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCAyNTA7XG4gICAgICAgIGlmIChpc1RhcFBvaW50ZXIgJiYgaXNUYXBNb3ZlbWVudCAmJiBpc1RhcFRvdWNoVGltZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgICAvLyBgcGFuLXggcGFuLXlgIG1lYW5zIGJyb3dzZXIgaGFuZGxlcyBhbGwgc2Nyb2xsaW5nL3Bhbm5pbmcsIGRvIG5vdCBwcmV2ZW50XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNOb25lIHx8IGhhc1BhblkgJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwgfHwgaGFzUGFuWCAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yIChzY3JvbGxpbmcgaW4gbW9zdCBjYXNlcylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjRXZlbnRcbiAgICAgKi9cbiAgICBwcmV2ZW50U3JjOiBmdW5jdGlvbiAoc3JjRXZlbnQpIHtcbiAgICAgIHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCA9IHRydWU7XG4gICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogd2hlbiB0aGUgdG91Y2hBY3Rpb25zIGFyZSBjb2xsZWN0ZWQgdGhleSBhcmUgbm90IGEgdmFsaWQgdmFsdWUsIHNvIHdlIG5lZWQgdG8gY2xlYW4gdGhpbmdzIHVwLiAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZnVuY3Rpb24gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucykge1xuICAgIC8vIG5vbmVcbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpKSB7XG4gICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgfVxuICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XG5cbiAgICAvLyBpZiBib3RoIHBhbi14IGFuZCBwYW4teSBhcmUgc2V0IChkaWZmZXJlbnQgcmVjb2duaXplcnNcbiAgICAvLyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMsIGUuZy4gaG9yaXpvbnRhbCBwYW4gYnV0IHZlcnRpY2FsIHN3aXBlPylcbiAgICAvLyB3ZSBuZWVkIG5vbmUgKGFzIG90aGVyd2lzZSB3aXRoIHBhbi14IHBhbi15IGNvbWJpbmVkIG5vbmUgb2YgdGhlc2VcbiAgICAvLyByZWNvZ25pemVycyB3aWxsIHdvcmssIHNpbmNlIHRoZSBicm93c2VyIHdvdWxkIGhhbmRsZSBhbGwgcGFubmluZ1xuICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICAvLyBwYW4teCBPUiBwYW4teVxuICAgIGlmIChoYXNQYW5YIHx8IGhhc1BhblkpIHtcbiAgICAgIHJldHVybiBoYXNQYW5YID8gVE9VQ0hfQUNUSU9OX1BBTl9YIDogVE9VQ0hfQUNUSU9OX1BBTl9ZO1xuICAgIH1cblxuICAgIC8vIG1hbmlwdWxhdGlvblxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OKSkge1xuICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT047XG4gICAgfVxuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fQVVUTztcbiAgfVxuICBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvblByb3BzKCkge1xuICAgIGlmICghTkFUSVZFX1RPVUNIX0FDVElPTikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdG91Y2hNYXAgPSB7fTtcbiAgICB2YXIgY3NzU3VwcG9ydHMgPSB3aW5kb3cuQ1NTICYmIHdpbmRvdy5DU1Muc3VwcG9ydHM7XG4gICAgWydhdXRvJywgJ21hbmlwdWxhdGlvbicsICdwYW4teScsICdwYW4teCcsICdwYW4teCBwYW4teScsICdub25lJ10uZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAvLyBJZiBjc3Muc3VwcG9ydHMgaXMgbm90IHN1cHBvcnRlZCBidXQgdGhlcmUgaXMgbmF0aXZlIHRvdWNoLWFjdGlvbiBhc3N1bWUgaXQgc3VwcG9ydHNcbiAgICAgIC8vIGFsbCB2YWx1ZXMuIFRoaXMgaXMgdGhlIGNhc2UgZm9yIElFIDEwIGFuZCAxMS5cbiAgICAgIHRvdWNoTWFwW3ZhbF0gPSBjc3NTdXBwb3J0cyA/IHdpbmRvdy5DU1Muc3VwcG9ydHMoJ3RvdWNoLWFjdGlvbicsIHZhbCkgOiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiB0b3VjaE1hcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvZ25pemVyIGZsb3cgZXhwbGFpbmVkOyAqXG4gICAqIEFsbCByZWNvZ25pemVycyBoYXZlIHRoZSBpbml0aWFsIHN0YXRlIG9mIFBPU1NJQkxFIHdoZW4gYSBpbnB1dCBzZXNzaW9uIHN0YXJ0cy5cbiAgICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXG4gICAqIEV4YW1wbGUgc2Vzc2lvbiBmb3IgbW91c2UtaW5wdXQ6IG1vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cFxuICAgKlxuICAgKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXG4gICAqIHdoaWNoIGRldGVybWluZXMgd2l0aCBzdGF0ZSBpdCBzaG91bGQgYmUuXG4gICAqXG4gICAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cbiAgICogUE9TU0lCTEUgdG8gZ2l2ZSBpdCBhbm90aGVyIGNoYW5nZSBvbiB0aGUgbmV4dCBjeWNsZS5cbiAgICpcbiAgICogICAgICAgICAgICAgICBQb3NzaWJsZVxuICAgKiAgICAgICAgICAgICAgICAgIHxcbiAgICogICAgICAgICAgICArLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICAgKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XG4gICAqICAgICAgKy0tLS0tKy0tLS0tKyAgICAgICAgICAgICAgIHxcbiAgICogICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgfFxuICAgKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLSstLS0tLS0rXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG4gICAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENoYW5nZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kZWQvUmVjb2duaXplZFxuICAgKi9cbiAgdmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcbiAgdmFyIFNUQVRFX0JFR0FOID0gMjtcbiAgdmFyIFNUQVRFX0NIQU5HRUQgPSA0O1xuICB2YXIgU1RBVEVfRU5ERUQgPSA4O1xuICB2YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xuICB2YXIgU1RBVEVfQ0FOQ0VMTEVEID0gMTY7XG4gIHZhciBTVEFURV9GQUlMRUQgPSAzMjtcblxuICAvKipcbiAgICogUmVjb2duaXplclxuICAgKiBFdmVyeSByZWNvZ25pemVyIG5lZWRzIHRvIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcbiAgICB0aGlzLmlkID0gdW5pcXVlSWQoKTtcbiAgICB0aGlzLm1hbmFnZXIgPSBudWxsO1xuXG4gICAgLy8gZGVmYXVsdCBpcyBlbmFibGUgdHJ1ZVxuICAgIHRoaXMub3B0aW9ucy5lbmFibGUgPSBpZlVuZGVmaW5lZCh0aGlzLm9wdGlvbnMuZW5hYmxlLCB0cnVlKTtcbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgdGhpcy5zaW11bHRhbmVvdXMgPSB7fTtcbiAgICB0aGlzLnJlcXVpcmVGYWlsID0gW107XG4gIH1cbiAgUmVjb2duaXplci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7fSxcbiAgICAvKipcbiAgICAgKiBzZXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UmVjb2duaXplcn1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgLy8gYWxzbyB1cGRhdGUgdGhlIHRvdWNoQWN0aW9uLCBpbiBjYXNlIHNvbWV0aGluZyBjaGFuZ2VkIGFib3V0IHRoZSBkaXJlY3Rpb25zL2VuYWJsZWQgc3RhdGVcbiAgICAgIHRoaXMubWFuYWdlciAmJiB0aGlzLm1hbmFnZXIudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICByZWNvZ25pemVXaXRoOiBmdW5jdGlvbiAob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIHNpbXVsdGFuZW91cyA9IHRoaXMuc2ltdWx0YW5lb3VzO1xuICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgaWYgKCFzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSkge1xuICAgICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlY29nbml6ZVdpdGgodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGRyb3AgdGhlIHNpbXVsdGFuZW91cyBsaW5rLiBpdCBkb2VzbnQgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVjb2duaXplV2l0aDogZnVuY3Rpb24gKG90aGVyUmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICBkZWxldGUgdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbiAob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciByZXF1aXJlRmFpbCA9IHRoaXMucmVxdWlyZUZhaWw7XG4gICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcbiAgICAgICAgcmVxdWlyZUZhaWwucHVzaChvdGhlclJlY29nbml6ZXIpO1xuICAgICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGRyb3AgdGhlIHJlcXVpcmVGYWlsdXJlIGxpbmsuIGl0IGRvZXMgbm90IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgZHJvcFJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbiAob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGhhcyByZXF1aXJlIGZhaWx1cmVzIGJvb2xlYW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSZXF1aXJlRmFpbHVyZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCA+IDA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNhblJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uIChvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcbiAgICAgKiB0aGF0IGFsbCB0aGUgbmVlZGVkIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQgYmVmb3JlIGVtaXR0aW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcbiAgICAgICAgc2VsZi5tYW5hZ2VyLmVtaXQoZXZlbnQsIGlucHV0KTtcbiAgICAgIH1cblxuICAgICAgLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXG4gICAgICBpZiAoc3RhdGUgPCBTVEFURV9FTkRFRCkge1xuICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICB9XG4gICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCk7IC8vIHNpbXBsZSAnZXZlbnROYW1lJyBldmVudHNcblxuICAgICAgaWYgKGlucHV0LmFkZGl0aW9uYWxFdmVudCkge1xuICAgICAgICAvLyBhZGRpdGlvbmFsIGV2ZW50KHBhbmxlZnQsIHBhbnJpZ2h0LCBwaW5jaGluLCBwaW5jaG91dC4uLilcbiAgICAgICAgZW1pdChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBwYW5lbmQgYW5kIHBhbmNhbmNlbFxuICAgICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XG4gICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgYWxsIHRoZSByZXF1aXJlIGZhaWx1cmUgcmVjb2duaXplcnMgaGFzIGZhaWxlZCxcbiAgICAgKiBpZiB0cnVlLCBpdCBlbWl0cyBhIGdlc3R1cmUgZXZlbnQsXG4gICAgICogb3RoZXJ3aXNlLCBzZXR1cCB0aGUgc3RhdGUgdG8gRkFJTEVELlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHRyeUVtaXQ6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgaWYgKHRoaXMuY2FuRW1pdCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgLy8gaXQncyBmYWlsaW5nIGFueXdheVxuICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGNhbiB3ZSBlbWl0P1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNhbkVtaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCEodGhpcy5yZXF1aXJlRmFpbFtpXS5zdGF0ZSAmIChTVEFURV9GQUlMRUQgfCBTVEFURV9QT1NTSUJMRSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24gKGlucHV0RGF0YSkge1xuICAgICAgLy8gbWFrZSBhIG5ldyBjb3B5IG9mIHRoZSBpbnB1dERhdGFcbiAgICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXG4gICAgICB2YXIgaW5wdXREYXRhQ2xvbmUgPSBhc3NpZ24oe30sIGlucHV0RGF0YSk7XG5cbiAgICAgIC8vIGlzIGlzIGVuYWJsZWQgYW5kIGFsbG93IHJlY29nbml6aW5nP1xuICAgICAgaWYgKCFib29sT3JGbih0aGlzLm9wdGlvbnMuZW5hYmxlLCBbdGhpcywgaW5wdXREYXRhQ2xvbmVdKSkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gcmVzZXQgd2hlbiB3ZSd2ZSByZWFjaGVkIHRoZSBlbmRcbiAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX1JFQ09HTklaRUQgfCBTVEFURV9DQU5DRUxMRUQgfCBTVEFURV9GQUlMRUQpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnByb2Nlc3MoaW5wdXREYXRhQ2xvbmUpO1xuXG4gICAgICAvLyB0aGUgcmVjb2duaXplciBoYXMgcmVjb2duaXplZCBhIGdlc3R1cmVcbiAgICAgIC8vIHNvIHRyaWdnZXIgYW4gZXZlbnRcbiAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEIHwgU1RBVEVfQ0FOQ0VMTEVEKSkge1xuICAgICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxuICAgICAqIHRoZSBhY3R1YWwgcmVjb2duaXppbmcgaGFwcGVucyBpbiB0aGlzIG1ldGhvZFxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqIEByZXR1cm5zIHtDb25zdH0gU1RBVEVcbiAgICAgKi9cbiAgICBwcm9jZXNzOiBmdW5jdGlvbiAoaW5wdXREYXRhKSB7fSxcbiAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgcHJlZmVycmVkIHRvdWNoLWFjdGlvblxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAvKipcbiAgICAgKiBjYWxsZWQgd2hlbiB0aGUgZ2VzdHVyZSBpc24ndCBhbGxvd2VkIHRvIHJlY29nbml6ZVxuICAgICAqIGxpa2Ugd2hlbiBhbm90aGVyIGlzIGJlaW5nIHJlY29nbml6ZWQgb3IgaXQgaXMgZGlzYWJsZWRcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7fVxuICB9O1xuXG4gIC8qKlxuICAgKiBnZXQgYSB1c2FibGUgc3RyaW5nLCB1c2VkIGFzIGV2ZW50IHBvc3RmaXhcbiAgICogQHBhcmFtIHtDb25zdH0gc3RhdGVcbiAgICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHN0YXRlU3RyKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlICYgU1RBVEVfQ0FOQ0VMTEVEKSB7XG4gICAgICByZXR1cm4gJ2NhbmNlbCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgICByZXR1cm4gJ2VuZCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0NIQU5HRUQpIHtcbiAgICAgIHJldHVybiAnbW92ZSc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0JFR0FOKSB7XG4gICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xuICAgKiBAcGFyYW0ge0NvbnN0fSBkaXJlY3Rpb25cbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIGRpcmVjdGlvblN0cihkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9ET1dOKSB7XG4gICAgICByZXR1cm4gJ2Rvd24nO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9VUCkge1xuICAgICAgcmV0dXJuICd1cCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0xFRlQpIHtcbiAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1JJR0hUKSB7XG4gICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gb3RoZXJSZWNvZ25pemVyXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XG4gICAgdmFyIG1hbmFnZXIgPSByZWNvZ25pemVyLm1hbmFnZXI7XG4gICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgIHJldHVybiBtYW5hZ2VyLmdldChvdGhlclJlY29nbml6ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb3RoZXJSZWNvZ25pemVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgcmVjb2duaXplciBpcyBqdXN0IHVzZWQgYXMgYSBiYXNlIGZvciB0aGUgc2ltcGxlIGF0dHJpYnV0ZSByZWNvZ25pemVycy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAgICovXG4gIGZ1bmN0aW9uIEF0dHJSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBpbmhlcml0KEF0dHJSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgKi9cbiAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICAgKi9cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICB2YXIgb3B0aW9uUG9pbnRlcnMgPSB0aGlzLm9wdGlvbnMucG9pbnRlcnM7XG4gICAgICByZXR1cm4gb3B0aW9uUG9pbnRlcnMgPT09IDAgfHwgaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25Qb2ludGVycztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIGlucHV0IGFuZCByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgcmVjb2duaXplclxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHsqfSBTdGF0ZVxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIHZhciBldmVudFR5cGUgPSBpbnB1dC5ldmVudFR5cGU7XG4gICAgICB2YXIgaXNSZWNvZ25pemVkID0gc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEKTtcbiAgICAgIHZhciBpc1ZhbGlkID0gdGhpcy5hdHRyVGVzdChpbnB1dCk7XG5cbiAgICAgIC8vIG9uIGNhbmNlbCBpbnB1dCBhbmQgd2UndmUgcmVjb2duaXplZCBiZWZvcmUsIHJldHVybiBTVEFURV9DQU5DRUxMRURcbiAgICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0FOQ0VMTEVEO1xuICAgICAgfSBlbHNlIGlmIChpc1JlY29nbml6ZWQgfHwgaXNWYWxpZCkge1xuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfRU5ERUQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIShzdGF0ZSAmIFNUQVRFX0JFR0FOKSkge1xuICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DSEFOR0VEO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQYW5cbiAgICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gICAqL1xuICBmdW5jdGlvbiBQYW5SZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5wWCA9IG51bGw7XG4gICAgdGhpcy5wWSA9IG51bGw7XG4gIH1cbiAgaW5oZXJpdChQYW5SZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGFuUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICBldmVudDogJ3BhbicsXG4gICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcbiAgICB9LFxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgICB9XG4gICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfSxcbiAgICBkaXJlY3Rpb25UZXN0OiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIGhhc01vdmVkID0gdHJ1ZTtcbiAgICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcbiAgICAgIHZhciB4ID0gaW5wdXQuZGVsdGFYO1xuICAgICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgIC8vIGxvY2sgdG8gYXhpcz9cbiAgICAgIGlmICghKGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uKSkge1xuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgIGRpcmVjdGlvbiA9IHggPT09IDAgPyBESVJFQ1RJT05fTk9ORSA6IHggPCAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgaGFzTW92ZWQgPSB4ICE9IHRoaXMucFg7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpcmVjdGlvbiA9IHkgPT09IDAgPyBESVJFQ1RJT05fTk9ORSA6IHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgaGFzTW92ZWQgPSB5ICE9IHRoaXMucFk7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcbiAgICB9LFxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBBdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTiB8fCAhKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSk7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIHRoaXMucFggPSBpbnB1dC5kZWx0YVg7XG4gICAgICB0aGlzLnBZID0gaW5wdXQuZGVsdGFZO1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xuICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb247XG4gICAgICB9XG4gICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFBpbmNoXG4gICAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVycyBhcmUgbW92aW5nIHRvd2FyZCAoem9vbS1pbikgb3IgYXdheSBmcm9tIGVhY2ggb3RoZXIgKHpvb20tb3V0KS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gICAqL1xuICBmdW5jdGlvbiBQaW5jaFJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBpbmhlcml0KFBpbmNoUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICBldmVudDogJ3BpbmNoJyxcbiAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSxcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfSxcbiAgICBhdHRyVGVzdDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dC5zY2FsZSAhPT0gMSkge1xuICAgICAgICB2YXIgaW5PdXQgPSBpbnB1dC5zY2FsZSA8IDEgPyAnaW4nIDogJ291dCc7XG4gICAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGluT3V0O1xuICAgICAgfVxuICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQcmVzc1xuICAgKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBmb3IgeCBtcyB3aXRob3V0IGFueSBtb3ZlbWVudC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAgICovXG4gIGZ1bmN0aW9uIFByZXNzUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgfVxuICBpbmhlcml0KFByZXNzUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUHJlc3NSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIGV2ZW50OiAncHJlc3MnLFxuICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICB0aW1lOiAyNTEsXG4gICAgICAvLyBtaW5pbWFsIHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgcHJlc3NlZFxuICAgICAgdGhyZXNob2xkOiA5IC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgfSxcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gICAgfSxcbiAgICBwcm9jZXNzOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICB2YXIgdmFsaWRUaW1lID0gaW5wdXQuZGVsdGFUaW1lID4gb3B0aW9ucy50aW1lO1xuICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICAgIGlmICghdmFsaWRNb3ZlbWVudCB8fCAhdmFsaWRQb2ludGVycyB8fCBpbnB1dC5ldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAhdmFsaWRUaW1lKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgICAgfSwgb3B0aW9ucy50aW1lLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaW5wdXQgJiYgaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArICd1cCcsIGlucHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSb3RhdGVcbiAgICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXIgYXJlIG1vdmluZyBpbiBhIGNpcmN1bGFyIG1vdGlvbi5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gICAqL1xuICBmdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgaW5oZXJpdChSb3RhdGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUm90YXRlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICBwb2ludGVyczogMlxuICAgIH0sXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgIH0sXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmIChNYXRoLmFicyhpbnB1dC5yb3RhdGlvbikgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogU3dpcGVcbiAgICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gICAqL1xuICBmdW5jdGlvbiBTd2lwZVJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBpbmhlcml0KFN3aXBlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFN3aXBlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICBldmVudDogJ3N3aXBlJyxcbiAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICB2ZWxvY2l0eTogMC4zLFxuICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XG4gICAgfSxcbiAgICBhdHRyVGVzdDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgIHZhciB2ZWxvY2l0eTtcbiAgICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5O1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVg7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgZGlyZWN0aW9uICYgaW5wdXQub2Zmc2V0RGlyZWN0aW9uICYmIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJiBpbnB1dC5tYXhQb2ludGVycyA9PSB0aGlzLm9wdGlvbnMucG9pbnRlcnMgJiYgYWJzKHZlbG9jaXR5KSA+IHRoaXMub3B0aW9ucy52ZWxvY2l0eSAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQ7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQub2Zmc2V0RGlyZWN0aW9uKTtcbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIGlucHV0KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBIHRhcCBpcyBlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb2luZyBhIHNtYWxsIHRhcC9jbGljay4gTXVsdGlwbGUgdGFwcyBhcmUgcmVjb2duaXplZCBpZiB0aGV5IG9jY3VyXG4gICAqIGJldHdlZW4gdGhlIGdpdmVuIGludGVydmFsIGFuZCBwb3NpdGlvbi4gVGhlIGRlbGF5IG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZWNvZ25pemUgbXVsdGktdGFwcyB3aXRob3V0IGZpcmluZ1xuICAgKiBhIHNpbmdsZSB0YXAuXG4gICAqXG4gICAqIFRoZSBldmVudERhdGEgZnJvbSB0aGUgZW1pdHRlZCBldmVudCBjb250YWlucyB0aGUgcHJvcGVydHkgYHRhcENvdW50YCwgd2hpY2ggY29udGFpbnMgdGhlIGFtb3VudCBvZlxuICAgKiBtdWx0aS10YXBzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gICAqL1xuICBmdW5jdGlvbiBUYXBSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIHByZXZpb3VzIHRpbWUgYW5kIGNlbnRlcixcbiAgICAvLyB1c2VkIGZvciB0YXAgY291bnRpbmdcbiAgICB0aGlzLnBUaW1lID0gZmFsc2U7XG4gICAgdGhpcy5wQ2VudGVyID0gZmFsc2U7XG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgfVxuICBpbmhlcml0KFRhcFJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICBldmVudDogJ3RhcCcsXG4gICAgICBwb2ludGVyczogMSxcbiAgICAgIHRhcHM6IDEsXG4gICAgICBpbnRlcnZhbDogMzAwLFxuICAgICAgLy8gbWF4IHRpbWUgYmV0d2VlbiB0aGUgbXVsdGktdGFwIHRhcHNcbiAgICAgIHRpbWU6IDI1MCxcbiAgICAgIC8vIG1heCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIGRvd24gKGxpa2UgZmluZ2VyIG9uIHRoZSBzY3JlZW4pXG4gICAgICB0aHJlc2hvbGQ6IDksXG4gICAgICAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgICAgcG9zVGhyZXNob2xkOiAxMCAvLyBhIG11bHRpLXRhcCBjYW4gYmUgYSBiaXQgb2ZmIHRoZSBpbml0aWFsIHBvc2l0aW9uXG4gICAgfSxcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OXTtcbiAgICB9LFxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgIHZhciB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiB0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG4gICAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XG4gICAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfRU5EKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsaWRJbnRlcnZhbCA9IHRoaXMucFRpbWUgPyBpbnB1dC50aW1lU3RhbXAgLSB0aGlzLnBUaW1lIDwgb3B0aW9ucy5pbnRlcnZhbCA6IHRydWU7XG4gICAgICAgIHZhciB2YWxpZE11bHRpVGFwID0gIXRoaXMucENlbnRlciB8fCBnZXREaXN0YW5jZSh0aGlzLnBDZW50ZXIsIGlucHV0LmNlbnRlcikgPCBvcHRpb25zLnBvc1RocmVzaG9sZDtcbiAgICAgICAgdGhpcy5wVGltZSA9IGlucHV0LnRpbWVTdGFtcDtcbiAgICAgICAgdGhpcy5wQ2VudGVyID0gaW5wdXQuY2VudGVyO1xuICAgICAgICBpZiAoIXZhbGlkTXVsdGlUYXAgfHwgIXZhbGlkSW50ZXJ2YWwpIHtcbiAgICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgICAvLyBpZiB0YXAgY291bnQgbWF0Y2hlcyB3ZSBoYXZlIHJlY29nbml6ZWQgaXQsXG4gICAgICAgIC8vIGVsc2UgaXQgaGFzIGJlZ2FuIHJlY29nbml6aW5nLi4uXG4gICAgICAgIHZhciB0YXBDb3VudCA9IHRoaXMuY291bnQgJSBvcHRpb25zLnRhcHM7XG4gICAgICAgIGlmICh0YXBDb3VudCA9PT0gMCkge1xuICAgICAgICAgIC8vIG5vIGZhaWxpbmcgcmVxdWlyZW1lbnRzLCBpbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSB0YXAgZXZlbnRcbiAgICAgICAgICAvLyBvciB3YWl0IGFzIGxvbmcgYXMgdGhlIG11bHRpdGFwIGludGVydmFsIHRvIHRyaWdnZXJcbiAgICAgICAgICBpZiAoIXRoaXMuaGFzUmVxdWlyZUZhaWx1cmVzKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG4gICAgZmFpbFRpbWVvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcbiAgICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgdGhpcy5faW5wdXQudGFwQ291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTaW1wbGUgd2F5IHRvIGNyZWF0ZSBhIG1hbmFnZXIgd2l0aCBhIGRlZmF1bHQgc2V0IG9mIHJlY29nbml6ZXJzLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucmVjb2duaXplcnMgPSBpZlVuZGVmaW5lZChvcHRpb25zLnJlY29nbml6ZXJzLCBIYW1tZXIuZGVmYXVsdHMucHJlc2V0KTtcbiAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQGNvbnN0IHtzdHJpbmd9XG4gICAqL1xuICBIYW1tZXIuVkVSU0lPTiA9ICcyLjAuNyc7XG5cbiAgLyoqXG4gICAqIGRlZmF1bHQgc2V0dGluZ3NcbiAgICogQG5hbWVzcGFjZVxuICAgKi9cbiAgSGFtbWVyLmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIHNldCBpZiBET00gZXZlbnRzIGFyZSBiZWluZyB0cmlnZ2VyZWQuXG4gICAgICogQnV0IHRoaXMgaXMgc2xvd2VyIGFuZCB1bnVzZWQgYnkgc2ltcGxlIGltcGxlbWVudGF0aW9ucywgc28gZGlzYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGRvbUV2ZW50czogZmFsc2UsXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkvZmFsbGJhY2suXG4gICAgICogV2hlbiBzZXQgdG8gYGNvbXB1dGVgIGl0IHdpbGwgbWFnaWNhbGx5IHNldCB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiB0aGUgYWRkZWQgcmVjb2duaXplcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBjb21wdXRlXG4gICAgICovXG4gICAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBlbmFibGU6IHRydWUsXG4gICAgLyoqXG4gICAgICogRVhQRVJJTUVOVEFMIEZFQVRVUkUgLS0gY2FuIGJlIHJlbW92ZWQvY2hhbmdlZFxuICAgICAqIENoYW5nZSB0aGUgcGFyZW50IGlucHV0IHRhcmdldCBlbGVtZW50LlxuICAgICAqIElmIE51bGwsIHRoZW4gaXQgaXMgYmVpbmcgc2V0IHRoZSB0byBtYWluIGVsZW1lbnQuXG4gICAgICogQHR5cGUge051bGx8RXZlbnRUYXJnZXR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGlucHV0VGFyZ2V0OiBudWxsLFxuICAgIC8qKlxuICAgICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXG4gICAgICogQHR5cGUge051bGx8RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGlucHV0Q2xhc3M6IG51bGwsXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCByZWNvZ25pemVyIHNldHVwIHdoZW4gY2FsbGluZyBgSGFtbWVyKClgXG4gICAgICogV2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyIHRoZXNlIHdpbGwgYmUgc2tpcHBlZC5cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgcHJlc2V0OiBbXG4gICAgLy8gUmVjb2duaXplckNsYXNzLCBvcHRpb25zLCBbcmVjb2duaXplV2l0aCwgLi4uXSwgW3JlcXVpcmVGYWlsdXJlLCAuLi5dXG4gICAgW1JvdGF0ZVJlY29nbml6ZXIsIHtcbiAgICAgIGVuYWJsZTogZmFsc2VcbiAgICB9XSwgW1BpbmNoUmVjb2duaXplciwge1xuICAgICAgZW5hYmxlOiBmYWxzZVxuICAgIH0sIFsncm90YXRlJ11dLCBbU3dpcGVSZWNvZ25pemVyLCB7XG4gICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMXG4gICAgfV0sIFtQYW5SZWNvZ25pemVyLCB7XG4gICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMXG4gICAgfSwgWydzd2lwZSddXSwgW1RhcFJlY29nbml6ZXJdLCBbVGFwUmVjb2duaXplciwge1xuICAgICAgZXZlbnQ6ICdkb3VibGV0YXAnLFxuICAgICAgdGFwczogMlxuICAgIH0sIFsndGFwJ11dLCBbUHJlc3NSZWNvZ25pemVyXV0sXG4gICAgLyoqXG4gICAgICogU29tZSBDU1MgcHJvcGVydGllcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHRoZSB3b3JraW5nIG9mIEhhbW1lci5cbiAgICAgKiBBZGQgdGhlbSB0byB0aGlzIG1ldGhvZCBhbmQgdGhleSB3aWxsIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIuXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqL1xuICAgIGNzc1Byb3BzOiB7XG4gICAgICAvKipcbiAgICAgICAqIERpc2FibGVzIHRleHQgc2VsZWN0aW9uIHRvIGltcHJvdmUgdGhlIGRyYWdnaW5nIGdlc3R1cmUuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAqL1xuICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXNhYmxlIHRoZSBXaW5kb3dzIFBob25lIGdyaXBwZXJzIHdoZW4gcHJlc3NpbmcgYW4gZWxlbWVudC5cbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAqL1xuICAgICAgdG91Y2hTZWxlY3Q6ICdub25lJyxcbiAgICAgIC8qKlxuICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuICAgICAgICogYSBjYWxsb3V0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxpbmsuIFRoaXMgcHJvcGVydHkgYWxsb3dzIHlvdSB0byBkaXNhYmxlIHRoYXQgY2FsbG91dC5cbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAqL1xuICAgICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICovXG4gICAgICBjb250ZW50Wm9vbWluZzogJ25vbmUnLFxuICAgICAgLyoqXG4gICAgICAgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgKi9cbiAgICAgIHVzZXJEcmFnOiAnbm9uZScsXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyB0aGUgaGlnaGxpZ2h0IGNvbG9yIHNob3duIHdoZW4gdGhlIHVzZXIgdGFwcyBhIGxpbmsgb3IgYSBKYXZhU2NyaXB0XG4gICAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICogQGRlZmF1bHQgJ3JnYmEoMCwwLDAsMCknXG4gICAgICAgKi9cbiAgICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgICB9XG4gIH07XG4gIHZhciBTVE9QID0gMTtcbiAgdmFyIEZPUkNFRF9TVE9QID0gMjtcblxuICAvKipcbiAgICogTWFuYWdlclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIEhhbW1lci5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG4gICAgdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0ID0gdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0IHx8IGVsZW1lbnQ7XG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcbiAgICB0aGlzLm9sZENzc1Byb3BzID0ge307XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcbiAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XG4gICAgdG9nZ2xlQ3NzUHJvcHModGhpcywgdHJ1ZSk7XG4gICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgcmVjb2duaXplciA9IHRoaXMuYWRkKG5ldyBpdGVtWzBdKGl0ZW1bMV0pKTtcbiAgICAgIGl0ZW1bMl0gJiYgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW1bMl0pO1xuICAgICAgaXRlbVszXSAmJiByZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKGl0ZW1bM10pO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIE1hbmFnZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgLy8gT3B0aW9ucyB0aGF0IG5lZWQgYSBsaXR0bGUgbW9yZSBzZXR1cFxuICAgICAgaWYgKG9wdGlvbnMudG91Y2hBY3Rpb24pIHtcbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmlucHV0VGFyZ2V0KSB7XG4gICAgICAgIC8vIENsZWFuIHVwIGV4aXN0aW5nIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVpbml0aWFsaXplXG4gICAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlucHV0LnRhcmdldCA9IG9wdGlvbnMuaW5wdXRUYXJnZXQ7XG4gICAgICAgIHRoaXMuaW5wdXQuaW5pdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzdG9wIHJlY29nbml6aW5nIGZvciB0aGlzIHNlc3Npb24uXG4gICAgICogVGhpcyBzZXNzaW9uIHdpbGwgYmUgZGlzY2FyZGVkLCB3aGVuIGEgbmV3IFtpbnB1dF1zdGFydCBldmVudCBpcyBmaXJlZC5cbiAgICAgKiBXaGVuIGZvcmNlZCwgdGhlIHJlY29nbml6ZXIgY3ljbGUgaXMgc3RvcHBlZCBpbW1lZGlhdGVseS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAgICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgIHRoaXMuc2Vzc2lvbi5zdG9wcGVkID0gZm9yY2UgPyBGT1JDRURfU1RPUCA6IFNUT1A7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBydW4gdGhlIHJlY29nbml6ZXJzIVxuICAgICAqIGNhbGxlZCBieSB0aGUgaW5wdXRIYW5kbGVyIGZ1bmN0aW9uIG9uIGV2ZXJ5IG1vdmVtZW50IG9mIHRoZSBwb2ludGVycyAodG91Y2hlcylcbiAgICAgKiBpdCB3YWxrcyB0aHJvdWdoIGFsbCB0aGUgcmVjb2duaXplcnMgYW5kIHRyaWVzIHRvIGRldGVjdCB0aGUgZ2VzdHVyZSB0aGF0IGlzIGJlaW5nIG1hZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgcmVjb2duaXplOiBmdW5jdGlvbiAoaW5wdXREYXRhKSB7XG4gICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuICAgICAgdGhpcy50b3VjaEFjdGlvbi5wcmV2ZW50RGVmYXVsdHMoaW5wdXREYXRhKTtcbiAgICAgIHZhciByZWNvZ25pemVyO1xuICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcblxuICAgICAgLy8gdGhpcyBob2xkcyB0aGUgcmVjb2duaXplciB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXG4gICAgICAvLyBpZiBubyByZWNvZ25pemVyIGlzIGRldGVjdGluZyBhIHRoaW5nLCBpdCBpcyBzZXQgdG8gYG51bGxgXG4gICAgICB2YXIgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplcjtcblxuICAgICAgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAgIC8vIG9yIHdoZW4gd2UncmUgaW4gYSBuZXcgc2Vzc2lvblxuICAgICAgaWYgKCFjdXJSZWNvZ25pemVyIHx8IGN1clJlY29nbml6ZXIgJiYgY3VyUmVjb2duaXplci5zdGF0ZSAmIFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xuICAgICAgICByZWNvZ25pemVyID0gcmVjb2duaXplcnNbaV07XG5cbiAgICAgICAgLy8gZmluZCBvdXQgaWYgd2UgYXJlIGFsbG93ZWQgdHJ5IHRvIHJlY29nbml6ZSB0aGUgaW5wdXQgZm9yIHRoaXMgb25lLlxuICAgICAgICAvLyAxLiAgIGFsbG93IGlmIHRoZSBzZXNzaW9uIGlzIE5PVCBmb3JjZWQgc3RvcHBlZCAoc2VlIHRoZSAuc3RvcCgpIG1ldGhvZClcbiAgICAgICAgLy8gMi4gICBhbGxvdyBpZiB3ZSBzdGlsbCBoYXZlbid0IHJlY29nbml6ZWQgYSBnZXN0dXJlIGluIHRoaXMgc2Vzc2lvbiwgb3IgdGhlIHRoaXMgcmVjb2duaXplciBpcyB0aGUgb25lXG4gICAgICAgIC8vICAgICAgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAvLyAzLiAgIGFsbG93IGlmIHRoZSByZWNvZ25pemVyIGlzIGFsbG93ZWQgdG8gcnVuIHNpbXVsdGFuZW91cyB3aXRoIHRoZSBjdXJyZW50IHJlY29nbml6ZWQgcmVjb2duaXplci5cbiAgICAgICAgLy8gICAgICB0aGlzIGNhbiBiZSBzZXR1cCB3aXRoIHRoZSBgcmVjb2duaXplV2l0aCgpYCBtZXRob2Qgb24gdGhlIHJlY29nbml6ZXIuXG4gICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQgIT09IEZPUkNFRF9TVE9QICYmIChcbiAgICAgICAgLy8gMVxuICAgICAgICAhY3VyUmVjb2duaXplciB8fCByZWNvZ25pemVyID09IGN1clJlY29nbml6ZXIgfHxcbiAgICAgICAgLy8gMlxuICAgICAgICByZWNvZ25pemVyLmNhblJlY29nbml6ZVdpdGgoY3VyUmVjb2duaXplcikpKSB7XG4gICAgICAgICAgLy8gM1xuICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHJlY29nbml6ZXIgaGFzIGJlZW4gcmVjb2duaXppbmcgdGhlIGlucHV0IGFzIGEgdmFsaWQgZ2VzdHVyZSwgd2Ugd2FudCB0byBzdG9yZSB0aGlzIG9uZSBhcyB0aGVcbiAgICAgICAgLy8gY3VycmVudCBhY3RpdmUgcmVjb2duaXplci4gYnV0IG9ubHkgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGFuIGFjdGl2ZSByZWNvZ25pemVyXG4gICAgICAgIGlmICghY3VyUmVjb2duaXplciAmJiByZWNvZ25pemVyLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEKSkge1xuICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBhIHJlY29nbml6ZXIgYnkgaXRzIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE51bGx9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAocmVjb2duaXplcikge1xuICAgICAgaWYgKHJlY29nbml6ZXIgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSB7XG4gICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgICAgfVxuICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlY29nbml6ZXJzW2ldLm9wdGlvbnMuZXZlbnQgPT0gcmVjb2duaXplcikge1xuICAgICAgICAgIHJldHVybiByZWNvZ25pemVyc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBhZGQgYSByZWNvZ25pemVyIHRvIHRoZSBtYW5hZ2VyXG4gICAgICogZXhpc3RpbmcgcmVjb2duaXplcnMgd2l0aCB0aGUgc2FtZSBldmVudCBuYW1lIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE1hbmFnZXJ9XG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbiAocmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdhZGQnLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXG4gICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLmdldChyZWNvZ25pemVyLm9wdGlvbnMuZXZlbnQpO1xuICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVjb2duaXplcnMucHVzaChyZWNvZ25pemVyKTtcbiAgICAgIHJlY29nbml6ZXIubWFuYWdlciA9IHRoaXM7XG4gICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZW1vdmUgYSByZWNvZ25pemVyIGJ5IG5hbWUgb3IgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAocmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdyZW1vdmUnLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJlY29nbml6ZXIgPSB0aGlzLmdldChyZWNvZ25pemVyKTtcblxuICAgICAgLy8gbGV0J3MgbWFrZSBzdXJlIHRoaXMgcmVjb2duaXplciBleGlzdHNcbiAgICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgIHZhciBpbmRleCA9IGluQXJyYXkocmVjb2duaXplcnMsIHJlY29nbml6ZXIpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgcmVjb2duaXplcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGJpbmQgZXZlbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24gKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXJzW2V2ZW50XSB8fCBbXTtcbiAgICAgICAgaGFuZGxlcnNbZXZlbnRdLnB1c2goaGFuZGxlcik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24gKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICBkZWxldGUgaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XSAmJiBoYW5kbGVyc1tldmVudF0uc3BsaWNlKGluQXJyYXkoaGFuZGxlcnNbZXZlbnRdLCBoYW5kbGVyKSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBlbWl0IGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kb21FdmVudHMpIHtcbiAgICAgICAgdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKTtcbiAgICAgIH1cblxuICAgICAgLy8gbm8gaGFuZGxlcnMsIHNvIHNraXAgaXQgYWxsXG4gICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xuICAgICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRhdGEudHlwZSA9IGV2ZW50O1xuICAgICAgZGF0YS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgIGhhbmRsZXJzW2ldKGRhdGEpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBkZXN0cm95IHRoZSBtYW5hZ2VyIGFuZCB1bmJpbmRzIGFsbCBldmVudHNcbiAgICAgKiBpdCBkb2Vzbid0IHVuYmluZCBkb20gZXZlbnRzLCB0aGF0IGlzIHRoZSB1c2VyIG93biByZXNwb25zaWJpbGl0eVxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZWxlbWVudCAmJiB0b2dnbGVDc3NQcm9wcyh0aGlzLCBmYWxzZSk7XG4gICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGFkZC9yZW1vdmUgdGhlIGNzcyBwcm9wZXJ0aWVzIGFzIGRlZmluZWQgaW4gbWFuYWdlci5vcHRpb25zLmNzc1Byb3BzXG4gICAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFkZFxuICAgKi9cbiAgZnVuY3Rpb24gdG9nZ2xlQ3NzUHJvcHMobWFuYWdlciwgYWRkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwcm9wO1xuICAgIGVhY2gobWFuYWdlci5vcHRpb25zLmNzc1Byb3BzLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICAgIHByb3AgPSBwcmVmaXhlZChlbGVtZW50LnN0eWxlLCBuYW1lKTtcbiAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSA9IGVsZW1lbnQuc3R5bGVbcHJvcF07XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdIHx8ICcnO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghYWRkKSB7XG4gICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzID0ge307XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHRyaWdnZXIgZG9tIGV2ZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cbiAgZnVuY3Rpb24gdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGdlc3R1cmVFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGdlc3R1cmVFdmVudC5pbml0RXZlbnQoZXZlbnQsIHRydWUsIHRydWUpO1xuICAgIGdlc3R1cmVFdmVudC5nZXN0dXJlID0gZGF0YTtcbiAgICBkYXRhLnRhcmdldC5kaXNwYXRjaEV2ZW50KGdlc3R1cmVFdmVudCk7XG4gIH1cbiAgYXNzaWduKEhhbW1lciwge1xuICAgIElOUFVUX1NUQVJUOiBJTlBVVF9TVEFSVCxcbiAgICBJTlBVVF9NT1ZFOiBJTlBVVF9NT1ZFLFxuICAgIElOUFVUX0VORDogSU5QVVRfRU5ELFxuICAgIElOUFVUX0NBTkNFTDogSU5QVVRfQ0FOQ0VMLFxuICAgIFNUQVRFX1BPU1NJQkxFOiBTVEFURV9QT1NTSUJMRSxcbiAgICBTVEFURV9CRUdBTjogU1RBVEVfQkVHQU4sXG4gICAgU1RBVEVfQ0hBTkdFRDogU1RBVEVfQ0hBTkdFRCxcbiAgICBTVEFURV9FTkRFRDogU1RBVEVfRU5ERUQsXG4gICAgU1RBVEVfUkVDT0dOSVpFRDogU1RBVEVfUkVDT0dOSVpFRCxcbiAgICBTVEFURV9DQU5DRUxMRUQ6IFNUQVRFX0NBTkNFTExFRCxcbiAgICBTVEFURV9GQUlMRUQ6IFNUQVRFX0ZBSUxFRCxcbiAgICBESVJFQ1RJT05fTk9ORTogRElSRUNUSU9OX05PTkUsXG4gICAgRElSRUNUSU9OX0xFRlQ6IERJUkVDVElPTl9MRUZULFxuICAgIERJUkVDVElPTl9SSUdIVDogRElSRUNUSU9OX1JJR0hULFxuICAgIERJUkVDVElPTl9VUDogRElSRUNUSU9OX1VQLFxuICAgIERJUkVDVElPTl9ET1dOOiBESVJFQ1RJT05fRE9XTixcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTDogRElSRUNUSU9OX0hPUklaT05UQUwsXG4gICAgRElSRUNUSU9OX1ZFUlRJQ0FMOiBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgRElSRUNUSU9OX0FMTDogRElSRUNUSU9OX0FMTCxcbiAgICBNYW5hZ2VyOiBNYW5hZ2VyLFxuICAgIElucHV0OiBJbnB1dCxcbiAgICBUb3VjaEFjdGlvbjogVG91Y2hBY3Rpb24sXG4gICAgVG91Y2hJbnB1dDogVG91Y2hJbnB1dCxcbiAgICBNb3VzZUlucHV0OiBNb3VzZUlucHV0LFxuICAgIFBvaW50ZXJFdmVudElucHV0OiBQb2ludGVyRXZlbnRJbnB1dCxcbiAgICBUb3VjaE1vdXNlSW5wdXQ6IFRvdWNoTW91c2VJbnB1dCxcbiAgICBTaW5nbGVUb3VjaElucHV0OiBTaW5nbGVUb3VjaElucHV0LFxuICAgIFJlY29nbml6ZXI6IFJlY29nbml6ZXIsXG4gICAgQXR0clJlY29nbml6ZXI6IEF0dHJSZWNvZ25pemVyLFxuICAgIFRhcDogVGFwUmVjb2duaXplcixcbiAgICBQYW46IFBhblJlY29nbml6ZXIsXG4gICAgU3dpcGU6IFN3aXBlUmVjb2duaXplcixcbiAgICBQaW5jaDogUGluY2hSZWNvZ25pemVyLFxuICAgIFJvdGF0ZTogUm90YXRlUmVjb2duaXplcixcbiAgICBQcmVzczogUHJlc3NSZWNvZ25pemVyLFxuICAgIG9uOiBhZGRFdmVudExpc3RlbmVycyxcbiAgICBvZmY6IHJlbW92ZUV2ZW50TGlzdGVuZXJzLFxuICAgIGVhY2g6IGVhY2gsXG4gICAgbWVyZ2U6IG1lcmdlLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIGFzc2lnbjogYXNzaWduLFxuICAgIGluaGVyaXQ6IGluaGVyaXQsXG4gICAgYmluZEZuOiBiaW5kRm4sXG4gICAgcHJlZml4ZWQ6IHByZWZpeGVkXG4gIH0pO1xuXG4gIC8vIHRoaXMgcHJldmVudHMgZXJyb3JzIHdoZW4gSGFtbWVyIGlzIGxvYWRlZCBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EXG4gIC8vICBzdHlsZSBsb2FkZXIgYnV0IGJ5IHNjcmlwdCB0YWcsIG5vdCBieSB0aGUgbG9hZGVyLlxuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9OyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgZnJlZUdsb2JhbC5IYW1tZXIgPSBIYW1tZXI7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEhhbW1lcjtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIYW1tZXI7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93W2V4cG9ydE5hbWVdID0gSGFtbWVyO1xuICB9XG59KSh3aW5kb3csIGRvY3VtZW50LCAnSGFtbWVyJyk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///75645\n")},31254:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": function() { return /* binding */ pages; }\n});\n\n// NAMESPACE OBJECT: ./src/components/MapSearch/MapSearch.module.scss\nvar MapSearch_module_namespaceObject = {};\n__webpack_require__.r(MapSearch_module_namespaceObject);\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(96540);\n// EXTERNAL MODULE: ./node_modules/gatsby-plugin-intl/index.js\nvar gatsby_plugin_intl = __webpack_require__(23218);\n// EXTERNAL MODULE: ./node_modules/@trussworks/react-uswds/lib/index.js\nvar lib = __webpack_require__(17292);\n// EXTERNAL MODULE: ./src/data/copy/explore.tsx\nvar explore = __webpack_require__(9284);\n;// ./src/components/ExploreDataBox/ExploreDataBox.module.scss\n// extracted by mini-css-extract-plugin\nvar fileDownIcon = \"ExploreDataBox-module--fileDownIcon--ELpRf\";\nvar summaryBoxContainer = \"ExploreDataBox-module--summaryBoxContainer--7DnTC\";\n// EXTERNAL MODULE: ./node_modules/uswds/dist/img/usa-icons/file_download.svg\nvar file_download = __webpack_require__(96168);\n;// ./src/components/ExploreDataBox/ExploreDataBox.tsx\n// @ts-ignore\nconst ExploreDataBox=_ref=>{let{}=_ref;const intl=(0,gatsby_plugin_intl.useIntl)();return/*#__PURE__*/react.createElement(lib.SummaryBox,{className:summaryBoxContainer},/*#__PURE__*/react.createElement(lib.SummaryBoxHeading,{headingLevel:\"h2\"},intl.formatMessage(explore/* EXPLORE_DATA_BOX */.jU.TITLE),/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:fileDownIcon,src:file_download/* default */.A,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.PLUS)})),/*#__PURE__*/react.createElement(lib.SummaryBoxContent,null,explore/* EXPLORE_DATA_BOX_BODY */.U5));};/* harmony default export */ var ExploreDataBox_ExploreDataBox = (ExploreDataBox);\n;// ./src/components/ExploreDataBox/index.ts\n/* harmony default export */ var components_ExploreDataBox = (ExploreDataBox_ExploreDataBox);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 3 modules\nvar toConsumableArray = __webpack_require__(45458);\n;// ./node_modules/@babel/runtime/helpers/esm/extends.js\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/typeof.js\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\n\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\n\n\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\n\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(5556);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n;// ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js\nvar unsupportedIterableToArray = __webpack_require__(27800);\n;// ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\n\n\n\n\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || (0,unsupportedIterableToArray/* default */.A)(r, e) || _nonIterableRest();\n}\n\n;// ./node_modules/gl-matrix/esm/common.js\n/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nvar EPSILON = 0.000001;\nvar ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nvar RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nfunction setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nfunction toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n    i = arguments.length;\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n  return Math.sqrt(y);\n};\n;// ./node_modules/gl-matrix/esm/vec4.js\n\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\n\nfunction create() {\n  var out = new ARRAY_TYPE(4);\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n  return out;\n}\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {ReadonlyVec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\n\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\n\nfunction fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the source vector\n * @returns {vec4} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\n\nfunction set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to ceil\n * @returns {vec4} out\n */\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to floor\n * @returns {vec4} out\n */\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to round\n * @returns {vec4} out\n */\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} distance between a and b\n */\n\nfunction distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Calculates the length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction vec4_length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nfunction squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to negate\n * @returns {vec4} out\n */\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to invert\n * @returns {vec4} out\n */\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to normalize\n * @returns {vec4} out\n */\n\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param {ReadonlyVec4} result the receiving vector\n * @param {ReadonlyVec4} U the first vector\n * @param {ReadonlyVec4} V the second vector\n * @param {ReadonlyVec4} W the third vector\n * @returns {vec4} result\n */\n\nfunction cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n    B = v[0] * w[2] - v[2] * w[0],\n    C = v[0] * w[3] - v[3] * w[0],\n    D = v[1] * w[2] - v[2] * w[1],\n    E = v[1] * w[3] - v[3] * w[1],\n    F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\n\nfunction random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n  do {\n    v1 = glMatrix.RANDOM() * 2 - 1;\n    v2 = glMatrix.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n  do {\n    v3 = glMatrix.RANDOM() * 2 - 1;\n    v4 = glMatrix.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec4} out\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n    y = a[1],\n    z = a[2],\n    w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec4} out\n */\n\nfunction transformQuat(out, a, q) {\n  var x = a[0],\n    y = a[1],\n    z = a[2];\n  var qx = q[0],\n    qy = q[1],\n    qz = q[2],\n    qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to zero\n *\n * @param {vec4} out the receiving vector\n * @returns {vec4} out\n */\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nfunction str(a) {\n  return \"vec4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction vec4_equals(a, b) {\n  var a0 = a[0],\n    a1 = a[1],\n    a2 = a[2],\n    a3 = a[3];\n  var b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\n\nvar sub = (/* unused pure expression or super */ null && (subtract));\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\n\nvar mul = (/* unused pure expression or super */ null && (multiply));\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\n\nvar div = (/* unused pure expression or super */ null && (divide));\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\n\nvar dist = (/* unused pure expression or super */ null && (distance));\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\n\nvar sqrDist = (/* unused pure expression or super */ null && (squaredDistance));\n/**\n * Alias for {@link vec4.length}\n * @function\n */\n\nvar len = (/* unused pure expression or super */ null && (vec4_length));\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\n\nvar sqrLen = (/* unused pure expression or super */ null && (squaredLength));\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nvar forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n    if (!stride) {\n      stride = 4;\n    }\n    if (!offset) {\n      offset = 0;\n    }\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n    return a;\n  };\n}();\n;// ./node_modules/@math.gl/web-mercator/dist/esm/math-utils.js\n\nfunction createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nfunction transformVector(matrix, vector) {\n  const result = transformMat4([], vector, matrix);\n  scale(result, result, 1 / result[3]);\n  return result;\n}\nfunction mod(value, divisor) {\n  const modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\nfunction math_utils_lerp(start, end, step) {\n  return step * end + (1 - step) * start;\n}\nfunction clamp(x, min, max) {\n  return x < min ? min : x > max ? max : x;\n}\nfunction ieLog2(x) {\n  return Math.log(x) * Math.LOG2E;\n}\nconst log2 = Math.log2 || ieLog2;\n;// ./node_modules/gl-matrix/esm/mat4.js\n\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\n\nfunction mat4_create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\n\nfunction mat4_clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction mat4_copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\n\nfunction mat4_fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\n\nfunction mat4_set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n    var a12 = a[6],\n      a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction invert(out, a) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a03 = a[3];\n  var a10 = a[4],\n    a11 = a[5],\n    a12 = a[6],\n    a13 = a[7];\n  var a20 = a[8],\n    a21 = a[9],\n    a22 = a[10],\n    a23 = a[11];\n  var a30 = a[12],\n    a31 = a[13],\n    a32 = a[14],\n    a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction adjoint(out, a) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a03 = a[3];\n  var a10 = a[4],\n    a11 = a[5],\n    a12 = a[6],\n    a13 = a[7];\n  var a20 = a[8],\n    a21 = a[9],\n    a22 = a[10],\n    a23 = a[11];\n  var a30 = a[12],\n    a31 = a[13],\n    a32 = a[14],\n    a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nfunction determinant(a) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a03 = a[3];\n  var a10 = a[4],\n    a11 = a[5],\n    a12 = a[6],\n    a13 = a[7];\n  var a20 = a[8],\n    a21 = a[9],\n    a22 = a[10],\n    a23 = a[11];\n  var a30 = a[12],\n    a31 = a[13],\n    a32 = a[14],\n    a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction mat4_multiply(out, a, b) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a03 = a[3];\n  var a10 = a[4],\n    a11 = a[5],\n    a12 = a[6],\n    a13 = a[7];\n  var a20 = a[8],\n    a21 = a[9],\n    a22 = a[10],\n    a23 = a[11];\n  var a30 = a[12],\n    a31 = a[13],\n    a32 = a[14],\n    a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\n\nfunction translate(out, a, v) {\n  var x = v[0],\n    y = v[1],\n    z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nfunction mat4_scale(out, a, v) {\n  var x = v[0],\n    y = v[1],\n    z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nfunction rotate(out, a, rad, axis) {\n  var x = axis[0],\n    y = axis[1],\n    z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nfunction fromRotation(out, rad, axis) {\n  var x = axis[0],\n    y = axis[1],\n    z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n    y = q[1],\n    z = q[2],\n    w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\n\nfunction fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n    by = -a[1],\n    bz = -a[2],\n    bw = a[3],\n    ax = a[4],\n    ay = a[5],\n    az = a[6],\n    aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nfunction getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nfunction getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nfunction getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n    y = q[1],\n    z = q[2],\n    w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n    y = q[1],\n    z = q[2],\n    w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nfunction fromQuat(out, q) {\n  var x = q[0],\n    y = q[1],\n    z = q[2],\n    w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nfunction perspectiveNO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n    nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n  return out;\n}\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\n\nvar perspective = perspectiveNO;\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nfunction perspectiveZO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n    nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction orthoNO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\n\nvar ortho = (/* unused pure expression or super */ null && (orthoNO));\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction orthoZO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = near * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nfunction lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nfunction targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n    eyey = eye[1],\n    eyez = eye[2],\n    upx = up[0],\n    upy = up[1],\n    upz = up[2];\n  var z0 = eyex - target[0],\n    z1 = eyey - target[1],\n    z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n  var x0 = upy * z2 - upz * z1,\n    x1 = upz * z0 - upx * z2,\n    x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nfunction mat4_str(a) {\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nfunction frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction mat4_add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction mat4_subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction mat4_exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction mat4_equals(a, b) {\n  var a0 = a[0],\n    a1 = a[1],\n    a2 = a[2],\n    a3 = a[3];\n  var a4 = a[4],\n    a5 = a[5],\n    a6 = a[6],\n    a7 = a[7];\n  var a8 = a[8],\n    a9 = a[9],\n    a10 = a[10],\n    a11 = a[11];\n  var a12 = a[12],\n    a13 = a[13],\n    a14 = a[14],\n    a15 = a[15];\n  var b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3];\n  var b4 = b[4],\n    b5 = b[5],\n    b6 = b[6],\n    b7 = b[7];\n  var b8 = b[8],\n    b9 = b[9],\n    b10 = b[10],\n    b11 = b[11];\n  var b12 = b[12],\n    b13 = b[13],\n    b14 = b[14],\n    b15 = b[15];\n  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\n\nvar mat4_mul = (/* unused pure expression or super */ null && (mat4_multiply));\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\n\nvar mat4_sub = (/* unused pure expression or super */ null && (mat4_subtract));\n;// ./node_modules/gl-matrix/esm/vec2.js\n\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\n\nfunction vec2_create() {\n  var out = new ARRAY_TYPE(2);\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n  return out;\n}\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {ReadonlyVec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\n\nfunction vec2_clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\n\nfunction vec2_fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the source vector\n * @returns {vec2} out\n */\n\nfunction vec2_copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\n\nfunction vec2_set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction vec2_add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction vec2_subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction vec2_multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction vec2_divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to ceil\n * @returns {vec2} out\n */\n\nfunction vec2_ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to floor\n * @returns {vec2} out\n */\n\nfunction vec2_floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction vec2_min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction vec2_max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to round\n * @returns {vec2} out\n */\n\nfunction vec2_round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\n\nfunction vec2_scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\n\nfunction vec2_scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} distance between a and b\n */\n\nfunction vec2_distance(a, b) {\n  var x = b[0] - a[0],\n    y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nfunction vec2_squaredDistance(a, b) {\n  var x = b[0] - a[0],\n    y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\n * Calculates the length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction vec2_length(a) {\n  var x = a[0],\n    y = a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nfunction vec2_squaredLength(a) {\n  var x = a[0],\n    y = a[1];\n  return x * x + y * y;\n}\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to negate\n * @returns {vec2} out\n */\n\nfunction vec2_negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to invert\n * @returns {vec2} out\n */\n\nfunction vec2_inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to normalize\n * @returns {vec2} out\n */\n\nfunction vec2_normalize(out, a) {\n  var x = a[0],\n    y = a[1];\n  var len = x * x + y * y;\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction vec2_dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec2_cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\n\nfunction vec2_lerp(out, a, b, t) {\n  var ax = a[0],\n    ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\n\nfunction vec2_random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction transformMat2(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2d} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction transformMat2d(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat3} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction vec2_transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {ReadonlyVec2} a The vec2 point to rotate\n * @param {ReadonlyVec2} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec2} out\n */\n\nfunction vec2_rotate(out, a, b, rad) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n    p1 = a[1] - b[1],\n    sinC = Math.sin(rad),\n    cosC = Math.cos(rad); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\n * Get the angle between two 2D vectors\n * @param {ReadonlyVec2} a The first operand\n * @param {ReadonlyVec2} b The second operand\n * @returns {Number} The angle in radians\n */\n\nfunction angle(a, b) {\n  var x1 = a[0],\n    y1 = a[1],\n    x2 = b[0],\n    y2 = b[1],\n    // mag is the product of the magnitudes of a and b\n    mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),\n    // mag &&.. short circuits if mag == 0\n    cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1\n\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec2 to zero\n *\n * @param {vec2} out the receiving vector\n * @returns {vec2} out\n */\n\nfunction vec2_zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nfunction vec2_str(a) {\n  return \"vec2(\" + a[0] + \", \" + a[1] + \")\";\n}\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction vec2_exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction vec2_equals(a, b) {\n  var a0 = a[0],\n    a1 = a[1];\n  var b0 = b[0],\n    b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\n * Alias for {@link vec2.length}\n * @function\n */\n\nvar vec2_len = (/* unused pure expression or super */ null && (vec2_length));\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\n\nvar vec2_sub = vec2_subtract;\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\n\nvar vec2_mul = (/* unused pure expression or super */ null && (vec2_multiply));\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\n\nvar vec2_div = (/* unused pure expression or super */ null && (vec2_divide));\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\n\nvar vec2_dist = (/* unused pure expression or super */ null && (vec2_distance));\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\n\nvar vec2_sqrDist = (/* unused pure expression or super */ null && (vec2_squaredDistance));\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\n\nvar vec2_sqrLen = (/* unused pure expression or super */ null && (vec2_squaredLength));\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nvar vec2_forEach = function () {\n  var vec = vec2_create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n    if (!stride) {\n      stride = 2;\n    }\n    if (!offset) {\n      offset = 0;\n    }\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n    return a;\n  };\n}();\n;// ./node_modules/gl-matrix/esm/vec3.js\n\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nfunction vec3_create() {\n  var out = new ARRAY_TYPE(3);\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nfunction vec3_clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction vec3_length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nfunction vec3_fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nfunction vec3_copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nfunction vec3_set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec3_add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec3_subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec3_multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec3_divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nfunction vec3_ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nfunction vec3_floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec3_min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec3_max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nfunction vec3_round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nfunction vec3_scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nfunction vec3_scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nfunction vec3_distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nfunction vec3_squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nfunction vec3_squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nfunction vec3_negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nfunction vec3_inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nfunction vec3_normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction vec3_dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec3_cross(out, a, b) {\n  var ax = a[0],\n    ay = a[1],\n    az = a[2];\n  var bx = b[0],\n    by = b[1],\n    bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nfunction vec3_lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nfunction hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nfunction bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nfunction vec3_random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nfunction vec3_transformMat4(out, a, m) {\n  var x = a[0],\n    y = a[1],\n    z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nfunction vec3_transformMat3(out, a, m) {\n  var x = a[0],\n    y = a[1],\n    z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nfunction vec3_transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n    qy = q[1],\n    qz = q[2],\n    qw = q[3];\n  var x = a[0],\n    y = a[1],\n    z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n    uvy = qz * x - qx * z,\n    uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n    uuvy = qz * uvx - qx * uvz,\n    uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nfunction vec3_rotateX(out, a, b, rad) {\n  var p = [],\n    r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nfunction vec3_rotateY(out, a, b, rad) {\n  var p = [],\n    r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nfunction vec3_rotateZ(out, a, b, rad) {\n  var p = [],\n    r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nfunction vec3_angle(a, b) {\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    bx = b[0],\n    by = b[1],\n    bz = b[2],\n    mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n    mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n    mag = mag1 * mag2,\n    cosine = mag && vec3_dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nfunction vec3_zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nfunction vec3_str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction vec3_exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction vec3_equals(a, b) {\n  var a0 = a[0],\n    a1 = a[1],\n    a2 = a[2];\n  var b0 = b[0],\n    b1 = b[1],\n    b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nvar vec3_sub = (/* unused pure expression or super */ null && (vec3_subtract));\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nvar vec3_mul = vec3_multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nvar vec3_div = (/* unused pure expression or super */ null && (vec3_divide));\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nvar vec3_dist = (/* unused pure expression or super */ null && (vec3_distance));\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nvar vec3_sqrDist = (/* unused pure expression or super */ null && (vec3_squaredDistance));\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nvar vec3_len = (/* unused pure expression or super */ null && (vec3_length));\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nvar vec3_sqrLen = (/* unused pure expression or super */ null && (vec3_squaredLength));\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nvar vec3_forEach = function () {\n  var vec = vec3_create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n    if (!stride) {\n      stride = 3;\n    }\n    if (!offset) {\n      offset = 0;\n    }\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n    return a;\n  };\n}();\n;// ./node_modules/@math.gl/web-mercator/dist/esm/assert.js\nfunction assert_assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || '@math.gl/web-mercator: assertion failed.');\n  }\n}\n;// ./node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js\n\n\n\n\n\nconst PI = Math.PI;\nconst PI_4 = PI / 4;\nconst DEGREES_TO_RADIANS = PI / 180;\nconst RADIANS_TO_DEGREES = 180 / PI;\nconst TILE_SIZE = 512;\nconst EARTH_CIRCUMFERENCE = 40.03e6;\nconst MAX_LATITUDE = 85.051129;\nconst DEFAULT_ALTITUDE = 1.5;\nfunction zoomToScale(zoom) {\n  return Math.pow(2, zoom);\n}\nfunction scaleToZoom(scale) {\n  return log2(scale);\n}\nfunction lngLatToWorld(lngLat) {\n  const [lng, lat] = lngLat;\n  assert_assert(Number.isFinite(lng));\n  assert_assert(Number.isFinite(lat) && lat >= -90 && lat <= 90, 'invalid latitude');\n  const lambda2 = lng * DEGREES_TO_RADIANS;\n  const phi2 = lat * DEGREES_TO_RADIANS;\n  const x = TILE_SIZE * (lambda2 + PI) / (2 * PI);\n  const y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);\n  return [x, y];\n}\nfunction worldToLngLat(xy) {\n  const [x, y] = xy;\n  const lambda2 = x / TILE_SIZE * (2 * PI) - PI;\n  const phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);\n  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];\n}\nfunction getMeterZoom(options) {\n  const {\n    latitude\n  } = options;\n  assert(Number.isFinite(latitude));\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;\n}\nfunction unitsPerMeter(latitude) {\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;\n}\nfunction getDistanceScales(options) {\n  const {\n    latitude,\n    longitude,\n    highPrecision = false\n  } = options;\n  assert_assert(Number.isFinite(latitude) && Number.isFinite(longitude));\n  const worldSize = TILE_SIZE;\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  const unitsPerDegreeX = worldSize / 360;\n  const unitsPerDegreeY = unitsPerDegreeX / latCosine;\n  const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;\n  const result = {\n    unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],\n    metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],\n    unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],\n    degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]\n  };\n  if (highPrecision) {\n    const latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;\n    const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;\n    const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;\n    const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;\n    result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];\n    result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];\n  }\n  return result;\n}\nfunction addMetersToLngLat(lngLatZ, xyz) {\n  const [longitude, latitude, z0] = lngLatZ;\n  const [x, y, z] = xyz;\n  const {\n    unitsPerMeter,\n    unitsPerMeter2\n  } = getDistanceScales({\n    longitude,\n    latitude,\n    highPrecision: true\n  });\n  const worldspace = lngLatToWorld(lngLatZ);\n  worldspace[0] += x * (unitsPerMeter[0] + unitsPerMeter2[0] * y);\n  worldspace[1] += y * (unitsPerMeter[1] + unitsPerMeter2[1] * y);\n  const newLngLat = worldToLngLat(worldspace);\n  const newZ = (z0 || 0) + (z || 0);\n  return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;\n}\nfunction getViewMatrix(options) {\n  const {\n    height,\n    pitch,\n    bearing,\n    altitude,\n    scale,\n    center\n  } = options;\n  const vm = createMat4();\n  translate(vm, vm, [0, 0, -altitude]);\n  rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);\n  rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);\n  const relativeScale = scale / height;\n  mat4_scale(vm, vm, [relativeScale, relativeScale, relativeScale]);\n  if (center) {\n    translate(vm, vm, vec3_negate([], center));\n  }\n  return vm;\n}\nfunction getProjectionParameters(options) {\n  const {\n    width,\n    height,\n    altitude,\n    pitch = 0,\n    offset,\n    center,\n    scale,\n    nearZMultiplier = 1,\n    farZMultiplier = 1\n  } = options;\n  let {\n    fovy = altitudeToFovy(DEFAULT_ALTITUDE)\n  } = options;\n  if (altitude !== undefined) {\n    fovy = altitudeToFovy(altitude);\n  }\n  const fovRadians = fovy * DEGREES_TO_RADIANS;\n  const pitchRadians = pitch * DEGREES_TO_RADIANS;\n  const focalDistance = fovyToAltitude(fovy);\n  let cameraToSeaLevelDistance = focalDistance;\n  if (center) {\n    cameraToSeaLevelDistance += center[2] * scale / Math.cos(pitchRadians) / height;\n  }\n  const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);\n  const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(clamp(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));\n  const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;\n  const horizonDistance = cameraToSeaLevelDistance * 10;\n  const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);\n  return {\n    fov: fovRadians,\n    aspect: width / height,\n    focalDistance,\n    near: nearZMultiplier,\n    far: farZ\n  };\n}\nfunction getProjectionMatrix(options) {\n  const {\n    fov,\n    aspect,\n    near,\n    far\n  } = getProjectionParameters(options);\n  const projectionMatrix = perspective([], fov, aspect, near, far);\n  return projectionMatrix;\n}\nfunction altitudeToFovy(altitude) {\n  return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES;\n}\nfunction fovyToAltitude(fovy) {\n  return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS);\n}\nfunction worldToPixels(xyz, pixelProjectionMatrix) {\n  const [x, y, z = 0] = xyz;\n  assert_assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));\n  return transformVector(pixelProjectionMatrix, [x, y, z, 1]);\n}\nfunction pixelsToWorld(xyz, pixelUnprojectionMatrix) {\n  let targetZ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const [x, y, z] = xyz;\n  assert_assert(Number.isFinite(x) && Number.isFinite(y), 'invalid pixel coordinate');\n  if (Number.isFinite(z)) {\n    const coord = transformVector(pixelUnprojectionMatrix, [x, y, z, 1]);\n    return coord;\n  }\n  const coord0 = transformVector(pixelUnprojectionMatrix, [x, y, 0, 1]);\n  const coord1 = transformVector(pixelUnprojectionMatrix, [x, y, 1, 1]);\n  const z0 = coord0[2];\n  const z1 = coord1[2];\n  const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);\n  return vec2_lerp([], coord0, coord1, t);\n}\n;// ./node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js\n\n\n\nfunction fitBounds(options) {\n  const {\n    width,\n    height,\n    bounds,\n    minExtent = 0,\n    maxZoom = 24,\n    offset = [0, 0]\n  } = options;\n  const [[west, south], [east, north]] = bounds;\n  const padding = getPaddingObject(options.padding);\n  const nw = lngLatToWorld([west, clamp(north, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const se = lngLatToWorld([east, clamp(south, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];\n  const targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];\n  assert_assert(targetSize[0] > 0 && targetSize[1] > 0);\n  const scaleX = targetSize[0] / size[0];\n  const scaleY = targetSize[1] / size[1];\n  const offsetX = (padding.right - padding.left) / 2 / scaleX;\n  const offsetY = (padding.top - padding.bottom) / 2 / scaleY;\n  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n  const centerLngLat = worldToLngLat(center);\n  const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));\n  assert_assert(Number.isFinite(zoom));\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom\n  };\n}\nfunction getPaddingObject() {\n  let padding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  if (typeof padding === 'number') {\n    return {\n      top: padding,\n      bottom: padding,\n      left: padding,\n      right: padding\n    };\n  }\n  assert_assert(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));\n  return padding;\n}\n;// ./node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js\n\n\n\nconst get_bounds_DEGREES_TO_RADIANS = Math.PI / 180;\nfunction getBounds(viewport) {\n  let z = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const {\n    width,\n    height,\n    unproject\n  } = viewport;\n  const unprojectOps = {\n    targetZ: z\n  };\n  const bottomLeft = unproject([0, height], unprojectOps);\n  const bottomRight = unproject([width, height], unprojectOps);\n  let topLeft;\n  let topRight;\n  const halfFov = viewport.fovy ? 0.5 * viewport.fovy * get_bounds_DEGREES_TO_RADIANS : Math.atan(0.5 / viewport.altitude);\n  const angleToGround = (90 - viewport.pitch) * get_bounds_DEGREES_TO_RADIANS;\n  if (halfFov > angleToGround - 0.01) {\n    topLeft = unprojectOnFarPlane(viewport, 0, z);\n    topRight = unprojectOnFarPlane(viewport, width, z);\n  } else {\n    topLeft = unproject([0, 0], unprojectOps);\n    topRight = unproject([width, 0], unprojectOps);\n  }\n  return [bottomLeft, bottomRight, topRight, topLeft];\n}\nfunction unprojectOnFarPlane(viewport, x, targetZ) {\n  const {\n    pixelUnprojectionMatrix\n  } = viewport;\n  const coord0 = transformVector(pixelUnprojectionMatrix, [x, 0, 1, 1]);\n  const coord1 = transformVector(pixelUnprojectionMatrix, [x, viewport.height, 1, 1]);\n  const z = targetZ * viewport.distanceScales.unitsPerMeter[2];\n  const t = (z - coord0[2]) / (coord1[2] - coord0[2]);\n  const coord = vec2_lerp([], coord0, coord1, t);\n  const result = worldToLngLat(coord);\n  result.push(targetZ);\n  return result;\n}\n;// ./node_modules/@math.gl/web-mercator/dist/esm/web-mercator-viewport.js\n\n\n\n\n\n\n\n\nclass WebMercatorViewport {\n  constructor() {\n    var _this = this;\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      width: 1,\n      height: 1\n    };\n    _defineProperty(this, \"latitude\", void 0);\n    _defineProperty(this, \"longitude\", void 0);\n    _defineProperty(this, \"zoom\", void 0);\n    _defineProperty(this, \"pitch\", void 0);\n    _defineProperty(this, \"bearing\", void 0);\n    _defineProperty(this, \"altitude\", void 0);\n    _defineProperty(this, \"fovy\", void 0);\n    _defineProperty(this, \"meterOffset\", void 0);\n    _defineProperty(this, \"center\", void 0);\n    _defineProperty(this, \"width\", void 0);\n    _defineProperty(this, \"height\", void 0);\n    _defineProperty(this, \"scale\", void 0);\n    _defineProperty(this, \"distanceScales\", void 0);\n    _defineProperty(this, \"viewMatrix\", void 0);\n    _defineProperty(this, \"projectionMatrix\", void 0);\n    _defineProperty(this, \"viewProjectionMatrix\", void 0);\n    _defineProperty(this, \"pixelProjectionMatrix\", void 0);\n    _defineProperty(this, \"pixelUnprojectionMatrix\", void 0);\n    _defineProperty(this, \"equals\", viewport => {\n      if (!(viewport instanceof WebMercatorViewport)) {\n        return false;\n      }\n      return viewport.width === this.width && viewport.height === this.height && mat4_equals(viewport.projectionMatrix, this.projectionMatrix) && mat4_equals(viewport.viewMatrix, this.viewMatrix);\n    });\n    _defineProperty(this, \"project\", function (lngLatZ) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        topLeft = true\n      } = options;\n      const worldPosition = _this.projectPosition(lngLatZ);\n      const coord = worldToPixels(worldPosition, _this.pixelProjectionMatrix);\n      const [x, y] = coord;\n      const y2 = topLeft ? y : _this.height - y;\n      return lngLatZ.length === 2 ? [x, y2] : [x, y2, coord[2]];\n    });\n    _defineProperty(this, \"unproject\", function (xyz) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        topLeft = true,\n        targetZ = undefined\n      } = options;\n      const [x, y, z] = xyz;\n      const y2 = topLeft ? y : _this.height - y;\n      const targetZWorld = targetZ && targetZ * _this.distanceScales.unitsPerMeter[2];\n      const coord = pixelsToWorld([x, y2, z], _this.pixelUnprojectionMatrix, targetZWorld);\n      const [X, Y, Z] = _this.unprojectPosition(coord);\n      if (Number.isFinite(z)) {\n        return [X, Y, Z];\n      }\n      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n    });\n    _defineProperty(this, \"projectPosition\", xyz => {\n      const [X, Y] = lngLatToWorld(xyz);\n      const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n      return [X, Y, Z];\n    });\n    _defineProperty(this, \"unprojectPosition\", xyz => {\n      const [X, Y] = worldToLngLat(xyz);\n      const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n      return [X, Y, Z];\n    });\n    let {\n      width,\n      height,\n      altitude = null,\n      fovy = null\n    } = props;\n    const {\n      latitude = 0,\n      longitude = 0,\n      zoom = 0,\n      pitch = 0,\n      bearing = 0,\n      position = null,\n      nearZMultiplier = 0.02,\n      farZMultiplier = 1.01\n    } = props;\n    width = width || 1;\n    height = height || 1;\n    if (fovy === null && altitude === null) {\n      altitude = DEFAULT_ALTITUDE;\n      fovy = altitudeToFovy(altitude);\n    } else if (fovy === null) {\n      fovy = altitudeToFovy(altitude);\n    } else if (altitude === null) {\n      altitude = fovyToAltitude(fovy);\n    }\n    const scale = zoomToScale(zoom);\n    altitude = Math.max(0.75, altitude);\n    const distanceScales = getDistanceScales({\n      longitude,\n      latitude\n    });\n    const center = lngLatToWorld([longitude, latitude]);\n    center.push(0);\n    if (position) {\n      vec3_add(center, center, vec3_mul([], position, distanceScales.unitsPerMeter));\n    }\n    this.projectionMatrix = getProjectionMatrix({\n      width,\n      height,\n      scale,\n      center,\n      pitch,\n      fovy,\n      nearZMultiplier,\n      farZMultiplier\n    });\n    this.viewMatrix = getViewMatrix({\n      height,\n      scale,\n      center,\n      pitch,\n      bearing,\n      altitude\n    });\n    this.width = width;\n    this.height = height;\n    this.scale = scale;\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.zoom = zoom;\n    this.pitch = pitch;\n    this.bearing = bearing;\n    this.altitude = altitude;\n    this.fovy = fovy;\n    this.center = center;\n    this.meterOffset = position || [0, 0, 0];\n    this.distanceScales = distanceScales;\n    this._initMatrices();\n    Object.freeze(this);\n  }\n  _initMatrices() {\n    const {\n      width,\n      height,\n      projectionMatrix,\n      viewMatrix\n    } = this;\n    const vpm = createMat4();\n    mat4_multiply(vpm, vpm, projectionMatrix);\n    mat4_multiply(vpm, vpm, viewMatrix);\n    this.viewProjectionMatrix = vpm;\n    const m = createMat4();\n    mat4_scale(m, m, [width / 2, -height / 2, 1]);\n    translate(m, m, [1, -1, 0]);\n    mat4_multiply(m, m, vpm);\n    const mInverse = invert(createMat4(), m);\n    if (!mInverse) {\n      throw new Error('Pixel project matrix not invertible');\n    }\n    this.pixelProjectionMatrix = m;\n    this.pixelUnprojectionMatrix = mInverse;\n  }\n  projectFlat(lngLat) {\n    return lngLatToWorld(lngLat);\n  }\n  unprojectFlat(xy) {\n    return worldToLngLat(xy);\n  }\n  getMapCenterByLngLatPosition(_ref) {\n    let {\n      lngLat,\n      pos\n    } = _ref;\n    const fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);\n    const toLocation = lngLatToWorld(lngLat);\n    const translate = vec2_add([], toLocation, vec2_negate([], fromLocation));\n    const newCenter = vec2_add([], this.center, translate);\n    return worldToLngLat(newCenter);\n  }\n  fitBounds(bounds) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      width,\n      height\n    } = this;\n    const {\n      longitude,\n      latitude,\n      zoom\n    } = fitBounds(Object.assign({\n      width,\n      height,\n      bounds\n    }, options));\n    return new WebMercatorViewport({\n      width,\n      height,\n      longitude,\n      latitude,\n      zoom\n    });\n  }\n  getBounds(options) {\n    const corners = this.getBoundingRegion(options);\n    const west = Math.min(...corners.map(p => p[0]));\n    const east = Math.max(...corners.map(p => p[0]));\n    const south = Math.min(...corners.map(p => p[1]));\n    const north = Math.max(...corners.map(p => p[1]));\n    return [[west, south], [east, north]];\n  }\n  getBoundingRegion() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return getBounds(this, options.z || 0);\n  }\n  getLocationAtPoint(_ref2) {\n    let {\n      lngLat,\n      pos\n    } = _ref2;\n    return this.getMapCenterByLngLatPosition({\n      lngLat,\n      pos\n    });\n  }\n}\n;// ./node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js\n\n\nconst normalize_viewport_props_TILE_SIZE = 512;\nfunction normalizeViewportProps(props) {\n  const {\n    width,\n    height,\n    pitch = 0\n  } = props;\n  let {\n    longitude,\n    latitude,\n    zoom,\n    bearing = 0\n  } = props;\n  if (longitude < -180 || longitude > 180) {\n    longitude = mod(longitude + 180, 360) - 180;\n  }\n  if (bearing < -180 || bearing > 180) {\n    bearing = mod(bearing + 180, 360) - 180;\n  }\n  const minZoom = log2(height / normalize_viewport_props_TILE_SIZE);\n  if (zoom <= minZoom) {\n    zoom = minZoom;\n    latitude = 0;\n  } else {\n    const halfHeightPixels = height / 2 / Math.pow(2, zoom);\n    const minLatitude = worldToLngLat([0, halfHeightPixels])[1];\n    if (latitude < minLatitude) {\n      latitude = minLatitude;\n    } else {\n      const maxLatitude = worldToLngLat([0, normalize_viewport_props_TILE_SIZE - halfHeightPixels])[1];\n      if (latitude > maxLatitude) {\n        latitude = maxLatitude;\n      }\n    }\n  }\n  return {\n    width,\n    height,\n    longitude,\n    latitude,\n    zoom,\n    pitch,\n    bearing\n  };\n}\n;// ./node_modules/@math.gl/web-mercator/dist/esm/fly-to-viewport.js\n\n\n\nconst fly_to_viewport_EPSILON = 0.01;\nconst VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];\nconst DEFAULT_OPTS = {\n  curve: 1.414,\n  speed: 1.2\n};\nfunction flyToViewport(startProps, endProps, t, options) {\n  const {\n    startZoom,\n    startCenterXY,\n    uDelta,\n    w0,\n    u1,\n    S,\n    rho,\n    rho2,\n    r0\n  } = getFlyToTransitionParams(startProps, endProps, options);\n  if (u1 < fly_to_viewport_EPSILON) {\n    const viewport = {};\n    for (const key of VIEWPORT_TRANSITION_PROPS) {\n      const startValue = startProps[key];\n      const endValue = endProps[key];\n      viewport[key] = math_utils_lerp(startValue, endValue, t);\n    }\n    return viewport;\n  }\n  const s = t * S;\n  const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n  const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;\n  const scaleIncrement = 1 / w;\n  const newZoom = startZoom + scaleToZoom(scaleIncrement);\n  const newCenterWorld = vec2_scale([], uDelta, u);\n  vec2_add(newCenterWorld, newCenterWorld, startCenterXY);\n  const newCenter = worldToLngLat(newCenterWorld);\n  return {\n    longitude: newCenter[0],\n    latitude: newCenter[1],\n    zoom: newZoom\n  };\n}\nfunction getFlyToDuration(startProps, endProps, options) {\n  const opts = {\n    ...DEFAULT_OPTS,\n    ...options\n  };\n  const {\n    screenSpeed,\n    speed,\n    maxDuration\n  } = opts;\n  const {\n    S,\n    rho\n  } = getFlyToTransitionParams(startProps, endProps, opts);\n  const length = 1000 * S;\n  let duration;\n  if (Number.isFinite(screenSpeed)) {\n    duration = length / (screenSpeed / rho);\n  } else {\n    duration = length / speed;\n  }\n  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;\n}\nfunction getFlyToTransitionParams(startProps, endProps, opts) {\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  const rho = opts.curve;\n  const startZoom = startProps.zoom;\n  const startCenter = [startProps.longitude, startProps.latitude];\n  const startScale = zoomToScale(startZoom);\n  const endZoom = endProps.zoom;\n  const endCenter = [endProps.longitude, endProps.latitude];\n  const scale = zoomToScale(endZoom - startZoom);\n  const startCenterXY = lngLatToWorld(startCenter);\n  const endCenterXY = lngLatToWorld(endCenter);\n  const uDelta = vec2_sub([], endCenterXY, startCenterXY);\n  const w0 = Math.max(startProps.width, startProps.height);\n  const w1 = w0 / scale;\n  const u1 = vec2_length(uDelta) * startScale;\n  const _u1 = Math.max(u1, fly_to_viewport_EPSILON);\n  const rho2 = rho * rho;\n  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);\n  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);\n  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  const S = (r1 - r0) / rho;\n  return {\n    startZoom,\n    startCenterXY,\n    uDelta,\n    w0,\n    u1,\n    S,\n    rho,\n    rho2,\n    r0,\n    r1\n  };\n}\n;// ./node_modules/@math.gl/web-mercator/dist/esm/index.js\n\n\n\n\n\n\n\n;// ./node_modules/viewport-mercator-project/module.js\n\n\n;// ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\n/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\n/* eslint-disable require-jsdoc, valid-jsdoc */\nvar MapShim = function () {\n  if (typeof Map !== 'undefined') {\n    return Map;\n  }\n  /**\r\n   * Returns index in provided array that matches the specified key.\r\n   *\r\n   * @param {Array<Array>} arr\r\n   * @param {*} key\r\n   * @returns {number}\r\n   */\n  function getIndex(arr, key) {\n    var result = -1;\n    arr.some(function (entry, index) {\n      if (entry[0] === key) {\n        result = index;\n        return true;\n      }\n      return false;\n    });\n    return result;\n  }\n  return /** @class */function () {\n    function class_1() {\n      this.__entries__ = [];\n    }\n    Object.defineProperty(class_1.prototype, \"size\", {\n      /**\r\n       * @returns {boolean}\r\n       */\n      get: function () {\n        return this.__entries__.length;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    /**\r\n     * @param {*} key\r\n     * @returns {*}\r\n     */\n    class_1.prototype.get = function (key) {\n      var index = getIndex(this.__entries__, key);\n      var entry = this.__entries__[index];\n      return entry && entry[1];\n    };\n    /**\r\n     * @param {*} key\r\n     * @param {*} value\r\n     * @returns {void}\r\n     */\n    class_1.prototype.set = function (key, value) {\n      var index = getIndex(this.__entries__, key);\n      if (~index) {\n        this.__entries__[index][1] = value;\n      } else {\n        this.__entries__.push([key, value]);\n      }\n    };\n    /**\r\n     * @param {*} key\r\n     * @returns {void}\r\n     */\n    class_1.prototype.delete = function (key) {\n      var entries = this.__entries__;\n      var index = getIndex(entries, key);\n      if (~index) {\n        entries.splice(index, 1);\n      }\n    };\n    /**\r\n     * @param {*} key\r\n     * @returns {void}\r\n     */\n    class_1.prototype.has = function (key) {\n      return !!~getIndex(this.__entries__, key);\n    };\n    /**\r\n     * @returns {void}\r\n     */\n    class_1.prototype.clear = function () {\n      this.__entries__.splice(0);\n    };\n    /**\r\n     * @param {Function} callback\r\n     * @param {*} [ctx=null]\r\n     * @returns {void}\r\n     */\n    class_1.prototype.forEach = function (callback, ctx) {\n      if (ctx === void 0) {\n        ctx = null;\n      }\n      for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\n        var entry = _a[_i];\n        callback.call(ctx, entry[1], entry[0]);\n      }\n    };\n    return class_1;\n  }();\n}();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\nvar global$1 = function () {\n  if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.Math === Math) {\n    return __webpack_require__.g;\n  }\n  if (typeof self !== 'undefined' && self.Math === Math) {\n    return self;\n  }\n  if (typeof window !== 'undefined' && window.Math === Math) {\n    return window;\n  }\n  // eslint-disable-next-line no-new-func\n  return Function('return this')();\n}();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\nvar requestAnimationFrame$1 = function () {\n  if (typeof requestAnimationFrame === 'function') {\n    // It's required to use a bounded function because IE sometimes throws\n    // an \"Invalid calling object\" error if rAF is invoked without the global\n    // object on the left hand side.\n    return requestAnimationFrame.bind(global$1);\n  }\n  return function (callback) {\n    return setTimeout(function () {\n      return callback(Date.now());\n    }, 1000 / 60);\n  };\n}();\n\n// Defines minimum timeout before adding a trailing call.\nvar trailingTimeout = 2;\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\nfunction throttle(callback, delay) {\n  var leadingCall = false,\n    trailingCall = false,\n    lastCallTime = 0;\n  /**\r\n   * Invokes the original callback function and schedules new invocation if\r\n   * the \"proxy\" was called during current request.\r\n   *\r\n   * @returns {void}\r\n   */\n  function resolvePending() {\n    if (leadingCall) {\n      leadingCall = false;\n      callback();\n    }\n    if (trailingCall) {\n      proxy();\n    }\n  }\n  /**\r\n   * Callback invoked after the specified delay. It will further postpone\r\n   * invocation of the original function delegating it to the\r\n   * requestAnimationFrame.\r\n   *\r\n   * @returns {void}\r\n   */\n  function timeoutCallback() {\n    requestAnimationFrame$1(resolvePending);\n  }\n  /**\r\n   * Schedules invocation of the original function.\r\n   *\r\n   * @returns {void}\r\n   */\n  function proxy() {\n    var timeStamp = Date.now();\n    if (leadingCall) {\n      // Reject immediately following calls.\n      if (timeStamp - lastCallTime < trailingTimeout) {\n        return;\n      }\n      // Schedule new call to be in invoked when the pending one is resolved.\n      // This is important for \"transitions\" which never actually start\n      // immediately so there is a chance that we might miss one if change\n      // happens amids the pending invocation.\n      trailingCall = true;\n    } else {\n      leadingCall = true;\n      trailingCall = false;\n      setTimeout(timeoutCallback, delay);\n    }\n    lastCallTime = timeStamp;\n  }\n  return proxy;\n}\n\n// Minimum delay before invoking the update of observers.\nvar REFRESH_DELAY = 20;\n// A list of substrings of CSS properties used to find transition events that\n// might affect dimensions of observed elements.\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\n// Check if MutationObserver is available.\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\nvar ResizeObserverController = /** @class */function () {\n  /**\r\n   * Creates a new instance of ResizeObserverController.\r\n   *\r\n   * @private\r\n   */\n  function ResizeObserverController() {\n    /**\r\n     * Indicates whether DOM listeners have been added.\r\n     *\r\n     * @private {boolean}\r\n     */\n    this.connected_ = false;\n    /**\r\n     * Tells that controller has subscribed for Mutation Events.\r\n     *\r\n     * @private {boolean}\r\n     */\n    this.mutationEventsAdded_ = false;\n    /**\r\n     * Keeps reference to the instance of MutationObserver.\r\n     *\r\n     * @private {MutationObserver}\r\n     */\n    this.mutationsObserver_ = null;\n    /**\r\n     * A list of connected observers.\r\n     *\r\n     * @private {Array<ResizeObserverSPI>}\r\n     */\n    this.observers_ = [];\n    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\n    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\n  }\n  /**\r\n   * Adds observer to observers list.\r\n   *\r\n   * @param {ResizeObserverSPI} observer - Observer to be added.\r\n   * @returns {void}\r\n   */\n  ResizeObserverController.prototype.addObserver = function (observer) {\n    if (!~this.observers_.indexOf(observer)) {\n      this.observers_.push(observer);\n    }\n    // Add listeners if they haven't been added yet.\n    if (!this.connected_) {\n      this.connect_();\n    }\n  };\n  /**\r\n   * Removes observer from observers list.\r\n   *\r\n   * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n   * @returns {void}\r\n   */\n  ResizeObserverController.prototype.removeObserver = function (observer) {\n    var observers = this.observers_;\n    var index = observers.indexOf(observer);\n    // Remove observer if it's present in registry.\n    if (~index) {\n      observers.splice(index, 1);\n    }\n    // Remove listeners if controller has no connected observers.\n    if (!observers.length && this.connected_) {\n      this.disconnect_();\n    }\n  };\n  /**\r\n   * Invokes the update of observers. It will continue running updates insofar\r\n   * it detects changes.\r\n   *\r\n   * @returns {void}\r\n   */\n  ResizeObserverController.prototype.refresh = function () {\n    var changesDetected = this.updateObservers_();\n    // Continue running updates if changes have been detected as there might\n    // be future ones caused by CSS transitions.\n    if (changesDetected) {\n      this.refresh();\n    }\n  };\n  /**\r\n   * Updates every observer from observers list and notifies them of queued\r\n   * entries.\r\n   *\r\n   * @private\r\n   * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n   *      dimensions of it's elements.\r\n   */\n  ResizeObserverController.prototype.updateObservers_ = function () {\n    // Collect observers that have active observations.\n    var activeObservers = this.observers_.filter(function (observer) {\n      return observer.gatherActive(), observer.hasActive();\n    });\n    // Deliver notifications in a separate cycle in order to avoid any\n    // collisions between observers, e.g. when multiple instances of\n    // ResizeObserver are tracking the same element and the callback of one\n    // of them changes content dimensions of the observed target. Sometimes\n    // this may result in notifications being blocked for the rest of observers.\n    activeObservers.forEach(function (observer) {\n      return observer.broadcastActive();\n    });\n    return activeObservers.length > 0;\n  };\n  /**\r\n   * Initializes DOM listeners.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\n  ResizeObserverController.prototype.connect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already added.\n    if (!isBrowser || this.connected_) {\n      return;\n    }\n    // Subscription to the \"Transitionend\" event is used as a workaround for\n    // delayed transitions. This way it's possible to capture at least the\n    // final state of an element.\n    document.addEventListener('transitionend', this.onTransitionEnd_);\n    window.addEventListener('resize', this.refresh);\n    if (mutationObserverSupported) {\n      this.mutationsObserver_ = new MutationObserver(this.refresh);\n      this.mutationsObserver_.observe(document, {\n        attributes: true,\n        childList: true,\n        characterData: true,\n        subtree: true\n      });\n    } else {\n      document.addEventListener('DOMSubtreeModified', this.refresh);\n      this.mutationEventsAdded_ = true;\n    }\n    this.connected_ = true;\n  };\n  /**\r\n   * Removes DOM listeners.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\n  ResizeObserverController.prototype.disconnect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already removed.\n    if (!isBrowser || !this.connected_) {\n      return;\n    }\n    document.removeEventListener('transitionend', this.onTransitionEnd_);\n    window.removeEventListener('resize', this.refresh);\n    if (this.mutationsObserver_) {\n      this.mutationsObserver_.disconnect();\n    }\n    if (this.mutationEventsAdded_) {\n      document.removeEventListener('DOMSubtreeModified', this.refresh);\n    }\n    this.mutationsObserver_ = null;\n    this.mutationEventsAdded_ = false;\n    this.connected_ = false;\n  };\n  /**\r\n   * \"Transitionend\" event handler.\r\n   *\r\n   * @private\r\n   * @param {TransitionEvent} event\r\n   * @returns {void}\r\n   */\n  ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\n    var _b = _a.propertyName,\n      propertyName = _b === void 0 ? '' : _b;\n    // Detect whether transition may affect dimensions of an element.\n    var isReflowProperty = transitionKeys.some(function (key) {\n      return !!~propertyName.indexOf(key);\n    });\n    if (isReflowProperty) {\n      this.refresh();\n    }\n  };\n  /**\r\n   * Returns instance of the ResizeObserverController.\r\n   *\r\n   * @returns {ResizeObserverController}\r\n   */\n  ResizeObserverController.getInstance = function () {\n    if (!this.instance_) {\n      this.instance_ = new ResizeObserverController();\n    }\n    return this.instance_;\n  };\n  /**\r\n   * Holds reference to the controller's instance.\r\n   *\r\n   * @private {ResizeObserverController}\r\n   */\n  ResizeObserverController.instance_ = null;\n  return ResizeObserverController;\n}();\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\nvar defineConfigurable = function (target, props) {\n  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\n    var key = _a[_i];\n    Object.defineProperty(target, key, {\n      value: props[key],\n      enumerable: false,\n      writable: false,\n      configurable: true\n    });\n  }\n  return target;\n};\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\nvar getWindowOf = function (target) {\n  // Assume that the element is an instance of Node, which means that it\n  // has the \"ownerDocument\" property from which we can retrieve a\n  // corresponding global object.\n  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\n  // Return the local global object if it's not possible extract one from\n  // provided element.\n  return ownerGlobal || global$1;\n};\n\n// Placeholder of an empty content rectangle.\nvar emptyRect = createRectInit(0, 0, 0, 0);\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\nfunction toFloat(value) {\n  return parseFloat(value) || 0;\n}\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\nfunction getBordersSize(styles) {\n  var positions = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    positions[_i - 1] = arguments[_i];\n  }\n  return positions.reduce(function (size, position) {\n    var value = styles['border-' + position + '-width'];\n    return size + toFloat(value);\n  }, 0);\n}\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\nfunction getPaddings(styles) {\n  var positions = ['top', 'right', 'bottom', 'left'];\n  var paddings = {};\n  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\n    var position = positions_1[_i];\n    var value = styles['padding-' + position];\n    paddings[position] = toFloat(value);\n  }\n  return paddings;\n}\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\nfunction getSVGContentRect(target) {\n  var bbox = target.getBBox();\n  return createRectInit(0, 0, bbox.width, bbox.height);\n}\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\nfunction getHTMLElementContentRect(target) {\n  // Client width & height properties can't be\n  // used exclusively as they provide rounded values.\n  var clientWidth = target.clientWidth,\n    clientHeight = target.clientHeight;\n  // By this condition we can catch all non-replaced inline, hidden and\n  // detached elements. Though elements with width & height properties less\n  // than 0.5 will be discarded as well.\n  //\n  // Without it we would need to implement separate methods for each of\n  // those cases and it's not possible to perform a precise and performance\n  // effective test for hidden elements. E.g. even jQuery's ':visible' filter\n  // gives wrong results for elements with width & height less than 0.5.\n  if (!clientWidth && !clientHeight) {\n    return emptyRect;\n  }\n  var styles = getWindowOf(target).getComputedStyle(target);\n  var paddings = getPaddings(styles);\n  var horizPad = paddings.left + paddings.right;\n  var vertPad = paddings.top + paddings.bottom;\n  // Computed styles of width & height are being used because they are the\n  // only dimensions available to JS that contain non-rounded values. It could\n  // be possible to utilize the getBoundingClientRect if only it's data wasn't\n  // affected by CSS transformations let alone paddings, borders and scroll bars.\n  var width = toFloat(styles.width),\n    height = toFloat(styles.height);\n  // Width & height include paddings and borders when the 'border-box' box\n  // model is applied (except for IE).\n  if (styles.boxSizing === 'border-box') {\n    // Following conditions are required to handle Internet Explorer which\n    // doesn't include paddings and borders to computed CSS dimensions.\n    //\n    // We can say that if CSS dimensions + paddings are equal to the \"client\"\n    // properties then it's either IE, and thus we don't need to subtract\n    // anything, or an element merely doesn't have paddings/borders styles.\n    if (Math.round(width + horizPad) !== clientWidth) {\n      width -= getBordersSize(styles, 'left', 'right') + horizPad;\n    }\n    if (Math.round(height + vertPad) !== clientHeight) {\n      height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\n    }\n  }\n  // Following steps can't be applied to the document's root element as its\n  // client[Width/Height] properties represent viewport area of the window.\n  // Besides, it's as well not necessary as the <html> itself neither has\n  // rendered scroll bars nor it can be clipped.\n  if (!isDocumentElement(target)) {\n    // In some browsers (only in Firefox, actually) CSS width & height\n    // include scroll bars size which can be removed at this step as scroll\n    // bars are the only difference between rounded dimensions + paddings\n    // and \"client\" properties, though that is not always true in Chrome.\n    var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n    var horizScrollbar = Math.round(height + vertPad) - clientHeight;\n    // Chrome has a rather weird rounding of \"client\" properties.\n    // E.g. for an element with content width of 314.2px it sometimes gives\n    // the client width of 315px and for the width of 314.7px it may give\n    // 314px. And it doesn't happen all the time. So just ignore this delta\n    // as a non-relevant.\n    if (Math.abs(vertScrollbar) !== 1) {\n      width -= vertScrollbar;\n    }\n    if (Math.abs(horizScrollbar) !== 1) {\n      height -= horizScrollbar;\n    }\n  }\n  return createRectInit(paddings.left, paddings.top, width, height);\n}\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\nvar isSVGGraphicsElement = function () {\n  // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\n  // interface.\n  if (typeof SVGGraphicsElement !== 'undefined') {\n    return function (target) {\n      return target instanceof getWindowOf(target).SVGGraphicsElement;\n    };\n  }\n  // If it's so, then check that element is at least an instance of the\n  // SVGElement and that it has the \"getBBox\" method.\n  // eslint-disable-next-line no-extra-parens\n  return function (target) {\n    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';\n  };\n}();\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\nfunction isDocumentElement(target) {\n  return target === getWindowOf(target).document.documentElement;\n}\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\nfunction getContentRect(target) {\n  if (!isBrowser) {\n    return emptyRect;\n  }\n  if (isSVGGraphicsElement(target)) {\n    return getSVGContentRect(target);\n  }\n  return getHTMLElementContentRect(target);\n}\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\nfunction createReadOnlyRect(_a) {\n  var x = _a.x,\n    y = _a.y,\n    width = _a.width,\n    height = _a.height;\n  // If DOMRectReadOnly is available use it as a prototype for the rectangle.\n  var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\n  var rect = Object.create(Constr.prototype);\n  // Rectangle's properties are not writable and non-enumerable.\n  defineConfigurable(rect, {\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    top: y,\n    right: x + width,\n    bottom: height + y,\n    left: x\n  });\n  return rect;\n}\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\nfunction createRectInit(x, y, width, height) {\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height\n  };\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\nvar ResizeObservation = /** @class */function () {\n  /**\r\n   * Creates an instance of ResizeObservation.\r\n   *\r\n   * @param {Element} target - Element to be observed.\r\n   */\n  function ResizeObservation(target) {\n    /**\r\n     * Broadcasted width of content rectangle.\r\n     *\r\n     * @type {number}\r\n     */\n    this.broadcastWidth = 0;\n    /**\r\n     * Broadcasted height of content rectangle.\r\n     *\r\n     * @type {number}\r\n     */\n    this.broadcastHeight = 0;\n    /**\r\n     * Reference to the last observed content rectangle.\r\n     *\r\n     * @private {DOMRectInit}\r\n     */\n    this.contentRect_ = createRectInit(0, 0, 0, 0);\n    this.target = target;\n  }\n  /**\r\n   * Updates content rectangle and tells whether it's width or height properties\r\n   * have changed since the last broadcast.\r\n   *\r\n   * @returns {boolean}\r\n   */\n  ResizeObservation.prototype.isActive = function () {\n    var rect = getContentRect(this.target);\n    this.contentRect_ = rect;\n    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\n  };\n  /**\r\n   * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n   * from the corresponding properties of the last observed content rectangle.\r\n   *\r\n   * @returns {DOMRectInit} Last observed content rectangle.\r\n   */\n  ResizeObservation.prototype.broadcastRect = function () {\n    var rect = this.contentRect_;\n    this.broadcastWidth = rect.width;\n    this.broadcastHeight = rect.height;\n    return rect;\n  };\n  return ResizeObservation;\n}();\nvar ResizeObserverEntry = /** @class */function () {\n  /**\r\n   * Creates an instance of ResizeObserverEntry.\r\n   *\r\n   * @param {Element} target - Element that is being observed.\r\n   * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n   */\n  function ResizeObserverEntry(target, rectInit) {\n    var contentRect = createReadOnlyRect(rectInit);\n    // According to the specification following properties are not writable\n    // and are also not enumerable in the native implementation.\n    //\n    // Property accessors are not being used as they'd require to define a\n    // private WeakMap storage which may cause memory leaks in browsers that\n    // don't support this type of collections.\n    defineConfigurable(this, {\n      target: target,\n      contentRect: contentRect\n    });\n  }\n  return ResizeObserverEntry;\n}();\nvar ResizeObserverSPI = /** @class */function () {\n  /**\r\n   * Creates a new instance of ResizeObserver.\r\n   *\r\n   * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n   *      when one of the observed elements changes it's content dimensions.\r\n   * @param {ResizeObserverController} controller - Controller instance which\r\n   *      is responsible for the updates of observer.\r\n   * @param {ResizeObserver} callbackCtx - Reference to the public\r\n   *      ResizeObserver instance which will be passed to callback function.\r\n   */\n  function ResizeObserverSPI(callback, controller, callbackCtx) {\n    /**\r\n     * Collection of resize observations that have detected changes in dimensions\r\n     * of elements.\r\n     *\r\n     * @private {Array<ResizeObservation>}\r\n     */\n    this.activeObservations_ = [];\n    /**\r\n     * Registry of the ResizeObservation instances.\r\n     *\r\n     * @private {Map<Element, ResizeObservation>}\r\n     */\n    this.observations_ = new MapShim();\n    if (typeof callback !== 'function') {\n      throw new TypeError('The callback provided as parameter 1 is not a function.');\n    }\n    this.callback_ = callback;\n    this.controller_ = controller;\n    this.callbackCtx_ = callbackCtx;\n  }\n  /**\r\n   * Starts observing provided element.\r\n   *\r\n   * @param {Element} target - Element to be observed.\r\n   * @returns {void}\r\n   */\n  ResizeObserverSPI.prototype.observe = function (target) {\n    if (!arguments.length) {\n      throw new TypeError('1 argument required, but only 0 present.');\n    }\n    // Do nothing if current environment doesn't have the Element interface.\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n      return;\n    }\n    if (!(target instanceof getWindowOf(target).Element)) {\n      throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n    var observations = this.observations_;\n    // Do nothing if element is already being observed.\n    if (observations.has(target)) {\n      return;\n    }\n    observations.set(target, new ResizeObservation(target));\n    this.controller_.addObserver(this);\n    // Force the update of observations.\n    this.controller_.refresh();\n  };\n  /**\r\n   * Stops observing provided element.\r\n   *\r\n   * @param {Element} target - Element to stop observing.\r\n   * @returns {void}\r\n   */\n  ResizeObserverSPI.prototype.unobserve = function (target) {\n    if (!arguments.length) {\n      throw new TypeError('1 argument required, but only 0 present.');\n    }\n    // Do nothing if current environment doesn't have the Element interface.\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n      return;\n    }\n    if (!(target instanceof getWindowOf(target).Element)) {\n      throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n    var observations = this.observations_;\n    // Do nothing if element is not being observed.\n    if (!observations.has(target)) {\n      return;\n    }\n    observations.delete(target);\n    if (!observations.size) {\n      this.controller_.removeObserver(this);\n    }\n  };\n  /**\r\n   * Stops observing all elements.\r\n   *\r\n   * @returns {void}\r\n   */\n  ResizeObserverSPI.prototype.disconnect = function () {\n    this.clearActive();\n    this.observations_.clear();\n    this.controller_.removeObserver(this);\n  };\n  /**\r\n   * Collects observation instances the associated element of which has changed\r\n   * it's content rectangle.\r\n   *\r\n   * @returns {void}\r\n   */\n  ResizeObserverSPI.prototype.gatherActive = function () {\n    var _this = this;\n    this.clearActive();\n    this.observations_.forEach(function (observation) {\n      if (observation.isActive()) {\n        _this.activeObservations_.push(observation);\n      }\n    });\n  };\n  /**\r\n   * Invokes initial callback function with a list of ResizeObserverEntry\r\n   * instances collected from active resize observations.\r\n   *\r\n   * @returns {void}\r\n   */\n  ResizeObserverSPI.prototype.broadcastActive = function () {\n    // Do nothing if observer doesn't have active observations.\n    if (!this.hasActive()) {\n      return;\n    }\n    var ctx = this.callbackCtx_;\n    // Create ResizeObserverEntry instance for every active observation.\n    var entries = this.activeObservations_.map(function (observation) {\n      return new ResizeObserverEntry(observation.target, observation.broadcastRect());\n    });\n    this.callback_.call(ctx, entries, ctx);\n    this.clearActive();\n  };\n  /**\r\n   * Clears the collection of active observations.\r\n   *\r\n   * @returns {void}\r\n   */\n  ResizeObserverSPI.prototype.clearActive = function () {\n    this.activeObservations_.splice(0);\n  };\n  /**\r\n   * Tells whether observer has active observations.\r\n   *\r\n   * @returns {boolean}\r\n   */\n  ResizeObserverSPI.prototype.hasActive = function () {\n    return this.activeObservations_.length > 0;\n  };\n  return ResizeObserverSPI;\n}();\n\n// Registry of internal observers. If WeakMap is not available use current shim\n// for the Map collection as it has all required methods and because WeakMap\n// can't be fully polyfilled anyway.\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\nvar ResizeObserver = /** @class */function () {\n  /**\r\n   * Creates a new instance of ResizeObserver.\r\n   *\r\n   * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n   *      dimensions of the observed elements change.\r\n   */\n  function ResizeObserver(callback) {\n    if (!(this instanceof ResizeObserver)) {\n      throw new TypeError('Cannot call a class as a function.');\n    }\n    if (!arguments.length) {\n      throw new TypeError('1 argument required, but only 0 present.');\n    }\n    var controller = ResizeObserverController.getInstance();\n    var observer = new ResizeObserverSPI(callback, controller, this);\n    observers.set(this, observer);\n  }\n  return ResizeObserver;\n}();\n// Expose public methods of ResizeObserver.\n['observe', 'unobserve', 'disconnect'].forEach(function (method) {\n  ResizeObserver.prototype[method] = function () {\n    var _a;\n    return (_a = observers.get(this))[method].apply(_a, arguments);\n  };\n});\nvar index = function () {\n  // Export existing implementation if available.\n  if (typeof global$1.ResizeObserver !== 'undefined') {\n    return global$1.ResizeObserver;\n  }\n  return ResizeObserver;\n}();\n/* harmony default export */ var ResizeObserver_es = (index);\n;// ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/createClass.js\n\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\n\n;// ./node_modules/react-map-gl/dist/esm/utils/globals.js\nvar window_ = typeof window !== 'undefined' ? window : __webpack_require__.g;\nvar global_ = typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : window;\nvar document_ = typeof document !== 'undefined' ? document : {};\n\n;// ./node_modules/react-map-gl/dist/esm/utils/style-utils.js\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar refProps = ['type', 'source', 'source-layer', 'minzoom', 'maxzoom', 'filter', 'layout'];\nfunction normalizeStyle(style) {\n  if (!style) {\n    return null;\n  }\n  if (typeof style === 'string') {\n    return style;\n  }\n  if (style.toJS) {\n    style = style.toJS();\n  }\n  var layerIndex = {};\n  var _iterator = _createForOfIteratorHelper(style.layers),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var layer = _step.value;\n      layerIndex[layer.id] = layer;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var layers = style.layers.map(function (layer) {\n    var layerRef = layerIndex[layer.ref];\n    var normalizedLayer = null;\n    if ('interactive' in layer) {\n      normalizedLayer = _objectSpread({}, layer);\n      delete normalizedLayer.interactive;\n    }\n    if (layerRef) {\n      normalizedLayer = normalizedLayer || _objectSpread({}, layer);\n      delete normalizedLayer.ref;\n      var _iterator2 = _createForOfIteratorHelper(refProps),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var propName = _step2.value;\n          if (propName in layerRef) {\n            normalizedLayer[propName] = layerRef[propName];\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    return normalizedLayer || layer;\n  });\n  return _objectSpread(_objectSpread({}, style), {}, {\n    layers: layers\n  });\n}\n;// ./node_modules/react-map-gl/dist/esm/mapbox/mapbox.js\n\n\n\n\n\n\nfunction noop() {}\nfunction defaultOnError(event) {\n  if (event) {\n    console.error(event.error);\n  }\n}\nvar propTypes = {\n  container: prop_types.object,\n  gl: prop_types.object,\n  mapboxApiAccessToken: prop_types.string,\n  mapboxApiUrl: prop_types.string,\n  attributionControl: prop_types.bool,\n  preserveDrawingBuffer: prop_types.bool,\n  reuseMaps: prop_types.bool,\n  transformRequest: prop_types.func,\n  mapOptions: prop_types.object,\n  mapStyle: prop_types.oneOfType([prop_types.string, prop_types.object]),\n  preventStyleDiffing: prop_types.bool,\n  visible: prop_types.bool,\n  asyncRender: prop_types.bool,\n  onLoad: prop_types.func,\n  onError: prop_types.func,\n  width: prop_types.number,\n  height: prop_types.number,\n  viewState: prop_types.object,\n  longitude: prop_types.number,\n  latitude: prop_types.number,\n  zoom: prop_types.number,\n  bearing: prop_types.number,\n  pitch: prop_types.number,\n  altitude: prop_types.number\n};\nvar defaultProps = {\n  container: document_.body,\n  mapboxApiAccessToken: getAccessToken(),\n  mapboxApiUrl: 'https://api.mapbox.com',\n  preserveDrawingBuffer: false,\n  attributionControl: true,\n  reuseMaps: false,\n  mapOptions: {},\n  mapStyle: 'mapbox://styles/mapbox/light-v8',\n  preventStyleDiffing: false,\n  visible: true,\n  asyncRender: false,\n  onLoad: noop,\n  onError: defaultOnError,\n  width: 0,\n  height: 0,\n  longitude: 0,\n  latitude: 0,\n  zoom: 0,\n  bearing: 0,\n  pitch: 0,\n  altitude: 1.5\n};\nfunction getAccessToken() {\n  var accessToken = null;\n  if (typeof window !== 'undefined' && window.location) {\n    var match = window.location.search.match(/access_token=([^&\\/]*)/);\n    accessToken = match && match[1];\n  }\n  if (!accessToken && typeof process !== 'undefined') {\n    accessToken = accessToken || ({}).MapboxAccessToken || ({}).REACT_APP_MAPBOX_ACCESS_TOKEN;\n  }\n  return accessToken || 'no-token';\n}\nfunction checkPropTypes(props) {\n  var component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'component';\n  if (props.debug) {\n    prop_types.checkPropTypes(propTypes, props, 'prop', component);\n  }\n}\nvar Mapbox = function () {\n  function Mapbox(props) {\n    var _this = this;\n    _classCallCheck(this, Mapbox);\n    _defineProperty(this, \"props\", defaultProps);\n    _defineProperty(this, \"width\", 0);\n    _defineProperty(this, \"height\", 0);\n    _defineProperty(this, \"_fireLoadEvent\", function () {\n      _this.props.onLoad({\n        type: 'load',\n        target: _this._map\n      });\n    });\n    _defineProperty(this, \"_handleError\", function (event) {\n      _this.props.onError(event);\n    });\n    if (!props.mapboxgl) {\n      throw new Error('Mapbox not available');\n    }\n    this.mapboxgl = props.mapboxgl;\n    if (!Mapbox.initialized) {\n      Mapbox.initialized = true;\n      this._checkStyleSheet(this.mapboxgl.version);\n    }\n    this._initialize(props);\n  }\n  _createClass(Mapbox, [{\n    key: \"finalize\",\n    value: function finalize() {\n      this._destroy();\n      return this;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      this._update(this.props, props);\n      return this;\n    }\n  }, {\n    key: \"redraw\",\n    value: function redraw() {\n      var map = this._map;\n      if (map.style) {\n        if (map._frame) {\n          map._frame.cancel();\n          map._frame = null;\n        }\n        map._render();\n      }\n    }\n  }, {\n    key: \"getMap\",\n    value: function getMap() {\n      return this._map;\n    }\n  }, {\n    key: \"_reuse\",\n    value: function _reuse(props) {\n      this._map = Mapbox.savedMap;\n      var oldContainer = this._map.getContainer();\n      var newContainer = props.container;\n      newContainer.classList.add('mapboxgl-map');\n      while (oldContainer.childNodes.length > 0) {\n        newContainer.appendChild(oldContainer.childNodes[0]);\n      }\n      this._map._container = newContainer;\n      Mapbox.savedMap = null;\n      if (props.mapStyle) {\n        this._map.setStyle(normalizeStyle(props.mapStyle), {\n          diff: false\n        });\n      }\n      if (this._map.isStyleLoaded()) {\n        this._fireLoadEvent();\n      } else {\n        this._map.once('styledata', this._fireLoadEvent);\n      }\n    }\n  }, {\n    key: \"_create\",\n    value: function _create(props) {\n      if (props.reuseMaps && Mapbox.savedMap) {\n        this._reuse(props);\n      } else {\n        if (props.gl) {\n          var getContext = HTMLCanvasElement.prototype.getContext;\n          HTMLCanvasElement.prototype.getContext = function () {\n            HTMLCanvasElement.prototype.getContext = getContext;\n            return props.gl;\n          };\n        }\n        var mapOptions = {\n          container: props.container,\n          center: [0, 0],\n          zoom: 8,\n          pitch: 0,\n          bearing: 0,\n          maxZoom: 24,\n          style: normalizeStyle(props.mapStyle),\n          interactive: false,\n          trackResize: false,\n          attributionControl: props.attributionControl,\n          preserveDrawingBuffer: props.preserveDrawingBuffer\n        };\n        if (props.transformRequest) {\n          mapOptions.transformRequest = props.transformRequest;\n        }\n        this._map = new this.mapboxgl.Map(Object.assign({}, mapOptions, props.mapOptions));\n        this._map.once('load', this._fireLoadEvent);\n        this._map.on('error', this._handleError);\n      }\n      return this;\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      if (!this._map) {\n        return;\n      }\n      if (this.props.reuseMaps && !Mapbox.savedMap) {\n        Mapbox.savedMap = this._map;\n        this._map.off('load', this._fireLoadEvent);\n        this._map.off('error', this._handleError);\n        this._map.off('styledata', this._fireLoadEvent);\n      } else {\n        this._map.remove();\n      }\n      this._map = null;\n    }\n  }, {\n    key: \"_initialize\",\n    value: function _initialize(props) {\n      var _this2 = this;\n      props = Object.assign({}, defaultProps, props);\n      checkPropTypes(props, 'Mapbox');\n      this.mapboxgl.accessToken = props.mapboxApiAccessToken || defaultProps.mapboxApiAccessToken;\n      this.mapboxgl.baseApiUrl = props.mapboxApiUrl;\n      this._create(props);\n      var _props = props,\n        container = _props.container;\n      Object.defineProperty(container, 'offsetWidth', {\n        configurable: true,\n        get: function get() {\n          return _this2.width;\n        }\n      });\n      Object.defineProperty(container, 'clientWidth', {\n        configurable: true,\n        get: function get() {\n          return _this2.width;\n        }\n      });\n      Object.defineProperty(container, 'offsetHeight', {\n        configurable: true,\n        get: function get() {\n          return _this2.height;\n        }\n      });\n      Object.defineProperty(container, 'clientHeight', {\n        configurable: true,\n        get: function get() {\n          return _this2.height;\n        }\n      });\n      var canvas = this._map.getCanvas();\n      if (canvas) {\n        canvas.style.outline = 'none';\n      }\n      this._updateMapViewport({}, props);\n      this._updateMapSize({}, props);\n      this.props = props;\n    }\n  }, {\n    key: \"_update\",\n    value: function _update(oldProps, newProps) {\n      if (!this._map) {\n        return;\n      }\n      newProps = Object.assign({}, this.props, newProps);\n      checkPropTypes(newProps, 'Mapbox');\n      var viewportChanged = this._updateMapViewport(oldProps, newProps);\n      var sizeChanged = this._updateMapSize(oldProps, newProps);\n      this._updateMapStyle(oldProps, newProps);\n      if (!newProps.asyncRender && (viewportChanged || sizeChanged)) {\n        this.redraw();\n      }\n      this.props = newProps;\n    }\n  }, {\n    key: \"_updateMapStyle\",\n    value: function _updateMapStyle(oldProps, newProps) {\n      var styleChanged = oldProps.mapStyle !== newProps.mapStyle;\n      if (styleChanged) {\n        this._map.setStyle(normalizeStyle(newProps.mapStyle), {\n          diff: !newProps.preventStyleDiffing\n        });\n      }\n    }\n  }, {\n    key: \"_updateMapSize\",\n    value: function _updateMapSize(oldProps, newProps) {\n      var sizeChanged = oldProps.width !== newProps.width || oldProps.height !== newProps.height;\n      if (sizeChanged) {\n        this.width = newProps.width;\n        this.height = newProps.height;\n        this._map.resize();\n      }\n      return sizeChanged;\n    }\n  }, {\n    key: \"_updateMapViewport\",\n    value: function _updateMapViewport(oldProps, newProps) {\n      var oldViewState = this._getViewState(oldProps);\n      var newViewState = this._getViewState(newProps);\n      var viewportChanged = newViewState.latitude !== oldViewState.latitude || newViewState.longitude !== oldViewState.longitude || newViewState.zoom !== oldViewState.zoom || newViewState.pitch !== oldViewState.pitch || newViewState.bearing !== oldViewState.bearing || newViewState.altitude !== oldViewState.altitude;\n      if (viewportChanged) {\n        this._map.jumpTo(this._viewStateToMapboxProps(newViewState));\n        if (newViewState.altitude !== oldViewState.altitude) {\n          this._map.transform.altitude = newViewState.altitude;\n        }\n      }\n      return viewportChanged;\n    }\n  }, {\n    key: \"_getViewState\",\n    value: function _getViewState(props) {\n      var _ref = props.viewState || props,\n        longitude = _ref.longitude,\n        latitude = _ref.latitude,\n        zoom = _ref.zoom,\n        _ref$pitch = _ref.pitch,\n        pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,\n        _ref$bearing = _ref.bearing,\n        bearing = _ref$bearing === void 0 ? 0 : _ref$bearing,\n        _ref$altitude = _ref.altitude,\n        altitude = _ref$altitude === void 0 ? 1.5 : _ref$altitude;\n      return {\n        longitude: longitude,\n        latitude: latitude,\n        zoom: zoom,\n        pitch: pitch,\n        bearing: bearing,\n        altitude: altitude\n      };\n    }\n  }, {\n    key: \"_checkStyleSheet\",\n    value: function _checkStyleSheet() {\n      var mapboxVersion = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '0.47.0';\n      if (typeof document_ === 'undefined') {\n        return;\n      }\n      try {\n        var testElement = document_.createElement('div');\n        testElement.className = 'mapboxgl-map';\n        testElement.style.display = 'none';\n        document_.body.appendChild(testElement);\n        var isCssLoaded = window.getComputedStyle(testElement).position !== 'static';\n        if (!isCssLoaded) {\n          var link = document_.createElement('link');\n          link.setAttribute('rel', 'stylesheet');\n          link.setAttribute('type', 'text/css');\n          link.setAttribute('href', \"https://api.tiles.mapbox.com/mapbox-gl-js/v\".concat(mapboxVersion, \"/mapbox-gl.css\"));\n          document_.head.appendChild(link);\n        }\n      } catch (error) {}\n    }\n  }, {\n    key: \"_viewStateToMapboxProps\",\n    value: function _viewStateToMapboxProps(viewState) {\n      return {\n        center: [viewState.longitude, viewState.latitude],\n        zoom: viewState.zoom,\n        bearing: viewState.bearing,\n        pitch: viewState.pitch\n      };\n    }\n  }]);\n  return Mapbox;\n}();\n_defineProperty(Mapbox, \"initialized\", false);\n_defineProperty(Mapbox, \"propTypes\", propTypes);\n_defineProperty(Mapbox, \"defaultProps\", defaultProps);\n_defineProperty(Mapbox, \"savedMap\", null);\n\n// EXTERNAL MODULE: ./node_modules/maplibre-gl/dist/maplibre-gl.js\nvar maplibre_gl = __webpack_require__(40111);\nvar maplibre_gl_default = /*#__PURE__*/__webpack_require__.n(maplibre_gl);\n;// ./node_modules/react-map-gl/dist/esm/utils/mapboxgl.browser.js\n\n;// ./node_modules/react-map-gl/dist/esm/utils/math-utils.js\nvar math_utils_EPSILON = 1e-7;\nfunction isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value);\n}\nfunction math_utils_equals(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (isArray(a) && isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (var i = 0; i < a.length; ++i) {\n      if (!math_utils_equals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return Math.abs(a - b) <= math_utils_EPSILON;\n}\nfunction math_utils_clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nfunction utils_math_utils_lerp(a, b, t) {\n  if (isArray(a)) {\n    return a.map(function (ai, i) {\n      return utils_math_utils_lerp(ai, b[i], t);\n    });\n  }\n  return t * b + (1 - t) * a;\n}\n;// ./node_modules/react-map-gl/dist/esm/utils/assert.js\nfunction utils_assert_assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'react-map-gl: assertion failed.');\n  }\n}\n;// ./node_modules/react-map-gl/dist/esm/utils/map-state.js\n\n\n\n\nfunction map_state_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction map_state_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      map_state_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      map_state_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\nvar MAPBOX_LIMITS = {\n  minZoom: 0,\n  maxZoom: 24,\n  minPitch: 0,\n  maxPitch: 85\n};\nvar DEFAULT_STATE = {\n  pitch: 0,\n  bearing: 0,\n  altitude: 1.5\n};\nvar PITCH_MOUSE_THRESHOLD = 5;\nvar PITCH_ACCEL = 1.2;\nvar MapState = function () {\n  function MapState(_ref) {\n    var width = _ref.width,\n      height = _ref.height,\n      latitude = _ref.latitude,\n      longitude = _ref.longitude,\n      zoom = _ref.zoom,\n      _ref$bearing = _ref.bearing,\n      bearing = _ref$bearing === void 0 ? DEFAULT_STATE.bearing : _ref$bearing,\n      _ref$pitch = _ref.pitch,\n      pitch = _ref$pitch === void 0 ? DEFAULT_STATE.pitch : _ref$pitch,\n      _ref$altitude = _ref.altitude,\n      altitude = _ref$altitude === void 0 ? DEFAULT_STATE.altitude : _ref$altitude,\n      _ref$maxZoom = _ref.maxZoom,\n      maxZoom = _ref$maxZoom === void 0 ? MAPBOX_LIMITS.maxZoom : _ref$maxZoom,\n      _ref$minZoom = _ref.minZoom,\n      minZoom = _ref$minZoom === void 0 ? MAPBOX_LIMITS.minZoom : _ref$minZoom,\n      _ref$maxPitch = _ref.maxPitch,\n      maxPitch = _ref$maxPitch === void 0 ? MAPBOX_LIMITS.maxPitch : _ref$maxPitch,\n      _ref$minPitch = _ref.minPitch,\n      minPitch = _ref$minPitch === void 0 ? MAPBOX_LIMITS.minPitch : _ref$minPitch,\n      transitionDuration = _ref.transitionDuration,\n      transitionEasing = _ref.transitionEasing,\n      transitionInterpolator = _ref.transitionInterpolator,\n      transitionInterruption = _ref.transitionInterruption,\n      startPanLngLat = _ref.startPanLngLat,\n      startZoomLngLat = _ref.startZoomLngLat,\n      startRotatePos = _ref.startRotatePos,\n      startBearing = _ref.startBearing,\n      startPitch = _ref.startPitch,\n      startZoom = _ref.startZoom;\n    _classCallCheck(this, MapState);\n    utils_assert_assert(Number.isFinite(width), '`width` must be supplied');\n    utils_assert_assert(Number.isFinite(height), '`height` must be supplied');\n    utils_assert_assert(Number.isFinite(longitude), '`longitude` must be supplied');\n    utils_assert_assert(Number.isFinite(latitude), '`latitude` must be supplied');\n    utils_assert_assert(Number.isFinite(zoom), '`zoom` must be supplied');\n    this._viewportProps = this._applyConstraints({\n      width: width,\n      height: height,\n      latitude: latitude,\n      longitude: longitude,\n      zoom: zoom,\n      bearing: bearing,\n      pitch: pitch,\n      altitude: altitude,\n      maxZoom: maxZoom,\n      minZoom: minZoom,\n      maxPitch: maxPitch,\n      minPitch: minPitch,\n      transitionDuration: transitionDuration,\n      transitionEasing: transitionEasing,\n      transitionInterpolator: transitionInterpolator,\n      transitionInterruption: transitionInterruption\n    });\n    this._state = {\n      startPanLngLat: startPanLngLat,\n      startZoomLngLat: startZoomLngLat,\n      startRotatePos: startRotatePos,\n      startBearing: startBearing,\n      startPitch: startPitch,\n      startZoom: startZoom\n    };\n  }\n  _createClass(MapState, [{\n    key: \"getViewportProps\",\n    value: function getViewportProps() {\n      return this._viewportProps;\n    }\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return this._state;\n    }\n  }, {\n    key: \"panStart\",\n    value: function panStart(_ref2) {\n      var pos = _ref2.pos;\n      return this._getUpdatedMapState({\n        startPanLngLat: this._unproject(pos)\n      });\n    }\n  }, {\n    key: \"pan\",\n    value: function pan(_ref3) {\n      var pos = _ref3.pos,\n        startPos = _ref3.startPos;\n      var startPanLngLat = this._state.startPanLngLat || this._unproject(startPos);\n      if (!startPanLngLat) {\n        return this;\n      }\n      var _this$_calculateNewLn = this._calculateNewLngLat({\n          startPanLngLat: startPanLngLat,\n          pos: pos\n        }),\n        _this$_calculateNewLn2 = _slicedToArray(_this$_calculateNewLn, 2),\n        longitude = _this$_calculateNewLn2[0],\n        latitude = _this$_calculateNewLn2[1];\n      return this._getUpdatedMapState({\n        longitude: longitude,\n        latitude: latitude\n      });\n    }\n  }, {\n    key: \"panEnd\",\n    value: function panEnd() {\n      return this._getUpdatedMapState({\n        startPanLngLat: null\n      });\n    }\n  }, {\n    key: \"rotateStart\",\n    value: function rotateStart(_ref4) {\n      var pos = _ref4.pos;\n      return this._getUpdatedMapState({\n        startRotatePos: pos,\n        startBearing: this._viewportProps.bearing,\n        startPitch: this._viewportProps.pitch\n      });\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(_ref5) {\n      var pos = _ref5.pos,\n        _ref5$deltaAngleX = _ref5.deltaAngleX,\n        deltaAngleX = _ref5$deltaAngleX === void 0 ? 0 : _ref5$deltaAngleX,\n        _ref5$deltaAngleY = _ref5.deltaAngleY,\n        deltaAngleY = _ref5$deltaAngleY === void 0 ? 0 : _ref5$deltaAngleY;\n      var _this$_state = this._state,\n        startRotatePos = _this$_state.startRotatePos,\n        startBearing = _this$_state.startBearing,\n        startPitch = _this$_state.startPitch;\n      if (!Number.isFinite(startBearing) || !Number.isFinite(startPitch)) {\n        return this;\n      }\n      var newRotation;\n      if (pos) {\n        newRotation = this._calculateNewPitchAndBearing(map_state_objectSpread(map_state_objectSpread({}, this._getRotationParams(pos, startRotatePos)), {}, {\n          startBearing: startBearing,\n          startPitch: startPitch\n        }));\n      } else {\n        newRotation = {\n          bearing: startBearing + deltaAngleX,\n          pitch: startPitch + deltaAngleY\n        };\n      }\n      return this._getUpdatedMapState(newRotation);\n    }\n  }, {\n    key: \"rotateEnd\",\n    value: function rotateEnd() {\n      return this._getUpdatedMapState({\n        startBearing: null,\n        startPitch: null\n      });\n    }\n  }, {\n    key: \"zoomStart\",\n    value: function zoomStart(_ref6) {\n      var pos = _ref6.pos;\n      return this._getUpdatedMapState({\n        startZoomLngLat: this._unproject(pos),\n        startZoom: this._viewportProps.zoom\n      });\n    }\n  }, {\n    key: \"zoom\",\n    value: function zoom(_ref7) {\n      var pos = _ref7.pos,\n        startPos = _ref7.startPos,\n        scale = _ref7.scale;\n      utils_assert_assert(scale > 0, '`scale` must be a positive number');\n      var _this$_state2 = this._state,\n        startZoom = _this$_state2.startZoom,\n        startZoomLngLat = _this$_state2.startZoomLngLat;\n      if (!Number.isFinite(startZoom)) {\n        startZoom = this._viewportProps.zoom;\n        startZoomLngLat = this._unproject(startPos) || this._unproject(pos);\n      }\n      utils_assert_assert(startZoomLngLat, '`startZoomLngLat` prop is required ' + 'for zoom behavior to calculate where to position the map.');\n      var zoom = this._calculateNewZoom({\n        scale: scale,\n        startZoom: startZoom || 0\n      });\n      var zoomedViewport = new WebMercatorViewport(Object.assign({}, this._viewportProps, {\n        zoom: zoom\n      }));\n      var _zoomedViewport$getMa = zoomedViewport.getMapCenterByLngLatPosition({\n          lngLat: startZoomLngLat,\n          pos: pos\n        }),\n        _zoomedViewport$getMa2 = _slicedToArray(_zoomedViewport$getMa, 2),\n        longitude = _zoomedViewport$getMa2[0],\n        latitude = _zoomedViewport$getMa2[1];\n      return this._getUpdatedMapState({\n        zoom: zoom,\n        longitude: longitude,\n        latitude: latitude\n      });\n    }\n  }, {\n    key: \"zoomEnd\",\n    value: function zoomEnd() {\n      return this._getUpdatedMapState({\n        startZoomLngLat: null,\n        startZoom: null\n      });\n    }\n  }, {\n    key: \"_getUpdatedMapState\",\n    value: function _getUpdatedMapState(newProps) {\n      return new MapState(Object.assign({}, this._viewportProps, this._state, newProps));\n    }\n  }, {\n    key: \"_applyConstraints\",\n    value: function _applyConstraints(props) {\n      var maxZoom = props.maxZoom,\n        minZoom = props.minZoom,\n        zoom = props.zoom;\n      props.zoom = math_utils_clamp(zoom, minZoom, maxZoom);\n      var maxPitch = props.maxPitch,\n        minPitch = props.minPitch,\n        pitch = props.pitch;\n      props.pitch = math_utils_clamp(pitch, minPitch, maxPitch);\n      Object.assign(props, normalizeViewportProps(props));\n      return props;\n    }\n  }, {\n    key: \"_unproject\",\n    value: function _unproject(pos) {\n      var viewport = new WebMercatorViewport(this._viewportProps);\n      return pos && viewport.unproject(pos);\n    }\n  }, {\n    key: \"_calculateNewLngLat\",\n    value: function _calculateNewLngLat(_ref8) {\n      var startPanLngLat = _ref8.startPanLngLat,\n        pos = _ref8.pos;\n      var viewport = new WebMercatorViewport(this._viewportProps);\n      return viewport.getMapCenterByLngLatPosition({\n        lngLat: startPanLngLat,\n        pos: pos\n      });\n    }\n  }, {\n    key: \"_calculateNewZoom\",\n    value: function _calculateNewZoom(_ref9) {\n      var scale = _ref9.scale,\n        startZoom = _ref9.startZoom;\n      var _this$_viewportProps = this._viewportProps,\n        maxZoom = _this$_viewportProps.maxZoom,\n        minZoom = _this$_viewportProps.minZoom;\n      var zoom = startZoom + Math.log2(scale);\n      return math_utils_clamp(zoom, minZoom, maxZoom);\n    }\n  }, {\n    key: \"_calculateNewPitchAndBearing\",\n    value: function _calculateNewPitchAndBearing(_ref10) {\n      var deltaScaleX = _ref10.deltaScaleX,\n        deltaScaleY = _ref10.deltaScaleY,\n        startBearing = _ref10.startBearing,\n        startPitch = _ref10.startPitch;\n      deltaScaleY = math_utils_clamp(deltaScaleY, -1, 1);\n      var _this$_viewportProps2 = this._viewportProps,\n        minPitch = _this$_viewportProps2.minPitch,\n        maxPitch = _this$_viewportProps2.maxPitch;\n      var bearing = startBearing + 180 * deltaScaleX;\n      var pitch = startPitch;\n      if (deltaScaleY > 0) {\n        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);\n      } else if (deltaScaleY < 0) {\n        pitch = startPitch - deltaScaleY * (minPitch - startPitch);\n      }\n      return {\n        pitch: pitch,\n        bearing: bearing\n      };\n    }\n  }, {\n    key: \"_getRotationParams\",\n    value: function _getRotationParams(pos, startPos) {\n      var deltaX = pos[0] - startPos[0];\n      var deltaY = pos[1] - startPos[1];\n      var centerY = pos[1];\n      var startY = startPos[1];\n      var _this$_viewportProps3 = this._viewportProps,\n        width = _this$_viewportProps3.width,\n        height = _this$_viewportProps3.height;\n      var deltaScaleX = deltaX / width;\n      var deltaScaleY = 0;\n      if (deltaY > 0) {\n        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {\n          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;\n        }\n      } else if (deltaY < 0) {\n        if (startY > PITCH_MOUSE_THRESHOLD) {\n          deltaScaleY = 1 - centerY / startY;\n        }\n      }\n      deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));\n      return {\n        deltaScaleX: deltaScaleX,\n        deltaScaleY: deltaScaleY\n      };\n    }\n  }]);\n  return MapState;\n}();\n\n;// ./node_modules/react-map-gl/dist/esm/utils/map-constraints.js\n\nfunction decapitalize(s) {\n  return s[0].toLowerCase() + s.slice(1);\n}\nfunction checkVisibilityConstraints(props) {\n  var constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAPBOX_LIMITS;\n  for (var constraintName in constraints) {\n    var type = constraintName.slice(0, 3);\n    var propName = decapitalize(constraintName.slice(3));\n    if (type === 'min' && props[propName] < constraints[constraintName]) {\n      return false;\n    }\n    if (type === 'max' && props[propName] > constraints[constraintName]) {\n      return false;\n    }\n  }\n  return true;\n}\n;// ./node_modules/react-map-gl/dist/esm/components/map-context.js\n\n\nfunction map_context_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction map_context_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      map_context_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      map_context_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\nvar MapContext = (0,react.createContext)({\n  viewport: null,\n  map: null,\n  container: null,\n  onViewportChange: null,\n  onViewStateChange: null,\n  eventManager: null\n});\nvar MapContextProvider = MapContext.Provider;\nfunction WrappedProvider(_ref) {\n  var value = _ref.value,\n    children = _ref.children;\n  var _useState = (0,react.useState)(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    map = _useState2[0],\n    setMap = _useState2[1];\n  var context = (0,react.useContext)(MapContext);\n  value = map_context_objectSpread(map_context_objectSpread({\n    setMap: setMap\n  }, context), {}, {\n    map: context && context.map || map\n  }, value);\n  return react.createElement(MapContextProvider, {\n    value: value\n  }, children);\n}\nMapContext.Provider = WrappedProvider;\n/* harmony default export */ var map_context = (MapContext);\n;// ./node_modules/react-map-gl/dist/esm/utils/use-isomorphic-layout-effect.js\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react.useLayoutEffect : react.useEffect;\n/* harmony default export */ var use_isomorphic_layout_effect = (useIsomorphicLayoutEffect);\n;// ./node_modules/react-map-gl/dist/esm/utils/terrain.js\nfunction getTerrainElevation(map, _ref) {\n  var longitude = _ref.longitude,\n    latitude = _ref.latitude;\n  if (map && map.queryTerrainElevation) {\n    return map.queryTerrainElevation([longitude, latitude]) || 0;\n  }\n  return 0;\n}\n;// ./node_modules/react-map-gl/dist/esm/components/static-map.js\n\n\nfunction static_map_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction static_map_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      static_map_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      static_map_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\n\n\n\n\n\n\n\nvar TOKEN_DOC_URL = 'https://visgl.github.io/react-map-gl/docs/get-started/mapbox-tokens';\nvar NO_TOKEN_WARNING = 'A valid API access token is required to use Mapbox data';\nfunction static_map_noop() {}\nfunction getViewport(_ref) {\n  var map = _ref.map,\n    props = _ref.props,\n    width = _ref.width,\n    height = _ref.height;\n  var viewportProps = static_map_objectSpread(static_map_objectSpread(static_map_objectSpread({}, props), props.viewState), {}, {\n    width: width,\n    height: height\n  });\n  viewportProps.position = [0, 0, getTerrainElevation(map, viewportProps)];\n  return new WebMercatorViewport(viewportProps);\n}\nvar UNAUTHORIZED_ERROR_CODE = 401;\nvar CONTAINER_STYLE = {\n  position: 'absolute',\n  width: '100%',\n  height: '100%',\n  overflow: 'hidden'\n};\nvar static_map_defaultProps = Object.assign({}, Mapbox.defaultProps, {\n  disableTokenWarning: false,\n  visible: true,\n  onResize: static_map_noop,\n  className: '',\n  style: null,\n  visibilityConstraints: MAPBOX_LIMITS\n});\nfunction NoTokenWarning() {\n  var style = {\n    position: 'absolute',\n    left: 0,\n    top: 0\n  };\n  return react.createElement(\"div\", {\n    key: \"warning\",\n    id: \"no-token-warning\",\n    style: style\n  }, react.createElement(\"h3\", {\n    key: \"header\"\n  }, NO_TOKEN_WARNING), react.createElement(\"div\", {\n    key: \"text\"\n  }, \"For information on setting up your basemap, read\"), react.createElement(\"a\", {\n    key: \"link\",\n    href: TOKEN_DOC_URL\n  }, \"Note on Map Tokens\"));\n}\nfunction getRefHandles(mapboxRef) {\n  return {\n    getMap: function getMap() {\n      return mapboxRef.current && mapboxRef.current.getMap();\n    },\n    queryRenderedFeatures: function queryRenderedFeatures(geometry) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var map = mapboxRef.current && mapboxRef.current.getMap();\n      return map && map.queryRenderedFeatures(geometry, options);\n    }\n  };\n}\nvar StaticMap = (0,react.forwardRef)(function (props, ref) {\n  var _useState = (0,react.useState)(true),\n    _useState2 = _slicedToArray(_useState, 2),\n    accessTokenValid = _useState2[0],\n    setTokenState = _useState2[1];\n  var _useState3 = (0,react.useState)({\n      width: 0,\n      height: 0\n    }),\n    _useState4 = _slicedToArray(_useState3, 2),\n    size = _useState4[0],\n    setSize = _useState4[1];\n  var mapboxRef = (0,react.useRef)(null);\n  var mapDivRef = (0,react.useRef)(null);\n  var containerRef = (0,react.useRef)(null);\n  var overlayRef = (0,react.useRef)(null);\n  var context = (0,react.useContext)(map_context);\n  use_isomorphic_layout_effect(function () {\n    if (!StaticMap.supported()) {\n      return undefined;\n    }\n    var mapbox = new Mapbox(static_map_objectSpread(static_map_objectSpread(static_map_objectSpread({}, props), size), {}, {\n      mapboxgl: (maplibre_gl_default()),\n      container: mapDivRef.current,\n      onError: function onError(evt) {\n        var statusCode = evt.error && evt.error.status || evt.status;\n        if (statusCode === UNAUTHORIZED_ERROR_CODE && accessTokenValid) {\n          console.error(NO_TOKEN_WARNING);\n          setTokenState(false);\n        }\n        props.onError(evt);\n      }\n    }));\n    mapboxRef.current = mapbox;\n    if (context && context.setMap) {\n      context.setMap(mapbox.getMap());\n    }\n    var resizeObserver = new ResizeObserver_es(function (entries) {\n      if (entries[0].contentRect) {\n        var _entries$0$contentRec = entries[0].contentRect,\n          _width = _entries$0$contentRec.width,\n          _height = _entries$0$contentRec.height;\n        setSize({\n          width: _width,\n          height: _height\n        });\n        props.onResize({\n          width: _width,\n          height: _height\n        });\n      }\n    });\n    resizeObserver.observe(containerRef.current);\n    return function () {\n      mapbox.finalize();\n      mapboxRef.current = null;\n      resizeObserver.disconnect();\n    };\n  }, []);\n  use_isomorphic_layout_effect(function () {\n    if (mapboxRef.current) {\n      mapboxRef.current.setProps(static_map_objectSpread(static_map_objectSpread({}, props), size));\n    }\n  });\n  var map = mapboxRef.current && mapboxRef.current.getMap();\n  (0,react.useImperativeHandle)(ref, function () {\n    return getRefHandles(mapboxRef);\n  }, []);\n  var preventScroll = (0,react.useCallback)(function (_ref2) {\n    var target = _ref2.target;\n    if (target === overlayRef.current) {\n      target.scrollTo(0, 0);\n    }\n  }, []);\n  var overlays = map && react.createElement(MapContextProvider, {\n    value: static_map_objectSpread(static_map_objectSpread({}, context), {}, {\n      viewport: context.viewport || getViewport(static_map_objectSpread({\n        map: map,\n        props: props\n      }, size)),\n      map: map,\n      container: context.container || containerRef.current\n    })\n  }, react.createElement(\"div\", {\n    key: \"map-overlays\",\n    className: \"overlays\",\n    ref: overlayRef,\n    style: CONTAINER_STYLE,\n    onScroll: preventScroll\n  }, props.children));\n  var className = props.className,\n    width = props.width,\n    height = props.height,\n    style = props.style,\n    visibilityConstraints = props.visibilityConstraints;\n  var mapContainerStyle = Object.assign({\n    position: 'relative'\n  }, style, {\n    width: width,\n    height: height\n  });\n  var visible = props.visible && checkVisibilityConstraints(props.viewState || props, visibilityConstraints);\n  var mapStyle = Object.assign({}, CONTAINER_STYLE, {\n    visibility: visible ? 'inherit' : 'hidden'\n  });\n  return react.createElement(\"div\", {\n    key: \"map-container\",\n    ref: containerRef,\n    style: mapContainerStyle\n  }, react.createElement(\"div\", {\n    key: \"map-mapbox\",\n    ref: mapDivRef,\n    style: mapStyle,\n    className: className\n  }), overlays, !accessTokenValid && !props.disableTokenWarning && react.createElement(NoTokenWarning, null));\n});\nStaticMap.supported = function () {\n  return (maplibre_gl_default()) && maplibre_gl_default().supported();\n};\nStaticMap.defaultProps = static_map_defaultProps;\n/* harmony default export */ var static_map = (StaticMap);\n;// ./node_modules/react-map-gl/dist/esm/utils/transition/transition-interpolator.js\n\n\n\nfunction transition_interpolator_createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = transition_interpolator_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction transition_interpolator_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return transition_interpolator_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return transition_interpolator_arrayLikeToArray(o, minLen);\n}\nfunction transition_interpolator_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\n\n\nvar TransitionInterpolator = function () {\n  function TransitionInterpolator() {\n    _classCallCheck(this, TransitionInterpolator);\n    _defineProperty(this, \"propNames\", []);\n  }\n  _createClass(TransitionInterpolator, [{\n    key: \"arePropsEqual\",\n    value: function arePropsEqual(currentProps, nextProps) {\n      var _iterator = transition_interpolator_createForOfIteratorHelper(this.propNames || []),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          if (!math_utils_equals(currentProps[key], nextProps[key])) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return true;\n    }\n  }, {\n    key: \"initializeProps\",\n    value: function initializeProps(startProps, endProps) {\n      return {\n        start: startProps,\n        end: endProps\n      };\n    }\n  }, {\n    key: \"interpolateProps\",\n    value: function interpolateProps(startProps, endProps, t) {\n      utils_assert_assert(false, 'interpolateProps is not implemented');\n    }\n  }, {\n    key: \"getDuration\",\n    value: function getDuration(startProps, endProps) {\n      return endProps.transitionDuration;\n    }\n  }]);\n  return TransitionInterpolator;\n}();\n\n;// ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\nfunction _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\nvar setPrototypeOf = __webpack_require__(63662);\n;// ./node_modules/@babel/runtime/helpers/esm/inherits.js\n\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && (0,setPrototypeOf/* default */.A)(t, e);\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\n\n\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\n\n;// ./node_modules/react-map-gl/dist/esm/utils/transition/transition-utils.js\nvar WRAPPED_ANGULAR_PROPS = {\n  longitude: 1,\n  bearing: 1\n};\nfunction transition_utils_mod(value, divisor) {\n  var modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\nfunction isValid(prop) {\n  return Number.isFinite(prop) || Array.isArray(prop);\n}\nfunction isWrappedAngularProp(propName) {\n  return propName in WRAPPED_ANGULAR_PROPS;\n}\nfunction getEndValueByShortestPath(propName, startValue, endValue) {\n  if (isWrappedAngularProp(propName) && Math.abs(endValue - startValue) > 180) {\n    endValue = endValue < 0 ? endValue + 360 : endValue - 360;\n  }\n  return endValue;\n}\n;// ./node_modules/react-map-gl/dist/esm/utils/transition/viewport-fly-to-interpolator.js\n\n\n\n\n\n\n\nfunction viewport_fly_to_interpolator_createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = viewport_fly_to_interpolator_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction viewport_fly_to_interpolator_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return viewport_fly_to_interpolator_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return viewport_fly_to_interpolator_arrayLikeToArray(o, minLen);\n}\nfunction viewport_fly_to_interpolator_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n\n\n\n\nvar viewport_fly_to_interpolator_VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'];\nvar REQUIRED_PROPS = ['latitude', 'longitude', 'zoom', 'width', 'height'];\nvar LINEARLY_INTERPOLATED_PROPS = ['bearing', 'pitch'];\nvar viewport_fly_to_interpolator_DEFAULT_OPTS = {\n  speed: 1.2,\n  curve: 1.414\n};\nvar ViewportFlyToInterpolator = function (_TransitionInterpolat) {\n  _inherits(ViewportFlyToInterpolator, _TransitionInterpolat);\n  var _super = _createSuper(ViewportFlyToInterpolator);\n  function ViewportFlyToInterpolator() {\n    var _this;\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, ViewportFlyToInterpolator);\n    _this = _super.call(this);\n    _defineProperty(_assertThisInitialized(_this), \"propNames\", viewport_fly_to_interpolator_VIEWPORT_TRANSITION_PROPS);\n    _this.props = Object.assign({}, viewport_fly_to_interpolator_DEFAULT_OPTS, props);\n    return _this;\n  }\n  _createClass(ViewportFlyToInterpolator, [{\n    key: \"initializeProps\",\n    value: function initializeProps(startProps, endProps) {\n      var startViewportProps = {};\n      var endViewportProps = {};\n      var _iterator = viewport_fly_to_interpolator_createForOfIteratorHelper(REQUIRED_PROPS),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          var startValue = startProps[key];\n          var endValue = endProps[key];\n          utils_assert_assert(isValid(startValue) && isValid(endValue), \"\".concat(key, \" must be supplied for transition\"));\n          startViewportProps[key] = startValue;\n          endViewportProps[key] = getEndValueByShortestPath(key, startValue, endValue);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var _iterator2 = viewport_fly_to_interpolator_createForOfIteratorHelper(LINEARLY_INTERPOLATED_PROPS),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _key = _step2.value;\n          var _startValue = startProps[_key] || 0;\n          var _endValue = endProps[_key] || 0;\n          startViewportProps[_key] = _startValue;\n          endViewportProps[_key] = getEndValueByShortestPath(_key, _startValue, _endValue);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return {\n        start: startViewportProps,\n        end: endViewportProps\n      };\n    }\n  }, {\n    key: \"interpolateProps\",\n    value: function interpolateProps(startProps, endProps, t) {\n      var viewport = flyToViewport(startProps, endProps, t, this.props);\n      var _iterator3 = viewport_fly_to_interpolator_createForOfIteratorHelper(LINEARLY_INTERPOLATED_PROPS),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var key = _step3.value;\n          viewport[key] = utils_math_utils_lerp(startProps[key], endProps[key], t);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return viewport;\n    }\n  }, {\n    key: \"getDuration\",\n    value: function getDuration(startProps, endProps) {\n      var transitionDuration = endProps.transitionDuration;\n      if (transitionDuration === 'auto') {\n        transitionDuration = getFlyToDuration(startProps, endProps, this.props);\n      }\n      return transitionDuration;\n    }\n  }]);\n  return ViewportFlyToInterpolator;\n}(TransitionInterpolator);\n\n;// ./node_modules/react-map-gl/dist/esm/utils/transition/linear-interpolator.js\n\n\n\n\n\n\nfunction linear_interpolator_createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = linear_interpolator_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction linear_interpolator_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return linear_interpolator_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return linear_interpolator_arrayLikeToArray(o, minLen);\n}\nfunction linear_interpolator_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction linear_interpolator_createSuper(Derived) {\n  var hasNativeReflectConstruct = linear_interpolator_isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction linear_interpolator_isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n\n\n\n\nvar linear_interpolator_VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'];\nvar LinearInterpolator = function (_TransitionInterpolat) {\n  _inherits(LinearInterpolator, _TransitionInterpolat);\n  var _super = linear_interpolator_createSuper(LinearInterpolator);\n  function LinearInterpolator() {\n    var _this;\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, LinearInterpolator);\n    _this = _super.call(this);\n    if (Array.isArray(opts)) {\n      opts = {\n        transitionProps: opts\n      };\n    }\n    _this.propNames = opts.transitionProps || linear_interpolator_VIEWPORT_TRANSITION_PROPS;\n    if (opts.around) {\n      _this.around = opts.around;\n    }\n    return _this;\n  }\n  _createClass(LinearInterpolator, [{\n    key: \"initializeProps\",\n    value: function initializeProps(startProps, endProps) {\n      var startViewportProps = {};\n      var endViewportProps = {};\n      if (this.around) {\n        startViewportProps.around = this.around;\n        var aroundLngLat = new WebMercatorViewport(startProps).unproject(this.around);\n        Object.assign(endViewportProps, endProps, {\n          around: new WebMercatorViewport(endProps).project(aroundLngLat),\n          aroundLngLat: aroundLngLat\n        });\n      }\n      var _iterator = linear_interpolator_createForOfIteratorHelper(this.propNames),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          var startValue = startProps[key];\n          var endValue = endProps[key];\n          utils_assert_assert(isValid(startValue) && isValid(endValue), \"\".concat(key, \" must be supplied for transition\"));\n          startViewportProps[key] = startValue;\n          endViewportProps[key] = getEndValueByShortestPath(key, startValue, endValue);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return {\n        start: startViewportProps,\n        end: endViewportProps\n      };\n    }\n  }, {\n    key: \"interpolateProps\",\n    value: function interpolateProps(startProps, endProps, t) {\n      var viewport = {};\n      var _iterator2 = linear_interpolator_createForOfIteratorHelper(this.propNames),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var key = _step2.value;\n          viewport[key] = utils_math_utils_lerp(startProps[key], endProps[key], t);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      if (endProps.around) {\n        var _WebMercatorViewport$ = new WebMercatorViewport(Object.assign({}, endProps, viewport)).getMapCenterByLngLatPosition({\n            lngLat: endProps.aroundLngLat,\n            pos: utils_math_utils_lerp(startProps.around, endProps.around, t)\n          }),\n          _WebMercatorViewport$2 = _slicedToArray(_WebMercatorViewport$, 2),\n          longitude = _WebMercatorViewport$2[0],\n          latitude = _WebMercatorViewport$2[1];\n        viewport.longitude = longitude;\n        viewport.latitude = latitude;\n      }\n      return viewport;\n    }\n  }]);\n  return LinearInterpolator;\n}(TransitionInterpolator);\n\n;// ./node_modules/react-map-gl/dist/esm/utils/transition/index.js\n\n\n\n;// ./node_modules/react-map-gl/dist/esm/utils/transition-manager.js\n\n\n\n\n\n\nvar transition_manager_noop = function noop() {};\nfunction cropEasingFunction(easing, x0) {\n  var y0 = easing(x0);\n  return function (t) {\n    return 1 / (1 - y0) * (easing(t * (1 - x0) + x0) - y0);\n  };\n}\nvar TRANSITION_EVENTS = {\n  BREAK: 1,\n  SNAP_TO_END: 2,\n  IGNORE: 3,\n  UPDATE: 4\n};\nvar DEFAULT_PROPS = {\n  transitionDuration: 0,\n  transitionEasing: function transitionEasing(t) {\n    return t;\n  },\n  transitionInterpolator: new LinearInterpolator(),\n  transitionInterruption: TRANSITION_EVENTS.BREAK,\n  onTransitionStart: transition_manager_noop,\n  onTransitionInterrupt: transition_manager_noop,\n  onTransitionEnd: transition_manager_noop\n};\nvar TransitionManager = function () {\n  function TransitionManager() {\n    var _this = this;\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, TransitionManager);\n    _defineProperty(this, \"_animationFrame\", null);\n    _defineProperty(this, \"_onTransitionFrame\", function () {\n      _this._animationFrame = requestAnimationFrame(_this._onTransitionFrame);\n      _this._updateViewport();\n    });\n    this.props = null;\n    this.onViewportChange = opts.onViewportChange || transition_manager_noop;\n    this.onStateChange = opts.onStateChange || transition_manager_noop;\n    this.time = opts.getTime || Date.now;\n  }\n  _createClass(TransitionManager, [{\n    key: \"getViewportInTransition\",\n    value: function getViewportInTransition() {\n      return this._animationFrame ? this.state.propsInTransition : null;\n    }\n  }, {\n    key: \"processViewportChange\",\n    value: function processViewportChange(nextProps) {\n      var currentProps = this.props;\n      this.props = nextProps;\n      if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n        return false;\n      }\n      if (this._isTransitionEnabled(nextProps)) {\n        var startProps = Object.assign({}, currentProps);\n        var endProps = Object.assign({}, nextProps);\n        if (this._isTransitionInProgress()) {\n          currentProps.onTransitionInterrupt();\n          if (this.state.interruption === TRANSITION_EVENTS.SNAP_TO_END) {\n            Object.assign(startProps, this.state.endProps);\n          } else {\n            Object.assign(startProps, this.state.propsInTransition);\n          }\n          if (this.state.interruption === TRANSITION_EVENTS.UPDATE) {\n            var currentTime = this.time();\n            var x0 = (currentTime - this.state.startTime) / this.state.duration;\n            endProps.transitionDuration = this.state.duration - (currentTime - this.state.startTime);\n            endProps.transitionEasing = cropEasingFunction(this.state.easing, x0);\n            endProps.transitionInterpolator = startProps.transitionInterpolator;\n          }\n        }\n        endProps.onTransitionStart();\n        this._triggerTransition(startProps, endProps);\n        return true;\n      }\n      if (this._isTransitionInProgress()) {\n        currentProps.onTransitionInterrupt();\n        this._endTransition();\n      }\n      return false;\n    }\n  }, {\n    key: \"_isTransitionInProgress\",\n    value: function _isTransitionInProgress() {\n      return Boolean(this._animationFrame);\n    }\n  }, {\n    key: \"_isTransitionEnabled\",\n    value: function _isTransitionEnabled(props) {\n      var transitionDuration = props.transitionDuration,\n        transitionInterpolator = props.transitionInterpolator;\n      return (transitionDuration > 0 || transitionDuration === 'auto') && Boolean(transitionInterpolator);\n    }\n  }, {\n    key: \"_isUpdateDueToCurrentTransition\",\n    value: function _isUpdateDueToCurrentTransition(props) {\n      if (this.state.propsInTransition) {\n        return this.state.interpolator.arePropsEqual(props, this.state.propsInTransition);\n      }\n      return false;\n    }\n  }, {\n    key: \"_shouldIgnoreViewportChange\",\n    value: function _shouldIgnoreViewportChange(currentProps, nextProps) {\n      if (!currentProps) {\n        return true;\n      }\n      if (this._isTransitionInProgress()) {\n        return this.state.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);\n      }\n      if (this._isTransitionEnabled(nextProps)) {\n        return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);\n      }\n      return true;\n    }\n  }, {\n    key: \"_triggerTransition\",\n    value: function _triggerTransition(startProps, endProps) {\n      utils_assert_assert(this._isTransitionEnabled(endProps));\n      if (this._animationFrame) {\n        cancelAnimationFrame(this._animationFrame);\n      }\n      var transitionInterpolator = endProps.transitionInterpolator;\n      var duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;\n      if (duration === 0) {\n        return;\n      }\n      var initialProps = endProps.transitionInterpolator.initializeProps(startProps, endProps);\n      var interactionState = {\n        inTransition: true,\n        isZooming: startProps.zoom !== endProps.zoom,\n        isPanning: startProps.longitude !== endProps.longitude || startProps.latitude !== endProps.latitude,\n        isRotating: startProps.bearing !== endProps.bearing || startProps.pitch !== endProps.pitch\n      };\n      this.state = {\n        duration: duration,\n        easing: endProps.transitionEasing,\n        interpolator: endProps.transitionInterpolator,\n        interruption: endProps.transitionInterruption,\n        startTime: this.time(),\n        startProps: initialProps.start,\n        endProps: initialProps.end,\n        animation: null,\n        propsInTransition: {}\n      };\n      this._onTransitionFrame();\n      this.onStateChange(interactionState);\n    }\n  }, {\n    key: \"_endTransition\",\n    value: function _endTransition() {\n      if (this._animationFrame) {\n        cancelAnimationFrame(this._animationFrame);\n        this._animationFrame = null;\n      }\n      this.onStateChange({\n        inTransition: false,\n        isZooming: false,\n        isPanning: false,\n        isRotating: false\n      });\n    }\n  }, {\n    key: \"_updateViewport\",\n    value: function _updateViewport() {\n      var currentTime = this.time();\n      var _this$state = this.state,\n        startTime = _this$state.startTime,\n        duration = _this$state.duration,\n        easing = _this$state.easing,\n        interpolator = _this$state.interpolator,\n        startProps = _this$state.startProps,\n        endProps = _this$state.endProps;\n      var shouldEnd = false;\n      var t = (currentTime - startTime) / duration;\n      if (t >= 1) {\n        t = 1;\n        shouldEnd = true;\n      }\n      t = easing(t);\n      var viewport = interpolator.interpolateProps(startProps, endProps, t);\n      var mapState = new MapState(Object.assign({}, this.props, viewport));\n      this.state.propsInTransition = mapState.getViewportProps();\n      this.onViewportChange(this.state.propsInTransition, this.props);\n      if (shouldEnd) {\n        this._endTransition();\n        this.props.onTransitionEnd();\n      }\n    }\n  }]);\n  return TransitionManager;\n}();\n_defineProperty(TransitionManager, \"defaultProps\", DEFAULT_PROPS);\n\n// EXTERNAL MODULE: ./node_modules/hammerjs/hammer.js\nvar hammer = __webpack_require__(75645);\n;// ./node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js\n/**\n * This file contains overrides the default\n * hammer.js functions to add our own utility\n */\n/* eslint-disable */\n/* Hammer.js constants */\nconst INPUT_START = 1;\nconst INPUT_MOVE = 2;\nconst INPUT_END = 4;\nconst MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\n/**\n * Helper function that returns true if any element in an array meets given criteria.\n * Because older browsers do not support `Array.prototype.some`\n * @params array {Array}\n * @params predict {Function}\n */\nfunction some(array, predict) {\n  for (let i = 0; i < array.length; i++) {\n    if (predict(array[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n/* eslint-disable no-invalid-this */\nfunction enhancePointerEventInput(PointerEventInput) {\n  const oldHandler = PointerEventInput.prototype.handler;\n  // overrides PointerEventInput.handler to accept right mouse button\n  PointerEventInput.prototype.handler = function handler(ev) {\n    const store = this.store;\n    // Allow non-left mouse buttons through\n    if (ev.button > 0 && ev.type === 'pointerdown') {\n      if (!some(store, e => e.pointerId === ev.pointerId)) {\n        store.push(ev);\n      }\n    }\n    oldHandler.call(this, ev);\n  };\n}\n// overrides MouseInput.handler to accept right mouse button\nfunction enhanceMouseInput(MouseInput) {\n  MouseInput.prototype.handler = function handler(ev) {\n    let eventType = MOUSE_INPUT_MAP[ev.type];\n    // on start we want to have the mouse button down\n    if (eventType & INPUT_START && ev.button >= 0) {\n      this.pressed = true;\n    }\n    if (eventType & INPUT_MOVE && ev.buttons === 0) {\n      eventType = INPUT_END;\n    }\n    // mouse must be down\n    if (!this.pressed) {\n      return;\n    }\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: 'mouse',\n      srcEvent: ev\n    });\n  };\n}\n;// ./node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js\n\n\nenhancePointerEventInput(hammer.PointerEventInput);\nenhanceMouseInput(hammer.MouseInput);\nconst Manager = hammer.Manager;\n/* harmony default export */ var hammer_browser = (hammer);\n;// ./node_modules/mjolnir.js/dist/esm/inputs/input.js\nclass Input {\n  constructor(element, callback, options) {\n    this.element = element;\n    this.callback = callback;\n    this.options = {\n      enable: true,\n      ...options\n    };\n  }\n}\n;// ./node_modules/mjolnir.js/dist/esm/constants.js\n\n// This module contains constants that must be conditionally required\n// due to `window`/`document` references downstream.\nconst RECOGNIZERS = hammer_browser ? [[hammer_browser.Pan, {\n  event: 'tripan',\n  pointers: 3,\n  threshold: 0,\n  enable: false\n}], [hammer_browser.Rotate, {\n  enable: false\n}], [hammer_browser.Pinch, {\n  enable: false\n}], [hammer_browser.Swipe, {\n  enable: false\n}], [hammer_browser.Pan, {\n  threshold: 0,\n  enable: false\n}], [hammer_browser.Press, {\n  enable: false\n}], [hammer_browser.Tap, {\n  event: 'doubletap',\n  taps: 2,\n  enable: false\n}],\n// TODO - rename to 'tap' and 'singletap' in the next major release\n[hammer_browser.Tap, {\n  event: 'anytap',\n  enable: false\n}], [hammer_browser.Tap, {\n  enable: false\n}]] : null;\n// Recognize the following gestures even if a given recognizer succeeds\nconst RECOGNIZER_COMPATIBLE_MAP = {\n  tripan: ['rotate', 'pinch', 'pan'],\n  rotate: ['pinch'],\n  pinch: ['pan'],\n  pan: ['press', 'doubletap', 'anytap', 'tap'],\n  doubletap: ['anytap'],\n  anytap: ['tap']\n};\n// Recognize the folling gestures only if a given recognizer fails\nconst RECOGNIZER_FALLBACK_MAP = {\n  doubletap: ['tap']\n};\n/**\n * Only one set of basic input events will be fired by Hammer.js:\n * either pointer, touch, or mouse, depending on system support.\n * In order to enable an application to be agnostic of system support,\n * alias basic input events into \"classes\" of events: down, move, and up.\n * See `_onBasicInput()` for usage of these aliases.\n */\nconst BASIC_EVENT_ALIASES = {\n  pointerdown: 'pointerdown',\n  pointermove: 'pointermove',\n  pointerup: 'pointerup',\n  touchstart: 'pointerdown',\n  touchmove: 'pointermove',\n  touchend: 'pointerup',\n  mousedown: 'pointerdown',\n  mousemove: 'pointermove',\n  mouseup: 'pointerup'\n};\nconst INPUT_EVENT_TYPES = {\n  KEY_EVENTS: ['keydown', 'keyup'],\n  MOUSE_EVENTS: ['mousedown', 'mousemove', 'mouseup', 'mouseover', 'mouseout', 'mouseleave'],\n  WHEEL_EVENTS: [\n  // Chrome, Safari\n  'wheel',\n  // IE\n  'mousewheel']\n};\n/**\n * \"Gestural\" events are those that have semantic meaning beyond the basic input event,\n * e.g. a click or tap is a sequence of `down` and `up` events with no `move` event in between.\n * Hammer.js handles these with its Recognizer system;\n * this block maps event names to the Recognizers required to detect the events.\n */\nconst EVENT_RECOGNIZER_MAP = {\n  tap: 'tap',\n  anytap: 'anytap',\n  doubletap: 'doubletap',\n  press: 'press',\n  pinch: 'pinch',\n  pinchin: 'pinch',\n  pinchout: 'pinch',\n  pinchstart: 'pinch',\n  pinchmove: 'pinch',\n  pinchend: 'pinch',\n  pinchcancel: 'pinch',\n  rotate: 'rotate',\n  rotatestart: 'rotate',\n  rotatemove: 'rotate',\n  rotateend: 'rotate',\n  rotatecancel: 'rotate',\n  tripan: 'tripan',\n  tripanstart: 'tripan',\n  tripanmove: 'tripan',\n  tripanup: 'tripan',\n  tripandown: 'tripan',\n  tripanleft: 'tripan',\n  tripanright: 'tripan',\n  tripanend: 'tripan',\n  tripancancel: 'tripan',\n  pan: 'pan',\n  panstart: 'pan',\n  panmove: 'pan',\n  panup: 'pan',\n  pandown: 'pan',\n  panleft: 'pan',\n  panright: 'pan',\n  panend: 'pan',\n  pancancel: 'pan',\n  swipe: 'swipe',\n  swipeleft: 'swipe',\n  swiperight: 'swipe',\n  swipeup: 'swipe',\n  swipedown: 'swipe'\n};\n/**\n * Map gestural events typically provided by browsers\n * that are not reported in 'hammer.input' events\n * to corresponding Hammer.js gestures.\n */\nconst GESTURE_EVENT_ALIASES = {\n  click: 'tap',\n  anyclick: 'anytap',\n  dblclick: 'doubletap',\n  mousedown: 'pointerdown',\n  mousemove: 'pointermove',\n  mouseup: 'pointerup',\n  mouseover: 'pointerover',\n  mouseout: 'pointerout',\n  mouseleave: 'pointerleave'\n};\n;// ./node_modules/mjolnir.js/dist/esm/utils/globals.js\n// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global'\n/* global window, global, document, navigator */\nconst userAgent = typeof navigator !== 'undefined' && navigator.userAgent ? navigator.userAgent.toLowerCase() : '';\nconst globals_window_ = typeof window !== 'undefined' ? window : __webpack_require__.g;\nconst globals_global_ = typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : window;\nconst globals_document_ = typeof document !== 'undefined' ? document : {};\n\n/*\n * Detect whether passive option is supported by the current browser.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n   #Safely_detecting_option_support\n */\nlet passiveSupported = false;\n/* eslint-disable accessor-pairs, no-empty */\ntry {\n  const options = {\n    // This function will be called when the browser\n    // attempts to access the passive property.\n    get passive() {\n      passiveSupported = true;\n      return true;\n    }\n  };\n  globals_window_.addEventListener('test', null, options);\n  globals_window_.removeEventListener('test', null);\n} catch (err) {\n  passiveSupported = false;\n}\n\n;// ./node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js\n\n\n\nconst firefox = userAgent.indexOf('firefox') !== -1;\nconst {\n  WHEEL_EVENTS\n} = INPUT_EVENT_TYPES;\nconst EVENT_TYPE = 'wheel';\n// Constants for normalizing input delta\nconst WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;\nconst WHEEL_DELTA_PER_LINE = 40;\n// Slow down zoom if shift key is held for more precise zooming\nconst SHIFT_MULTIPLIER = 0.25;\nclass WheelInput extends Input {\n  constructor(element, callback, options) {\n    super(element, callback, options);\n    /* eslint-disable complexity, max-statements */\n    this.handleEvent = event => {\n      if (!this.options.enable) {\n        return;\n      }\n      let value = event.deltaY;\n      if (globals_window_.WheelEvent) {\n        // Firefox doubles the values on retina screens...\n        if (firefox && event.deltaMode === globals_window_.WheelEvent.DOM_DELTA_PIXEL) {\n          value /= globals_window_.devicePixelRatio;\n        }\n        if (event.deltaMode === globals_window_.WheelEvent.DOM_DELTA_LINE) {\n          value *= WHEEL_DELTA_PER_LINE;\n        }\n      }\n      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {\n        // This one is definitely a mouse wheel event.\n        // Normalize this value to match trackpad.\n        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);\n      }\n      if (event.shiftKey && value) {\n        value = value * SHIFT_MULTIPLIER;\n      }\n      this.callback({\n        type: EVENT_TYPE,\n        center: {\n          x: event.clientX,\n          y: event.clientY\n        },\n        delta: -value,\n        srcEvent: event,\n        pointerType: 'mouse',\n        target: event.target\n      });\n    };\n    this.events = (this.options.events || []).concat(WHEEL_EVENTS);\n    this.events.forEach(event => element.addEventListener(event, this.handleEvent, passiveSupported ? {\n      passive: false\n    } : false));\n  }\n  destroy() {\n    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n  }\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType, enabled) {\n    if (eventType === EVENT_TYPE) {\n      this.options.enable = enabled;\n    }\n  }\n}\n;// ./node_modules/mjolnir.js/dist/esm/inputs/move-input.js\n\n\nconst {\n  MOUSE_EVENTS\n} = INPUT_EVENT_TYPES;\nconst MOVE_EVENT_TYPE = 'pointermove';\nconst OVER_EVENT_TYPE = 'pointerover';\nconst OUT_EVENT_TYPE = 'pointerout';\nconst ENTER_EVENT_TYPE = 'pointerenter';\nconst LEAVE_EVENT_TYPE = 'pointerleave';\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\nclass MoveInput extends Input {\n  constructor(element, callback, options) {\n    super(element, callback, options);\n    this.handleEvent = event => {\n      this.handleOverEvent(event);\n      this.handleOutEvent(event);\n      this.handleEnterEvent(event);\n      this.handleLeaveEvent(event);\n      this.handleMoveEvent(event);\n    };\n    this.pressed = false;\n    const {\n      enable\n    } = this.options;\n    this.enableMoveEvent = enable;\n    this.enableLeaveEvent = enable;\n    this.enableEnterEvent = enable;\n    this.enableOutEvent = enable;\n    this.enableOverEvent = enable;\n    this.events = (this.options.events || []).concat(MOUSE_EVENTS);\n    this.events.forEach(event => element.addEventListener(event, this.handleEvent));\n  }\n  destroy() {\n    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n  }\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType, enabled) {\n    if (eventType === MOVE_EVENT_TYPE) {\n      this.enableMoveEvent = enabled;\n    }\n    if (eventType === OVER_EVENT_TYPE) {\n      this.enableOverEvent = enabled;\n    }\n    if (eventType === OUT_EVENT_TYPE) {\n      this.enableOutEvent = enabled;\n    }\n    if (eventType === ENTER_EVENT_TYPE) {\n      this.enableEnterEvent = enabled;\n    }\n    if (eventType === LEAVE_EVENT_TYPE) {\n      this.enableLeaveEvent = enabled;\n    }\n  }\n  handleOverEvent(event) {\n    if (this.enableOverEvent) {\n      if (event.type === 'mouseover') {\n        this._emit(OVER_EVENT_TYPE, event);\n      }\n    }\n  }\n  handleOutEvent(event) {\n    if (this.enableOutEvent) {\n      if (event.type === 'mouseout') {\n        this._emit(OUT_EVENT_TYPE, event);\n      }\n    }\n  }\n  handleEnterEvent(event) {\n    if (this.enableEnterEvent) {\n      if (event.type === 'mouseenter') {\n        this._emit(ENTER_EVENT_TYPE, event);\n      }\n    }\n  }\n  handleLeaveEvent(event) {\n    if (this.enableLeaveEvent) {\n      if (event.type === 'mouseleave') {\n        this._emit(LEAVE_EVENT_TYPE, event);\n      }\n    }\n  }\n  handleMoveEvent(event) {\n    if (this.enableMoveEvent) {\n      switch (event.type) {\n        case 'mousedown':\n          if (event.button >= 0) {\n            // Button is down\n            this.pressed = true;\n          }\n          break;\n        case 'mousemove':\n          // Move events use `bottons` to track the button being pressed\n          if (event.buttons === 0) {\n            // Button is not down\n            this.pressed = false;\n          }\n          if (!this.pressed) {\n            // Drag events are emitted by hammer already\n            // we just need to emit the move event on hover\n            this._emit(MOVE_EVENT_TYPE, event);\n          }\n          break;\n        case 'mouseup':\n          this.pressed = false;\n          break;\n        default:\n      }\n    }\n  }\n  _emit(type, event) {\n    this.callback({\n      type,\n      center: {\n        x: event.clientX,\n        y: event.clientY\n      },\n      srcEvent: event,\n      pointerType: 'mouse',\n      target: event.target\n    });\n  }\n}\n;// ./node_modules/mjolnir.js/dist/esm/inputs/key-input.js\n\n\nconst {\n  KEY_EVENTS\n} = INPUT_EVENT_TYPES;\nconst DOWN_EVENT_TYPE = 'keydown';\nconst UP_EVENT_TYPE = 'keyup';\nclass KeyInput extends Input {\n  constructor(element, callback, options) {\n    super(element, callback, options);\n    this.handleEvent = event => {\n      // Ignore if focused on text input\n      const targetElement = event.target || event.srcElement;\n      if (targetElement.tagName === 'INPUT' && targetElement.type === 'text' || targetElement.tagName === 'TEXTAREA') {\n        return;\n      }\n      if (this.enableDownEvent && event.type === 'keydown') {\n        this.callback({\n          type: DOWN_EVENT_TYPE,\n          srcEvent: event,\n          key: event.key,\n          target: event.target\n        });\n      }\n      if (this.enableUpEvent && event.type === 'keyup') {\n        this.callback({\n          type: UP_EVENT_TYPE,\n          srcEvent: event,\n          key: event.key,\n          target: event.target\n        });\n      }\n    };\n    this.enableDownEvent = this.options.enable;\n    this.enableUpEvent = this.options.enable;\n    this.events = (this.options.events || []).concat(KEY_EVENTS);\n    element.tabIndex = this.options.tabIndex || 0;\n    element.style.outline = 'none';\n    this.events.forEach(event => element.addEventListener(event, this.handleEvent));\n  }\n  destroy() {\n    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n  }\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType, enabled) {\n    if (eventType === DOWN_EVENT_TYPE) {\n      this.enableDownEvent = enabled;\n    }\n    if (eventType === UP_EVENT_TYPE) {\n      this.enableUpEvent = enabled;\n    }\n  }\n}\n;// ./node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js\n\nconst contextmenu_input_EVENT_TYPE = 'contextmenu';\nclass ContextmenuInput extends Input {\n  constructor(element, callback, options) {\n    super(element, callback, options);\n    this.handleEvent = event => {\n      if (!this.options.enable) {\n        return;\n      }\n      this.callback({\n        type: contextmenu_input_EVENT_TYPE,\n        center: {\n          x: event.clientX,\n          y: event.clientY\n        },\n        srcEvent: event,\n        pointerType: 'mouse',\n        target: event.target\n      });\n    };\n    element.addEventListener('contextmenu', this.handleEvent);\n  }\n  destroy() {\n    this.element.removeEventListener('contextmenu', this.handleEvent);\n  }\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType, enabled) {\n    if (eventType === contextmenu_input_EVENT_TYPE) {\n      this.options.enable = enabled;\n    }\n  }\n}\n;// ./node_modules/mjolnir.js/dist/esm/utils/event-utils.js\n/* Constants */\nconst DOWN_EVENT = 1;\nconst MOVE_EVENT = 2;\nconst UP_EVENT = 4;\nconst event_utils_MOUSE_EVENTS = {\n  pointerdown: DOWN_EVENT,\n  pointermove: MOVE_EVENT,\n  pointerup: UP_EVENT,\n  mousedown: DOWN_EVENT,\n  mousemove: MOVE_EVENT,\n  mouseup: UP_EVENT\n};\n// MouseEvent.button https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\nconst MOUSE_EVENT_BUTTON_LEFT = 0;\nconst MOUSE_EVENT_BUTTON_MIDDLE = 1;\nconst MOUSE_EVENT_BUTTON_RIGHT = 2;\n// MouseEvent.buttons https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\nconst MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;\nconst MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;\nconst MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;\n/**\n * Extract the involved mouse button\n */\nfunction whichButtons(event) {\n  const eventType = event_utils_MOUSE_EVENTS[event.srcEvent.type];\n  if (!eventType) {\n    // Not a mouse evet\n    return null;\n  }\n  const {\n    buttons,\n    button\n  } = event.srcEvent;\n  let leftButton = false;\n  let middleButton = false;\n  let rightButton = false;\n  if (eventType === MOVE_EVENT) {\n    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);\n    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);\n    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);\n  } else {\n    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;\n    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;\n    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;\n  }\n  return {\n    leftButton,\n    middleButton,\n    rightButton\n  };\n}\n/**\n * Calculate event position relative to the root element\n */\nfunction getOffsetPosition(event, rootElement) {\n  const center = event.center;\n  // `center` is a hammer.js event property\n  if (!center) {\n    // Not a gestural event\n    return null;\n  }\n  const rect = rootElement.getBoundingClientRect();\n  // Fix scale for map affected by a CSS transform.\n  // See https://stackoverflow.com/a/26893663/3528533\n  const scaleX = rect.width / rootElement.offsetWidth || 1;\n  const scaleY = rect.height / rootElement.offsetHeight || 1;\n  // Calculate center relative to the root element\n  const offsetCenter = {\n    x: (center.x - rect.left - rootElement.clientLeft) / scaleX,\n    y: (center.y - rect.top - rootElement.clientTop) / scaleY\n  };\n  return {\n    center,\n    offsetCenter\n  };\n}\n;// ./node_modules/mjolnir.js/dist/esm/utils/event-registrar.js\n\nconst DEFAULT_OPTIONS = {\n  srcElement: 'root',\n  priority: 0\n};\nclass EventRegistrar {\n  constructor(eventManager) {\n    /**\n     * Handles hammerjs event\n     */\n    this.handleEvent = event => {\n      if (this.isEmpty()) {\n        return;\n      }\n      const mjolnirEvent = this._normalizeEvent(event);\n      let target = event.srcEvent.target;\n      while (target && target !== mjolnirEvent.rootElement) {\n        this._emit(mjolnirEvent, target);\n        if (mjolnirEvent.handled) {\n          return;\n        }\n        target = target.parentNode;\n      }\n      this._emit(mjolnirEvent, 'root');\n    };\n    this.eventManager = eventManager;\n    this.handlers = [];\n    // Element -> handler map\n    this.handlersByElement = new Map();\n    this._active = false;\n  }\n  // Returns true if there are no non-passive handlers\n  isEmpty() {\n    return !this._active;\n  }\n  add(type, handler, options) {\n    let once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let passive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const {\n      handlers,\n      handlersByElement\n    } = this;\n    let opts = DEFAULT_OPTIONS;\n    if (typeof options === 'string' || options && options.addEventListener) {\n      // is DOM element, backward compatibility\n      // @ts-ignore\n      opts = {\n        ...DEFAULT_OPTIONS,\n        srcElement: options\n      };\n    } else if (options) {\n      opts = {\n        ...DEFAULT_OPTIONS,\n        ...options\n      };\n    }\n    let entries = handlersByElement.get(opts.srcElement);\n    if (!entries) {\n      entries = [];\n      handlersByElement.set(opts.srcElement, entries);\n    }\n    const entry = {\n      type,\n      handler,\n      srcElement: opts.srcElement,\n      priority: opts.priority\n    };\n    if (once) {\n      entry.once = true;\n    }\n    if (passive) {\n      entry.passive = true;\n    }\n    handlers.push(entry);\n    this._active = this._active || !entry.passive;\n    // Sort handlers by descending priority\n    // Handlers with the same priority are excuted in the order of registration\n    let insertPosition = entries.length - 1;\n    while (insertPosition >= 0) {\n      if (entries[insertPosition].priority >= entry.priority) {\n        break;\n      }\n      insertPosition--;\n    }\n    entries.splice(insertPosition + 1, 0, entry);\n  }\n  remove(type, handler) {\n    const {\n      handlers,\n      handlersByElement\n    } = this;\n    for (let i = handlers.length - 1; i >= 0; i--) {\n      const entry = handlers[i];\n      if (entry.type === type && entry.handler === handler) {\n        handlers.splice(i, 1);\n        const entries = handlersByElement.get(entry.srcElement);\n        entries.splice(entries.indexOf(entry), 1);\n        if (entries.length === 0) {\n          handlersByElement.delete(entry.srcElement);\n        }\n      }\n    }\n    this._active = handlers.some(entry => !entry.passive);\n  }\n  /**\n   * Invoke handlers on a particular element\n   */\n  _emit(event, srcElement) {\n    const entries = this.handlersByElement.get(srcElement);\n    if (entries) {\n      let immediatePropagationStopped = false;\n      // Prevents the current event from bubbling up\n      const stopPropagation = () => {\n        event.handled = true;\n      };\n      // Prevent any remaining listeners from being called\n      const stopImmediatePropagation = () => {\n        event.handled = true;\n        immediatePropagationStopped = true;\n      };\n      const entriesToRemove = [];\n      for (let i = 0; i < entries.length; i++) {\n        const {\n          type,\n          handler,\n          once\n        } = entries[i];\n        handler({\n          ...event,\n          // @ts-ignore\n          type,\n          stopPropagation,\n          stopImmediatePropagation\n        });\n        if (once) {\n          entriesToRemove.push(entries[i]);\n        }\n        if (immediatePropagationStopped) {\n          break;\n        }\n      }\n      for (let i = 0; i < entriesToRemove.length; i++) {\n        const {\n          type,\n          handler\n        } = entriesToRemove[i];\n        this.remove(type, handler);\n      }\n    }\n  }\n  /**\n   * Normalizes hammerjs and custom events to have predictable fields.\n   */\n  _normalizeEvent(event) {\n    const rootElement = this.eventManager.getElement();\n    return {\n      ...event,\n      ...whichButtons(event),\n      ...getOffsetPosition(event, rootElement),\n      preventDefault: () => {\n        event.srcEvent.preventDefault();\n      },\n      stopImmediatePropagation: null,\n      stopPropagation: null,\n      handled: false,\n      rootElement\n    };\n  }\n}\n;// ./node_modules/mjolnir.js/dist/esm/event-manager.js\n\n\n\n\n\n\n\nconst event_manager_DEFAULT_OPTIONS = {\n  // event handlers\n  events: null,\n  // custom recognizers\n  recognizers: null,\n  recognizerOptions: {},\n  // Manager class\n  Manager: Manager,\n  // allow browser default touch action\n  // https://github.com/uber/react-map-gl/issues/506\n  touchAction: 'none',\n  tabIndex: 0\n};\n// Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\nclass EventManager {\n  constructor() {\n    let element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n    /**\n     * Handle basic events using the 'hammer.input' Hammer.js API:\n     * Before running Recognizers, Hammer emits a 'hammer.input' event\n     * with the basic event info. This function emits all basic events\n     * aliased to the \"class\" of event received.\n     * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n     */\n    this._onBasicInput = event => {\n      const {\n        srcEvent\n      } = event;\n      const alias = BASIC_EVENT_ALIASES[srcEvent.type];\n      if (alias) {\n        // fire all events aliased to srcEvent.type\n        this.manager.emit(alias, event);\n      }\n    };\n    /**\n     * Handle events not supported by Hammer.js,\n     * and pipe back out through same (Hammer) channel used by other events.\n     */\n    this._onOtherEvent = event => {\n      // console.log('onotherevent', event.type, event)\n      this.manager.emit(event.type, event);\n    };\n    this.options = {\n      ...event_manager_DEFAULT_OPTIONS,\n      ...options\n    };\n    this.events = new Map();\n    this.setElement(element);\n    // Register all passed events.\n    const {\n      events\n    } = this.options;\n    if (events) {\n      this.on(events);\n    }\n  }\n  getElement() {\n    return this.element;\n  }\n  setElement(element) {\n    if (this.element) {\n      // unregister all events\n      this.destroy();\n    }\n    this.element = element;\n    if (!element) {\n      return;\n    }\n    const {\n      options\n    } = this;\n    const ManagerClass = options.Manager;\n    this.manager = new ManagerClass(element, {\n      touchAction: options.touchAction,\n      recognizers: options.recognizers || RECOGNIZERS\n    }).on('hammer.input', this._onBasicInput);\n    if (!options.recognizers) {\n      // Set default recognize withs\n      // http://hammerjs.github.io/recognize-with/\n      Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(name => {\n        const recognizer = this.manager.get(name);\n        if (recognizer) {\n          RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {\n            recognizer.recognizeWith(otherName);\n          });\n        }\n      });\n    }\n    // Set recognizer options\n    for (const recognizerName in options.recognizerOptions) {\n      const recognizer = this.manager.get(recognizerName);\n      if (recognizer) {\n        const recognizerOption = options.recognizerOptions[recognizerName];\n        // `enable` is managed by the event registrations\n        delete recognizerOption.enable;\n        recognizer.set(recognizerOption);\n      }\n    }\n    // Handle events not handled by Hammer.js:\n    // - mouse wheel\n    // - pointer/touch/mouse move\n    this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.moveInput = new MoveInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.keyInput = new KeyInput(element, this._onOtherEvent, {\n      enable: false,\n      tabIndex: options.tabIndex\n    });\n    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    // Register all existing events\n    for (const [eventAlias, eventRegistrar] of this.events) {\n      if (!eventRegistrar.isEmpty()) {\n        // Enable recognizer for this event.\n        this._toggleRecognizer(eventRegistrar.recognizerName, true);\n        this.manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n  }\n  // Tear down internal event management implementations.\n  destroy() {\n    if (this.element) {\n      // wheelInput etc. are created in setElement() and therefore\n      // cannot exist if there is no element\n      this.wheelInput.destroy();\n      this.moveInput.destroy();\n      this.keyInput.destroy();\n      this.contextmenuInput.destroy();\n      this.manager.destroy();\n      this.wheelInput = null;\n      this.moveInput = null;\n      this.keyInput = null;\n      this.contextmenuInput = null;\n      this.manager = null;\n      this.element = null;\n    }\n  }\n  /** Register an event handler function to be called on `event` */\n  on(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false);\n  }\n  once(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, true);\n  }\n  watch(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false, true);\n  }\n  off(event, handler) {\n    this._removeEventHandler(event, handler);\n  }\n  /*\n   * Enable/disable recognizer for the given event\n   */\n  _toggleRecognizer(name, enabled) {\n    const {\n      manager\n    } = this;\n    if (!manager) {\n      return;\n    }\n    const recognizer = manager.get(name);\n    // @ts-ignore\n    if (recognizer && recognizer.options.enable !== enabled) {\n      recognizer.set({\n        enable: enabled\n      });\n      const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];\n      if (fallbackRecognizers && !this.options.recognizers) {\n        // Set default require failures\n        // http://hammerjs.github.io/require-failure/\n        fallbackRecognizers.forEach(otherName => {\n          const otherRecognizer = manager.get(otherName);\n          if (enabled) {\n            // Wait for this recognizer to fail\n            otherRecognizer.requireFailure(name);\n            /**\n             * This seems to be a bug in hammerjs:\n             * requireFailure() adds both ways\n             * dropRequireFailure() only drops one way\n             * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/\n               recognizer-constructor.js#L136\n             */\n            recognizer.dropRequireFailure(otherName);\n          } else {\n            // Do not wait for this recognizer to fail\n            otherRecognizer.dropRequireFailure(name);\n          }\n        });\n      }\n    }\n    this.wheelInput.enableEventType(name, enabled);\n    this.moveInput.enableEventType(name, enabled);\n    this.keyInput.enableEventType(name, enabled);\n    this.contextmenuInput.enableEventType(name, enabled);\n  }\n  /**\n   * Process the event registration for a single event + handler.\n   */\n  _addEventHandler(event, handler, opts, once, passive) {\n    if (typeof event !== 'string') {\n      // @ts-ignore\n      opts = handler;\n      // If `event` is a map, call `on()` for each entry.\n      for (const eventName in event) {\n        this._addEventHandler(eventName, event[eventName], opts, once, passive);\n      }\n      return;\n    }\n    const {\n      manager,\n      events\n    } = this;\n    // Alias to a recognized gesture as necessary.\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n    let eventRegistrar = events.get(eventAlias);\n    if (!eventRegistrar) {\n      eventRegistrar = new EventRegistrar(this);\n      events.set(eventAlias, eventRegistrar);\n      // Enable recognizer for this event.\n      eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;\n      // Listen to the event\n      if (manager) {\n        manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n    eventRegistrar.add(event, handler, opts, once, passive);\n    if (!eventRegistrar.isEmpty()) {\n      this._toggleRecognizer(eventRegistrar.recognizerName, true);\n    }\n  }\n  /**\n   * Process the event deregistration for a single event + handler.\n   */\n  _removeEventHandler(event, handler) {\n    if (typeof event !== 'string') {\n      // If `event` is a map, call `off()` for each entry.\n      for (const eventName in event) {\n        this._removeEventHandler(eventName, event[eventName]);\n      }\n      return;\n    }\n    const {\n      events\n    } = this;\n    // Alias to a recognized gesture as necessary.\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n    const eventRegistrar = events.get(eventAlias);\n    if (!eventRegistrar) {\n      return;\n    }\n    eventRegistrar.remove(event, handler);\n    if (eventRegistrar.isEmpty()) {\n      const {\n        recognizerName\n      } = eventRegistrar;\n      // Disable recognizer if no more handlers are attached to its events\n      let isRecognizerUsed = false;\n      for (const eh of events.values()) {\n        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n          isRecognizerUsed = true;\n          break;\n        }\n      }\n      if (!isRecognizerUsed) {\n        this._toggleRecognizer(recognizerName, false);\n      }\n    }\n  }\n}\n;// ./node_modules/mjolnir.js/dist/esm/index.js\n\n;// ./node_modules/react-map-gl/dist/esm/utils/map-controller.js\n\n\n\nfunction map_controller_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction map_controller_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      map_controller_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      map_controller_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\nvar NO_TRANSITION_PROPS = {\n  transitionDuration: 0\n};\nvar LINEAR_TRANSITION_PROPS = {\n  transitionDuration: 300,\n  transitionEasing: function transitionEasing(t) {\n    return t;\n  },\n  transitionInterpolator: new LinearInterpolator(),\n  transitionInterruption: TRANSITION_EVENTS.BREAK\n};\nvar DEFAULT_INERTIA = 300;\nvar INERTIA_EASING = function INERTIA_EASING(t) {\n  return 1 - (1 - t) * (1 - t);\n};\nvar EVENT_TYPES = {\n  WHEEL: ['wheel'],\n  PAN: ['panstart', 'panmove', 'panend'],\n  PINCH: ['pinchstart', 'pinchmove', 'pinchend'],\n  TRIPLE_PAN: ['tripanstart', 'tripanmove', 'tripanend'],\n  DOUBLE_TAP: ['doubletap'],\n  KEYBOARD: ['keydown']\n};\nvar MapController = function () {\n  function MapController() {\n    var _this = this;\n    _classCallCheck(this, MapController);\n    _defineProperty(this, \"events\", []);\n    _defineProperty(this, \"scrollZoom\", true);\n    _defineProperty(this, \"dragPan\", true);\n    _defineProperty(this, \"dragRotate\", true);\n    _defineProperty(this, \"doubleClickZoom\", true);\n    _defineProperty(this, \"touchZoom\", true);\n    _defineProperty(this, \"touchRotate\", false);\n    _defineProperty(this, \"keyboard\", true);\n    _defineProperty(this, \"_interactionState\", {\n      isDragging: false\n    });\n    _defineProperty(this, \"_events\", {});\n    _defineProperty(this, \"_setInteractionState\", function (newState) {\n      Object.assign(_this._interactionState, newState);\n      if (_this.onStateChange) {\n        _this.onStateChange(_this._interactionState);\n      }\n    });\n    _defineProperty(this, \"_onTransition\", function (newViewport, oldViewport) {\n      _this.onViewportChange(newViewport, _this._interactionState, oldViewport);\n    });\n    this.handleEvent = this.handleEvent.bind(this);\n    this._transitionManager = new TransitionManager({\n      onViewportChange: this._onTransition,\n      onStateChange: this._setInteractionState\n    });\n  }\n  _createClass(MapController, [{\n    key: \"handleEvent\",\n    value: function handleEvent(event) {\n      this.mapState = this.getMapState();\n      var eventStartBlocked = this._eventStartBlocked;\n      switch (event.type) {\n        case 'panstart':\n          return eventStartBlocked ? false : this._onPanStart(event);\n        case 'panmove':\n          return this._onPan(event);\n        case 'panend':\n          return this._onPanEnd(event);\n        case 'pinchstart':\n          return eventStartBlocked ? false : this._onPinchStart(event);\n        case 'pinchmove':\n          return this._onPinch(event);\n        case 'pinchend':\n          return this._onPinchEnd(event);\n        case 'tripanstart':\n          return eventStartBlocked ? false : this._onTriplePanStart(event);\n        case 'tripanmove':\n          return this._onTriplePan(event);\n        case 'tripanend':\n          return this._onTriplePanEnd(event);\n        case 'doubletap':\n          return this._onDoubleTap(event);\n        case 'wheel':\n          return this._onWheel(event);\n        case 'keydown':\n          return this._onKeyDown(event);\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: \"getCenter\",\n    value: function getCenter(event) {\n      var _event$offsetCenter = event.offsetCenter,\n        x = _event$offsetCenter.x,\n        y = _event$offsetCenter.y;\n      return [x, y];\n    }\n  }, {\n    key: \"isFunctionKeyPressed\",\n    value: function isFunctionKeyPressed(event) {\n      var srcEvent = event.srcEvent;\n      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);\n    }\n  }, {\n    key: \"blockEvents\",\n    value: function blockEvents(timeout) {\n      var _this2 = this;\n      var timer = setTimeout(function () {\n        if (_this2._eventStartBlocked === timer) {\n          _this2._eventStartBlocked = null;\n        }\n      }, timeout);\n      this._eventStartBlocked = timer;\n    }\n  }, {\n    key: \"updateViewport\",\n    value: function updateViewport(newMapState, extraProps, interactionState) {\n      var oldViewport = this.mapState instanceof MapState ? this.mapState.getViewportProps() : this.mapState;\n      var newViewport = map_controller_objectSpread(map_controller_objectSpread({}, newMapState.getViewportProps()), extraProps);\n      var viewStateChanged = Object.keys(newViewport).some(function (key) {\n        return oldViewport[key] !== newViewport[key];\n      });\n      this._state = newMapState.getState();\n      this._setInteractionState(interactionState);\n      if (viewStateChanged) {\n        this.onViewportChange(newViewport, this._interactionState, oldViewport);\n      }\n    }\n  }, {\n    key: \"getMapState\",\n    value: function getMapState(overrides) {\n      return new MapState(map_controller_objectSpread(map_controller_objectSpread(map_controller_objectSpread({}, this.mapStateProps), this._state), overrides));\n    }\n  }, {\n    key: \"isDragging\",\n    value: function isDragging() {\n      return this._interactionState.isDragging;\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var onViewportChange = options.onViewportChange,\n        onStateChange = options.onStateChange,\n        _options$eventManager = options.eventManager,\n        eventManager = _options$eventManager === void 0 ? this.eventManager : _options$eventManager,\n        _options$isInteractiv = options.isInteractive,\n        isInteractive = _options$isInteractiv === void 0 ? true : _options$isInteractiv,\n        _options$scrollZoom = options.scrollZoom,\n        scrollZoom = _options$scrollZoom === void 0 ? this.scrollZoom : _options$scrollZoom,\n        _options$dragPan = options.dragPan,\n        dragPan = _options$dragPan === void 0 ? this.dragPan : _options$dragPan,\n        _options$dragRotate = options.dragRotate,\n        dragRotate = _options$dragRotate === void 0 ? this.dragRotate : _options$dragRotate,\n        _options$doubleClickZ = options.doubleClickZoom,\n        doubleClickZoom = _options$doubleClickZ === void 0 ? this.doubleClickZoom : _options$doubleClickZ,\n        _options$touchZoom = options.touchZoom,\n        touchZoom = _options$touchZoom === void 0 ? this.touchZoom : _options$touchZoom,\n        _options$touchRotate = options.touchRotate,\n        touchRotate = _options$touchRotate === void 0 ? this.touchRotate : _options$touchRotate,\n        _options$keyboard = options.keyboard,\n        keyboard = _options$keyboard === void 0 ? this.keyboard : _options$keyboard;\n      this.onViewportChange = onViewportChange;\n      this.onStateChange = onStateChange;\n      var prevOptions = this.mapStateProps || {};\n      var dimensionChanged = prevOptions.height !== options.height || prevOptions.width !== options.width;\n      this.mapStateProps = options;\n      if (dimensionChanged) {\n        this.mapState = prevOptions;\n        this.updateViewport(new MapState(options));\n      }\n      this._transitionManager.processViewportChange(options);\n      if (this.eventManager !== eventManager) {\n        this.eventManager = eventManager;\n        this._events = {};\n        this.toggleEvents(this.events, true);\n      }\n      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && Boolean(scrollZoom));\n      this.toggleEvents(EVENT_TYPES.PAN, isInteractive && Boolean(dragPan || dragRotate));\n      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && Boolean(touchZoom || touchRotate));\n      this.toggleEvents(EVENT_TYPES.TRIPLE_PAN, isInteractive && Boolean(touchRotate));\n      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && Boolean(doubleClickZoom));\n      this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && Boolean(keyboard));\n      this.scrollZoom = scrollZoom;\n      this.dragPan = dragPan;\n      this.dragRotate = dragRotate;\n      this.doubleClickZoom = doubleClickZoom;\n      this.touchZoom = touchZoom;\n      this.touchRotate = touchRotate;\n      this.keyboard = keyboard;\n    }\n  }, {\n    key: \"toggleEvents\",\n    value: function toggleEvents(eventNames, enabled) {\n      var _this3 = this;\n      if (this.eventManager) {\n        eventNames.forEach(function (eventName) {\n          if (_this3._events[eventName] !== enabled) {\n            _this3._events[eventName] = enabled;\n            if (enabled) {\n              _this3.eventManager.on(eventName, _this3.handleEvent);\n            } else {\n              _this3.eventManager.off(eventName, _this3.handleEvent);\n            }\n          }\n        });\n      }\n    }\n  }, {\n    key: \"_onPanStart\",\n    value: function _onPanStart(event) {\n      var pos = this.getCenter(event);\n      this._panRotate = this.isFunctionKeyPressed(event) || event.rightButton;\n      var newMapState = this._panRotate ? this.mapState.rotateStart({\n        pos: pos\n      }) : this.mapState.panStart({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isDragging: true\n      });\n      return true;\n    }\n  }, {\n    key: \"_onPan\",\n    value: function _onPan(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n      return this._panRotate ? this._onPanRotate(event) : this._onPanMove(event);\n    }\n  }, {\n    key: \"_onPanEnd\",\n    value: function _onPanEnd(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n      return this._panRotate ? this._onPanRotateEnd(event) : this._onPanMoveEnd(event);\n    }\n  }, {\n    key: \"_onPanMove\",\n    value: function _onPanMove(event) {\n      if (!this.dragPan) {\n        return false;\n      }\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.pan({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isPanning: true\n      });\n      return true;\n    }\n  }, {\n    key: \"_onPanMoveEnd\",\n    value: function _onPanMoveEnd(event) {\n      if (this.dragPan) {\n        var _this$dragPan$inertia = this.dragPan.inertia,\n          inertia = _this$dragPan$inertia === void 0 ? DEFAULT_INERTIA : _this$dragPan$inertia;\n        if (inertia && event.velocity) {\n          var pos = this.getCenter(event);\n          var endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];\n          var newControllerState = this.mapState.pan({\n            pos: endPos\n          }).panEnd();\n          this.updateViewport(newControllerState, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n            transitionDuration: inertia,\n            transitionEasing: INERTIA_EASING\n          }), {\n            isDragging: false,\n            isPanning: true\n          });\n          return true;\n        }\n      }\n      var newMapState = this.mapState.panEnd();\n      this.updateViewport(newMapState, null, {\n        isDragging: false,\n        isPanning: false\n      });\n      return true;\n    }\n  }, {\n    key: \"_onPanRotate\",\n    value: function _onPanRotate(event) {\n      if (!this.dragRotate) {\n        return false;\n      }\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.rotate({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isRotating: true\n      });\n      return true;\n    }\n  }, {\n    key: \"_onPanRotateEnd\",\n    value: function _onPanRotateEnd(event) {\n      if (this.dragRotate) {\n        var _this$dragRotate$iner = this.dragRotate.inertia,\n          inertia = _this$dragRotate$iner === void 0 ? DEFAULT_INERTIA : _this$dragRotate$iner;\n        if (inertia && event.velocity) {\n          var pos = this.getCenter(event);\n          var endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];\n          var newControllerState = this.mapState.rotate({\n            pos: endPos\n          }).rotateEnd();\n          this.updateViewport(newControllerState, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n            transitionDuration: inertia,\n            transitionEasing: INERTIA_EASING\n          }), {\n            isDragging: false,\n            isRotating: true\n          });\n          return true;\n        }\n      }\n      var newMapState = this.mapState.panEnd();\n      this.updateViewport(newMapState, null, {\n        isDragging: false,\n        isRotating: false\n      });\n      return true;\n    }\n  }, {\n    key: \"_onWheel\",\n    value: function _onWheel(event) {\n      if (!this.scrollZoom) {\n        return false;\n      }\n      var _this$scrollZoom = this.scrollZoom,\n        _this$scrollZoom$spee = _this$scrollZoom.speed,\n        speed = _this$scrollZoom$spee === void 0 ? 0.01 : _this$scrollZoom$spee,\n        _this$scrollZoom$smoo = _this$scrollZoom.smooth,\n        smooth = _this$scrollZoom$smoo === void 0 ? false : _this$scrollZoom$smoo;\n      event.preventDefault();\n      var pos = this.getCenter(event);\n      var delta = event.delta;\n      var scale = 2 / (1 + Math.exp(-Math.abs(delta * speed)));\n      if (delta < 0 && scale !== 0) {\n        scale = 1 / scale;\n      }\n      var newMapState = this.mapState.zoom({\n        pos: pos,\n        scale: scale\n      });\n      if (newMapState.getViewportProps().zoom === this.mapStateProps.zoom) {\n        return false;\n      }\n      this.updateViewport(newMapState, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n        transitionInterpolator: new LinearInterpolator({\n          around: pos\n        }),\n        transitionDuration: smooth ? 250 : 1\n      }), {\n        isPanning: true,\n        isZooming: true\n      });\n      return true;\n    }\n  }, {\n    key: \"_onPinchStart\",\n    value: function _onPinchStart(event) {\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.zoomStart({\n        pos: pos\n      }).rotateStart({\n        pos: pos\n      });\n      this._startPinchRotation = event.rotation;\n      this._lastPinchEvent = event;\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isDragging: true\n      });\n      return true;\n    }\n  }, {\n    key: \"_onPinch\",\n    value: function _onPinch(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n      if (!this.touchZoom && !this.touchRotate) {\n        return false;\n      }\n      var newMapState = this.mapState;\n      if (this.touchZoom) {\n        var scale = event.scale;\n        var pos = this.getCenter(event);\n        newMapState = newMapState.zoom({\n          pos: pos,\n          scale: scale\n        });\n      }\n      if (this.touchRotate) {\n        var rotation = event.rotation;\n        newMapState = newMapState.rotate({\n          deltaAngleX: this._startPinchRotation - rotation\n        });\n      }\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isDragging: true,\n        isPanning: Boolean(this.touchZoom),\n        isZooming: Boolean(this.touchZoom),\n        isRotating: Boolean(this.touchRotate)\n      });\n      this._lastPinchEvent = event;\n      return true;\n    }\n  }, {\n    key: \"_onPinchEnd\",\n    value: function _onPinchEnd(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n      if (this.touchZoom) {\n        var _this$touchZoom$inert = this.touchZoom.inertia,\n          inertia = _this$touchZoom$inert === void 0 ? DEFAULT_INERTIA : _this$touchZoom$inert;\n        var _lastPinchEvent = this._lastPinchEvent;\n        if (inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {\n          var pos = this.getCenter(event);\n          var _newMapState = this.mapState.rotateEnd();\n          var z = Math.log2(event.scale);\n          var velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);\n          var endScale = Math.pow(2, z + velocityZ * inertia / 2);\n          _newMapState = _newMapState.zoom({\n            pos: pos,\n            scale: endScale\n          }).zoomEnd();\n          this.updateViewport(_newMapState, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n            transitionInterpolator: new LinearInterpolator({\n              around: pos\n            }),\n            transitionDuration: inertia,\n            transitionEasing: INERTIA_EASING\n          }), {\n            isDragging: false,\n            isPanning: Boolean(this.touchZoom),\n            isZooming: Boolean(this.touchZoom),\n            isRotating: false\n          });\n          this.blockEvents(inertia);\n          return true;\n        }\n      }\n      var newMapState = this.mapState.zoomEnd().rotateEnd();\n      this._state.startPinchRotation = 0;\n      this.updateViewport(newMapState, null, {\n        isDragging: false,\n        isPanning: false,\n        isZooming: false,\n        isRotating: false\n      });\n      this._startPinchRotation = null;\n      this._lastPinchEvent = null;\n      return true;\n    }\n  }, {\n    key: \"_onTriplePanStart\",\n    value: function _onTriplePanStart(event) {\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.rotateStart({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isDragging: true\n      });\n      return true;\n    }\n  }, {\n    key: \"_onTriplePan\",\n    value: function _onTriplePan(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n      if (!this.touchRotate) {\n        return false;\n      }\n      var pos = this.getCenter(event);\n      pos[0] -= event.deltaX;\n      var newMapState = this.mapState.rotate({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isRotating: true\n      });\n      return true;\n    }\n  }, {\n    key: \"_onTriplePanEnd\",\n    value: function _onTriplePanEnd(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n      if (this.touchRotate) {\n        var _this$touchRotate$ine = this.touchRotate.inertia,\n          inertia = _this$touchRotate$ine === void 0 ? DEFAULT_INERTIA : _this$touchRotate$ine;\n        if (inertia && event.velocityY) {\n          var pos = this.getCenter(event);\n          var endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];\n          var _newMapState2 = this.mapState.rotate({\n            pos: endPos\n          });\n          this.updateViewport(_newMapState2, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n            transitionDuration: inertia,\n            transitionEasing: INERTIA_EASING\n          }), {\n            isDragging: false,\n            isRotating: true\n          });\n          this.blockEvents(inertia);\n          return false;\n        }\n      }\n      var newMapState = this.mapState.rotateEnd();\n      this.updateViewport(newMapState, null, {\n        isDragging: false,\n        isRotating: false\n      });\n      return true;\n    }\n  }, {\n    key: \"_onDoubleTap\",\n    value: function _onDoubleTap(event) {\n      if (!this.doubleClickZoom) {\n        return false;\n      }\n      var pos = this.getCenter(event);\n      var isZoomOut = this.isFunctionKeyPressed(event);\n      var newMapState = this.mapState.zoom({\n        pos: pos,\n        scale: isZoomOut ? 0.5 : 2\n      });\n      this.updateViewport(newMapState, Object.assign({}, LINEAR_TRANSITION_PROPS, {\n        transitionInterpolator: new LinearInterpolator({\n          around: pos\n        })\n      }), {\n        isZooming: true\n      });\n      return true;\n    }\n  }, {\n    key: \"_onKeyDown\",\n    value: function _onKeyDown(event) {\n      if (!this.keyboard) {\n        return false;\n      }\n      var funcKey = this.isFunctionKeyPressed(event);\n      var _this$keyboard = this.keyboard,\n        _this$keyboard$zoomSp = _this$keyboard.zoomSpeed,\n        zoomSpeed = _this$keyboard$zoomSp === void 0 ? 2 : _this$keyboard$zoomSp,\n        _this$keyboard$moveSp = _this$keyboard.moveSpeed,\n        moveSpeed = _this$keyboard$moveSp === void 0 ? 100 : _this$keyboard$moveSp,\n        _this$keyboard$rotate = _this$keyboard.rotateSpeedX,\n        rotateSpeedX = _this$keyboard$rotate === void 0 ? 15 : _this$keyboard$rotate,\n        _this$keyboard$rotate2 = _this$keyboard.rotateSpeedY,\n        rotateSpeedY = _this$keyboard$rotate2 === void 0 ? 10 : _this$keyboard$rotate2;\n      var mapStateProps = this.mapStateProps;\n      var newMapState;\n      switch (event.srcEvent.keyCode) {\n        case 189:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              zoom: mapStateProps.zoom - Math.log2(zoomSpeed) - 1\n            });\n          } else {\n            newMapState = this.getMapState({\n              zoom: mapStateProps.zoom - Math.log2(zoomSpeed)\n            });\n          }\n          break;\n        case 187:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              zoom: mapStateProps.zoom + Math.log2(zoomSpeed) + 1\n            });\n          } else {\n            newMapState = this.getMapState({\n              zoom: mapStateProps.zoom + Math.log2(zoomSpeed)\n            });\n          }\n          break;\n        case 37:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              bearing: mapStateProps.bearing - rotateSpeedX\n            });\n          } else {\n            newMapState = this.mapState.pan({\n              pos: [moveSpeed, 0],\n              startPos: [0, 0]\n            });\n          }\n          break;\n        case 39:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              bearing: mapStateProps.bearing + rotateSpeedX\n            });\n          } else {\n            newMapState = this.mapState.pan({\n              pos: [-moveSpeed, 0],\n              startPos: [0, 0]\n            });\n          }\n          break;\n        case 38:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              pitch: mapStateProps.pitch + rotateSpeedY\n            });\n          } else {\n            newMapState = this.mapState.pan({\n              pos: [0, moveSpeed],\n              startPos: [0, 0]\n            });\n          }\n          break;\n        case 40:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              pitch: mapStateProps.pitch - rotateSpeedY\n            });\n          } else {\n            newMapState = this.mapState.pan({\n              pos: [0, -moveSpeed],\n              startPos: [0, 0]\n            });\n          }\n          break;\n        default:\n          return false;\n      }\n      return this.updateViewport(newMapState, LINEAR_TRANSITION_PROPS);\n    }\n  }]);\n  return MapController;\n}();\n\n;// ./node_modules/react-map-gl/dist/esm/components/interactive-map.js\n\n\n\nfunction interactive_map_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction interactive_map_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      interactive_map_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      interactive_map_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\n\n\n\n\n\n\n\nvar interactive_map_propTypes = Object.assign({}, static_map.propTypes, {\n  maxZoom: prop_types.number,\n  minZoom: prop_types.number,\n  maxPitch: prop_types.number,\n  minPitch: prop_types.number,\n  onViewStateChange: prop_types.func,\n  onViewportChange: prop_types.func,\n  onInteractionStateChange: prop_types.func,\n  transitionDuration: prop_types.oneOfType([prop_types.number, prop_types.string]),\n  transitionInterpolator: prop_types.object,\n  transitionInterruption: prop_types.number,\n  transitionEasing: prop_types.func,\n  onTransitionStart: prop_types.func,\n  onTransitionInterrupt: prop_types.func,\n  onTransitionEnd: prop_types.func,\n  scrollZoom: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  dragPan: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  dragRotate: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  doubleClickZoom: prop_types.bool,\n  touchZoom: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  touchRotate: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  keyboard: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  onHover: prop_types.func,\n  onClick: prop_types.func,\n  onDblClick: prop_types.func,\n  onContextMenu: prop_types.func,\n  onMouseDown: prop_types.func,\n  onMouseMove: prop_types.func,\n  onMouseUp: prop_types.func,\n  onTouchStart: prop_types.func,\n  onTouchMove: prop_types.func,\n  onTouchEnd: prop_types.func,\n  onMouseEnter: prop_types.func,\n  onMouseLeave: prop_types.func,\n  onMouseOut: prop_types.func,\n  onWheel: prop_types.func,\n  touchAction: prop_types.string,\n  eventRecognizerOptions: prop_types.object,\n  clickRadius: prop_types.number,\n  interactiveLayerIds: prop_types.array,\n  getCursor: prop_types.func,\n  controller: prop_types.instanceOf(MapController)\n});\nvar getDefaultCursor = function getDefaultCursor(_ref) {\n  var isDragging = _ref.isDragging,\n    isHovering = _ref.isHovering;\n  return isDragging ? 'grabbing' : isHovering ? 'pointer' : 'grab';\n};\nvar interactive_map_defaultProps = Object.assign({}, static_map.defaultProps, MAPBOX_LIMITS, TransitionManager.defaultProps, {\n  onViewStateChange: null,\n  onViewportChange: null,\n  onClick: null,\n  onNativeClick: null,\n  onHover: null,\n  onContextMenu: function onContextMenu(event) {\n    return event.preventDefault();\n  },\n  scrollZoom: true,\n  dragPan: true,\n  dragRotate: true,\n  doubleClickZoom: true,\n  touchZoom: true,\n  touchRotate: false,\n  keyboard: true,\n  touchAction: 'none',\n  eventRecognizerOptions: {},\n  clickRadius: 0,\n  getCursor: getDefaultCursor\n});\nfunction normalizeEvent(event) {\n  if (event.lngLat || !event.offsetCenter) {\n    return event;\n  }\n  var _event$offsetCenter = event.offsetCenter,\n    x = _event$offsetCenter.x,\n    y = _event$offsetCenter.y;\n  if (!Number.isFinite(x) || !Number.isFinite(y)) {\n    return event;\n  }\n  var pos = [x, y];\n  event.point = pos;\n  if (this.map) {\n    var location = this.map.unproject(pos);\n    event.lngLat = [location.lng, location.lat];\n  }\n  return event;\n}\nfunction getFeatures(pos) {\n  var map = this.map;\n  if (!map || !pos) {\n    return null;\n  }\n  var queryParams = {};\n  var size = this.props.clickRadius;\n  if (this.props.interactiveLayerIds) {\n    queryParams.layers = this.props.interactiveLayerIds;\n  }\n  try {\n    return map.queryRenderedFeatures(size ? [[pos[0] - size, pos[1] + size], [pos[0] + size, pos[1] - size]] : pos, queryParams);\n  } catch (_unused) {\n    return null;\n  }\n}\nfunction onEvent(callbackName, event) {\n  var func = this.props[callbackName];\n  if (func) {\n    func(normalizeEvent.call(this, event));\n  }\n}\nfunction onPointerDown(event) {\n  onEvent.call(this, event.pointerType === 'touch' ? 'onTouchStart' : 'onMouseDown', event);\n}\nfunction onPointerUp(event) {\n  onEvent.call(this, event.pointerType === 'touch' ? 'onTouchEnd' : 'onMouseUp', event);\n}\nfunction onPointerMove(event) {\n  onEvent.call(this, event.pointerType === 'touch' ? 'onTouchMove' : 'onMouseMove', event);\n  if (!this.state.isDragging) {\n    var _this$props = this.props,\n      onHover = _this$props.onHover,\n      interactiveLayerIds = _this$props.interactiveLayerIds;\n    var features;\n    event = normalizeEvent.call(this, event);\n    if (interactiveLayerIds || onHover) {\n      features = getFeatures.call(this, event.point);\n    }\n    var isHovering = Boolean(interactiveLayerIds && features && features.length > 0);\n    var isEntering = isHovering && !this.state.isHovering;\n    var isExiting = !isHovering && this.state.isHovering;\n    if (onHover || isEntering) {\n      event.features = features;\n      if (onHover) {\n        onHover(event);\n      }\n    }\n    if (isEntering) {\n      onEvent.call(this, 'onMouseEnter', event);\n    }\n    if (isExiting) {\n      onEvent.call(this, 'onMouseLeave', event);\n    }\n    if (isEntering || isExiting) {\n      this.setState({\n        isHovering: isHovering\n      });\n    }\n  }\n}\nfunction onPointerClick(event) {\n  var _this$props2 = this.props,\n    onClick = _this$props2.onClick,\n    onNativeClick = _this$props2.onNativeClick,\n    onDblClick = _this$props2.onDblClick,\n    doubleClickZoom = _this$props2.doubleClickZoom;\n  var callbacks = [];\n  var isDoubleClickEnabled = onDblClick || doubleClickZoom;\n  switch (event.type) {\n    case 'anyclick':\n      callbacks.push(onNativeClick);\n      if (!isDoubleClickEnabled) {\n        callbacks.push(onClick);\n      }\n      break;\n    case 'click':\n      if (isDoubleClickEnabled) {\n        callbacks.push(onClick);\n      }\n      break;\n    default:\n  }\n  callbacks = callbacks.filter(Boolean);\n  if (callbacks.length) {\n    event = normalizeEvent.call(this, event);\n    event.features = getFeatures.call(this, event.point);\n    callbacks.forEach(function (cb) {\n      return cb(event);\n    });\n  }\n}\nfunction interactive_map_getRefHandles(staticMapRef) {\n  return {\n    getMap: staticMapRef.current && staticMapRef.current.getMap,\n    queryRenderedFeatures: staticMapRef.current && staticMapRef.current.queryRenderedFeatures\n  };\n}\nvar InteractiveMap = (0,react.forwardRef)(function (props, ref) {\n  var parentContext = (0,react.useContext)(map_context);\n  var controller = (0,react.useMemo)(function () {\n    return props.controller || new MapController();\n  }, []);\n  var eventManager = (0,react.useMemo)(function () {\n    return new EventManager(null, {\n      touchAction: props.touchAction,\n      recognizerOptions: props.eventRecognizerOptions\n    });\n  }, []);\n  var eventCanvasRef = (0,react.useRef)(null);\n  var staticMapRef = (0,react.useRef)(null);\n  var _thisRef = (0,react.useRef)({\n    width: 0,\n    height: 0,\n    state: {\n      isHovering: false,\n      isDragging: false\n    }\n  });\n  var thisRef = _thisRef.current;\n  thisRef.props = props;\n  thisRef.map = staticMapRef.current && staticMapRef.current.getMap();\n  thisRef.setState = function (newState) {\n    thisRef.state = interactive_map_objectSpread(interactive_map_objectSpread({}, thisRef.state), newState);\n    eventCanvasRef.current.style.cursor = props.getCursor(thisRef.state);\n  };\n  var inRender = true;\n  var viewportUpdateRequested;\n  var stateUpdateRequested;\n  var handleViewportChange = function handleViewportChange(viewState, interactionState, oldViewState) {\n    if (inRender) {\n      viewportUpdateRequested = [viewState, interactionState, oldViewState];\n      return;\n    }\n    var _thisRef$props = thisRef.props,\n      onViewStateChange = _thisRef$props.onViewStateChange,\n      onViewportChange = _thisRef$props.onViewportChange;\n    Object.defineProperty(viewState, 'position', {\n      get: function get() {\n        return [0, 0, getTerrainElevation(thisRef.map, viewState)];\n      }\n    });\n    if (onViewStateChange) {\n      onViewStateChange({\n        viewState: viewState,\n        interactionState: interactionState,\n        oldViewState: oldViewState\n      });\n    }\n    if (onViewportChange) {\n      onViewportChange(viewState, interactionState, oldViewState);\n    }\n  };\n  (0,react.useImperativeHandle)(ref, function () {\n    return interactive_map_getRefHandles(staticMapRef);\n  }, []);\n  var context = (0,react.useMemo)(function () {\n    return interactive_map_objectSpread(interactive_map_objectSpread({}, parentContext), {}, {\n      eventManager: eventManager,\n      container: parentContext.container || eventCanvasRef.current\n    });\n  }, [parentContext, eventCanvasRef.current]);\n  context.onViewportChange = handleViewportChange;\n  context.viewport = parentContext.viewport || getViewport(thisRef);\n  thisRef.viewport = context.viewport;\n  var handleInteractionStateChange = function handleInteractionStateChange(interactionState) {\n    var _interactionState$isD = interactionState.isDragging,\n      isDragging = _interactionState$isD === void 0 ? false : _interactionState$isD;\n    if (isDragging !== thisRef.state.isDragging) {\n      thisRef.setState({\n        isDragging: isDragging\n      });\n    }\n    if (inRender) {\n      stateUpdateRequested = interactionState;\n      return;\n    }\n    var onInteractionStateChange = thisRef.props.onInteractionStateChange;\n    if (onInteractionStateChange) {\n      onInteractionStateChange(interactionState);\n    }\n  };\n  var updateControllerOpts = function updateControllerOpts() {\n    if (thisRef.width && thisRef.height) {\n      controller.setOptions(interactive_map_objectSpread(interactive_map_objectSpread(interactive_map_objectSpread({}, thisRef.props), thisRef.props.viewState), {}, {\n        isInteractive: Boolean(thisRef.props.onViewStateChange || thisRef.props.onViewportChange),\n        onViewportChange: handleViewportChange,\n        onStateChange: handleInteractionStateChange,\n        eventManager: eventManager,\n        width: thisRef.width,\n        height: thisRef.height\n      }));\n    }\n  };\n  var onResize = function onResize(_ref2) {\n    var width = _ref2.width,\n      height = _ref2.height;\n    thisRef.width = width;\n    thisRef.height = height;\n    updateControllerOpts();\n    thisRef.props.onResize({\n      width: width,\n      height: height\n    });\n  };\n  (0,react.useEffect)(function () {\n    eventManager.setElement(eventCanvasRef.current);\n    eventManager.on({\n      pointerdown: onPointerDown.bind(thisRef),\n      pointermove: onPointerMove.bind(thisRef),\n      pointerup: onPointerUp.bind(thisRef),\n      pointerleave: onEvent.bind(thisRef, 'onMouseOut'),\n      click: onPointerClick.bind(thisRef),\n      anyclick: onPointerClick.bind(thisRef),\n      dblclick: onEvent.bind(thisRef, 'onDblClick'),\n      wheel: onEvent.bind(thisRef, 'onWheel'),\n      contextmenu: onEvent.bind(thisRef, 'onContextMenu')\n    });\n    return function () {\n      eventManager.destroy();\n    };\n  }, []);\n  use_isomorphic_layout_effect(function () {\n    if (viewportUpdateRequested) {\n      handleViewportChange.apply(void 0, (0,toConsumableArray/* default */.A)(viewportUpdateRequested));\n    }\n    if (stateUpdateRequested) {\n      handleInteractionStateChange(stateUpdateRequested);\n    }\n  });\n  updateControllerOpts();\n  var width = props.width,\n    height = props.height,\n    style = props.style,\n    getCursor = props.getCursor;\n  var eventCanvasStyle = (0,react.useMemo)(function () {\n    return interactive_map_objectSpread(interactive_map_objectSpread({\n      position: 'relative'\n    }, style), {}, {\n      width: width,\n      height: height,\n      cursor: getCursor(thisRef.state)\n    });\n  }, [style, width, height, getCursor, thisRef.state]);\n  if (!viewportUpdateRequested || !thisRef._child) {\n    thisRef._child = react.createElement(MapContextProvider, {\n      value: context\n    }, react.createElement(\"div\", {\n      key: \"event-canvas\",\n      ref: eventCanvasRef,\n      style: eventCanvasStyle\n    }, react.createElement(static_map, _extends({}, props, {\n      width: \"100%\",\n      height: \"100%\",\n      style: null,\n      onResize: onResize,\n      ref: staticMapRef\n    }))));\n  }\n  inRender = false;\n  return thisRef._child;\n});\nInteractiveMap.supported = static_map.supported;\nInteractiveMap.propTypes = interactive_map_propTypes;\nInteractiveMap.defaultProps = interactive_map_defaultProps;\n/* harmony default export */ var interactive_map = (InteractiveMap);\n;// ./node_modules/react-map-gl/dist/esm/utils/deep-equal.js\n\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (!a || !b) {\n    return false;\n  }\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b) || a.length !== b.length) {\n      return false;\n    }\n    for (var i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  } else if (Array.isArray(b)) {\n    return false;\n  }\n  if (_typeof(a) === 'object' && _typeof(b) === 'object') {\n    var aKeys = Object.keys(a);\n    var bKeys = Object.keys(b);\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n    for (var _i = 0, _aKeys = aKeys; _i < _aKeys.length; _i++) {\n      var key = _aKeys[_i];\n      if (!b.hasOwnProperty(key)) {\n        return false;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n;// ./node_modules/react-map-gl/dist/esm/components/source.js\n\n\nfunction source_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction source_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      source_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      source_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\n\n\nvar sourceCounter = 0;\nfunction createSource(map, id, props) {\n  if (map && map.style && map.style._loaded) {\n    var options = source_objectSpread({}, props);\n    delete options.id;\n    delete options.children;\n    map.addSource(id, options);\n    return map.getSource(id);\n  }\n  return null;\n}\nfunction updateSource(source, props, prevProps) {\n  utils_assert_assert(props.id === prevProps.id, 'source id changed');\n  utils_assert_assert(props.type === prevProps.type, 'source type changed');\n  var changedKey = '';\n  var changedKeyCount = 0;\n  for (var key in props) {\n    if (key !== 'children' && key !== 'id' && !deepEqual(prevProps[key], props[key])) {\n      changedKey = key;\n      changedKeyCount++;\n    }\n  }\n  if (!changedKeyCount) {\n    return;\n  }\n  var type = props.type;\n  if (type === 'geojson') {\n    source.setData(props.data);\n  } else if (type === 'image') {\n    source.updateImage({\n      url: props.url,\n      coordinates: props.coordinates\n    });\n  } else if ((type === 'canvas' || type === 'video') && changedKeyCount === 1 && changedKey === 'coordinates') {\n    source.setCoordinates(props.coordinates);\n  } else if (type === 'vector' && source.setUrl) {\n    switch (changedKey) {\n      case 'url':\n        source.setUrl(props.url);\n        break;\n      case 'tiles':\n        source.setTiles(props.tiles);\n        break;\n      default:\n    }\n  } else {\n    console.warn(\"Unable to update <Source> prop: \".concat(changedKey));\n  }\n}\nfunction Source(props) {\n  var context = (0,react.useContext)(map_context);\n  var propsRef = (0,react.useRef)({\n    id: props.id,\n    type: props.type\n  });\n  var _useState = (0,react.useState)(0),\n    _useState2 = _slicedToArray(_useState, 2),\n    setStyleLoaded = _useState2[1];\n  var id = (0,react.useMemo)(function () {\n    return props.id || \"jsx-source-\".concat(sourceCounter++);\n  }, []);\n  var map = context.map;\n  (0,react.useEffect)(function () {\n    if (map) {\n      var forceUpdate = function forceUpdate() {\n        return setStyleLoaded(function (version) {\n          return version + 1;\n        });\n      };\n      map.on('styledata', forceUpdate);\n      return function () {\n        map.off('styledata', forceUpdate);\n        requestAnimationFrame(function () {\n          if (map.style && map.style._loaded && map.getSource(id)) {\n            map.removeSource(id);\n          }\n        });\n      };\n    }\n    return undefined;\n  }, [map, id]);\n  var source = map && map.style && map.getSource(id);\n  if (source) {\n    updateSource(source, props, propsRef.current);\n  } else {\n    source = createSource(map, id, props);\n  }\n  propsRef.current = props;\n  return source && react.Children.map(props.children, function (child) {\n    return child && (0,react.cloneElement)(child, {\n      source: id\n    });\n  }) || null;\n}\n/* harmony default export */ var source = (Source);\n;// ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (e.includes(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\n\n;// ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\n\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var s = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\n\n;// ./node_modules/react-map-gl/dist/esm/components/layer.js\n\n\n\nfunction layer_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction layer_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      layer_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      layer_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\n\nvar LAYER_TYPES = ['fill', 'line', 'symbol', 'circle', 'fill-extrusion', 'raster', 'background', 'heatmap', 'hillshade', 'sky'];\nvar layer_propTypes = {\n  type: prop_types.oneOf(LAYER_TYPES).isRequired,\n  id: prop_types.string,\n  source: prop_types.string,\n  beforeId: prop_types.string\n};\nfunction diffLayerStyles(map, id, props, prevProps) {\n  var _props$layout = props.layout,\n    layout = _props$layout === void 0 ? {} : _props$layout,\n    _props$paint = props.paint,\n    paint = _props$paint === void 0 ? {} : _props$paint,\n    filter = props.filter,\n    minzoom = props.minzoom,\n    maxzoom = props.maxzoom,\n    beforeId = props.beforeId,\n    otherProps = _objectWithoutProperties(props, [\"layout\", \"paint\", \"filter\", \"minzoom\", \"maxzoom\", \"beforeId\"]);\n  if (beforeId !== prevProps.beforeId) {\n    map.moveLayer(id, beforeId);\n  }\n  if (layout !== prevProps.layout) {\n    var prevLayout = prevProps.layout || {};\n    for (var key in layout) {\n      if (!deepEqual(layout[key], prevLayout[key])) {\n        map.setLayoutProperty(id, key, layout[key]);\n      }\n    }\n    for (var _key in prevLayout) {\n      if (!layout.hasOwnProperty(_key)) {\n        map.setLayoutProperty(id, _key, undefined);\n      }\n    }\n  }\n  if (paint !== prevProps.paint) {\n    var prevPaint = prevProps.paint || {};\n    for (var _key2 in paint) {\n      if (!deepEqual(paint[_key2], prevPaint[_key2])) {\n        map.setPaintProperty(id, _key2, paint[_key2]);\n      }\n    }\n    for (var _key3 in prevPaint) {\n      if (!paint.hasOwnProperty(_key3)) {\n        map.setPaintProperty(id, _key3, undefined);\n      }\n    }\n  }\n  if (!deepEqual(filter, prevProps.filter)) {\n    map.setFilter(id, filter);\n  }\n  if (minzoom !== prevProps.minzoom || maxzoom !== prevProps.maxzoom) {\n    map.setLayerZoomRange(id, minzoom, maxzoom);\n  }\n  for (var _key4 in otherProps) {\n    if (!deepEqual(otherProps[_key4], prevProps[_key4])) {\n      map.setLayerProperty(id, _key4, otherProps[_key4]);\n    }\n  }\n}\nfunction createLayer(map, id, props) {\n  if (map.style && map.style._loaded) {\n    var options = layer_objectSpread(layer_objectSpread({}, props), {}, {\n      id: id\n    });\n    delete options.beforeId;\n    map.addLayer(options, props.beforeId);\n  }\n}\nfunction updateLayer(map, id, props, prevProps) {\n  utils_assert_assert(props.id === prevProps.id, 'layer id changed');\n  utils_assert_assert(props.type === prevProps.type, 'layer type changed');\n  try {\n    diffLayerStyles(map, id, props, prevProps);\n  } catch (error) {\n    console.warn(error);\n  }\n}\nvar layerCounter = 0;\nfunction Layer(props) {\n  var context = (0,react.useContext)(map_context);\n  var propsRef = (0,react.useRef)({\n    id: props.id,\n    type: props.type\n  });\n  var _useState = (0,react.useState)(0),\n    _useState2 = _slicedToArray(_useState, 2),\n    setStyleLoaded = _useState2[1];\n  var id = (0,react.useMemo)(function () {\n    return props.id || \"jsx-layer-\".concat(layerCounter++);\n  }, []);\n  var map = context.map;\n  (0,react.useEffect)(function () {\n    if (map) {\n      var forceUpdate = function forceUpdate() {\n        return setStyleLoaded(function (version) {\n          return version + 1;\n        });\n      };\n      map.on('styledata', forceUpdate);\n      return function () {\n        map.off('styledata', forceUpdate);\n        if (map.style && map.style._loaded) {\n          map.removeLayer(id);\n        }\n      };\n    }\n    return undefined;\n  }, [map]);\n  var layer = map && map.style && map.getLayer(id);\n  if (layer) {\n    updateLayer(map, id, props, propsRef.current);\n  } else {\n    createLayer(map, id, props);\n  }\n  propsRef.current = props;\n  return null;\n}\nLayer.propTypes = layer_propTypes;\n/* harmony default export */ var components_layer = (Layer);\n;// ./node_modules/react-map-gl/dist/esm/components/use-map-control.js\n\n\n\nvar mapControlDefaultProps = {\n  captureScroll: false,\n  captureDrag: true,\n  captureClick: true,\n  captureDoubleClick: true,\n  capturePointerMove: false\n};\nvar mapControlPropTypes = {\n  captureScroll: prop_types.bool,\n  captureDrag: prop_types.bool,\n  captureClick: prop_types.bool,\n  captureDoubleClick: prop_types.bool,\n  capturePointerMove: prop_types.bool\n};\nfunction onMount(thisRef) {\n  var ref = thisRef.containerRef.current;\n  var eventManager = thisRef.context.eventManager;\n  if (!ref || !eventManager) {\n    return undefined;\n  }\n  var events = {\n    wheel: function wheel(evt) {\n      var props = thisRef.props;\n      if (props.captureScroll) {\n        evt.stopPropagation();\n      }\n      if (props.onScroll) {\n        props.onScroll(evt, thisRef);\n      }\n    },\n    panstart: function panstart(evt) {\n      var props = thisRef.props;\n      if (props.captureDrag) {\n        evt.stopPropagation();\n      }\n      if (props.onDragStart) {\n        props.onDragStart(evt, thisRef);\n      }\n    },\n    anyclick: function anyclick(evt) {\n      var props = thisRef.props;\n      if (props.captureClick) {\n        evt.stopPropagation();\n      }\n      if (props.onNativeClick) {\n        props.onNativeClick(evt, thisRef);\n      }\n    },\n    click: function click(evt) {\n      var props = thisRef.props;\n      if (props.captureClick) {\n        evt.stopPropagation();\n      }\n      if (props.onClick) {\n        props.onClick(evt, thisRef);\n      }\n    },\n    dblclick: function dblclick(evt) {\n      var props = thisRef.props;\n      if (props.captureDoubleClick) {\n        evt.stopPropagation();\n      }\n      if (props.onDoubleClick) {\n        props.onDoubleClick(evt, thisRef);\n      }\n    },\n    pointermove: function pointermove(evt) {\n      var props = thisRef.props;\n      if (props.capturePointerMove) {\n        evt.stopPropagation();\n      }\n      if (props.onPointerMove) {\n        props.onPointerMove(evt, thisRef);\n      }\n    }\n  };\n  eventManager.watch(events, ref);\n  return function () {\n    eventManager.off(events);\n  };\n}\nfunction useMapControl() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var context = (0,react.useContext)(map_context);\n  var containerRef = (0,react.useRef)(null);\n  var _thisRef = (0,react.useRef)({\n    props: props,\n    state: {},\n    context: context,\n    containerRef: containerRef\n  });\n  var thisRef = _thisRef.current;\n  thisRef.props = props;\n  thisRef.context = context;\n  (0,react.useEffect)(function () {\n    return onMount(thisRef);\n  }, [context.eventManager]);\n  return thisRef;\n}\n;// ./node_modules/react-map-gl/dist/esm/components/base-control.js\n\n\n\n\n\n\n\n\nfunction base_control_createSuper(Derived) {\n  var hasNativeReflectConstruct = base_control_isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction base_control_isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n\n\nfunction Control(props) {\n  var instance = props.instance;\n  var _useMapControl = useMapControl(props),\n    context = _useMapControl.context,\n    containerRef = _useMapControl.containerRef;\n  instance._context = context;\n  instance._containerRef = containerRef;\n  return instance._render();\n}\nvar BaseControl = function (_PureComponent) {\n  _inherits(BaseControl, _PureComponent);\n  var _super = base_control_createSuper(BaseControl);\n  function BaseControl() {\n    var _this;\n    _classCallCheck(this, BaseControl);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"_context\", {});\n    _defineProperty(_assertThisInitialized(_this), \"_containerRef\", (0,react.createRef)());\n    _defineProperty(_assertThisInitialized(_this), \"_onScroll\", function (evt) {});\n    _defineProperty(_assertThisInitialized(_this), \"_onDragStart\", function (evt) {});\n    _defineProperty(_assertThisInitialized(_this), \"_onDblClick\", function (evt) {});\n    _defineProperty(_assertThisInitialized(_this), \"_onClick\", function (evt) {});\n    _defineProperty(_assertThisInitialized(_this), \"_onPointerMove\", function (evt) {});\n    return _this;\n  }\n  _createClass(BaseControl, [{\n    key: \"_render\",\n    value: function _render() {\n      throw new Error('_render() not implemented');\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react.createElement(Control, _extends({\n        instance: this\n      }, this.props, {\n        onScroll: this._onScroll,\n        onDragStart: this._onDragStart,\n        onDblClick: this._onDblClick,\n        onClick: this._onClick,\n        onPointerMove: this._onPointerMove\n      }));\n    }\n  }]);\n  return BaseControl;\n}(react.PureComponent);\n_defineProperty(BaseControl, \"propTypes\", mapControlPropTypes);\n_defineProperty(BaseControl, \"defaultProps\", mapControlDefaultProps);\n\n;// ./node_modules/react-map-gl/dist/esm/components/draggable-control.js\n\n\nfunction draggable_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction draggable_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      draggable_control_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      draggable_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\nvar draggableControlPropTypes = Object.assign({}, mapControlPropTypes, {\n  draggable: prop_types.bool,\n  onDrag: prop_types.func,\n  onDragEnd: prop_types.func,\n  onDragStart: prop_types.func,\n  offsetLeft: prop_types.number,\n  offsetTop: prop_types.number\n});\nvar draggableControlDefaultProps = Object.assign({}, mapControlDefaultProps, {\n  draggable: false,\n  offsetLeft: 0,\n  offsetTop: 0\n});\nfunction getDragEventPosition(event) {\n  var _event$offsetCenter = event.offsetCenter,\n    x = _event$offsetCenter.x,\n    y = _event$offsetCenter.y;\n  return [x, y];\n}\nfunction getDragEventOffset(event, container) {\n  var _event$center = event.center,\n    x = _event$center.x,\n    y = _event$center.y;\n  if (container) {\n    var rect = container.getBoundingClientRect();\n    return [rect.left - x, rect.top - y];\n  }\n  return null;\n}\nfunction getDragLngLat(dragPos, dragOffset, props, context) {\n  var x = dragPos[0] + dragOffset[0] - props.offsetLeft;\n  var y = dragPos[1] + dragOffset[1] - props.offsetTop;\n  return context.viewport.unproject([x, y]);\n}\nfunction onDragStart(event, _ref) {\n  var props = _ref.props,\n    callbacks = _ref.callbacks,\n    state = _ref.state,\n    context = _ref.context,\n    containerRef = _ref.containerRef;\n  var draggable = props.draggable;\n  if (!draggable) {\n    return;\n  }\n  event.stopPropagation();\n  var dragPos = getDragEventPosition(event);\n  var dragOffset = getDragEventOffset(event, containerRef.current);\n  state.setDragPos(dragPos);\n  state.setDragOffset(dragOffset);\n  if (callbacks.onDragStart && dragOffset) {\n    var callbackEvent = Object.assign({}, event);\n    callbackEvent.lngLat = getDragLngLat(dragPos, dragOffset, props, context);\n    callbacks.onDragStart(callbackEvent);\n  }\n}\nfunction onDrag(event, _ref2) {\n  var props = _ref2.props,\n    callbacks = _ref2.callbacks,\n    state = _ref2.state,\n    context = _ref2.context;\n  event.stopPropagation();\n  var dragPos = getDragEventPosition(event);\n  state.setDragPos(dragPos);\n  var dragOffset = state.dragOffset;\n  if (callbacks.onDrag && dragOffset) {\n    var callbackEvent = Object.assign({}, event);\n    callbackEvent.lngLat = getDragLngLat(dragPos, dragOffset, props, context);\n    callbacks.onDrag(callbackEvent);\n  }\n}\nfunction onDragEnd(event, _ref3) {\n  var props = _ref3.props,\n    callbacks = _ref3.callbacks,\n    state = _ref3.state,\n    context = _ref3.context;\n  event.stopPropagation();\n  var dragPos = state.dragPos,\n    dragOffset = state.dragOffset;\n  state.setDragPos(null);\n  state.setDragOffset(null);\n  if (callbacks.onDragEnd && dragPos && dragOffset) {\n    var callbackEvent = Object.assign({}, event);\n    callbackEvent.lngLat = getDragLngLat(dragPos, dragOffset, props, context);\n    callbacks.onDragEnd(callbackEvent);\n  }\n}\nfunction onDragCancel(event, _ref4) {\n  var state = _ref4.state;\n  event.stopPropagation();\n  state.setDragPos(null);\n  state.setDragOffset(null);\n}\nfunction registerEvents(thisRef) {\n  var eventManager = thisRef.context.eventManager;\n  if (!eventManager || !thisRef.state.dragPos) {\n    return undefined;\n  }\n  var events = {\n    panmove: function panmove(evt) {\n      return onDrag(evt, thisRef);\n    },\n    panend: function panend(evt) {\n      return onDragEnd(evt, thisRef);\n    },\n    pancancel: function pancancel(evt) {\n      return onDragCancel(evt, thisRef);\n    }\n  };\n  eventManager.watch(events);\n  return function () {\n    eventManager.off(events);\n  };\n}\nfunction useDraggableControl(props) {\n  var _useState = (0,react.useState)(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    dragPos = _useState2[0],\n    setDragPos = _useState2[1];\n  var _useState3 = (0,react.useState)(null),\n    _useState4 = _slicedToArray(_useState3, 2),\n    dragOffset = _useState4[0],\n    setDragOffset = _useState4[1];\n  var thisRef = useMapControl(draggable_control_objectSpread(draggable_control_objectSpread({}, props), {}, {\n    onDragStart: onDragStart\n  }));\n  thisRef.callbacks = props;\n  thisRef.state.dragPos = dragPos;\n  thisRef.state.setDragPos = setDragPos;\n  thisRef.state.dragOffset = dragOffset;\n  thisRef.state.setDragOffset = setDragOffset;\n  (0,react.useEffect)(function () {\n    return registerEvents(thisRef);\n  }, [thisRef.context.eventManager, Boolean(dragPos)]);\n  return thisRef;\n}\n;// ./node_modules/react-map-gl/dist/esm/utils/crisp-pixel.js\nvar pixelRatio = typeof window !== 'undefined' && window.devicePixelRatio || 1;\nvar crispPixel = function crispPixel(size) {\n  return Math.round(size * pixelRatio) / pixelRatio;\n};\nvar crispPercentage = function crispPercentage(el, percentage) {\n  var dimension = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'x';\n  if (el === null) {\n    return percentage;\n  }\n  var origSize = dimension === 'x' ? el.offsetWidth : el.offsetHeight;\n  return crispPixel(percentage / 100 * origSize) / origSize * 100;\n};\n;// ./node_modules/react-map-gl/dist/esm/components/marker.js\n\n\nfunction marker_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction marker_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      marker_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      marker_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\n\nvar marker_defaultProps = Object.assign({}, draggableControlDefaultProps, {\n  className: ''\n});\nfunction getPosition(_ref) {\n  var props = _ref.props,\n    state = _ref.state,\n    context = _ref.context;\n  var longitude = props.longitude,\n    latitude = props.latitude,\n    offsetLeft = props.offsetLeft,\n    offsetTop = props.offsetTop;\n  var dragPos = state.dragPos,\n    dragOffset = state.dragOffset;\n  var viewport = context.viewport,\n    map = context.map;\n  if (dragPos && dragOffset) {\n    return [dragPos[0] + dragOffset[0], dragPos[1] + dragOffset[1]];\n  }\n  var altitude = getTerrainElevation(map, {\n    longitude: longitude,\n    latitude: latitude\n  });\n  var _viewport$project = viewport.project([longitude, latitude, altitude]),\n    _viewport$project2 = _slicedToArray(_viewport$project, 2),\n    x = _viewport$project2[0],\n    y = _viewport$project2[1];\n  x += offsetLeft;\n  y += offsetTop;\n  return [x, y];\n}\nfunction Marker(props) {\n  var thisRef = useDraggableControl(props);\n  var state = thisRef.state,\n    containerRef = thisRef.containerRef;\n  var children = props.children,\n    className = props.className,\n    draggable = props.draggable,\n    style = props.style;\n  var dragPos = state.dragPos;\n  var _getPosition = getPosition(thisRef),\n    _getPosition2 = _slicedToArray(_getPosition, 2),\n    x = _getPosition2[0],\n    y = _getPosition2[1];\n  var transform = \"translate(\".concat(crispPixel(x), \"px, \").concat(crispPixel(y), \"px)\");\n  var cursor = draggable ? dragPos ? 'grabbing' : 'grab' : 'auto';\n  var control = (0,react.useMemo)(function () {\n    var containerStyle = marker_objectSpread({\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      transform: transform,\n      cursor: cursor\n    }, style);\n    return react.createElement(\"div\", {\n      className: \"mapboxgl-marker \".concat(className),\n      ref: thisRef.containerRef,\n      style: containerStyle\n    }, children);\n  }, [children, className]);\n  var container = containerRef.current;\n  if (container) {\n    container.style.transform = transform;\n    container.style.cursor = cursor;\n  }\n  return control;\n}\nMarker.defaultProps = marker_defaultProps;\n/* harmony default export */ var marker = (react.memo(Marker));\n;// ./node_modules/react-map-gl/dist/esm/utils/dynamic-position.js\nvar ANCHOR_POSITION = {\n  top: {\n    x: 0.5,\n    y: 0\n  },\n  'top-left': {\n    x: 0,\n    y: 0\n  },\n  'top-right': {\n    x: 1,\n    y: 0\n  },\n  bottom: {\n    x: 0.5,\n    y: 1\n  },\n  'bottom-left': {\n    x: 0,\n    y: 1\n  },\n  'bottom-right': {\n    x: 1,\n    y: 1\n  },\n  left: {\n    x: 0,\n    y: 0.5\n  },\n  right: {\n    x: 1,\n    y: 0.5\n  }\n};\nvar ANCHOR_TYPES = Object.keys(ANCHOR_POSITION);\nfunction getDynamicPosition(_ref) {\n  var x = _ref.x,\n    y = _ref.y,\n    width = _ref.width,\n    height = _ref.height,\n    selfWidth = _ref.selfWidth,\n    selfHeight = _ref.selfHeight,\n    anchor = _ref.anchor,\n    _ref$padding = _ref.padding,\n    padding = _ref$padding === void 0 ? 0 : _ref$padding;\n  var _ANCHOR_POSITION$anch = ANCHOR_POSITION[anchor],\n    anchorX = _ANCHOR_POSITION$anch.x,\n    anchorY = _ANCHOR_POSITION$anch.y;\n  var top = y - anchorY * selfHeight;\n  var bottom = top + selfHeight;\n  var cutoffY = Math.max(0, padding - top) + Math.max(0, bottom - height + padding);\n  if (cutoffY > 0) {\n    var bestAnchorY = anchorY;\n    var minCutoff = cutoffY;\n    for (anchorY = 0; anchorY <= 1; anchorY += 0.5) {\n      top = y - anchorY * selfHeight;\n      bottom = top + selfHeight;\n      cutoffY = Math.max(0, padding - top) + Math.max(0, bottom - height + padding);\n      if (cutoffY < minCutoff) {\n        minCutoff = cutoffY;\n        bestAnchorY = anchorY;\n      }\n    }\n    anchorY = bestAnchorY;\n  }\n  var xStep = 0.5;\n  if (anchorY === 0.5) {\n    anchorX = Math.floor(anchorX);\n    xStep = 1;\n  }\n  var left = x - anchorX * selfWidth;\n  var right = left + selfWidth;\n  var cutoffX = Math.max(0, padding - left) + Math.max(0, right - width + padding);\n  if (cutoffX > 0) {\n    var bestAnchorX = anchorX;\n    var _minCutoff = cutoffX;\n    for (anchorX = 0; anchorX <= 1; anchorX += xStep) {\n      left = x - anchorX * selfWidth;\n      right = left + selfWidth;\n      cutoffX = Math.max(0, padding - left) + Math.max(0, right - width + padding);\n      if (cutoffX < _minCutoff) {\n        _minCutoff = cutoffX;\n        bestAnchorX = anchorX;\n      }\n    }\n    anchorX = bestAnchorX;\n  }\n  return ANCHOR_TYPES.find(function (positionType) {\n    var anchorPosition = ANCHOR_POSITION[positionType];\n    return anchorPosition.x === anchorX && anchorPosition.y === anchorY;\n  }) || anchor;\n}\n;// ./node_modules/react-map-gl/dist/esm/components/popup.js\n\n\n\n\n\n\n\nvar popup_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: '',\n  offsetLeft: 0,\n  offsetTop: 0,\n  tipSize: 10,\n  anchor: 'bottom',\n  dynamicPosition: true,\n  sortByDepth: false,\n  closeButton: true,\n  closeOnClick: true,\n  onClose: function onClose() {}\n});\nfunction popup_getPosition(props, viewport, el, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    x = _ref2[0],\n    y = _ref2[1];\n  var anchor = props.anchor,\n    dynamicPosition = props.dynamicPosition,\n    tipSize = props.tipSize;\n  if (el) {\n    return dynamicPosition ? getDynamicPosition({\n      x: x,\n      y: y,\n      anchor: anchor,\n      padding: tipSize,\n      width: viewport.width,\n      height: viewport.height,\n      selfWidth: el.clientWidth,\n      selfHeight: el.clientHeight\n    }) : anchor;\n  }\n  return anchor;\n}\nfunction getContainerStyle(props, viewport, el, _ref3, positionType) {\n  var _ref4 = _slicedToArray(_ref3, 3),\n    x = _ref4[0],\n    y = _ref4[1],\n    z = _ref4[2];\n  var offsetLeft = props.offsetLeft,\n    offsetTop = props.offsetTop,\n    sortByDepth = props.sortByDepth;\n  var anchorPosition = ANCHOR_POSITION[positionType];\n  var left = x + offsetLeft;\n  var top = y + offsetTop;\n  var xPercentage = crispPercentage(el, -anchorPosition.x * 100);\n  var yPercentage = crispPercentage(el, -anchorPosition.y * 100, 'y');\n  var style = {\n    position: 'absolute',\n    transform: \"\\n      translate(\".concat(xPercentage, \"%, \").concat(yPercentage, \"%)\\n      translate(\").concat(crispPixel(left), \"px, \").concat(crispPixel(top), \"px)\\n    \"),\n    display: undefined,\n    zIndex: undefined\n  };\n  if (!sortByDepth) {\n    return style;\n  }\n  if (z > 1 || z < -1 || x < 0 || x > viewport.width || y < 0 || y > viewport.height) {\n    style.display = 'none';\n  } else {\n    style.zIndex = Math.floor((1 - z) / 2 * 100000);\n  }\n  return style;\n}\nfunction Popup(props) {\n  var contentRef = (0,react.useRef)(null);\n  var thisRef = useMapControl(props);\n  var context = thisRef.context,\n    containerRef = thisRef.containerRef;\n  var _useState = (0,react.useState)(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    setLoaded = _useState2[1];\n  (0,react.useEffect)(function () {\n    setLoaded(true);\n  }, [contentRef.current]);\n  (0,react.useEffect)(function () {\n    if (context.eventManager && props.closeOnClick) {\n      var clickCallback = function clickCallback() {\n        return thisRef.props.onClose();\n      };\n      context.eventManager.on('anyclick', clickCallback);\n      return function () {\n        context.eventManager.off('anyclick', clickCallback);\n      };\n    }\n    return undefined;\n  }, [context.eventManager, props.closeOnClick]);\n  var viewport = context.viewport,\n    map = context.map;\n  var className = props.className,\n    longitude = props.longitude,\n    latitude = props.latitude,\n    tipSize = props.tipSize,\n    closeButton = props.closeButton,\n    children = props.children;\n  var altitude = props.altitude;\n  if (altitude === undefined) {\n    altitude = getTerrainElevation(map, {\n      longitude: longitude,\n      latitude: latitude\n    });\n  }\n  var position = viewport.project([longitude, latitude, altitude]);\n  var positionType = popup_getPosition(props, viewport, contentRef.current, position);\n  var containerStyle = getContainerStyle(props, viewport, containerRef.current, position, positionType);\n  var onClickCloseButton = (0,react.useCallback)(function (evt) {\n    thisRef.props.onClose();\n    var eventManager = thisRef.context.eventManager;\n    if (eventManager) {\n      eventManager.once('click', function (e) {\n        return e.stopPropagation();\n      }, evt.target);\n    }\n  }, []);\n  return react.createElement(\"div\", {\n    className: \"mapboxgl-popup mapboxgl-popup-anchor-\".concat(positionType, \" \").concat(className),\n    style: containerStyle,\n    ref: containerRef\n  }, react.createElement(\"div\", {\n    key: \"tip\",\n    className: \"mapboxgl-popup-tip\",\n    style: {\n      borderWidth: tipSize\n    }\n  }), react.createElement(\"div\", {\n    key: \"content\",\n    ref: contentRef,\n    className: \"mapboxgl-popup-content\"\n  }, closeButton && react.createElement(\"button\", {\n    key: \"close-button\",\n    className: \"mapboxgl-popup-close-button\",\n    type: \"button\",\n    onClick: onClickCloseButton\n  }, \"\\xD7\"), children));\n}\nPopup.defaultProps = popup_defaultProps;\n/* harmony default export */ var popup = (react.memo(Popup));\n;// ./node_modules/react-map-gl/dist/esm/components/attribution-control.js\n\n\nfunction attribution_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction attribution_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      attribution_control_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      attribution_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\nvar attribution_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: '',\n  toggleLabel: 'Toggle Attribution'\n});\nfunction setupAttributioncontrol(opts, map, container, attributionContainer) {\n  var control = new (maplibre_gl_default()).AttributionControl(opts);\n  control._map = map;\n  control._container = container;\n  control._innerContainer = attributionContainer;\n  control._updateAttributions();\n  control._updateEditLink();\n  map.on('styledata', control._updateData);\n  map.on('sourcedata', control._updateData);\n  return control;\n}\nfunction removeAttributionControl(control) {\n  control._map.off('styledata', control._updateData);\n  control._map.off('sourcedata', control._updateData);\n}\nfunction AttributionControl(props) {\n  var _useMapControl = useMapControl(props),\n    context = _useMapControl.context,\n    containerRef = _useMapControl.containerRef;\n  var innerContainerRef = (0,react.useRef)(null);\n  var _useState = (0,react.useState)(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    showCompact = _useState2[0],\n    setShowCompact = _useState2[1];\n  (0,react.useEffect)(function () {\n    var control;\n    if (context.map) {\n      control = setupAttributioncontrol({\n        customAttribution: props.customAttribution\n      }, context.map, containerRef.current, innerContainerRef.current);\n    }\n    return function () {\n      return control && removeAttributionControl(control);\n    };\n  }, [context.map]);\n  var compact = props.compact === undefined ? context.viewport.width <= 640 : props.compact;\n  (0,react.useEffect)(function () {\n    if (!compact && showCompact) {\n      setShowCompact(false);\n    }\n  }, [compact]);\n  var toggleAttribution = (0,react.useCallback)(function () {\n    return setShowCompact(function (value) {\n      return !value;\n    });\n  }, []);\n  var style = (0,react.useMemo)(function () {\n    return attribution_control_objectSpread({\n      position: 'absolute'\n    }, props.style);\n  }, [props.style]);\n  return react.createElement(\"div\", {\n    style: style,\n    className: props.className\n  }, react.createElement(\"div\", {\n    ref: containerRef,\n    \"aria-pressed\": showCompact,\n    className: \"mapboxgl-ctrl mapboxgl-ctrl-attrib \".concat(compact ? 'mapboxgl-compact' : '', \" \").concat(showCompact ? 'mapboxgl-compact-show' : '')\n  }, react.createElement(\"button\", {\n    type: \"button\",\n    className: \"mapboxgl-ctrl-attrib-button\",\n    title: props.toggleLabel,\n    onClick: toggleAttribution\n  }), react.createElement(\"div\", {\n    ref: innerContainerRef,\n    className: \"mapboxgl-ctrl-attrib-inner\",\n    role: \"list\"\n  })));\n}\nAttributionControl.defaultProps = attribution_control_defaultProps;\n/* harmony default export */ var attribution_control = (react.memo(AttributionControl));\n;// ./node_modules/react-map-gl/dist/esm/components/fullscreen-control.js\n\n\nfunction fullscreen_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction fullscreen_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      fullscreen_control_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      fullscreen_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\n\nvar fullscreen_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: '',\n  container: null,\n  label: 'Toggle fullscreen'\n});\nfunction FullscreenControl(props) {\n  var _useMapControl = useMapControl(props),\n    context = _useMapControl.context,\n    containerRef = _useMapControl.containerRef;\n  var _useState = (0,react.useState)(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    isFullscreen = _useState2[0],\n    setIsFullscreen = _useState2[1];\n  var _useState3 = (0,react.useState)(false),\n    _useState4 = _slicedToArray(_useState3, 2),\n    showButton = _useState4[0],\n    setShowButton = _useState4[1];\n  var _useState5 = (0,react.useState)(null),\n    _useState6 = _slicedToArray(_useState5, 2),\n    mapboxFullscreenControl = _useState6[0],\n    createMapboxFullscreenControl = _useState6[1];\n  (0,react.useEffect)(function () {\n    var control = new (maplibre_gl_default()).FullscreenControl();\n    createMapboxFullscreenControl(control);\n    setShowButton(control._checkFullscreenSupport());\n    var onFullscreenChange = function onFullscreenChange() {\n      var nextState = !control._fullscreen;\n      control._fullscreen = nextState;\n      setIsFullscreen(nextState);\n    };\n    document_.addEventListener(control._fullscreenchange, onFullscreenChange);\n    return function () {\n      document_.removeEventListener(control._fullscreenchange, onFullscreenChange);\n    };\n  }, []);\n  var onClickFullscreen = function onClickFullscreen() {\n    if (mapboxFullscreenControl) {\n      mapboxFullscreenControl._container = props.container || context.container;\n      mapboxFullscreenControl._onClickFullscreen();\n    }\n  };\n  var style = (0,react.useMemo)(function () {\n    return fullscreen_control_objectSpread({\n      position: 'absolute'\n    }, props.style);\n  }, [props.style]);\n  if (!showButton) {\n    return null;\n  }\n  var className = props.className,\n    label = props.label;\n  var type = isFullscreen ? 'shrink' : 'fullscreen';\n  return react.createElement(\"div\", {\n    style: style,\n    className: className\n  }, react.createElement(\"div\", {\n    className: \"mapboxgl-ctrl mapboxgl-ctrl-group\",\n    ref: containerRef\n  }, react.createElement(\"button\", {\n    key: type,\n    className: \"mapboxgl-ctrl-icon mapboxgl-ctrl-\".concat(type),\n    type: \"button\",\n    title: label,\n    onClick: onClickFullscreen\n  }, react.createElement(\"span\", {\n    className: \"mapboxgl-ctrl-icon\",\n    \"aria-hidden\": \"true\"\n  }))));\n}\nFullscreenControl.defaultProps = fullscreen_control_defaultProps;\n/* harmony default export */ var fullscreen_control = (react.memo(FullscreenControl));\n;// ./node_modules/react-map-gl/dist/esm/utils/geolocate-utils.js\nvar supported;\nfunction isGeolocationSupported() {\n  if (supported !== undefined) {\n    return Promise.resolve(supported);\n  }\n  if (window.navigator.permissions !== undefined) {\n    return window.navigator.permissions.query({\n      name: 'geolocation'\n    }).then(function (p) {\n      supported = p.state !== 'denied';\n      return supported;\n    });\n  }\n  supported = Boolean(window.navigator.geolocation);\n  return Promise.resolve(supported);\n}\n;// ./node_modules/react-map-gl/dist/esm/components/geolocate-control.js\n\n\nfunction geolocate_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction geolocate_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      geolocate_control_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      geolocate_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\n\n\n\n\nvar geolocate_control_noop = function noop() {};\nvar geolocate_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: '',\n  label: 'Find My Location',\n  disabledLabel: 'Location Not Available',\n  auto: false,\n  positionOptions: {\n    enableHighAccuracy: false,\n    timeout: 6000\n  },\n  fitBoundsOptions: {\n    maxZoom: 15\n  },\n  trackUserLocation: false,\n  showUserLocation: true,\n  showUserHeading: false,\n  showAccuracyCircle: true,\n  onGeolocate: function onGeolocate() {}\n});\nfunction geolocate_control_getBounds(position) {\n  var center = new (maplibre_gl_default()).LngLat(position.coords.longitude, position.coords.latitude);\n  var radius = position.coords.accuracy;\n  var bounds = center.toBounds(radius);\n  return [[bounds._ne.lng, bounds._ne.lat], [bounds._sw.lng, bounds._sw.lat]];\n}\nfunction setupMapboxGeolocateControl(context, props, geolocateButton) {\n  var control = new (maplibre_gl_default()).GeolocateControl(props);\n  control._container = document_.createElement('div');\n  control._map = {\n    on: function on() {},\n    _getUIString: function _getUIString() {\n      return '';\n    }\n  };\n  control._setupUI(true);\n  control._map = context.map;\n  control._geolocateButton = geolocateButton;\n  var eventManager = context.eventManager;\n  if (control.options.trackUserLocation && eventManager) {\n    eventManager.on('panstart', function () {\n      if (control._watchState === 'ACTIVE_LOCK') {\n        control._watchState = 'BACKGROUND';\n        geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background');\n        geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active');\n      }\n    });\n  }\n  control.on('geolocate', props.onGeolocate);\n  return control;\n}\nfunction updateCamera(position, _ref) {\n  var context = _ref.context,\n    props = _ref.props;\n  var bounds = geolocate_control_getBounds(position);\n  var _context$viewport$fit = context.viewport.fitBounds(bounds, props.fitBoundsOptions),\n    longitude = _context$viewport$fit.longitude,\n    latitude = _context$viewport$fit.latitude,\n    zoom = _context$viewport$fit.zoom;\n  var newViewState = Object.assign({}, context.viewport, {\n    longitude: longitude,\n    latitude: latitude,\n    zoom: zoom\n  });\n  var mapState = new MapState(newViewState);\n  var viewState = Object.assign({}, mapState.getViewportProps(), LINEAR_TRANSITION_PROPS);\n  var onViewportChange = props.onViewportChange || context.onViewportChange || geolocate_control_noop;\n  var onViewStateChange = props.onViewStateChange || context.onViewStateChange || geolocate_control_noop;\n  onViewStateChange({\n    viewState: viewState\n  });\n  onViewportChange(viewState);\n}\nfunction GeolocateControl(props) {\n  var thisRef = useMapControl(props);\n  var context = thisRef.context,\n    containerRef = thisRef.containerRef;\n  var geolocateButtonRef = (0,react.useRef)(null);\n  var _useState = (0,react.useState)(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    mapboxGeolocateControl = _useState2[0],\n    createMapboxGeolocateControl = _useState2[1];\n  var _useState3 = (0,react.useState)(false),\n    _useState4 = _slicedToArray(_useState3, 2),\n    supportsGeolocation = _useState4[0],\n    setSupportsGeolocation = _useState4[1];\n  (0,react.useEffect)(function () {\n    var control;\n    if (context.map) {\n      isGeolocationSupported().then(function (result) {\n        setSupportsGeolocation(result);\n        if (geolocateButtonRef.current) {\n          control = setupMapboxGeolocateControl(context, props, geolocateButtonRef.current);\n          control._updateCamera = function (position) {\n            return updateCamera(position, thisRef);\n          };\n          createMapboxGeolocateControl(control);\n        }\n      });\n    }\n    return function () {\n      if (control) {\n        control._clearWatch();\n      }\n    };\n  }, [context.map]);\n  var triggerGeolocate = (0,react.useCallback)(function () {\n    if (mapboxGeolocateControl) {\n      mapboxGeolocateControl.options = thisRef.props;\n      mapboxGeolocateControl.trigger();\n    }\n  }, [mapboxGeolocateControl]);\n  (0,react.useEffect)(function () {\n    if (props.auto) {\n      triggerGeolocate();\n    }\n  }, [mapboxGeolocateControl, props.auto]);\n  (0,react.useEffect)(function () {\n    if (mapboxGeolocateControl) {\n      mapboxGeolocateControl._onZoom();\n    }\n  }, [context.viewport.zoom]);\n  var className = props.className,\n    label = props.label,\n    disabledLabel = props.disabledLabel,\n    trackUserLocation = props.trackUserLocation;\n  var style = (0,react.useMemo)(function () {\n    return geolocate_control_objectSpread({\n      position: 'absolute'\n    }, props.style);\n  }, [props.style]);\n  return react.createElement(\"div\", {\n    style: style,\n    className: className\n  }, react.createElement(\"div\", {\n    key: \"geolocate-control\",\n    className: \"mapboxgl-ctrl mapboxgl-ctrl-group\",\n    ref: containerRef\n  }, react.createElement(\"button\", {\n    key: \"geolocate\",\n    className: \"mapboxgl-ctrl-icon mapboxgl-ctrl-geolocate\",\n    ref: geolocateButtonRef,\n    disabled: !supportsGeolocation,\n    \"aria-pressed\": !trackUserLocation,\n    type: \"button\",\n    title: supportsGeolocation ? label : disabledLabel,\n    \"aria-label\": supportsGeolocation ? label : disabledLabel,\n    onClick: triggerGeolocate\n  }, react.createElement(\"span\", {\n    className: \"mapboxgl-ctrl-icon\",\n    \"aria-hidden\": \"true\"\n  }))));\n}\nGeolocateControl.defaultProps = geolocate_control_defaultProps;\n/* harmony default export */ var geolocate_control = (react.memo(GeolocateControl));\n;// ./node_modules/react-map-gl/dist/esm/utils/version.js\nfunction compareVersions(version1, version2) {\n  var v1 = (version1 || '').split('.').map(Number);\n  var v2 = (version2 || '').split('.').map(Number);\n  for (var i = 0; i < 3; i++) {\n    var part1 = v1[i] || 0;\n    var part2 = v2[i] || 0;\n    if (part1 < part2) {\n      return -1;\n    }\n    if (part1 > part2) {\n      return 1;\n    }\n  }\n  return 0;\n}\n;// ./node_modules/react-map-gl/dist/esm/components/navigation-control.js\n\nfunction navigation_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction navigation_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      navigation_control_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      navigation_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\n\n\nvar navigation_control_noop = function noop() {};\nvar navigation_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: '',\n  showCompass: true,\n  showZoom: true,\n  zoomInLabel: 'Zoom In',\n  zoomOutLabel: 'Zoom Out',\n  compassLabel: 'Reset North'\n});\nvar VERSION_LEGACY = 1;\nvar VERSION_1_6 = 2;\nfunction getUIVersion(mapboxVersion) {\n  return compareVersions(mapboxVersion, '1.6.0') >= 0 ? VERSION_1_6 : VERSION_LEGACY;\n}\nfunction updateViewport(context, props, opts) {\n  var viewport = context.viewport;\n  var mapState = new MapState(Object.assign({}, viewport, opts));\n  var viewState = Object.assign({}, mapState.getViewportProps(), LINEAR_TRANSITION_PROPS);\n  var onViewportChange = props.onViewportChange || context.onViewportChange || navigation_control_noop;\n  var onViewStateChange = props.onViewStateChange || context.onViewStateChange || navigation_control_noop;\n  onViewStateChange({\n    viewState: viewState\n  });\n  onViewportChange(viewState);\n}\nfunction renderButton(type, label, callback, children) {\n  return react.createElement(\"button\", {\n    key: type,\n    className: \"mapboxgl-ctrl-icon mapboxgl-ctrl-\".concat(type),\n    type: \"button\",\n    title: label,\n    onClick: callback\n  }, children || react.createElement(\"span\", {\n    className: \"mapboxgl-ctrl-icon\",\n    \"aria-hidden\": \"true\"\n  }));\n}\nfunction renderCompass(context) {\n  var uiVersion = (0,react.useMemo)(function () {\n    return context.map ? getUIVersion(context.map.version) : VERSION_1_6;\n  }, [context.map]);\n  var bearing = context.viewport.bearing;\n  var style = {\n    transform: \"rotate(\".concat(-bearing, \"deg)\")\n  };\n  return uiVersion === VERSION_1_6 ? react.createElement(\"span\", {\n    className: \"mapboxgl-ctrl-icon\",\n    \"aria-hidden\": \"true\",\n    style: style\n  }) : react.createElement(\"span\", {\n    className: \"mapboxgl-ctrl-compass-arrow\",\n    style: style\n  });\n}\nfunction NavigationControl(props) {\n  var _useMapControl = useMapControl(props),\n    context = _useMapControl.context,\n    containerRef = _useMapControl.containerRef;\n  var onZoomIn = function onZoomIn() {\n    updateViewport(context, props, {\n      zoom: context.viewport.zoom + 1\n    });\n  };\n  var onZoomOut = function onZoomOut() {\n    updateViewport(context, props, {\n      zoom: context.viewport.zoom - 1\n    });\n  };\n  var onResetNorth = function onResetNorth() {\n    updateViewport(context, props, {\n      bearing: 0,\n      pitch: 0\n    });\n  };\n  var className = props.className,\n    showCompass = props.showCompass,\n    showZoom = props.showZoom,\n    zoomInLabel = props.zoomInLabel,\n    zoomOutLabel = props.zoomOutLabel,\n    compassLabel = props.compassLabel;\n  var style = (0,react.useMemo)(function () {\n    return navigation_control_objectSpread({\n      position: 'absolute'\n    }, props.style);\n  }, [props.style]);\n  return react.createElement(\"div\", {\n    style: style,\n    className: className\n  }, react.createElement(\"div\", {\n    className: \"mapboxgl-ctrl mapboxgl-ctrl-group\",\n    ref: containerRef\n  }, showZoom && renderButton('zoom-in', zoomInLabel, onZoomIn), showZoom && renderButton('zoom-out', zoomOutLabel, onZoomOut), showCompass && renderButton('compass', compassLabel, onResetNorth, renderCompass(context))));\n}\nNavigationControl.defaultProps = navigation_control_defaultProps;\n/* harmony default export */ var navigation_control = (react.memo(NavigationControl));\n;// ./node_modules/react-map-gl/dist/esm/components/scale-control.js\n\n\nfunction scale_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction scale_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      scale_control_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      scale_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\n\n\nvar scale_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: '',\n  maxWidth: 100,\n  unit: 'metric'\n});\nfunction ScaleControl(props) {\n  var _useMapControl = useMapControl(props),\n    context = _useMapControl.context,\n    containerRef = _useMapControl.containerRef;\n  var _useState = (0,react.useState)(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    mapboxScaleControl = _useState2[0],\n    createMapboxScaleControl = _useState2[1];\n  (0,react.useEffect)(function () {\n    if (context.map) {\n      var control = new (maplibre_gl_default()).ScaleControl();\n      control._map = context.map;\n      control._container = containerRef.current;\n      createMapboxScaleControl(control);\n    }\n  }, [context.map]);\n  if (mapboxScaleControl) {\n    mapboxScaleControl.options = props;\n    if (mapboxScaleControl._onMove) mapboxScaleControl._onMove();\n  }\n  var style = (0,react.useMemo)(function () {\n    return scale_control_objectSpread({\n      position: 'absolute'\n    }, props.style);\n  }, [props.style]);\n  return react.createElement(\"div\", {\n    style: style,\n    className: props.className\n  }, react.createElement(\"div\", {\n    ref: containerRef,\n    className: \"mapboxgl-ctrl mapboxgl-ctrl-scale\"\n  }));\n}\nScaleControl.defaultProps = scale_control_defaultProps;\n/* harmony default export */ var scale_control = (react.memo(ScaleControl));\n;// ./node_modules/react-map-gl/dist/esm/overlays/canvas-overlay.js\n\n\n\n\nvar canvas_overlay_pixelRatio = typeof window !== 'undefined' && window.devicePixelRatio || 1;\nvar canvas_overlay_defaultProps = {\n  captureScroll: false,\n  captureDrag: false,\n  captureClick: false,\n  captureDoubleClick: false,\n  capturePointerMove: false\n};\nfunction CanvasOverlay(props) {\n  var _useMapControl = useMapControl(props),\n    context = _useMapControl.context,\n    containerRef = _useMapControl.containerRef;\n  var _useState = (0,react.useState)(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    ctx = _useState2[0],\n    setDrawingContext = _useState2[1];\n  (0,react.useEffect)(function () {\n    setDrawingContext(containerRef.current.getContext('2d'));\n  }, []);\n  var viewport = context.viewport,\n    isDragging = context.isDragging;\n  if (ctx) {\n    ctx.save();\n    ctx.scale(canvas_overlay_pixelRatio, canvas_overlay_pixelRatio);\n    props.redraw({\n      width: viewport.width,\n      height: viewport.height,\n      ctx: ctx,\n      isDragging: isDragging,\n      project: viewport.project,\n      unproject: viewport.unproject\n    });\n    ctx.restore();\n  }\n  return react.createElement(\"canvas\", {\n    ref: containerRef,\n    width: viewport.width * canvas_overlay_pixelRatio,\n    height: viewport.height * canvas_overlay_pixelRatio,\n    style: {\n      width: \"\".concat(viewport.width, \"px\"),\n      height: \"\".concat(viewport.height, \"px\"),\n      position: 'absolute',\n      left: 0,\n      top: 0\n    }\n  });\n}\nCanvasOverlay.defaultProps = canvas_overlay_defaultProps;\n/* harmony default export */ var canvas_overlay = ((/* unused pure expression or super */ null && (CanvasOverlay)));\n;// ./node_modules/react-map-gl/dist/esm/overlays/html-overlay.js\n\nfunction html_overlay_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction html_overlay_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      html_overlay_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      html_overlay_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\nvar html_overlay_defaultProps = {\n  captureScroll: false,\n  captureDrag: false,\n  captureClick: false,\n  captureDoubleClick: false,\n  capturePointerMove: false\n};\nfunction HTMLOverlay(props) {\n  var _useMapControl = useMapControl(props),\n    context = _useMapControl.context,\n    containerRef = _useMapControl.containerRef;\n  var viewport = context.viewport,\n    isDragging = context.isDragging;\n  var style = html_overlay_objectSpread({\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    width: viewport.width,\n    height: viewport.height\n  }, props.style);\n  return react.createElement(\"div\", {\n    ref: containerRef,\n    style: style\n  }, props.redraw({\n    width: viewport.width,\n    height: viewport.height,\n    isDragging: isDragging,\n    project: viewport.project,\n    unproject: viewport.unproject\n  }));\n}\nHTMLOverlay.defaultProps = html_overlay_defaultProps;\n/* harmony default export */ var html_overlay = ((/* unused pure expression or super */ null && (HTMLOverlay)));\n;// ./node_modules/react-map-gl/dist/esm/overlays/svg-overlay.js\n\nfunction svg_overlay_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction svg_overlay_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      svg_overlay_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      svg_overlay_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n\nvar svg_overlay_defaultProps = {\n  captureScroll: false,\n  captureDrag: false,\n  captureClick: false,\n  captureDoubleClick: false,\n  capturePointerMove: false\n};\nfunction SVGOverlay(props) {\n  var _useMapControl = useMapControl(props),\n    context = _useMapControl.context,\n    containerRef = _useMapControl.containerRef;\n  var viewport = context.viewport,\n    isDragging = context.isDragging;\n  var style = svg_overlay_objectSpread({\n    position: 'absolute',\n    left: 0,\n    top: 0\n  }, props.style);\n  return react.createElement(\"svg\", {\n    width: viewport.width,\n    height: viewport.height,\n    ref: containerRef,\n    style: style\n  }, props.redraw({\n    width: viewport.width,\n    height: viewport.height,\n    isDragging: isDragging,\n    project: viewport.project,\n    unproject: viewport.unproject\n  }));\n}\nSVGOverlay.defaultProps = svg_overlay_defaultProps;\n/* harmony default export */ var svg_overlay = ((/* unused pure expression or super */ null && (SVGOverlay)));\n;// ./node_modules/react-map-gl/dist/esm/utils/set-rtl-text-plugin.js\n\nvar setRTLTextPlugin = (maplibre_gl_default()) ? (maplibre_gl_default()).setRTLTextPlugin : function () {};\n/* harmony default export */ var set_rtl_text_plugin = ((/* unused pure expression or super */ null && (setRTLTextPlugin)));\n;// ./node_modules/react-map-gl/dist/esm/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;// ./node_modules/@turf/helpers/dist/es/index.js\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nvar earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nvar factors = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: earthRadius / 111325,\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1000,\n  kilometres: earthRadius / 1000,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1000,\n  millimetres: earthRadius * 1000,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nvar unitsFactors = {\n  centimeters: 100,\n  centimetres: 100,\n  degrees: 1 / 111325,\n  feet: 3.28084,\n  inches: 39.37,\n  kilometers: 1 / 1000,\n  kilometres: 1 / 1000,\n  meters: 1,\n  metres: 1,\n  miles: 1 / 1609.344,\n  millimeters: 1000,\n  millimetres: 1000,\n  nauticalmiles: 1 / 1852,\n  radians: 1 / earthRadius,\n  yards: 1.0936133\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nvar areaFactors = {\n  acres: 0.000247105,\n  centimeters: 10000,\n  centimetres: 10000,\n  feet: 10.763910417,\n  hectares: 0.0001,\n  inches: 1550.003100006,\n  kilometers: 0.000001,\n  kilometres: 0.000001,\n  meters: 1,\n  metres: 1,\n  miles: 3.86e-7,\n  millimeters: 1000000,\n  millimetres: 1000000,\n  yards: 1.195990046\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction es_feature(geom, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var feat = {\n    type: \"Feature\"\n  };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, _options) {\n  if (_options === void 0) {\n    _options = {};\n  }\n  switch (type) {\n    case \"Point\":\n      return es_point(coordinates).geometry;\n    case \"LineString\":\n      return es_lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction es_point(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n  var geom = {\n    type: \"Point\",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return featureCollection(coordinates.map(function (coords) {\n    return es_point(coords, properties);\n  }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n    var ring = coordinates_1[_i];\n    if (ring.length < 4) {\n      throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n    }\n    for (var j = 0; j < ring[ring.length - 1].length; j++) {\n      // Check if first point of Polygon contains two numbers\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  var geom = {\n    type: \"Polygon\",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return featureCollection(coordinates.map(function (coords) {\n    return polygon(coords, properties);\n  }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction es_lineString(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  var geom = {\n    type: \"LineString\",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return featureCollection(coordinates.map(function (coords) {\n    return es_lineString(coords, properties);\n  }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var fc = {\n    type: \"FeatureCollection\"\n  };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var geom = {\n    type: \"MultiLineString\",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var geom = {\n    type: \"MultiPoint\",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var geom = {\n    type: \"MultiPolygon\",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var geom = {\n    type: \"GeometryCollection\",\n    geometries: geometries\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction es_round(num, precision) {\n  if (precision === void 0) {\n    precision = 0;\n  }\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  var multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n  if (units === void 0) {\n    units = \"kilometers\";\n  }\n  var factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n  if (units === void 0) {\n    units = \"kilometers\";\n  }\n  var factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n  var angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n  var degrees = radians % (2 * Math.PI);\n  return degrees * 180 / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n  var radians = degrees % 360;\n  return radians * Math.PI / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n  if (originalUnit === void 0) {\n    originalUnit = \"kilometers\";\n  }\n  if (finalUnit === void 0) {\n    finalUnit = \"kilometers\";\n  }\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n  if (originalUnit === void 0) {\n    originalUnit = \"meters\";\n  }\n  if (finalUnit === void 0) {\n    finalUnit = \"kilometers\";\n  }\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n  var startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n  var finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n  return area / startFactor * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction es_isObject(input) {\n  return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach(function (num) {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\n;// ./node_modules/@turf/meta/dist/es/index.js\n\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++) if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n  }, excludeWrapCoord);\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;else previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n          {\n            if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n            break;\n          }\n        case \"GeometryCollection\":\n          {\n            for (j = 0; j < geometry.geometries.length; j++) {\n              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n            }\n            break;\n          }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(feature(geometry, properties, {\n          bbox: bbox,\n          id: id\n        }), featureIndex, 0) === false) return false;\n        return;\n    }\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n    if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n      // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n      if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n        previousCoords = currentCoord;\n        previousFeatureIndex = featureIndex;\n        previousMultiIndex = multiPartIndexCoord;\n        prevGeomIndex = geometryIndex;\n        segmentIndex = 0;\n        return;\n      }\n      var currentSegment = lineString([previousCoords, currentCoord], feature.properties);\n      if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n      segmentIndex++;\n      previousCoords = currentCoord;\n    }) === false) return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n    if (started === false && initialValue === undefined) previousValue = currentSegment;else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n    started = true;\n  });\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n        break;\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n;// ./node_modules/@turf/bbox/dist/es/index.js\n\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n  var result = [Infinity, Infinity, -Infinity, -Infinity];\n  coordEach(geojson, function (coord) {\n    if (result[0] > coord[0]) {\n      result[0] = coord[0];\n    }\n    if (result[1] > coord[1]) {\n      result[1] = coord[1];\n    }\n    if (result[2] < coord[0]) {\n      result[2] = coord[0];\n    }\n    if (result[3] < coord[1]) {\n      result[3] = coord[1];\n    }\n  });\n  return result;\n}\nbbox[\"default\"] = bbox;\n/* harmony default export */ var es = (bbox);\n;// ./node_modules/d3-ease/src/cubic.js\nfunction cubicIn(t) {\n  return t * t * t;\n}\nfunction cubicOut(t) {\n  return --t * t * t + 1;\n}\nfunction cubicInOut(t) {\n  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\n}\n// EXTERNAL MODULE: ./node_modules/react-device-detect/dist/lib.js\nvar dist_lib = __webpack_require__(8132);\n// EXTERNAL MODULE: ./node_modules/react-use/esm/useWindowSize.js + 3 modules\nvar useWindowSize = __webpack_require__(79835);\n// EXTERNAL MODULE: ./node_modules/react-use/esm/misc/util.js\nvar util = __webpack_require__(82466);\n;// ./node_modules/react-use/esm/useLocalStorage.js\n\n\nvar useLocalStorage = function (key, initialValue, options) {\n  if (!util/* isBrowser */.Bd) {\n    return [initialValue, util/* noop */.lQ, util/* noop */.lQ];\n  }\n  if (!key) {\n    throw new Error('useLocalStorage key may not be falsy');\n  }\n  var deserializer = options ? options.raw ? function (value) {\n    return value;\n  } : options.deserializer : JSON.parse;\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  var initializer = (0,react.useRef)(function (key) {\n    try {\n      var serializer = options ? options.raw ? String : options.serializer : JSON.stringify;\n      var localStorageValue = localStorage.getItem(key);\n      if (localStorageValue !== null) {\n        return deserializer(localStorageValue);\n      } else {\n        initialValue && localStorage.setItem(key, serializer(initialValue));\n        return initialValue;\n      }\n    } catch (_a) {\n      // If user is in private mode or has storage restriction\n      // localStorage can throw. JSON.parse and JSON.stringify\n      // can throw, too.\n      return initialValue;\n    }\n  });\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  var _a = (0,react.useState)(function () {\n      return initializer.current(key);\n    }),\n    state = _a[0],\n    setState = _a[1];\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  (0,react.useLayoutEffect)(function () {\n    return setState(initializer.current(key));\n  }, [key]);\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  var set = (0,react.useCallback)(function (valOrFunc) {\n    try {\n      var newState = typeof valOrFunc === 'function' ? valOrFunc(state) : valOrFunc;\n      if (typeof newState === 'undefined') return;\n      var value = void 0;\n      if (options) {\n        if (options.raw) {\n          if (typeof newState === 'string') value = newState;else value = JSON.stringify(newState);\n        } else if (options.serializer) value = options.serializer(newState);else value = JSON.stringify(newState);\n      } else value = JSON.stringify(newState);\n      localStorage.setItem(key, value);\n      setState(deserializer(value));\n    } catch (_a) {\n      // If user is in private mode or has storage restriction\n      // localStorage can throw. Also JSON.stringify can throw.\n    }\n  }, [key, setState]);\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  var remove = (0,react.useCallback)(function () {\n    try {\n      localStorage.removeItem(key);\n      setState(undefined);\n    } catch (_a) {\n      // If user is in private mode or has storage restriction\n      // localStorage can throw.\n    }\n  }, [key, setState]);\n  return [state, set, remove];\n};\n/* harmony default export */ var esm_useLocalStorage = (useLocalStorage);\n// EXTERNAL MODULE: ./src/contexts/FlagContext.tsx\nvar FlagContext = __webpack_require__(19576);\n;// ./src/components/DisadvantageDot/DisadvantageDot.module.scss\n// extracted by mini-css-extract-plugin\nvar disadvantagedDotBig = \"DisadvantageDot-module--disadvantagedDotBig--uEj+Y\";\nvar disadvantagedDotSmall = \"DisadvantageDot-module--disadvantagedDotSmall--75NmP\";\n;// ./src/components/DisadvantageDot/DisadvantageDot.tsx\nconst DisadvantageDot=_ref=>{let{isDisadvantaged=false,isBig}=_ref;let computedClass='';if(isBig){computedClass=disadvantagedDotBig;}else{computedClass=isDisadvantaged?disadvantagedDotSmall:'';}return/*#__PURE__*/react.createElement(\"div\",{className:computedClass});};/* harmony default export */ var DisadvantageDot_DisadvantageDot = (DisadvantageDot);\n;// ./src/components/DisadvantageDot/index.tsx\n/* harmony default export */ var components_DisadvantageDot = (DisadvantageDot_DisadvantageDot);\n;// ./src/components/Category/Category.module.scss\n// extracted by mini-css-extract-plugin\nvar category = \"Category-module--category--QiyGB\";\nvar categoryContainer = \"Category-module--categoryContainer--hJQyd\";\nvar disCategoryContainer = \"Category-module--disCategoryContainer--K7Ziw\";\n;// ./src/components/Category/Category.tsx\n/**\n * This component controls the Categories on the side panel.\n *\n * The category will be styled differently differently depending on\n * if the category is disadvantaged or not. The JSX in the return\n * statement is identical however in the global CSS file, we\n * override the disadvantaged case with a psuedo-selector (:has) that\n * is new. In order to fallback gracefully for browsers that do\n * not yet support the \":has\" psuedo selector, this redundant JSX\n * will allow the disadvantaged case show the older category styling\n * while browsers that do support the \":has\" psuedo selector will\n * render the newer category style.\n *\n * @param {string} name\n * @param {boolean} isDisadvagtaged\n * @return {JSX.Element}\n */const Category=_ref=>{let{name,isDisadvantaged}=_ref;return isDisadvantaged?/*#__PURE__*/react.createElement(\"div\",{className:disCategoryContainer},/*#__PURE__*/react.createElement(\"div\",{className:category},name),/*#__PURE__*/react.createElement(components_DisadvantageDot,{isDisadvantaged:isDisadvantaged})):/*#__PURE__*/react.createElement(\"div\",{className:categoryContainer},/*#__PURE__*/react.createElement(\"div\",{className:category},name),/*#__PURE__*/react.createElement(components_DisadvantageDot,{isDisadvantaged:isDisadvantaged}));};/* harmony default export */ var Category_Category = (Category);\n;// ./src/components/Category/index.tsx\n/* harmony default export */ var components_Category = (Category_Category);\n;// ./node_modules/react-tooltip/node_modules/uuid/dist/esm-browser/rng.js\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n// find the complete implementation of crypto (msCrypto) on IE11.\nvar getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);\nvar rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\nfunction rng() {\n  if (!getRandomValues) {\n    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n  }\n  return getRandomValues(rnds8);\n}\n;// ./node_modules/react-tooltip/node_modules/uuid/dist/esm-browser/bytesToUuid.js\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\n  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');\n}\n/* harmony default export */ var esm_browser_bytesToUuid = (bytesToUuid);\n;// ./node_modules/react-tooltip/node_modules/uuid/dist/esm-browser/v4.js\n\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n  if (typeof options == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n  return buf || esm_browser_bytesToUuid(rnds);\n}\n/* harmony default export */ var esm_browser_v4 = (v4);\n;// ./node_modules/react-tooltip/dist/index.es.js\n\n\n\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {\n      index_es_defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction index_es_classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction index_es_defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction index_es_createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) index_es_defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) index_es_defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction index_es_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction index_es_extends() {\n  index_es_extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return index_es_extends.apply(this, arguments);\n}\nfunction index_es_inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction index_es_getPrototypeOf(o) {\n  index_es_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return index_es_getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction index_es_isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction index_es_assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction index_es_possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return index_es_assertThisInitialized(self);\n}\nfunction index_es_createSuper(Derived) {\n  var hasNativeReflectConstruct = index_es_isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = index_es_getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = index_es_getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return index_es_possibleConstructorReturn(this, result);\n  };\n}\nfunction index_es_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return index_es_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return index_es_arrayLikeToArray(o, minLen);\n}\nfunction index_es_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction index_es_createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = index_es_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function () {};\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$a =\n// eslint-disable-next-line es/no-global-this -- safe\ncheck(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) ||\n// eslint-disable-next-line no-restricted-globals -- safe\ncheck(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n// eslint-disable-next-line no-new-func -- fallback\nfunction () {\n  return this;\n}() || Function('return this')();\nvar objectGetOwnPropertyDescriptor = {};\nvar fails$9 = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\nvar fails$8 = fails$9;\n\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$8(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, {\n    get: function () {\n      return 7;\n    }\n  })[1] != 7;\n});\nvar fails$7 = fails$9;\nvar functionBindNative = !fails$7(function () {\n  // eslint-disable-next-line es/no-function-prototype-bind -- safe\n  var test = function () {/* empty */}.bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\nvar NATIVE_BIND$2 = functionBindNative;\nvar call$4 = Function.prototype.call;\nvar functionCall = NATIVE_BIND$2 ? call$4.bind(call$4) : function () {\n  return call$4.apply(call$4, arguments);\n};\nvar objectPropertyIsEnumerable = {};\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({\n  1: 2\n}, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor$1(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\nvar createPropertyDescriptor$2 = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\nvar NATIVE_BIND$1 = functionBindNative;\nvar FunctionPrototype$1 = Function.prototype;\nvar call$3 = FunctionPrototype$1.call;\nvar uncurryThisWithBind = NATIVE_BIND$1 && FunctionPrototype$1.bind.bind(call$3, call$3);\nvar functionUncurryThisRaw = function (fn) {\n  return NATIVE_BIND$1 ? uncurryThisWithBind(fn) : function () {\n    return call$3.apply(fn, arguments);\n  };\n};\nvar uncurryThisRaw$1 = functionUncurryThisRaw;\nvar toString$1 = uncurryThisRaw$1({}.toString);\nvar stringSlice = uncurryThisRaw$1(''.slice);\nvar classofRaw$2 = function (it) {\n  return stringSlice(toString$1(it), 8, -1);\n};\nvar classofRaw$1 = classofRaw$2;\nvar uncurryThisRaw = functionUncurryThisRaw;\nvar functionUncurryThis = function (fn) {\n  // Nashorn bug:\n  //   https://github.com/zloirock/core-js/issues/1128\n  //   https://github.com/zloirock/core-js/issues/1130\n  if (classofRaw$1(fn) === 'Function') return uncurryThisRaw(fn);\n};\nvar uncurryThis$9 = functionUncurryThis;\nvar fails$6 = fails$9;\nvar classof$3 = classofRaw$2;\nvar $Object$3 = Object;\nvar split = uncurryThis$9(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$6(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object$3('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof$3(it) == 'String' ? split(it, '') : $Object$3(it);\n} : $Object$3;\n\n// we can't use just `it == null` since of `document.all` special case\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec\nvar isNullOrUndefined$2 = function (it) {\n  return it === null || it === undefined;\n};\nvar isNullOrUndefined$1 = isNullOrUndefined$2;\nvar $TypeError$5 = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$2 = function (it) {\n  if (isNullOrUndefined$1(it)) throw $TypeError$5(\"Can't call method on \" + it);\n  return it;\n};\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$1 = indexedObject;\nvar requireObjectCoercible$1 = requireObjectCoercible$2;\nvar toIndexedObject$4 = function (it) {\n  return IndexedObject$1(requireObjectCoercible$1(it));\n};\nvar documentAll$2 = typeof document == 'object' && document.all;\n\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\nvar IS_HTMLDDA = typeof documentAll$2 == 'undefined' && documentAll$2 !== undefined;\nvar documentAll_1 = {\n  all: documentAll$2,\n  IS_HTMLDDA: IS_HTMLDDA\n};\nvar $documentAll$1 = documentAll_1;\nvar documentAll$1 = $documentAll$1.all;\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$c = $documentAll$1.IS_HTMLDDA ? function (argument) {\n  return typeof argument == 'function' || argument === documentAll$1;\n} : function (argument) {\n  return typeof argument == 'function';\n};\nvar isCallable$b = isCallable$c;\nvar $documentAll = documentAll_1;\nvar documentAll = $documentAll.all;\nvar isObject$6 = $documentAll.IS_HTMLDDA ? function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$b(it) || it === documentAll;\n} : function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$b(it);\n};\nvar global$9 = global$a;\nvar isCallable$a = isCallable$c;\nvar aFunction = function (argument) {\n  return isCallable$a(argument) ? argument : undefined;\n};\nvar getBuiltIn$5 = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global$9[namespace]) : global$9[namespace] && global$9[namespace][method];\n};\nvar uncurryThis$8 = functionUncurryThis;\nvar objectIsPrototypeOf = uncurryThis$8({}.isPrototypeOf);\nvar getBuiltIn$4 = getBuiltIn$5;\nvar engineUserAgent = getBuiltIn$4('navigator', 'userAgent') || '';\nvar global$8 = global$a;\nvar index_es_userAgent = engineUserAgent;\nvar index_es_process = global$8.process;\nvar Deno = global$8.Deno;\nvar versions = index_es_process && index_es_process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && index_es_userAgent) {\n  match = index_es_userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = index_es_userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\nvar engineV8Version = version;\n\n/* eslint-disable es/no-symbol -- required for testing */\n\nvar V8_VERSION = engineV8Version;\nvar fails$5 = fails$9;\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\nvar symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$5(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n  // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n  !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n\n/* eslint-disable es/no-symbol -- required for testing */\n\nvar NATIVE_SYMBOL$1 = symbolConstructorDetection;\nvar useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == 'symbol';\nvar getBuiltIn$3 = getBuiltIn$5;\nvar isCallable$9 = isCallable$c;\nvar index_es_isPrototypeOf = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\nvar $Object$2 = Object;\nvar isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn$3('Symbol');\n  return isCallable$9($Symbol) && index_es_isPrototypeOf($Symbol.prototype, $Object$2(it));\n};\nvar $String$1 = String;\nvar tryToString$1 = function (argument) {\n  try {\n    return $String$1(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\nvar isCallable$8 = isCallable$c;\nvar tryToString = tryToString$1;\nvar $TypeError$4 = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nvar aCallable$2 = function (argument) {\n  if (isCallable$8(argument)) return argument;\n  throw $TypeError$4(tryToString(argument) + ' is not a function');\n};\nvar aCallable$1 = aCallable$2;\nvar isNullOrUndefined = isNullOrUndefined$2;\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$1 = function (V, P) {\n  var func = V[P];\n  return isNullOrUndefined(func) ? undefined : aCallable$1(func);\n};\nvar call$2 = functionCall;\nvar isCallable$7 = isCallable$c;\nvar isObject$5 = isObject$6;\nvar $TypeError$3 = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable$7(fn = input.toString) && !isObject$5(val = call$2(fn, input))) return val;\n  if (isCallable$7(fn = input.valueOf) && !isObject$5(val = call$2(fn, input))) return val;\n  if (pref !== 'string' && isCallable$7(fn = input.toString) && !isObject$5(val = call$2(fn, input))) return val;\n  throw $TypeError$3(\"Can't convert object to primitive value\");\n};\nvar shared$3 = {\n  exports: {}\n};\nvar global$7 = global$a;\n\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty$2 = Object.defineProperty;\nvar defineGlobalProperty$3 = function (key, value) {\n  try {\n    defineProperty$2(global$7, key, {\n      value: value,\n      configurable: true,\n      writable: true\n    });\n  } catch (error) {\n    global$7[key] = value;\n  }\n  return value;\n};\nvar global$6 = global$a;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\nvar SHARED = '__core-js_shared__';\nvar store$3 = global$6[SHARED] || defineGlobalProperty$2(SHARED, {});\nvar sharedStore = store$3;\nvar store$2 = sharedStore;\n(shared$3.exports = function (key, value) {\n  return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.25.5',\n  mode: 'global',\n  copyright: ' 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.25.5/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\nvar requireObjectCoercible = requireObjectCoercible$2;\nvar $Object$1 = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$2 = function (argument) {\n  return $Object$1(requireObjectCoercible(argument));\n};\nvar uncurryThis$7 = functionUncurryThis;\nvar toObject$1 = toObject$2;\nvar index_es_hasOwnProperty = uncurryThis$7({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n  return index_es_hasOwnProperty(toObject$1(it), key);\n};\nvar uncurryThis$6 = functionUncurryThis;\nvar id = 0;\nvar postfix = Math.random();\nvar index_es_toString = uncurryThis$6(1.0.toString);\nvar uid$2 = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + index_es_toString(++id + postfix, 36);\n};\nvar global$5 = global$a;\nvar shared$2 = shared$3.exports;\nvar hasOwn$6 = hasOwnProperty_1;\nvar uid$1 = uid$2;\nvar NATIVE_SYMBOL = symbolConstructorDetection;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\nvar WellKnownSymbolsStore = shared$2('wks');\nvar Symbol$1 = global$5.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;\nvar wellKnownSymbol$5 = function (name) {\n  if (!hasOwn$6(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL && hasOwn$6(Symbol$1, name)) {\n      WellKnownSymbolsStore[name] = Symbol$1[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  }\n  return WellKnownSymbolsStore[name];\n};\nvar call$1 = functionCall;\nvar isObject$4 = isObject$6;\nvar isSymbol$1 = isSymbol$2;\nvar getMethod = getMethod$1;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$4 = wellKnownSymbol$5;\nvar $TypeError$2 = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$4('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$1 = function (input, pref) {\n  if (!isObject$4(input) || isSymbol$1(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call$1(exoticToPrim, input, pref);\n    if (!isObject$4(result) || isSymbol$1(result)) return result;\n    throw $TypeError$2(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\nvar index_es_toPrimitive = toPrimitive$1;\nvar isSymbol = isSymbol$2;\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$2 = function (argument) {\n  var key = index_es_toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\nvar global$4 = global$a;\nvar isObject$3 = isObject$6;\nvar document$1 = global$4.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$3(document$1) && isObject$3(document$1.createElement);\nvar documentCreateElement$1 = function (it) {\n  return EXISTS$1 ? document$1.createElement(it) : {};\n};\nvar DESCRIPTORS$7 = descriptors;\nvar fails$4 = fails$9;\nvar createElement = documentCreateElement$1;\n\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$7 && !fails$4(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () {\n      return 7;\n    }\n  }).a != 7;\n});\nvar DESCRIPTORS$6 = descriptors;\nvar call = functionCall;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$2;\nvar toIndexedObject$3 = toIndexedObject$4;\nvar toPropertyKey$1 = toPropertyKey$2;\nvar hasOwn$5 = hasOwnProperty_1;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$6 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject$3(O);\n  P = toPropertyKey$1(P);\n  if (IE8_DOM_DEFINE$1) try {\n    return $getOwnPropertyDescriptor$1(O, P);\n  } catch (error) {/* empty */}\n  if (hasOwn$5(O, P)) return createPropertyDescriptor$1(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n};\nvar objectDefineProperty = {};\nvar DESCRIPTORS$5 = descriptors;\nvar fails$3 = fails$9;\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$5 && fails$3(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () {/* empty */}, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\nvar isObject$2 = isObject$6;\nvar $String = String;\nvar $TypeError$1 = TypeError;\n\n// `Assert: Type(argument) is Object`\nvar anObject$4 = function (argument) {\n  if (isObject$2(argument)) return argument;\n  throw $TypeError$1($String(argument) + ' is not an object');\n};\nvar DESCRIPTORS$4 = descriptors;\nvar IE8_DOM_DEFINE = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$3 = anObject$4;\nvar index_es_toPropertyKey = toPropertyKey$2;\nvar $TypeError = TypeError;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE$1 = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$4 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n  anObject$3(O);\n  P = index_es_toPropertyKey(P);\n  anObject$3(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  }\n  return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject$3(O);\n  P = index_es_toPropertyKey(P);\n  anObject$3(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) {/* empty */}\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\nvar DESCRIPTORS$3 = descriptors;\nvar definePropertyModule$3 = objectDefineProperty;\nvar createPropertyDescriptor = createPropertyDescriptor$2;\nvar createNonEnumerableProperty$2 = DESCRIPTORS$3 ? function (object, key, value) {\n  return definePropertyModule$3.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\nvar makeBuiltIn$2 = {\n  exports: {}\n};\nvar DESCRIPTORS$2 = descriptors;\nvar hasOwn$4 = hasOwnProperty_1;\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$2 && Object.getOwnPropertyDescriptor;\nvar EXISTS = hasOwn$4(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && function something() {/* empty */}.name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$2 || DESCRIPTORS$2 && getDescriptor(FunctionPrototype, 'name').configurable);\nvar functionName = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\nvar uncurryThis$5 = functionUncurryThis;\nvar isCallable$6 = isCallable$c;\nvar store$1 = sharedStore;\nvar functionToString = uncurryThis$5(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$6(store$1.inspectSource)) {\n  store$1.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\nvar inspectSource$2 = store$1.inspectSource;\nvar global$3 = global$a;\nvar isCallable$5 = isCallable$c;\nvar WeakMap$1 = global$3.WeakMap;\nvar weakMapBasicDetection = isCallable$5(WeakMap$1) && /native code/.test(String(WeakMap$1));\nvar shared$1 = shared$3.exports;\nvar uid = uid$2;\nvar keys = shared$1('keys');\nvar sharedKey$2 = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\nvar hiddenKeys$4 = {};\nvar NATIVE_WEAK_MAP = weakMapBasicDetection;\nvar global$2 = global$a;\nvar isObject$1 = isObject$6;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$2;\nvar hasOwn$3 = hasOwnProperty_1;\nvar shared = sharedStore;\nvar sharedKey$1 = sharedKey$2;\nvar hiddenKeys$3 = hiddenKeys$4;\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError$1 = global$2.TypeError;\nvar index_es_WeakMap = global$2.WeakMap;\nvar index_es_set, get, has;\nvar enforce = function (it) {\n  return has(it) ? get(it) : index_es_set(it, {});\n};\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject$1(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError$1('Incompatible receiver, ' + TYPE + ' required');\n    }\n    return state;\n  };\n};\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new index_es_WeakMap());\n  /* eslint-disable no-self-assign -- prototype methods protection */\n  store.get = store.get;\n  store.has = store.has;\n  store.set = store.set;\n  /* eslint-enable no-self-assign -- prototype methods protection */\n  index_es_set = function (it, metadata) {\n    if (store.has(it)) throw TypeError$1(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    store.set(it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return store.get(it) || {};\n  };\n  has = function (it) {\n    return store.has(it);\n  };\n} else {\n  var STATE = sharedKey$1('state');\n  hiddenKeys$3[STATE] = true;\n  index_es_set = function (it, metadata) {\n    if (hasOwn$3(it, STATE)) throw TypeError$1(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty$1(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn$3(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn$3(it, STATE);\n  };\n}\nvar internalState = {\n  set: index_es_set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\nvar fails$2 = fails$9;\nvar isCallable$4 = isCallable$c;\nvar hasOwn$2 = hasOwnProperty_1;\nvar DESCRIPTORS$1 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;\nvar inspectSource$1 = inspectSource$2;\nvar InternalStateModule = internalState;\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty$1 = Object.defineProperty;\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$1 && !fails$2(function () {\n  return defineProperty$1(function () {/* empty */}, 'length', {\n    value: 8\n  }).length !== 8;\n});\nvar TEMPLATE = String(String).split('String');\nvar makeBuiltIn$1 = makeBuiltIn$2.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn$2(value, 'name') || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {\n    if (DESCRIPTORS$1) defineProperty$1(value, 'name', {\n      value: name,\n      configurable: true\n    });else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn$2(options, 'arity') && value.length !== options.arity) {\n    defineProperty$1(value, 'length', {\n      value: options.arity\n    });\n  }\n  try {\n    if (options && hasOwn$2(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS$1) defineProperty$1(value, 'prototype', {\n        writable: false\n      });\n      // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) {/* empty */}\n  var state = enforceInternalState(value);\n  if (!hasOwn$2(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  }\n  return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$1(function toString() {\n  return isCallable$4(this) && getInternalState(this).source || inspectSource$1(this);\n}, 'toString');\nvar isCallable$3 = isCallable$c;\nvar definePropertyModule$2 = objectDefineProperty;\nvar makeBuiltIn = makeBuiltIn$2.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\nvar defineBuiltIn$1 = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable$3(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;else defineGlobalProperty$1(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];else if (O[key]) simple = true;\n    } catch (error) {/* empty */}\n    if (simple) O[key] = value;else definePropertyModule$2.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  }\n  return O;\n};\nvar objectGetOwnPropertyNames = {};\nvar index_es_ceil = Math.ceil;\nvar index_es_floor = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? index_es_floor : index_es_ceil)(n);\n};\nvar trunc = mathTrunc;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$2 = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$2;\nvar index_es_max = Math.max;\nvar min$1 = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$1 = function (index, length) {\n  var integer = toIntegerOrInfinity$1(index);\n  return integer < 0 ? index_es_max(integer + length, 0) : min$1(integer, length);\n};\nvar toIntegerOrInfinity = toIntegerOrInfinity$2;\nvar index_es_min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$1 = function (argument) {\n  return argument > 0 ? index_es_min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\nvar toLength = toLength$1;\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$2 = function (obj) {\n  return toLength(obj.length);\n};\nvar toIndexedObject$2 = toIndexedObject$4;\nvar toAbsoluteIndex = toAbsoluteIndex$1;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$2;\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod$1 = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject$2($this);\n    var length = lengthOfArrayLike$1(O);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n      // Array#indexOf ignores holes, Array#includes - not\n    } else for (; length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    }\n    return !IS_INCLUDES && -1;\n  };\n};\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod$1(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod$1(false)\n};\nvar uncurryThis$4 = functionUncurryThis;\nvar hasOwn$1 = hasOwnProperty_1;\nvar toIndexedObject$1 = toIndexedObject$4;\nvar indexOf = arrayIncludes.indexOf;\nvar hiddenKeys$2 = hiddenKeys$4;\nvar push$1 = uncurryThis$4([].push);\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject$1(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn$1(hiddenKeys$2, key) && hasOwn$1(O, key) && push$1(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn$1(O, key = names[i++])) {\n    ~indexOf(result, key) || push$1(result, key);\n  }\n  return result;\n};\n\n// IE8- don't enum bug keys\nvar enumBugKeys$3 = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\nvar hiddenKeys$1 = enumBugKeys$2.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys$1(O, hiddenKeys$1);\n};\nvar objectGetOwnPropertySymbols = {};\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\nvar getBuiltIn$2 = getBuiltIn$5;\nvar uncurryThis$3 = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar anObject$2 = anObject$4;\nvar concat = uncurryThis$3([].concat);\n\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn$2('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject$2(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\nvar hasOwn = hasOwnProperty_1;\nvar index_es_ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar definePropertyModule$1 = objectDefineProperty;\nvar copyConstructorProperties$1 = function (target, source, exceptions) {\n  var keys = index_es_ownKeys(source);\n  var defineProperty = definePropertyModule$1.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\nvar fails$1 = fails$9;\nvar isCallable$2 = isCallable$c;\nvar replacement = /#|\\.prototype\\./;\nvar isForced$1 = function (feature, detection) {\n  var value = data[index_es_normalize(feature)];\n  return value == POLYFILL ? true : value == NATIVE ? false : isCallable$2(detection) ? fails$1(detection) : !!detection;\n};\nvar index_es_normalize = isForced$1.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\nvar data = isForced$1.data = {};\nvar NATIVE = isForced$1.NATIVE = 'N';\nvar POLYFILL = isForced$1.POLYFILL = 'P';\nvar isForced_1 = isForced$1;\nvar index_es_global$1 = global$a;\nvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty = createNonEnumerableProperty$2;\nvar defineBuiltIn = defineBuiltIn$1;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties = copyConstructorProperties$1;\nvar isForced = isForced_1;\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = index_es_global$1;\n  } else if (STATIC) {\n    target = index_es_global$1[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (index_es_global$1[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || targetProperty && targetProperty.sham) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn(target, key, sourceProperty, options);\n  }\n};\nvar uncurryThis$2 = functionUncurryThis;\nvar aCallable = aCallable$2;\nvar NATIVE_BIND = functionBindNative;\nvar bind$1 = uncurryThis$2(uncurryThis$2.bind);\n\n// optional / simple context binding\nvar functionBindContext = function (fn, that) {\n  aCallable(fn);\n  return that === undefined ? fn : NATIVE_BIND ? bind$1(fn, that) : function /* ...args */\n  () {\n    return fn.apply(that, arguments);\n  };\n};\nvar classof$2 = classofRaw$2;\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es/no-array-isarray -- safe\nvar isArray$1 = Array.isArray || function isArray(argument) {\n  return classof$2(argument) == 'Array';\n};\nvar wellKnownSymbol$3 = wellKnownSymbol$5;\nvar TO_STRING_TAG$1 = wellKnownSymbol$3('toStringTag');\nvar test = {};\ntest[TO_STRING_TAG$1] = 'z';\nvar toStringTagSupport = String(test) === '[object z]';\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable$1 = isCallable$c;\nvar classofRaw = classofRaw$2;\nvar wellKnownSymbol$2 = wellKnownSymbol$5;\nvar TO_STRING_TAG = wellKnownSymbol$2('toStringTag');\nvar $Object = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () {\n  return arguments;\n}()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) {/* empty */}\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$1 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n  // @@toStringTag case\n  : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag\n  // builtinTag case\n  : CORRECT_ARGUMENTS ? classofRaw(O)\n  // ES3 arguments fallback\n  : (result = classofRaw(O)) == 'Object' && isCallable$1(O.callee) ? 'Arguments' : result;\n};\nvar uncurryThis$1 = functionUncurryThis;\nvar fails = fails$9;\nvar isCallable = isCallable$c;\nvar classof = classof$1;\nvar getBuiltIn$1 = getBuiltIn$5;\nvar inspectSource = inspectSource$2;\nvar index_es_noop = function () {/* empty */};\nvar empty = [];\nvar construct = getBuiltIn$1('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec = uncurryThis$1(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(index_es_noop);\nvar isConstructorModern = function isConstructor(argument) {\n  if (!isCallable(argument)) return false;\n  try {\n    construct(index_es_noop, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\nvar isConstructorLegacy = function isConstructor(argument) {\n  if (!isCallable(argument)) return false;\n  switch (classof(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction':\n      return false;\n  }\n  try {\n    // we can't check .prototype since constructors produced by .bind haven't it\n    // `Function#toString` throws on some built-it function in some legacy engines\n    // (for example, `DOMQuad` and similar in FF41-)\n    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));\n  } catch (error) {\n    return true;\n  }\n};\nisConstructorLegacy.sham = true;\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nvar isConstructor$1 = !construct || fails(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function () {\n    called = true;\n  }) || called;\n}) ? isConstructorLegacy : isConstructorModern;\nvar index_es_isArray = isArray$1;\nvar isConstructor = isConstructor$1;\nvar index_es_isObject = isObject$6;\nvar wellKnownSymbol$1 = wellKnownSymbol$5;\nvar SPECIES = wellKnownSymbol$1('species');\nvar $Array = Array;\n\n// a part of `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nvar arraySpeciesConstructor$1 = function (originalArray) {\n  var C;\n  if (index_es_isArray(originalArray)) {\n    C = originalArray.constructor;\n    // cross-realm fallback\n    if (isConstructor(C) && (C === $Array || index_es_isArray(C.prototype))) C = undefined;else if (index_es_isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  }\n  return C === undefined ? $Array : C;\n};\nvar arraySpeciesConstructor = arraySpeciesConstructor$1;\n\n// `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nvar arraySpeciesCreate$1 = function (originalArray, length) {\n  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);\n};\nvar bind = functionBindContext;\nvar uncurryThis = functionUncurryThis;\nvar IndexedObject = indexedObject;\nvar toObject = toObject$2;\nvar lengthOfArrayLike = lengthOfArrayLike$2;\nvar arraySpeciesCreate = arraySpeciesCreate$1;\nvar push = uncurryThis([].push);\n\n// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation\nvar createMethod = function (TYPE) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var IS_FILTER_REJECT = TYPE == 7;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  return function ($this, callbackfn, that, specificCreate) {\n    var O = toObject($this);\n    var self = IndexedObject(O);\n    var boundFunction = bind(callbackfn, that);\n    var length = lengthOfArrayLike(self);\n    var index = 0;\n    var create = specificCreate || arraySpeciesCreate;\n    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;\n    var value, result;\n    for (; length > index; index++) if (NO_HOLES || index in self) {\n      value = self[index];\n      result = boundFunction(value, index, O);\n      if (TYPE) {\n        if (IS_MAP) target[index] = result; // map\n        else if (result) switch (TYPE) {\n          case 3:\n            return true;\n          // some\n          case 5:\n            return value;\n          // find\n          case 6:\n            return index;\n          // findIndex\n          case 2:\n            push(target, value);\n          // filter\n        } else switch (TYPE) {\n          case 4:\n            return false;\n          // every\n          case 7:\n            push(target, value);\n          // filterReject\n        }\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\nvar arrayIteration = {\n  // `Array.prototype.forEach` method\n  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n  forEach: createMethod(0),\n  // `Array.prototype.map` method\n  // https://tc39.es/ecma262/#sec-array.prototype.map\n  map: createMethod(1),\n  // `Array.prototype.filter` method\n  // https://tc39.es/ecma262/#sec-array.prototype.filter\n  filter: createMethod(2),\n  // `Array.prototype.some` method\n  // https://tc39.es/ecma262/#sec-array.prototype.some\n  some: createMethod(3),\n  // `Array.prototype.every` method\n  // https://tc39.es/ecma262/#sec-array.prototype.every\n  every: createMethod(4),\n  // `Array.prototype.find` method\n  // https://tc39.es/ecma262/#sec-array.prototype.find\n  find: createMethod(5),\n  // `Array.prototype.findIndex` method\n  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n  findIndex: createMethod(6),\n  // `Array.prototype.filterReject` method\n  // https://github.com/tc39/proposal-array-filtering\n  filterReject: createMethod(7)\n};\nvar objectDefineProperties = {};\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys$1 = enumBugKeys$3;\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es/no-object-keys -- safe\nvar objectKeys$1 = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys$1);\n};\nvar DESCRIPTORS = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule = objectDefineProperty;\nvar anObject$1 = anObject$4;\nvar toIndexedObject = toIndexedObject$4;\nvar objectKeys = objectKeys$1;\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es/no-object-defineproperties -- safe\nobjectDefineProperties.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject$1(O);\n  var props = toIndexedObject(Properties);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);\n  return O;\n};\nvar getBuiltIn = getBuiltIn$5;\nvar html$1 = getBuiltIn('document', 'documentElement');\n\n/* global ActiveXObject -- old IE, WSH */\n\nvar anObject = anObject$4;\nvar definePropertiesModule = objectDefineProperties;\nvar enumBugKeys = enumBugKeys$3;\nvar hiddenKeys = hiddenKeys$4;\nvar html = html$1;\nvar documentCreateElement = documentCreateElement$1;\nvar sharedKey = sharedKey$2;\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar EmptyConstructor = function () {/* empty */};\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) {/* ignore */}\n  NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n  : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys.length;\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n  return NullProtoObject();\n};\nhiddenKeys[IE_PROTO] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es/no-object-create -- safe\nvar objectCreate = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\nvar wellKnownSymbol = wellKnownSymbol$5;\nvar index_es_create = objectCreate;\nvar defineProperty = objectDefineProperty.f;\nvar UNSCOPABLES = wellKnownSymbol('unscopables');\nvar ArrayPrototype = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n  defineProperty(ArrayPrototype, UNSCOPABLES, {\n    configurable: true,\n    value: index_es_create(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nvar addToUnscopables$1 = function (key) {\n  ArrayPrototype[UNSCOPABLES][key] = true;\n};\nvar $ = _export;\nvar $find = arrayIteration.find;\nvar addToUnscopables = addToUnscopables$1;\nvar FIND = 'find';\nvar SKIPS_HOLES = true;\n\n// Shouldn't skip holes\nif (FIND in []) Array(1)[FIND](function () {\n  SKIPS_HOLES = false;\n});\n\n// `Array.prototype.find` method\n// https://tc39.es/ecma262/#sec-array.prototype.find\n$({\n  target: 'Array',\n  proto: true,\n  forced: SKIPS_HOLES\n}, {\n  find: function find(callbackfn /* , that = undefined */) {\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables(FIND);\nvar CONSTANT = {\n  GLOBAL: {\n    HIDE: '__react_tooltip_hide_event',\n    REBUILD: '__react_tooltip_rebuild_event',\n    SHOW: '__react_tooltip_show_event'\n  }\n};\n\n/**\n * Static methods for react-tooltip\n */\nvar dispatchGlobalEvent = function dispatchGlobalEvent(eventName, opts) {\n  // Compatible with IE\n  // @see http://stackoverflow.com/questions/26596123/internet-explorer-9-10-11-event-constructor-doesnt-work\n  // @see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n  var event;\n  if (typeof window.CustomEvent === 'function') {\n    event = new window.CustomEvent(eventName, {\n      detail: opts\n    });\n  } else {\n    event = document.createEvent('Event');\n    event.initEvent(eventName, false, true, opts);\n  }\n  window.dispatchEvent(event);\n};\nfunction staticMethods(target) {\n  /**\n   * Hide all tooltip\n   * @trigger ReactTooltip.hide()\n   */\n  target.hide = function (target) {\n    dispatchGlobalEvent(CONSTANT.GLOBAL.HIDE, {\n      target: target\n    });\n  };\n\n  /**\n   * Rebuild all tooltip\n   * @trigger ReactTooltip.rebuild()\n   */\n  target.rebuild = function () {\n    dispatchGlobalEvent(CONSTANT.GLOBAL.REBUILD);\n  };\n\n  /**\n   * Show specific tooltip\n   * @trigger ReactTooltip.show()\n   */\n  target.show = function (target) {\n    dispatchGlobalEvent(CONSTANT.GLOBAL.SHOW, {\n      target: target\n    });\n  };\n  target.prototype.globalRebuild = function () {\n    if (this.mount) {\n      this.unbindListener();\n      this.bindListener();\n    }\n  };\n  target.prototype.globalShow = function (event) {\n    if (this.mount) {\n      var hasTarget = event && event.detail && event.detail.target && true || false;\n      // Create a fake event, specific show will limit the type to `solid`\n      // only `float` type cares e.clientX e.clientY\n      this.showTooltip({\n        currentTarget: hasTarget && event.detail.target\n      }, true);\n    }\n  };\n  target.prototype.globalHide = function (event) {\n    if (this.mount) {\n      var hasTarget = event && event.detail && event.detail.target && true || false;\n      this.hideTooltip({\n        currentTarget: hasTarget && event.detail.target\n      }, hasTarget);\n    }\n  };\n}\n\n/**\n * Events that should be bound to the window\n */\nfunction windowListener(target) {\n  target.prototype.bindWindowEvents = function (resizeHide) {\n    // ReactTooltip.hide\n    window.removeEventListener(CONSTANT.GLOBAL.HIDE, this.globalHide);\n    window.addEventListener(CONSTANT.GLOBAL.HIDE, this.globalHide, false);\n\n    // ReactTooltip.rebuild\n    window.removeEventListener(CONSTANT.GLOBAL.REBUILD, this.globalRebuild);\n    window.addEventListener(CONSTANT.GLOBAL.REBUILD, this.globalRebuild, false);\n\n    // ReactTooltip.show\n    window.removeEventListener(CONSTANT.GLOBAL.SHOW, this.globalShow);\n    window.addEventListener(CONSTANT.GLOBAL.SHOW, this.globalShow, false);\n\n    // Resize\n    if (resizeHide) {\n      window.removeEventListener('resize', this.onWindowResize);\n      window.addEventListener('resize', this.onWindowResize, false);\n    }\n  };\n  target.prototype.unbindWindowEvents = function () {\n    window.removeEventListener(CONSTANT.GLOBAL.HIDE, this.globalHide);\n    window.removeEventListener(CONSTANT.GLOBAL.REBUILD, this.globalRebuild);\n    window.removeEventListener(CONSTANT.GLOBAL.SHOW, this.globalShow);\n    window.removeEventListener('resize', this.onWindowResize);\n  };\n\n  /**\n   * invoked by resize event of window\n   */\n  target.prototype.onWindowResize = function () {\n    if (!this.mount) return;\n    this.hideTooltip();\n  };\n}\n\n/**\n * Custom events to control showing and hiding of tooltip\n *\n * @attributes\n * - `event` {String}\n * - `eventOff` {String}\n */\n\nvar checkStatus = function checkStatus(dataEventOff, e) {\n  var show = this.state.show;\n  var id = this.props.id;\n  var isCapture = this.isCapture(e.currentTarget);\n  var currentItem = e.currentTarget.getAttribute('currentItem');\n  if (!isCapture) e.stopPropagation();\n  if (show && currentItem === 'true') {\n    if (!dataEventOff) this.hideTooltip(e);\n  } else {\n    e.currentTarget.setAttribute('currentItem', 'true');\n    setUntargetItems(e.currentTarget, this.getTargetArray(id));\n    this.showTooltip(e);\n  }\n};\nvar setUntargetItems = function setUntargetItems(currentTarget, targetArray) {\n  for (var i = 0; i < targetArray.length; i++) {\n    if (currentTarget !== targetArray[i]) {\n      targetArray[i].setAttribute('currentItem', 'false');\n    } else {\n      targetArray[i].setAttribute('currentItem', 'true');\n    }\n  }\n};\nvar customListeners = {\n  id: '9b69f92e-d3fe-498b-b1b4-c5e63a51b0cf',\n  set: function set(target, event, listener) {\n    if (this.id in target) {\n      var map = target[this.id];\n      map[event] = listener;\n    } else {\n      // this is workaround for WeakMap, which is not supported in older browsers, such as IE\n      Object.defineProperty(target, this.id, {\n        configurable: true,\n        value: index_es_defineProperty({}, event, listener)\n      });\n    }\n  },\n  get: function get(target, event) {\n    var map = target[this.id];\n    if (map !== undefined) {\n      return map[event];\n    }\n  }\n};\nfunction customEvent(target) {\n  target.prototype.isCustomEvent = function (ele) {\n    var event = this.state.event;\n    return event || !!ele.getAttribute('data-event');\n  };\n\n  /* Bind listener for custom event */\n  target.prototype.customBindListener = function (ele) {\n    var _this = this;\n    var _this$state = this.state,\n      event = _this$state.event,\n      eventOff = _this$state.eventOff;\n    var dataEvent = ele.getAttribute('data-event') || event;\n    var dataEventOff = ele.getAttribute('data-event-off') || eventOff;\n    dataEvent.split(' ').forEach(function (event) {\n      ele.removeEventListener(event, customListeners.get(ele, event));\n      var customListener = checkStatus.bind(_this, dataEventOff);\n      customListeners.set(ele, event, customListener);\n      ele.addEventListener(event, customListener, false);\n    });\n    if (dataEventOff) {\n      dataEventOff.split(' ').forEach(function (event) {\n        ele.removeEventListener(event, _this.hideTooltip);\n        ele.addEventListener(event, _this.hideTooltip, false);\n      });\n    }\n  };\n\n  /* Unbind listener for custom event */\n  target.prototype.customUnbindListener = function (ele) {\n    var _this$state2 = this.state,\n      event = _this$state2.event,\n      eventOff = _this$state2.eventOff;\n    var dataEvent = event || ele.getAttribute('data-event');\n    var dataEventOff = eventOff || ele.getAttribute('data-event-off');\n    ele.removeEventListener(dataEvent, customListeners.get(ele, event));\n    if (dataEventOff) ele.removeEventListener(dataEventOff, this.hideTooltip);\n  };\n}\n\n/**\n * Util method to judge if it should follow capture model\n */\n\nfunction isCapture(target) {\n  target.prototype.isCapture = function (currentTarget) {\n    return currentTarget && currentTarget.getAttribute('data-iscapture') === 'true' || this.props.isCapture || false;\n  };\n}\n\n/**\n * Util method to get effect\n */\n\nfunction getEffect(target) {\n  target.prototype.getEffect = function (currentTarget) {\n    var dataEffect = currentTarget.getAttribute('data-effect');\n    return dataEffect || this.props.effect || 'float';\n  };\n}\n\n/**\n * Util method to get effect\n */\nvar makeProxy = function makeProxy(e) {\n  var proxy = {};\n  for (var key in e) {\n    if (typeof e[key] === 'function') {\n      proxy[key] = e[key].bind(e);\n    } else {\n      proxy[key] = e[key];\n    }\n  }\n  return proxy;\n};\nvar bodyListener = function bodyListener(callback, options, e) {\n  var _options$respectEffec = options.respectEffect,\n    respectEffect = _options$respectEffec === void 0 ? false : _options$respectEffec,\n    _options$customEvent = options.customEvent,\n    customEvent = _options$customEvent === void 0 ? false : _options$customEvent;\n  var id = this.props.id;\n  var tip = null;\n  var forId;\n  var target = e.target;\n  var lastTarget;\n  // walk up parent chain until tip is found\n  // there is no match if parent visible area is matched by mouse position, so some corner cases might not work as expected\n  while (tip === null && target !== null) {\n    lastTarget = target;\n    tip = target.getAttribute('data-tip') || null;\n    forId = target.getAttribute('data-for') || null;\n    target = target.parentElement;\n  }\n  target = lastTarget || e.target;\n  if (this.isCustomEvent(target) && !customEvent) {\n    return;\n  }\n  var isTargetBelongsToTooltip = id == null && forId == null || forId === id;\n  if (tip != null && (!respectEffect || this.getEffect(target) === 'float') && isTargetBelongsToTooltip) {\n    var proxy = makeProxy(e);\n    proxy.currentTarget = target;\n    callback(proxy);\n  }\n};\nvar findCustomEvents = function findCustomEvents(targetArray, dataAttribute) {\n  var events = {};\n  targetArray.forEach(function (target) {\n    var event = target.getAttribute(dataAttribute);\n    if (event) event.split(' ').forEach(function (event) {\n      return events[event] = true;\n    });\n  });\n  return events;\n};\nvar getBody = function getBody() {\n  return document.getElementsByTagName('body')[0];\n};\nfunction bodyMode(target) {\n  target.prototype.isBodyMode = function () {\n    return !!this.props.bodyMode;\n  };\n  target.prototype.bindBodyListener = function (targetArray) {\n    var _this = this;\n    var _this$state = this.state,\n      event = _this$state.event,\n      eventOff = _this$state.eventOff,\n      possibleCustomEvents = _this$state.possibleCustomEvents,\n      possibleCustomEventsOff = _this$state.possibleCustomEventsOff;\n    var body = getBody();\n    var customEvents = findCustomEvents(targetArray, 'data-event');\n    var customEventsOff = findCustomEvents(targetArray, 'data-event-off');\n    if (event != null) customEvents[event] = true;\n    if (eventOff != null) customEventsOff[eventOff] = true;\n    possibleCustomEvents.split(' ').forEach(function (event) {\n      return customEvents[event] = true;\n    });\n    possibleCustomEventsOff.split(' ').forEach(function (event) {\n      return customEventsOff[event] = true;\n    });\n    this.unbindBodyListener(body);\n    var listeners = this.bodyModeListeners = {};\n    if (event == null) {\n      listeners.mouseover = bodyListener.bind(this, this.showTooltip, {});\n      listeners.mousemove = bodyListener.bind(this, this.updateTooltip, {\n        respectEffect: true\n      });\n      listeners.mouseout = bodyListener.bind(this, this.hideTooltip, {});\n    }\n    for (var _event in customEvents) {\n      listeners[_event] = bodyListener.bind(this, function (e) {\n        var targetEventOff = e.currentTarget.getAttribute('data-event-off') || eventOff;\n        checkStatus.call(_this, targetEventOff, e);\n      }, {\n        customEvent: true\n      });\n    }\n    for (var _event2 in customEventsOff) {\n      listeners[_event2] = bodyListener.bind(this, this.hideTooltip, {\n        customEvent: true\n      });\n    }\n    for (var _event3 in listeners) {\n      body.addEventListener(_event3, listeners[_event3]);\n    }\n  };\n  target.prototype.unbindBodyListener = function (body) {\n    body = body || getBody();\n    var listeners = this.bodyModeListeners;\n    for (var event in listeners) {\n      body.removeEventListener(event, listeners[event]);\n    }\n  };\n}\n\n/**\n * Tracking target removing from DOM.\n * It's necessary to hide tooltip when it's target disappears.\n * Otherwise, the tooltip would be shown forever until another target\n * is triggered.\n *\n * If MutationObserver is not available, this feature just doesn't work.\n */\n\n// https://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/\nvar getMutationObserverClass = function getMutationObserverClass() {\n  return window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;\n};\nfunction trackRemoval(target) {\n  target.prototype.bindRemovalTracker = function () {\n    var _this = this;\n    var MutationObserver = getMutationObserverClass();\n    if (MutationObserver == null) return;\n    var observer = new MutationObserver(function (mutations) {\n      for (var m1 = 0; m1 < mutations.length; m1++) {\n        var mutation = mutations[m1];\n        for (var m2 = 0; m2 < mutation.removedNodes.length; m2++) {\n          var element = mutation.removedNodes[m2];\n          if (element === _this.state.currentTarget) {\n            _this.hideTooltip();\n            return;\n          }\n        }\n      }\n    });\n    observer.observe(window.document, {\n      childList: true,\n      subtree: true\n    });\n    this.removalTracker = observer;\n  };\n  target.prototype.unbindRemovalTracker = function () {\n    if (this.removalTracker) {\n      this.removalTracker.disconnect();\n      this.removalTracker = null;\n    }\n  };\n}\n\n/**\n * Calculate the position of tooltip\n *\n * @params\n * - `e` {Event} the event of current mouse\n * - `target` {Element} the currentTarget of the event\n * - `node` {DOM} the react-tooltip object\n * - `place` {String} top / right / bottom / left\n * - `effect` {String} float / solid\n * - `offset` {Object} the offset to default position\n *\n * @return {Object}\n * - `isNewState` {Bool} required\n * - `newState` {Object}\n * - `position` {Object} {left: {Number}, top: {Number}}\n */\nfunction index_es_getPosition(e, target, node, place, desiredPlace, effect, offset) {\n  var _getDimensions = getDimensions(node),\n    tipWidth = _getDimensions.width,\n    tipHeight = _getDimensions.height;\n  var _getDimensions2 = getDimensions(target),\n    targetWidth = _getDimensions2.width,\n    targetHeight = _getDimensions2.height;\n  var _getCurrentOffset = getCurrentOffset(e, target, effect),\n    mouseX = _getCurrentOffset.mouseX,\n    mouseY = _getCurrentOffset.mouseY;\n  var defaultOffset = getDefaultPosition(effect, targetWidth, targetHeight, tipWidth, tipHeight);\n  var _calculateOffset = calculateOffset(offset),\n    extraOffsetX = _calculateOffset.extraOffsetX,\n    extraOffsetY = _calculateOffset.extraOffsetY;\n  var windowWidth = window.innerWidth;\n  var windowHeight = window.innerHeight;\n  var _getParent = getParent(node),\n    parentTop = _getParent.parentTop,\n    parentLeft = _getParent.parentLeft;\n\n  // Get the edge offset of the tooltip\n  var getTipOffsetLeft = function getTipOffsetLeft(place) {\n    var offsetX = defaultOffset[place].l;\n    return mouseX + offsetX + extraOffsetX;\n  };\n  var getTipOffsetRight = function getTipOffsetRight(place) {\n    var offsetX = defaultOffset[place].r;\n    return mouseX + offsetX + extraOffsetX;\n  };\n  var getTipOffsetTop = function getTipOffsetTop(place) {\n    var offsetY = defaultOffset[place].t;\n    return mouseY + offsetY + extraOffsetY;\n  };\n  var getTipOffsetBottom = function getTipOffsetBottom(place) {\n    var offsetY = defaultOffset[place].b;\n    return mouseY + offsetY + extraOffsetY;\n  };\n\n  //\n  // Functions to test whether the tooltip's sides are inside\n  // the client window for a given orientation p\n  //\n  //  _____________\n  // |             | <-- Right side\n  // | p = 'left'  |\\\n  // |             |/  |\\\n  // |_____________|   |_\\  <-- Mouse\n  //      / \\           |\n  //       |\n  //       |\n  //  Bottom side\n  //\n  var outsideLeft = function outsideLeft(p) {\n    return getTipOffsetLeft(p) < 0;\n  };\n  var outsideRight = function outsideRight(p) {\n    return getTipOffsetRight(p) > windowWidth;\n  };\n  var outsideTop = function outsideTop(p) {\n    return getTipOffsetTop(p) < 0;\n  };\n  var outsideBottom = function outsideBottom(p) {\n    return getTipOffsetBottom(p) > windowHeight;\n  };\n\n  // Check whether the tooltip with orientation p is completely inside the client window\n  var outside = function outside(p) {\n    return outsideLeft(p) || outsideRight(p) || outsideTop(p) || outsideBottom(p);\n  };\n  var inside = function inside(p) {\n    return !outside(p);\n  };\n  var placeIsInside = {\n    top: inside('top'),\n    bottom: inside('bottom'),\n    left: inside('left'),\n    right: inside('right')\n  };\n  function choose() {\n    var allPlaces = desiredPlace.split(',').concat(place, ['top', 'bottom', 'left', 'right']);\n    var _iterator = index_es_createForOfIteratorHelper(allPlaces),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var d = _step.value;\n        if (placeIsInside[d]) return d;\n      }\n      // if nothing is inside, just use the old place.\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return place;\n  }\n  var chosen = choose();\n  var isNewState = false;\n  var newPlace;\n  if (chosen && chosen !== place) {\n    isNewState = true;\n    newPlace = chosen;\n  }\n  if (isNewState) {\n    return {\n      isNewState: true,\n      newState: {\n        place: newPlace\n      }\n    };\n  }\n  return {\n    isNewState: false,\n    position: {\n      left: parseInt(getTipOffsetLeft(place) - parentLeft, 10),\n      top: parseInt(getTipOffsetTop(place) - parentTop, 10)\n    }\n  };\n}\nvar getDimensions = function getDimensions(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n    height = _node$getBoundingClie.height,\n    width = _node$getBoundingClie.width;\n  return {\n    height: parseInt(height, 10),\n    width: parseInt(width, 10)\n  };\n};\n\n// Get current mouse offset\nvar getCurrentOffset = function getCurrentOffset(e, currentTarget, effect) {\n  var boundingClientRect = currentTarget.getBoundingClientRect();\n  var targetTop = boundingClientRect.top;\n  var targetLeft = boundingClientRect.left;\n  var _getDimensions3 = getDimensions(currentTarget),\n    targetWidth = _getDimensions3.width,\n    targetHeight = _getDimensions3.height;\n  if (effect === 'float') {\n    return {\n      mouseX: e.clientX,\n      mouseY: e.clientY\n    };\n  }\n  return {\n    mouseX: targetLeft + targetWidth / 2,\n    mouseY: targetTop + targetHeight / 2\n  };\n};\n\n// List all possibility of tooltip final offset\n// This is useful in judging if it is necessary for tooltip to switch position when out of window\nvar getDefaultPosition = function getDefaultPosition(effect, targetWidth, targetHeight, tipWidth, tipHeight) {\n  var top;\n  var right;\n  var bottom;\n  var left;\n  var disToMouse = 3;\n  var triangleHeight = 2;\n  var cursorHeight = 12; // Optimize for float bottom only, cause the cursor will hide the tooltip\n\n  if (effect === 'float') {\n    top = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: -(tipHeight + disToMouse + triangleHeight),\n      b: -disToMouse\n    };\n    bottom = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: disToMouse + cursorHeight,\n      b: tipHeight + disToMouse + triangleHeight + cursorHeight\n    };\n    left = {\n      l: -(tipWidth + disToMouse + triangleHeight),\n      r: -disToMouse,\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n    right = {\n      l: disToMouse,\n      r: tipWidth + disToMouse + triangleHeight,\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n  } else if (effect === 'solid') {\n    top = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: -(targetHeight / 2 + tipHeight + triangleHeight),\n      b: -(targetHeight / 2)\n    };\n    bottom = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: targetHeight / 2,\n      b: targetHeight / 2 + tipHeight + triangleHeight\n    };\n    left = {\n      l: -(tipWidth + targetWidth / 2 + triangleHeight),\n      r: -(targetWidth / 2),\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n    right = {\n      l: targetWidth / 2,\n      r: tipWidth + targetWidth / 2 + triangleHeight,\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n  }\n  return {\n    top: top,\n    bottom: bottom,\n    left: left,\n    right: right\n  };\n};\n\n// Consider additional offset into position calculation\nvar calculateOffset = function calculateOffset(offset) {\n  var extraOffsetX = 0;\n  var extraOffsetY = 0;\n  if (Object.prototype.toString.apply(offset) === '[object String]') {\n    offset = JSON.parse(offset.toString().replace(/'/g, '\"'));\n  }\n  for (var key in offset) {\n    if (key === 'top') {\n      extraOffsetY -= parseInt(offset[key], 10);\n    } else if (key === 'bottom') {\n      extraOffsetY += parseInt(offset[key], 10);\n    } else if (key === 'left') {\n      extraOffsetX -= parseInt(offset[key], 10);\n    } else if (key === 'right') {\n      extraOffsetX += parseInt(offset[key], 10);\n    }\n  }\n  return {\n    extraOffsetX: extraOffsetX,\n    extraOffsetY: extraOffsetY\n  };\n};\n\n// Get the offset of the parent elements\nvar getParent = function getParent(currentTarget) {\n  var currentParent = currentTarget;\n  while (currentParent) {\n    var computedStyle = window.getComputedStyle(currentParent);\n    // transform and will-change: transform change the containing block\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_Block\n    if (computedStyle.getPropertyValue('transform') !== 'none' || computedStyle.getPropertyValue('will-change') === 'transform') break;\n    currentParent = currentParent.parentElement;\n  }\n  var parentTop = currentParent && currentParent.getBoundingClientRect().top || 0;\n  var parentLeft = currentParent && currentParent.getBoundingClientRect().left || 0;\n  return {\n    parentTop: parentTop,\n    parentLeft: parentLeft\n  };\n};\n\n/**\n * To get the tooltip content\n * it may comes from data-tip or this.props.children\n * it should support multiline\n *\n * @params\n * - `tip` {String} value of data-tip\n * - `children` {ReactElement} this.props.children\n * - `multiline` {Any} could be Bool(true/false) or String('true'/'false')\n *\n * @return\n * - String or react component\n */\nfunction TipContent(tip, children, getContent, multiline) {\n  if (children) return children;\n  if (getContent !== undefined && getContent !== null) return getContent; // getContent can be 0, '', etc.\n  if (getContent === null) return null; // Tip not exist and children is null or undefined\n\n  var regexp = /<br\\s*\\/?>/;\n  if (!multiline || multiline === 'false' || !regexp.test(tip)) {\n    // No trim(), so that user can keep their input\n    return tip;\n  }\n\n  // Multiline tooltip content\n  return tip.split(regexp).map(function (d, i) {\n    return /*#__PURE__*/react.createElement(\"span\", {\n      key: i,\n      className: \"multi-line\"\n    }, d);\n  });\n}\n\n/**\n * Support aria- and role in ReactTooltip\n *\n * @params props {Object}\n * @return {Object}\n */\nfunction parseAria(props) {\n  var ariaObj = {};\n  Object.keys(props).filter(function (prop) {\n    // aria-xxx and role is acceptable\n    return /(^aria-\\w+$|^role$)/.test(prop);\n  }).forEach(function (prop) {\n    ariaObj[prop] = props[prop];\n  });\n  return ariaObj;\n}\n\n/**\n * Convert nodelist to array\n * @see https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/core/createArrayFromMixed.js#L24\n * NodeLists are functions in Safari\n */\n\nfunction nodeListToArray(nodeList) {\n  var length = nodeList.length;\n  if (nodeList.hasOwnProperty) {\n    return Array.prototype.slice.call(nodeList);\n  }\n  return new Array(length).fill().map(function (index) {\n    return nodeList[index];\n  });\n}\nfunction generateUUID() {\n  return 't' + esm_browser_v4();\n}\nvar baseCss = \".__react_component_tooltip {\\n  border-radius: 3px;\\n  display: inline-block;\\n  font-size: 13px;\\n  left: -999em;\\n  opacity: 0;\\n  position: fixed;\\n  pointer-events: none;\\n  transition: opacity 0.3s ease-out;\\n  top: -999em;\\n  visibility: hidden;\\n  z-index: 999;\\n}\\n.__react_component_tooltip.allow_hover, .__react_component_tooltip.allow_click {\\n  pointer-events: auto;\\n}\\n.__react_component_tooltip::before, .__react_component_tooltip::after {\\n  content: \\\"\\\";\\n  width: 0;\\n  height: 0;\\n  position: absolute;\\n}\\n.__react_component_tooltip.show {\\n  opacity: 0.9;\\n  margin-top: 0;\\n  margin-left: 0;\\n  visibility: visible;\\n}\\n.__react_component_tooltip.place-top::before {\\n  bottom: 0;\\n  left: 50%;\\n  margin-left: -11px;\\n}\\n.__react_component_tooltip.place-bottom::before {\\n  top: 0;\\n  left: 50%;\\n  margin-left: -11px;\\n}\\n.__react_component_tooltip.place-left::before {\\n  right: 0;\\n  top: 50%;\\n  margin-top: -9px;\\n}\\n.__react_component_tooltip.place-right::before {\\n  left: 0;\\n  top: 50%;\\n  margin-top: -9px;\\n}\\n.__react_component_tooltip .multi-line {\\n  display: block;\\n  padding: 2px 0;\\n  text-align: center;\\n}\";\n\n/**\n * Default pop-up style values (text color, background color).\n */\nvar defaultColors = {\n  dark: {\n    text: '#fff',\n    background: '#222',\n    border: 'transparent',\n    arrow: '#222'\n  },\n  success: {\n    text: '#fff',\n    background: '#8DC572',\n    border: 'transparent',\n    arrow: '#8DC572'\n  },\n  warning: {\n    text: '#fff',\n    background: '#F0AD4E',\n    border: 'transparent',\n    arrow: '#F0AD4E'\n  },\n  error: {\n    text: '#fff',\n    background: '#BE6464',\n    border: 'transparent',\n    arrow: '#BE6464'\n  },\n  info: {\n    text: '#fff',\n    background: '#337AB7',\n    border: 'transparent',\n    arrow: '#337AB7'\n  },\n  light: {\n    text: '#222',\n    background: '#fff',\n    border: 'transparent',\n    arrow: '#fff'\n  }\n};\nfunction getDefaultPopupColors(type) {\n  return defaultColors[type] ? _objectSpread2({}, defaultColors[type]) : undefined;\n}\nvar DEFAULT_PADDING = '8px 21px';\nvar DEFAULT_RADIUS = {\n  tooltip: 3,\n  arrow: 0\n};\n\n/**\n * Generates the specific tooltip style for use on render.\n */\nfunction generateTooltipStyle(uuid, customColors, type, hasBorder, padding, radius) {\n  return generateStyle(uuid, getPopupColors(customColors, type, hasBorder), padding, radius);\n}\n\n/**\n * Generates the tooltip style rules based on the element-specified \"data-type\" property.\n */\nfunction generateStyle(uuid, colors) {\n  var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_PADDING;\n  var radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_RADIUS;\n  var textColor = colors.text;\n  var backgroundColor = colors.background;\n  var borderColor = colors.border;\n  var arrowColor = colors.arrow;\n  var arrowRadius = radius.arrow;\n  var tooltipRadius = radius.tooltip;\n  return \"\\n  \\t.\".concat(uuid, \" {\\n\\t    color: \").concat(textColor, \";\\n\\t    background: \").concat(backgroundColor, \";\\n\\t    border: 1px solid \").concat(borderColor, \";\\n\\t    border-radius: \").concat(tooltipRadius, \"px;\\n\\t    padding: \").concat(padding, \";\\n  \\t}\\n\\n  \\t.\").concat(uuid, \".place-top {\\n        margin-top: -10px;\\n    }\\n    .\").concat(uuid, \".place-top::before {\\n        content: \\\"\\\";\\n        background-color: inherit;\\n        position: absolute;\\n        z-index: 2;\\n        width: 20px;\\n        height: 12px;\\n    }\\n    .\").concat(uuid, \".place-top::after {\\n        content: \\\"\\\";\\n        position: absolute;\\n        width: 10px;\\n        height: 10px;\\n        border-top-right-radius: \").concat(arrowRadius, \"px;\\n        border: 1px solid \").concat(borderColor, \";\\n        background-color: \").concat(arrowColor, \";\\n        z-index: -2;\\n        bottom: -6px;\\n        left: 50%;\\n        margin-left: -6px;\\n        transform: rotate(135deg);\\n    }\\n\\n    .\").concat(uuid, \".place-bottom {\\n        margin-top: 10px;\\n    }\\n    .\").concat(uuid, \".place-bottom::before {\\n        content: \\\"\\\";\\n        background-color: inherit;\\n        position: absolute;\\n        z-index: -1;\\n        width: 18px;\\n        height: 10px;\\n    }\\n    .\").concat(uuid, \".place-bottom::after {\\n        content: \\\"\\\";\\n        position: absolute;\\n        width: 10px;\\n        height: 10px;\\n        border-top-right-radius: \").concat(arrowRadius, \"px;\\n        border: 1px solid \").concat(borderColor, \";\\n        background-color: \").concat(arrowColor, \";\\n        z-index: -2;\\n        top: -6px;\\n        left: 50%;\\n        margin-left: -6px;\\n        transform: rotate(45deg);\\n    }\\n\\n    .\").concat(uuid, \".place-left {\\n        margin-left: -10px;\\n    }\\n    .\").concat(uuid, \".place-left::before {\\n        content: \\\"\\\";\\n        background-color: inherit;\\n        position: absolute;\\n        z-index: -1;\\n        width: 10px;\\n        height: 18px;\\n    }\\n    .\").concat(uuid, \".place-left::after {\\n        content: \\\"\\\";\\n        position: absolute;\\n        width: 10px;\\n        height: 10px;\\n        border-top-right-radius: \").concat(arrowRadius, \"px;\\n        border: 1px solid \").concat(borderColor, \";\\n        background-color: \").concat(arrowColor, \";\\n        z-index: -2;\\n        right: -6px;\\n        top: 50%;\\n        margin-top: -6px;\\n        transform: rotate(45deg);\\n    }\\n\\n    .\").concat(uuid, \".place-right {\\n        margin-left: 10px;\\n    }\\n    .\").concat(uuid, \".place-right::before {\\n        content: \\\"\\\";\\n        background-color: inherit;\\n        position: absolute;\\n        z-index: -1;\\n        width: 10px;\\n        height: 18px;\\n    }\\n    .\").concat(uuid, \".place-right::after {\\n        content: \\\"\\\";\\n        position: absolute;\\n        width: 10px;\\n        height: 10px;\\n        border-top-right-radius: \").concat(arrowRadius, \"px;\\n        border: 1px solid \").concat(borderColor, \";\\n        background-color: \").concat(arrowColor, \";\\n        z-index: -2;\\n        left: -6px;\\n        top: 50%;\\n        margin-top: -6px;\\n        transform: rotate(-135deg);\\n    }\\n  \");\n}\nfunction getPopupColors(customColors, type, hasBorder) {\n  var textColor = customColors.text;\n  var backgroundColor = customColors.background;\n  var borderColor = customColors.border;\n  var arrowColor = customColors.arrow ? customColors.arrow : customColors.background;\n  var colors = getDefaultPopupColors(type);\n  if (textColor) {\n    colors.text = textColor;\n  }\n  if (backgroundColor) {\n    colors.background = backgroundColor;\n  }\n  if (hasBorder) {\n    if (borderColor) {\n      colors.border = borderColor;\n    } else {\n      colors.border = type === 'light' ? 'black' : 'white';\n    }\n  }\n  if (arrowColor) {\n    colors.arrow = arrowColor;\n  }\n  return colors;\n}\nvar _class, _class2;\n\n/* Polyfill */\nvar ReactTooltip = staticMethods(_class = windowListener(_class = customEvent(_class = isCapture(_class = getEffect(_class = bodyMode(_class = trackRemoval(_class = (_class2 = /*#__PURE__*/function (_React$Component) {\n  index_es_inherits(ReactTooltip, _React$Component);\n  var _super = index_es_createSuper(ReactTooltip);\n  function ReactTooltip(props) {\n    var _this;\n    index_es_classCallCheck(this, ReactTooltip);\n    _this = _super.call(this, props);\n    _this.state = {\n      uuid: props.uuid || generateUUID(),\n      place: props.place || 'top',\n      // Direction of tooltip\n      desiredPlace: props.place || 'top',\n      type: props.type || 'dark',\n      // Color theme of tooltip\n      effect: props.effect || 'float',\n      // float or fixed\n      show: false,\n      border: false,\n      borderClass: 'border',\n      customColors: {},\n      customRadius: {},\n      offset: {},\n      padding: props.padding,\n      extraClass: '',\n      html: false,\n      delayHide: 0,\n      delayShow: 0,\n      event: props.event || null,\n      eventOff: props.eventOff || null,\n      currentEvent: null,\n      // Current mouse event\n      currentTarget: null,\n      // Current target of mouse event\n      ariaProps: parseAria(props),\n      // aria- and role attributes\n      isEmptyTip: false,\n      disable: false,\n      possibleCustomEvents: props.possibleCustomEvents || '',\n      possibleCustomEventsOff: props.possibleCustomEventsOff || '',\n      originTooltip: null,\n      isMultiline: false\n    };\n    _this.bind(['showTooltip', 'updateTooltip', 'hideTooltip', 'hideTooltipOnScroll', 'getTooltipContent', 'globalRebuild', 'globalShow', 'globalHide', 'onWindowResize', 'mouseOnToolTip']);\n    _this.mount = true;\n    _this.delayShowLoop = null;\n    _this.delayHideLoop = null;\n    _this.delayReshow = null;\n    _this.intervalUpdateContent = null;\n    return _this;\n  }\n\n  /**\n   * For unify the bind and unbind listener\n   */\n  index_es_createClass(ReactTooltip, [{\n    key: \"bind\",\n    value: function bind(methodArray) {\n      var _this2 = this;\n      methodArray.forEach(function (method) {\n        _this2[method] = _this2[method].bind(_this2);\n      });\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props = this.props;\n      _this$props.insecure;\n      var resizeHide = _this$props.resizeHide,\n        disableInternalStyle = _this$props.disableInternalStyle;\n      this.mount = true;\n      this.bindListener(); // Bind listener for tooltip\n      this.bindWindowEvents(resizeHide); // Bind global event for static method\n\n      if (!disableInternalStyle) {\n        this.injectStyles(); // Inject styles for each DOM root having tooltip.\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.mount = false;\n      this.clearTimer();\n      this.unbindListener();\n      this.removeScrollListener(this.state.currentTarget);\n      this.unbindWindowEvents();\n    }\n\n    /* Look for the closest DOM root having tooltip and inject styles. */\n  }, {\n    key: \"injectStyles\",\n    value: function injectStyles() {\n      var tooltipRef = this.tooltipRef;\n      if (!tooltipRef) {\n        return;\n      }\n      var parentNode = tooltipRef.parentNode;\n      while (parentNode.parentNode) {\n        parentNode = parentNode.parentNode;\n      }\n      var domRoot;\n      switch (parentNode.constructor.name) {\n        case 'Document':\n        case 'HTMLDocument':\n        case undefined:\n          domRoot = parentNode.head;\n          break;\n        case 'ShadowRoot':\n        default:\n          domRoot = parentNode;\n          break;\n      }\n\n      // Prevent styles duplication.\n      if (!domRoot.querySelector('style[data-react-tooltip]')) {\n        var style = document.createElement('style');\n        style.textContent = baseCss;\n        style.setAttribute('data-react-tooltip', 'true');\n        domRoot.appendChild(style);\n      }\n    }\n\n    /**\n     * Return if the mouse is on the tooltip.\n     * @returns {boolean} true - mouse is on the tooltip\n     */\n  }, {\n    key: \"mouseOnToolTip\",\n    value: function mouseOnToolTip() {\n      var show = this.state.show;\n      if (show && this.tooltipRef) {\n        /* old IE or Firefox work around */\n        if (!this.tooltipRef.matches) {\n          /* old IE work around */\n          if (this.tooltipRef.msMatchesSelector) {\n            this.tooltipRef.matches = this.tooltipRef.msMatchesSelector;\n          } else {\n            /* old Firefox work around */\n            this.tooltipRef.matches = this.tooltipRef.mozMatchesSelector;\n          }\n        }\n        return this.tooltipRef.matches(':hover');\n      }\n      return false;\n    }\n\n    /**\n     * Pick out corresponded target elements\n     */\n  }, {\n    key: \"getTargetArray\",\n    value: function getTargetArray(id) {\n      var targetArray = [];\n      var selector;\n      if (!id) {\n        selector = '[data-tip]:not([data-for])';\n      } else {\n        var escaped = id.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\n        selector = \"[data-tip][data-for=\\\"\".concat(escaped, \"\\\"]\");\n      }\n\n      // Scan document for shadow DOM elements\n      nodeListToArray(document.getElementsByTagName('*')).filter(function (element) {\n        return element.shadowRoot;\n      }).forEach(function (element) {\n        targetArray = targetArray.concat(nodeListToArray(element.shadowRoot.querySelectorAll(selector)));\n      });\n      return targetArray.concat(nodeListToArray(document.querySelectorAll(selector)));\n    }\n\n    /**\n     * Bind listener to the target elements\n     * These listeners used to trigger showing or hiding the tooltip\n     */\n  }, {\n    key: \"bindListener\",\n    value: function bindListener() {\n      var _this3 = this;\n      var _this$props2 = this.props,\n        id = _this$props2.id,\n        globalEventOff = _this$props2.globalEventOff,\n        isCapture = _this$props2.isCapture;\n      var targetArray = this.getTargetArray(id);\n      targetArray.forEach(function (target) {\n        if (target.getAttribute('currentItem') === null) {\n          target.setAttribute('currentItem', 'false');\n        }\n        _this3.unbindBasicListener(target);\n        if (_this3.isCustomEvent(target)) {\n          _this3.customUnbindListener(target);\n        }\n      });\n      if (this.isBodyMode()) {\n        this.bindBodyListener(targetArray);\n      } else {\n        targetArray.forEach(function (target) {\n          var isCaptureMode = _this3.isCapture(target);\n          var effect = _this3.getEffect(target);\n          if (_this3.isCustomEvent(target)) {\n            _this3.customBindListener(target);\n            return;\n          }\n          target.addEventListener('mouseenter', _this3.showTooltip, isCaptureMode);\n          target.addEventListener('focus', _this3.showTooltip, isCaptureMode);\n          if (effect === 'float') {\n            target.addEventListener('mousemove', _this3.updateTooltip, isCaptureMode);\n          }\n          target.addEventListener('mouseleave', _this3.hideTooltip, isCaptureMode);\n          target.addEventListener('blur', _this3.hideTooltip, isCaptureMode);\n        });\n      }\n\n      // Global event to hide tooltip\n      if (globalEventOff) {\n        window.removeEventListener(globalEventOff, this.hideTooltip);\n        window.addEventListener(globalEventOff, this.hideTooltip, isCapture);\n      }\n\n      // Track removal of targetArray elements from DOM\n      this.bindRemovalTracker();\n    }\n\n    /**\n     * Unbind listeners on target elements\n     */\n  }, {\n    key: \"unbindListener\",\n    value: function unbindListener() {\n      var _this4 = this;\n      var _this$props3 = this.props,\n        id = _this$props3.id,\n        globalEventOff = _this$props3.globalEventOff;\n      if (this.isBodyMode()) {\n        this.unbindBodyListener();\n      } else {\n        var targetArray = this.getTargetArray(id);\n        targetArray.forEach(function (target) {\n          _this4.unbindBasicListener(target);\n          if (_this4.isCustomEvent(target)) _this4.customUnbindListener(target);\n        });\n      }\n      if (globalEventOff) window.removeEventListener(globalEventOff, this.hideTooltip);\n      this.unbindRemovalTracker();\n    }\n\n    /**\n     * Invoke this before bind listener and unmount the component\n     * it is necessary to invoke this even when binding custom event\n     * so that the tooltip can switch between custom and default listener\n     */\n  }, {\n    key: \"unbindBasicListener\",\n    value: function unbindBasicListener(target) {\n      var isCaptureMode = this.isCapture(target);\n      target.removeEventListener('mouseenter', this.showTooltip, isCaptureMode);\n      target.removeEventListener('mousemove', this.updateTooltip, isCaptureMode);\n      target.removeEventListener('mouseleave', this.hideTooltip, isCaptureMode);\n    }\n  }, {\n    key: \"getTooltipContent\",\n    value: function getTooltipContent() {\n      var _this$props4 = this.props,\n        getContent = _this$props4.getContent,\n        children = _this$props4.children;\n\n      // Generate tooltip content\n      var content;\n      if (getContent) {\n        if (Array.isArray(getContent)) {\n          content = getContent[0] && getContent[0](this.state.originTooltip);\n        } else {\n          content = getContent(this.state.originTooltip);\n        }\n      }\n      return TipContent(this.state.originTooltip, children, content, this.state.isMultiline);\n    }\n  }, {\n    key: \"isEmptyTip\",\n    value: function isEmptyTip(placeholder) {\n      return typeof placeholder === 'string' && placeholder === '' || placeholder === null;\n    }\n\n    /**\n     * When mouse enter, show the tooltip\n     */\n  }, {\n    key: \"showTooltip\",\n    value: function showTooltip(e, isGlobalCall) {\n      if (!this.tooltipRef) {\n        return;\n      }\n      if (isGlobalCall) {\n        // Don't trigger other elements belongs to other ReactTooltip\n        var targetArray = this.getTargetArray(this.props.id);\n        var isMyElement = targetArray.some(function (ele) {\n          return ele === e.currentTarget;\n        });\n        if (!isMyElement) return;\n      }\n      // Get the tooltip content\n      // calculate in this phrase so that tip width height can be detected\n      var _this$props5 = this.props,\n        multiline = _this$props5.multiline,\n        getContent = _this$props5.getContent;\n      var originTooltip = e.currentTarget.getAttribute('data-tip');\n      var isMultiline = e.currentTarget.getAttribute('data-multiline') || multiline || false;\n\n      // If it is focus event or called by ReactTooltip.show, switch to `solid` effect\n      var switchToSolid = e instanceof window.FocusEvent || isGlobalCall;\n\n      // if it needs to skip adding hide listener to scroll\n      var scrollHide = true;\n      if (e.currentTarget.getAttribute('data-scroll-hide')) {\n        scrollHide = e.currentTarget.getAttribute('data-scroll-hide') === 'true';\n      } else if (this.props.scrollHide != null) {\n        scrollHide = this.props.scrollHide;\n      }\n\n      // adding aria-describedby to target to make tooltips read by screen readers\n      if (e && e.currentTarget && e.currentTarget.setAttribute) {\n        e.currentTarget.setAttribute('aria-describedby', this.props.id || this.state.uuid);\n      }\n\n      // Make sure the correct place is set\n      var desiredPlace = e.currentTarget.getAttribute('data-place') || this.props.place || 'top';\n      var effect = switchToSolid && 'solid' || this.getEffect(e.currentTarget);\n      var offset = e.currentTarget.getAttribute('data-offset') || this.props.offset || {};\n      var result = index_es_getPosition(e, e.currentTarget, this.tooltipRef, desiredPlace.split(',')[0], desiredPlace, effect, offset);\n      if (result.position && this.props.overridePosition) {\n        result.position = this.props.overridePosition(result.position, e, e.currentTarget, this.tooltipRef, desiredPlace, desiredPlace, effect, offset);\n      }\n      var place = result.isNewState ? result.newState.place : desiredPlace.split(',')[0];\n\n      // To prevent previously created timers from triggering\n      this.clearTimer();\n      var target = e.currentTarget;\n      var reshowDelay = this.state.show ? target.getAttribute('data-delay-update') || this.props.delayUpdate : 0;\n      var self = this;\n      var updateState = function updateState() {\n        self.setState({\n          originTooltip: originTooltip,\n          isMultiline: isMultiline,\n          desiredPlace: desiredPlace,\n          place: place,\n          type: target.getAttribute('data-type') || self.props.type || 'dark',\n          customColors: {\n            text: target.getAttribute('data-text-color') || self.props.textColor || null,\n            background: target.getAttribute('data-background-color') || self.props.backgroundColor || null,\n            border: target.getAttribute('data-border-color') || self.props.borderColor || null,\n            arrow: target.getAttribute('data-arrow-color') || self.props.arrowColor || null\n          },\n          customRadius: {\n            tooltip: target.getAttribute('data-tooltip-radius') || self.props.tooltipRadius || '3',\n            arrow: target.getAttribute('data-arrow-radius') || self.props.arrowRadius || '0'\n          },\n          effect: effect,\n          offset: offset,\n          padding: target.getAttribute('data-padding') || self.props.padding,\n          html: (target.getAttribute('data-html') ? target.getAttribute('data-html') === 'true' : self.props.html) || false,\n          delayShow: target.getAttribute('data-delay-show') || self.props.delayShow || 0,\n          delayHide: target.getAttribute('data-delay-hide') || self.props.delayHide || 0,\n          delayUpdate: target.getAttribute('data-delay-update') || self.props.delayUpdate || 0,\n          border: (target.getAttribute('data-border') ? target.getAttribute('data-border') === 'true' : self.props.border) || false,\n          borderClass: target.getAttribute('data-border-class') || self.props.borderClass || 'border',\n          extraClass: target.getAttribute('data-class') || self.props[\"class\"] || self.props.className || '',\n          disable: (target.getAttribute('data-tip-disable') ? target.getAttribute('data-tip-disable') === 'true' : self.props.disable) || false,\n          currentTarget: target\n        }, function () {\n          if (scrollHide) {\n            self.addScrollListener(self.state.currentTarget);\n          }\n          self.updateTooltip(e);\n          if (getContent && Array.isArray(getContent)) {\n            self.intervalUpdateContent = setInterval(function () {\n              if (self.mount) {\n                var _getContent = self.props.getContent;\n                var placeholder = TipContent(originTooltip, '', _getContent[0](), isMultiline);\n                var isEmptyTip = self.isEmptyTip(placeholder);\n                self.setState({\n                  isEmptyTip: isEmptyTip\n                });\n                self.updatePosition();\n              }\n            }, getContent[1]);\n          }\n        });\n      };\n\n      // If there is no delay call immediately, don't allow events to get in first.\n      if (reshowDelay) {\n        this.delayReshow = setTimeout(updateState, reshowDelay);\n      } else {\n        updateState();\n      }\n    }\n\n    /**\n     * When mouse hover, update tool tip\n     */\n  }, {\n    key: \"updateTooltip\",\n    value: function updateTooltip(e) {\n      var _this5 = this;\n      var _this$state = this.state,\n        delayShow = _this$state.delayShow,\n        disable = _this$state.disable;\n      var _this$props6 = this.props,\n        afterShow = _this$props6.afterShow,\n        disableProp = _this$props6.disable;\n      var placeholder = this.getTooltipContent();\n      var eventTarget = e.currentTarget || e.target;\n\n      // Check if the mouse is actually over the tooltip, if so don't hide the tooltip\n      if (this.mouseOnToolTip()) {\n        return;\n      }\n\n      // if the tooltip is empty, disable the tooltip\n      if (this.isEmptyTip(placeholder) || disable || disableProp) {\n        return;\n      }\n      var delayTime = !this.state.show ? parseInt(delayShow, 10) : 0;\n      var updateState = function updateState() {\n        if (Array.isArray(placeholder) && placeholder.length > 0 || placeholder) {\n          var isInvisible = !_this5.state.show;\n          _this5.setState({\n            currentEvent: e,\n            currentTarget: eventTarget,\n            show: true\n          }, function () {\n            _this5.updatePosition(function () {\n              if (isInvisible && afterShow) {\n                afterShow(e);\n              }\n            });\n          });\n        }\n      };\n      if (this.delayShowLoop) {\n        clearTimeout(this.delayShowLoop);\n      }\n      if (delayTime) {\n        this.delayShowLoop = setTimeout(updateState, delayTime);\n      } else {\n        this.delayShowLoop = null;\n        updateState();\n      }\n    }\n\n    /*\n     * If we're mousing over the tooltip remove it when we leave.\n     */\n  }, {\n    key: \"listenForTooltipExit\",\n    value: function listenForTooltipExit() {\n      var show = this.state.show;\n      if (show && this.tooltipRef) {\n        this.tooltipRef.addEventListener('mouseleave', this.hideTooltip);\n      }\n    }\n  }, {\n    key: \"removeListenerForTooltipExit\",\n    value: function removeListenerForTooltipExit() {\n      var show = this.state.show;\n      if (show && this.tooltipRef) {\n        this.tooltipRef.removeEventListener('mouseleave', this.hideTooltip);\n      }\n    }\n\n    /**\n     * When mouse leave, hide tooltip\n     */\n  }, {\n    key: \"hideTooltip\",\n    value: function hideTooltip(e, hasTarget) {\n      var _this6 = this;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n        isScroll: false\n      };\n      var disable = this.state.disable;\n      var isScroll = options.isScroll;\n      var delayHide = isScroll ? 0 : this.state.delayHide;\n      var _this$props7 = this.props,\n        afterHide = _this$props7.afterHide,\n        disableProp = _this$props7.disable;\n      var placeholder = this.getTooltipContent();\n      if (!this.mount) return;\n      if (this.isEmptyTip(placeholder) || disable || disableProp) return; // if the tooltip is empty, disable the tooltip\n      if (hasTarget) {\n        // Don't trigger other elements belongs to other ReactTooltip\n        var targetArray = this.getTargetArray(this.props.id);\n        var isMyElement = targetArray.some(function (ele) {\n          return ele === e.currentTarget;\n        });\n        if (!isMyElement || !this.state.show) return;\n      }\n\n      // clean up aria-describedby when hiding tooltip\n      if (e && e.currentTarget && e.currentTarget.removeAttribute) {\n        e.currentTarget.removeAttribute('aria-describedby');\n      }\n      var resetState = function resetState() {\n        var isVisible = _this6.state.show;\n        // Check if the mouse is actually over the tooltip, if so don't hide the tooltip\n        if (_this6.mouseOnToolTip()) {\n          _this6.listenForTooltipExit();\n          return;\n        }\n        _this6.removeListenerForTooltipExit();\n        _this6.setState({\n          show: false\n        }, function () {\n          _this6.removeScrollListener(_this6.state.currentTarget);\n          if (isVisible && afterHide) {\n            afterHide(e);\n          }\n        });\n      };\n      this.clearTimer();\n      if (delayHide) {\n        this.delayHideLoop = setTimeout(resetState, parseInt(delayHide, 10));\n      } else {\n        resetState();\n      }\n    }\n\n    /**\n     * When scroll, hide tooltip\n     */\n  }, {\n    key: \"hideTooltipOnScroll\",\n    value: function hideTooltipOnScroll(event, hasTarget) {\n      this.hideTooltip(event, hasTarget, {\n        isScroll: true\n      });\n    }\n\n    /**\n     * Add scroll event listener when tooltip show\n     * automatically hide the tooltip when scrolling\n     */\n  }, {\n    key: \"addScrollListener\",\n    value: function addScrollListener(currentTarget) {\n      var isCaptureMode = this.isCapture(currentTarget);\n      window.addEventListener('scroll', this.hideTooltipOnScroll, isCaptureMode);\n    }\n  }, {\n    key: \"removeScrollListener\",\n    value: function removeScrollListener(currentTarget) {\n      var isCaptureMode = this.isCapture(currentTarget);\n      window.removeEventListener('scroll', this.hideTooltipOnScroll, isCaptureMode);\n    }\n\n    // Calculation the position\n  }, {\n    key: \"updatePosition\",\n    value: function updatePosition(callbackAfter) {\n      var _this7 = this;\n      var _this$state2 = this.state,\n        currentEvent = _this$state2.currentEvent,\n        currentTarget = _this$state2.currentTarget,\n        place = _this$state2.place,\n        desiredPlace = _this$state2.desiredPlace,\n        effect = _this$state2.effect,\n        offset = _this$state2.offset;\n      var node = this.tooltipRef;\n      var result = index_es_getPosition(currentEvent, currentTarget, node, place, desiredPlace, effect, offset);\n      if (result.position && this.props.overridePosition) {\n        result.position = this.props.overridePosition(result.position, currentEvent, currentTarget, node, place, desiredPlace, effect, offset);\n      }\n      if (result.isNewState) {\n        // Switch to reverse placement\n        return this.setState(result.newState, function () {\n          _this7.updatePosition(callbackAfter);\n        });\n      }\n      if (callbackAfter && typeof callbackAfter === 'function') {\n        callbackAfter();\n      }\n\n      // Set tooltip position\n      node.style.left = result.position.left + 'px';\n      node.style.top = result.position.top + 'px';\n    }\n\n    /**\n     * CLear all kinds of timeout of interval\n     */\n  }, {\n    key: \"clearTimer\",\n    value: function clearTimer() {\n      if (this.delayShowLoop) {\n        clearTimeout(this.delayShowLoop);\n        this.delayShowLoop = null;\n      }\n      if (this.delayHideLoop) {\n        clearTimeout(this.delayHideLoop);\n        this.delayHideLoop = null;\n      }\n      if (this.delayReshow) {\n        clearTimeout(this.delayReshow);\n        this.delayReshow = null;\n      }\n      if (this.intervalUpdateContent) {\n        clearInterval(this.intervalUpdateContent);\n        this.intervalUpdateContent = null;\n      }\n    }\n  }, {\n    key: \"hasCustomColors\",\n    value: function hasCustomColors() {\n      var _this8 = this;\n      return Boolean(Object.keys(this.state.customColors).find(function (color) {\n        return color !== 'border' && _this8.state.customColors[color];\n      }) || this.state.border && this.state.customColors['border']);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this9 = this;\n      var _this$state3 = this.state,\n        extraClass = _this$state3.extraClass,\n        html = _this$state3.html,\n        ariaProps = _this$state3.ariaProps,\n        disable = _this$state3.disable,\n        uuid = _this$state3.uuid;\n      var content = this.getTooltipContent();\n      var isEmptyTip = this.isEmptyTip(content);\n      var style = this.props.disableInternalStyle ? '' : generateTooltipStyle(this.state.uuid, this.state.customColors, this.state.type, this.state.border, this.state.padding, this.state.customRadius);\n      var tooltipClass = '__react_component_tooltip' + \" \".concat(this.state.uuid) + (this.state.show && !disable && !isEmptyTip ? ' show' : '') + (this.state.border ? ' ' + this.state.borderClass : '') + \" place-\".concat(this.state.place) +\n      // top, bottom, left, right\n      \" type-\".concat(this.hasCustomColors() ? 'custom' : this.state.type) + (\n      // dark, success, warning, error, info, light, custom\n      this.props.delayUpdate ? ' allow_hover' : '') + (this.props.clickable ? ' allow_click' : '');\n      var Wrapper = this.props.wrapper;\n      if (ReactTooltip.supportedWrappers.indexOf(Wrapper) < 0) {\n        Wrapper = ReactTooltip.defaultProps.wrapper;\n      }\n      var wrapperClassName = [tooltipClass, extraClass].filter(Boolean).join(' ');\n      if (html) {\n        var htmlContent = \"\".concat(content).concat(style ? \"\\n<style aria-hidden=\\\"true\\\">\".concat(style, \"</style>\") : '');\n        return /*#__PURE__*/react.createElement(Wrapper, index_es_extends({\n          className: \"\".concat(wrapperClassName),\n          id: this.props.id || uuid,\n          ref: function ref(_ref) {\n            return _this9.tooltipRef = _ref;\n          }\n        }, ariaProps, {\n          \"data-id\": \"tooltip\",\n          dangerouslySetInnerHTML: {\n            __html: htmlContent\n          }\n        }));\n      } else {\n        return /*#__PURE__*/react.createElement(Wrapper, index_es_extends({\n          className: \"\".concat(wrapperClassName),\n          id: this.props.id || uuid\n        }, ariaProps, {\n          ref: function ref(_ref2) {\n            return _this9.tooltipRef = _ref2;\n          },\n          \"data-id\": \"tooltip\"\n        }), style && /*#__PURE__*/react.createElement(\"style\", {\n          dangerouslySetInnerHTML: {\n            __html: style\n          },\n          \"aria-hidden\": \"true\"\n        }), content);\n      }\n    }\n  }], [{\n    key: \"propTypes\",\n    get: function get() {\n      return {\n        uuid: (prop_types_default()).string,\n        children: (prop_types_default()).any,\n        place: (prop_types_default()).string,\n        type: (prop_types_default()).string,\n        effect: (prop_types_default()).string,\n        offset: (prop_types_default()).object,\n        padding: (prop_types_default()).string,\n        multiline: (prop_types_default()).bool,\n        border: (prop_types_default()).bool,\n        borderClass: (prop_types_default()).string,\n        textColor: (prop_types_default()).string,\n        backgroundColor: (prop_types_default()).string,\n        borderColor: (prop_types_default()).string,\n        arrowColor: (prop_types_default()).string,\n        arrowRadius: (prop_types_default()).string,\n        tooltipRadius: (prop_types_default()).string,\n        insecure: (prop_types_default()).bool,\n        \"class\": (prop_types_default()).string,\n        className: (prop_types_default()).string,\n        id: (prop_types_default()).string,\n        html: (prop_types_default()).bool,\n        delayHide: (prop_types_default()).number,\n        delayUpdate: (prop_types_default()).number,\n        delayShow: (prop_types_default()).number,\n        event: (prop_types_default()).string,\n        eventOff: (prop_types_default()).string,\n        isCapture: (prop_types_default()).bool,\n        globalEventOff: (prop_types_default()).string,\n        getContent: (prop_types_default()).any,\n        afterShow: (prop_types_default()).func,\n        afterHide: (prop_types_default()).func,\n        overridePosition: (prop_types_default()).func,\n        disable: (prop_types_default()).bool,\n        scrollHide: (prop_types_default()).bool,\n        resizeHide: (prop_types_default()).bool,\n        wrapper: (prop_types_default()).string,\n        bodyMode: (prop_types_default()).bool,\n        possibleCustomEvents: (prop_types_default()).string,\n        possibleCustomEventsOff: (prop_types_default()).string,\n        clickable: (prop_types_default()).bool,\n        disableInternalStyle: (prop_types_default()).bool\n      };\n    }\n  }, {\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var ariaProps = prevState.ariaProps;\n      var newAriaProps = parseAria(nextProps);\n      var isChanged = Object.keys(newAriaProps).some(function (props) {\n        return newAriaProps[props] !== ariaProps[props];\n      });\n      if (!isChanged) {\n        return null;\n      }\n      return _objectSpread2(_objectSpread2({}, prevState), {}, {\n        ariaProps: newAriaProps\n      });\n    }\n  }]);\n  return ReactTooltip;\n}(react.Component), index_es_defineProperty(_class2, \"defaultProps\", {\n  insecure: true,\n  resizeHide: true,\n  wrapper: 'div',\n  clickable: false\n}), index_es_defineProperty(_class2, \"supportedWrappers\", ['div', 'span']), index_es_defineProperty(_class2, \"displayName\", 'ReactTooltip'), _class2)) || _class) || _class) || _class) || _class) || _class) || _class) || _class;\n\n;// ./src/components/Indicator/Indicator.module.scss\n// extracted by mini-css-extract-plugin\nvar disIndicatorValue = \"Indicator-module--disIndicatorValue--DX0Ig\";\nvar indicatorBoxMain = \"Indicator-module--indicatorBoxMain--6T5Xt\";\nvar indicatorDesc = \"Indicator-module--indicatorDesc---ECTQ\";\nvar indicatorInfo = \"Indicator-module--indicatorInfo--p6lCu\";\nvar indicatorName = \"Indicator-module--indicatorName--lr3HM\";\nvar indicatorRow = \"Indicator-module--indicatorRow--dEaNg\";\nvar indicatorValue = \"Indicator-module--indicatorValue--PcUu3\";\nvar indicatorValueCol = \"Indicator-module--indicatorValueCol--cic1C\";\nvar indicatorValueRow = \"Indicator-module--indicatorValueRow--IchE8\";\nvar indicatorValueSubText = \"Indicator-module--indicatorValueSubText--w92wv\";\nvar info = \"Indicator-module--info--5wdv5\";\nvar infoTilde = \"Indicator-module--infoTilde--JSJWE\";\n// EXTERNAL MODULE: ./src/data/constants.tsx\nvar constants = __webpack_require__(4328);\n;// ./node_modules/uswds/dist/img/usa-icons/info.svg\n/* harmony default export */ var usa_icons_info = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTEyIDJDNi40OCAyIDIgNi40OCAyIDEyczQuNDggMTAgMTAgMTAgMTAtNC40OCAxMC0xMFMxNy41MiAyIDEyIDJ6bTEgMTVoLTJ2LTZoMnY2em0wLThoLTJWN2gydjJ6Ii8+PC9zdmc+\");\n;// ./src/components/Indicator/Indicator.tsx\n// @ts-ignore\n/**\n * This component will render an info icon in the indicator value\n *\n * @return {JSX.Element}\n */const IndicatorInfoIcon=_ref=>{let{isImpute,population}=_ref;const intl=(0,gatsby_plugin_intl.useIntl)();let showTilde=false;const getToolTipCopy=()=>{if(population===constants/* MISSING_DATA_STRING */.WiZ){return intl.formatMessage(explore/* LOW_INCOME_TOOLTIP */.L9.IMP_YES_POP_NULL);}else if(population!==constants/* MISSING_DATA_STRING */.WiZ&&isImpute){showTilde=true;return intl.formatMessage(explore/* LOW_INCOME_TOOLTIP */.L9.IMP_YES_POP_NOT_NULL);}else{return null;}};/**\n   * This library react-tooltip creates random DOM ID which will not allow for snapshot testing as\n   * the IDs change on each build. Due to time constraints, we simply removed the AreaDetails test.\n   * The AreaDetails component is made up of sub component and each sub component has tests so this\n   * is low risk.\n   *\n   * This is a temporary solution. Some longer terms solutions may be\n   * 1. Remove this library and get the USWDS tool tip to work\n   * 2. Re-factor the areaDetail.tests.tsx snapshot tests to do more DOM assertions rather than snapshots\n   * 3. Some combination of the two.\n   */return/*#__PURE__*/react.createElement(react.Fragment,null,/*#__PURE__*/react.createElement(ReactTooltip,{id:\"lowIncomeIcon\",multiline:true}),/*#__PURE__*/react.createElement(\"img\",{\"data-for\":\"lowIncomeIcon\",\"data-tip\":getToolTipCopy(),\"data-iscapture\":\"true\",className:info,src:usa_icons_info,alt:intl.formatMessage(explore/* SIDE_PANEL_VALUES */.M4.IMG_ALT_TEXT.INFO)}),showTilde&&/*#__PURE__*/react.createElement(\"span\",{className:infoTilde},` ~ `));};/**\n * This component will determine the sub-text of the indicator's value, some examples could be\n *   \"above 90th percentile\"\n *   \"below 20 percent\"\n *   \"data is not available\"\n *\n * @param {IIndicatorValueSubText} {}\n * @return {JSX.Element}\n */const IndicatorValueSubText=_ref2=>{let{type,value,isAboveThresh,threshold}=_ref2;if(value===null){return/*#__PURE__*/react.createElement(\"div\",null,explore/* SIDE_PANEL_VALUES */.M4.UNAVAILBLE_MSG);}else if(type==='percent'||type==='percentile'){return/*#__PURE__*/react.createElement(\"div\",null,isAboveThresh?explore/* SIDE_PANEL_VALUES */.M4.ABOVE:explore/* SIDE_PANEL_VALUES */.M4.BELOW,threshold?/*#__PURE__*/react.createElement(IndicatorValue,{type:type,displayStat:threshold}):/*#__PURE__*/react.createElement(IndicatorValue,{type:type,displayStat:90}),` `,type==='percent'?explore/* SIDE_PANEL_VALUES */.M4.PERCENT:explore/* SIDE_PANEL_VALUES */.M4.PERCENTILE);}else{return/*#__PURE__*/react.createElement(react.Fragment,null);}};/**\n * The react-i18n library allow to add ordinal suffix (st, nd, rd, th) to indicator values.\n * The number and the suffix is a single entity. We are looking to add styling to\n * just the suffix portion if the value is a percentile. This function will add\n * a superscript styling to just the suffix portion of percentile values.\n *\n * The i18n variable named i18nOrdinalSuffix, in the IndicatorValue function defines the\n * various prefixes. The Spanish version of the i18n variable works in a similar manner,\n * however has a difference. The superscripting is different for Spanish.\n * In Spanish, the suffix is a \".a\" and \".o\", where only the \"a\" and \"o\" are superscripted.\n * This function handles this case.\n *\n * Verbatim from translation team:\n * We suggest changing this to the Spanish ordinal number abbreviation, which is .o for masculine\n * and .a for feminine gendered words. ***Since this ranking applies to the communities of focus,\n * which use a feminine gender in Spanish, we recommend that the th ordinal abbreviation in English\n * be substituted with the feminine ordinal abbreviation in Spanish: .a  throughout the text.\n * E.g., 19th would be 19.a in Spanish and 65th would be 65.a\n *\n * @param {string} indicatorValueWithSuffix\n * @return {string}\n */const superscriptOrdinal=indicatorValueWithSuffix=>{// Spanish case:\nif(indicatorValueWithSuffix.indexOf('.')!==-1){const ordinalSuffix=indicatorValueWithSuffix.charAt(indicatorValueWithSuffix.length-1);const indicatorValue=indicatorValueWithSuffix.slice(0,-1);return/*#__PURE__*/react.createElement(react.Fragment,null,indicatorValue,/*#__PURE__*/react.createElement(\"sup\",{style:{top:'-0.2em'}},ordinalSuffix));}// English case:\nconst valueRegEx=/[0-9]{1,2}/;const suffixRegEx=/[a-z]{2}/;// ie, (st, nd, rd, th)\nconst indicatorValue=valueRegEx.exec(indicatorValueWithSuffix);const ordinalSuffix=suffixRegEx.exec(indicatorValueWithSuffix);return/*#__PURE__*/react.createElement(react.Fragment,null,indicatorValue,/*#__PURE__*/react.createElement(\"sup\",{style:{top:'-0.2em'}},ordinalSuffix));};/**\n * This component will return the indicators's value. The value depends on the\n * indicator type. Each type renders a different UI.\n *\n * @return {JSX.Element | null}\n */const IndicatorValue=_ref3=>{let{type,displayStat}=_ref3;const intl=(0,gatsby_plugin_intl.useIntl)();if(displayStat===null)return/*#__PURE__*/react.createElement(react.Fragment,null,constants/* MISSING_DATA_STRING */.WiZ);if(type==='percent'||type==='percentile'){// In this case we will show no value and an icon only\nif(type==='percent'){// If the type is percent, return the intl percent format\nreturn/*#__PURE__*/react.createElement(\"span\",null,intl.formatNumber(displayStat,{style:'unit',unit:'percent',unitDisplay:'short'}));}else{// If the type is percentile, create the intl ordinal and return it as a superscript\nconst i18nOrdinalSuffix=intl.formatMessage({id:'explore.map.page.side.panel.indicator.percentile.value.ordinal.suffix',// eslint-disable-next-line max-len\ndescription:`Navigate to the explore the tool page. Click on the map. The side panel will show categories. Open a category. This will define the indicator value's ordinal suffix. For example the st in 91st, the rd in 23rd, and the th in 26th, etc.`,defaultMessage:`\n        {indicatorValue, selectordinal, \n          one {#st} \n          two {#nd}\n          few {#rd} \n          other {#th}\n        }\n        `},{indicatorValue:displayStat});return superscriptOrdinal(i18nOrdinalSuffix);}}else{// when the type === boolean the display stat will be either 100 (true) or 0 (false)\nreturn displayStat===0?explore/* SIDE_PANEL_SPACERS */.zZ.NO:explore/* SIDE_PANEL_SPACERS */.zZ.YES;}};/**\n * This component will return the list element which will be the indicator row in the side panel\n *\n * @param {IIndicator} indicator\n * @return {JSX.Element}\n */const Indicator=_ref4=>{let{indicator,isImpute,population}=_ref4;/**\n   * The indicator value could be a number | boolean | null. In all cases we coerce to number\n   * before flooring.\n   *\n   * In the case where indicator.value is a boolean, the displayStat will be either 100 or 0, depending\n   * on if indicator.value is true or false respectively.\n   *\n   * Todo: The way the displayStat handles the boolean indicators should be refactored\n   */const displayStat=indicator.value!==null?Math.floor(Number(indicator.value)*100):null;// If the threshold exists, set it, otherwise set it to the default value\nconst threshold=indicator.threshold?indicator.threshold:constants/* DEFAULT_THRESHOLD_PERCENTILE */.QPF;// A boolean to represent if the indicator is above or below the threshold\nconst isAboveThresh=displayStat!==null&&displayStat>=threshold?true:false;// Show an info icon on the low icome indicator if:\nconst showLowIncomeInfoIcon=indicator.label==='Low income'&&isImpute||indicator.label==='Low income'&&population===constants/* MISSING_DATA_STRING */.WiZ&&!isImpute;return/*#__PURE__*/react.createElement(\"li\",{className:indicatorBoxMain,\"data-cy\":'indicatorBox',\"data-testid\":\"indicator-box\"},/*#__PURE__*/react.createElement(\"div\",{className:indicatorRow},/*#__PURE__*/react.createElement(\"div\",{className:indicatorName},indicator.label,/*#__PURE__*/react.createElement(\"div\",{className:indicatorDesc},indicator.description)),/*#__PURE__*/react.createElement(\"div\",{className:indicatorValueCol},/*#__PURE__*/react.createElement(\"div\",{className:indicatorValueRow},showLowIncomeInfoIcon&&/*#__PURE__*/react.createElement(\"div\",{className:indicatorInfo},/*#__PURE__*/react.createElement(IndicatorInfoIcon,{isImpute:isImpute,population:population})),/*#__PURE__*/react.createElement(\"div\",{className:indicator.isDisadvagtaged?disIndicatorValue:indicatorValue},/*#__PURE__*/react.createElement(IndicatorValue,{type:indicator.type,displayStat:displayStat}))),/*#__PURE__*/react.createElement(\"div\",{className:indicatorValueSubText},/*#__PURE__*/react.createElement(IndicatorValueSubText,{value:displayStat,isAboveThresh:isAboveThresh,threshold:threshold,type:indicator.type})))));};/* harmony default export */ var Indicator_Indicator = (Indicator);\n;// ./src/components/DonutCopy/DonutCopy.module.scss\n// extracted by mini-css-extract-plugin\nvar donutCopyContainer = \"DonutCopy-module--donutCopyContainer--rZc2n\";\nvar donutRow = \"DonutCopy-module--donutRow--uMGO+\";\nvar donutRowLabel = \"DonutCopy-module--donutRowLabel--H2Zix\";\nvar DonutCopy_module_invert = \"DonutCopy-module--invert--ItmCg\";\nvar noInvert = \"DonutCopy-module--noInvert--WfEDN\";\nvar subTextContainer = \"DonutCopy-module--subTextContainer--rOEhm\";\nvar valueSubTextContainer = \"DonutCopy-module--valueSubTextContainer---ntK0\";\n;// ./src/components/DonutCopy/DonutCopy.tsx\nconst DonutCopy=_ref=>{let{isAdjacent,povertyBelow200Percentile}=_ref;const intl=(0,gatsby_plugin_intl.useIntl)();const povBel200Percentile=povertyBelow200Percentile?parseFloat((povertyBelow200Percentile*100).toFixed()):null;const threshold=50;return/*#__PURE__*/react.createElement(\"div\",{className:donutCopyContainer},/*#__PURE__*/react.createElement(\"div\",{className:donutRow},/*#__PURE__*/react.createElement(\"div\",{className:donutRowLabel},intl.formatMessage(explore/* DONUT_COPY */.zf.COMP_SURR)),/*#__PURE__*/react.createElement(\"div\",{className:isAdjacent?DonutCopy_module_invert:''},isAdjacent?explore/* COMMUNITY */.GN.OF_FOCUS:explore/* COMMUNITY */.GN.NOT_OF_FOCUS)),/*#__PURE__*/react.createElement(\"div\",{className:donutRow},/*#__PURE__*/react.createElement(\"div\",{className:donutRowLabel},intl.formatMessage(explore/* DONUT_COPY */.zf.ADJ_LOW_INC)),/*#__PURE__*/react.createElement(\"div\",{className:valueSubTextContainer},/*#__PURE__*/react.createElement(\"div\",{className:isAdjacent&&povBel200Percentile&&povBel200Percentile>=threshold?DonutCopy_module_invert:noInvert},/*#__PURE__*/react.createElement(IndicatorValue,{type:'percentile',displayStat:povBel200Percentile})),/*#__PURE__*/react.createElement(\"div\",{className:subTextContainer},/*#__PURE__*/react.createElement(IndicatorValueSubText,{value:povBel200Percentile,isAboveThresh:povBel200Percentile&&povBel200Percentile>=threshold?true:false,threshold:threshold,type:'percentile'})))));};/* harmony default export */ var DonutCopy_DonutCopy = (DonutCopy);\n;// ./src/components/DonutCopy/index.ts\n/* harmony default export */ var components_DonutCopy = (DonutCopy_DonutCopy);\n;// ./src/components/Indicator/index.tsx\n/* harmony default export */ var components_Indicator = (Indicator_Indicator);\n;// ./src/components/PrioritizationCopy/PrioritizationCopy.tsx\n;/**\n * This component returns the prioritzation copy.\n *\n * The truth table that tracks all the states for this logic is captured in the shared doc\n * called \"Indicators for UI and BE Signals\". The Sheet is called \"Disadv Copy v4 p1\". This\n * spreadsheet is a giant truth table with all possible BE signal combinations and what the\n * approppriate copy should be.\n *\n * @param {number} totalCategoriesPrioritized\n * @param {number} totalBurdensPrioritized\n * @param {boolean} isAdjacencyThreshMet\n * @param {boolean} isAdjacencyLowIncome\n * @param {boolean} isIslandLowIncome\n * @param {number | null} tribalCountAK\n * @param {number | null} tribalCountUS\n * @param {number | null} percentTractTribal\n * @return {JSX}\n */const PrioritizationCopy=_ref=>{let{totalCategoriesPrioritized,totalBurdensPrioritized,isAdjacencyThreshMet,isAdjacencyLowIncome,isGrandfathered,isIslandLowIncome,tribalCountAK,tribalCountUS,percentTractTribal}=_ref;let prioCopyRendered=null;if(isGrandfathered){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.PRIO_GRANDFATHERED_LI;// if 1\n}else if(totalCategoriesPrioritized===0){// if 1-1\nif(isAdjacencyThreshMet&&isAdjacencyLowIncome){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.PRIO_SURR_LI;// if 1-2\n}else if(isIslandLowIncome){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.PRIO_ISLAND_LI;// if 1-3\n}else if(isAdjacencyThreshMet&&!isAdjacencyLowIncome){// if 1-2-1\nif(tribalCountAK===null&&tribalCountUS===null){// if 1-2-1-1\nif(percentTractTribal===null){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.NOT_PRIO_SURR_LI;// if 1-2-1-2\n}else if(percentTractTribal===0){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.PAR_PRIO_SURR_NO_LI;// if 1-2-1-3\n}else if(percentTractTribal>=1){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.PAR_PRIO_SURR_NO_LI;}// if 1-2-2\n}else if(tribalCountAK!==null&&tribalCountAK>=1){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.PAR_PRIO_SURR_NO_LI;}// if 1-3\n}else if(!(isAdjacencyThreshMet&&isAdjacencyLowIncome)&&tribalCountAK===null&&tribalCountUS===null&&percentTractTribal===null){// if 1-3-1\nif(totalBurdensPrioritized===0){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.NOT_PRIO;// if 1-3-2\n}else if(totalBurdensPrioritized===1){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.NOT_PRIO_1BUR;// if 1-3-3\n}else if(totalBurdensPrioritized>1){prioCopyRendered=explore/* PRIORITIZATION_COPY */.Q8.NOT_PRIO_NBUR;}// if 1-4\n}else if(!(isAdjacencyThreshMet&&isAdjacencyLowIncome)){// if 1-4-1\nif(tribalCountAK!==null&&tribalCountAK>=1&&tribalCountUS!==null&&tribalCountUS>=1){prioCopyRendered=explore/* getPrioAKUSCopy */.uG(tribalCountAK,tribalCountUS);// if 1-4-2\n}else if(tribalCountAK!==null&&tribalCountAK>=1&&tribalCountUS===null){prioCopyRendered=explore/* getPrioANVCopy */.vr(tribalCountAK);// if 1-4-3\n}else if(tribalCountUS!==null&&tribalCountUS>=1&&tribalCountAK===null){if(percentTractTribal===null){prioCopyRendered=explore/* getPrioFRTPointsCopy */.VO(`${tribalCountUS}`);}else if(percentTractTribal===0){prioCopyRendered=explore/* getPrioFRTCopy */.EW(`less than 1%`);}else if(percentTractTribal>=1){prioCopyRendered=explore/* getPrioFRTCopy */.EW(`${percentTractTribal}%`);}// 1-4-4\n}else if(tribalCountUS===null&&tribalCountAK===null){if(percentTractTribal===0){prioCopyRendered=explore/* getPrioFRTCopy */.EW(`less than 1%`);}else if(percentTractTribal!==null&&percentTractTribal>=1){prioCopyRendered=explore/* getPrioFRTCopy */.EW(`${percentTractTribal}%`);}}}// if 2\n}else if(totalCategoriesPrioritized>0){if(totalBurdensPrioritized===0){}else if(totalBurdensPrioritized===1){prioCopyRendered=explore/* getPrioNBurdenCopy */.M9(`1`);}else if(totalBurdensPrioritized>1){prioCopyRendered=explore/* getPrioNBurdenCopy */.M9(`more than 1`);}};return prioCopyRendered&&/*#__PURE__*/react.createElement(\"p\",null,prioCopyRendered);};/* harmony default export */ var PrioritizationCopy_PrioritizationCopy = (PrioritizationCopy);\n;// ./src/components/PrioritizationCopy/index.ts\n/* harmony default export */ var components_PrioritizationCopy = (PrioritizationCopy_PrioritizationCopy);\n;// ./src/components/PrioritizationCopy2/PrioritizationCopy2.tsx\n;/**\n * This component returns the prioritzation copy.\n *\n * The truth table for this logic is captured in the shared doc called \"Indicators for\n * UI and BE Signals\". The Sheet name is \"Disadv Copy p2 v5\". This sheet is a copy of the\n * the full table in Sheet \"Disadv Copy v4 p1\", which is the full truth table in logical order.\n * The p2 v4 sheet copies the full truth table and sorts by the column 'second paragraph' to\n * find the appropriate logical grouping for the second paragraph.\n *\n * @param {number} totalCategoriesPrioritized\n * @param {number} totalBurdensPrioritized\n * @param {boolean} isAdjacencyThreshMet\n * @param {boolean} isAdjacencyLowIncome\n * @param {number | null} tribalCountAK\n * @param {number | null} tribalCountUS\n * @param {number | null} percentTractTribal\n * @return {JSX}\n */const PrioritizationCopy2=_ref=>{let{totalCategoriesPrioritized,isAdjacencyThreshMet,isAdjacencyLowIncome,tribalCountAK,tribalCountUS,percentTractTribal}=_ref;let prioCopy2Rendered=null;// if 1\nif(totalCategoriesPrioritized===0&&isAdjacencyThreshMet&&isAdjacencyLowIncome||totalCategoriesPrioritized>=1){// if 1-1\nif(tribalCountAK===null&&tribalCountUS!==null&&tribalCountUS>=1&&percentTractTribal!==null&&percentTractTribal>=1){prioCopy2Rendered=explore/* getPrioPercAndNumPointsAlsoCopy */.Rh(`${percentTractTribal}%`,tribalCountUS);// if 1-2\n}else if(tribalCountAK===null&&tribalCountUS===null&&percentTractTribal!==null&&percentTractTribal>=1){prioCopy2Rendered=explore/* getPrioFRTCopy */.EW(`${percentTractTribal}%`,true);// if 1-3\n}else if(tribalCountAK===null&&tribalCountUS!==null&&tribalCountUS>=1&&percentTractTribal!==null&&percentTractTribal==0){prioCopy2Rendered=explore/* getPrioPercAndNumPointsAlsoCopy */.Rh(`less than 1%`,tribalCountUS);// if 1-4\n}else if(tribalCountAK===null&&tribalCountUS===null&&percentTractTribal!==null&&percentTractTribal==0){prioCopy2Rendered=explore/* getPrioFRTCopy */.EW(`less than 1%`,true);// if 1-5\n}else if(tribalCountAK!==null&&tribalCountAK>=1&&tribalCountUS===null&&percentTractTribal===null){prioCopy2Rendered=explore/* getPrioANVCopy */.vr(tribalCountAK,true);// if 1-6\n}else if(tribalCountAK!==null&&tribalCountAK>=1&&tribalCountUS!==null&&tribalCountUS>=1){prioCopy2Rendered=explore/* getPrioAKUSCopy */.uG(tribalCountAK,tribalCountUS,true);// if 1-7\n}else if(!isAdjacencyThreshMet&&isAdjacencyLowIncome&&tribalCountAK!==null&&tribalCountAK>=1&&percentTractTribal!==null&&percentTractTribal>=1){prioCopy2Rendered=explore/* getPrioFRTCopy */.EW(`${percentTractTribal}%`,true);// if 1-8\n}else if(totalCategoriesPrioritized>=1&&tribalCountAK==null&&tribalCountUS!==null&&tribalCountUS>=1&&percentTractTribal==null){prioCopy2Rendered=explore/* getPrioFRTPointsCopy */.VO(tribalCountUS,true);// if 1-9\n}else if(totalCategoriesPrioritized>=1&&tribalCountAK!==null&&tribalCountAK>=1&&percentTractTribal!==null&&percentTractTribal==0){prioCopy2Rendered=explore/* getPrioFRTCopy */.EW(`less than 1%`,true);// if 1-10\n}else if(totalCategoriesPrioritized>=1&&tribalCountAK!==null&&tribalCountAK>=1&&percentTractTribal!==null&&percentTractTribal>=1){prioCopy2Rendered=explore/* getPrioFRTCopy */.EW(`${percentTractTribal}%`,true);}// if 2\n}else if(totalCategoriesPrioritized===0&&isAdjacencyThreshMet&&!isAdjacencyLowIncome&&tribalCountAK===null&&tribalCountUS===null){// if 2-1\nif(percentTractTribal!==null&&percentTractTribal==0){prioCopy2Rendered=explore/* getPrioFRTCopy */.EW(`less than 1%`,false);// if 2-2\n}else if(percentTractTribal!==null&&percentTractTribal>=1){prioCopy2Rendered=explore/* getPrioFRTCopy */.EW(`${percentTractTribal}%`,false);}// if 3-1\n}else if(totalCategoriesPrioritized===0&&isAdjacencyThreshMet&&!isAdjacencyLowIncome&&tribalCountAK===null&&tribalCountUS!==null&&tribalCountUS>=1&&percentTractTribal!==null&&percentTractTribal==0){prioCopy2Rendered=explore/* getPrioFRTPointsCopy */.VO(tribalCountUS,false);// if 3-2\n}else if(totalCategoriesPrioritized===0&&isAdjacencyThreshMet&&!isAdjacencyLowIncome&&tribalCountAK===null&&tribalCountUS!==null&&tribalCountUS>=1&&percentTractTribal!==null&&percentTractTribal>=1){prioCopy2Rendered=explore/* getPrioFRTPointsCopy */.VO(tribalCountUS,false);// if 3-3\n}else if(totalCategoriesPrioritized===0&&!(isAdjacencyThreshMet&&isAdjacencyLowIncome)&&tribalCountAK===null&&tribalCountUS!==null&&tribalCountUS>=1&&percentTractTribal!==null&&percentTractTribal>=0){prioCopy2Rendered=explore/* getPrioFRTPointsCopy */.VO(tribalCountUS,true);// if 4\n}else if(totalCategoriesPrioritized===0&&isAdjacencyThreshMet&&!isAdjacencyLowIncome&&tribalCountAK!==null&&tribalCountAK>=1){prioCopy2Rendered=explore/* getPrioANVCopy */.vr(tribalCountAK,false);}return prioCopy2Rendered&&/*#__PURE__*/react.createElement(\"p\",null,prioCopy2Rendered);};/* harmony default export */ var PrioritizationCopy2_PrioritizationCopy2 = (PrioritizationCopy2);\n;// ./src/components/PrioritizationCopy2/index.ts\n/* harmony default export */ var components_PrioritizationCopy2 = (PrioritizationCopy2_PrioritizationCopy2);\n// EXTERNAL MODULE: ./node_modules/uswds/dist/img/usa-icons/expand_more.svg\nvar expand_more = __webpack_require__(17709);\n// EXTERNAL MODULE: ./node_modules/uswds/dist/img/usa-icons/expand_less.svg\nvar expand_less = __webpack_require__(95477);\n;// ./src/components/TractDemographics/TractDemographics.module.scss\n// extracted by mini-css-extract-plugin\nvar demographicHeading = \"TractDemographics-module--demographicHeading--ICYl+\";\nvar demographicItem = \"TractDemographics-module--demographicItem--16mYq\";\nvar demographicsContainer = \"TractDemographics-module--demographicsContainer--F8hLJ\";\nvar demographicsTitle = \"TractDemographics-module--demographicsTitle--FJtUA\";\nvar showHideIcon = \"TractDemographics-module--showHideIcon--YjMob\";\nvar showHideText = \"TractDemographics-module--showHideText--VRHvL\";\n;// ./src/components/TractDemographics/TractDemographics.tsx\n// @ts-ignore\n// @ts-ignore\n/**\n * This function will create the custom Accordion item. This will be used\n * for the race and age demographic UI elements\n *\n * @param {IJ40AccordionItem} props\n * @return {JSX.Element}\n */const J40AccordionItem=_ref=>{let{id,title,children}=_ref;const{0:isExpanded,1:setIsExpanded}=(0,react.useState)(false);return/*#__PURE__*/react.createElement(react.Fragment,null,/*#__PURE__*/react.createElement(\"h6\",{className:demographicHeading},title,/*#__PURE__*/react.createElement(\"span\",null,'(',/*#__PURE__*/react.createElement(\"a\",{className:showHideText?`usa-link ${showHideText}`:`usa-link`,id:`${id}-header`,\"aria-controls\":`${id}-panel`,\"aria-expanded\":isExpanded,onClick:()=>setIsExpanded(!isExpanded),tabIndex:0},isExpanded?explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.HIDE_DEMOGRAPHICS:explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.SHOW_DEMOGRAPHICS),isExpanded?/*#__PURE__*/react.createElement(\"img\",{className:showHideIcon,src:expand_less/* default */.A,alt:'collapse icon',onClick:()=>setIsExpanded(!isExpanded)}):/*#__PURE__*/react.createElement(\"img\",{className:showHideIcon,src:expand_more/* default */.A,alt:'expand icon',onClick:()=>setIsExpanded(!isExpanded)}),')')),/*#__PURE__*/react.createElement(\"section\",{id:`${id}-panel`,\"aria-labelledby\":`${id}-header`,hidden:!isExpanded},children));};/**\n * This function will create each line item on the list of demographics\n *\n * @param {[]} demographicData\n * @return {JSX.Element}\n */const demographicItemGen=demographicData=>{return demographicData.map((el,index)=>{return/*#__PURE__*/react.createElement(\"div\",{key:index,className:demographicItem},/*#__PURE__*/react.createElement(\"span\",null,el[0]),typeof el[1]==='number'?/*#__PURE__*/react.createElement(\"span\",null,`${el[1]}%`):/*#__PURE__*/react.createElement(\"span\",null,`${el[1]}`));});};/**\n * This function will return the numeric value of each demographic. Taking into\n * account cases when the data is undefined or is null\n *\n * @param {number} stat\n * @return {number}\n */const displayStat=stat=>{if(stat===undefined||stat===null){return'--';}else if(stat===0){return 0;}return Number(Math.floor(stat*100));};/**\n * This function will create the data structure for the demographics data\n *\n * @param {constants.J40Properties} properties\n * @return {IDemographicsData}\n */const getDemographicsData=properties=>({race:[[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_NON_HISPANIC_WHITE,displayStat(properties[constants/* DEMO_NON_HISPANIC_WHITE */.gaC])],[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_BLACK,displayStat(properties[constants/* DEMO_BLACK */.abY])],[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_AMERICAN_INDIAN,displayStat(properties[constants/* DEMO_AMERICAN_INDIAN */.Juu])],[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_ASIAN,displayStat(properties[constants/* DEMO_ASIAN */.lIl])],[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_HAWAIIAN,displayStat(properties[constants/* DEMO_HAWAIIAN */.fRK])],[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_OTHER_RACE,displayStat(properties[constants/* DEMO_OTHER_RACE */.xa4])],[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_TWO_OR_MORE_RACES,displayStat(properties[constants/* DEMO_TWO_OR_MORE_RACES */.CfZ])],[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_HISPANIC,displayStat(properties[constants/* DEMO_HISPANIC */.iqL])]],age:[[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_AGE_UNDER_10,displayStat(properties[constants/* DEMO_AGE_UNDER_10 */.XTj])],[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_AGE_MID,displayStat(properties[constants/* DEMO_AGE_MID */.ri])],[explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.DEMO_AGE_OVER_65,displayStat(properties[constants/* DEMO_AGE_OVER_64 */.UTf])]]});/**\n * This is the main component for this file. It accepts the selected feature\n * as a prop and return the demographics component.\n *\n * @param {ITractDemographicsProps} props\n * @return {JSX.Element}\n */const TractDemographics=_ref2=>{let{properties}=_ref2;const{race,age}=getDemographicsData(properties);return/*#__PURE__*/react.createElement(\"div\",{className:demographicsContainer},/*#__PURE__*/react.createElement(\"div\",{className:demographicsTitle},explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.TITLE),/*#__PURE__*/react.createElement(react.Fragment,null,/*#__PURE__*/react.createElement(J40AccordionItem,{id:'race',title:explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.RACE_TITLE},demographicItemGen(race)),/*#__PURE__*/react.createElement(J40AccordionItem,{id:'age',title:explore/* SIDE_PANEL_DEMOGRAPHICS */.Eg.AGE_TITLE},demographicItemGen(age))));};/* harmony default export */ var TractDemographics_TractDemographics = (TractDemographics);\n;// ./src/components/TractDemographics/index.ts\n/* harmony default export */ var components_TractDemographics = (TractDemographics_TractDemographics);\n;// ./src/components/TractInfo/TractInfo.module.scss\n// extracted by mini-css-extract-plugin\nvar tractInfoContainer = \"TractInfo-module--tractInfoContainer--uPhEW\";\nvar tractInfoLabel = \"TractInfo-module--tractInfoLabel--mY12q\";\n;// ./src/components/TractInfo/TractInfo.tsx\nconst TractInfo=_ref=>{let{blockGroup,countyName,stateName,population,sidePanelState}=_ref;const intl=(0,gatsby_plugin_intl.useIntl)();return/*#__PURE__*/react.createElement(\"ul\",{className:tractInfoContainer},/*#__PURE__*/react.createElement(\"li\",null,/*#__PURE__*/react.createElement(\"span\",{className:tractInfoLabel},intl.formatMessage(explore/* SIDE_PANEL_CBG_INFO */.Fr.CENSUS_INFO_TITLE))),/*#__PURE__*/react.createElement(\"li\",null,/*#__PURE__*/react.createElement(\"span\",null,intl.formatMessage(explore/* SIDE_PANEL_CBG_INFO */.Fr.CENSUS_BLOCK_GROUP)),/*#__PURE__*/react.createElement(\"span\",null,` ${blockGroup}`)),/*#__PURE__*/react.createElement(\"li\",null,/*#__PURE__*/react.createElement(\"span\",null,intl.formatMessage(explore/* SIDE_PANEL_CBG_INFO */.Fr.COUNTY)),/*#__PURE__*/react.createElement(\"span\",null,` ${countyName}`)),/*#__PURE__*/react.createElement(\"li\",null,/*#__PURE__*/react.createElement(\"span\",null,sidePanelState!==constants/* SIDE_PANEL_STATE_VALUES */.IfH.NATION?intl.formatMessage(explore/* SIDE_PANEL_CBG_INFO */.Fr.TERRITORY):intl.formatMessage(explore/* SIDE_PANEL_CBG_INFO */.Fr.STATE)),/*#__PURE__*/react.createElement(\"span\",null,` ${stateName}`)),/*#__PURE__*/react.createElement(\"li\",null,/*#__PURE__*/react.createElement(\"span\",null,intl.formatMessage(explore/* SIDE_PANEL_CBG_INFO */.Fr.POPULATION)),/*#__PURE__*/react.createElement(\"span\",null,` ${population.toLocaleString()}`)));};/* harmony default export */ var TractInfo_TractInfo = (TractInfo);\n;// ./src/components/TractInfo/index.ts\n/* harmony default export */ var components_TractInfo = (TractInfo_TractInfo);\n;// ./src/components/TractPrioritization/TractPrioritization.module.scss\n// extracted by mini-css-extract-plugin\nvar TractPrioritization_module_invert = \"TractPrioritization-module--invert--ouwFc\";\n;// ./src/components/TractPrioritization/TractPrioritization.tsx\n/**\n * This component will return the appropriate designation for the tract's prioritization\n *\n * @param {boolean} scoreNCommunities\n * @param {number | null} tribalCountAK\n * @param {number | null} tribalCountUS\n * @param {number | null} percentTractTribal\n * @return {JSX}\n */const TractPrioritization=_ref=>{let{scoreNCommunities,tribalCountAK,tribalCountUS,percentTractTribal}=_ref;if(scoreNCommunities===true){return/*#__PURE__*/react.createElement(\"h3\",{className:TractPrioritization_module_invert},explore/* COMMUNITY */.GN.OF_FOCUS);}else{if(percentTractTribal===null&&tribalCountAK===null&&tribalCountUS===null){return/*#__PURE__*/react.createElement(\"h3\",null,explore/* COMMUNITY */.GN.NOT_OF_FOCUS);}else{return/*#__PURE__*/react.createElement(\"h3\",{className:TractPrioritization_module_invert},explore/* COMMUNITY */.GN.PARTIAL);}}};/* harmony default export */ var TractPrioritization_TractPrioritization = (TractPrioritization);\n;// ./src/components/TractPrioritization/index.ts\n/* harmony default export */ var components_TractPrioritization = (TractPrioritization_TractPrioritization);\n;// ./src/components/AreaDetail/areaDetail.module.scss\n// extracted by mini-css-extract-plugin\nvar areaDetailContainer = \"areaDetail-module--areaDetailContainer--i8S4c\";\nvar buttonContainer = \"areaDetail-module--buttonContainer--1m7jg\";\nvar buttonText = \"areaDetail-module--buttonText--gKuX3\";\nvar categorization = \"areaDetail-module--categorization--IwyOG\";\nvar categoryHeader = \"areaDetail-module--categoryHeader--74Luo\";\nvar categorySpacer = \"areaDetail-module--categorySpacer--tt0d5\";\nvar censusLabel = \"areaDetail-module--censusLabel--JvpFV\";\nvar censusRow = \"areaDetail-module--censusRow--C9QPu\";\nvar censusText = \"areaDetail-module--censusText--DN7vv\";\nvar communityOfFocus = \"areaDetail-module--communityOfFocus--E2Y4z\";\nvar isInFocus = \"areaDetail-module--isInFocus--cMU9S\";\nvar prioCopy = \"areaDetail-module--prioCopy--8ozG5\";\nvar sendFeedbackBtn = \"areaDetail-module--sendFeedbackBtn--yzU7P\";\nvar sendFeedbackLink = \"areaDetail-module--sendFeedbackLink--w3Noj\";\nvar showCategoriesExceed = \"areaDetail-module--showCategoriesExceed--bumI1\";\nvar testSignals = \"areaDetail-module--testSignals--yYhqR\";\nvar versionInfo = \"areaDetail-module--versionInfo--HNH0O\";\n;// ./src/components/IslandCopy/IslandCopy.module.scss\n// extracted by mini-css-extract-plugin\nvar IslandCopy_module_invert = \"IslandCopy-module--invert--WabDT\";\nvar islandCopyContainer = \"IslandCopy-module--islandCopyContainer--rCBWo\";\nvar islandRow = \"IslandCopy-module--islandRow--U6fnR\";\nvar islandRowLabel = \"IslandCopy-module--islandRowLabel--0Wskg\";\nvar IslandCopy_module_noInvert = \"IslandCopy-module--noInvert--23WaS\";\nvar IslandCopy_module_subTextContainer = \"IslandCopy-module--subTextContainer--WAQ5I\";\nvar valueContainer = \"IslandCopy-module--valueContainer--XyvfT\";\nvar IslandCopy_module_valueSubTextContainer = \"IslandCopy-module--valueSubTextContainer--Y+DQ2\";\n;// ./src/components/IslandCopy/IslandCopy.tsx\nconst IslandCopy=_ref=>{let{povertyPercentile}=_ref;const intl=(0,gatsby_plugin_intl.useIntl)();const percentileWhole=povertyPercentile?parseFloat((povertyPercentile*100).toFixed()):null;const threshold=65;return/*#__PURE__*/react.createElement(\"div\",{className:islandCopyContainer},/*#__PURE__*/react.createElement(\"div\",{className:islandRow},/*#__PURE__*/react.createElement(\"div\",{className:islandRowLabel},intl.formatMessage(explore/* ISLAND_COPY */.cT.LOW_INC)),/*#__PURE__*/react.createElement(\"div\",{className:IslandCopy_module_valueSubTextContainer},/*#__PURE__*/react.createElement(\"div\",{className:`${valueContainer}\n            ${percentileWhole&&percentileWhole>=threshold?IslandCopy_module_invert:IslandCopy_module_noInvert}\n          `},/*#__PURE__*/react.createElement(IndicatorValue,{type:'percentile',displayStat:percentileWhole})),/*#__PURE__*/react.createElement(\"div\",{className:IslandCopy_module_subTextContainer},/*#__PURE__*/react.createElement(IndicatorValueSubText,{value:percentileWhole,isAboveThresh:percentileWhole&&percentileWhole>=threshold?true:false,threshold:threshold,type:'percentile'})))));};/* harmony default export */ var IslandCopy_IslandCopy = (IslandCopy);\n;// ./src/components/AreaDetail/AreaDetail.tsx\n/* eslint-disable quotes */// External Libs:\n// Components:\n// Styles and constants\n// @ts-ignore\n/**\n * There are a 4 different indicator types. Each indicator type will render in the UI differently.\n *\n * percentile - is the majority of indicators\n * percents - a few indicators fall into this type\n * boolean - 3 indicators are of boolean type\n *    - historic redlining\n *    - abandoned land mines\n *    - FUDS\n *\n *//**\n * This interface is used as define the various fields for each indicator in the side panel\n *  label: the indicator label or title\n *  description: the description of the indicator used in the side panel\n *  type: see indicatorType above\n *  value: the number from the geoJSON tile. If tile doesn't exist it get a null value. Could be boolean also\n *  isDisadvagtaged: the flag from the geoJSON tile\n *  threshold: a custom value of threshold for certain indicators\n *  *//**\n * This interface is used as define the various fields for category in the side panel\n * id: distict id\n * titleText: display text for the category title\n * indicators: an array of indicators\n * socioEcIndicators: an array of socioeconomic indicators\n * isDisadvagtaged: boolean to indicate if the category is disadvantaged\n * isExceed1MoreBurden: boolean to indicate if the category exceeds more than one burden\n * isExceedBothSocioBurdens: boolean to indicate if the category exceeds both socio-eco burdens\n *  *//**\n * This filter will remove indicators from appearing in the side panel by returning\n * the filter function (currying). There is 1 use case. It can accept any indicator name\n * as an input.\n *\n * 1. For Historic underinvestment if the value is null\n *\n * Recommendation is to use a separate filter for each indicator that needs filtering.\n *\n * @param {MessageDescriptor} label - allows to re-use this filter for any number of indicators\n * @return {indicatorInfo}\n */const indicatorFilter=label=>{const intl=useIntl();return indicator=>indicator.label!==intl.formatMessage(label)||indicator.label==intl.formatMessage(label)&&indicator.value!=null;};/**\n * Function to calculate the tribal area percentage value to display when a tract is selected\n *\n * @param {number} tribalPercentRaw\n * @return {string}\n */const getTribalPercentValue=tribalPercentRaw=>{if(tribalPercentRaw===undefined){return` none`;}if(tribalPercentRaw===0){// test tract = #9.03/42.9242/-98.8015\nreturn` less than 1%`;}if(tribalPercentRaw&&tribalPercentRaw>0){return` ${parseFloat((tribalPercentRaw*100).toFixed())} %`;}};/**\n * This is the main component. It will render the entire side panel and show the details\n * of the area/feature that is selected.\n *\n * @param {IAreaDetailProps} {}\n * @return {void}\n */const AreaDetail=_ref=>{let{properties}=_ref;const intl=(0,gatsby_plugin_intl.useIntl)();/**\n   * Set the indicators for a given category.\n   * @param {string} id the category ID\n   * @param {indicatorInfo[]} indicators the indicators to set for the category.\n   * @throws Error if the category ID does not exist\n   */const setCategoryIndicators=(id,indicators)=>{const cat=categories.find(category=>category.id===id);if(cat)cat.indicators=indicators;else throw new Error('Unknown side panel category ID '+id);};// console.log the properties of the census that is selected:\nconsole.log(\"BE signals for tract (last one is the tract currently selected): \",properties);// console.log around the donut, adjacency and tribal info:\nconsole.log(\"Income imputed? \",properties[constants/* IMPUTE_FLAG */.WDE]===\"0\"?\" NO\":\" YES\");console.log(\"Adjacency indicator? \",properties[constants/* ADJACENCY_EXCEEDS_THRESH */.axb]?\" YES\":\" NO\");console.log(\"% of tract tribal: \",getTribalPercentValue(properties[constants/* TRIBAL_AREAS_PERCENTAGE */.H3b]));console.log(\"Tribal count in AK: \",properties[constants/* TRIBAL_AREAS_COUNT_AK */.$RP]>=1?` ${properties[constants/* TRIBAL_AREAS_COUNT_AK */.$RP]}`:` null`);console.log(\"Tribal count in CONUS: \",properties[constants/* TRIBAL_AREAS_COUNT_CONUS */.drv]>=1?` ${properties[constants/* TRIBAL_AREAS_COUNT_CONUS */.drv]}`:` null`);// Fix constants.MISSING_DATA_STRING import\nconst blockGroup=properties[constants/* GEOID_PROPERTY */.TnO]?properties[constants/* GEOID_PROPERTY */.TnO]:constants/* MISSING_DATA_STRING */.WiZ;const population=properties[constants/* TOTAL_POPULATION */.tO9]?properties[constants/* TOTAL_POPULATION */.tO9]:constants/* MISSING_DATA_STRING */.WiZ;const countyName=properties[constants/* COUNTY_NAME */.LsS]?properties[constants/* COUNTY_NAME */.LsS]:constants/* MISSING_DATA_STRING */.WiZ;const stateName=properties[constants/* STATE_NAME */.sfg]?properties[constants/* STATE_NAME */.sfg]:constants/* MISSING_DATA_STRING */.WiZ;const sidePanelState=properties[constants/* SIDE_PANEL_STATE */.TPq];const percentTractTribal=properties[constants/* TRIBAL_AREAS_PERCENTAGE */.H3b]>=0?parseFloat((properties[constants/* TRIBAL_AREAS_PERCENTAGE */.H3b]*100).toFixed()):null;/**\n   * The workforce development category has some indicators who's source will vary depending on which\n   * territory is selected. This function allows us to change the source of workforce development indicators\n   * depending on which territory was selected\n   *\n   * @param {string} indicatorName\n   * @return {void}\n   */const getWorkForceIndicatorValue=indicatorName=>{if(sidePanelState===constants/* SIDE_PANEL_STATE_VALUES */.IfH.ISLAND_AREAS){if(indicatorName===\"lowMedInc\"){return properties.hasOwnProperty(constants/* ISLAND_AREAS_LOW_MEDIAN_INCOME_LOW_HS_EDU_PERCENTILE_FIELD */.e79)?properties[constants/* ISLAND_AREAS_LOW_MEDIAN_INCOME_LOW_HS_EDU_PERCENTILE_FIELD */.e79]:null;}if(indicatorName===\"unemploy\"){return properties.hasOwnProperty(constants/* ISLAND_AREAS_UNEMPLOYMENT_LOW_HS_EDU_PERCENTILE_FIELD */.urO)?properties[constants/* ISLAND_AREAS_UNEMPLOYMENT_LOW_HS_EDU_PERCENTILE_FIELD */.urO]:null;}if(indicatorName===\"poverty\"){return properties.hasOwnProperty(constants/* ISLAND_AREAS_POVERTY_LOW_HS_EDU_PERCENTILE_FIELD */.Isp)?properties[constants/* ISLAND_AREAS_POVERTY_LOW_HS_EDU_PERCENTILE_FIELD */.Isp]:null;}if(indicatorName===\"highSchool\"){return properties.hasOwnProperty(constants/* ISLAND_AREAS_HS_EDU_PERCENTAGE_FIELD */.s0s)?properties[constants/* ISLAND_AREAS_HS_EDU_PERCENTAGE_FIELD */.s0s]:null;}}if(indicatorName===\"lowMedInc\"){return properties.hasOwnProperty(constants/* LOW_MEDIAN_INCOME_PERCENTILE */.Ipt)?properties[constants/* LOW_MEDIAN_INCOME_PERCENTILE */.Ipt]:null;}if(indicatorName===\"unemploy\"){return properties.hasOwnProperty(constants/* UNEMPLOYMENT_PROPERTY_PERCENTILE */.Q_N)?properties[constants/* UNEMPLOYMENT_PROPERTY_PERCENTILE */.Q_N]:null;}if(indicatorName===\"poverty\"){return properties.hasOwnProperty(constants/* POVERTY_BELOW_100_PERCENTILE */.uZc)?properties[constants/* POVERTY_BELOW_100_PERCENTILE */.uZc]:null;}if(indicatorName===\"highSchool\"){return properties.hasOwnProperty(constants/* HIGH_SCHOOL_PROPERTY_PERCENTILE */.QTx)?properties[constants/* HIGH_SCHOOL_PROPERTY_PERCENTILE */.QTx]:null;}};/**\n   * The workforce development category has some indicators who's disadvantaged boolean\n   * will vary depending on which territory is selected. This function allows us to change\n   * the boolean of workforce development indicators depending on which territory was selected\n   *\n   * @param {string} indicatorName\n   * @return {void}\n   */const getWorkForceIndicatorIsDisadv=indicatorName=>{if(sidePanelState===constants/* SIDE_PANEL_STATE_VALUES */.IfH.ISLAND_AREAS){if(indicatorName===\"lowMedInc\"){return properties.hasOwnProperty(constants/* IS_EXCEEDS_THRESH_FOR_ISLAND_AREA_LOW_MEDIAN_INCOME */.WGo)?properties[constants/* IS_EXCEEDS_THRESH_FOR_ISLAND_AREA_LOW_MEDIAN_INCOME */.WGo]:null;}if(indicatorName===\"unemploy\"){return properties.hasOwnProperty(constants/* IS_EXCEEDS_THRESH_FOR_ISLAND_AREA_UNEMPLOYMENT */.md9)?properties[constants/* IS_EXCEEDS_THRESH_FOR_ISLAND_AREA_UNEMPLOYMENT */.md9]:null;}if(indicatorName===\"poverty\"){return properties.hasOwnProperty(constants/* IS_EXCEEDS_THRESH_FOR_ISLAND_AREA_BELOW_100_POVERTY */.mHs)?properties[constants/* IS_EXCEEDS_THRESH_FOR_ISLAND_AREA_BELOW_100_POVERTY */.mHs]:null;}if(indicatorName===\"highSchool\"){return properties.hasOwnProperty(constants/* ISLAND_AREA_LOW_HS_EDU */.A7Z)?properties[constants/* ISLAND_AREA_LOW_HS_EDU */.A7Z]:null;}}if(indicatorName===\"lowMedInc\"){return properties.hasOwnProperty(constants/* IS_EXCEEDS_THRESH_FOR_LOW_MEDIAN_INCOME */.SCG)?properties[constants/* IS_EXCEEDS_THRESH_FOR_LOW_MEDIAN_INCOME */.SCG]:null;}if(indicatorName===\"unemploy\"){return properties.hasOwnProperty(constants/* IS_EXCEEDS_THRESH_FOR_UNEMPLOYMENT */.Kvk)?properties[constants/* IS_EXCEEDS_THRESH_FOR_UNEMPLOYMENT */.Kvk]:null;}if(indicatorName===\"poverty\"){return properties.hasOwnProperty(constants/* IS_EXCEEDS_THRESH_FOR_BELOW_100_POVERTY */._FA)?properties[constants/* IS_EXCEEDS_THRESH_FOR_BELOW_100_POVERTY */._FA]:null;}if(indicatorName===\"highSchool\"){return properties.hasOwnProperty(constants/* IS_LOW_HS_EDUCATION_LOW_HIGHER_ED_PRIORITIZED */.mx8)?properties[constants/* IS_LOW_HS_EDUCATION_LOW_HIGHER_ED_PRIORITIZED */.mx8]:null;}};/**\n   * Define each indicator in the side panel with constants from copy file (for intl)\n   *\n   * Indicators are grouped by category\n   */// Climate category\nconst expAgLoss={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.EXP_AG_LOSS),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.EXP_AG_LOSS),type:\"percentile\",value:properties.hasOwnProperty(constants/* EXP_AGRICULTURE_LOSS_PERCENTILE */.eH1)?properties[constants/* EXP_AGRICULTURE_LOSS_PERCENTILE */.eH1]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_EXP_AGR_LOSS */.DaG]?properties[constants/* IS_EXCEEDS_THRESH_FOR_EXP_AGR_LOSS */.DaG]:null};const expBldLoss={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.EXP_BLD_LOSS),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.EXP_BLD_LOSS),type:\"percentile\",value:properties.hasOwnProperty(constants/* EXP_BUILDING_LOSS_PERCENTILE */.Ht4)?properties[constants/* EXP_BUILDING_LOSS_PERCENTILE */.Ht4]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_EXP_BLD_LOSS */.fuF]?properties[constants/* IS_EXCEEDS_THRESH_FOR_EXP_BLD_LOSS */.fuF]:null};const expPopLoss={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.EXP_POP_LOSS),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.EXP_POP_LOSS),type:\"percentile\",value:properties.hasOwnProperty(constants/* EXP_POPULATION_LOSS_PERCENTILE */.Cvf)?properties[constants/* EXP_POPULATION_LOSS_PERCENTILE */.Cvf]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_EXP_POP_LOSS */.O4u]?properties[constants/* IS_EXCEEDS_THRESH_FOR_EXP_POP_LOSS */.O4u]:null};const flooding={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.FLOODING),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.FLOODING),type:\"percentile\",value:properties.hasOwnProperty(constants/* FLOODING_PERCENTILE */.Tp5)?properties[constants/* FLOODING_PERCENTILE */.Tp5]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FLOODING */.HY7]?properties[constants/* IS_EXCEEDS_THRESH_FLOODING */.HY7]:null};const wildfire={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.WILDFIRE),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.WILDFIRE),type:\"percentile\",value:properties.hasOwnProperty(constants/* WILDFIRE_PERCENTILE */.n9g)?properties[constants/* WILDFIRE_PERCENTILE */.n9g]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_WILDFIRE */.TUJ]?properties[constants/* IS_EXCEEDS_THRESH_WILDFIRE */.TUJ]:null};const lowInc={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.LOW_INCOME),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.LOW_INCOME),type:\"percentile\",value:properties.hasOwnProperty(constants/* POVERTY_BELOW_200_PERCENTILE */.FSv)?properties[constants/* POVERTY_BELOW_200_PERCENTILE */.FSv]:null,isDisadvagtaged:properties[constants/* IS_FEDERAL_POVERTY_LEVEL_200 */.pyQ]?properties[constants/* IS_FEDERAL_POVERTY_LEVEL_200 */.pyQ]:null,threshold:65};// const higherEd: indicatorInfo = {\n//   label: intl.formatMessage(EXPLORE_COPY.SIDE_PANEL_INDICATORS.HIGH_ED),\n//   description: intl.formatMessage(EXPLORE_COPY.SIDE_PANEL_INDICATOR_DESCRIPTION.HIGH_ED),\n//   type: 'percent',\n//   value: properties.hasOwnProperty(constants.NON_HIGHER_ED_PERCENTILE) ?\n//     properties[constants.NON_HIGHER_ED_PERCENTILE] : null,\n//   isDisadvagtaged: properties[constants.IS_HIGHER_ED_PERCENTILE] ?\n//     properties[constants.IS_HIGHER_ED_PERCENTILE] : null,\n//   threshold: 80,\n// };\n// Energy category\nconst energyCost={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.ENERGY_COST),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.ENERGY_COST),type:\"percentile\",value:properties.hasOwnProperty(constants/* ENERGY_PERCENTILE */.$N3)?properties[constants/* ENERGY_PERCENTILE */.$N3]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_ENERGY_BURDEN */._Ad]?properties[constants/* IS_EXCEEDS_THRESH_FOR_ENERGY_BURDEN */._Ad]:null};const pm25={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.PM_2_5),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.PM_2_5),type:\"percentile\",value:properties.hasOwnProperty(constants/* PM25_PERCENTILE */.BNf)?properties[constants/* PM25_PERCENTILE */.BNf]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_PM25 */.NGc]?properties[constants/* IS_EXCEEDS_THRESH_FOR_PM25 */.NGc]:null};// Health category\nconst asthma={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.ASTHMA),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.ASTHMA),type:\"percentile\",value:properties.hasOwnProperty(constants/* ASTHMA_PERCENTILE */.dbq)?properties[constants/* ASTHMA_PERCENTILE */.dbq]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_ASTHMA */.Ptd]?properties[constants/* IS_EXCEEDS_THRESH_FOR_ASTHMA */.Ptd]:null};const diabetes={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.DIABETES),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.DIABETES),type:\"percentile\",value:properties.hasOwnProperty(constants/* DIABETES_PERCENTILE */.aJS)?properties[constants/* DIABETES_PERCENTILE */.aJS]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_DIABETES */.Ot]?properties[constants/* IS_EXCEEDS_THRESH_FOR_DIABETES */.Ot]:null};const heartDisease={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.HEART_DISEASE),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.HEART_DISEASE),type:\"percentile\",value:properties.hasOwnProperty(constants/* HEART_PERCENTILE */.Pgu)?properties[constants/* HEART_PERCENTILE */.Pgu]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_HEART_DISEASE */.i_2]?properties[constants/* IS_EXCEEDS_THRESH_FOR_HEART_DISEASE */.i_2]:null};const lifeExpect={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.LIFE_EXPECT),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.LOW_LIFE_EXPECT),type:\"percentile\",value:properties.hasOwnProperty(constants/* LIFE_PERCENTILE */.Zv0)?properties[constants/* LIFE_PERCENTILE */.Zv0]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_LOW_LIFE_EXP */.aD6]?properties[constants/* IS_EXCEEDS_THRESH_FOR_LOW_LIFE_EXP */.aD6]:null};// Housing category\nconst historicUnderinvest={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.HIST_UNDERINVEST),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.HIST_UNDERINVEST),type:\"boolean\",value:properties.hasOwnProperty(constants/* HISTORIC_UNDERINVESTMENT_EXCEED_THRESH */.yIR)?properties[constants/* HISTORIC_UNDERINVESTMENT_EXCEED_THRESH */.yIR]===constants/* HISTORIC_UNDERINVESTMENT_RAW_YES */.pas?true:false:null,isDisadvagtaged:properties.hasOwnProperty(constants/* HISTORIC_UNDERINVESTMENT_EXCEED_THRESH */.yIR)&&properties[constants/* HISTORIC_UNDERINVESTMENT_EXCEED_THRESH */.yIR]===constants/* HISTORIC_UNDERINVESTMENT_RAW_YES */.pas?true:false};const houseCost={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.HOUSE_COST),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.HOUSE_COST),type:\"percentile\",value:properties.hasOwnProperty(constants/* HOUSING_BURDEN_PROPERTY_PERCENTILE */.XCy)?properties[constants/* HOUSING_BURDEN_PROPERTY_PERCENTILE */.XCy]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_HOUSE_BURDEN */.arr]?properties[constants/* IS_EXCEEDS_THRESH_FOR_HOUSE_BURDEN */.arr]:null};const lackGreenSpace={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.LACK_GREEN_SPACE),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.LACK_GREEN_SPACE),type:\"percentile\",value:properties.hasOwnProperty(constants/* IMPERVIOUS_PERCENTILE */._lZ)?properties[constants/* IMPERVIOUS_PERCENTILE */._lZ]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_IMPERVIOUS */.SJ6]?properties[constants/* IS_EXCEEDS_THRESH_IMPERVIOUS */.SJ6]:null};const lackPlumbing={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.LACK_PLUMBING),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.LACK_PLUMBING),type:\"percentile\",value:properties.hasOwnProperty(constants/* KITCHEN_PLUMB_PERCENTILE */.M_z)?properties[constants/* KITCHEN_PLUMB_PERCENTILE */.M_z]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_KITCHEN_PLUMB */.GVB]?properties[constants/* IS_EXCEEDS_THRESH_KITCHEN_PLUMB */.GVB]:null};const leadPaint={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.LEAD_PAINT),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.LEAD_PAINT),type:\"percentile\",value:properties.hasOwnProperty(constants/* LEAD_PAINT_PERCENTILE */.ShH)?properties[constants/* LEAD_PAINT_PERCENTILE */.ShH]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_LEAD_PAINT_AND_MEDIAN_HOME_VAL */.fuy]?properties[constants/* IS_EXCEEDS_THRESH_FOR_LEAD_PAINT_AND_MEDIAN_HOME_VAL */.fuy]:null};// Pollution categeory\nconst abandonMines={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.ABANDON_MINES),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.ABANDON_MINES),type:\"boolean\",value:properties.hasOwnProperty(constants/* ABANDON_LAND_MINES_EXCEEDS_THRESH */.oa$)?properties[constants/* ABANDON_LAND_MINES_EXCEEDS_THRESH */.oa$]:null,isDisadvagtaged:properties.hasOwnProperty(constants/* ABANDON_LAND_MINES_EXCEEDS_THRESH */.oa$)?properties[constants/* ABANDON_LAND_MINES_EXCEEDS_THRESH */.oa$]:null};const formerDefSites={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.FORMER_DEF_SITES),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.FORMER_DEF_SITES),type:\"boolean\",// double equality is used in this instance as it seems that FUDS_RAW could be \"1\" or 1 from the BE\nvalue:properties.hasOwnProperty(constants/* FORMER_DEF_SITES_RAW_VALUE */.MdH)?properties[constants/* FORMER_DEF_SITES_RAW_VALUE */.MdH]==constants/* FUDS_RAW_YES */.wzj?true:false:null,isDisadvagtaged:properties.hasOwnProperty(constants/* FORMER_DEF_SITES_EXCEEDS_THRESH */.aU2)?properties[constants/* FORMER_DEF_SITES_EXCEEDS_THRESH */.aU2]:null};const proxHaz={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.PROX_HAZ),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.PROX_HAZ),type:\"percentile\",value:properties.hasOwnProperty(constants/* PROXIMITY_TSDF_SITES_PERCENTILE */.xJH)?properties[constants/* PROXIMITY_TSDF_SITES_PERCENTILE */.xJH]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_HAZARD_WASTE */.i3y]?properties[constants/* IS_EXCEEDS_THRESH_FOR_HAZARD_WASTE */.i3y]:null};const proxRMP={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.PROX_RMP),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.PROX_RMP),type:\"percentile\",value:properties.hasOwnProperty(constants/* PROXIMITY_RMP_SITES_PERCENTILE */.RAw)?properties[constants/* PROXIMITY_RMP_SITES_PERCENTILE */.RAw]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_RMP */.qh7]?properties[constants/* IS_EXCEEDS_THRESH_FOR_RMP */.qh7]:null};const proxNPL={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.PROX_NPL),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.PROX_NPL),type:\"percentile\",value:properties.hasOwnProperty(constants/* PROXIMITY_NPL_SITES_PERCENTILE */.eLl)?properties[constants/* PROXIMITY_NPL_SITES_PERCENTILE */.eLl]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_SUPERFUND */.pmG]?properties[constants/* IS_EXCEEDS_THRESH_FOR_SUPERFUND */.pmG]:null};// Transpotation category\nconst dieselPartMatter={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.DIESEL_PARTICULATE_MATTER),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.DIESEL_PARTICULATE_MATTER),type:\"percentile\",value:properties.hasOwnProperty(constants/* DIESEL_MATTER_PERCENTILE */.PHG)?properties[constants/* DIESEL_MATTER_PERCENTILE */.PHG]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_DIESEL_PM */.vDd]?properties[constants/* IS_EXCEEDS_THRESH_FOR_DIESEL_PM */.vDd]:null};const barrierTransport={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.BARRIER_TRANS),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.BARRIER_TRANS),type:\"percentile\",value:properties.hasOwnProperty(constants/* TRAVEL_DISADV_PERCENTILE */.pRw)?properties[constants/* TRAVEL_DISADV_PERCENTILE */.pRw]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_TRAVEL_DISADV */.TdA]?properties[constants/* IS_EXCEEDS_THRESH_TRAVEL_DISADV */.TdA]:null};const trafficVolume={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.TRAFFIC_VOLUME),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.TRAFFIC_VOLUME),type:\"percentile\",value:properties.hasOwnProperty(constants/* TRAFFIC_PERCENTILE */.SIY)?properties[constants/* TRAFFIC_PERCENTILE */.SIY]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_TRAFFIC_PROX */.eMp]?properties[constants/* IS_EXCEEDS_THRESH_FOR_TRAFFIC_PROX */.eMp]:null};// Water category\nconst leakyTanks={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.LEAKY_TANKS),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.LEAKY_TANKS),type:\"percentile\",value:properties.hasOwnProperty(constants/* LEAKY_UNDER_PERCENTILE */.qxA)?properties[constants/* LEAKY_UNDER_PERCENTILE */.qxA]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_LEAKY_UNDER */.YgP]?properties[constants/* IS_EXCEEDS_THRESH_LEAKY_UNDER */.YgP]:null};const wasteWater={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.WASTE_WATER),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.WASTE_WATER),type:\"percentile\",value:properties.hasOwnProperty(constants/* WASTEWATER_PERCENTILE */.Uo7)?properties[constants/* WASTEWATER_PERCENTILE */.Uo7]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_WASTEWATER */.Gle]?properties[constants/* IS_EXCEEDS_THRESH_FOR_WASTEWATER */.Gle]:null};// Workforce dev category\nconst lingIso={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.LING_ISO),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.LING_ISO),type:\"percentile\",value:properties.hasOwnProperty(constants/* LINGUISTIC_ISOLATION_PROPERTY_PERCENTILE */.b1X)?properties[constants/* LINGUISTIC_ISOLATION_PROPERTY_PERCENTILE */.b1X]:null,isDisadvagtaged:properties[constants/* IS_EXCEEDS_THRESH_FOR_LINGUISITIC_ISO */.pyI]?properties[constants/* IS_EXCEEDS_THRESH_FOR_LINGUISITIC_ISO */.pyI]:null};const lowMedInc={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.LOW_MED_INC),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.LOW_MED_INCOME),type:\"percentile\",value:getWorkForceIndicatorValue(\"lowMedInc\"),isDisadvagtaged:getWorkForceIndicatorIsDisadv(\"lowMedInc\")};const unemploy={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.UNEMPLOY),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.UNEMPLOY),type:\"percentile\",value:getWorkForceIndicatorValue(\"unemploy\"),isDisadvagtaged:getWorkForceIndicatorIsDisadv(\"unemploy\")};const poverty={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.POVERTY),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.POVERTY),type:\"percentile\",value:getWorkForceIndicatorValue(\"poverty\"),isDisadvagtaged:getWorkForceIndicatorIsDisadv(\"poverty\")};const highSchool={label:intl.formatMessage(explore/* SIDE_PANEL_INDICATORS */.mN.HIGH_SCL),description:intl.formatMessage(explore/* SIDE_PANEL_INDICATOR_DESCRIPTION */.EB.HIGH_SKL),type:\"percent\",value:getWorkForceIndicatorValue(\"highSchool\"),isDisadvagtaged:getWorkForceIndicatorIsDisadv(\"highSchool\"),threshold:10};/**\n   * Aggregate indicators based on categories\n   *\n   * The indicators property must be an array with last two elements being the\n   * socioeconomic burdens.\n   */let categories=[{id:\"climate-change\",titleText:intl.formatMessage(explore/* SIDE_PANEL_CATEGORY */.wP.CLIMATE),indicators:[expAgLoss,expBldLoss,expPopLoss,flooding,wildfire],socioEcIndicators:[lowInc],isDisadvagtaged:properties[constants/* IS_CLIMATE_FACTOR_DISADVANTAGED */.z1Q]?properties[constants/* IS_CLIMATE_FACTOR_DISADVANTAGED */.z1Q]:null,isExceed1MoreBurden:properties[constants/* IS_CLIMATE_EXCEED_ONE_OR_MORE_INDICATORS */.gDg]?properties[constants/* IS_CLIMATE_EXCEED_ONE_OR_MORE_INDICATORS */.gDg]:null,isExceedBothSocioBurdens:properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]?properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]:null},{id:\"clean-energy\",titleText:intl.formatMessage(explore/* SIDE_PANEL_CATEGORY */.wP.CLEAN_ENERGY),indicators:[energyCost,pm25],socioEcIndicators:[lowInc],isDisadvagtaged:properties[constants/* IS_ENERGY_FACTOR_DISADVANTAGED */.QRn]?properties[constants/* IS_ENERGY_FACTOR_DISADVANTAGED */.QRn]:null,isExceed1MoreBurden:properties[constants/* IS_ENERGY_EXCEED_ONE_OR_MORE_INDICATORS */.F1p]?properties[constants/* IS_ENERGY_EXCEED_ONE_OR_MORE_INDICATORS */.F1p]:null,isExceedBothSocioBurdens:properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]?properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]:null},{id:\"health-burdens\",titleText:intl.formatMessage(explore/* SIDE_PANEL_CATEGORY */.wP.HEALTH_BURDEN),indicators:[asthma,diabetes,heartDisease,lifeExpect],socioEcIndicators:[lowInc],isDisadvagtaged:properties[constants/* IS_HEALTH_FACTOR_DISADVANTAGED */.sW6]?properties[constants/* IS_HEALTH_FACTOR_DISADVANTAGED */.sW6]:null,isExceed1MoreBurden:properties[constants/* IS_HEALTH_EXCEED_ONE_OR_MORE_INDICATORS */.fbb]?properties[constants/* IS_HEALTH_EXCEED_ONE_OR_MORE_INDICATORS */.fbb]:null,isExceedBothSocioBurdens:properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]?properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]:null},{id:\"sustain-house\",titleText:intl.formatMessage(explore/* SIDE_PANEL_CATEGORY */.wP.SUSTAIN_HOUSE),indicators:[historicUnderinvest,houseCost,lackGreenSpace,lackPlumbing,leadPaint],socioEcIndicators:[lowInc],isDisadvagtaged:properties[constants/* IS_HOUSING_FACTOR_DISADVANTAGED */.jtt]?properties[constants/* IS_HOUSING_FACTOR_DISADVANTAGED */.jtt]:null,isExceed1MoreBurden:properties[constants/* IS_HOUSING_EXCEED_ONE_OR_MORE_INDICATORS */.IXr]?properties[constants/* IS_HOUSING_EXCEED_ONE_OR_MORE_INDICATORS */.IXr]:null,isExceedBothSocioBurdens:properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]?properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]:null},{id:\"leg-pollute\",titleText:intl.formatMessage(explore/* SIDE_PANEL_CATEGORY */.wP.LEG_POLLUTE),indicators:[abandonMines,formerDefSites,proxHaz,proxRMP,proxNPL],socioEcIndicators:[lowInc],isDisadvagtaged:properties[constants/* IS_POLLUTION_FACTOR_DISADVANTAGED */.uxy]?properties[constants/* IS_POLLUTION_FACTOR_DISADVANTAGED */.uxy]:null,isExceed1MoreBurden:properties[constants/* IS_POLLUTION_EXCEED_ONE_OR_MORE_INDICATORS */.jD1]?properties[constants/* IS_POLLUTION_EXCEED_ONE_OR_MORE_INDICATORS */.jD1]:null,isExceedBothSocioBurdens:properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]?properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]:null},{id:\"clean-transport\",titleText:intl.formatMessage(explore/* SIDE_PANEL_CATEGORY */.wP.CLEAN_TRANSPORT),indicators:[dieselPartMatter,barrierTransport,trafficVolume],socioEcIndicators:[lowInc],isDisadvagtaged:properties[constants/* IS_TRANSPORT_FACTOR_DISADVANTAGED */.lJt]?properties[constants/* IS_TRANSPORT_FACTOR_DISADVANTAGED */.lJt]:null,isExceed1MoreBurden:properties[constants/* IS_TRANSPORT_EXCEED_ONE_OR_MORE_INDICATORS */.QqC]?properties[constants/* IS_TRANSPORT_EXCEED_ONE_OR_MORE_INDICATORS */.QqC]:null,isExceedBothSocioBurdens:properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]?properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]:null},{id:\"clean-water\",titleText:intl.formatMessage(explore/* SIDE_PANEL_CATEGORY */.wP.CLEAN_WATER),indicators:[leakyTanks,wasteWater],socioEcIndicators:[lowInc],isDisadvagtaged:properties[constants/* IS_WATER_FACTOR_DISADVANTAGED */.fPC]?properties[constants/* IS_WATER_FACTOR_DISADVANTAGED */.fPC]:null,isExceed1MoreBurden:properties[constants/* IS_WATER_EXCEED_ONE_OR_MORE_INDICATORS */.KUV]?properties[constants/* IS_WATER_EXCEED_ONE_OR_MORE_INDICATORS */.KUV]:null,isExceedBothSocioBurdens:properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]?properties[constants/* IS_EXCEED_BOTH_SOCIO_INDICATORS */.Zdj]:null},{id:\"work-dev\",titleText:intl.formatMessage(explore/* SIDE_PANEL_CATEGORY */.wP.WORK_DEV),indicators:[lingIso,lowMedInc,poverty,unemploy],socioEcIndicators:[highSchool],isDisadvagtaged:properties[constants/* IS_WORKFORCE_FACTOR_DISADVANTAGED */.EPb]?properties[constants/* IS_WORKFORCE_FACTOR_DISADVANTAGED */.EPb]:null,isExceed1MoreBurden:properties[constants/* IS_WORKFORCE_EXCEED_ONE_OR_MORE_INDICATORS */.R35]?properties[constants/* IS_WORKFORCE_EXCEED_ONE_OR_MORE_INDICATORS */.R35]:null,isExceedBothSocioBurdens:properties[constants/* IS_WORKFORCE_EXCEED_BOTH_SOCIO_INDICATORS */.mVw]?properties[constants/* IS_WORKFORCE_EXCEED_BOTH_SOCIO_INDICATORS */.mVw]:null}];/**\n   * Modify the category array depending on the sidePanelState field. This field comes from the backend\n   * and is called UI_EXP.\n   *\n   * This sidePanelState has 3 values; namely, Nation, Puerto Rico and Island Areas.\n   */if(sidePanelState===constants/* SIDE_PANEL_STATE_VALUES */.IfH.PUERTO_RICO){// Re-define which burdens show up for each category:\nsetCategoryIndicators('climate-change',[flooding]);setCategoryIndicators('clean-energy',[energyCost]);setCategoryIndicators('sustain-house',[historicUnderinvest,houseCost,lackPlumbing,leadPaint]);setCategoryIndicators('leg-pollute',[proxHaz,proxRMP,proxNPL]);setCategoryIndicators('clean-transport',[dieselPartMatter,trafficVolume]);setCategoryIndicators('work-dev',[lowMedInc,poverty,unemploy]);}if(sidePanelState===constants/* SIDE_PANEL_STATE_VALUES */.IfH.ISLAND_AREAS){// For Island Areas - only show workforce dev category\ncategories=categories.filter(category=>category.id===\"work-dev\");// For Island Areas - remove the linguistic Isolation\ncategories[0].indicators=[lowMedInc,unemploy,poverty];}const isTerritory=constants/* TILES_ISLAND_AREA_FIPS_CODES */.STP.some(code=>{return properties[constants/* GEOID_PROPERTY */.TnO].startsWith(code);});const isGrandfathered=properties[constants/* IS_GRANDFATHERED */.fgy];// Show Donut information !isGrandfathered\nconst showDonutCopy=!isGrandfathered&&properties[constants/* ADJACENCY_EXCEEDS_THRESH */.axb]&&properties[constants/* TOTAL_NUMBER_OF_DISADVANTAGE_INDICATORS */.SfK]===0;const showIslandCopy=isTerritory&&!showDonutCopy;// For territories we use the poverty percentile from the census decennial data\nconst poveryPercentile=isTerritory?properties[constants/* CENSUS_DECENNIAL_POVERTY_LESS_THAN_200_FPL_PERCENTILE */.g1v]:properties[constants/* POVERTY_BELOW_200_PERCENTILE */.FSv]>0?properties[constants/* POVERTY_BELOW_200_PERCENTILE */.FSv]:null;/**\n   * Create the AccoridionItems by mapping over the categories array. In this array we define the\n   * various indicators for a specific category. This is an array which then maps over the\n   * <Indicator /> component to render the actual Indicator\n   */const categoryItems=categories.map(category=>({id:category.id,/*\n    As of trussworks 3.0.0, there were some breaking changes. This new prop of headingLevel\n    is required, however, the title prop is already defining the category styling, so this\n    is placed here to satisfy the requirement of the AccordionItems API, however it's not\n    being used.\n\n    Casting 'h4' as const because it needs to be a heading type as specified HeadingLevel.\n    */headingLevel:\"h4\",title:/*#__PURE__*/react.createElement(components_Category,{name:category.titleText,isDisadvantaged:category.isDisadvagtaged}),content:/*#__PURE__*/react.createElement(react.Fragment,null,category.indicators.map((indicator,index)=>{return/*#__PURE__*/react.createElement(components_Indicator,{key:`ind${index}`,indicator:indicator});}),/*#__PURE__*/react.createElement(\"div\",{className:categorySpacer},explore/* SIDE_PANEL_SPACERS */.zZ.AND),category.socioEcIndicators.map((indicator,index)=>{return/*#__PURE__*/react.createElement(components_Indicator,{key:`ind${index}`,indicator:indicator,isImpute:properties[constants/* IMPUTE_FLAG */.WDE]===\"0\"?false:true,population:population});})),expanded:false}));return/*#__PURE__*/react.createElement(\"aside\",{className:areaDetailContainer,\"data-cy\":\"aside\"},/*#__PURE__*/react.createElement(components_TractInfo,{blockGroup:blockGroup,countyName:countyName,stateName:stateName,population:population,sidePanelState:properties[constants/* SIDE_PANEL_STATE */.TPq]}),/*#__PURE__*/react.createElement(components_TractDemographics,{properties:properties}),/*#__PURE__*/react.createElement(\"div\",{className:categorization},/*#__PURE__*/react.createElement(\"div\",{className:isInFocus},explore/* COMMUNITY */.GN.IS_FOCUS),/*#__PURE__*/react.createElement(\"div\",{className:communityOfFocus},/*#__PURE__*/react.createElement(components_TractPrioritization,{scoreNCommunities:properties[constants/* SCORE_N_COMMUNITIES */.ylX]===true?properties[constants/* SCORE_N_COMMUNITIES */.ylX]:false,tribalCountAK:properties[constants/* TRIBAL_AREAS_COUNT_AK */.$RP]>=1?properties[constants/* TRIBAL_AREAS_COUNT_AK */.$RP]:null,tribalCountUS:properties[constants/* TRIBAL_AREAS_COUNT_CONUS */.drv]>=1?properties[constants/* TRIBAL_AREAS_COUNT_CONUS */.drv]:null,percentTractTribal:percentTractTribal})),/*#__PURE__*/react.createElement(\"div\",{className:prioCopy},/*#__PURE__*/react.createElement(components_PrioritizationCopy,{totalCategoriesPrioritized:properties[constants/* COUNT_OF_CATEGORIES_DISADV */.xLj],totalBurdensPrioritized:properties[constants/* TOTAL_NUMBER_OF_DISADVANTAGE_INDICATORS */.SfK],isAdjacencyThreshMet:properties[constants/* ADJACENCY_EXCEEDS_THRESH */.axb],isAdjacencyLowIncome:properties[constants/* ADJACENCY_LOW_INCOME_EXCEEDS_THRESH */.PAj],isIslandLowIncome:properties[constants/* IS_FEDERAL_POVERTY_LEVEL_200 */.pyQ]&&constants/* TILES_ISLAND_AREA_FIPS_CODES */.STP.some(code=>{return properties[constants/* GEOID_PROPERTY */.TnO].startsWith(code);}),tribalCountAK:properties[constants/* TRIBAL_AREAS_COUNT_AK */.$RP]>=1?properties[constants/* TRIBAL_AREAS_COUNT_AK */.$RP]:null,tribalCountUS:properties[constants/* TRIBAL_AREAS_COUNT_CONUS */.drv]>=1?properties[constants/* TRIBAL_AREAS_COUNT_CONUS */.drv]:null,percentTractTribal:percentTractTribal,isGrandfathered:properties[constants/* IS_GRANDFATHERED */.fgy]}),/*#__PURE__*/react.createElement(components_PrioritizationCopy2,{totalCategoriesPrioritized:properties[constants/* COUNT_OF_CATEGORIES_DISADV */.xLj],isAdjacencyThreshMet:properties[constants/* ADJACENCY_EXCEEDS_THRESH */.axb],isAdjacencyLowIncome:properties[constants/* ADJACENCY_LOW_INCOME_EXCEEDS_THRESH */.PAj],tribalCountAK:properties[constants/* TRIBAL_AREAS_COUNT_AK */.$RP]>=1?properties[constants/* TRIBAL_AREAS_COUNT_AK */.$RP]:null,tribalCountUS:properties[constants/* TRIBAL_AREAS_COUNT_CONUS */.drv]>=1?properties[constants/* TRIBAL_AREAS_COUNT_CONUS */.drv]:null,percentTractTribal:percentTractTribal}))),showIslandCopy&&/*#__PURE__*/react.createElement(IslandCopy_IslandCopy,{povertyPercentile:poveryPercentile}),showDonutCopy&&/*#__PURE__*/react.createElement(components_DonutCopy,{isAdjacent:properties[constants/* ADJACENCY_EXCEEDS_THRESH */.axb],povertyBelow200Percentile:poveryPercentile}),/*#__PURE__*/react.createElement(\"a\",{className:sendFeedbackLink,href:intl.locale===`es`?`${constants/* CENSUS_TRACT_SURVEY_LINKS */.GGW.ES}?tractid=${blockGroup}`:`${constants/* CENSUS_TRACT_SURVEY_LINKS */.GGW.EN}?tractid=${blockGroup}`,target:\"_blank\",rel:\"noreferrer\"},/*#__PURE__*/react.createElement(lib.Button,{type:\"button\",className:sendFeedbackBtn},/*#__PURE__*/react.createElement(\"div\",{className:buttonContainer},/*#__PURE__*/react.createElement(\"div\",{className:buttonText},explore/* COMMUNITY */.GN.SEND_FEEDBACK.TITLE),/*#__PURE__*/react.createElement(lib.Icon.Launch,{\"aria-label\":intl.formatMessage(explore/* COMMUNITY */.GN.SEND_FEEDBACK.IMG_ICON.ALT_TAG)})))),/*#__PURE__*/react.createElement(lib.Accordion,{multiselectable:true,items:categoryItems,className:\"-AreaDetail\"}),/*#__PURE__*/react.createElement(\"div\",{className:versionInfo},explore/* SIDE_PANEL_VERSION */.Co.TITLE));};/* harmony default export */ var AreaDetail_AreaDetail = (AreaDetail);\n;// ./src/components/AreaDetail/index.tsx\n/* harmony default export */ var components_AreaDetail = (AreaDetail_AreaDetail);\n;// ./node_modules/uswds/dist/img/usa-icons/add.svg\n/* harmony default export */ var usa_icons_add = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE5IDEzaC02djZoLTJ2LTZINXYtMmg2VjVoMnY2aDZ2MnoiLz48L3N2Zz4=\");\n;// ./node_modules/uswds/dist/img/usa-icons/search.svg\n/* harmony default export */ var search = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE1LjUgMTRoLS43OWwtLjI4LS4yN0MxNS40MSAxMi41OSAxNiAxMS4xMSAxNiA5LjUgMTYgNS45MSAxMy4wOSAzIDkuNSAzUzMgNS45MSAzIDkuNSA1LjkxIDE2IDkuNSAxNmMxLjYxIDAgMy4wOS0uNTkgNC4yMy0xLjU3bC4yNy4yOHYuNzlsNSA0Ljk5TDIwLjQ5IDE5bC00Ljk5LTV6bS02IDBDNy4wMSAxNCA1IDExLjk5IDUgOS41UzcuMDEgNSA5LjUgNSAxNCA3LjAxIDE0IDkuNSAxMS45OSAxNCA5LjUgMTR6Ii8+PC9zdmc+\");\n;// ./node_modules/uswds/dist/img/usa-icons/my_location.svg\n/* harmony default export */ var my_location = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTEyIDhjLTIuMjEgMC00IDEuNzktNCA0czEuNzkgNCA0IDQgNC0xLjc5IDQtNC0xLjc5LTQtNC00em04Ljk0IDNjLS40Ni00LjE3LTMuNzctNy40OC03Ljk0LTcuOTRWMWgtMnYyLjA2QzYuODMgMy41MiAzLjUyIDYuODMgMy4wNiAxMUgxdjJoMi4wNmMuNDYgNC4xNyAzLjc3IDcuNDggNy45NCA3Ljk0VjIzaDJ2LTIuMDZjNC4xNy0uNDYgNy40OC0zLjc3IDcuOTQtNy45NEgyM3YtMmgtMi4wNnpNMTIgMTljLTMuODcgMC03LTMuMTMtNy03czMuMTMtNyA3LTcgNyAzLjEzIDcgNy0zLjEzIDctNyA3eiIvPjwvc3ZnPg==\");\n;// ./node_modules/uswds/dist/img/usa-icons/people.svg\n/* harmony default export */ var people = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE2IDExYzEuNjYgMCAyLjk5LTEuMzQgMi45OS0zUzE3LjY2IDUgMTYgNWMtMS42NiAwLTMgMS4zNC0zIDNzMS4zNCAzIDMgM3ptLTggMGMxLjY2IDAgMi45OS0xLjM0IDIuOTktM1M5LjY2IDUgOCA1QzYuMzQgNSA1IDYuMzQgNSA4czEuMzQgMyAzIDN6bTAgMmMtMi4zMyAwLTcgMS4xNy03IDMuNVYxOWgxNHYtMi41YzAtMi4zMy00LjY3LTMuNS03LTMuNXptOCAwYy0uMjkgMC0uNjIuMDItLjk3LjA1IDEuMTYuODQgMS45NyAxLjk3IDEuOTcgMy40NVYxOWg2di0yLjVjMC0yLjMzLTQuNjctMy41LTctMy41eiIvPjwvc3ZnPg==\");\n;// ./node_modules/uswds/dist/img/usa-icons/file_upload.svg\n/* harmony default export */ var file_upload = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTkgMTZoNnYtNmg0bC03LTctNyA3aDR6bS00IDJoMTR2Mkg1eiIvPjwvc3ZnPg==\");\n;// ./node_modules/uswds/dist/img/usa-icons/check.svg\n/* harmony default export */ var usa_icons_check = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTkgMTYuMTdMNC44MyAxMmwtMS40MiAxLjQxTDkgMTkgMjEgN2wtMS40MS0xLjQxeiIvPjwvc3ZnPg==\");\n;// ./src/images/sidePanelIcons/puzzle.svg\n/* harmony default export */ var puzzle = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMzkuODcgMTQyLjc0Ij48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2ZmZjt9LmNscy0ye2ZpbGw6IzIzMWYyMDt9LmNscy0ze2ZpbGw6I2JjYmVjYTt9LmNscy00e2ZpbGw6IzBjMzU1Njt9PC9zdHlsZT48L2RlZnM+PGcgaWQ9IkxheWVyXzIiIGRhdGEtbmFtZT0iTGF5ZXIgMiI+PGcgaWQ9IkxheWVyXzEtMiIgZGF0YS1uYW1lPSJMYXllciAxIj48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0xMDkuMDksODguMjVoLTIuMjhsLTMyLjIxLjg0Yy0yLjE0LjA2LTMsLjg1LTMsMi45djQ3LjQ2YzAsMiwxLDIuOTQsMywyLjkzcTMxLjItLjEsNjIuMzgtLjI2YzIuMDYsMCwyLjg5LS44NiwyLjg5LTIuOTRWNzUuODVjMC0yLjEzLS44OC0zLTMtM0gxMTIuMDljLTIuMTgsMC0zLC44NC0zLDNaTTQ3LjE2LDI4Ljg3VjMuMTVjMC0yLjMyLS43Ny0zLjEzLTMtMy4xM0gzQzEsMCwuMDUuODYuMDYsMi43OVEuMTcsMzQsLjMxLDY1LjI5YzAsMi4xMS43OSwyLjgxLDMsMi44Nkg2Ny4wOWMyLjU1LDAsMy4yOS0uNjEsMy4zLTIuODJWMzEuNjdjMC0yLS44My0yLjc4LTIuODUtMi43OEg0Ny4xNlptNS4xNC0yNGg4Mi41MXY2M2g0Ljc1VjMuMzFjMC0yLjU4LS43My0zLjI5LTMuMzYtMy4yOUg1Mi4zWm0tNDcuMTYsMTMzdi02NkguMzV2NjcuM2MwLDIuODcuNzEsMy41NywzLjYsMy41N0g2Ni42MVYxMzhaIi8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMzkuNDQsNS4wNnYtNUgxMzYuMmMyLjYzLDAsMy4zNi43NCwzLjM2LDMuNDFWODMuNzJoLTQuNzVWNS4wNloiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik01LjE0LDEzNy45SDc2LjI1djQuNzlINGMtMi44OSwwLTMuNi0uNy0zLjYtMy41N1Y2NS40Mkg1LjE0WiIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTc2LjU0LDkzLjg5Yy42MywwLDEuMTUtLjA5LDEuNjctLjFsMzEuOTEtLjcxYzIuNDQsMCwyLjIyLS43NywyLjMzLTMuMjguMTQtMy40OS4yLTcsLjMtMTAuNDcsMC0uNTMsMS4xLTEsMS4xNS0xLjYzaDIxdjYwSDc2LjU0WiIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTY1LjUxLDMzLjY3VjYzLjQxSDYuNjZjLTEuNDcsMC0xLjc4LS41LTEuNzgtMS44NFY1LjQ4QTIuMTIsMi4xMiwwLDAsMSw1LDQuODlINDIuNDFWMzAuNDVjMCwyLjM4Ljc5LDMuMTgsMy4xNCwzLjE4aDIwWiIvPjxwYXRoIGNsYXNzPSJjbHMtNCIgZD0iTTEwOC45MSw4OC4zMlY3NS44M2MwLTIuMTUuODYtMywzLTNoMjQuNThjMi4xNCwwLDMsLjg4LDMsM3Y2My42MmMwLDIuMDktLjgyLDMtMi44OCwzcS0zMSwuMTUtNjIuMDkuMjVjLTIsMC0zLS45MS0zLTIuOTRWOTIuMDljMC0yLjA3LjgyLTIuODUsMy0yLjkxQzg1LjI3LDg4Ljg3LDEwNy44LDg4LjMyLDEwOC45MSw4OC4zMlptLTMyLjQsNS41OXY0My44aDU4LjE0di02MEgxMTMuNzFjMCwuNTgtLjEzLDEuMTEtLjE1LDEuNjMtLjEsMy40OS0uMTYsNy0uMywxMC40Ni0uMSwyLjUyLS44OCwzLjIzLTMuMzEsMy4yOWwtMzEuNzYuNy0xLjY4LjEyWiIvPjxwYXRoIGNsYXNzPSJjbHMtNCIgZD0iTTQ3LjE2LDI4Ljg3SDY3LjVjMiwwLDIuODQuNzgsMi44NSwyLjc4VjY1LjMxYzAsMi4yMS0uNzUsMi44Mi0zLjMsMi44MkgzLjI1Yy0yLjE2LDAtMi45NC0uNzUtMy0yLjg2US4xLDM0LDAsMi43N0MwLC44NC45MSwwLDIuOSwwSDQ0LjFjMi4yNSwwLDMsLjgxLDMsMy4xM1YyNi44NVptMTguMzUsNC44aC0yMGMtMi4zNSwwLTMuMTQtLjgtMy4xNC0zLjE4VjQuOTNINC45MWMwLC4yOC0uMDcuNDQtLjA3LjU5VjYxLjYxYzAsMS4zNC4zMSwxLjg0LDEuNzgsMS44NHEyOC42MS0uMDgsNTcuMjIsMGgxLjYzWiIvPjwvZz48L2c+PC9zdmc+\");\n;// ./src/images/sidePanelIcons/bell-curve.svg\n/* harmony default export */ var bell_curve = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxODcuODcgMTI5LjgiPjxkZWZzPjxzdHlsZT4uY2xzLTF7ZmlsbDojZmZmO308L3N0eWxlPjwvZGVmcz48ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIj48ZyBpZD0iTGF5ZXJfMS0yIiBkYXRhLW5hbWU9IkxheWVyIDEiPjxnIGlkPSJYTVBwMkoudGlmIj48cGF0aCBkPSJNMjAuODYsMTI1LjNhNC4xMSw0LjExLDAsMCwwLDMuNzUtMS44MSwxMzIuNiwxMzIuNiwwLDAsMCwyNC00OS42NEM1MS4xOCw2My41NSw1Myw1My4wNyw1NS4yNSw0Mi43YzItOS4yMiw0LjYtMTguMjgsMTAuNjQtMjUuNzlDNzQuMTksNi42LDg0LjY5LS4xNCw5OC4zLDBjMTYuMzYuMTgsMjguMTYsOC4zOSwzNS44MiwyMi41OCw0LjEzLDcuNjQsNS40MywxNi4xNiw2LjQ4LDI0LjY2LDIsMTUuOSwzLjY2LDMxLjg0LDkuNDEsNDdBMTI2LjE2LDEyNi4xNiwwLDAsMCwxNjYsMTIzLjQ2YTQsNCwwLDAsMCwzLjcxLDEuODZNMzUuMjMsMTI1LjFoMTIwLjVjLS4zMi0uNTgtLjQ4LS45NC0uNy0xLjI2YTEyNC42NiwxMjQuNjYsMCwwLDEtMTkuOS00OS41M2MtMS43OS0xMC40Ny0yLjkxLTIxLTQuNTEtMzEuNTUtMS4wNS02LjkzLTIuNzgtMTMuNjYtNi43NC0xOS42MkMxMTYuOTMsMTIuNywxMDMuNzksNyw5Mi4zLDkuOTRjLTExLjI1LDIuOS0xOS4xMiwxMC0yMy43LDIwLjY5QzY0LjYsNDAsNjMuMTksNTAuMSw2MS4zMSw2MCw1OCw3Ny42Nyw1Myw5NC43NCw0NC4xNywxMTAuNDgsNDEuMzcsMTE1LjM5LDM4LjIzLDEyMC4xLDM1LjIzLDEyNS4xWiIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTM1LjIzLDEyNS4xYzMuMDctNSw2LjE4LTkuNzEsOC45NC0xNC42MkM1Myw5NC43NCw1Ny45NCw3Ny42Nyw2MS4yMyw2MGMxLjg4LTkuOTQsMy4yNS0yMCw3LjI5LTI5LjQxQzczLjEsMjAsODEsMTIuODQsOTIuMjIsOS45NGMxMS40OS0zLDI0LjYzLDIuNzYsMzEuNTgsMTMuMiw0LDYsNS42OSwxMi42OSw2Ljc0LDE5LjYyLDEuNiwxMC41LDIuNzIsMjEuMDgsNC41MSwzMS41NUExMjQuNjYsMTI0LjY2LDAsMCwwLDE1NSwxMjMuODRjLjIyLjMyLjM4LjY4LjcsMS4yNloiLz48L2c+PHJlY3QgeT0iMTIwLjgiIHdpZHRoPSIxODcuODciIGhlaWdodD0iOSIvPjwvZz48L2c+PC9zdmc+\");\n// EXTERNAL MODULE: ./src/images/sidePanelIcons/census-tract.svg\nvar census_tract = __webpack_require__(6455);\n;// ./src/images/sidePanelIcons/pie-chart.svg\n/* harmony default export */ var pie_chart = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTcuMDMgMTU2LjkyIj48ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIj48ZyBpZD0iTGF5ZXJfMS0yIiBkYXRhLW5hbWU9IkxheWVyIDEiPjxwYXRoIGQ9Ik05NC40MSwxMjYuODVoLS45NGwtMy40NCwwVjc5YzAtNS45NC0zLjM2LTEwLjMxLTktMTEuNjlhMTguNCwxOC40LDAsMCwwLTQtLjM1SDM1Ljg5TDMwLjIsNjdsLS4wOC0zLjRDMjkuNDIsMzQuNTIsNTIuMjYsMiw5MC4zNi4wOWE2My4zOSw2My4zOSwwLDAsMSw2Ni41OSw2MCw2NCw2NCwwLDAsMSwwLDcuMDYsNjMuMjYsNjMuMjYsMCwwLDEtNjIuNTEsNTkuNzJaTTc3LjU3LDYwYTI0LjY5LDI0LjY5LDAsMCwxLDUsLjUxbC4xMSwwQzkxLjUxLDYyLjY0LDk3LDY5LjczLDk3LDc5djQwLjc4YTU2LjMyLDU2LjMyLDAsMCwwLDUyLjktNTMuMDcsNTcuMzgsNTcuMzgsMCwwLDAsMC02LjI5QTU2LjM4LDU2LjM4LDAsMCwwLDkwLjcyLDcuMDhDNTguMyw4LjcxLDM4LjMxLDM1LjE1LDM3LjE2LDYwSDc3LjU3WiIvPjxwYXRoIGQ9Ik02OCwxNTYuOTJoMEE2OC4yOSw2OC4yOSwwLDAsMSwxLjUyLDEwMi41LDgzLjI0LDgzLjI0LDAsMCwxLC4zNCw5Mi45Qy4yNSw5MS44LjE2LDkwLjY5LjA2LDg5LjZhOC41Miw4LjUyLDAsMCwxLDIuMTMtNi43OEE5LjI5LDkuMjksMCwwLDEsOS40MSw4MGMyLjc0LjA2LDUuNTQsMCw4LjI0LDBsNC4yLDBINjcuNjNjNC4wOSwwLDYuOTIsMS41NSw4LjM5LDQuNjJBMTAuNDksMTAuNDksMCwwLDEsNzcsODl2MTAuN2MwLDIuMTYsMCw0LjU1LDAsOC44OHYzOS4zN2E4LjQ0LDguNDQsMCwwLDEtOSw5Wm0tNTguNzgtNzBhMi40OCwyLjQ4LDAsMCwwLTEuODQuNjFBMS42MywxLjYzLDAsMCwwLDcsODguODhjLjExLDEuMTcuMjEsMi4zMS4zLDMuNDVhNzQuNDIsNzQuNDIsMCwwLDAsMS4wNiw4Ljc2QTYxLjYsNjEuNiwwLDAsMCw2OCwxNDkuOTJhMi40LDIuNCwwLDAsMCwxLjYzLS40LDIuNDMsMi40MywwLDAsMCwuNC0xLjZWMTA4LjU1YzAtNC4zMywwLTYuNzMsMC04Ljg5Vjg5YTMuMzEsMy4zMSwwLDAsMC0uMzItMS40MmMtLjExLS4yMy0uMjktLjYxLTIuMDYtLjYxSDE3LjdjLTIuNzUsMC01LjYsMC04LjQzLDBaIi8+PC9nPjwvZz48L3N2Zz4=\");\n;// ./src/components/SidePanelInfo/SidePanelInfo.module.scss\n// extracted by mini-css-extract-plugin\nvar sidePanelInfoContainer = \"SidePanelInfo-module--sidePanelInfoContainer--z0WO6\";\nvar sidePanelInfoHeading = \"SidePanelInfo-module--sidePanelInfoHeading--IqyD0\";\nvar sidePanelInfoIcon = \"SidePanelInfo-module--sidePanelInfoIcon--FvRrL\";\nvar sidePanelInfoTitle = \"SidePanelInfo-module--sidePanelInfoTitle--RozdZ\";\n;// ./src/components/SidePanelInfo/SidePanelInfo.tsx\n// @ts-ignore\n// @ts-ignore\n// @ts-ignore\n// @ts-ignore\n// @ts-ignore\n// @ts-ignore\n// @ts-ignore\n// @ts-ignore\n// @ts-ignore\n// @ts-ignore\n// import tribalDotIcon from '../../images/sidePanelIcons/tribal-tract.svg';\n// @ts-ignore\n// @ts-ignore\n// import handPointIcon from '../../images/sidePanelIcons/mouse-hand-point.svg';\nconst SidePanelInfo=()=>{const intl=(0,gatsby_plugin_intl.useIntl)();const{width:windowWidth}=(0,useWindowSize/* default */.A)();return/*#__PURE__*/react.createElement(\"aside\",{className:sidePanelInfoContainer},/*#__PURE__*/react.createElement(\"header\",{tabIndex:0,className:sidePanelInfoTitle},intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.HEADING1)),/*#__PURE__*/react.createElement(\"p\",{tabIndex:0},intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA1_PART1),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:usa_icons_add,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.PLUS)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA1_PART2),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:search,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.SEARCH)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA1_PART3),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:my_location,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.LOCATE)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA1_PART4),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA1_PART5)),/*#__PURE__*/react.createElement(\"p\",{tabIndex:0,className:sidePanelInfoHeading},intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.HEADING2)),/*#__PURE__*/react.createElement(\"p\",{tabIndex:0},intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA2_PART1),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:puzzle,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.TRACT)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA2_PART2),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:people,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.PEOPLE)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA2_PART3)),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(\"p\",{tabIndex:0},intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA3_PART1),/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:census_tract/* default */.A,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.DAC_CIRCLE)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA3_PART2)),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(\"p\",{tabIndex:0},intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA4_PART1),/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:bell_curve,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.BELL_CURVE)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA4_PART2)),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(\"p\",{tabIndex:0},intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA5_PART1),/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:file_upload,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.FILE_UP)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA5_PART2),/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:pie_chart,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.PIE_CHART)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA5_PART3),/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:usa_icons_check,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.CHECK)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA5_PART4)),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(\"p\",{tabIndex:0},intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA6_PART1),/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,className:sidePanelInfoIcon,src:census_tract/* default */.A,alt:intl.formatMessage(explore/* SIDE_PANEL_INIT_STATE_ICON_ALT_TEXT */.Kz.DAC_CIRCLE)}),intl.formatMessage(explore/* SIDE_PANEL_INITIAL_STATE */.aV.PARA6_PART2)));};/* harmony default export */ var SidePanelInfo_SidePanelInfo = (SidePanelInfo);\n;// ./src/components/SidePanelInfo/index.tsx\n/* harmony default export */ var components_SidePanelInfo = (SidePanelInfo_SidePanelInfo);\n;// ./src/components/mapInfoPanel.tsx\nconst MapInfoPanel=_ref=>{let{className,featureProperties,hash}=_ref;return/*#__PURE__*/react.createElement(\"div\",{className:className},featureProperties?/*#__PURE__*/react.createElement(components_AreaDetail,{properties:featureProperties,hash:hash}):/*#__PURE__*/react.createElement(components_SidePanelInfo,null));};/* harmony default export */ var mapInfoPanel = (MapInfoPanel);\n;// ./node_modules/js-search/dist/esm/js-search.js\n/**\n * Indexes for all substring searches (e.g. the term \"cat\" is indexed as \"c\", \"ca\", \"cat\", \"a\", \"at\", and \"t\").\n */\nvar AllSubstringsIndexStrategy = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  function AllSubstringsIndexStrategy() {}\n  var _proto = AllSubstringsIndexStrategy.prototype;\n\n  /**\n   * @inheritDocs\n   */\n  _proto.expandToken = function expandToken(token) {\n    var expandedTokens = [];\n    var string;\n    for (var i = 0, length = token.length; i < length; ++i) {\n      string = '';\n      for (var j = i; j < length; ++j) {\n        string += token.charAt(j);\n        expandedTokens.push(string);\n      }\n    }\n    return expandedTokens;\n  };\n  return AllSubstringsIndexStrategy;\n}()));\n\n/**\n * Indexes for exact word matches.\n */\nvar ExactWordIndexStrategy = /*#__PURE__*/function () {\n  function ExactWordIndexStrategy() {}\n  var _proto = ExactWordIndexStrategy.prototype;\n\n  /**\n   * @inheritDocs\n   */\n  _proto.expandToken = function expandToken(token) {\n    return token ? [token] : [];\n  };\n  return ExactWordIndexStrategy;\n}();\n\n/**\n * Indexes for prefix searches (e.g. the term \"cat\" is indexed as \"c\", \"ca\", and \"cat\" allowing prefix search lookups).\n */\nvar PrefixIndexStrategy = /*#__PURE__*/function () {\n  function PrefixIndexStrategy() {}\n  var _proto = PrefixIndexStrategy.prototype;\n\n  /**\n   * @inheritDocs\n   */\n  _proto.expandToken = function expandToken(token) {\n    var expandedTokens = [];\n    var string = '';\n    for (var i = 0, length = token.length; i < length; ++i) {\n      string += token.charAt(i);\n      expandedTokens.push(string);\n    }\n    return expandedTokens;\n  };\n  return PrefixIndexStrategy;\n}();\n\n/**\n * Enforces case-sensitive text matches.\n */\nvar CaseSensitiveSanitizer = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  function CaseSensitiveSanitizer() {}\n  var _proto = CaseSensitiveSanitizer.prototype;\n\n  /**\n   * @inheritDocs\n   */\n  _proto.sanitize = function sanitize(text) {\n    return text ? text.trim() : '';\n  };\n  return CaseSensitiveSanitizer;\n}()));\n\n/**\n * Sanitizes text by converting to a locale-friendly lower-case version and triming leading and trailing whitespace.\n */\nvar LowerCaseSanitizer = /*#__PURE__*/function () {\n  function LowerCaseSanitizer() {}\n  var _proto = LowerCaseSanitizer.prototype;\n\n  /**\n   * @inheritDocs\n   */\n  _proto.sanitize = function sanitize(text) {\n    return text ? text.toLocaleLowerCase().trim() : '';\n  };\n  return LowerCaseSanitizer;\n}();\n\n/**\n * Find and return a nested object value.\n *\n * @param object to crawl\n * @param path Property path\n * @returns {any}\n */\nfunction getNestedFieldValue(object, path) {\n  path = path || [];\n  object = object || {};\n  var value = object; // walk down the property path\n\n  for (var i = 0; i < path.length; i++) {\n    value = value[path[i]];\n    if (value == null) {\n      return null;\n    }\n  }\n  return value;\n}\n\n/**\n * Search index capable of returning results matching a set of tokens and ranked according to TF-IDF.\n */\nvar TfIdfSearchIndex = /*#__PURE__*/function () {\n  function TfIdfSearchIndex(uidFieldName) {\n    this._uidFieldName = uidFieldName;\n    this._tokenToIdfCache = {};\n    this._tokenMap = {};\n  }\n  /**\n   * @inheritDocs\n   */\n\n  var _proto = TfIdfSearchIndex.prototype;\n  _proto.indexDocument = function indexDocument(token, uid, doc) {\n    this._tokenToIdfCache = {}; // New index invalidates previous IDF caches\n\n    var tokenMap = this._tokenMap;\n    var tokenDatum;\n    if (typeof tokenMap[token] !== 'object') {\n      tokenMap[token] = tokenDatum = {\n        $numDocumentOccurrences: 0,\n        $totalNumOccurrences: 1,\n        $uidMap: {}\n      };\n    } else {\n      tokenDatum = tokenMap[token];\n      tokenDatum.$totalNumOccurrences++;\n    }\n    var uidMap = tokenDatum.$uidMap;\n    if (typeof uidMap[uid] !== 'object') {\n      tokenDatum.$numDocumentOccurrences++;\n      uidMap[uid] = {\n        $document: doc,\n        $numTokenOccurrences: 1\n      };\n    } else {\n      uidMap[uid].$numTokenOccurrences++;\n    }\n  }\n  /**\n   * @inheritDocs\n   */;\n  _proto.search = function search(tokens, corpus) {\n    var uidToDocumentMap = {};\n    for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n      var token = tokens[i];\n      var tokenMetadata = this._tokenMap[token]; // Short circuit if no matches were found for any given token.\n\n      if (!tokenMetadata) {\n        return [];\n      }\n      if (i === 0) {\n        var keys = Object.keys(tokenMetadata.$uidMap);\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n          uidToDocumentMap[uid] = tokenMetadata.$uidMap[uid].$document;\n        }\n      } else {\n        var keys = Object.keys(uidToDocumentMap);\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n          if (typeof tokenMetadata.$uidMap[uid] !== 'object') {\n            delete uidToDocumentMap[uid];\n          }\n        }\n      }\n    }\n    var documents = [];\n    for (var uid in uidToDocumentMap) {\n      documents.push(uidToDocumentMap[uid]);\n    }\n    var calculateTfIdf = this._createCalculateTfIdf(); // Return documents sorted by TF-IDF\n\n    return documents.sort(function (documentA, documentB) {\n      return calculateTfIdf(tokens, documentB, corpus) - calculateTfIdf(tokens, documentA, corpus);\n    });\n  };\n  _proto._createCalculateIdf = function _createCalculateIdf() {\n    var tokenMap = this._tokenMap;\n    var tokenToIdfCache = this._tokenToIdfCache;\n    return function calculateIdf(token, documents) {\n      if (!tokenToIdfCache[token]) {\n        var numDocumentsWithToken = typeof tokenMap[token] !== 'undefined' ? tokenMap[token].$numDocumentOccurrences : 0;\n        tokenToIdfCache[token] = 1 + Math.log(documents.length / (1 + numDocumentsWithToken));\n      }\n      return tokenToIdfCache[token];\n    };\n  };\n  _proto._createCalculateTfIdf = function _createCalculateTfIdf() {\n    var tokenMap = this._tokenMap;\n    var uidFieldName = this._uidFieldName;\n    var calculateIdf = this._createCalculateIdf();\n    return function calculateTfIdf(tokens, document, documents) {\n      var score = 0;\n      for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n        var token = tokens[i];\n        var inverseDocumentFrequency = calculateIdf(token, documents);\n        if (inverseDocumentFrequency === Infinity) {\n          inverseDocumentFrequency = 0;\n        }\n        var uid;\n        if (uidFieldName instanceof Array) {\n          uid = document && getNestedFieldValue(document, uidFieldName);\n        } else {\n          uid = document && document[uidFieldName];\n        }\n        var termFrequency = typeof tokenMap[token] !== 'undefined' && typeof tokenMap[token].$uidMap[uid] !== 'undefined' ? tokenMap[token].$uidMap[uid].$numTokenOccurrences : 0;\n        score += termFrequency * inverseDocumentFrequency;\n      }\n      return score;\n    };\n  };\n  return TfIdfSearchIndex;\n}();\n\n/**\n * Search index capable of returning results matching a set of tokens but without any meaningful rank or order.\n */\nvar UnorderedSearchIndex = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  function UnorderedSearchIndex() {\n    this._tokenToUidToDocumentMap = {};\n  }\n  /**\n   * @inheritDocs\n   */\n\n  var _proto = UnorderedSearchIndex.prototype;\n  _proto.indexDocument = function indexDocument(token, uid, doc) {\n    if (typeof this._tokenToUidToDocumentMap[token] !== 'object') {\n      this._tokenToUidToDocumentMap[token] = {};\n    }\n    this._tokenToUidToDocumentMap[token][uid] = doc;\n  }\n  /**\n   * @inheritDocs\n   */;\n  _proto.search = function search(tokens, corpus) {\n    var intersectingDocumentMap = {};\n    var tokenToUidToDocumentMap = this._tokenToUidToDocumentMap;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n      var token = tokens[i];\n      var documentMap = tokenToUidToDocumentMap[token]; // Short circuit if no matches were found for any given token.\n\n      if (!documentMap) {\n        return [];\n      }\n      if (i === 0) {\n        var keys = Object.keys(documentMap);\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n          intersectingDocumentMap[uid] = documentMap[uid];\n        }\n      } else {\n        var keys = Object.keys(intersectingDocumentMap);\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n          if (typeof documentMap[uid] !== 'object') {\n            delete intersectingDocumentMap[uid];\n          }\n        }\n      }\n    }\n    var keys = Object.keys(intersectingDocumentMap);\n    var documents = [];\n    for (var i = 0, numKeys = keys.length; i < numKeys; i++) {\n      var uid = keys[i];\n      documents.push(intersectingDocumentMap[uid]);\n    }\n    return documents;\n  };\n  return UnorderedSearchIndex;\n}()));\nvar REGEX = /[^a-z-0-9\\-']+/i;\n/**\n * Simple tokenizer that splits strings on whitespace characters and returns an array of all non-empty substrings.\n */\n\nvar SimpleTokenizer = /*#__PURE__*/function () {\n  function SimpleTokenizer() {}\n  var _proto = SimpleTokenizer.prototype;\n\n  /**\n   * @inheritDocs\n   */\n  _proto.tokenize = function tokenize(text) {\n    return text.split(REGEX).filter(function (text) {\n      return text;\n    } // Filter empty tokens\n    );\n  };\n  return SimpleTokenizer;\n}();\n\n/**\n * Stemming is the process of reducing search tokens to their root (or stem) so that searches for different forms of a\n * word will match. For example \"search\", \"searching\" and \"searched\" are all reduced to the stem \"search\".\n *\n * <p>This stemming tokenizer converts tokens (words) to their stem forms before returning them. It requires an\n * external stemming function to be provided; for this purpose I recommend the NPM 'porter-stemmer' library.\n *\n * <p>For more information see http : //tartarus.org/~martin/PorterStemmer/\n */\nvar StemmingTokenizer = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  /**\n   * Constructor.\n   *\n   * @param stemmingFunction Function capable of accepting a word and returning its stem.\n   * @param decoratedIndexStrategy Index strategy to be run after all stop words have been removed.\n   */\n  function StemmingTokenizer(stemmingFunction, decoratedTokenizer) {\n    this._stemmingFunction = stemmingFunction;\n    this._tokenizer = decoratedTokenizer;\n  }\n  /**\n   * @inheritDocs\n   */\n\n  var _proto = StemmingTokenizer.prototype;\n  _proto.tokenize = function tokenize(text) {\n    return this._tokenizer.tokenize(text).map(this._stemmingFunction);\n  };\n  return StemmingTokenizer;\n}()));\n\n/**\n * Stop words list copied from Lunr JS.\n */\nvar StopWordsMap = {\n  a: true,\n  able: true,\n  about: true,\n  across: true,\n  after: true,\n  all: true,\n  almost: true,\n  also: true,\n  am: true,\n  among: true,\n  an: true,\n  and: true,\n  any: true,\n  are: true,\n  as: true,\n  at: true,\n  be: true,\n  because: true,\n  been: true,\n  but: true,\n  by: true,\n  can: true,\n  cannot: true,\n  could: true,\n  dear: true,\n  did: true,\n  'do': true,\n  does: true,\n  either: true,\n  'else': true,\n  ever: true,\n  every: true,\n  'for': true,\n  from: true,\n  'get': true,\n  got: true,\n  had: true,\n  has: true,\n  have: true,\n  he: true,\n  her: true,\n  hers: true,\n  him: true,\n  his: true,\n  how: true,\n  however: true,\n  i: true,\n  'if': true,\n  'in': true,\n  into: true,\n  is: true,\n  it: true,\n  its: true,\n  just: true,\n  least: true,\n  \"let\": true,\n  like: true,\n  likely: true,\n  may: true,\n  me: true,\n  might: true,\n  most: true,\n  must: true,\n  my: true,\n  neither: true,\n  no: true,\n  nor: true,\n  not: true,\n  of: true,\n  off: true,\n  often: true,\n  on: true,\n  only: true,\n  or: true,\n  other: true,\n  our: true,\n  own: true,\n  rather: true,\n  said: true,\n  say: true,\n  says: true,\n  she: true,\n  should: true,\n  since: true,\n  so: true,\n  some: true,\n  than: true,\n  that: true,\n  the: true,\n  their: true,\n  them: true,\n  then: true,\n  there: true,\n  these: true,\n  they: true,\n  'this': true,\n  tis: true,\n  to: true,\n  too: true,\n  twas: true,\n  us: true,\n  wants: true,\n  was: true,\n  we: true,\n  were: true,\n  what: true,\n  when: true,\n  where: true,\n  which: true,\n  'while': true,\n  who: true,\n  whom: true,\n  why: true,\n  will: true,\n  'with': true,\n  would: true,\n  yet: true,\n  you: true,\n  your: true\n}; // Prevent false positives for inherited properties\n\nStopWordsMap.constructor = false;\nStopWordsMap.hasOwnProperty = false;\nStopWordsMap.isPrototypeOf = false;\nStopWordsMap.propertyIsEnumerable = false;\nStopWordsMap.toLocaleString = false;\nStopWordsMap.toString = false;\nStopWordsMap.valueOf = false;\n\n/**\n * Stop words are very common (e.g. \"a\", \"and\", \"the\") and are often not semantically meaningful in the context of a\n * search. This tokenizer removes stop words from a set of tokens before passing the remaining tokens along for\n * indexing or searching purposes.\n */\n\nvar StopWordsTokenizer = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  /**\n   * Constructor.\n   *\n   * @param decoratedIndexStrategy Index strategy to be run after all stop words have been removed.\n   */\n  function StopWordsTokenizer(decoratedTokenizer) {\n    this._tokenizer = decoratedTokenizer;\n  }\n  /**\n   * @inheritDocs\n   */\n\n  var _proto = StopWordsTokenizer.prototype;\n  _proto.tokenize = function tokenize(text) {\n    return this._tokenizer.tokenize(text).filter(function (token) {\n      return !StopWordsMap[token];\n    });\n  };\n  return StopWordsTokenizer;\n}()));\nfunction js_search_defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction js_search_createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) js_search_defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) js_search_defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * Simple client-side searching within a set of documents.\n *\n * <p>Documents can be searched by any number of fields. Indexing and search strategies are highly customizable.\n */\nvar Search = /*#__PURE__*/function () {\n  /**\n   * Array containing either a property name or a path (list of property names) to a nested value\n   */\n\n  /**\n   * Constructor.\n   * @param uidFieldName Field containing values that uniquely identify search documents; this field's values are used\n   *                     to ensure that a search result set does not contain duplicate objects.\n   */\n  function Search(uidFieldName) {\n    if (!uidFieldName) {\n      throw Error('js-search requires a uid field name constructor parameter');\n    }\n    this._uidFieldName = uidFieldName; // Set default/recommended strategies\n\n    this._indexStrategy = new PrefixIndexStrategy();\n    this._searchIndex = new TfIdfSearchIndex(uidFieldName);\n    this._sanitizer = new LowerCaseSanitizer();\n    this._tokenizer = new SimpleTokenizer();\n    this._documents = [];\n    this._searchableFields = [];\n  }\n  /**\n   * Override the default index strategy.\n   * @param value Custom index strategy\n   * @throws Error if documents have already been indexed by this search instance\n   */\n\n  var _proto = Search.prototype;\n\n  /**\n   * Add a searchable document to the index. Document will automatically be indexed for search.\n   * @param document\n   */\n  _proto.addDocument = function addDocument(document) {\n    this.addDocuments([document]);\n  }\n  /**\n   * Adds searchable documents to the index. Documents will automatically be indexed for search.\n   * @param document\n   */;\n  _proto.addDocuments = function addDocuments(documents) {\n    this._documents = this._documents.concat(documents);\n    this.indexDocuments_(documents, this._searchableFields);\n  }\n  /**\n   * Add a new searchable field to the index. Existing documents will automatically be indexed using this new field.\n   *\n   * @param field Searchable field or field path. Pass a string to index a top-level field and an array of strings for nested fields.\n   */;\n  _proto.addIndex = function addIndex(field) {\n    this._searchableFields.push(field);\n    this.indexDocuments_(this._documents, [field]);\n  }\n  /**\n   * Search all documents for ones matching the specified query text.\n   * @param query\n   * @returns {Array<Object>}\n   */;\n  _proto.search = function search(query) {\n    var tokens = this._tokenizer.tokenize(this._sanitizer.sanitize(query));\n    return this._searchIndex.search(tokens, this._documents);\n  }\n  /**\n   * @param documents\n   * @param _searchableFields Array containing property names and paths (lists of property names) to nested values\n   * @private\n   */;\n  _proto.indexDocuments_ = function indexDocuments_(documents, _searchableFields) {\n    this._initialized = true;\n    var indexStrategy = this._indexStrategy;\n    var sanitizer = this._sanitizer;\n    var searchIndex = this._searchIndex;\n    var tokenizer = this._tokenizer;\n    var uidFieldName = this._uidFieldName;\n    for (var di = 0, numDocuments = documents.length; di < numDocuments; di++) {\n      var doc = documents[di];\n      var uid;\n      if (uidFieldName instanceof Array) {\n        uid = getNestedFieldValue(doc, uidFieldName);\n      } else {\n        uid = doc[uidFieldName];\n      }\n      for (var sfi = 0, numSearchableFields = _searchableFields.length; sfi < numSearchableFields; sfi++) {\n        var fieldValue;\n        var searchableField = _searchableFields[sfi];\n        if (searchableField instanceof Array) {\n          fieldValue = getNestedFieldValue(doc, searchableField);\n        } else {\n          fieldValue = doc[searchableField];\n        }\n        if (fieldValue != null && typeof fieldValue !== 'string' && fieldValue.toString) {\n          fieldValue = fieldValue.toString();\n        }\n        if (typeof fieldValue === 'string') {\n          var fieldTokens = tokenizer.tokenize(sanitizer.sanitize(fieldValue));\n          for (var fti = 0, numFieldValues = fieldTokens.length; fti < numFieldValues; fti++) {\n            var fieldToken = fieldTokens[fti];\n            var expandedTokens = indexStrategy.expandToken(fieldToken);\n            for (var eti = 0, nummExpandedTokens = expandedTokens.length; eti < nummExpandedTokens; eti++) {\n              var expandedToken = expandedTokens[eti];\n              searchIndex.indexDocument(expandedToken, uid, doc);\n            }\n          }\n        }\n      }\n    }\n  };\n  js_search_createClass(Search, [{\n    key: \"indexStrategy\",\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('IIndexStrategy cannot be set after initialization');\n      }\n      this._indexStrategy = value;\n    },\n    get: function get() {\n      return this._indexStrategy;\n    }\n    /**\n     * Override the default text sanitizing strategy.\n     * @param value Custom text sanitizing strategy\n     * @throws Error if documents have already been indexed by this search instance\n     */\n  }, {\n    key: \"sanitizer\",\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('ISanitizer cannot be set after initialization');\n      }\n      this._sanitizer = value;\n    },\n    get: function get() {\n      return this._sanitizer;\n    }\n    /**\n     * Override the default search index strategy.\n     * @param value Custom search index strategy\n     * @throws Error if documents have already been indexed\n     */\n  }, {\n    key: \"searchIndex\",\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('ISearchIndex cannot be set after initialization');\n      }\n      this._searchIndex = value;\n    },\n    get: function get() {\n      return this._searchIndex;\n    }\n    /**\n     * Override the default text tokenizing strategy.\n     * @param value Custom text tokenizing strategy\n     * @throws Error if documents have already been indexed by this search instance\n     */\n  }, {\n    key: \"tokenizer\",\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('ITokenizer cannot be set after initialization');\n      }\n      this._tokenizer = value;\n    },\n    get: function get() {\n      return this._tokenizer;\n    }\n  }]);\n  return Search;\n}();\n\n/**\n * This utility highlights the occurrences of tokens within a string of text. It can be used to give visual indicators\n * of match criteria within searchable fields.\n *\n * <p>For performance purposes this highlighter only works with full-word or prefix token indexes.\n */\nvar TokenHighlighter = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  /**\n   * Constructor.\n   *\n   * @param opt_indexStrategy Index strategy used by Search\n   * @param opt_sanitizer Sanitizer used by Search\n   * @param opt_wrapperTagName Optional wrapper tag name; defaults to 'mark' (e.g. <mark>)\n   */\n  function TokenHighlighter(opt_indexStrategy, opt_sanitizer, opt_wrapperTagName) {\n    this._indexStrategy = opt_indexStrategy || new PrefixIndexStrategy();\n    this._sanitizer = opt_sanitizer || new LowerCaseSanitizer();\n    this._wrapperTagName = opt_wrapperTagName || 'mark';\n  }\n  /**\n   * Highlights token occurrences within a string by wrapping them with a DOM element.\n   *\n   * @param text e.g. \"john wayne\"\n   * @param tokens e.g. [\"wa\"]\n   * @returns {string} e.g. \"john <mark>wa</mark>yne\"\n   */\n\n  var _proto = TokenHighlighter.prototype;\n  _proto.highlight = function highlight(text, tokens) {\n    var tagsLength = this._wrapText('').length;\n    var tokenDictionary = Object.create(null); // Create a token map for easier lookup below.\n\n    for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n      var token = this._sanitizer.sanitize(tokens[i]);\n      var expandedTokens = this._indexStrategy.expandToken(token);\n      for (var j = 0, numExpandedTokens = expandedTokens.length; j < numExpandedTokens; j++) {\n        var expandedToken = expandedTokens[j];\n        if (!tokenDictionary[expandedToken]) {\n          tokenDictionary[expandedToken] = [token];\n        } else {\n          tokenDictionary[expandedToken].push(token);\n        }\n      }\n    } // Track actualCurrentWord and sanitizedCurrentWord separately in case we encounter nested tags.\n\n    var actualCurrentWord = '';\n    var sanitizedCurrentWord = '';\n    var currentWordStartIndex = 0; // Note this assumes either prefix or full word matching.\n\n    for (var i = 0, textLength = text.length; i < textLength; i++) {\n      var character = text.charAt(i);\n      if (character === ' ') {\n        actualCurrentWord = '';\n        sanitizedCurrentWord = '';\n        currentWordStartIndex = i + 1;\n      } else {\n        actualCurrentWord += character;\n        sanitizedCurrentWord += this._sanitizer.sanitize(character);\n      }\n      if (tokenDictionary[sanitizedCurrentWord] && tokenDictionary[sanitizedCurrentWord].indexOf(sanitizedCurrentWord) >= 0) {\n        actualCurrentWord = this._wrapText(actualCurrentWord);\n        text = text.substring(0, currentWordStartIndex) + actualCurrentWord + text.substring(i + 1);\n        i += tagsLength;\n        textLength += tagsLength;\n      }\n    }\n    return text;\n  }\n  /**\n   * @param text to wrap\n   * @returns Text wrapped by wrapper tag (e.g. \"foo\" becomes \"<mark>foo</mark>\")\n   * @private\n   */;\n  _proto._wrapText = function _wrapText(text) {\n    var tagName = this._wrapperTagName;\n    return \"<\" + tagName + \">\" + text + \"</\" + tagName + \">\";\n  };\n  return TokenHighlighter;\n}()));\n\n;// ./src/components/MapSearchMessage/MapSearchMessage.module.scss\n// extracted by mini-css-extract-plugin\nvar hideMessage = \"MapSearchMessage-module--hideMessage--9LOUu\";\nvar showMessage = \"MapSearchMessage-module--showMessage--eatMu\";\n;// ./src/components/MapSearchMessage/MapSearchMessage.tsx\n;const MapSearchMessage=_ref=>{let{isSearchResultsNull}=_ref;const intl=(0,gatsby_plugin_intl.useIntl)();return/*#__PURE__*/react.createElement(\"div\",{className:isSearchResultsNull?showMessage:hideMessage},intl.formatMessage(explore/* MAP */.lC.SEARCH_RESULTS_EMPTY_MESSAGE));};/* harmony default export */ var MapSearchMessage_MapSearchMessage = (MapSearchMessage);\n;// ./src/components/MapSearchMessage/index.tsx\n/* harmony default export */ var components_MapSearchMessage = (MapSearchMessage_MapSearchMessage);\n;// ./src/components/MapSearch/MapSearch.module.scss\n// extracted by mini-css-extract-plugin\n\n;// ./src/components/MapSearch/MapSearch.tsx\n/* eslint-disable max-len */const MapSearch=_ref=>{let{goToPlace}=_ref;// State to hold if the search results are empty or not:\nconst{0:isSearchResultsNull,1:setIsSearchResultsNull}=(0,react.useState)(false);const intl=(0,gatsby_plugin_intl.useIntl)();/**\n   * At compile-time, the width/height returned by useWindowSize will be X. When the client requests the\n   * app on run-time from CDN, and the app hydrates, reconcilation no longer occurs and the client is forced\n   * to use X.\n   *\n   * To avoid this, we set the placeholder text as a state variable. We also create a useEffect that updates\n   * that state whenenver the width changes.\n   *\n   */const{width,height}=(0,useWindowSize/* default */.A)();const{0:placeholderText,1:setPlaceholderText}=(0,react.useState)(explore/* MAP */.lC.SEARCH_PLACEHOLDER);const{0:tractSearch,1:setTractSearch}=(0,react.useState)(null);/**\n   * Gets the tract search data and loads in the state.\n   */const getTractSearchData=async()=>{const searchDataUrl=`${constants/* TILE_BASE_URL */.RST}/${constants/* MAP_TRACT_SEARCH_PATH */.lsl}`;fetch(searchDataUrl).then(response=>{if(response.ok){return response.json();}else{throw new Error(`${response.statusText} error with status code of ${response.status}`);}}).then(data=>{// We use JsSearch to make it easy to load and quick to search.\nconst search=new Search('GEOID10');search.indexStrategy=new ExactWordIndexStrategy();search.addIndex('GEOID10');search.addDocuments(data);setTractSearch(search);}).catch(error=>console.error('Unable to read search tract table:',error));};(0,react.useEffect)(()=>{width>height?setPlaceholderText(explore/* MAP */.lC.SEARCH_PLACEHOLDER):setPlaceholderText(explore/* MAP */.lC.SEARCH_PLACEHOLDER_MOBILE);},[width]);(0,react.useEffect)(()=>{getTractSearchData();},[]);/**\n   * Searchs for a given Census tract ID.\n   * @param {string} tract the 11 digit tract ID as a string\n   */const searchForTract=async tract=>{// We create a bounding box just to get the tract in the view box.\n// The size is not important.\nconst BOUNDING_BOX_SIZE_DD=0.2;// Convert 10 digit tracts to 11.\nconst normalizedTractId=tract.length==10?'0'+tract:tract;setIsSearchResultsNull(true);if(tractSearch){const result=tractSearch.search(normalizedTractId);if(result.length>0){const searchTractRecord=result[0];const lat=Number(searchTractRecord.INTPTLAT10);const lon=Number(searchTractRecord.INTPTLON10);const boundingBox=[(lat-BOUNDING_BOX_SIZE_DD/2).toString(),(lat+BOUNDING_BOX_SIZE_DD/2).toString(),(lon-BOUNDING_BOX_SIZE_DD/2).toString(),(lon+BOUNDING_BOX_SIZE_DD/2).toString()];const[latMin,latMax,longMin,longMax]=boundingBox;setIsSearchResultsNull(false);// Now move the map and select the tract.\ngoToPlace([[Number(longMin),Number(latMin)],[Number(longMax),Number(latMax)]],false,normalizedTractId);}}};/**\n   * Searchs for a given location such as address, zip, etc. This method will\n   * will fetch data from the PSM API and return the results as JSON and\n   * results to US only. If the data is valid, destructure the boundingBox\n   * values from the search results. Finally, is pans the map to the location.\n   * @param {string} searchTerm the location to search for\n   */const searchForLocation=async searchTerm=>{const searchResults=await fetch(`https://nominatim.openstreetmap.org/search?q=${searchTerm}&format=json&countrycodes=us`,{mode:'cors'}).then(response=>{if(!response.ok){throw new Error('Network response was not OK');}return response.json();}).catch(error=>{console.error('There has been a problem with your fetch operation:',error);});console.log('Nominatum search results: ',searchResults);// If results are valid, set isSearchResultsNull to false and pan map to location:\nif(searchResults&&searchResults.length>0){setIsSearchResultsNull(false);const[latMin,latMax,longMin,longMax]=searchResults[0].boundingbox;goToPlace([[Number(longMin),Number(latMin)],[Number(longMax),Number(latMax)]],false,undefined);}else{setIsSearchResultsNull(true);}};/**\n    Searches for a given search term upon clicking on the search button.\n    @param {React.FormEvent<HTMLFormElement>} event the click event\n  */const onSearchHandler=async event=>{event.preventDefault();event.stopPropagation();const searchTerm=event.currentTarget.elements.namedItem('search').value;// If the search term a Census tract\nconst isTract=/^\\d{10,11}$/.test(searchTerm);if(isTract){searchForTract(searchTerm);}else{searchForLocation(searchTerm);}};return/*#__PURE__*/react.createElement(\"div\",{className:MapSearch_module_namespaceObject.mapSearchContainer},/*#__PURE__*/react.createElement(components_MapSearchMessage,{isSearchResultsNull:isSearchResultsNull}),/*#__PURE__*/react.createElement(lib.Search,{placeholder:intl.formatMessage(placeholderText),size:\"small\",onSubmit:e=>onSearchHandler(e)}));};/* harmony default export */ var MapSearch_MapSearch = (MapSearch);\n;// ./src/components/MapSearch/index.tsx\n/* harmony default export */ var components_MapSearch = (MapSearch_MapSearch);\n// EXTERNAL MODULE: ./src/data/copy/common.tsx + 3 modules\nvar common = __webpack_require__(5635);\n;// ./src/components/MapTractLayers/MapTractLayers.tsx\n// Contexts:\n/**\n * This function will determine the URL for the map tiles. It will read in a string that will designate either\n * high or low tiles. It will allow to overide the URL to the pipeline staging tile URL via feature flag.\n * Lastly, it allows to set the tiles to be local or via the CDN as well.\n *\n * @param {string} tilesetName\n * @return {string}\n */const featureURLForTilesetName=tilesetName=>{const flags=(0,FlagContext/* useFlags */.D0)();const pipelineStagingBaseURL=\"https://static-data-screeningtool.geoplatform.gov\"+`/data-pipeline-staging`;const XYZ_SUFFIX='{z}/{x}/{y}.pbf';if('stage_hash'in flags){// Check if the stage_hash is valid\nconst regex=/^[0-9]{4}\\/[a-f0-9]{40}$/;if(!regex.test(flags['stage_hash'])){console.error(common/* CONSOLE_ERROR */.b6.STAGE_URL);}return`${pipelineStagingBaseURL}/${flags['stage_hash']}/data/score/tiles/${tilesetName}/${XYZ_SUFFIX}`;}else{// The feature tile base URL and path can either point locally or the CDN.\n// This is selected based on the DATA_SOURCE env variable.\nconst featureTileBaseURL=constants/* TILE_BASE_URL */.RST;const featureTilePath=constants/* TILE_PATH */.Jau;return[featureTileBaseURL,featureTilePath,\"tiles\",tilesetName,XYZ_SUFFIX].join('/');}};/**\n * This component will return the appropriate source and layers for the census layer on the\n * map.\n *\n * There are two use cases here, eg, when the MapBox token is or isn't provided. When the token\n * is not provided, the open-source map will be rendered. When the open-source map is rendered\n * only the interactive layers are returned from this component. The reason being is that the\n * other layers are supplied by he getOSBaseMap function.\n *\n * @param {string | number} selectedFeatureId\n * @param {MapGeoJSONFeature | undefined} selectedFeature\n * @return {Style}\n */const MapTractLayers=_ref=>{let{selectedFeatures}=_ref;const selectedFeatureIds=selectedFeatures?selectedFeatures.map(feat=>feat.id):[''];const filter=['in',constants/* GEOID_PROPERTY */.TnO].concat((0,toConsumableArray/* default */.A)(selectedFeatureIds));return/*#__PURE__*/react.createElement(react.Fragment,null,/*#__PURE__*/react.createElement(source,{id:constants/* LOW_ZOOM_SOURCE_NAME */.LQt,type:\"vector\",promoteId:constants/* GEOID_PROPERTY */.TnO,tiles:[featureURLForTilesetName('low')],maxzoom:constants/* GLOBAL_MAX_ZOOM_LOW */.Gb5,minzoom:constants/* GLOBAL_MIN_ZOOM_LOW */.gD2},/*#__PURE__*/react.createElement(components_layer,{id:constants/* LOW_ZOOM_LAYER_ID */.v39,\"source-layer\":constants/* SCORE_SOURCE_LAYER */.ZG$,filter:['>',constants/* SCORE_PROPERTY_LOW */.UsB,constants/* SCORE_BOUNDARY_THRESHOLD */.y2s],type:\"fill\",paint:{'fill-color':constants/* PRIORITIZED_FEATURE_FILL_COLOR */.HOT,'fill-opacity':constants/* LOW_ZOOM_PRIORITIZED_FEATURE_FILL_OPACITY */.wAO},maxzoom:constants/* GLOBAL_MAX_ZOOM_LOW */.Gb5,minzoom:constants/* GLOBAL_MIN_ZOOM_LOW */.gD2})),/*#__PURE__*/react.createElement(source,{id:constants/* HIGH_ZOOM_SOURCE_NAME */.NP7,type:\"vector\",promoteId:constants/* GEOID_PROPERTY */.TnO,tiles:[featureURLForTilesetName('high')],maxzoom:constants/* GLOBAL_MAX_ZOOM_HIGH */._yN,minzoom:constants/* GLOBAL_MIN_ZOOM_HIGH */.uDw},/*#__PURE__*/react.createElement(components_layer,{id:constants/* HIGH_ZOOM_LAYER_ID */.jt_,\"source-layer\":constants/* SCORE_SOURCE_LAYER */.ZG$,filter:['==',constants/* SCORE_PROPERTY_HIGH */.YfI,false],type:\"fill\",paint:{'fill-opacity':constants/* NON_PRIORITIZED_FEATURE_FILL_OPACITY */.XP8},minzoom:constants/* GLOBAL_MIN_ZOOM_HIGH */.uDw}),/*#__PURE__*/react.createElement(components_layer,{id:constants/* PRIORITIZED_HIGH_ZOOM_LAYER_ID */.nHu,\"source-layer\":constants/* SCORE_SOURCE_LAYER */.ZG$,filter:['==',constants/* SCORE_PROPERTY_HIGH */.YfI,true],type:\"fill\",paint:{'fill-color':constants/* PRIORITIZED_FEATURE_FILL_COLOR */.HOT,'fill-opacity':constants/* HIGH_ZOOM_PRIORITIZED_FEATURE_FILL_OPACITY */.GrS},minzoom:constants/* GLOBAL_MIN_ZOOM_HIGH */.uDw}),/*#__PURE__*/react.createElement(components_layer,{id:constants/* GRANDFATHERED_HIGH_ZOOM_LAYER_ID */.J1r,\"source-layer\":constants/* SCORE_SOURCE_LAYER */.ZG$,filter:['==',constants/* IS_GRANDFATHERED */.fgy,true],type:\"fill\",paint:{'fill-color':constants/* GRANDFATHERED_FEATURE_FILL_COLOR */.NUZ,'fill-opacity':constants/* HIGH_ZOOM_PRIORITIZED_FEATURE_FILL_OPACITY */.GrS},minzoom:constants/* GLOBAL_MIN_ZOOM_HIGH */.uDw}),/*#__PURE__*/react.createElement(components_layer,{id:constants/* FEATURE_BORDER_LAYER_ID */.ESF,\"source-layer\":constants/* SCORE_SOURCE_LAYER */.ZG$,type:\"line\",paint:{'line-color':constants/* FEATURE_BORDER_COLOR */.IND,'line-width':constants/* FEATURE_BORDER_WIDTH */.n_R,'line-opacity':constants/* FEATURE_BORDER_OPACITY */.IkD},maxzoom:constants/* GLOBAL_MAX_ZOOM_FEATURE_BORDER */.Hvn,minzoom:constants/* GLOBAL_MIN_ZOOM_FEATURE_BORDER */.xvi}),/*#__PURE__*/react.createElement(components_layer,{id:constants/* SELECTED_FEATURE_BORDER_LAYER_ID */.oUX,\"source-layer\":constants/* SCORE_SOURCE_LAYER */.ZG$,filter:filter// This filter filters out all other features except the selected feature.\n,type:\"line\",paint:{'line-color':constants/* SELECTED_FEATURE_BORDER_COLOR */.Ckd,'line-width':constants/* SELECTED_FEATURE_BORDER_WIDTH */.NXr},minzoom:constants/* GLOBAL_MIN_ZOOM_HIGH */.uDw})));};/* harmony default export */ var MapTractLayers_MapTractLayers = (MapTractLayers);\n;// ./src/components/MapTribalLayers/MapTribalLayers.tsx\n/**\n * This function will determine the URL for the tribal tiles.\n * @return {string}\n */const tribalURL=()=>{const featureTileBaseURL=constants/* TILE_BASE_URL */.RST;const featureTilePath=constants/* GATSBY_DATA_PIPELINE_TRIBAL_PATH */.In6;const XYZ_SUFFIX='{z}/{x}/{y}.pbf';return[featureTileBaseURL,featureTilePath,\"tiles\",XYZ_SUFFIX].join('/');};/**\n * This component will return the appropriate source and layers for the tribal layer on the\n * map.\n *\n * There are two use cases here, eg, when the MapBox token is or isn't provided. When the token\n * is not provided, the open-source map will be rendered. When the open-source map is rendered\n * only the interactive layers are returned from this component. The reason being is that the\n * other layers are supplied by he getOSBaseMap function.\n *\n * @param {string | number} selectedFeatureId\n * @param {MapGeoJSONFeature | undefined} selectedFeature\n * @return {Style}\n */const MapTribalLayer=()=>{return(/*#__PURE__*/// In this case the MapBox token is found and ALL source(s)/layer(s) are returned.\nreact.createElement(source,{id:constants/* TRIBAL_SOURCE_NAME */.VFt,type:\"vector\",promoteId:constants/* TRIBAL_ID */.BtP,tiles:[tribalURL()]},/*#__PURE__*/react.createElement(components_layer,{id:constants/* TRIBAL_LAYER_ID */.jL2,\"source-layer\":constants/* TRIBAL_SOURCE_LAYER */.Fa3,type:\"fill\",paint:{'fill-color':constants/* PRIORITIZED_FEATURE_FILL_COLOR */.HOT,'fill-opacity':constants/* TRIBAL_FEATURE_FILL_OPACITY */.gWm},minzoom:constants/* TRIBAL_MIN_ZOOM */.o1R,maxzoom:constants/* TRIBAL_MAX_ZOOM */.IWD}),/*#__PURE__*/react.createElement(components_layer,{id:constants/* FEATURE_BORDER_LAYER_ID */.ESF,\"source-layer\":constants/* TRIBAL_SOURCE_LAYER */.Fa3,type:\"line\",paint:{'line-color':constants/* FEATURE_BORDER_COLOR */.IND,'line-width':constants/* FEATURE_BORDER_WIDTH */.n_R,'line-opacity':constants/* FEATURE_BORDER_OPACITY */.IkD},minzoom:constants/* TRIBAL_MIN_ZOOM */.o1R,maxzoom:constants/* TRIBAL_MAX_ZOOM */.IWD}),/*#__PURE__*/react.createElement(components_layer,{id:constants/* TRIBAL_ALASKA_POINTS_LAYER_ID */.$mQ,\"source-layer\":constants/* TRIBAL_SOURCE_LAYER */.Fa3,filter:['==',['geometry-type'],'Point'],type:\"circle\",paint:{'circle-radius':constants/* TRIBAL_ALASKA_CIRCLE_RADIUS */.Zj6,'circle-color':constants/* TRIBAL_ALASKA_CIRCLE_FILL_COLOR */.Mth,'circle-opacity':constants/* TRIBAL_FEATURE_FILL_OPACITY */.gWm,'circle-stroke-color':constants/* TRIBAL_BORDER_COLOR */.EFx,'circle-stroke-width':constants/* ALAKSA_POINTS_STROKE_WIDTH */.mIl,'circle-stroke-opacity':constants/* FEATURE_BORDER_OPACITY */.IkD},minzoom:constants/* ALASKA_MIN_ZOOM */.DgY,maxzoom:constants/* ALASKA_MAX_ZOOM */.L9E}),/*#__PURE__*/react.createElement(components_layer,{id:constants/* TRIBAL_LABELS_LAYER_ID */.paD,\"source-layer\":constants/* TRIBAL_SOURCE_LAYER */.Fa3,type:\"symbol\",layout:{'text-field':['case',['in',' LAR',['get',constants/* LAND_AREA_NAME */.M2L]],['slice',['get',constants/* LAND_AREA_NAME */.M2L],0,['-',['length',['get',constants/* LAND_AREA_NAME */.M2L]],4]],['in',' IRA',['get',constants/* LAND_AREA_NAME */.M2L]],['slice',['get',constants/* LAND_AREA_NAME */.M2L],0,['-',['length',['get',constants/* LAND_AREA_NAME */.M2L]],4]],['in',' TSA',['get',constants/* LAND_AREA_NAME */.M2L]],['slice',['get',constants/* LAND_AREA_NAME */.M2L],0,['-',['length',['get',constants/* LAND_AREA_NAME */.M2L]],4]],['get',constants/* LAND_AREA_NAME */.M2L]],'text-anchor':'top','text-offset':[0,1],'text-size':12,'text-allow-overlap':false,'text-ignore-placement':false},paint:{'text-color':'#333333','text-halo-color':'#FFFFFF','text-halo-width':1.5},minzoom:constants/* TRIBAL_MIN_ZOOM */.o1R,maxzoom:constants/* TRIBAL_MAX_ZOOM */.IWD})));};/* harmony default export */ var MapTribalLayers = (MapTribalLayer);\n;// ./src/components/territoryFocusControl.module.scss\n// extracted by mini-css-extract-plugin\nvar territoryFocusContainer = \"territoryFocusControl-module--territoryFocusContainer--X5A14\";\n;// ./src/components/territoryFocusControl.tsx\nconst TerritoryFocusControl=_ref=>{let{onClick}=_ref;const intl=(0,gatsby_plugin_intl.useIntl)();const territories=[{short:intl.formatMessage(explore/* MAP */.lC.LOWER48_SHORT),long:intl.formatMessage(explore/* MAP */.lC.LOWER48_LONG)},{short:intl.formatMessage(explore/* MAP */.lC.ALASKA_SHORT),long:intl.formatMessage(explore/* MAP */.lC.ALASKA_LONG)},{short:intl.formatMessage(explore/* MAP */.lC.HAWAII_SHORT),long:intl.formatMessage(explore/* MAP */.lC.HAWAII_LONG)},{short:intl.formatMessage(explore/* MAP */.lC.PR_SHORT),long:intl.formatMessage(explore/* MAP */.lC.PR_LONG)},{short:intl.formatMessage(explore/* MAP */.lC.GU_SHORT),long:intl.formatMessage(explore/* MAP */.lC.GU_LONG)},{short:intl.formatMessage(explore/* MAP */.lC.AS_SHORT),long:intl.formatMessage(explore/* MAP */.lC.AS_LONG)},{short:intl.formatMessage(explore/* MAP */.lC.MP_SHORT),long:intl.formatMessage(explore/* MAP */.lC.MP_LONG)},{short:intl.formatMessage(explore/* MAP */.lC.VI_SHORT),long:intl.formatMessage(explore/* MAP */.lC.VI_LONG)}];// the offset for this array should map the territories variable\nconst territoriesIconClassName=['mapboxgl-ctrl-zoom-to-48','mapboxgl-ctrl-zoom-to-ak','mapboxgl-ctrl-zoom-to-hi','mapboxgl-ctrl-zoom-to-pr','mapboxgl-ctrl-zoom-to-gu','mapboxgl-ctrl-zoom-to-as','mapboxgl-ctrl-zoom-to-mp','mapboxgl-ctrl-zoom-to-vi'];return/*#__PURE__*/react.createElement(\"div\",{className:territoryFocusContainer},/*#__PURE__*/react.createElement(\"div\",{className:'mapboxgl-ctrl mapboxgl-ctrl-group'},territories.map((territory,index)=>/*#__PURE__*/react.createElement(\"button\",{id:territory.short,key:territory.short// onClickCapture={(e) => onClickTerritoryFocusButton(e)}\n,onClickCapture:e=>onClick(e),className:'mapboxgl-ctrl-icon '+territoriesIconClassName[index],title:territories[index].long,\"aria-label\":intl.formatMessage({id:'map.territoryFocus.focusOn',defaultMessage:'Focus on {territory}',description:'Focus on the bounds of a specific territory'},{territory:territory.long})},/*#__PURE__*/react.createElement(\"span\",{className:'mapboxgl-ctrl-icon',\"aria-hidden\":true})))));};/* harmony default export */ var territoryFocusControl = (TerritoryFocusControl);\n;// ./src/components/J40Map.module.scss\n// extracted by mini-css-extract-plugin\nvar fullscreenControl = \"J40Map-module--fullscreenControl--gbYO0\";\nvar geolocateBox = \"J40Map-module--geolocateBox--5HnSE\";\nvar geolocateMessage = \"J40Map-module--geolocateMessage--jD1GP\";\nvar geolocateMessageHide = \"J40Map-module--geolocateMessageHide--MU8Bz\";\nvar j40Map = \"J40Map-module--j40Map--DFr6E\";\nvar j40Popup = \"J40Map-module--j40Popup--KLpXL\";\nvar mapHeaderRow = \"J40Map-module--mapHeaderRow--+ctO-\";\nvar J40Map_module_mapInfoPanel = \"J40Map-module--mapInfoPanel--WdI9e\";\nvar navigationControl = \"J40Map-module--navigationControl--6uUM7\";\n;// ./src/components/CreateReportPanel/CreateReportPanel.module.scss\n// extracted by mini-css-extract-plugin\nvar createReportButton = \"CreateReportPanel-module--createReportButton--+Usds\";\nvar createReportContainer = \"CreateReportPanel-module--createReportContainer--yFj9z\";\nvar startOver = \"CreateReportPanel-module--startOver--9sZuS\";\nvar tractListContainer = \"CreateReportPanel-module--tractListContainer--o2ner\";\nvar tractListItem = \"CreateReportPanel-module--tractListItem--JMCb4\";\nvar tractListItemDelete = \"CreateReportPanel-module--tractListItemDelete--BS88W\";\nvar tractListItemHighlight = \"CreateReportPanel-module--tractListItemHighlight--nxXly\";\n;// ./node_modules/uswds/dist/img/usa-icons/close.svg\n/* harmony default export */ var usa_icons_close = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE5IDYuNDFMMTcuNTkgNSAxMiAxMC41OSA2LjQxIDUgNSA2LjQxIDEwLjU5IDEyIDUgMTcuNTkgNi40MSAxOSAxMiAxMy40MSAxNy41OSAxOSAxOSAxNy41OSAxMy40MSAxMnoiLz48L3N2Zz4=\");\n;// ./src/components/CreateReportPanel/CreateReportPanel.tsx\n// @ts-ignore\nconst CreateReportPanel=_ref=>{let{className,featureList,maxNumTracts,showTooManyTractsAlert,deleteTractHandler,exitHandler}=_ref;const{0:numPrevTracts,1:setNumPrevTracts}=(0,react.useState)(0);(0,react.useEffect)(()=>{// If adding a tract then scroll to the bottom of the tract list to always show the last added tract\nif(numPrevTracts<featureList.length){const container=document.getElementById('j40-create-report-tract-list');if(container)container.scrollTop=container.scrollHeight;}setNumPrevTracts(featureList.length);},[featureList,numPrevTracts]);/**\n   * Handle the creation of a report.\n   */const handleCreateReport=()=>{if(featureList.length===1){// TODO: One tract report\n}else{// TODO: Multi tract report\n}};return/*#__PURE__*/react.createElement(\"div\",{id:\"create-report-panel\",className:className},/*#__PURE__*/react.createElement(\"div\",{className:createReportContainer},/*#__PURE__*/react.createElement(\"h4\",null,\"Create Report\"),showTooManyTractsAlert?/*#__PURE__*/react.createElement(lib.Alert,{type:\"error\",slim:true,headingLevel:\"h4\"},\"You can only select up to \",maxNumTracts,\" tracts for a report.\"):/*#__PURE__*/react.createElement(lib.Alert,{type:\"info\",slim:true,headingLevel:\"h4\"},\"Select \",/*#__PURE__*/react.createElement(\"strong\",null,\"up to \",maxNumTracts),\" tracts in the map\"),/*#__PURE__*/react.createElement(\"p\",null,/*#__PURE__*/react.createElement(\"span\",null,/*#__PURE__*/react.createElement(\"strong\",null,featureList.length,\" tract\",featureList.length===1?'':'s'),\" selected\")),/*#__PURE__*/react.createElement(\"div\",{id:\"j40-create-report-tract-list\",className:tractListContainer},featureList.map((item,index)=>/*#__PURE__*/react.createElement(lib.Grid,{row:true,key:index,className:index===featureList.length-1?tractListItemHighlight:tractListItem},/*#__PURE__*/react.createElement(lib.Grid,{col:\"auto\"},item.id,\", \",item.properties[constants/* STATE_NAME */.sfg]),/*#__PURE__*/react.createElement(lib.Grid,{col:\"fill\"}),/*#__PURE__*/react.createElement(lib.Grid,{col:\"auto\",className:tractListItemDelete},/*#__PURE__*/react.createElement(lib.Button,{type:\"button\",unstyled:true,onClick:()=>deleteTractHandler(item)},/*#__PURE__*/react.createElement(\"img\",{tabIndex:0,src:usa_icons_close,alt:\"Need alt message\"})))))),/*#__PURE__*/react.createElement(\"div\",{className:createReportButton},/*#__PURE__*/react.createElement(lib.Button,{type:\"button\",onClick:handleCreateReport,disabled:featureList.length==0},\"Create Report\")),/*#__PURE__*/react.createElement(\"div\",{className:startOver},/*#__PURE__*/react.createElement(lib.Button,{type:\"button\",unstyled:true,onClick:exitHandler},\"Start Over\"))));};/* harmony default export */ var CreateReportPanel_CreateReportPanel = (CreateReportPanel);\n;// ./src/components/CreateReportPanel/index.tsx\n/* harmony default export */ var components_CreateReportPanel = (CreateReportPanel_CreateReportPanel);\n;// ./src/components/J40Map.tsx\n/* eslint-disable valid-jsdoc *//* eslint-disable no-unused-vars */// External Libs:\n// Contexts:\n// Components:\n// Styles and constants\n;;const MAX_SELECTED_TRACTS=20;const J40Map=_ref=>{var _mapRef$current;let{location}=_ref;/**\n   * Initializes the zoom, and the map's center point (lat, lng) via the URL hash #{z}/{lat}/{long}\n   * where\n   *  @TODO: These values do not update when zooming in/out. Could explain a number of cypress bugs\n   *  reference to ticket #1550\n   *\n   *    z = zoom\n   *    lat = map center's latitude\n   *    long = map center's longitude\n   */const[zoom,lat,lng]=location.hash.slice(1).split('/');/**\n   * If the URL has no #{z}/{lat}/{long} specified in the hash, then set the map's intial viewport state\n   * to use constants. This is so that we can load URLs with certain zoom/lat/long specified:\n   */const{0:viewport,1:setViewport}=(0,react.useState)({latitude:lat&&parseFloat(lat)?parseFloat(lat):constants/* DEFAULT_CENTER */.IiY[0],longitude:lng&&parseFloat(lng)?parseFloat(lng):constants/* DEFAULT_CENTER */.IiY[1],zoom:zoom&&parseFloat(zoom)?parseFloat(zoom):constants/* GLOBAL_MIN_ZOOM */.xaE});const{0:selectedFeatures,1:setSelectedFeatures}=(0,react.useState)([]);const{0:detailViewData,1:setDetailViewData}=(0,react.useState)();const{0:transitionInProgress,1:setTransitionInProgress}=(0,react.useState)(false);const{0:geolocationInProgress,1:setGeolocationInProgress}=(0,react.useState)(false);const{0:isMobileMapState,1:setIsMobileMapState}=(0,react.useState)(false);const{0:inMultiSelectMode,1:setInMultiSelectMode}=(0,react.useState)(false);const{0:showTooManyTractsAlert,1:setShowTooManyTractsAlert}=(0,react.useState)(false);const{0:selectTractId,1:setSelectTractId}=(0,react.useState)(undefined);const{width:windowWidth}=(0,useWindowSize/* default */.A)();/**\n   * Store the geolocation lock state in local storage. The Geolocation component from MapBox does not\n   * expose (API) various geolocation lock/unlock states in the version we are using. This makes it\n   * challenging to change the UI state to match the Geolocation state. A work around is to store the\n   * geolocation \"locked\" state in local storage. The local storage state will then be used to show the\n   * \"Finding location\" message. The local storage will be removed everytime the map is reloaded.\n   *\n   * The \"Finding location\" message only applies for desktop layouts.\n   */// eslint-disable-next-line max-len\nconst[isGeolocateLocked,setIsGeolocateLocked,removeGeolocateLock]=esm_useLocalStorage('is-geolocate-locked',false,{raw:true});const mapRef=(0,react.useRef)(null);const flags=(0,FlagContext/* useFlags */.D0)();const intl=(0,gatsby_plugin_intl.useIntl)();const zoomLatLngHash=(_mapRef$current=mapRef.current)===null||_mapRef$current===void 0?void 0:_mapRef$current.getMap()._hash._getCurrentHash();/**\n   * Get the bounding box for one or more features.\n   * @param featureList the list of features\n   * @returns the bounding box\n   */const getFeaturesBbox=featureList=>{if(featureList.length===0){throw new Error('featureList must be a non-empty array to get a bounding box.');}// Calculate a max and min lat/lon from all the selected features.\nconst minLngList=[];const minLatList=[];const maxLngList=[];const maxLatList=[];featureList.forEach(feature=>{const[featMinLng,featMinLat,featMaxLng,featMaxLat]=es(feature);minLngList.push(featMinLng);minLatList.push(featMinLat);maxLngList.push(featMaxLng);maxLatList.push(featMaxLat);});const minLng=Math.min.apply(Math,minLngList);const minLat=Math.max.apply(Math,minLatList);const maxLng=Math.max.apply(Math,maxLngList);const maxLat=Math.min.apply(Math,maxLatList);return[minLng,minLat,maxLng,maxLat];};/**\n   * Updates the state with the list of selected features. This function will:\n   *   - Add the feature to the list if in multi select and the feature does not already exist\n   *   - Remove the feature from the list if in multi select and the feature does already exist\n   * @param feature the feature to add or remove\n   * @param isMultiSelect true if in multiselect mode\n   * @returns the list of zero or more features\n   */const updateSelectedFeatures=(feature,isMultiSelect)=>{if(!feature)return selectedFeatures;// If the feature is in the list then remove it as it is being deselected\nconst exists=selectedFeatures.some(item=>item.id===feature.id);let featureList=selectedFeatures;if(exists){featureList=selectedFeatures.filter(item=>item.id!==feature.id);setShowTooManyTractsAlert(false);}else if(selectedFeatures.length<MAX_SELECTED_TRACTS){// Add the feature to the list if in multi select, otherwise replace the list\n// with just this one feature.\nfeatureList=isMultiSelect?[].concat((0,toConsumableArray/* default */.A)(selectedFeatures),[feature]):[feature];}else{setShowTooManyTractsAlert(true);}setSelectedFeatures(featureList);if(!inMultiSelectMode){// Turn on multi select mode any time we select more than one tract.\nsetInMultiSelectMode(featureList.length>1);}return featureList;};/**\n   * Selects the provided feature on the map.\n   * @param feature the feature to select\n   * @param isMultiSelectKeyDown true if the multi select key is down\n   */const selectFeaturesOnMap=function(feature,isMultiSelectKeyDown){if(isMultiSelectKeyDown===void 0){isMultiSelectKeyDown=false;}const featuresList=updateSelectedFeatures(feature,isMultiSelectKeyDown||inMultiSelectMode);if(featuresList.length>0){const[minLng,minLat,maxLng,maxLat]=getFeaturesBbox(featuresList);// Go to area of the selected feature(s)\ngoToPlace([[minLng,minLat],[maxLng,maxLat]]);/**\n       * The following logic is used for the popup for the fullscreen feature\n       */// Create a new viewport using the current viewport dimnesions:\nconst newViewPort=new WebMercatorViewport({height:viewport.height,width:viewport.width});// Fit the viewport to the new bounds and return a long, lat and zoom:\nconst{longitude,latitude,zoom}=newViewPort.fitBounds([[minLng,minLat],[maxLng,maxLat]],{padding:40});// Save the popupInfo\nconst popupInfo={longitude:longitude,latitude:latitude,zoom:zoom,properties:feature.properties};// Update the DetailedView state variable with the new popupInfo object:\nsetDetailViewData(popupInfo);/**\n       * End Fullscreen feature specific logic\n       */}};/**\n * This onClick event handler will listen and handle clicks on the map. It will listen for clicks on the\n * territory controls and it will listen to clicks on the map.\n *\n * It will NOT listen to clicks into the search field or the zoom controls. These clickHandlers are\n * captured in their own respective components.\n */const onClick=event=>{var _stopPropagation,_ref2;// Stop all propagation / bubbling / capturing\nevent.preventDefault();(_stopPropagation=(_ref2=event).stopPropagation)===null||_stopPropagation===void 0?void 0:_stopPropagation.call(_ref2);// Check if the click is for territories. Given the territories component's design, it can be\n// guaranteed that each territory control will have an id. We use this ID to determine\n// if the click is coming from a territory control\nif(event.target&&event.target.id){const buttonID=event.target&&event.target.id;switch(buttonID){case'48':goToPlace(constants/* LOWER_48_BOUNDS */.z1R,true);break;case'AK':goToPlace(constants/* ALASKA_BOUNDS */.YnL,true);break;case'HI':goToPlace(constants/* HAWAII_BOUNDS */.snE,true);break;case'PR':goToPlace(constants/* PUERTO_RICO_BOUNDS */.cKu,true);break;case'GU':goToPlace(constants/* GUAM_BOUNDS */.hsW,true);break;case'AS':goToPlace(constants/* AMERICAN_SAMOA_BOUNDS */.Vih,true);break;case'MP':goToPlace(constants/* MARIANA_ISLAND_BOUNDS */.eSo,true);break;case'VI':goToPlace(constants/* US_VIRGIN_ISLANDS_BOUNDS */.qT,true);break;default:break;}}else if(event.target&&event.target.nodeName=='DIV'){// This else clause will fire when the user clicks on the map and will ignore other controls\n// such as the search box and buttons.\n// @ts-ignore\nconst feature=event.features&&event.features[0];// @ts-ignore\nselectFeaturesOnMap(feature,event.srcEvent.ctrlKey);}};const onLoad=()=>{if(typeof window!=='undefined'&&window.Cypress&&mapRef.current){window.underlyingMap=mapRef.current.getMap();}// When map loads remove the geolocate lock boolean in local storage\nremoveGeolocateLock();if(dist_lib/* isMobile */.Fr)setIsMobileMapState(true);};/**\n   * This function will move the map (with easing) to the given lat/long bounds.\n   *\n   * When a user clicks on a tracts vs a territory button, the zoom level returned by the fitBounds\n   * function differ. Given that we want to handle the zoom differently depending on these two cases, we\n   * introduce a boolean, isTerritory that will allow the zoom level to be set depending on what the user\n   * is interacting with, namely a tract vs a territory button.\n   *\n   * @param {LngLatBoundsLike} bounds\n   * @param {boolean} isTerritory\n   */const goToPlace=function(bounds,isTerritory,selectTractId){if(isTerritory===void 0){isTerritory=false;}if(selectTractId===void 0){selectTractId=undefined;}const newViewPort=new WebMercatorViewport({height:viewport.height,width:viewport.width});const{longitude,latitude,zoom}=newViewPort.fitBounds(bounds,{// padding: 200,  // removing padding and offset in favor of a zoom offset below\n// offset: [0, -100],\n});/**\n     * When some tracts are selected, they end up too far zoomed in, causing some census tracts to\n     * only show a portion of the tract in the viewport. We reduce the zoom level by 1 to allow\n     * more space around the selected tract.\n     *\n     * Given that the high zoom tiles only go to zoom level 5, if the corrected zoom level (zoom - 1) is\n     * less than MIN_ZOOM_FEATURE_BORDER, then we floor the zoom to MIN_ZOOM_FEATURE_BORDER + .1 (which\n     * is 5.1 as of this comment)\n     */// eslint-disable-next-line max-len\nconst featureSelectionZoomLevel=zoom-1<constants/* GLOBAL_MIN_ZOOM_FEATURE_BORDER */.xvi+.1?constants/* GLOBAL_MIN_ZOOM_FEATURE_BORDER */.xvi:zoom-1;setViewport({...viewport,longitude,latitude,zoom:isTerritory?zoom:featureSelectionZoomLevel,transitionDuration:1000,transitionInterpolator:new ViewportFlyToInterpolator(),transitionEasing:cubicInOut});// Set the tract ID to be selected if any.\nsetSelectTractId(selectTractId);};const onTransitionStart=()=>{setTransitionInProgress(true);};const onTransitionEnd=()=>{setTransitionInProgress(false);/*\n    If there is a tract ID to be selected then do so once the map has finished moving.\n    Note that setting the viewpoint to move the map as done in this component does not\n    trigger a moveend or idle event like when using flyTo or easeTo.\n    */if(selectTractId){var _mapRef$current2;// Search for features in the map that have the tract ID.\nconst geoidSearchResults=(_mapRef$current2=mapRef.current)===null||_mapRef$current2===void 0?void 0:_mapRef$current2.getMap().querySourceFeatures(constants/* HIGH_ZOOM_SOURCE_NAME */.NP7,{sourceLayer:constants/* SCORE_SOURCE_LAYER */.ZG$,validate:true,filter:['==',constants/* GEOID_PROPERTY */.TnO,selectTractId]});if(geoidSearchResults&&geoidSearchResults.length>0){// TODO, support searching for a list of tracts\nselectFeaturesOnMap(geoidSearchResults[0]);}setSelectTractId(undefined);}};const onGeolocate=()=>{setGeolocationInProgress(false);// set local storage that location was locked on this app at some point\nsetIsGeolocateLocked(true);};const onClickGeolocate=()=>{setGeolocationInProgress(true);};/**\n   * Handler for when there is a change in the multi select side panel.\n   * @param feature the feature that was added or removed\n   */const onReportDeleteTract=feature=>{updateSelectedFeatures(feature,true);};/**\n   * Handler for when the multi select is finished.\n   */const onReportExit=()=>{// Clear everything\nsetSelectedFeatures([]);setDetailViewData(undefined);setInMultiSelectMode(false);};return/*#__PURE__*/react.createElement(react.Fragment,null,/*#__PURE__*/react.createElement(lib.Grid,{desktop:{col:9},className:j40Map},/*#__PURE__*/react.createElement(interactive_map// ****** Initialization props: ******\n// access token is j40StylesReadToken\n,Object.assign({mapboxApiAccessToken:({}).MAPBOX_STYLES_READ_TOKEN?({}).MAPBOX_STYLES_READ_TOKEN:''// ****** Map state props: ******\n// http://visgl.github.io/react-map-gl/docs/api-reference/interactive-map#map-state\n},viewport,{mapStyle:({}).MAPBOX_STYLES_READ_TOKEN?'mapbox://styles/justice40/cl9g30qh7000p15l9cp1ftw16':'https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json',width:\"100%\"// Ajusting this height with a conditional statement will not render the map on staging.\n// The reason for this issue is unknown. Consider styling the parent container via SASS.\n,height:\"100%\",mapOptions:{hash:true}// ****** Interaction option props: ******\n// http://visgl.github.io/react-map-gl/docs/api-reference/interactive-map#interaction-options\n,maxZoom:constants/* GLOBAL_MAX_ZOOM */.lZg,minZoom:constants/* GLOBAL_MIN_ZOOM */.xaE,dragRotate:false,touchRotate:false// eslint-disable-next-line max-len\n,interactiveLayerIds:[constants/* HIGH_ZOOM_LAYER_ID */.jt_,constants/* PRIORITIZED_HIGH_ZOOM_LAYER_ID */.nHu]// ****** Callback props: ******\n// http://visgl.github.io/react-map-gl/docs/api-reference/interactive-map#callbacks\n,onViewportChange:setViewport,onClick:onClick,onLoad:onLoad,onTransitionStart:onTransitionStart,onTransitionEnd:onTransitionEnd,ref:mapRef,\"data-cy\":'reactMapGL'}),/* Tribal layer is baked into Mapbox source,\n             * only render here if we're not using that\n             **/({}).MAPBOX_STYLES_READ_TOKEN||/*#__PURE__*/react.createElement(MapTribalLayers,null),/*#__PURE__*/react.createElement(MapTractLayers_MapTractLayers,{selectedFeatures:selectedFeatures}),/*#__PURE__*/react.createElement(\"div\",{className:mapHeaderRow},/*#__PURE__*/react.createElement(components_MapSearch,{goToPlace:goToPlace}),/*#__PURE__*/react.createElement(\"div\",{className:geolocateBox},windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG-1&&/*#__PURE__*/react.createElement(\"div\",{className:geolocationInProgress&&!isGeolocateLocked?geolocateMessage:geolocateMessageHide},intl.formatMessage(explore/* MAP */.lC.GEOLOC_MSG_LOCATING)),/*#__PURE__*/react.createElement(geolocate_control,{positionOptions:{enableHighAccuracy:true},onGeolocate:onGeolocate,onClick:onClickGeolocate,trackUserLocation:windowWidth<constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG,showUserHeading:windowWidth<constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG}))),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(navigation_control,{showCompass:false,className:navigationControl}),windowWidth>constants/* USWDS_BREAKPOINTS */.ArX.MOBILE_LG&&/*#__PURE__*/react.createElement(territoryFocusControl,{onClick:onClick}),'fs'in flags&&detailViewData&&!transitionInProgress&&/*#__PURE__*/react.createElement(popup,{className:j40Popup,tipSize:5,anchor:\"top\",longitude:detailViewData.longitude,latitude:detailViewData.latitude,closeOnClick:true,onClose:setDetailViewData,captureScroll:true},/*#__PURE__*/react.createElement(components_AreaDetail,{properties:detailViewData.properties,hash:zoomLatLngHash})),'fs'in flags?/*#__PURE__*/react.createElement(fullscreen_control,{className:fullscreenControl}):'')),/*#__PURE__*/react.createElement(lib.Grid,{desktop:{col:3}},inMultiSelectMode?/*#__PURE__*/react.createElement(components_CreateReportPanel,{className:J40Map_module_mapInfoPanel,featureList:selectedFeatures,deleteTractHandler:onReportDeleteTract,exitHandler:onReportExit,maxNumTracts:MAX_SELECTED_TRACTS,showTooManyTractsAlert:showTooManyTractsAlert}):/*#__PURE__*/react.createElement(mapInfoPanel,{className:J40Map_module_mapInfoPanel,featureProperties:detailViewData===null||detailViewData===void 0?void 0:detailViewData.properties,hash:zoomLatLngHash})));};/* harmony default export */ var components_J40Map = (J40Map);\n// EXTERNAL MODULE: ./src/components/J40MainGridContainer.tsx\nvar J40MainGridContainer = __webpack_require__(21481);\n// EXTERNAL MODULE: ./src/components/layout.tsx + 15 modules\nvar layout = __webpack_require__(81462);\n;// ./src/pages/index.tsx\n// import DatasetsButton from '../components/DatasetsButton';\n// import {DATA_SURVEY_LINKS} from '../data/constants';\nconst ExporeToolPage=_ref=>{let{location}=_ref;// We temporarily removed MapControls, which would enable you to `setFeatures` also, for now\n//   We will bring back later when we have interactive controls.\nconst intl=(0,gatsby_plugin_intl.useIntl)();return/*#__PURE__*/react.createElement(layout/* default */.A,{location:location,title:intl.formatMessage(explore/* PAGE_INTRO */.jk.PAGE_TILE)},/*#__PURE__*/react.createElement(J40MainGridContainer/* default */.A,null,/*#__PURE__*/react.createElement(\"section\",{className:'page-heading'},/*#__PURE__*/react.createElement(\"h1\",null,intl.formatMessage(explore/* PAGE_INTRO */.jk.PAGE_HEADING))),/*#__PURE__*/react.createElement(lib.Grid,{row:true,gap:true,className:'j40-mb5-mt3'},/*#__PURE__*/react.createElement(lib.Grid,{desktop:{col:8},tablet:{col:10},col:12},/*#__PURE__*/react.createElement(\"p\",null,explore/* PAGE_DESCRIPTION1 */.oy),/*#__PURE__*/react.createElement(\"p\",null,explore/* PAGE_DESCRIPTION2 */.v)),/*#__PURE__*/react.createElement(lib.Grid,{desktop:{col:4},tablet:{col:10},col:12},/*#__PURE__*/react.createElement(components_ExploreDataBox,null)))),/*#__PURE__*/react.createElement(J40MainGridContainer/* default */.A,null,/*#__PURE__*/react.createElement(lib.Grid,{row:true},/*#__PURE__*/react.createElement(components_J40Map,{location:location}))),/*#__PURE__*/react.createElement(J40MainGridContainer/* default */.A,null,/*#__PURE__*/react.createElement(lib.Grid,{desktop:{col:7},tablet:{col:10},col:12},/*#__PURE__*/react.createElement(\"h2\",null,explore/* NOTE_ON_TERRITORIES */.oI.INTRO),/*#__PURE__*/react.createElement(\"p\",null,explore/* NOTE_ON_TERRITORIES */.oI.PARA_0),/*#__PURE__*/react.createElement(\"p\",null,explore/* NOTE_ON_TERRITORIES */.oI.PARA_1),/*#__PURE__*/react.createElement(\"p\",null,explore/* NOTE_ON_TERRITORIES */.oI.PARA_2)),/*#__PURE__*/react.createElement(lib.Grid,{desktop:{col:7},tablet:{col:10},col:12},/*#__PURE__*/react.createElement(\"h2\",null,explore/* NOTE_ON_TRIBAL_NATIONS */.j2.INTRO),/*#__PURE__*/react.createElement(\"p\",null,explore/* NOTE_ON_TRIBAL_NATIONS */.j2.PARA_1),/*#__PURE__*/react.createElement(\"p\",null,explore/* NOTE_ON_TRIBAL_NATIONS */.j2.PARA_2))));};/* harmony default export */ var pages = (ExporeToolPage);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxXQUFXO0FBQ3RCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseUJBQXlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1GQUFtRixnQkFBZ0I7QUFDbkc7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOztBQ3BFNEI7QUFDcUI7QUFDakQ7QUFDQTtBQUNBLEVBQUUsRUFBRSxpQkFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZSx3QkFBd0IsS0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQzs7QUNwSTRCO0FBQ3FCO0FBQ2pEO0FBQ0E7QUFDQSxFQUFFLEVBQUUsaUJBQWlCO0FBQ3JCO0FBQ0E7QUFDZSx1QkFBdUIsS0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7O0FDdkQ0QjtBQUM1QixNQUFNLDRCQUFVO0FBQ0QsK0JBQStCLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxDOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0JBQVk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxvQkFBb0Isd0JBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOztBQzNFZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsa0RBQWtELDJCQUFhLENBQUMsMkJBQWEsR0FBRyw4QkFBOEI7QUFDOUc7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsa0RBQWtELDJCQUFhLENBQUMsMkJBQWEsR0FBRyw4QkFBOEI7QUFDOUc7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx1Q0FB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0EsT0FBTztBQUNQLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0EseUJBQXlCLG1DQUFtQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFL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O0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUIsVUFBVSxnQkFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUiw0QkFBNEIsbUJBQW1CLFVBQVUsZ0JBQVE7QUFDakU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUyx5QkFBeUIsbUJBQW1CO0FBQ3JEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUFnQjtBQUM5QixrQkFBa0IsMEJBQWE7QUFDL0IsZUFBZSw2QkFBZ0I7QUFDL0IsY0FBYyw2QkFBZ0I7QUFDOUIsZ0JBQWdCLDZCQUFnQjtBQUNoQyxnQkFBZ0IsNkJBQWdCO0FBQ2hDLGlCQUFpQiw2QkFBZ0I7QUFDakMsbUJBQW1CLDJCQUFjO0FBQ2pDLGdCQUFnQiwyQkFBYztBQUM5QixxQkFBcUIsNkJBQWdCO0FBQ3JDLG1CQUFtQiw2QkFBZ0I7QUFDbkMseUJBQXlCLDZCQUFnQjtBQUN6QyxxQkFBcUIsNkJBQWdCO0FBQ3JDLG9CQUFvQiw2QkFBZ0I7QUFDcEMscUJBQXFCLDZCQUFnQjtBQUNyQyx1QkFBdUIsNkJBQWdCO0FBQ3ZDLGtCQUFrQiwyQkFBYztBQUNoQyxpQkFBaUIsNkJBQWdCO0FBQ2pDLG1CQUFtQiw2QkFBZ0I7QUFDbkMsWUFBWSw2QkFBZ0I7QUFDNUIsY0FBYywyQkFBYztBQUM1QixtQkFBbUIsNkJBQWdCO0FBQ25DLHFCQUFxQiw2QkFBZ0I7QUFDckMsbUJBQW1CLDZCQUFnQjtBQUNuQyxlQUFlLDZCQUFnQjtBQUMvQixrQkFBa0IsNkJBQWdCO0FBQ2xDLG1CQUFtQiwyQkFBYztBQUNqQyx3QkFBd0IsNkJBQWdCO0FBQ3hDLG9CQUFvQiwwQkFBYTtBQUNqQyxtQkFBbUIsMkJBQWM7QUFDakMsbUJBQW1CLDJCQUFjO0FBQ2pDLDBCQUEwQiwyQkFBYztBQUN4QyxpQkFBaUIsMkJBQWM7QUFDL0Isb0JBQW9CLDJCQUFjO0FBQ2xDLG9CQUFvQiwyQkFBYztBQUNsQyxpQkFBaUIsNkJBQWdCO0FBQ2pDLGtCQUFrQiwyQkFBYztBQUNoQyw4QkFBOEIsNkJBQWdCO0FBQzlDLGlDQUFpQyw2QkFBZ0I7QUFDakQsbUJBQW1CLDJCQUFjO0FBQ2pDLDhCQUE4QiwyQkFBYztBQUM1QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQyxDQUFDLGVBQWUsR0FBRyx1QkFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRyx1QkFBZSxpREFBaUQsdUJBQWU7OztBQ3o5Rm5GO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEOzs7O0FDWlAsbURBQWUsb0JBQW9COztBQ1VuQztBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQ08sS0FBTSxDQUFBUSxpQkFBaUIsQ0FBRzdCLElBQUEsRUFBMkQsSUFBMUQsQ0FBQzhCLFFBQVEsQ0FBRUMsVUFBeUMsQ0FBQyxDQUFBL0IsSUFBQSxDQUNyRixLQUFNLENBQUFDLElBQUksQ0FBR04sOEJBQU8sQ0FBQyxDQUFDLENBQ3RCLEdBQUksQ0FBQXFDLFNBQVMsQ0FBRyxLQUFLLENBRXJCLEtBQU0sQ0FBQUMsY0FBYyxDQUFHQSxDQUFBLEdBQU0sQ0FDM0IsR0FBSUYsVUFBVSxHQUFLSixzQ0FBNkIsQ0FBRSxDQUNoRCxNQUFPLENBQUExQixJQUFJLENBQUNLLGFBQWEsQ0FBQ1Ysa0NBQStCLENBQUN3QyxnQkFBZ0IsQ0FBQyxDQUM3RSxDQUFDLElBQU0sSUFBSUwsVUFBVSxHQUFLSixzQ0FBNkIsRUFBSUcsUUFBUSxDQUFFLENBQ25FRSxTQUFTLENBQUcsSUFBSSxDQUNoQixNQUFPLENBQUEvQixJQUFJLENBQUNLLGFBQWEsQ0FBQ1Ysa0NBQStCLENBQUN5QyxvQkFBb0IsQ0FBQyxDQUNqRixDQUFDLElBQU0sQ0FDTCxNQUFPLEtBQUksQ0FDYixDQUNGLENBQUMsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsbUJBQ0U5QyxtQkFBQSxDQUFBQSxjQUFBLG1CQUNFQSxtQkFBQSxDQUFDbUMsWUFBWSxFQUNYYSxFQUFFLENBQUMsZUFBZSxDQUNsQkMsU0FBUyxDQUFFLElBQUssQ0FDakIsQ0FBQyxjQUNGakQsbUJBQUEsUUFDRSxXQUFTLGVBQWUsQ0FDeEIsV0FBVTBDLGNBQWMsQ0FBQyxDQUFFLENBQzNCLGlCQUFlLE1BQU0sQ0FDckI5QixTQUFTLENBQUVOLElBQVksQ0FDdkJhLEdBQUcsQ0FBRWtCLGNBQVMsQ0FDZGpCLEdBQUcsQ0FBRVYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLGlDQUE4QixDQUFDK0MsWUFBWSxDQUFDQyxJQUFJLENBQUUsQ0FDM0UsQ0FBQyxDQUNEWixTQUFTLGVBQUl6QyxtQkFBQSxTQUFNWSxTQUFTLENBQUVOLFNBQWlCLEVBQUcsS0FBYSxDQUNoRSxDQUFDLENBRVAsQ0FBQyxDQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUNPLEtBQU0sQ0FBQWlELHFCQUFxQixDQUFHQyxLQUFBLEVBQW9FLElBQW5FLENBQUNDLElBQUksQ0FBRUMsS0FBSyxDQUFFQyxhQUFhLENBQUVDLFNBQWdDLENBQUMsQ0FBQUosS0FBQSxDQUNsRyxHQUFJRSxLQUFLLEdBQUssSUFBSSxDQUFFLENBQ2xCLG1CQUNFMUQsbUJBQUEsWUFDR0ssaUNBQThCLENBQUN3RCxjQUM3QixDQUFDLENBRVYsQ0FBQyxJQUFNLElBQUlKLElBQUksR0FBSyxTQUFTLEVBQUlBLElBQUksR0FBSyxZQUFZLENBQUUsQ0FDdEQsbUJBQ0V6RCxtQkFBQSxZQUVJMkQsYUFBYSxDQUNidEQsaUNBQThCLENBQUN5RCxLQUFLLENBQ3BDekQsaUNBQThCLENBQUMwRCxLQUFLLENBR3BDSCxTQUFTLGNBQ1Q1RCxtQkFBQSxDQUFDZ0UsY0FBYyxFQUFDUCxJQUFJLENBQUVBLElBQUssQ0FBQ1EsV0FBVyxDQUFFTCxTQUFVLENBQUMsQ0FBQyxjQUNyRDVELG1CQUFBLENBQUNnRSxjQUFjLEVBQUNQLElBQUksQ0FBRUEsSUFBSyxDQUFDUSxXQUFXLENBQUUsRUFBRyxDQUFDLENBQUMsQ0FFL0MsR0FBRyxDQUVGUixJQUFJLEdBQUssU0FBUyxDQUNsQnBELGlDQUE4QixDQUFDNkQsT0FBTyxDQUN0QzdELGlDQUE4QixDQUFDOEQsVUFFOUIsQ0FBQyxDQUVWLENBQUMsSUFBTSxDQUNMLG1CQUFRbkUsbUJBQUEsQ0FBQUEsY0FBQSxLQUFJLENBQUMsQ0FDZixDQUNGLENBQUMsQ0FFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUNPLEtBQU0sQ0FBQW9FLGtCQUFrQixDQUFJQyx3QkFBK0IsRUFBSyxDQUNyRTtBQUNBLEdBQUlBLHdCQUF3QixDQUFDQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUssQ0FBQyxDQUFDLENBQUUsQ0FDaEQsS0FBTSxDQUFBQyxhQUFhLENBQUdGLHdCQUF3QixDQUFDRyxNQUFNLENBQUNILHdCQUF3QixDQUFDSSxNQUFNLENBQUcsQ0FBQyxDQUFDLENBQzFGLEtBQU0sQ0FBQUMsY0FBYyxDQUFHTCx3QkFBd0IsQ0FBQ00sS0FBSyxDQUFDLENBQUMsQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUU1RCxtQkFBTzNFLG1CQUFBLENBQUFBLGNBQUEsTUFBRzBFLGNBQWMsY0FBQzFFLG1CQUFBLFFBQUs0RSxLQUFLLENBQUUsQ0FBQ0MsR0FBRyxDQUFFLFFBQVEsQ0FBRSxFQUFFTixhQUFtQixDQUFHLENBQUMsQ0FDaEYsQ0FFQTtBQUNBLEtBQU0sQ0FBQU8sVUFBVSxDQUFHLFlBQVksQ0FDL0IsS0FBTSxDQUFBQyxXQUFXLENBQUcsVUFBVSxDQUFFO0FBQ2hDLEtBQU0sQ0FBQUwsY0FBYyxDQUFHSSxVQUFVLENBQUNFLElBQUksQ0FBQ1gsd0JBQXdCLENBQUMsQ0FDaEUsS0FBTSxDQUFBRSxhQUFhLENBQUdRLFdBQVcsQ0FBQ0MsSUFBSSxDQUFDWCx3QkFBd0IsQ0FBQyxDQUVoRSxtQkFBT3JFLG1CQUFBLENBQUFBLGNBQUEsTUFBRzBFLGNBQWMsY0FBQzFFLG1CQUFBLFFBQUs0RSxLQUFLLENBQUUsQ0FBQ0MsR0FBRyxDQUFFLFFBQVEsQ0FBRSxFQUFFTixhQUFtQixDQUFHLENBQUMsQ0FDaEYsQ0FBQyxDQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUNPLEtBQU0sQ0FBQVAsY0FBYyxDQUFHaUIsS0FBQSxFQUF5QyxJQUF4QyxDQUFDeEIsSUFBSSxDQUFFUSxXQUEyQixDQUFDLENBQUFnQixLQUFBLENBQ2hFLEtBQU0sQ0FBQXZFLElBQUksQ0FBR04sOEJBQU8sQ0FBQyxDQUFDLENBRXRCLEdBQUk2RCxXQUFXLEdBQUssSUFBSSxDQUFFLG1CQUFPakUsbUJBQUEsQ0FBQUEsY0FBQSxNQUFHb0Msc0NBQWdDLENBQUMsQ0FFckUsR0FBSXFCLElBQUksR0FBSyxTQUFTLEVBQUlBLElBQUksR0FBSyxZQUFZLENBQUUsQ0FDL0M7QUFFQSxHQUFJQSxJQUFJLEdBQUssU0FBUyxDQUFFLENBQ3RCO0FBQ0EsbUJBQ0V6RCxtQkFBQSxhQUNHVSxJQUFJLENBQUN3RSxZQUFZLENBQ2RqQixXQUFXLENBQ1gsQ0FDRVcsS0FBSyxDQUFFLE1BQU0sQ0FDYk8sSUFBSSxDQUFFLFNBQVMsQ0FDZkMsV0FBVyxDQUFFLE9BQ2YsQ0FDSixDQUNJLENBQUMsQ0FFWCxDQUFDLElBQU0sQ0FDUDtBQUNFLEtBQU0sQ0FBQUMsaUJBQXlCLENBQUczRSxJQUFJLENBQUNLLGFBQWEsQ0FDaEQsQ0FDRWlDLEVBQUUsQ0FBRSx1RUFBdUUsQ0FDM0U7QUFDQXNDLFdBQVcsQ0FBRSw0T0FBNE8sQ0FDelBDLGNBQWMsQ0FBRTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUNVLENBQUMsQ0FDRCxDQUNFYixjQUFjLENBQUVULFdBQ2xCLENBQ0osQ0FBQyxDQUNELE1BQU8sQ0FBQUcsa0JBQWtCLENBQUNpQixpQkFBaUIsQ0FBQyxDQUM5QyxDQUNGLENBQUMsSUFBTSxDQUNMO0FBQ0EsTUFBTyxDQUFBcEIsV0FBVyxHQUFLLENBQUMsQ0FDdEI1RCxrQ0FBK0IsQ0FBQ29GLEVBQUUsQ0FDbENwRixrQ0FBK0IsQ0FBQ3FGLEdBQUcsQ0FDdkMsQ0FDRixDQUFDLENBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQ0EsS0FBTSxDQUFBQyxTQUFTLENBQUdDLEtBQUEsRUFBa0QsSUFBakQsQ0FBQ0MsU0FBUyxDQUFFdEQsUUFBUSxDQUFFQyxVQUFxQixDQUFDLENBQUFvRCxLQUFBLENBQzdEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLEtBQU0sQ0FBQTNCLFdBQVcsQ0FBRzRCLFNBQVMsQ0FBQ25DLEtBQUssR0FBSyxJQUFJLENBQUdvQyxJQUFJLENBQUNDLEtBQUssQ0FBQ0MsTUFBTSxDQUFDSCxTQUFTLENBQUNuQyxLQUFLLENBQUMsQ0FBRyxHQUFHLENBQUMsQ0FBRyxJQUFJLENBRS9GO0FBQ0EsS0FBTSxDQUFBRSxTQUFTLENBQUdpQyxTQUFTLENBQUNqQyxTQUFTLENBQUdpQyxTQUFTLENBQUNqQyxTQUFTLENBQUd4QiwrQ0FBc0MsQ0FFcEc7QUFDQSxLQUFNLENBQUF1QixhQUFhLENBQUdNLFdBQVcsR0FBSyxJQUFJLEVBQUlBLFdBQVcsRUFBSUwsU0FBUyxDQUFHLElBQUksQ0FBRyxLQUFLLENBRXJGO0FBQ0EsS0FBTSxDQUFBc0MscUJBQXFCLENBQ3hCTCxTQUFTLENBQUNNLEtBQUssR0FBSyxZQUFZLEVBQUs1RCxRQUFTLEVBQzlDc0QsU0FBUyxDQUFDTSxLQUFLLEdBQUssWUFBWSxFQUFJM0QsVUFBVSxHQUFLSixzQ0FBNkIsRUFBSSxDQUFDRyxRQUN2RixDQUVELG1CQUNFdkMsbUJBQUEsT0FDRVksU0FBUyxDQUFFTixnQkFBd0IsQ0FDbkMsVUFBUyxjQUFlLENBQ3hCLGNBQVksZUFBZSxlQUMzQk4sbUJBQUEsUUFBS1ksU0FBUyxDQUFFTixZQUFvQixlQUdsQ04sbUJBQUEsUUFBS1ksU0FBUyxDQUFFTixhQUFxQixFQUNsQ3VGLFNBQVMsQ0FBQ00sS0FBSyxjQUNoQm5HLG1CQUFBLFFBQUtZLFNBQVMsQ0FBRU4sYUFBcUIsRUFDbEN1RixTQUFTLENBQUNQLFdBQ1IsQ0FDRixDQUFDLGNBR050RixtQkFBQSxRQUFLWSxTQUFTLENBQUVOLGlCQUF5QixlQUN2Q04sbUJBQUEsUUFBS1ksU0FBUyxDQUFFTixpQkFBeUIsRUFHckM0RixxQkFBcUIsZUFDckJsRyxtQkFBQSxRQUFLWSxTQUFTLENBQUVOLGFBQXFCLGVBQ25DTixtQkFBQSxDQUFDc0MsaUJBQWlCLEVBQ2hCQyxRQUFRLENBQUVBLFFBQVMsQ0FDbkJDLFVBQVUsQ0FBRUEsVUFBVyxDQUN4QixDQUNFLENBQUMsY0FJUnhDLG1CQUFBLFFBQUtZLFNBQVMsQ0FBRWlGLFNBQVMsQ0FBQ2MsZUFBZSxDQUN2Q3JHLGlCQUF3QixDQUFHQSxjQUFzQixlQUVqRE4sbUJBQUEsQ0FBQ2dFLGNBQWMsRUFDYlAsSUFBSSxDQUFFb0MsU0FBUyxDQUFDcEMsSUFBSyxDQUNyQlEsV0FBVyxDQUFFQSxXQUFZLENBQzFCLENBQ0UsQ0FFRixDQUFDLGNBR05qRSxtQkFBQSxRQUFLWSxTQUFTLENBQUVOLHFCQUE2QixlQUMzQ04sbUJBQUEsQ0FBQ3VELHFCQUFxQixFQUNwQkcsS0FBSyxDQUFFTyxXQUFZLENBQ25CTixhQUFhLENBQUVBLGFBQWMsQ0FDN0JDLFNBQVMsQ0FBRUEsU0FBVSxDQUNyQkgsSUFBSSxDQUFFb0MsU0FBUyxDQUFDcEMsSUFBSyxDQUN0QixDQUNFLENBRUYsQ0FDRixDQUNILENBQUMsQ0FFVCxDQUFDLENBRUQsd0RBQWVrQyxTQUFTLEU7O0FDblR4QjtBQUNPO0FBQ0E7QUFDQTtBQUNBLElBQUksdUJBQU07QUFDVjtBQUNBO0FBQ0EsNkU7O0FDT1AsS0FBTSxDQUFBbUIsU0FBUyxDQUFHckcsSUFBQSxFQUE4RCxJQUE3RCxDQUFDc0csVUFBVSxDQUFFQyx5QkFBMEMsQ0FBQyxDQUFBdkcsSUFBQSxDQUN6RSxLQUFNLENBQUFDLElBQUksQ0FBR04sOEJBQU8sQ0FBQyxDQUFDLENBQ3RCLEtBQU0sQ0FBQTZHLG1CQUFtQixDQUFHRCx5QkFBeUIsQ0FDbkRFLFVBQVUsQ0FBQyxDQUFDRix5QkFBeUIsQ0FBQyxHQUFHLEVBQUVHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBRyxJQUFJLENBQzlELEtBQU0sQ0FBQXZELFNBQVMsQ0FBRyxFQUFFLENBRXBCLG1CQUNFNUQsbUJBQUEsUUFBS1ksU0FBUyxDQUFFTixrQkFBMEIsZUFDeENOLG1CQUFBLFFBQUtZLFNBQVMsQ0FBRU4sUUFBZ0IsZUFDOUJOLG1CQUFBLFFBQUtZLFNBQVMsQ0FBRU4sYUFBcUIsRUFBRUksSUFBSSxDQUFDSyxhQUFhLENBQUNWLDBCQUF1QixDQUFDbUgsU0FBUyxDQUFPLENBQUMsY0FDbkd4SCxtQkFBQSxRQUFLWSxTQUFTLENBQUVtRyxVQUFVLENBQUd6Ryx1QkFBYSxDQUFHLEVBQUcsRUFDN0N5RyxVQUFVLENBQUcxRyx5QkFBc0IsQ0FBQ3NILFFBQVEsQ0FBR3RILHlCQUFzQixDQUFDdUgsWUFDcEUsQ0FDRixDQUFDLGNBQ041SCxtQkFBQSxRQUFLWSxTQUFTLENBQUVOLFFBQWdCLGVBQzlCTixtQkFBQSxRQUFLWSxTQUFTLENBQUVOLGFBQXFCLEVBQUVJLElBQUksQ0FBQ0ssYUFBYSxDQUFDViwwQkFBdUIsQ0FBQ3dILFdBQVcsQ0FBTyxDQUFDLGNBQ3JHN0gsbUJBQUEsUUFBS1ksU0FBUyxDQUFFTixxQkFBNkIsZUFDM0NOLG1CQUFBLFFBQUtZLFNBQVMsQ0FDWm1HLFVBQVUsRUFBSUUsbUJBQW1CLEVBQ2pDQSxtQkFBbUIsRUFBSXJELFNBQVMsQ0FBR3RELHVCQUFhLENBQUdBLFFBQWdCLGVBQ25FTixtQkFBQSxDQUFDZ0UsY0FBYyxFQUNiUCxJQUFJLENBQUUsWUFBYSxDQUNuQlEsV0FBVyxDQUFFZ0QsbUJBQW9CLENBQ2xDLENBQ0UsQ0FBQyxjQUNOakgsbUJBQUEsUUFBS1ksU0FBUyxDQUFFTixnQkFBd0IsZUFDdENOLG1CQUFBLENBQUN1RCxxQkFBcUIsRUFDcEJHLEtBQUssQ0FBRXVELG1CQUFvQixDQUMzQnRELGFBQWEsQ0FBRXNELG1CQUFtQixFQUFJQSxtQkFBbUIsRUFBSXJELFNBQVMsQ0FBRyxJQUFJLENBQUcsS0FBTSxDQUN0RkEsU0FBUyxDQUFFQSxTQUFVLENBQ3JCSCxJQUFJLENBQUUsWUFBYSxDQUNwQixDQUNFLENBQ0YsQ0FDRixDQUNGLENBQUMsQ0FFVixDQUFDLENBRUQsd0RBQWVxRCxTQUFTLEU7O0FDcER4Qix5REFBZUEsbUJBQVMsRTs7QUNDeEIseURBQWVuQixtQkFBUyxFOztBQ1l2QixDQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUNBLEtBQU0sQ0FBQXNDLGtCQUFrQixDQUNyQnhILElBQUEsRUFTMEIsSUFUekIsQ0FBQ3lILDBCQUEwQixDQUMxQkMsdUJBQXVCLENBQ3ZCQyxvQkFBb0IsQ0FDcEJDLG9CQUFvQixDQUNwQkMsZUFBZSxDQUNmQyxpQkFBaUIsQ0FDakJDLGFBQWEsQ0FDYkMsYUFBYSxDQUNiQyxrQkFDa0IsQ0FBQyxDQUFBakksSUFBQSxDQUNuQixHQUFJLENBQUFrSSxnQkFBZ0IsQ0FBRyxJQUFJLENBRTNCLEdBQUlMLGVBQWUsQ0FBRSxDQUNuQkssZ0JBQWdCLENBQUd0SSxtQ0FBZ0MsQ0FBQ3dJLHFCQUFxQixDQUMzRTtBQUNBLENBQUMsSUFBTSxJQUFJWCwwQkFBMEIsR0FBSyxDQUFDLENBQUUsQ0FDM0M7QUFDQSxHQUFJRSxvQkFBb0IsRUFBSUMsb0JBQW9CLENBQUUsQ0FDaERNLGdCQUFnQixDQUFHdEksbUNBQWdDLENBQUN5SSxZQUFZLENBQ2hFO0FBQ0YsQ0FBQyxJQUFNLElBQUlQLGlCQUFpQixDQUFFLENBQzVCSSxnQkFBZ0IsQ0FBR3RJLG1DQUFnQyxDQUFDMEksY0FBYyxDQUNsRTtBQUNGLENBQUMsSUFBTSxJQUFJWCxvQkFBb0IsRUFBSSxDQUFDQyxvQkFBb0IsQ0FBRSxDQUN4RDtBQUNBLEdBQUtHLGFBQWEsR0FBSyxJQUFJLEVBQUlDLGFBQWEsR0FBSyxJQUFJLENBQUUsQ0FDckQ7QUFDQSxHQUFJQyxrQkFBa0IsR0FBSyxJQUFJLENBQUUsQ0FDL0JDLGdCQUFnQixDQUFHdEksbUNBQWdDLENBQUMySSxnQkFBZ0IsQ0FDcEU7QUFDRixDQUFDLElBQU0sSUFBSU4sa0JBQWtCLEdBQUssQ0FBQyxDQUFFLENBQ25DQyxnQkFBZ0IsQ0FBR3RJLG1DQUFnQyxDQUFDNEksbUJBQW1CLENBQ3ZFO0FBQ0YsQ0FBQyxJQUFNLElBQUlQLGtCQUFrQixFQUFJLENBQUMsQ0FBRSxDQUNsQ0MsZ0JBQWdCLENBQUd0SSxtQ0FBZ0MsQ0FBQzRJLG1CQUFtQixDQUN6RSxDQUNBO0FBQ0YsQ0FBQyxJQUFNLElBQUlULGFBQWEsR0FBSyxJQUFJLEVBQUlBLGFBQWEsRUFBSSxDQUFDLENBQUUsQ0FDdkRHLGdCQUFnQixDQUFHdEksbUNBQWdDLENBQUM0SSxtQkFBbUIsQ0FDekUsQ0FDQTtBQUNGLENBQUMsSUFBTSxJQUNMLEVBQUViLG9CQUFvQixFQUFJQyxvQkFBb0IsQ0FBQyxFQUM5Q0csYUFBYSxHQUFLLElBQUksRUFDdEJDLGFBQWEsR0FBSyxJQUFJLEVBQ3RCQyxrQkFBa0IsR0FBSyxJQUFJLENBQzVCLENBQ0E7QUFDQSxHQUFJUCx1QkFBdUIsR0FBSyxDQUFDLENBQUUsQ0FDakNRLGdCQUFnQixDQUFHdEksbUNBQWdDLENBQUM2SSxRQUFRLENBQzVEO0FBQ0YsQ0FBQyxJQUFNLElBQUlmLHVCQUF1QixHQUFLLENBQUMsQ0FBRSxDQUN4Q1EsZ0JBQWdCLENBQUd0SSxtQ0FBZ0MsQ0FBQzhJLGFBQWEsQ0FDakU7QUFDRixDQUFDLElBQU0sSUFBSWhCLHVCQUF1QixDQUFHLENBQUMsQ0FBRSxDQUN0Q1EsZ0JBQWdCLENBQUd0SSxtQ0FBZ0MsQ0FBQytJLGFBQWEsQ0FDbkUsQ0FDQTtBQUNGLENBQUMsSUFBTSxJQUFJLEVBQUVoQixvQkFBb0IsRUFBSUMsb0JBQW9CLENBQUMsQ0FBRSxDQUMxRDtBQUNBLEdBQ0dHLGFBQWEsR0FBSyxJQUFJLEVBQUlBLGFBQWEsRUFBSSxDQUFDLEVBQy9DQyxhQUFhLEdBQUssSUFBSSxFQUFJQSxhQUFhLEVBQUksQ0FBRSxDQUMzQyxDQUNBRSxnQkFBZ0IsQ0FBR3RJLCtCQUE0QixDQUFDbUksYUFBYSxDQUFFQyxhQUFhLENBQUMsQ0FDN0U7QUFDRixDQUFDLElBQU0sSUFDSkQsYUFBYSxHQUFLLElBQUksRUFBSUEsYUFBYSxFQUFJLENBQUMsRUFDaERDLGFBQWEsR0FBSyxJQUFJLENBQ25CLENBQ0FFLGdCQUFnQixDQUFHdEksOEJBQTJCLENBQUNtSSxhQUFhLENBQUMsQ0FDN0Q7QUFDRixDQUFDLElBQU0sSUFDSkMsYUFBYSxHQUFLLElBQUksRUFBSUEsYUFBYSxFQUFJLENBQUMsRUFDaERELGFBQWEsR0FBSyxJQUFJLENBQ25CLENBQ0EsR0FBSUUsa0JBQWtCLEdBQUssSUFBSSxDQUFFLENBQy9CQyxnQkFBZ0IsQ0FBR3RJLG9DQUFpQyxDQUFDLEdBQUdvSSxhQUFhLEVBQUUsQ0FBQyxDQUMxRSxDQUFDLElBQU0sSUFBSUMsa0JBQWtCLEdBQUssQ0FBQyxDQUFFLENBQ25DQyxnQkFBZ0IsQ0FBR3RJLDhCQUEyQixDQUFDLGNBQWMsQ0FBQyxDQUNoRSxDQUFDLElBQU0sSUFBSXFJLGtCQUFrQixFQUFJLENBQUMsQ0FBRSxDQUNsQ0MsZ0JBQWdCLENBQUd0SSw4QkFBMkIsQ0FBQyxHQUFHcUksa0JBQWtCLEdBQUcsQ0FBQyxDQUMxRSxDQUNGO0FBQ0EsQ0FBQyxJQUFNLElBQUlELGFBQWEsR0FBSyxJQUFJLEVBQUlELGFBQWEsR0FBSyxJQUFJLENBQUUsQ0FDM0QsR0FBSUUsa0JBQWtCLEdBQUssQ0FBQyxDQUFFLENBQzVCQyxnQkFBZ0IsQ0FBR3RJLDhCQUEyQixDQUFDLGNBQWMsQ0FBQyxDQUNoRSxDQUFDLElBQU0sSUFBSXFJLGtCQUFrQixHQUFLLElBQUksRUFBSUEsa0JBQWtCLEVBQUksQ0FBQyxDQUFHLENBQ2xFQyxnQkFBZ0IsQ0FBR3RJLDhCQUEyQixDQUFDLEdBQUdxSSxrQkFBa0IsR0FBRyxDQUFDLENBQzFFLENBQ0YsQ0FDRixDQUNBO0FBQ0YsQ0FBQyxJQUFNLElBQUlSLDBCQUEwQixDQUFHLENBQUMsQ0FBRSxDQUN6QyxHQUFJQyx1QkFBdUIsR0FBSyxDQUFDLENBQUUsQ0FDbkMsQ0FBQyxJQUFNLElBQUlBLHVCQUF1QixHQUFLLENBQUMsQ0FBRSxDQUN4Q1EsZ0JBQWdCLENBQUd0SSxrQ0FBK0IsQ0FBQyxHQUFHLENBQUMsQ0FDekQsQ0FBQyxJQUFNLElBQUk4SCx1QkFBdUIsQ0FBRyxDQUFDLENBQUUsQ0FDdENRLGdCQUFnQixDQUFHdEksa0NBQStCLENBQUMsYUFBYSxDQUFDLENBQ25FLENBQ0YsQ0FBQyxDQUVELE1BQU8sQ0FBQXNJLGdCQUFnQixlQUFJM0ksbUJBQUEsVUFBSTJJLGdCQUFvQixDQUFDLENBQ3RELENBQUMsQ0FFSiwwRUFBZVYsa0JBQWtCLEU7O0FDM0lqQyxrRUFBZUEscUNBQWtCLEU7O0FDV2hDLENBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQ0EsS0FBTSxDQUFBeUIsbUJBQW1CLENBQ3RCakosSUFBQSxFQU0yQixJQU4xQixDQUFDeUgsMEJBQTBCLENBQzFCRSxvQkFBb0IsQ0FDcEJDLG9CQUFvQixDQUNwQkcsYUFBYSxDQUNiQyxhQUFhLENBQ2JDLGtCQUNtQixDQUFDLENBQUFqSSxJQUFBLENBQ3BCLEdBQUksQ0FBQWtKLGlCQUFpQixDQUFHLElBQUksQ0FFNUI7QUFDQSxHQUNHekIsMEJBQTBCLEdBQUssQ0FBQyxFQUFLRSxvQkFBb0IsRUFBSUMsb0JBQXFCLEVBQ25GSCwwQkFBMEIsRUFBSSxDQUFFLENBQ2hDLENBQ0E7QUFDQSxHQUNFTSxhQUFhLEdBQUssSUFBSSxFQUN0QkMsYUFBYSxHQUFLLElBQUksRUFBSUEsYUFBYSxFQUFJLENBQUUsRUFDN0NDLGtCQUFrQixHQUFLLElBQUksRUFBSUEsa0JBQWtCLEVBQUksQ0FBRSxDQUN2RCxDQUNBaUIsaUJBQWlCLENBQUd0SiwrQ0FBNEMsQ0FBQyxHQUFHcUksa0JBQWtCLEdBQUcsQ0FBRUQsYUFBYSxDQUFDLENBQzNHO0FBQ0EsQ0FBQyxJQUFNLElBQ0xELGFBQWEsR0FBSyxJQUFJLEVBQ3ZCQyxhQUFhLEdBQUssSUFBSSxFQUNyQkMsa0JBQWtCLEdBQUssSUFBSSxFQUFJQSxrQkFBa0IsRUFBSSxDQUFFLENBQ3ZELENBQ0FpQixpQkFBaUIsQ0FBR3RKLDhCQUEyQixDQUFDLEdBQUdxSSxrQkFBa0IsR0FBRyxDQUFFLElBQUksQ0FBQyxDQUNqRjtBQUNBLENBQUMsSUFBTSxJQUNMRixhQUFhLEdBQUssSUFBSSxFQUN0QkMsYUFBYSxHQUFLLElBQUksRUFBSUEsYUFBYSxFQUFJLENBQUUsRUFDN0NDLGtCQUFrQixHQUFLLElBQUksRUFBSUEsa0JBQWtCLEVBQUksQ0FBRSxDQUN2RCxDQUNBaUIsaUJBQWlCLENBQUd0SiwrQ0FBNEMsQ0FBQyxjQUFjLENBQUVvSSxhQUFhLENBQUMsQ0FDakc7QUFDQSxDQUFDLElBQU0sSUFDTEQsYUFBYSxHQUFLLElBQUksRUFDdkJDLGFBQWEsR0FBSyxJQUFJLEVBQ3JCQyxrQkFBa0IsR0FBSyxJQUFJLEVBQUlBLGtCQUFrQixFQUFJLENBQUUsQ0FDdkQsQ0FDQWlCLGlCQUFpQixDQUFHdEosOEJBQTJCLENBQUMsY0FBYyxDQUFFLElBQUksQ0FBQyxDQUN2RTtBQUNBLENBQUMsSUFBTSxJQUNKbUksYUFBYSxHQUFLLElBQUksRUFBSUEsYUFBYSxFQUFJLENBQUMsRUFDOUNDLGFBQWEsR0FBSyxJQUFJLEVBQ3RCQyxrQkFBa0IsR0FBSyxJQUFJLENBQzFCLENBQ0FpQixpQkFBaUIsQ0FBR3RKLDhCQUEyQixDQUFDbUksYUFBYSxDQUFFLElBQUksQ0FBQyxDQUN0RTtBQUNBLENBQUMsSUFBTSxJQUNKQSxhQUFhLEdBQUssSUFBSSxFQUFJQSxhQUFhLEVBQUksQ0FBQyxFQUM3Q0MsYUFBYSxHQUFLLElBQUksRUFBSUEsYUFBYSxFQUFJLENBQUUsQ0FDN0MsQ0FDQWtCLGlCQUFpQixDQUFHdEosK0JBQTRCLENBQUNtSSxhQUFhLENBQUVDLGFBQWEsQ0FBRSxJQUFJLENBQUMsQ0FDcEY7QUFDRixDQUFDLElBQU0sSUFDTCxDQUFDTCxvQkFBb0IsRUFBSUMsb0JBQW9CLEVBQzlDRyxhQUFhLEdBQUssSUFBSSxFQUFJQSxhQUFhLEVBQUksQ0FBRSxFQUM3Q0Usa0JBQWtCLEdBQUssSUFBSSxFQUFJQSxrQkFBa0IsRUFBSSxDQUFFLENBQ3RELENBQ0FpQixpQkFBaUIsQ0FBR3RKLDhCQUEyQixDQUFDLEdBQUdxSSxrQkFBa0IsR0FBRyxDQUFFLElBQUksQ0FBQyxDQUMvRTtBQUNGLENBQUMsSUFBTSxJQUNKUiwwQkFBMEIsRUFBSSxDQUFDLEVBQ2hDTSxhQUFhLEVBQUksSUFBSSxFQUNwQkMsYUFBYSxHQUFLLElBQUksRUFBSUEsYUFBYSxFQUFJLENBQUUsRUFDOUNDLGtCQUFrQixFQUFJLElBQUksQ0FDMUIsQ0FDQWlCLGlCQUFpQixDQUFHdEosb0NBQWlDLENBQUNvSSxhQUFhLENBQUUsSUFBSSxDQUFDLENBQzFFO0FBQ0YsQ0FBQyxJQUFNLElBQ0xQLDBCQUEwQixFQUFJLENBQUMsRUFDaENNLGFBQWEsR0FBSyxJQUFJLEVBQUlBLGFBQWEsRUFBSSxDQUFFLEVBQzdDRSxrQkFBa0IsR0FBSyxJQUFJLEVBQUlBLGtCQUFrQixFQUFJLENBQUUsQ0FDdEQsQ0FDQWlCLGlCQUFpQixDQUFHdEosOEJBQTJCLENBQUMsY0FBYyxDQUFFLElBQUksQ0FBQyxDQUNyRTtBQUNGLENBQUMsSUFBTSxJQUNMNkgsMEJBQTBCLEVBQUksQ0FBQyxFQUNoQ00sYUFBYSxHQUFLLElBQUksRUFBSUEsYUFBYSxFQUFJLENBQUUsRUFDN0NFLGtCQUFrQixHQUFLLElBQUksRUFBSUEsa0JBQWtCLEVBQUksQ0FBRSxDQUN0RCxDQUNBaUIsaUJBQWlCLENBQUd0Siw4QkFBMkIsQ0FBQyxHQUFHcUksa0JBQWtCLEdBQUcsQ0FBRSxJQUFJLENBQUMsQ0FDakYsQ0FDQTtBQUNGLENBQUMsSUFBTSxJQUNMUiwwQkFBMEIsR0FBSyxDQUFDLEVBQ2pDRSxvQkFBb0IsRUFBSSxDQUFDQyxvQkFBb0IsRUFDN0NHLGFBQWEsR0FBSyxJQUFJLEVBQUlDLGFBQWEsR0FBSyxJQUFJLENBQy9DLENBQ0E7QUFDQSxHQUFJQyxrQkFBa0IsR0FBSyxJQUFJLEVBQUlBLGtCQUFrQixFQUFJLENBQUMsQ0FBRSxDQUMxRGlCLGlCQUFpQixDQUFHdEosOEJBQTJCLENBQUMsY0FBYyxDQUFFLEtBQUssQ0FBQyxDQUN0RTtBQUNGLENBQUMsSUFBTSxJQUFJcUksa0JBQWtCLEdBQUssSUFBSSxFQUFJQSxrQkFBa0IsRUFBSSxDQUFDLENBQUUsQ0FDakVpQixpQkFBaUIsQ0FBR3RKLDhCQUEyQixDQUFDLEdBQUdxSSxrQkFBa0IsR0FBRyxDQUFFLEtBQUssQ0FBQyxDQUNsRixDQUNBO0FBQ0YsQ0FBQyxJQUFNLElBQ0xSLDBCQUEwQixHQUFLLENBQUMsRUFDaENFLG9CQUFvQixFQUFJLENBQUNDLG9CQUFxQixFQUMvQ0csYUFBYSxHQUFLLElBQUksRUFDckJDLGFBQWEsR0FBSyxJQUFJLEVBQUlBLGFBQWEsRUFBSSxDQUFFLEVBQzdDQyxrQkFBa0IsR0FBSyxJQUFJLEVBQUlBLGtCQUFrQixFQUFJLENBQUUsQ0FDdkQsQ0FDQWlCLGlCQUFpQixDQUFHdEosb0NBQWlDLENBQUNvSSxhQUFhLENBQUUsS0FBSyxDQUFDLENBQzNFO0FBQ0YsQ0FBQyxJQUFNLElBQ0xQLDBCQUEwQixHQUFLLENBQUMsRUFDaENFLG9CQUFvQixFQUFJLENBQUNDLG9CQUFxQixFQUMvQ0csYUFBYSxHQUFLLElBQUksRUFDckJDLGFBQWEsR0FBSyxJQUFJLEVBQUlBLGFBQWEsRUFBSSxDQUFFLEVBQzdDQyxrQkFBa0IsR0FBSyxJQUFJLEVBQUlBLGtCQUFrQixFQUFJLENBQUUsQ0FDdkQsQ0FDQWlCLGlCQUFpQixDQUFHdEosb0NBQWlDLENBQUNvSSxhQUFhLENBQUUsS0FBSyxDQUFDLENBQzNFO0FBQ0YsQ0FBQyxJQUFNLElBQ0pQLDBCQUEwQixHQUFLLENBQUMsRUFBSSxFQUFFRSxvQkFBb0IsRUFBSUMsb0JBQW9CLENBQUMsRUFDckZHLGFBQWEsR0FBSyxJQUFJLEVBQ3JCQyxhQUFhLEdBQUssSUFBSSxFQUFJQSxhQUFhLEVBQUksQ0FBRSxFQUM3Q0Msa0JBQWtCLEdBQUssSUFBSSxFQUFJQSxrQkFBa0IsRUFBSSxDQUFFLENBQ3ZELENBQ0FpQixpQkFBaUIsQ0FBR3RKLG9DQUFpQyxDQUFDb0ksYUFBYSxDQUFFLElBQUksQ0FBQyxDQUMxRTtBQUNGLENBQUMsSUFBTSxJQUNMUCwwQkFBMEIsR0FBSyxDQUFDLEVBQ2pDRSxvQkFBb0IsRUFBSSxDQUFDQyxvQkFBb0IsRUFDNUNHLGFBQWEsR0FBSyxJQUFJLEVBQUlBLGFBQWEsRUFBSSxDQUFFLENBQzdDLENBQ0FtQixpQkFBaUIsQ0FBR3RKLDhCQUEyQixDQUFDbUksYUFBYSxDQUFFLEtBQUssQ0FBQyxDQUN2RSxDQUVBLE1BQU8sQ0FBQW1CLGlCQUFpQixlQUFJM0osbUJBQUEsVUFBSTJKLGlCQUFxQixDQUFDLENBQ3hELENBQUMsQ0FFSiw0RUFBZUQsbUJBQW1CLEU7O0FDeEtsQyxtRUFBZUEsdUNBQW1CLEU7Ozs7OztBQ0RsQztBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRTs7QUNKUDtBQUVBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQ0EsS0FBTSxDQUFBTSxnQkFBZ0IsQ0FBR3ZKLElBQUEsRUFBNkMsSUFBNUMsQ0FBQ3VDLEVBQUUsQ0FBRWlILEtBQUssQ0FBRUMsUUFBMEIsQ0FBQyxDQUFBekosSUFBQSxDQUMvRCxLQUFNLEdBQUMwSixVQUFVLEdBQUVDLGFBQWEsRUFBSVAsa0JBQVEsQ0FBQyxLQUFLLENBQUMsQ0FDbkQsbUJBQ0U3SixtQkFBQSxDQUFBQSxjQUFBLG1CQUNFQSxtQkFBQSxPQUFJWSxTQUFTLENBQUVOLGtCQUEwQixFQUN0QzJKLEtBQUssY0FDTmpLLG1CQUFBLGFBQ0csR0FBRyxjQUNKQSxtQkFBQSxNQUNFWSxTQUFTLENBQUVOLFlBQW1CLENBQUcsWUFBWUEsWUFBbUIsRUFBRSxDQUFHLFVBQVcsQ0FDaEYwQyxFQUFFLENBQUUsR0FBR0EsRUFBRSxTQUFVLENBQ25CLGdCQUFlLEdBQUdBLEVBQUUsUUFBUyxDQUM3QixnQkFBZW1ILFVBQVcsQ0FDMUJJLE9BQU8sQ0FBRUEsQ0FBQSxHQUFNSCxhQUFhLENBQUMsQ0FBQ0QsVUFBVSxDQUFFLENBQzFDakosUUFBUSxDQUFFLENBQUUsRUFFWGlKLFVBQVUsQ0FDWDlKLHVDQUFvQyxDQUFDb0ssaUJBQWlCLENBQ3REcEssdUNBQW9DLENBQUNxSyxpQkFDcEMsQ0FBQyxDQUNGUCxVQUFVLGNBQ1puSyxtQkFBQSxRQUNFWSxTQUFTLENBQUVOLFlBQW9CLENBQy9CYSxHQUFHLENBQUU0SSwwQkFBYSxDQUNsQjNJLEdBQUcsQ0FBRSxlQUFnQixDQUNyQm1KLE9BQU8sQ0FBRUEsQ0FBQSxHQUFNSCxhQUFhLENBQUMsQ0FBQ0QsVUFBVSxDQUFFLENBQzNDLENBQUMsY0FDRm5LLG1CQUFBLFFBQ0VZLFNBQVMsQ0FBRU4sWUFBb0IsQ0FDL0JhLEdBQUcsQ0FBRTJJLDBCQUFXLENBQ2hCMUksR0FBRyxDQUFFLGFBQWMsQ0FDbkJtSixPQUFPLENBQUVBLENBQUEsR0FBTUgsYUFBYSxDQUFDLENBQUNELFVBQVUsQ0FBRSxDQUMzQyxDQUFDLENBRUQsR0FDRyxDQUVKLENBQUMsY0FFTG5LLG1CQUFBLFlBQ0VnRCxFQUFFLENBQUUsR0FBR0EsRUFBRSxRQUFTLENBQ2xCLGtCQUFpQixHQUFHQSxFQUFFLFNBQVUsQ0FDaEM0SCxNQUFNLENBQUUsQ0FBQ1QsVUFBVyxFQUNwQkQsUUFBa0IsQ0FDcEIsQ0FBQyxDQUVQLENBQUMsQ0FHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FDQSxLQUFNLENBQUFXLGtCQUFrQixDQUFJQyxlQUFtQixFQUFLLENBQ2xELE1BQU8sQ0FBQUEsZUFBZSxDQUFDQyxHQUFHLENBQUMsQ0FBQ0MsRUFBRSxDQUFFQyxLQUFLLEdBQUssQ0FDeEMsbUJBQ0VqTCxtQkFBQSxRQUFLa0wsR0FBRyxDQUFFRCxLQUFNLENBQUNySyxTQUFTLENBQUVOLGVBQXVCLGVBQ2pETixtQkFBQSxhQUFRZ0wsRUFBRSxDQUFDLENBQUMsQ0FBUyxDQUFDLENBQ3JCLE1BQU8sQ0FBQUEsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFLLFFBQVEsY0FDMUJoTCxtQkFBQSxhQUFPLEdBQUdnTCxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQVUsQ0FBQyxjQUMxQmhMLG1CQUFBLGFBQU8sR0FBR2dMLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBUyxDQUNyQixDQUFDLENBRVYsQ0FBQyxDQUFDLENBQ0osQ0FBQyxDQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQ0EsS0FBTSxDQUFBL0csV0FBVyxDQUFJbUgsSUFBWSxFQUFLLENBQ3BDLEdBQUlBLElBQUksR0FBS0MsU0FBUyxFQUFJRCxJQUFJLEdBQUssSUFBSSxDQUFFLENBQ3ZDLE1BQU8sSUFBSSxDQUNiLENBQUMsSUFBTSxJQUFJQSxJQUFJLEdBQUssQ0FBQyxDQUFFLENBQ3JCLE1BQU8sRUFBQyxDQUNWLENBRUEsTUFBTyxDQUFBcEYsTUFBTSxDQUFDRixJQUFJLENBQUNDLEtBQUssQ0FBQ3FGLElBQUksQ0FBRyxHQUFHLENBQUMsQ0FBQyxDQUN2QyxDQUFDLENBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQ0EsS0FBTSxDQUFBRSxtQkFBbUIsQ0FBSUMsVUFBa0MsR0FDN0QsQ0FDRUMsSUFBSSxDQUFFLENBQ0osQ0FDRW5MLHVDQUFvQyxDQUFDb0wsdUJBQXVCLENBQzVEeEgsV0FBVyxDQUFDc0gsVUFBVSxDQUFDbkosMENBQWlDLENBQUMsQ0FBQyxDQUMzRCxDQUNELENBQ0UvQix1Q0FBb0MsQ0FBQ3FMLFVBQVUsQ0FDL0N6SCxXQUFXLENBQUNzSCxVQUFVLENBQUNuSiw2QkFBb0IsQ0FBQyxDQUFDLENBQzlDLENBQ0QsQ0FDRS9CLHVDQUFvQyxDQUFDc0wsb0JBQW9CLENBQ3pEMUgsV0FBVyxDQUFDc0gsVUFBVSxDQUFDbkosdUNBQThCLENBQUMsQ0FBQyxDQUN4RCxDQUNELENBQ0UvQix1Q0FBb0MsQ0FBQ3VMLFVBQVUsQ0FDL0MzSCxXQUFXLENBQUNzSCxVQUFVLENBQUNuSiw2QkFBb0IsQ0FBQyxDQUFDLENBQzlDLENBQ0QsQ0FDRS9CLHVDQUFvQyxDQUFDd0wsYUFBYSxDQUNsRDVILFdBQVcsQ0FBQ3NILFVBQVUsQ0FBQ25KLGdDQUF1QixDQUFDLENBQUMsQ0FDakQsQ0FDRCxDQUNFL0IsdUNBQW9DLENBQUN5TCxlQUFlLENBQ3BEN0gsV0FBVyxDQUFDc0gsVUFBVSxDQUFDbkosa0NBQXlCLENBQUMsQ0FBQyxDQUNuRCxDQUNELENBQ0UvQix1Q0FBb0MsQ0FBQzBMLHNCQUFzQixDQUMzRDlILFdBQVcsQ0FBQ3NILFVBQVUsQ0FBQ25KLHlDQUFnQyxDQUFDLENBQUMsQ0FDMUQsQ0FDRCxDQUNFL0IsdUNBQW9DLENBQUMyTCxhQUFhLENBQ2xEL0gsV0FBVyxDQUFDc0gsVUFBVSxDQUFDbkosZ0NBQXVCLENBQUMsQ0FBQyxDQUNqRCxDQUNGLENBQ0Q2SixHQUFHLENBQUUsQ0FDSCxDQUNFNUwsdUNBQW9DLENBQUM2TCxpQkFBaUIsQ0FDdERqSSxXQUFXLENBQUNzSCxVQUFVLENBQUNuSixvQ0FBMkIsQ0FBQyxDQUFDLENBQ3JELENBQ0QsQ0FDRS9CLHVDQUFvQyxDQUFDOEwsWUFBWSxDQUNqRGxJLFdBQVcsQ0FBQ3NILFVBQVUsQ0FBQ25KLDhCQUFzQixDQUFDLENBQUMsQ0FDaEQsQ0FDRCxDQUNFL0IsdUNBQW9DLENBQUMrTCxnQkFBZ0IsQ0FDckRuSSxXQUFXLENBQUNzSCxVQUFVLENBQUNuSixtQ0FBMEIsQ0FBQyxDQUFDLENBQ3BELENBRUwsQ0FBQyxDQUFDLENBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FDQSxLQUFNLENBQUFrSyxpQkFBaUIsQ0FBRzlJLEtBQUEsRUFBMkMsSUFBMUMsQ0FBQytILFVBQW1DLENBQUMsQ0FBQS9ILEtBQUEsQ0FDOUQsS0FBTSxDQUFDZ0ksSUFBSSxDQUFFUyxHQUFHLENBQUMsQ0FBR1gsbUJBQW1CLENBQUNDLFVBQVUsQ0FBQyxDQUVuRCxtQkFDRXZMLG1CQUFBLFFBQUtZLFNBQVMsQ0FBRU4scUJBQTZCLGVBQzNDTixtQkFBQSxRQUFLWSxTQUFTLENBQUVOLGlCQUF5QixFQUN0Q0QsdUNBQW9DLENBQUNZLEtBQ25DLENBQUMsY0FDTmpCLG1CQUFBLENBQUFBLGNBQUEsbUJBQ0VBLG1CQUFBLENBQUNnSyxnQkFBZ0IsRUFBQ2hILEVBQUUsQ0FBRSxNQUFPLENBQUNpSCxLQUFLLENBQUU1Six1Q0FBb0MsQ0FBQ29NLFVBQVcsRUFDbEY1QixrQkFBa0IsQ0FBQ1csSUFBSSxDQUNSLENBQUMsY0FDbkJ4TCxtQkFBQSxDQUFDZ0ssZ0JBQWdCLEVBQUNoSCxFQUFFLENBQUUsS0FBTSxDQUFDaUgsS0FBSyxDQUFFNUosdUNBQW9DLENBQUNxTSxTQUFVLEVBQ2hGN0Isa0JBQWtCLENBQUNvQixHQUFHLENBQ1AsQ0FDbEIsQ0FDQyxDQUFDLENBRVYsQ0FBQyxDQUVELHdFQUFlSyxpQkFBaUIsRTs7QUM5TWhDLGlFQUFlQSxtQ0FBaUIsRTs7QUNEaEM7QUFDTztBQUNBLCtEOztBQ2FQLEtBQU0sQ0FBQUssU0FBUyxDQUFHbE0sSUFBQSxFQUFzRixJQUFyRixDQUFDbU0sVUFBVSxDQUFFQyxVQUFVLENBQUVDLFNBQVMsQ0FBRXRLLFVBQVUsQ0FBRXVLLGNBQStCLENBQUMsQ0FBQXRNLElBQUEsQ0FDakcsS0FBTSxDQUFBQyxJQUFJLENBQUdOLDhCQUFPLENBQUMsQ0FBQyxDQUV0QixtQkFDRUosbUJBQUEsT0FBSVksU0FBUyxDQUFFTixrQkFBMEIsZUFDdkNOLG1CQUFBLHdCQUNFQSxtQkFBQSxTQUFNWSxTQUFTLENBQUVOLGNBQXNCLEVBQ3BDSSxJQUFJLENBQUNLLGFBQWEsQ0FBQ1YsbUNBQWdDLENBQUM4TSxpQkFBaUIsQ0FDbEUsQ0FDSixDQUFDLGNBQ0xuTixtQkFBQSx3QkFDRUEsbUJBQUEsYUFDR1UsSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1DQUFnQyxDQUFDK00sa0JBQWtCLENBQ25FLENBQUMsY0FDUHBOLG1CQUFBLGFBQU8sSUFBSTRNLFVBQVUsRUFBUyxDQUM1QixDQUFDLGNBQ0w1TSxtQkFBQSx3QkFDRUEsbUJBQUEsYUFDR1UsSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1DQUFnQyxDQUFDZ04sTUFBTSxDQUN2RCxDQUFDLGNBQ1ByTixtQkFBQSxhQUFPLElBQUk2TSxVQUFVLEVBQVMsQ0FDNUIsQ0FBQyxjQUNMN00sbUJBQUEsd0JBQ0VBLG1CQUFBLGFBQ0crTSxjQUFjLEdBQUszSywwQ0FBaUMsQ0FBQ21MLE1BQU0sQ0FDeEQ3TSxJQUFJLENBQUNLLGFBQWEsQ0FBQ1YsbUNBQWdDLENBQUNtTixTQUFTLENBQUMsQ0FDOUQ5TSxJQUFJLENBQUNLLGFBQWEsQ0FBQ1YsbUNBQWdDLENBQUNvTixLQUFLLENBRXpELENBQUMsY0FDUHpOLG1CQUFBLGFBQU8sSUFBSThNLFNBQVMsRUFBUyxDQUMzQixDQUFDLGNBQ0w5TSxtQkFBQSx3QkFDRUEsbUJBQUEsYUFDR1UsSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1DQUFnQyxDQUFDcU4sVUFBVSxDQUMzRCxDQUFDLGNBQ1AxTixtQkFBQSxhQUFPLElBQUl3QyxVQUFVLENBQUNtTCxjQUFjLENBQUMsQ0FBQyxFQUFTLENBQzdDLENBQ0YsQ0FBQyxDQUVULENBQUMsQ0FFRCx3REFBZWhCLFNBQVMsRTs7QUN2RHhCLHlEQUFlQSxtQkFBUyxFOztBQ0R4QjtBQUNPLElBQUksaUNBQU0sK0M7O0FDWWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUNBLEtBQU0sQ0FBQWlCLG1CQUFtQixDQUFHbk4sSUFBQSxFQUl1QixJQUgvQyxDQUFDb04saUJBQWlCLENBQ2hCckYsYUFBYSxDQUNiQyxhQUFhLENBQ2JDLGtCQUF1QyxDQUFDLENBQUFqSSxJQUFBLENBQzVDLEdBQUlvTixpQkFBaUIsR0FBSyxJQUFJLENBQUUsQ0FDOUIsbUJBQU83TixtQkFBQSxPQUFJWSxTQUFTLENBQUVOLGlDQUFjLEVBQUVELHlCQUFzQixDQUFDc0gsUUFBYSxDQUFDLENBQzdFLENBQUMsSUFBTSxDQUNMLEdBQUllLGtCQUFrQixHQUFLLElBQUksRUFBSUYsYUFBYSxHQUFLLElBQUksRUFBSUMsYUFBYSxHQUFLLElBQUksQ0FBRSxDQUNuRixtQkFBT3pJLG1CQUFBLFdBQUtLLHlCQUFzQixDQUFDdUgsWUFBaUIsQ0FBQyxDQUN2RCxDQUFDLElBQU0sQ0FDTCxtQkFBTzVILG1CQUFBLE9BQUlZLFNBQVMsQ0FBRU4saUNBQWMsRUFBRUQseUJBQXNCLENBQUN5TixPQUFZLENBQUMsQ0FDNUUsQ0FDRixDQUNGLENBQUMsQ0FFRCw0RUFBZUYsbUJBQW1CLEU7O0FDckNsQyxtRUFBZUEsdUNBQW1CLEU7O0FDRGxDO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRDs7QUNqQlA7QUFDTyxJQUFJLHdCQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwQkFBUTtBQUNaLElBQUksa0NBQWdCO0FBQ3BCO0FBQ0EsSUFBSSx1Q0FBcUIscUQ7O0FDS2hDLEtBQU0sQ0FBQUcsVUFBVSxDQUFHdE4sSUFBQSxFQUEyQyxJQUExQyxDQUFDdU4saUJBQW1DLENBQUMsQ0FBQXZOLElBQUEsQ0FDdkQsS0FBTSxDQUFBQyxJQUFJLENBQUdOLDhCQUFPLENBQUMsQ0FBQyxDQUN0QixLQUFNLENBQUE2TixlQUFlLENBQUdELGlCQUFpQixDQUN2QzlHLFVBQVUsQ0FBQyxDQUFDOEcsaUJBQWlCLENBQUMsR0FBRyxFQUFFN0csT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFHLElBQUksQ0FDdEQsS0FBTSxDQUFBdkQsU0FBUyxDQUFHLEVBQUUsQ0FFcEIsbUJBQ0U1RCxtQkFBQSxRQUFLWSxTQUFTLENBQUVOLG1CQUEyQixlQUN6Q04sbUJBQUEsUUFBS1ksU0FBUyxDQUFFTixTQUFpQixlQUMvQk4sbUJBQUEsUUFBS1ksU0FBUyxDQUFFTixjQUFzQixFQUNuQ0ksSUFBSSxDQUFDSyxhQUFhLENBQUNWLDJCQUF3QixDQUFDaU8sT0FBTyxDQUNqRCxDQUFDLGNBQ050TyxtQkFBQSxRQUFLWSxTQUFTLENBQUVOLHVDQUE2QixlQUMzQ04sbUJBQUEsUUFBS1ksU0FBUyxDQUFFLEdBQUdOLGNBQXFCO0FBQ2xELGNBQWUyTixlQUFlLEVBQUlBLGVBQWUsRUFBSXJLLFNBQVMsQ0FDaER0RCx3QkFBYSxDQUNiQSwwQkFBZTtBQUM3QixXQUFZLGVBQ0FOLG1CQUFBLENBQUNnRSxjQUFjLEVBQ2JQLElBQUksQ0FBRSxZQUFhLENBQ25CUSxXQUFXLENBQUVnSyxlQUFnQixDQUM5QixDQUNFLENBQUMsY0FDTmpPLG1CQUFBLFFBQUtZLFNBQVMsQ0FBRU4sa0NBQXdCLGVBQ3RDTixtQkFBQSxDQUFDdUQscUJBQXFCLEVBQ3BCRyxLQUFLLENBQUV1SyxlQUFnQixDQUN2QnRLLGFBQWEsQ0FBRXNLLGVBQWUsRUFBSUEsZUFBZSxFQUFJckssU0FBUyxDQUFHLElBQUksQ0FBRyxLQUFNLENBQzlFQSxTQUFTLENBQUVBLFNBQVUsQ0FDckJILElBQUksQ0FBRSxZQUFhLENBQ3BCLENBQ0UsQ0FDRixDQUNGLENBQ0YsQ0FBQyxDQUVWLENBQUMsQ0FFRCwwREFBZXNLLFVBQVUsRTs7QUNsRHpCLDJCQUNBO0FBS0E7QUFVQTtBQUtBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQ08sS0FBTSxDQUFBWSxlQUFlLENBQUl4SSxLQUF3QixFQUFLLENBQzNELEtBQU0sQ0FBQXpGLElBQUksQ0FBR04sT0FBTyxDQUFDLENBQUMsQ0FFdEIsTUFBUSxDQUFBeUYsU0FBd0IsRUFDOUJBLFNBQVMsQ0FBQ00sS0FBSyxHQUFLekYsSUFBSSxDQUFDSyxhQUFhLENBQUNvRixLQUFLLENBQUMsRUFDNUNOLFNBQVMsQ0FBQ00sS0FBSyxFQUFJekYsSUFBSSxDQUFDSyxhQUFhLENBQUNvRixLQUFLLENBQUMsRUFBSU4sU0FBUyxDQUFDbkMsS0FBSyxFQUFJLElBQUssQ0FDN0UsQ0FBQyxDQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUNPLEtBQU0sQ0FBQWtMLHFCQUFxQixDQUFJQyxnQkFBd0IsRUFBSyxDQUNqRSxHQUFJQSxnQkFBZ0IsR0FBS3hELFNBQVMsQ0FBRSxDQUNsQyxNQUFPLE9BQU8sQ0FDaEIsQ0FFQSxHQUFJd0QsZ0JBQWdCLEdBQUssQ0FBQyxDQUFFLENBQzFCO0FBQ0EsTUFBTyxlQUFlLENBQ3hCLENBRUEsR0FBSUEsZ0JBQWdCLEVBQUlBLGdCQUFnQixDQUFHLENBQUMsQ0FBRSxDQUM1QyxNQUFPLElBQUkzSCxVQUFVLENBQUMsQ0FBQzJILGdCQUFnQixDQUFHLEdBQUcsRUFBRTFILE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUMvRCxDQUNGLENBQUMsQ0FFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUNBLEtBQU0sQ0FBQTJILFVBQVUsQ0FBR3JPLElBQUEsRUFBb0MsSUFBbkMsQ0FBQzhLLFVBQTRCLENBQUMsQ0FBQTlLLElBQUEsQ0FDaEQsS0FBTSxDQUFBQyxJQUFJLENBQUdOLDhCQUFPLENBQUMsQ0FBQyxDQUV0QjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxLQUFNLENBQUEyTyxxQkFBcUIsQ0FBR0EsQ0FBQy9MLEVBQVUsQ0FBRWdNLFVBQTJCLEdBQUssQ0FDekUsS0FBTSxDQUFBQyxHQUFHLENBQUdDLFVBQVUsQ0FBQ0MsSUFBSSxDQUFFbE4sUUFBUSxFQUFLQSxRQUFRLENBQUNlLEVBQUUsR0FBS0EsRUFBRSxDQUFDLENBQzdELEdBQUlpTSxHQUFHLENBQUVBLEdBQUcsQ0FBQ0QsVUFBVSxDQUFHQSxVQUFVLENBQUMsSUFDaEMsTUFBTSxJQUFJLENBQUFJLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBR3BNLEVBQUUsQ0FBQyxDQUM5RCxDQUFDLENBRUQ7QUFDQXFNLE9BQU8sQ0FBQ0MsR0FBRyxDQUNQLG1FQUFtRSxDQUNuRS9ELFVBQ0osQ0FBQyxDQUVEO0FBQ0E4RCxPQUFPLENBQUNDLEdBQUcsQ0FDUCxrQkFBa0IsQ0FDcEIvRCxVQUFVLENBQUNuSiw4QkFBcUIsQ0FBQyxHQUFLLEdBQUcsQ0FBRyxLQUFLLENBQUcsTUFDdEQsQ0FBQyxDQUNEaU4sT0FBTyxDQUFDQyxHQUFHLENBQ1AsdUJBQXVCLENBQ3pCL0QsVUFBVSxDQUFDbkosMkNBQWtDLENBQUMsQ0FBRyxNQUFNLENBQUcsS0FDNUQsQ0FBQyxDQUNEaU4sT0FBTyxDQUFDQyxHQUFHLENBQ1AscUJBQXFCLENBQ3JCVixxQkFBcUIsQ0FBQ3JELFVBQVUsQ0FBQ25KLDBDQUFpQyxDQUFDLENBQ3ZFLENBQUMsQ0FDRGlOLE9BQU8sQ0FBQ0MsR0FBRyxDQUNQLHNCQUFzQixDQUN4Qi9ELFVBQVUsQ0FBQ25KLHdDQUErQixDQUFDLEVBQUksQ0FBQyxDQUM5QyxJQUFJbUosVUFBVSxDQUFDbkosd0NBQStCLENBQUMsRUFBRSxDQUNqRCxPQUNKLENBQUMsQ0FDRGlOLE9BQU8sQ0FBQ0MsR0FBRyxDQUNQLHlCQUF5QixDQUMzQi9ELFVBQVUsQ0FBQ25KLDJDQUFrQyxDQUFDLEVBQUksQ0FBQyxDQUNqRCxJQUFJbUosVUFBVSxDQUFDbkosMkNBQWtDLENBQUMsRUFBRSxDQUNwRCxPQUNKLENBQUMsQ0FFRDtBQUNBLEtBQU0sQ0FBQXdLLFVBQVUsQ0FBR3JCLFVBQVUsQ0FBQ25KLGlDQUF3QixDQUFDLENBQ3JEbUosVUFBVSxDQUFDbkosaUNBQXdCLENBQUMsQ0FDcENBLHNDQUE2QixDQUMvQixLQUFNLENBQUFJLFVBQVUsQ0FBRytJLFVBQVUsQ0FBQ25KLG1DQUEwQixDQUFDLENBQ3ZEbUosVUFBVSxDQUFDbkosbUNBQTBCLENBQUMsQ0FDdENBLHNDQUE2QixDQUMvQixLQUFNLENBQUF5SyxVQUFVLENBQUd0QixVQUFVLENBQUNuSiw4QkFBcUIsQ0FBQyxDQUNsRG1KLFVBQVUsQ0FBQ25KLDhCQUFxQixDQUFDLENBQ2pDQSxzQ0FBNkIsQ0FDL0IsS0FBTSxDQUFBMEssU0FBUyxDQUFHdkIsVUFBVSxDQUFDbkosNkJBQW9CLENBQUMsQ0FDaERtSixVQUFVLENBQUNuSiw2QkFBb0IsQ0FBQyxDQUNoQ0Esc0NBQTZCLENBRS9CLEtBQU0sQ0FBQTJLLGNBQWMsQ0FBR3hCLFVBQVUsQ0FBQ25KLG1DQUEwQixDQUFDLENBQzdELEtBQU0sQ0FBQXNHLGtCQUFrQixDQUN0QjZDLFVBQVUsQ0FBQ25KLDBDQUFpQyxDQUFDLEVBQUksQ0FBQyxDQUNoRDhFLFVBQVUsQ0FDTixDQUFDcUUsVUFBVSxDQUFDbkosMENBQWlDLENBQUMsQ0FBRyxHQUFHLEVBQUUrRSxPQUFPLENBQUMsQ0FDbEUsQ0FBQyxDQUNELElBQUksQ0FFUjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsS0FBTSxDQUFBOEksMEJBQTBCLENBQUkzSixhQUFxQixFQUFLLENBQzVELEdBQUl5RyxjQUFjLEdBQUszSywwQ0FBaUMsQ0FBQzhOLFlBQVksQ0FBRSxDQUNyRSxHQUFJNUosYUFBYSxHQUFLLFdBQVcsQ0FBRSxDQUNqQyxNQUFPLENBQUFpRixVQUFVLENBQUM0RSxjQUFjLENBQzVCL04sNkVBQ0osQ0FBQyxDQUNDbUosVUFBVSxDQUNObkosNkVBQytELENBQ2xFLENBQ0QsSUFBSSxDQUNSLENBQ0EsR0FBSWtFLGFBQWEsR0FBSyxVQUFVLENBQUUsQ0FDaEMsTUFBTyxDQUFBaUYsVUFBVSxDQUFDNEUsY0FBYyxDQUM1Qi9OLHdFQUNKLENBQUMsQ0FDQ21KLFVBQVUsQ0FDTm5KLHdFQUErRCxDQUNsRSxDQUNELElBQUksQ0FDUixDQUNBLEdBQUlrRSxhQUFhLEdBQUssU0FBUyxDQUFFLENBQy9CLE1BQU8sQ0FBQWlGLFVBQVUsQ0FBQzRFLGNBQWMsQ0FDNUIvTixtRUFDSixDQUFDLENBQ0NtSixVQUFVLENBQ05uSixtRUFBMEQsQ0FDN0QsQ0FDRCxJQUFJLENBQ1IsQ0FDQSxHQUFJa0UsYUFBYSxHQUFLLFlBQVksQ0FBRSxDQUNsQyxNQUFPLENBQUFpRixVQUFVLENBQUM0RSxjQUFjLENBQzVCL04sdURBQ0osQ0FBQyxDQUNDbUosVUFBVSxDQUFDbkosdURBQThDLENBQUMsQ0FDMUQsSUFBSSxDQUNSLENBQ0YsQ0FFQSxHQUFJa0UsYUFBYSxHQUFLLFdBQVcsQ0FBRSxDQUNqQyxNQUFPLENBQUFpRixVQUFVLENBQUM0RSxjQUFjLENBQUMvTiwrQ0FBc0MsQ0FBQyxDQUN0RW1KLFVBQVUsQ0FBQ25KLCtDQUFzQyxDQUFDLENBQ2xELElBQUksQ0FDUixDQUNBLEdBQUlrRSxhQUFhLEdBQUssVUFBVSxDQUFFLENBQ2hDLE1BQU8sQ0FBQWlGLFVBQVUsQ0FBQzRFLGNBQWMsQ0FDNUIvTixtREFDSixDQUFDLENBQ0NtSixVQUFVLENBQUNuSixtREFBMEMsQ0FBQyxDQUN0RCxJQUFJLENBQ1IsQ0FDQSxHQUFJa0UsYUFBYSxHQUFLLFNBQVMsQ0FBRSxDQUMvQixNQUFPLENBQUFpRixVQUFVLENBQUM0RSxjQUFjLENBQUMvTiwrQ0FBc0MsQ0FBQyxDQUN0RW1KLFVBQVUsQ0FBQ25KLCtDQUFzQyxDQUFDLENBQ2xELElBQUksQ0FDUixDQUNBLEdBQUlrRSxhQUFhLEdBQUssWUFBWSxDQUFFLENBQ2xDLE1BQU8sQ0FBQWlGLFVBQVUsQ0FBQzRFLGNBQWMsQ0FDNUIvTixrREFDSixDQUFDLENBQ0NtSixVQUFVLENBQUNuSixrREFBeUMsQ0FBQyxDQUNyRCxJQUFJLENBQ1IsQ0FDRixDQUFDLENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLEtBQU0sQ0FBQXdPLDZCQUE2QixDQUFJdEssYUFBcUIsRUFBSyxDQUMvRCxHQUFJeUcsY0FBYyxHQUFLM0ssMENBQWlDLENBQUM4TixZQUFZLENBQUUsQ0FDckUsR0FBSTVKLGFBQWEsR0FBSyxXQUFXLENBQUUsQ0FDakMsTUFBTyxDQUFBaUYsVUFBVSxDQUFDNEUsY0FBYyxDQUM1Qi9OLHNFQUNKLENBQUMsQ0FDQ21KLFVBQVUsQ0FDTm5KLHNFQUE2RCxDQUNoRSxDQUNELElBQUksQ0FDUixDQUNBLEdBQUlrRSxhQUFhLEdBQUssVUFBVSxDQUFFLENBQ2hDLE1BQU8sQ0FBQWlGLFVBQVUsQ0FBQzRFLGNBQWMsQ0FDNUIvTixpRUFDSixDQUFDLENBQ0NtSixVQUFVLENBQUNuSixpRUFBd0QsQ0FBQyxDQUNwRSxJQUFJLENBQ1IsQ0FDQSxHQUFJa0UsYUFBYSxHQUFLLFNBQVMsQ0FBRSxDQUMvQixNQUFPLENBQUFpRixVQUFVLENBQUM0RSxjQUFjLENBQzVCL04sc0VBQ0osQ0FBQyxDQUNDbUosVUFBVSxDQUNObkosc0VBQTZELENBQ2hFLENBQ0QsSUFBSSxDQUNSLENBQ0EsR0FBSWtFLGFBQWEsR0FBSyxZQUFZLENBQUUsQ0FDbEMsTUFBTyxDQUFBaUYsVUFBVSxDQUFDNEUsY0FBYyxDQUFDL04seUNBQWdDLENBQUMsQ0FDaEVtSixVQUFVLENBQUNuSix5Q0FBZ0MsQ0FBQyxDQUM1QyxJQUFJLENBQ1IsQ0FDRixDQUVBLEdBQUlrRSxhQUFhLEdBQUssV0FBVyxDQUFFLENBQ2pDLE1BQU8sQ0FBQWlGLFVBQVUsQ0FBQzRFLGNBQWMsQ0FDNUIvTiwwREFDSixDQUFDLENBQ0NtSixVQUFVLENBQUNuSiwwREFBaUQsQ0FBQyxDQUM3RCxJQUFJLENBQ1IsQ0FDQSxHQUFJa0UsYUFBYSxHQUFLLFVBQVUsQ0FBRSxDQUNoQyxNQUFPLENBQUFpRixVQUFVLENBQUM0RSxjQUFjLENBQzVCL04scURBQ0osQ0FBQyxDQUNDbUosVUFBVSxDQUFDbkoscURBQTRDLENBQUMsQ0FDeEQsSUFBSSxDQUNSLENBQ0EsR0FBSWtFLGFBQWEsR0FBSyxTQUFTLENBQUUsQ0FDL0IsTUFBTyxDQUFBaUYsVUFBVSxDQUFDNEUsY0FBYyxDQUM1Qi9OLDBEQUNKLENBQUMsQ0FDQ21KLFVBQVUsQ0FBQ25KLDBEQUFpRCxDQUFDLENBQzdELElBQUksQ0FDUixDQUNBLEdBQUlrRSxhQUFhLEdBQUssWUFBWSxDQUFFLENBQ2xDLE1BQU8sQ0FBQWlGLFVBQVUsQ0FBQzRFLGNBQWMsQ0FDNUIvTixnRUFDSixDQUFDLENBQ0NtSixVQUFVLENBQUNuSixnRUFBdUQsQ0FBQyxDQUNuRSxJQUFJLENBQ1IsQ0FDRixDQUFDLENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQSxLQUVFO0FBQ0EsS0FBTSxDQUFBaVAsU0FBd0IsQ0FBRyxDQUMvQmxMLEtBQUssQ0FBRXpGLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixxQ0FBa0MsQ0FBQ2tSLFdBQVcsQ0FBQyxDQUN6RWpNLFdBQVcsQ0FBRTVFLElBQUksQ0FBQ0ssYUFBYSxDQUMzQlYsZ0RBQTZDLENBQUNrUixXQUNsRCxDQUFDLENBQ0Q5TixJQUFJLENBQUUsWUFBWSxDQUNsQkMsS0FBSyxDQUFFNkgsVUFBVSxDQUFDNEUsY0FBYyxDQUFDL04sa0RBQXlDLENBQUMsQ0FDekVtSixVQUFVLENBQUNuSixrREFBeUMsQ0FBQyxDQUNyRCxJQUFJLENBQ051RSxlQUFlLENBQUU0RSxVQUFVLENBQUNuSixxREFBNEMsQ0FBQyxDQUN2RW1KLFVBQVUsQ0FBQ25KLHFEQUE0QyxDQUFDLENBQ3hELElBQ0osQ0FBQyxDQUNELEtBQU0sQ0FBQXVQLFVBQXlCLENBQUcsQ0FDaEN4TCxLQUFLLENBQUV6RixJQUFJLENBQUNLLGFBQWEsQ0FBQ1YscUNBQWtDLENBQUN1UixZQUFZLENBQUMsQ0FDMUV0TSxXQUFXLENBQUU1RSxJQUFJLENBQUNLLGFBQWEsQ0FDM0JWLGdEQUE2QyxDQUFDdVIsWUFDbEQsQ0FBQyxDQUNEbk8sSUFBSSxDQUFFLFlBQVksQ0FDbEJDLEtBQUssQ0FBRTZILFVBQVUsQ0FBQzRFLGNBQWMsQ0FBQy9OLCtDQUFzQyxDQUFDLENBQ3RFbUosVUFBVSxDQUFDbkosK0NBQXNDLENBQUMsQ0FDbEQsSUFBSSxDQUNOdUUsZUFBZSxDQUFFNEUsVUFBVSxDQUFDbkoscURBQTRDLENBQUMsQ0FDdkVtSixVQUFVLENBQUNuSixxREFBNEMsQ0FBQyxDQUN4RCxJQUNKLENBQUMsQ0FDRCxLQUFNLENBQUEyUCxVQUF5QixDQUFHLENBQ2hDNUwsS0FBSyxDQUFFekYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHFDQUFrQyxDQUFDMlIsWUFBWSxDQUFDLENBQzFFMU0sV0FBVyxDQUFFNUUsSUFBSSxDQUFDSyxhQUFhLENBQzNCVixnREFBNkMsQ0FBQzJSLFlBQ2xELENBQUMsQ0FDRHZPLElBQUksQ0FBRSxZQUFZLENBQ2xCQyxLQUFLLENBQUU2SCxVQUFVLENBQUM0RSxjQUFjLENBQUMvTixpREFBd0MsQ0FBQyxDQUN4RW1KLFVBQVUsQ0FBQ25KLGlEQUF3QyxDQUFDLENBQ3BELElBQUksQ0FDTnVFLGVBQWUsQ0FBRTRFLFVBQVUsQ0FBQ25KLHFEQUE0QyxDQUFDLENBQ3ZFbUosVUFBVSxDQUFDbkoscURBQTRDLENBQUMsQ0FDeEQsSUFDSixDQUFDLENBQ0QsS0FBTSxDQUFBK1AsUUFBdUIsQ0FBRyxDQUM5QmhNLEtBQUssQ0FBRXpGLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixxQ0FBa0MsQ0FBQytSLFFBQVEsQ0FBQyxDQUN0RTlNLFdBQVcsQ0FBRTVFLElBQUksQ0FBQ0ssYUFBYSxDQUMzQlYsZ0RBQTZDLENBQUMrUixRQUNsRCxDQUFDLENBQ0QzTyxJQUFJLENBQUUsWUFBWSxDQUNsQkMsS0FBSyxDQUFFNkgsVUFBVSxDQUFDNEUsY0FBYyxDQUFDL04sc0NBQTZCLENBQUMsQ0FDN0RtSixVQUFVLENBQUNuSixzQ0FBNkIsQ0FBQyxDQUN6QyxJQUFJLENBQ051RSxlQUFlLENBQUU0RSxVQUFVLENBQUNuSiw2Q0FBb0MsQ0FBQyxDQUMvRG1KLFVBQVUsQ0FBQ25KLDZDQUFvQyxDQUFDLENBQ2hELElBQ0osQ0FBQyxDQUNELEtBQU0sQ0FBQW1RLFFBQXVCLENBQUcsQ0FDOUJwTSxLQUFLLENBQUV6RixJQUFJLENBQUNLLGFBQWEsQ0FBQ1YscUNBQWtDLENBQUNtUyxRQUFRLENBQUMsQ0FDdEVsTixXQUFXLENBQUU1RSxJQUFJLENBQUNLLGFBQWEsQ0FDM0JWLGdEQUE2QyxDQUFDbVMsUUFDbEQsQ0FBQyxDQUNEL08sSUFBSSxDQUFFLFlBQVksQ0FDbEJDLEtBQUssQ0FBRTZILFVBQVUsQ0FBQzRFLGNBQWMsQ0FBQy9OLHNDQUE2QixDQUFDLENBQzdEbUosVUFBVSxDQUFDbkosc0NBQTZCLENBQUMsQ0FDekMsSUFBSSxDQUNOdUUsZUFBZSxDQUFFNEUsVUFBVSxDQUFDbkosNkNBQW9DLENBQUMsQ0FDL0RtSixVQUFVLENBQUNuSiw2Q0FBb0MsQ0FBQyxDQUNoRCxJQUNKLENBQUMsQ0FDRCxLQUFNLENBQUF1USxNQUFxQixDQUFHLENBQzVCeE0sS0FBSyxDQUFFekYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHFDQUFrQyxDQUFDdVMsVUFBVSxDQUFDLENBQ3hFdE4sV0FBVyxDQUFFNUUsSUFBSSxDQUFDSyxhQUFhLENBQzNCVixnREFBNkMsQ0FBQ3VTLFVBQ2xELENBQUMsQ0FDRG5QLElBQUksQ0FBRSxZQUFZLENBQ2xCQyxLQUFLLENBQUU2SCxVQUFVLENBQUM0RSxjQUFjLENBQUMvTiwrQ0FBc0MsQ0FBQyxDQUN0RW1KLFVBQVUsQ0FBQ25KLCtDQUFzQyxDQUFDLENBQ2xELElBQUksQ0FDTnVFLGVBQWUsQ0FBRTRFLFVBQVUsQ0FBQ25KLCtDQUFzQyxDQUFDLENBQ2pFbUosVUFBVSxDQUFDbkosK0NBQXNDLENBQUMsQ0FDbEQsSUFBSSxDQUNOd0IsU0FBUyxDQUFFLEVBQ2IsQ0FBQyxDQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQSxLQUFNLENBQUFtUCxVQUF5QixDQUFHLENBQ2hDNU0sS0FBSyxDQUFFekYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHFDQUFrQyxDQUFDMlMsV0FBVyxDQUFDLENBQ3pFMU4sV0FBVyxDQUFFNUUsSUFBSSxDQUFDSyxhQUFhLENBQzNCVixnREFBNkMsQ0FBQzJTLFdBQ2xELENBQUMsQ0FDRHZQLElBQUksQ0FBRSxZQUFZLENBQ2xCQyxLQUFLLENBQUU2SCxVQUFVLENBQUM0RSxjQUFjLENBQUMvTixvQ0FBMkIsQ0FBQyxDQUMzRG1KLFVBQVUsQ0FBQ25KLG9DQUEyQixDQUFDLENBQ3ZDLElBQUksQ0FDTnVFLGVBQWUsQ0FBRTRFLFVBQVUsQ0FBQ25KLHNEQUE2QyxDQUFDLENBQ3hFbUosVUFBVSxDQUFDbkosc0RBQTZDLENBQUMsQ0FDekQsSUFDSixDQUFDLENBQ0QsS0FBTSxDQUFBK1EsSUFBbUIsQ0FBRyxDQUMxQmhOLEtBQUssQ0FBRXpGLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixxQ0FBa0MsQ0FBQytTLE1BQU0sQ0FBQyxDQUNwRTlOLFdBQVcsQ0FBRTVFLElBQUksQ0FBQ0ssYUFBYSxDQUMzQlYsZ0RBQTZDLENBQUMrUyxNQUNsRCxDQUFDLENBQ0QzUCxJQUFJLENBQUUsWUFBWSxDQUNsQkMsS0FBSyxDQUFFNkgsVUFBVSxDQUFDNEUsY0FBYyxDQUFDL04sa0NBQXlCLENBQUMsQ0FDekRtSixVQUFVLENBQUNuSixrQ0FBeUIsQ0FBQyxDQUNyQyxJQUFJLENBQ051RSxlQUFlLENBQUU0RSxVQUFVLENBQUNuSiw2Q0FBb0MsQ0FBQyxDQUMvRG1KLFVBQVUsQ0FBQ25KLDZDQUFvQyxDQUFDLENBQ2hELElBQ0osQ0FBQyxDQUVEO0FBQ0EsS0FBTSxDQUFBbVIsTUFBcUIsQ0FBRyxDQUM1QnBOLEtBQUssQ0FBRXpGLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixxQ0FBa0MsQ0FBQ21ULE1BQU0sQ0FBQyxDQUNwRWxPLFdBQVcsQ0FBRTVFLElBQUksQ0FBQ0ssYUFBYSxDQUMzQlYsZ0RBQTZDLENBQUNtVCxNQUNsRCxDQUFDLENBQ0QvUCxJQUFJLENBQUUsWUFBWSxDQUNsQkMsS0FBSyxDQUFFNkgsVUFBVSxDQUFDNEUsY0FBYyxDQUFDL04sb0NBQTJCLENBQUMsQ0FDM0RtSixVQUFVLENBQUNuSixvQ0FBMkIsQ0FBQyxDQUN2QyxJQUFJLENBQ051RSxlQUFlLENBQUU0RSxVQUFVLENBQUNuSiwrQ0FBc0MsQ0FBQyxDQUNqRW1KLFVBQVUsQ0FBQ25KLCtDQUFzQyxDQUFDLENBQ2xELElBQ0osQ0FBQyxDQUNELEtBQU0sQ0FBQXVSLFFBQXVCLENBQUcsQ0FDOUJ4TixLQUFLLENBQUV6RixJQUFJLENBQUNLLGFBQWEsQ0FBQ1YscUNBQWtDLENBQUN1VCxRQUFRLENBQUMsQ0FDdEV0TyxXQUFXLENBQUU1RSxJQUFJLENBQUNLLGFBQWEsQ0FDM0JWLGdEQUE2QyxDQUFDdVQsUUFDbEQsQ0FBQyxDQUNEblEsSUFBSSxDQUFFLFlBQVksQ0FDbEJDLEtBQUssQ0FBRTZILFVBQVUsQ0FBQzRFLGNBQWMsQ0FBQy9OLHNDQUE2QixDQUFDLENBQzdEbUosVUFBVSxDQUFDbkosc0NBQTZCLENBQUMsQ0FDekMsSUFBSSxDQUNOdUUsZUFBZSxDQUFFNEUsVUFBVSxDQUFDbkosZ0RBQXdDLENBQUMsQ0FDbkVtSixVQUFVLENBQUNuSixnREFBd0MsQ0FBQyxDQUNwRCxJQUNKLENBQUMsQ0FDRCxLQUFNLENBQUEyUixZQUEyQixDQUFHLENBQ2xDNU4sS0FBSyxDQUFFekYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHFDQUFrQyxDQUFDMlQsYUFBYSxDQUFDLENBQzNFMU8sV0FBVyxDQUFFNUUsSUFBSSxDQUFDSyxhQUFhLENBQzNCVixnREFBNkMsQ0FBQzJULGFBQ2xELENBQUMsQ0FDRHZRLElBQUksQ0FBRSxZQUFZLENBQ2xCQyxLQUFLLENBQUU2SCxVQUFVLENBQUM0RSxjQUFjLENBQUMvTixtQ0FBMEIsQ0FBQyxDQUMxRG1KLFVBQVUsQ0FBQ25KLG1DQUEwQixDQUFDLENBQ3RDLElBQUksQ0FDTnVFLGVBQWUsQ0FBRTRFLFVBQVUsQ0FBQ25KLHNEQUE2QyxDQUFDLENBQ3hFbUosVUFBVSxDQUFDbkosc0RBQTZDLENBQUMsQ0FDekQsSUFDSixDQUFDLENBQ0QsS0FBTSxDQUFBK1IsVUFBeUIsQ0FBRyxDQUNoQ2hPLEtBQUssQ0FBRXpGLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixxQ0FBa0MsQ0FBQytULFdBQVcsQ0FBQyxDQUN6RTlPLFdBQVcsQ0FBRTVFLElBQUksQ0FBQ0ssYUFBYSxDQUMzQlYsZ0RBQTZDLENBQUNnVSxlQUNsRCxDQUFDLENBQ0Q1USxJQUFJLENBQUUsWUFBWSxDQUNsQkMsS0FBSyxDQUFFNkgsVUFBVSxDQUFDNEUsY0FBYyxDQUFDL04sa0NBQXlCLENBQUMsQ0FDekRtSixVQUFVLENBQUNuSixrQ0FBeUIsQ0FBQyxDQUNyQyxJQUFJLENBQ051RSxlQUFlLENBQUU0RSxVQUFVLENBQUNuSixxREFBNEMsQ0FBQyxDQUN2RW1KLFVBQVUsQ0FBQ25KLHFEQUE0QyxDQUFDLENBQ3hELElBQ0osQ0FBQyxDQUVEO0FBQ0EsS0FBTSxDQUFBb1MsbUJBQWtDLENBQUcsQ0FDekNyTyxLQUFLLENBQUV6RixJQUFJLENBQUNLLGFBQWEsQ0FDckJWLHFDQUFrQyxDQUFDb1UsZ0JBQ3ZDLENBQUMsQ0FDRG5QLFdBQVcsQ0FBRTVFLElBQUksQ0FBQ0ssYUFBYSxDQUMzQlYsZ0RBQTZDLENBQUNvVSxnQkFDbEQsQ0FBQyxDQUNEaFIsSUFBSSxDQUFFLFNBQVMsQ0FDZkMsS0FBSyxDQUFFNkgsVUFBVSxDQUFDNEUsY0FBYyxDQUM1Qi9OLHlEQUNKLENBQUMsQ0FDQ21KLFVBQVUsQ0FBQ25KLHlEQUFnRCxDQUFDLEdBQzFEQSxtREFBMEMsQ0FDMUMsSUFBSSxDQUNKLEtBQUssQ0FDUCxJQUFJLENBQ051RSxlQUFlLENBQ2I0RSxVQUFVLENBQUM0RSxjQUFjLENBQ3JCL04seURBQ0osQ0FBQyxFQUNEbUosVUFBVSxDQUFDbkoseURBQWdELENBQUMsR0FDMURBLG1EQUEwQyxDQUMxQyxJQUFJLENBQ0osS0FDTixDQUFDLENBQ0QsS0FBTSxDQUFBd1MsU0FBd0IsQ0FBRyxDQUMvQnpPLEtBQUssQ0FBRXpGLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixxQ0FBa0MsQ0FBQ3dVLFVBQVUsQ0FBQyxDQUN4RXZQLFdBQVcsQ0FBRTVFLElBQUksQ0FBQ0ssYUFBYSxDQUMzQlYsZ0RBQTZDLENBQUN3VSxVQUNsRCxDQUFDLENBQ0RwUixJQUFJLENBQUUsWUFBWSxDQUNsQkMsS0FBSyxDQUFFNkgsVUFBVSxDQUFDNEUsY0FBYyxDQUM1Qi9OLHFEQUNKLENBQUMsQ0FDQ21KLFVBQVUsQ0FBQ25KLHFEQUE0QyxDQUFDLENBQ3hELElBQUksQ0FDTnVFLGVBQWUsQ0FBRTRFLFVBQVUsQ0FBQ25KLHFEQUE0QyxDQUFDLENBQ3ZFbUosVUFBVSxDQUFDbkoscURBQTRDLENBQUMsQ0FDeEQsSUFDSixDQUFDLENBQ0QsS0FBTSxDQUFBNFMsY0FBNkIsQ0FBRyxDQUNwQzdPLEtBQUssQ0FBRXpGLElBQUksQ0FBQ0ssYUFBYSxDQUNyQlYscUNBQWtDLENBQUM0VSxnQkFDdkMsQ0FBQyxDQUNEM1AsV0FBVyxDQUFFNUUsSUFBSSxDQUFDSyxhQUFhLENBQzNCVixnREFBNkMsQ0FBQzRVLGdCQUNsRCxDQUFDLENBQ0R4UixJQUFJLENBQUUsWUFBWSxDQUNsQkMsS0FBSyxDQUFFNkgsVUFBVSxDQUFDNEUsY0FBYyxDQUFDL04sd0NBQStCLENBQUMsQ0FDL0RtSixVQUFVLENBQUNuSix3Q0FBK0IsQ0FBQyxDQUMzQyxJQUFJLENBQ051RSxlQUFlLENBQUU0RSxVQUFVLENBQUNuSiwrQ0FBc0MsQ0FBQyxDQUNqRW1KLFVBQVUsQ0FBQ25KLCtDQUFzQyxDQUFDLENBQ2xELElBQ0osQ0FBQyxDQUNELEtBQU0sQ0FBQWdULFlBQTJCLENBQUcsQ0FDbENqUCxLQUFLLENBQUV6RixJQUFJLENBQUNLLGFBQWEsQ0FBQ1YscUNBQWtDLENBQUNnVixhQUFhLENBQUMsQ0FDM0UvUCxXQUFXLENBQUU1RSxJQUFJLENBQUNLLGFBQWEsQ0FDM0JWLGdEQUE2QyxDQUFDZ1YsYUFDbEQsQ0FBQyxDQUNENVIsSUFBSSxDQUFFLFlBQVksQ0FDbEJDLEtBQUssQ0FBRTZILFVBQVUsQ0FBQzRFLGNBQWMsQ0FBQy9OLDJDQUFrQyxDQUFDLENBQ2xFbUosVUFBVSxDQUFDbkosMkNBQWtDLENBQUMsQ0FDOUMsSUFBSSxDQUNOdUUsZUFBZSxDQUFFNEUsVUFBVSxDQUFDbkosa0RBQXlDLENBQUMsQ0FDcEVtSixVQUFVLENBQUNuSixrREFBeUMsQ0FBQyxDQUNyRCxJQUNKLENBQUMsQ0FDRCxLQUFNLENBQUFvVCxTQUF3QixDQUFHLENBQy9CclAsS0FBSyxDQUFFekYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHFDQUFrQyxDQUFDb1YsVUFBVSxDQUFDLENBQ3hFblEsV0FBVyxDQUFFNUUsSUFBSSxDQUFDSyxhQUFhLENBQzNCVixnREFBNkMsQ0FBQ29WLFVBQ2xELENBQUMsQ0FDRGhTLElBQUksQ0FBRSxZQUFZLENBQ2xCQyxLQUFLLENBQUU2SCxVQUFVLENBQUM0RSxjQUFjLENBQUMvTix3Q0FBK0IsQ0FBQyxDQUMvRG1KLFVBQVUsQ0FBQ25KLHdDQUErQixDQUFDLENBQzNDLElBQUksQ0FDTnVFLGVBQWUsQ0FBRTRFLFVBQVUsQ0FDdkJuSix1RUFBOEQsQ0FDakUsQ0FDQ21KLFVBQVUsQ0FDTm5KLHVFQUE4RCxDQUNqRSxDQUNELElBQ0osQ0FBQyxDQUVEO0FBQ0EsS0FBTSxDQUFBd1QsWUFBMkIsQ0FBRyxDQUNsQ3pQLEtBQUssQ0FBRXpGLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixxQ0FBa0MsQ0FBQ3dWLGFBQWEsQ0FBQyxDQUMzRXZRLFdBQVcsQ0FBRTVFLElBQUksQ0FBQ0ssYUFBYSxDQUMzQlYsZ0RBQTZDLENBQUN3VixhQUNsRCxDQUFDLENBQ0RwUyxJQUFJLENBQUUsU0FBUyxDQUNmQyxLQUFLLENBQUU2SCxVQUFVLENBQUM0RSxjQUFjLENBQzVCL04sb0RBQ0osQ0FBQyxDQUNDbUosVUFBVSxDQUFDbkosb0RBQTJDLENBQUMsQ0FDdkQsSUFBSSxDQUNOdUUsZUFBZSxDQUFFNEUsVUFBVSxDQUFDNEUsY0FBYyxDQUN0Qy9OLG9EQUNKLENBQUMsQ0FDQ21KLFVBQVUsQ0FBQ25KLG9EQUEyQyxDQUFDLENBQ3ZELElBQ0osQ0FBQyxDQUNELEtBQU0sQ0FBQTJULGNBQTZCLENBQUcsQ0FDcEM1UCxLQUFLLENBQUV6RixJQUFJLENBQUNLLGFBQWEsQ0FDckJWLHFDQUFrQyxDQUFDMlYsZ0JBQ3ZDLENBQUMsQ0FDRDFRLFdBQVcsQ0FBRTVFLElBQUksQ0FBQ0ssYUFBYSxDQUMzQlYsZ0RBQTZDLENBQUMyVixnQkFDbEQsQ0FBQyxDQUNEdlMsSUFBSSxDQUFFLFNBQVMsQ0FDZjtBQUNBQyxLQUFLLENBQUU2SCxVQUFVLENBQUM0RSxjQUFjLENBQUMvTiw2Q0FBb0MsQ0FBQyxDQUNwRW1KLFVBQVUsQ0FBQ25KLDZDQUFvQyxDQUFDLEVBQzlDQSwrQkFBc0IsQ0FDdEIsSUFBSSxDQUNKLEtBQUssQ0FDUCxJQUFJLENBQ051RSxlQUFlLENBQUU0RSxVQUFVLENBQUM0RSxjQUFjLENBQ3RDL04sa0RBQ0osQ0FBQyxDQUNDbUosVUFBVSxDQUFDbkosa0RBQXlDLENBQUMsQ0FDckQsSUFDSixDQUFDLENBQ0QsS0FBTSxDQUFBZ1UsT0FBc0IsQ0FBRyxDQUM3QmpRLEtBQUssQ0FBRXpGLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixxQ0FBa0MsQ0FBQ2dXLFFBQVEsQ0FBQyxDQUN0RS9RLFdBQVcsQ0FBRTVFLElBQUksQ0FBQ0ssYUFBYSxDQUMzQlYsZ0RBQTZDLENBQUNnVyxRQUNsRCxDQUFDLENBQ0Q1UyxJQUFJLENBQUUsWUFBWSxDQUNsQkMsS0FBSyxDQUFFNkgsVUFBVSxDQUFDNEUsY0FBYyxDQUFDL04sa0RBQXlDLENBQUMsQ0FDekVtSixVQUFVLENBQUNuSixrREFBeUMsQ0FBQyxDQUNyRCxJQUFJLENBQ051RSxlQUFlLENBQUU0RSxVQUFVLENBQUNuSixxREFBNEMsQ0FBQyxDQUN2RW1KLFVBQVUsQ0FBQ25KLHFEQUE0QyxDQUFDLENBQ3hELElBQ0osQ0FBQyxDQUNELEtBQU0sQ0FBQW9VLE9BQXNCLENBQUcsQ0FDN0JyUSxLQUFLLENBQUV6RixJQUFJLENBQUNLLGFBQWEsQ0FBQ1YscUNBQWtDLENBQUNvVyxRQUFRLENBQUMsQ0FDdEVuUixXQUFXLENBQUU1RSxJQUFJLENBQUNLLGFBQWEsQ0FDM0JWLGdEQUE2QyxDQUFDb1csUUFDbEQsQ0FBQyxDQUNEaFQsSUFBSSxDQUFFLFlBQVksQ0FDbEJDLEtBQUssQ0FBRTZILFVBQVUsQ0FBQzRFLGNBQWMsQ0FBQy9OLGlEQUF3QyxDQUFDLENBQ3hFbUosVUFBVSxDQUFDbkosaURBQXdDLENBQUMsQ0FDcEQsSUFBSSxDQUNOdUUsZUFBZSxDQUFFNEUsVUFBVSxDQUFDbkosNENBQW1DLENBQUMsQ0FDOURtSixVQUFVLENBQUNuSiw0Q0FBbUMsQ0FBQyxDQUMvQyxJQUNKLENBQUMsQ0FDRCxLQUFNLENBQUF3VSxPQUFzQixDQUFHLENBQzdCelEsS0FBSyxDQUFFekYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHFDQUFrQyxDQUFDd1csUUFBUSxDQUFDLENBQ3RFdlIsV0FBVyxDQUFFNUUsSUFBSSxDQUFDSyxhQUFhLENBQzNCVixnREFBNkMsQ0FBQ3dXLFFBQ2xELENBQUMsQ0FDRHBULElBQUksQ0FBRSxZQUFZLENBQ2xCQyxLQUFLLENBQUU2SCxVQUFVLENBQUM0RSxjQUFjLENBQUMvTixpREFBd0MsQ0FBQyxDQUN4RW1KLFVBQVUsQ0FBQ25KLGlEQUF3QyxDQUFDLENBQ3BELElBQUksQ0FDTnVFLGVBQWUsQ0FBRTRFLFVBQVUsQ0FBQ25KLGtEQUF5QyxDQUFDLENBQ3BFbUosVUFBVSxDQUFDbkosa0RBQXlDLENBQUMsQ0FDckQsSUFDSixDQUFDLENBRUQ7QUFDQSxLQUFNLENBQUE0VSxnQkFBK0IsQ0FBRyxDQUN0QzdRLEtBQUssQ0FBRXpGLElBQUksQ0FBQ0ssYUFBYSxDQUNyQlYscUNBQWtDLENBQUM0Vyx5QkFDdkMsQ0FBQyxDQUNEM1IsV0FBVyxDQUFFNUUsSUFBSSxDQUFDSyxhQUFhLENBQzNCVixnREFBNkMsQ0FBQzRXLHlCQUNsRCxDQUFDLENBQ0R4VCxJQUFJLENBQUUsWUFBWSxDQUNsQkMsS0FBSyxDQUFFNkgsVUFBVSxDQUFDNEUsY0FBYyxDQUFDL04sMkNBQWtDLENBQUMsQ0FDbEVtSixVQUFVLENBQUNuSiwyQ0FBa0MsQ0FBQyxDQUM5QyxJQUFJLENBQ051RSxlQUFlLENBQUU0RSxVQUFVLENBQUNuSixrREFBeUMsQ0FBQyxDQUNwRW1KLFVBQVUsQ0FBQ25KLGtEQUF5QyxDQUFDLENBQ3JELElBQ0osQ0FBQyxDQUNELEtBQU0sQ0FBQWdWLGdCQUErQixDQUFHLENBQ3RDalIsS0FBSyxDQUFFekYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHFDQUFrQyxDQUFDZ1gsYUFBYSxDQUFDLENBQzNFL1IsV0FBVyxDQUFFNUUsSUFBSSxDQUFDSyxhQUFhLENBQzNCVixnREFBNkMsQ0FBQ2dYLGFBQ2xELENBQUMsQ0FDRDVULElBQUksQ0FBRSxZQUFZLENBQ2xCQyxLQUFLLENBQUU2SCxVQUFVLENBQUM0RSxjQUFjLENBQUMvTiwyQ0FBa0MsQ0FBQyxDQUNsRW1KLFVBQVUsQ0FBQ25KLDJDQUFrQyxDQUFDLENBQzlDLElBQUksQ0FDTnVFLGVBQWUsQ0FBRTRFLFVBQVUsQ0FBQ25KLGtEQUF5QyxDQUFDLENBQ3BFbUosVUFBVSxDQUFDbkosa0RBQXlDLENBQUMsQ0FDckQsSUFDSixDQUFDLENBQ0QsS0FBTSxDQUFBb1YsYUFBNEIsQ0FBRyxDQUNuQ3JSLEtBQUssQ0FBRXpGLElBQUksQ0FBQ0ssYUFBYSxDQUNyQlYscUNBQWtDLENBQUNvWCxjQUN2QyxDQUFDLENBQ0RuUyxXQUFXLENBQUU1RSxJQUFJLENBQUNLLGFBQWEsQ0FDM0JWLGdEQUE2QyxDQUFDb1gsY0FDbEQsQ0FBQyxDQUNEaFUsSUFBSSxDQUFFLFlBQVksQ0FDbEJDLEtBQUssQ0FBRTZILFVBQVUsQ0FBQzRFLGNBQWMsQ0FBQy9OLHFDQUE0QixDQUFDLENBQzVEbUosVUFBVSxDQUFDbkoscUNBQTRCLENBQUMsQ0FDeEMsSUFBSSxDQUNOdUUsZUFBZSxDQUFFNEUsVUFBVSxDQUFDbkoscURBQTRDLENBQUMsQ0FDdkVtSixVQUFVLENBQUNuSixxREFBNEMsQ0FBQyxDQUN4RCxJQUNKLENBQUMsQ0FFRDtBQUNBLEtBQU0sQ0FBQXdWLFVBQXlCLENBQUcsQ0FDaEN6UixLQUFLLENBQUV6RixJQUFJLENBQUNLLGFBQWEsQ0FBQ1YscUNBQWtDLENBQUN3WCxXQUFXLENBQUMsQ0FDekV2UyxXQUFXLENBQUU1RSxJQUFJLENBQUNLLGFBQWEsQ0FDM0JWLGdEQUE2QyxDQUFDd1gsV0FDbEQsQ0FBQyxDQUNEcFUsSUFBSSxDQUFFLFlBQVksQ0FDbEJDLEtBQUssQ0FBRTZILFVBQVUsQ0FBQzRFLGNBQWMsQ0FBQy9OLHlDQUFnQyxDQUFDLENBQ2hFbUosVUFBVSxDQUFDbkoseUNBQWdDLENBQUMsQ0FDNUMsSUFBSSxDQUNOdUUsZUFBZSxDQUFFNEUsVUFBVSxDQUFDbkosZ0RBQXVDLENBQUMsQ0FDbEVtSixVQUFVLENBQUNuSixnREFBdUMsQ0FBQyxDQUNuRCxJQUNKLENBQUMsQ0FDRCxLQUFNLENBQUE0VixVQUF5QixDQUFHLENBQ2hDN1IsS0FBSyxDQUFFekYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHFDQUFrQyxDQUFDNFgsV0FBVyxDQUFDLENBQ3pFM1MsV0FBVyxDQUFFNUUsSUFBSSxDQUFDSyxhQUFhLENBQzNCVixnREFBNkMsQ0FBQzRYLFdBQ2xELENBQUMsQ0FDRHhVLElBQUksQ0FBRSxZQUFZLENBQ2xCQyxLQUFLLENBQUU2SCxVQUFVLENBQUM0RSxjQUFjLENBQUMvTix3Q0FBK0IsQ0FBQyxDQUMvRG1KLFVBQVUsQ0FBQ25KLHdDQUErQixDQUFDLENBQzNDLElBQUksQ0FDTnVFLGVBQWUsQ0FBRTRFLFVBQVUsQ0FBQ25KLG1EQUEwQyxDQUFDLENBQ3JFbUosVUFBVSxDQUFDbkosbURBQTBDLENBQUMsQ0FDdEQsSUFDSixDQUFDLENBRUQ7QUFDQSxLQUFNLENBQUFnVyxPQUFzQixDQUFHLENBQzdCalMsS0FBSyxDQUFFekYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHFDQUFrQyxDQUFDZ1ksUUFBUSxDQUFDLENBQ3RFL1MsV0FBVyxDQUFFNUUsSUFBSSxDQUFDSyxhQUFhLENBQzNCVixnREFBNkMsQ0FBQ2dZLFFBQ2xELENBQUMsQ0FDRDVVLElBQUksQ0FBRSxZQUFZLENBQ2xCQyxLQUFLLENBQUU2SCxVQUFVLENBQUM0RSxjQUFjLENBQzVCL04sMkRBQ0osQ0FBQyxDQUNDbUosVUFBVSxDQUFDbkosMkRBQWtELENBQUMsQ0FDOUQsSUFBSSxDQUNOdUUsZUFBZSxDQUFFNEUsVUFBVSxDQUFDbkosd0RBQStDLENBQUMsQ0FDMUVtSixVQUFVLENBQUNuSix3REFBK0MsQ0FBQyxDQUMzRCxJQUNKLENBQUMsQ0FDRCxLQUFNLENBQUFvVyxTQUF3QixDQUFHLENBQy9CclMsS0FBSyxDQUFFekYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHFDQUFrQyxDQUFDb1ksV0FBVyxDQUFDLENBQ3pFblQsV0FBVyxDQUFFNUUsSUFBSSxDQUFDSyxhQUFhLENBQzNCVixnREFBNkMsQ0FBQ3FZLGNBQ2xELENBQUMsQ0FDRGpWLElBQUksQ0FBRSxZQUFZLENBQ2xCQyxLQUFLLENBQUV1TSwwQkFBMEIsQ0FBQyxXQUFXLENBQUMsQ0FDOUN0SixlQUFlLENBQUVpSyw2QkFBNkIsQ0FBQyxXQUFXLENBQzVELENBQUMsQ0FDRCxLQUFNLENBQUErSCxRQUF1QixDQUFHLENBQzlCeFMsS0FBSyxDQUFFekYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHFDQUFrQyxDQUFDdVksUUFBUSxDQUFDLENBQ3RFdFQsV0FBVyxDQUFFNUUsSUFBSSxDQUFDSyxhQUFhLENBQzNCVixnREFBNkMsQ0FBQ3VZLFFBQ2xELENBQUMsQ0FDRG5WLElBQUksQ0FBRSxZQUFZLENBQ2xCQyxLQUFLLENBQUV1TSwwQkFBMEIsQ0FBQyxVQUFVLENBQUMsQ0FDN0N0SixlQUFlLENBQUVpSyw2QkFBNkIsQ0FBQyxVQUFVLENBQzNELENBQUMsQ0FDRCxLQUFNLENBQUFpSSxPQUFzQixDQUFHLENBQzdCMVMsS0FBSyxDQUFFekYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHFDQUFrQyxDQUFDeVksT0FBTyxDQUFDLENBQ3JFeFQsV0FBVyxDQUFFNUUsSUFBSSxDQUFDSyxhQUFhLENBQzNCVixnREFBNkMsQ0FBQ3lZLE9BQ2xELENBQUMsQ0FDRHJWLElBQUksQ0FBRSxZQUFZLENBQ2xCQyxLQUFLLENBQUV1TSwwQkFBMEIsQ0FBQyxTQUFTLENBQUMsQ0FDNUN0SixlQUFlLENBQUVpSyw2QkFBNkIsQ0FBQyxTQUFTLENBQzFELENBQUMsQ0FDRCxLQUFNLENBQUFtSSxVQUF5QixDQUFHLENBQ2hDNVMsS0FBSyxDQUFFekYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHFDQUFrQyxDQUFDMlksUUFBUSxDQUFDLENBQ3RFMVQsV0FBVyxDQUFFNUUsSUFBSSxDQUFDSyxhQUFhLENBQzNCVixnREFBNkMsQ0FBQzRZLFFBQ2xELENBQUMsQ0FDRHhWLElBQUksQ0FBRSxTQUFTLENBQ2ZDLEtBQUssQ0FBRXVNLDBCQUEwQixDQUFDLFlBQVksQ0FBQyxDQUMvQ3RKLGVBQWUsQ0FBRWlLLDZCQUE2QixDQUFDLFlBQVksQ0FBQyxDQUM1RGhOLFNBQVMsQ0FBRSxFQUNiLENBQUMsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxHQUFJLENBQUFzTCxVQUF1QixDQUFHLENBQzVCLENBQ0VsTSxFQUFFLENBQUUsZ0JBQWdCLENBQ3BCa1csU0FBUyxDQUFFeFksSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1DQUFnQyxDQUFDK1ksT0FBTyxDQUFDLENBQ3ZFcEssVUFBVSxDQUFFLENBQUNxQyxTQUFTLENBQUVNLFVBQVUsQ0FBRUksVUFBVSxDQUFFSSxRQUFRLENBQUVJLFFBQVEsQ0FBQyxDQUNuRThHLGlCQUFpQixDQUFFLENBQUMxRyxNQUFNLENBQUMsQ0FDM0JoTSxlQUFlLENBQUU0RSxVQUFVLENBQUNuSixrREFBeUMsQ0FBQyxDQUNwRW1KLFVBQVUsQ0FBQ25KLGtEQUF5QyxDQUFDLENBQ3JELElBQUksQ0FDTm1YLG1CQUFtQixDQUFFaE8sVUFBVSxDQUMzQm5KLDJEQUFrRCxDQUNyRCxDQUNDbUosVUFBVSxDQUFDbkosMkRBQWtELENBQUMsQ0FDOUQsSUFBSSxDQUNOcVgsd0JBQXdCLENBQUVsTyxVQUFVLENBQ2hDbkosa0RBQXlDLENBQzVDLENBQ0NtSixVQUFVLENBQUNuSixrREFBeUMsQ0FBQyxDQUNyRCxJQUNKLENBQUMsQ0FDRCxDQUNFWSxFQUFFLENBQUUsY0FBYyxDQUNsQmtXLFNBQVMsQ0FBRXhZLElBQUksQ0FBQ0ssYUFBYSxDQUN6QlYsbUNBQWdDLENBQUNzWixZQUNyQyxDQUFDLENBQ0QzSyxVQUFVLENBQUUsQ0FBQytELFVBQVUsQ0FBRUksSUFBSSxDQUFDLENBQzlCa0csaUJBQWlCLENBQUUsQ0FBQzFHLE1BQU0sQ0FBQyxDQUMzQmhNLGVBQWUsQ0FBRTRFLFVBQVUsQ0FBQ25KLGlEQUF3QyxDQUFDLENBQ25FbUosVUFBVSxDQUFDbkosaURBQXdDLENBQUMsQ0FDcEQsSUFBSSxDQUNObVgsbUJBQW1CLENBQUVoTyxVQUFVLENBQzNCbkosMERBQWlELENBQ3BELENBQ0NtSixVQUFVLENBQUNuSiwwREFBaUQsQ0FBQyxDQUM3RCxJQUFJLENBQ05xWCx3QkFBd0IsQ0FBRWxPLFVBQVUsQ0FDaENuSixrREFBeUMsQ0FDNUMsQ0FDQ21KLFVBQVUsQ0FBQ25KLGtEQUF5QyxDQUFDLENBQ3JELElBQ0osQ0FBQyxDQUNELENBQ0VZLEVBQUUsQ0FBRSxnQkFBZ0IsQ0FDcEJrVyxTQUFTLENBQUV4WSxJQUFJLENBQUNLLGFBQWEsQ0FDekJWLG1DQUFnQyxDQUFDeVosYUFDckMsQ0FBQyxDQUNEOUssVUFBVSxDQUFFLENBQUN1RSxNQUFNLENBQUVJLFFBQVEsQ0FBRUksWUFBWSxDQUFFSSxVQUFVLENBQUMsQ0FDeERrRixpQkFBaUIsQ0FBRSxDQUFDMUcsTUFBTSxDQUFDLENBQzNCaE0sZUFBZSxDQUFFNEUsVUFBVSxDQUFDbkosaURBQXdDLENBQUMsQ0FDbkVtSixVQUFVLENBQUNuSixpREFBd0MsQ0FBQyxDQUNwRCxJQUFJLENBQ05tWCxtQkFBbUIsQ0FBRWhPLFVBQVUsQ0FDM0JuSiwwREFBaUQsQ0FDcEQsQ0FDQ21KLFVBQVUsQ0FBQ25KLDBEQUFpRCxDQUFDLENBQzdELElBQUksQ0FDTnFYLHdCQUF3QixDQUFFbE8sVUFBVSxDQUNoQ25KLGtEQUF5QyxDQUM1QyxDQUNDbUosVUFBVSxDQUFDbkosa0RBQXlDLENBQUMsQ0FDckQsSUFDSixDQUFDLENBQ0QsQ0FDRVksRUFBRSxDQUFFLGVBQWUsQ0FDbkJrVyxTQUFTLENBQUV4WSxJQUFJLENBQUNLLGFBQWEsQ0FDekJWLG1DQUFnQyxDQUFDNFosYUFDckMsQ0FBQyxDQUNEakwsVUFBVSxDQUFFLENBQ1Z3RixtQkFBbUIsQ0FDbkJJLFNBQVMsQ0FDVEksY0FBYyxDQUNkSSxZQUFZLENBQ1pJLFNBQVMsQ0FDVixDQUNENkQsaUJBQWlCLENBQUUsQ0FBQzFHLE1BQU0sQ0FBQyxDQUMzQmhNLGVBQWUsQ0FBRTRFLFVBQVUsQ0FBQ25KLGtEQUF5QyxDQUFDLENBQ3BFbUosVUFBVSxDQUFDbkosa0RBQXlDLENBQUMsQ0FDckQsSUFBSSxDQUNObVgsbUJBQW1CLENBQUVoTyxVQUFVLENBQzNCbkosMkRBQWtELENBQ3JELENBQ0NtSixVQUFVLENBQUNuSiwyREFBa0QsQ0FBQyxDQUM5RCxJQUFJLENBQ05xWCx3QkFBd0IsQ0FBRWxPLFVBQVUsQ0FDaENuSixrREFBeUMsQ0FDNUMsQ0FDQ21KLFVBQVUsQ0FBQ25KLGtEQUF5QyxDQUFDLENBQ3JELElBQ0osQ0FBQyxDQUNELENBQ0VZLEVBQUUsQ0FBRSxhQUFhLENBQ2pCa1csU0FBUyxDQUFFeFksSUFBSSxDQUFDSyxhQUFhLENBQ3pCVixtQ0FBZ0MsQ0FBQytaLFdBQ3JDLENBQUMsQ0FDRHBMLFVBQVUsQ0FBRSxDQUFDNEcsWUFBWSxDQUFFRyxjQUFjLENBQUVLLE9BQU8sQ0FBRUksT0FBTyxDQUFFSSxPQUFPLENBQUMsQ0FDckV5QyxpQkFBaUIsQ0FBRSxDQUFDMUcsTUFBTSxDQUFDLENBQzNCaE0sZUFBZSxDQUFFNEUsVUFBVSxDQUFDbkosb0RBQTJDLENBQUMsQ0FDdEVtSixVQUFVLENBQUNuSixvREFBMkMsQ0FBQyxDQUN2RCxJQUFJLENBQ05tWCxtQkFBbUIsQ0FBRWhPLFVBQVUsQ0FDM0JuSiw2REFBb0QsQ0FDdkQsQ0FDQ21KLFVBQVUsQ0FBQ25KLDZEQUFvRCxDQUFDLENBQ2hFLElBQUksQ0FDTnFYLHdCQUF3QixDQUFFbE8sVUFBVSxDQUNoQ25KLGtEQUF5QyxDQUM1QyxDQUNDbUosVUFBVSxDQUFDbkosa0RBQXlDLENBQUMsQ0FDckQsSUFDSixDQUFDLENBQ0QsQ0FDRVksRUFBRSxDQUFFLGlCQUFpQixDQUNyQmtXLFNBQVMsQ0FBRXhZLElBQUksQ0FBQ0ssYUFBYSxDQUN6QlYsbUNBQWdDLENBQUNrYSxlQUNyQyxDQUFDLENBQ0R2TCxVQUFVLENBQUUsQ0FBQ2dJLGdCQUFnQixDQUFFSSxnQkFBZ0IsQ0FBRUksYUFBYSxDQUFDLENBQy9ENkIsaUJBQWlCLENBQUUsQ0FBQzFHLE1BQU0sQ0FBQyxDQUMzQmhNLGVBQWUsQ0FBRTRFLFVBQVUsQ0FBQ25KLG9EQUEyQyxDQUFDLENBQ3RFbUosVUFBVSxDQUFDbkosb0RBQTJDLENBQUMsQ0FDdkQsSUFBSSxDQUNObVgsbUJBQW1CLENBQUVoTyxVQUFVLENBQzNCbkosNkRBQW9ELENBQ3ZELENBQ0NtSixVQUFVLENBQUNuSiw2REFBb0QsQ0FBQyxDQUNoRSxJQUFJLENBQ05xWCx3QkFBd0IsQ0FBRWxPLFVBQVUsQ0FDaENuSixrREFBeUMsQ0FDNUMsQ0FDQ21KLFVBQVUsQ0FBQ25KLGtEQUF5QyxDQUFDLENBQ3JELElBQ0osQ0FBQyxDQUNELENBQ0VZLEVBQUUsQ0FBRSxhQUFhLENBQ2pCa1csU0FBUyxDQUFFeFksSUFBSSxDQUFDSyxhQUFhLENBQ3pCVixtQ0FBZ0MsQ0FBQ3FhLFdBQ3JDLENBQUMsQ0FDRDFMLFVBQVUsQ0FBRSxDQUFDNEksVUFBVSxDQUFFSSxVQUFVLENBQUMsQ0FDcENxQixpQkFBaUIsQ0FBRSxDQUFDMUcsTUFBTSxDQUFDLENBQzNCaE0sZUFBZSxDQUFFNEUsVUFBVSxDQUFDbkosZ0RBQXVDLENBQUMsQ0FDbEVtSixVQUFVLENBQUNuSixnREFBdUMsQ0FBQyxDQUNuRCxJQUFJLENBQ05tWCxtQkFBbUIsQ0FBRWhPLFVBQVUsQ0FDM0JuSix5REFBZ0QsQ0FDbkQsQ0FDQ21KLFVBQVUsQ0FBQ25KLHlEQUFnRCxDQUFDLENBQzVELElBQUksQ0FDTnFYLHdCQUF3QixDQUFFbE8sVUFBVSxDQUNoQ25KLGtEQUF5QyxDQUM1QyxDQUNDbUosVUFBVSxDQUFDbkosa0RBQXlDLENBQUMsQ0FDckQsSUFDSixDQUFDLENBQ0QsQ0FDRVksRUFBRSxDQUFFLFVBQVUsQ0FDZGtXLFNBQVMsQ0FBRXhZLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixtQ0FBZ0MsQ0FBQ3dhLFFBQVEsQ0FBQyxDQUN4RTdMLFVBQVUsQ0FBRSxDQUFDb0osT0FBTyxDQUFFSSxTQUFTLENBQUVLLE9BQU8sQ0FBRUYsUUFBUSxDQUFDLENBQ25EVSxpQkFBaUIsQ0FBRSxDQUFDTixVQUFVLENBQUMsQ0FDL0JwUyxlQUFlLENBQUU0RSxVQUFVLENBQUNuSixvREFBMkMsQ0FBQyxDQUN0RW1KLFVBQVUsQ0FBQ25KLG9EQUEyQyxDQUFDLENBQ3ZELElBQUksQ0FDTm1YLG1CQUFtQixDQUFFaE8sVUFBVSxDQUMzQm5KLDZEQUFvRCxDQUN2RCxDQUNDbUosVUFBVSxDQUFDbkosNkRBQW9ELENBQUMsQ0FDaEUsSUFBSSxDQUNOcVgsd0JBQXdCLENBQUVsTyxVQUFVLENBQ2hDbkosNERBQW1ELENBQ3RELENBQ0NtSixVQUFVLENBQUNuSiw0REFBbUQsQ0FBQyxDQUMvRCxJQUNKLENBQUMsQ0FDRixDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLEdBQUkySyxjQUFjLEdBQUszSywwQ0FBaUMsQ0FBQzZZLFdBQVcsQ0FBRSxDQUNwRTtBQUVBbE0scUJBQXFCLENBQUMsZ0JBQWdCLENBQUUsQ0FBQ29ELFFBQVEsQ0FBQyxDQUFDLENBQ25EcEQscUJBQXFCLENBQUMsY0FBYyxDQUFFLENBQUNnRSxVQUFVLENBQUMsQ0FBQyxDQUNuRGhFLHFCQUFxQixDQUFDLGVBQWUsQ0FBRSxDQUFDeUYsbUJBQW1CLENBQUVJLFNBQVMsQ0FBRVEsWUFBWSxDQUFFSSxTQUFTLENBQUMsQ0FBQyxDQUNqR3pHLHFCQUFxQixDQUFDLGFBQWEsQ0FBRSxDQUFDcUgsT0FBTyxDQUFFSSxPQUFPLENBQUVJLE9BQU8sQ0FBQyxDQUFDLENBQ2pFN0gscUJBQXFCLENBQUMsaUJBQWlCLENBQUUsQ0FBQ2lJLGdCQUFnQixDQUFFUSxhQUFhLENBQUMsQ0FBQyxDQUMzRXpJLHFCQUFxQixDQUFDLFVBQVUsQ0FBRSxDQUFDeUosU0FBUyxDQUFFSyxPQUFPLENBQUVGLFFBQVEsQ0FBQyxDQUFDLENBQ25FLENBRUEsR0FBSTVMLGNBQWMsR0FBSzNLLDBDQUFpQyxDQUFDOE4sWUFBWSxDQUFFLENBQ3JFO0FBQ0FoQixVQUFVLENBQUdBLFVBQVUsQ0FBQ2dNLE1BQU0sQ0FBRWpaLFFBQVEsRUFBS0EsUUFBUSxDQUFDZSxFQUFFLEdBQUssVUFBVSxDQUFDLENBQ3hFO0FBQ0FrTSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUNGLFVBQVUsQ0FBRyxDQUFDd0osU0FBUyxDQUFFRyxRQUFRLENBQUVFLE9BQU8sQ0FBQyxDQUMzRCxDQUVBLEtBQU0sQ0FBQXNDLFdBQVcsQ0FBRy9ZLCtDQUFzQyxDQUFDaVosSUFBSSxDQUFFQyxJQUFJLEVBQUssQ0FDeEUsTUFBTyxDQUFBL1AsVUFBVSxDQUFDbkosaUNBQXdCLENBQUMsQ0FBQ21aLFVBQVUsQ0FBQ0QsSUFBSSxDQUFDLENBQzlELENBQUMsQ0FBQyxDQUVGLEtBQU0sQ0FBQWhULGVBQWUsQ0FBR2lELFVBQVUsQ0FBQ25KLG1DQUEwQixDQUFDLENBQzlEO0FBQ0EsS0FBTSxDQUFBcVosYUFBYSxDQUFHLENBQUNuVCxlQUFlLEVBQ3BDaUQsVUFBVSxDQUFDbkosMkNBQWtDLENBQUMsRUFDOUNtSixVQUFVLENBQUNuSiwwREFBaUQsQ0FBQyxHQUFLLENBQUMsQ0FDckUsS0FBTSxDQUFBdVosY0FBYyxDQUFHUixXQUFXLEVBQUksQ0FBQ00sYUFBYSxDQUVwRDtBQUNBLEtBQU0sQ0FBQUcsZ0JBQWdCLENBQUdULFdBQVcsQ0FDbEM1UCxVQUFVLENBQUNuSix3RUFBK0QsQ0FBQyxDQUMzRW1KLFVBQVUsQ0FBQ25KLCtDQUFzQyxDQUFDLENBQUcsQ0FBQyxDQUN0RG1KLFVBQVUsQ0FBQ25KLCtDQUFzQyxDQUFDLENBQ2xELElBQUksQ0FDTjtBQUNGO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsS0FBTSxDQUFBMFosYUFBYSxDQUFHNU0sVUFBVSxDQUFDbkUsR0FBRyxDQUFFOUksUUFBUSxHQUFNLENBQ2xEZSxFQUFFLENBQUVmLFFBQVEsQ0FBQ2UsRUFBRSxDQUVmO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFDSWxDLFlBQVksQ0FBRSxJQUFhLENBRTNCbUosS0FBSyxjQUNIakssbUJBQUEsQ0FBQzhCLG1CQUFRLEVBQ1BDLElBQUksQ0FBRUUsUUFBUSxDQUFDaVgsU0FBVSxDQUN6QnpYLGVBQWUsQ0FBRVEsUUFBUSxDQUFDMEUsZUFBZ0IsQ0FDM0MsQ0FDRixDQUNEb1YsT0FBTyxjQUNML2IsbUJBQUEsQ0FBQUEsY0FBQSxNQUVHaUMsUUFBUSxDQUFDK00sVUFBVSxDQUNmakUsR0FBRyxDQUFDLENBQUNsRixTQUFjLENBQUVvRixLQUFhLEdBQUssQ0FDdEMsbUJBQU9qTCxtQkFBQSxDQUFDMkYsb0JBQVMsRUFBQ3VGLEdBQUcsQ0FBRSxNQUFNRCxLQUFLLEVBQUcsQ0FBQ3BGLFNBQVMsQ0FBRUEsU0FBVSxDQUFFLENBQUMsQ0FDaEUsQ0FBQyxDQUFDLGNBR043RixtQkFBQSxRQUFLWSxTQUFTLENBQUVOLGNBQXNCLEVBQ25DRCxrQ0FBK0IsQ0FBQzRiLEdBQzlCLENBQUMsQ0FHTGhhLFFBQVEsQ0FBQ29YLGlCQUFpQixDQUFDdE8sR0FBRyxDQUFDLENBQUNsRixTQUFjLENBQUVvRixLQUFhLEdBQUssQ0FDakUsbUJBQ0VqTCxtQkFBQSxDQUFDMkYsb0JBQVMsRUFDUnVGLEdBQUcsQ0FBRSxNQUFNRCxLQUFLLEVBQUcsQ0FDbkJwRixTQUFTLENBQUVBLFNBQVUsQ0FDckJ0RCxRQUFRLENBQ05nSixVQUFVLENBQUNuSiw4QkFBcUIsQ0FBQyxHQUFLLEdBQUcsQ0FBRyxLQUFLLENBQUcsSUFDckQsQ0FDREksVUFBVSxDQUFFQSxVQUFXLENBQ3hCLENBQUMsQ0FFTixDQUFDLENBQ0QsQ0FDSCxDQUNEMFosUUFBUSxDQUFFLEtBQ1osQ0FBQyxDQUFDLENBQUMsQ0FFSCxtQkFDRWxjLG1CQUFBLFVBQU9ZLFNBQVMsQ0FBRU4sbUJBQTJCLENBQUMsVUFBUyxPQUFRLGVBRTdETixtQkFBQSxDQUFDMk0sb0JBQVMsRUFDUkMsVUFBVSxDQUFFQSxVQUFXLENBQ3ZCQyxVQUFVLENBQUVBLFVBQVcsQ0FDdkJDLFNBQVMsQ0FBRUEsU0FBVSxDQUNyQnRLLFVBQVUsQ0FBRUEsVUFBVyxDQUN2QnVLLGNBQWMsQ0FBRXhCLFVBQVUsQ0FBQ25KLG1DQUEwQixDQUFFLENBQ3hELENBQUMsY0FHRnBDLG1CQUFBLENBQUNzTSw0QkFBaUIsRUFBQ2YsVUFBVSxDQUFFQSxVQUFXLENBQUUsQ0FBQyxjQUc3Q3ZMLG1CQUFBLFFBQUtZLFNBQVMsQ0FBRU4sY0FBc0IsZUFFcENOLG1CQUFBLFFBQUtZLFNBQVMsQ0FBRU4sU0FBaUIsRUFDOUJELHlCQUFzQixDQUFDaWMsUUFDckIsQ0FBQyxjQUdOdGMsbUJBQUEsUUFBS1ksU0FBUyxDQUFFTixnQkFBd0IsZUFDdENOLG1CQUFBLENBQUM0Tiw4QkFBbUIsRUFDbEJDLGlCQUFpQixDQUNmdEMsVUFBVSxDQUFDbkosc0NBQTZCLENBQUMsR0FBSyxJQUFJLENBQ2hEbUosVUFBVSxDQUFDbkosc0NBQTZCLENBQUMsQ0FDekMsS0FDSCxDQUNEb0csYUFBYSxDQUNYK0MsVUFBVSxDQUFDbkosd0NBQStCLENBQUMsRUFBSSxDQUFDLENBQzlDbUosVUFBVSxDQUFDbkosd0NBQStCLENBQUMsQ0FDM0MsSUFDSCxDQUNEcUcsYUFBYSxDQUNYOEMsVUFBVSxDQUFDbkosMkNBQWtDLENBQUMsRUFBSSxDQUFDLENBQ2pEbUosVUFBVSxDQUFDbkosMkNBQWtDLENBQUMsQ0FDOUMsSUFDSCxDQUNEc0csa0JBQWtCLENBQUVBLGtCQUFtQixDQUN4QyxDQUNFLENBQUMsY0FFTjFJLG1CQUFBLFFBQUtZLFNBQVMsQ0FBRU4sUUFBZ0IsZUFDOUJOLG1CQUFBLENBQUNpSSw2QkFBa0IsRUFDakJDLDBCQUEwQixDQUN4QnFELFVBQVUsQ0FBQ25KLDZDQUFvQyxDQUNoRCxDQUNEK0YsdUJBQXVCLENBQ3JCb0QsVUFBVSxDQUFDbkosMERBQWlELENBQzdELENBQ0RnRyxvQkFBb0IsQ0FDbEJtRCxVQUFVLENBQUNuSiwyQ0FBa0MsQ0FDOUMsQ0FDRGlHLG9CQUFvQixDQUNsQmtELFVBQVUsQ0FBQ25KLHNEQUE2QyxDQUN6RCxDQUNEbUcsaUJBQWlCLENBQ2ZnRCxVQUFVLENBQUNuSiwrQ0FBc0MsQ0FBQyxFQUNsREEsK0NBQXNDLENBQUNpWixJQUFJLENBQUVDLElBQUksRUFBSyxDQUNwRCxNQUFPLENBQUEvUCxVQUFVLENBQUNuSixpQ0FBd0IsQ0FBQyxDQUFDbVosVUFBVSxDQUFDRCxJQUFJLENBQUMsQ0FDOUQsQ0FBQyxDQUNGLENBQ0Q5UyxhQUFhLENBQ1grQyxVQUFVLENBQUNuSix3Q0FBK0IsQ0FBQyxFQUFJLENBQUMsQ0FDOUNtSixVQUFVLENBQUNuSix3Q0FBK0IsQ0FBQyxDQUMzQyxJQUNILENBQ0RxRyxhQUFhLENBQ1g4QyxVQUFVLENBQUNuSiwyQ0FBa0MsQ0FBQyxFQUFJLENBQUMsQ0FDakRtSixVQUFVLENBQUNuSiwyQ0FBa0MsQ0FBQyxDQUM5QyxJQUNILENBQ0RzRyxrQkFBa0IsQ0FBRUEsa0JBQW1CLENBQ3ZDSixlQUFlLENBQ2JpRCxVQUFVLENBQUNuSixtQ0FBMEIsQ0FDdEMsQ0FDRixDQUFDLGNBQ0ZwQyxtQkFBQSxDQUFDMEosOEJBQW1CLEVBQ2xCeEIsMEJBQTBCLENBQ3hCcUQsVUFBVSxDQUFDbkosNkNBQW9DLENBQ2hELENBQ0RnRyxvQkFBb0IsQ0FDbEJtRCxVQUFVLENBQUNuSiwyQ0FBa0MsQ0FDOUMsQ0FDRGlHLG9CQUFvQixDQUNsQmtELFVBQVUsQ0FBQ25KLHNEQUE2QyxDQUN6RCxDQUNEb0csYUFBYSxDQUNYK0MsVUFBVSxDQUFDbkosd0NBQStCLENBQUMsRUFBSSxDQUFDLENBQzlDbUosVUFBVSxDQUFDbkosd0NBQStCLENBQUMsQ0FDM0MsSUFDSCxDQUNEcUcsYUFBYSxDQUNYOEMsVUFBVSxDQUFDbkosMkNBQWtDLENBQUMsRUFBSSxDQUFDLENBQ2pEbUosVUFBVSxDQUFDbkosMkNBQWtDLENBQUMsQ0FDOUMsSUFDSCxDQUNEc0csa0JBQWtCLENBQUVBLGtCQUFtQixDQUN4QyxDQUNFLENBQ0YsQ0FBQyxDQUVMaVQsY0FBYyxlQUNiM2IsbUJBQUEsQ0FBQytOLHFCQUFVLEVBQUNDLGlCQUFpQixDQUFFNE4sZ0JBQWlCLENBQUUsQ0FBQyxDQUNwREgsYUFBYSxlQUNaemIsbUJBQUEsQ0FBQzhHLG9CQUFTLEVBQ1JDLFVBQVUsQ0FBRXdFLFVBQVUsQ0FBQ25KLDJDQUFrQyxDQUFFLENBQzNENEUseUJBQXlCLENBQUU0VSxnQkFBaUIsQ0FDN0MsQ0FBQyxjQUlKNWIsbUJBQUEsTUFDRVksU0FBUyxDQUFFTixnQkFBd0IsQ0FDbkN1YyxJQUFJLENBQ0ZuYyxJQUFJLENBQUNvYyxNQUFNLEdBQUssSUFBSSxDQUNsQixHQUFHMWEsNENBQW1DLENBQUM0YSxFQUFFLFlBQVlwUSxVQUFVLEVBQUUsQ0FDakUsR0FBR3hLLDRDQUFtQyxDQUFDNmEsRUFBRSxZQUFZclEsVUFBVSxFQUNsRSxDQUNEc1EsTUFBTSxDQUFFLFFBQVMsQ0FDakJDLEdBQUcsQ0FBQyxZQUFZLGVBRWhCbmQsbUJBQUEsQ0FBQ3lPLFVBQU0sRUFBQ2hMLElBQUksQ0FBQyxRQUFRLENBQUM3QyxTQUFTLENBQUVOLGVBQXVCLGVBQ3RETixtQkFBQSxRQUFLWSxTQUFTLENBQUVOLGVBQXVCLGVBQ3JDTixtQkFBQSxRQUFLWSxTQUFTLENBQUVOLFVBQWtCLEVBQy9CRCx5QkFBc0IsQ0FBQ2tkLGFBQWEsQ0FBQ3RjLEtBQ25DLENBQUMsY0FFTmpCLG1CQUFBLENBQUMwTyxRQUFJLENBQUM4TyxNQUFNLEVBQUMsYUFBWTljLElBQUksQ0FBQ0ssYUFBYSxDQUFDVix5QkFBc0IsQ0FBQ2tkLGFBQWEsQ0FBQ0UsUUFBUSxDQUFDQyxPQUFPLENBQUUsQ0FBRSxDQUNsRyxDQUNDLENBQ1AsQ0FBQyxjQUdIMWQsbUJBQUEsQ0FBQ3dPLGFBQVMsRUFBQ21QLGVBQWUsQ0FBRSxJQUFLLENBQUNDLEtBQUssQ0FBRTlCLGFBQWMsQ0FBQ2xiLFNBQVMsQ0FBQyxhQUFhLENBQUUsQ0FBQyxjQUduRlosbUJBQUEsUUFBS1ksU0FBUyxDQUFFTixXQUFtQixFQUNoQ0Qsa0NBQStCLENBQUNZLEtBQzlCLENBQ0EsQ0FBQyxDQUVaLENBQUMsQ0FFRCwwREFBZTZOLFVBQVUsRTs7QUNodEN6QiwwREFBZUEscUJBQVUsRTs7QUNGekIsa0RBQWUsb0JBQW9COztBQ0FuQywyQ0FBZSxvQkFBb0I7O0FDQW5DLGdEQUFlLG9CQUFvQjs7QUNBbkMsMkNBQWUsb0JBQW9COztBQ0FuQyxnREFBZSxvQkFBb0I7O0FDQW5DLG9EQUFlLG9CQUFvQjs7QUNBbkMsMkNBQWUsb0JBQW9COztBQ0FuQywrQ0FBZSxvQkFBb0I7Ozs7QUNBbkMsOENBQWUsb0JBQW9COztBQ0FuQztBQUNPO0FBQ0E7QUFDQTtBQUNBLDJFOztBQ0FQO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFNQSxLQUFNLENBQUE0UCxhQUFhLENBQUdBLENBQUEsR0FBTSxDQUMxQixLQUFNLENBQUFoZSxJQUFJLENBQUdOLDhCQUFPLENBQUMsQ0FBQyxDQUN0QixLQUFNLENBQUN1ZSxLQUFLLENBQUVDLFdBQVcsQ0FBQyxDQUFHYixnQ0FBYSxDQUFDLENBQUMsQ0FFNUMsbUJBQ0UvZCxtQkFBQSxVQUFPWSxTQUFTLENBQUVOLHNCQUE4QixlQUc5Q04sbUJBQUEsV0FBUWtCLFFBQVEsQ0FBRSxDQUFFLENBQUNOLFNBQVMsQ0FBRU4sa0JBQTBCLEVBQ3ZESSxJQUFJLENBQUNLLGFBQWEsQ0FBQ1Ysd0NBQXFDLENBQUMyZSxRQUFRLENBQzVELENBQUMsY0FHVGhmLG1CQUFBLE1BQUdrQixRQUFRLENBQUUsQ0FBRSxFQUNaUixJQUFJLENBQUNLLGFBQWEsQ0FBQ1Ysd0NBQXFDLENBQUM0ZSxXQUFXLENBQUMsQ0FFcEVMLFdBQVcsQ0FBR3hjLG9DQUEyQixDQUFDK2MsU0FBUyxlQUNuRG5mLG1CQUFBLFFBQUtrQixRQUFRLENBQUUsQ0FBRSxDQUFDTixTQUFTLENBQUVOLGlCQUF5QixDQUFDYSxHQUFHLENBQUU2YyxhQUFTLENBQ25FNWMsR0FBRyxDQUFFVixJQUFJLENBQUNLLGFBQWEsQ0FBQ1YsbURBQWdELENBQUNpQixJQUFJLENBQUUsQ0FDaEYsQ0FBQyxDQUVIWixJQUFJLENBQUNLLGFBQWEsQ0FBQ1Ysd0NBQXFDLENBQUNnZixXQUFXLENBQUMsQ0FFcEVULFdBQVcsQ0FBR3hjLG9DQUEyQixDQUFDK2MsU0FBUyxlQUNuRG5mLG1CQUFBLFFBQUtrQixRQUFRLENBQUUsQ0FBRSxDQUFDTixTQUFTLENBQUVOLGlCQUF5QixDQUFDYSxHQUFHLENBQUU4YyxNQUFXLENBQ3JFN2MsR0FBRyxDQUFFVixJQUFJLENBQUNLLGFBQWEsQ0FBQ1YsbURBQWdELENBQUNpZixNQUFNLENBQUUsQ0FDbEYsQ0FBQyxDQUVINWUsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHdDQUFxQyxDQUFDa2YsV0FBVyxDQUFDLENBRXBFWCxXQUFXLENBQUd4YyxvQ0FBMkIsQ0FBQytjLFNBQVMsZUFDbkRuZixtQkFBQSxRQUFLa0IsUUFBUSxDQUFFLENBQUUsQ0FBQ04sU0FBUyxDQUFFTixpQkFBeUIsQ0FBQ2EsR0FBRyxDQUFFK2MsV0FBVyxDQUNyRTljLEdBQUcsQ0FBRVYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1EQUFnRCxDQUFDbWYsTUFBTSxDQUFFLENBQ2xGLENBQUMsQ0FFSDllLElBQUksQ0FBQ0ssYUFBYSxDQUFDVix3Q0FBcUMsQ0FBQ29mLFdBQVcsQ0FBQyxDQU9yRS9lLElBQUksQ0FBQ0ssYUFBYSxDQUFDVix3Q0FBcUMsQ0FBQ3FmLFdBQVcsQ0FDcEUsQ0FBQyxjQUdKMWYsbUJBQUEsTUFBR2tCLFFBQVEsQ0FBRSxDQUFFLENBQUNOLFNBQVMsQ0FBRU4sb0JBQTRCLEVBQ3BESSxJQUFJLENBQUNLLGFBQWEsQ0FBQ1Ysd0NBQXFDLENBQUN1ZixRQUFRLENBQ2pFLENBQUMsY0FHSjVmLG1CQUFBLE1BQUdrQixRQUFRLENBQUUsQ0FBRSxFQUNaUixJQUFJLENBQUNLLGFBQWEsQ0FBQ1Ysd0NBQXFDLENBQUN3ZixXQUFXLENBQUMsQ0FFcEVqQixXQUFXLENBQUd4YyxvQ0FBMkIsQ0FBQytjLFNBQVMsZUFDbkRuZixtQkFBQSxRQUFLa0IsUUFBUSxDQUFFLENBQUUsQ0FBQ04sU0FBUyxDQUFFTixpQkFBeUIsQ0FBQ2EsR0FBRyxDQUFFbWQsTUFBVyxDQUNyRWxkLEdBQUcsQ0FBRVYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1EQUFnRCxDQUFDeWYsS0FBSyxDQUFFLENBQ2pGLENBQUMsQ0FFSHBmLElBQUksQ0FBQ0ssYUFBYSxDQUFDVix3Q0FBcUMsQ0FBQzBmLFdBQVcsQ0FBQyxDQUVwRW5CLFdBQVcsQ0FBR3hjLG9DQUEyQixDQUFDK2MsU0FBUyxlQUNuRG5mLG1CQUFBLFFBQUtrQixRQUFRLENBQUUsQ0FBRSxDQUFDTixTQUFTLENBQUVOLGlCQUF5QixDQUFDYSxHQUFHLENBQUVnZCxNQUFXLENBQ3JFL2MsR0FBRyxDQUFFVixJQUFJLENBQUNLLGFBQWEsQ0FBQ1YsbURBQWdELENBQUMyZixNQUFNLENBQUUsQ0FDbEYsQ0FBQyxDQUVIdGYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHdDQUFxQyxDQUFDNGYsV0FBVyxDQUNwRSxDQUFDLENBSUZyQixXQUFXLENBQUd4YyxvQ0FBMkIsQ0FBQytjLFNBQVMsZUFDbkRuZixtQkFBQSxNQUFHa0IsUUFBUSxDQUFFLENBQUUsRUFDWlIsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHdDQUFxQyxDQUFDNmYsV0FBVyxDQUFDLGNBQ3RFbGdCLG1CQUFBLFFBQUtrQixRQUFRLENBQUUsQ0FBRSxDQUFDTixTQUFTLENBQUVOLGlCQUF5QixDQUFDYSxHQUFHLENBQUVxZCwyQkFBYyxDQUN4RXBkLEdBQUcsQ0FBRVYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1EQUFnRCxDQUFDOGYsVUFBVSxDQUFFLENBQ3RGLENBQUMsQ0FDRHpmLElBQUksQ0FBQ0ssYUFBYSxDQUFDVix3Q0FBcUMsQ0FBQytmLFdBQVcsQ0FDcEUsQ0FBQyxDQUtKeEIsV0FBVyxDQUFHeGMsb0NBQTJCLENBQUMrYyxTQUFTLGVBQ25EbmYsbUJBQUEsTUFBR2tCLFFBQVEsQ0FBRSxDQUFFLEVBQ1pSLElBQUksQ0FBQ0ssYUFBYSxDQUFDVix3Q0FBcUMsQ0FBQ2dnQixXQUFXLENBQUMsY0FDdEVyZ0IsbUJBQUEsUUFBS2tCLFFBQVEsQ0FBRSxDQUFFLENBQUNOLFNBQVMsQ0FBRU4saUJBQXlCLENBQUNhLEdBQUcsQ0FBRW9kLFVBQWMsQ0FDeEVuZCxHQUFHLENBQUVWLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixtREFBZ0QsQ0FBQ2lnQixVQUFVLENBQUUsQ0FDdEYsQ0FBQyxDQUNENWYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHdDQUFxQyxDQUFDa2dCLFdBQVcsQ0FDcEUsQ0FBQyxDQUtKM0IsV0FBVyxDQUFHeGMsb0NBQTJCLENBQUMrYyxTQUFTLGVBQ3BEbmYsbUJBQUEsTUFBR2tCLFFBQVEsQ0FBRSxDQUFFLEVBQ1pSLElBQUksQ0FBQ0ssYUFBYSxDQUFDVix3Q0FBcUMsQ0FBQ21nQixXQUFXLENBQUMsY0FDdEV4Z0IsbUJBQUEsUUFBS2tCLFFBQVEsQ0FBRSxDQUFFLENBQUNOLFNBQVMsQ0FBRU4saUJBQXlCLENBQUNhLEdBQUcsQ0FBRWlkLFdBQVcsQ0FDckVoZCxHQUFHLENBQUVWLElBQUksQ0FBQ0ssYUFBYSxDQUFDVixtREFBZ0QsQ0FBQ29nQixPQUFPLENBQUUsQ0FDbkYsQ0FBQyxDQUNEL2YsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHdDQUFxQyxDQUFDcWdCLFdBQVcsQ0FBQyxjQUN0RTFnQixtQkFBQSxRQUFLa0IsUUFBUSxDQUFFLENBQUUsQ0FBQ04sU0FBUyxDQUFFTixpQkFBeUIsQ0FBQ2EsR0FBRyxDQUFFc2QsU0FBYSxDQUN2RXJkLEdBQUcsQ0FBRVYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1EQUFnRCxDQUFDc2dCLFNBQVMsQ0FBRSxDQUNyRixDQUFDLENBQ0RqZ0IsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHdDQUFxQyxDQUFDdWdCLFdBQVcsQ0FBQyxjQUN0RTVnQixtQkFBQSxRQUFLa0IsUUFBUSxDQUFFLENBQUUsQ0FBQ04sU0FBUyxDQUFFTixpQkFBeUIsQ0FBQ2EsR0FBRyxDQUFFa2QsZUFBVSxDQUNwRWpkLEdBQUcsQ0FBRVYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLG1EQUFnRCxDQUFDd2dCLEtBQUssQ0FBRSxDQUNqRixDQUFDLENBQ0RuZ0IsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHdDQUFxQyxDQUFDeWdCLFdBQVcsQ0FDcEUsQ0FBQyxDQUtIbEMsV0FBVyxDQUFHeGMsb0NBQTJCLENBQUMrYyxTQUFTLGVBQ25EbmYsbUJBQUEsTUFBR2tCLFFBQVEsQ0FBRSxDQUFFLEVBQ1pSLElBQUksQ0FBQ0ssYUFBYSxDQUFDVix3Q0FBcUMsQ0FBQzBnQixXQUFXLENBQUMsY0FDdEUvZ0IsbUJBQUEsUUFBS2tCLFFBQVEsQ0FBRSxDQUFFLENBQUNOLFNBQVMsQ0FBRU4saUJBQXlCLENBQUNhLEdBQUcsQ0FBRXFkLDJCQUFjLENBQ3hFcGQsR0FBRyxDQUFFVixJQUFJLENBQUNLLGFBQWEsQ0FBQ1YsbURBQWdELENBQUM4ZixVQUFVLENBQUUsQ0FDdEYsQ0FBQyxDQUNEemYsSUFBSSxDQUFDSyxhQUFhLENBQUNWLHdDQUFxQyxDQUFDMmdCLFdBQVcsQ0FDcEUsQ0FFQSxDQUFDLENBRVosQ0FBQyxDQUVELGdFQUFldEMsYUFBYSxFOztBQy9KNUIsNkRBQWVBLDJCQUFhLEU7O0FDUTVCLEtBQU0sQ0FBQXVDLFlBQVksQ0FBR3hnQixJQUFBLEVBSUksSUFKSCxDQUNwQkcsU0FBUyxDQUNUc2dCLGlCQUFpQixDQUNqQkMsSUFDaUIsQ0FBQyxDQUFBMWdCLElBQUEsQ0FDbEIsbUJBQ0VULG1CQUFBLFFBQUtZLFNBQVMsQ0FBRUEsU0FBVSxFQU10QnNnQixpQkFBaUIsY0FDZmxoQixtQkFBQSxDQUFDOE8scUJBQVUsRUFDVHZELFVBQVUsQ0FBRTJWLGlCQUFrQixDQUM5QkMsSUFBSSxDQUFFQSxJQUFLLENBQ1osQ0FBQyxjQUNGbmhCLG1CQUFBLENBQUMwZSx3QkFBYSxLQUFFLENBRWpCLENBQUMsQ0FFVixDQUFDLENBRUQsaURBQWV1QyxZQUFZLEU7O0FDakMzQjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QixrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZUFBZTtBQUM5RDtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGVBQWU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZUFBZTtBQUM5RDtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FB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RUEsUUFBUyxDQUFDLENBQ3hCLENBQ2MsQ0FBQyxjQUV2Qmp2QixtQkFBQSxDQUFDdTNCLG1DQUFvQixtQkFDbkJ2M0IsbUJBQUEsQ0FBQ3FzQixRQUFJLEVBQUMrSSxPQUFPLENBQUUsQ0FBQ3hILEdBQUcsQ0FBRSxDQUFDLENBQUUsQ0FBQ2tLLE1BQU0sQ0FBRSxDQUFDbEssR0FBRyxDQUFFLEVBQUUsQ0FBRSxDQUFDQSxHQUFHLENBQUUsRUFBRyxlQUNsRDV0QixtQkFBQSxXQUFLSyxtQ0FBZ0MsQ0FBQzYzQixLQUFVLENBQUMsY0FDakRsNEIsbUJBQUEsVUFBSUssbUNBQWdDLENBQUM4M0IsTUFBVSxDQUFDLGNBQ2hEbjRCLG1CQUFBLFVBQUlLLG1DQUFnQyxDQUFDKzNCLE1BQVUsQ0FBQyxjQUNoRHA0QixtQkFBQSxVQUFJSyxtQ0FBZ0MsQ0FBQ2c0QixNQUFVLENBQzNDLENBQUMsY0FFUHI0QixtQkFBQSxDQUFDcXNCLFFBQUksRUFBQytJLE9BQU8sQ0FBRSxDQUFDeEgsR0FBRyxDQUFFLENBQUMsQ0FBRSxDQUFDa0ssTUFBTSxDQUFFLENBQUNsSyxHQUFHLENBQUUsRUFBRSxDQUFFLENBQUNBLEdBQUcsQ0FBRSxFQUFHLGVBQ2xENXRCLG1CQUFBLFdBQUtLLHNDQUFtQyxDQUFDNjNCLEtBQVUsQ0FBQyxjQUNwRGw0QixtQkFBQSxVQUFJSyxzQ0FBbUMsQ0FBQyszQixNQUFVLENBQUMsY0FDbkRwNEIsbUJBQUEsVUFBSUssc0NBQW1DLENBQUNnNEIsTUFBVSxDQUM5QyxDQUNjLENBRWhCLENBQUMsQ0FFWCxDQUFDLENBRUQsMENBQWVaLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0V4cGxvcmVEYXRhQm94L0V4cGxvcmVEYXRhQm94Lm1vZHVsZS5zY3NzPzk4ODciLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9FeHBsb3JlRGF0YUJveC9FeHBsb3JlRGF0YUJveC50c3g/NDFjNyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0V4cGxvcmVEYXRhQm94L2luZGV4LnRzPzczZDIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcy5qcz9lMjllIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZi5qcz8zMzIwIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvUHJpbWl0aXZlLmpzPzJlZjMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Qcm9wZXJ0eUtleS5qcz9lZDk4Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5LmpzPzY4YWQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRoSG9sZXMuanM/M2U3MCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcz83Y2VhIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlUmVzdC5qcz8yOTk4Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkuanM/MmQ5NSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL2NvbW1vbi5qcz9iOTNlIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vdmVjNC5qcz84OWJiIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3dlYi1tZXJjYXRvci9kaXN0L2VzbS9tYXRoLXV0aWxzLmpzP2Q5MDYiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9tYXQ0LmpzPzQ1ODkiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS92ZWMyLmpzPzFhNzEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS92ZWMzLmpzPzg5MDIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvd2ViLW1lcmNhdG9yL2Rpc3QvZXNtL2Fzc2VydC5qcz9hYTdhIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3dlYi1tZXJjYXRvci9kaXN0L2VzbS93ZWItbWVyY2F0b3ItdXRpbHMuanM/NzM1MiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC93ZWItbWVyY2F0b3IvZGlzdC9lc20vZml0LWJvdW5kcy5qcz84MTdlIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3dlYi1tZXJjYXRvci9kaXN0L2VzbS9nZXQtYm91bmRzLmpzPzQwZjMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvd2ViLW1lcmNhdG9yL2Rpc3QvZXNtL3dlYi1tZXJjYXRvci12aWV3cG9ydC5qcz8xYWQ2Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3dlYi1tZXJjYXRvci9kaXN0L2VzbS9ub3JtYWxpemUtdmlld3BvcnQtcHJvcHMuanM/YzNkOCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC93ZWItbWVyY2F0b3IvZGlzdC9lc20vZmx5LXRvLXZpZXdwb3J0LmpzPzNjMjgiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvd2ViLW1lcmNhdG9yL2Rpc3QvZXNtL2luZGV4LmpzP2U1YjMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvdmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdC9tb2R1bGUuanM/ZTI0NSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwvZGlzdC9SZXNpemVPYnNlcnZlci5lcy5qcz82ZmVhIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrLmpzPzJhNDgiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanM/Y2Q0NSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvZ2xvYmFscy5qcz9lN2FlIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy9zdHlsZS11dGlscy5qcz9lMmRhIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9tYXBib3gvbWFwYm94LmpzPzljN2QiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL21hcGJveGdsLmJyb3dzZXIuanM/ZDdkNCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvbWF0aC11dGlscy5qcz9mOTFhIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy9hc3NlcnQuanM/ODA0NyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvbWFwLXN0YXRlLmpzPzRmYjEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL21hcC1jb25zdHJhaW50cy5qcz8yMWNiIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL21hcC1jb250ZXh0LmpzP2M2N2EiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL3VzZS1pc29tb3JwaGljLWxheW91dC1lZmZlY3QuanM/NGY3MSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvdGVycmFpbi5qcz8xMDFiIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL3N0YXRpYy1tYXAuanM/NjhkMCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvdHJhbnNpdGlvbi90cmFuc2l0aW9uLWludGVycG9sYXRvci5qcz80YWQ0Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcz8wYWYwIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzLmpzPzgwNTIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcz9lNzJhIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mLmpzPzFiMGIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL3RyYW5zaXRpb24vdHJhbnNpdGlvbi11dGlscy5qcz84ZDM2Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy90cmFuc2l0aW9uL3ZpZXdwb3J0LWZseS10by1pbnRlcnBvbGF0b3IuanM/NDg3MiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvdHJhbnNpdGlvbi9saW5lYXItaW50ZXJwb2xhdG9yLmpzPzRiMGUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL3RyYW5zaXRpb24vaW5kZXguanM/MmJiOSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvdHJhbnNpdGlvbi1tYW5hZ2VyLmpzP2MzMzQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS91dGlscy9oYW1tZXItb3ZlcnJpZGVzLmpzPzNjNzYiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS91dGlscy9oYW1tZXIuYnJvd3Nlci5qcz9iNjk4Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL21qb2xuaXIuanMvZGlzdC9lc20vaW5wdXRzL2lucHV0LmpzPzBjNDMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS9jb25zdGFudHMuanM/ZjQyNSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9tam9sbmlyLmpzL2Rpc3QvZXNtL3V0aWxzL2dsb2JhbHMuanM/ZTE0MSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9tam9sbmlyLmpzL2Rpc3QvZXNtL2lucHV0cy93aGVlbC1pbnB1dC5qcz8wNTNlIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL21qb2xuaXIuanMvZGlzdC9lc20vaW5wdXRzL21vdmUtaW5wdXQuanM/YmI0MCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9tam9sbmlyLmpzL2Rpc3QvZXNtL2lucHV0cy9rZXktaW5wdXQuanM/NDMyYSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9tam9sbmlyLmpzL2Rpc3QvZXNtL2lucHV0cy9jb250ZXh0bWVudS1pbnB1dC5qcz81ZWQxIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL21qb2xuaXIuanMvZGlzdC9lc20vdXRpbHMvZXZlbnQtdXRpbHMuanM/MjU2MiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9tam9sbmlyLmpzL2Rpc3QvZXNtL3V0aWxzL2V2ZW50LXJlZ2lzdHJhci5qcz80NzUzIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL21qb2xuaXIuanMvZGlzdC9lc20vZXZlbnQtbWFuYWdlci5qcz9kMTcxIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL21qb2xuaXIuanMvZGlzdC9lc20vaW5kZXguanM/MDllZSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvbWFwLWNvbnRyb2xsZXIuanM/MmM1MSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9pbnRlcmFjdGl2ZS1tYXAuanM/ODZkYiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvZGVlcC1lcXVhbC5qcz82NTAyIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL3NvdXJjZS5qcz82ZWU0Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanM/N2E2ZSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllcy5qcz8zYzVkIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL2xheWVyLmpzPzlmZjciLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvdXNlLW1hcC1jb250cm9sLmpzPzgzYjciLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvYmFzZS1jb250cm9sLmpzP2MzNTciLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvZHJhZ2dhYmxlLWNvbnRyb2wuanM/MmY3NCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvY3Jpc3AtcGl4ZWwuanM/ODhhZCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9tYXJrZXIuanM/MDA4ZCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvZHluYW1pYy1wb3NpdGlvbi5qcz9hZDM5Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL3BvcHVwLmpzPzk5MzYiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvYXR0cmlidXRpb24tY29udHJvbC5qcz8yMzEyIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL2Z1bGxzY3JlZW4tY29udHJvbC5qcz8xMDM2Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy9nZW9sb2NhdGUtdXRpbHMuanM/ZDM2YiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9nZW9sb2NhdGUtY29udHJvbC5qcz9hYzMwIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy92ZXJzaW9uLmpzP2IyNzgiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvbmF2aWdhdGlvbi1jb250cm9sLmpzP2ExYzUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvc2NhbGUtY29udHJvbC5qcz9lNzIwIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9vdmVybGF5cy9jYW52YXMtb3ZlcmxheS5qcz84NTMzIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9vdmVybGF5cy9odG1sLW92ZXJsYXkuanM/Y2Q3ZCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vb3ZlcmxheXMvc3ZnLW92ZXJsYXkuanM/OGU1MCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvc2V0LXJ0bC10ZXh0LXBsdWdpbi5qcz8wMGNmIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9pbmRleC5qcz9jMWIzIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0B0dXJmL2hlbHBlcnMvZGlzdC9lcy9pbmRleC5qcz8yOTI1Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0B0dXJmL21ldGEvZGlzdC9lcy9pbmRleC5qcz80ZTU4Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0B0dXJmL2Jib3gvZGlzdC9lcy9pbmRleC5qcz9jZTFjIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2N1YmljLmpzP2U0MmQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtdXNlL2VzbS91c2VMb2NhbFN0b3JhZ2UuanM/NTI4ZiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0Rpc2FkdmFudGFnZURvdC9EaXNhZHZhbnRhZ2VEb3QubW9kdWxlLnNjc3M/ZGY3NSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0Rpc2FkdmFudGFnZURvdC9EaXNhZHZhbnRhZ2VEb3QudHN4PzNiOTQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9EaXNhZHZhbnRhZ2VEb3QvaW5kZXgudHN4PzgzNDIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9DYXRlZ29yeS9DYXRlZ29yeS5tb2R1bGUuc2Nzcz82OTkyIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvQ2F0ZWdvcnkvQ2F0ZWdvcnkudHN4PzVjNjIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9DYXRlZ29yeS9pbmRleC50c3g/YTkxMSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC10b29sdGlwL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzPzY5YzUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtdG9vbHRpcC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL2J5dGVzVG9VdWlkLmpzPzVlN2YiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtdG9vbHRpcC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3Y0LmpzPzdlZjQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtdG9vbHRpcC9kaXN0L2luZGV4LmVzLmpzP2U5YjkiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9JbmRpY2F0b3IvSW5kaWNhdG9yLm1vZHVsZS5zY3NzPzFjOWQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL2luZm8uc3ZnPzI1MDMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9JbmRpY2F0b3IvSW5kaWNhdG9yLnRzeD9mMmJhIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvRG9udXRDb3B5L0RvbnV0Q29weS5tb2R1bGUuc2Nzcz85MGExIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvRG9udXRDb3B5L0RvbnV0Q29weS50c3g/NjE4ZSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0RvbnV0Q29weS9pbmRleC50cz9mMmQxIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvSW5kaWNhdG9yL2luZGV4LnRzeD9lNmY1Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvUHJpb3JpdGl6YXRpb25Db3B5L1ByaW9yaXRpemF0aW9uQ29weS50c3g/MjZhYyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL1ByaW9yaXRpemF0aW9uQ29weS9pbmRleC50cz85NWQ4Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvUHJpb3JpdGl6YXRpb25Db3B5Mi9Qcmlvcml0aXphdGlvbkNvcHkyLnRzeD9kMTczIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvUHJpb3JpdGl6YXRpb25Db3B5Mi9pbmRleC50cz8xYWFmIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvVHJhY3REZW1vZ3JhcGhpY3MvVHJhY3REZW1vZ3JhcGhpY3MubW9kdWxlLnNjc3M/MDgxMiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL1RyYWN0RGVtb2dyYXBoaWNzL1RyYWN0RGVtb2dyYXBoaWNzLnRzeD81NGYyIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvVHJhY3REZW1vZ3JhcGhpY3MvaW5kZXgudHM/NjM2ZiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL1RyYWN0SW5mby9UcmFjdEluZm8ubW9kdWxlLnNjc3M/Yzg4NiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL1RyYWN0SW5mby9UcmFjdEluZm8udHN4PzQ0ZWYiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9UcmFjdEluZm8vaW5kZXgudHM/NTgwYiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL1RyYWN0UHJpb3JpdGl6YXRpb24vVHJhY3RQcmlvcml0aXphdGlvbi5tb2R1bGUuc2Nzcz85NzllIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvVHJhY3RQcmlvcml0aXphdGlvbi9UcmFjdFByaW9yaXRpemF0aW9uLnRzeD84MGFmIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvVHJhY3RQcmlvcml0aXphdGlvbi9pbmRleC50cz84ODk0Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvQXJlYURldGFpbC9hcmVhRGV0YWlsLm1vZHVsZS5zY3NzPzRjMzYiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9Jc2xhbmRDb3B5L0lzbGFuZENvcHkubW9kdWxlLnNjc3M/MWU0NCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0lzbGFuZENvcHkvSXNsYW5kQ29weS50c3g/Njc1NSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0FyZWFEZXRhaWwvQXJlYURldGFpbC50c3g/NzIyYyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0FyZWFEZXRhaWwvaW5kZXgudHN4PzA5OTciLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL2FkZC5zdmc/MTE2NiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy91c3dkcy9kaXN0L2ltZy91c2EtaWNvbnMvc2VhcmNoLnN2Zz8zM2E4Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3Vzd2RzL2Rpc3QvaW1nL3VzYS1pY29ucy9teV9sb2NhdGlvbi5zdmc/NDYzYSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy91c3dkcy9kaXN0L2ltZy91c2EtaWNvbnMvcGVvcGxlLnN2Zz8wNjZiIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3Vzd2RzL2Rpc3QvaW1nL3VzYS1pY29ucy9maWxlX3VwbG9hZC5zdmc/NWM1MCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy91c3dkcy9kaXN0L2ltZy91c2EtaWNvbnMvY2hlY2suc3ZnPzRkOTciLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvaW1hZ2VzL3NpZGVQYW5lbEljb25zL3B1enpsZS5zdmc/ODE2OSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9pbWFnZXMvc2lkZVBhbmVsSWNvbnMvYmVsbC1jdXJ2ZS5zdmc/YTA5MCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9pbWFnZXMvc2lkZVBhbmVsSWNvbnMvcGllLWNoYXJ0LnN2Zz83ZTJjIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvU2lkZVBhbmVsSW5mby9TaWRlUGFuZWxJbmZvLm1vZHVsZS5zY3NzPzljNTQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9TaWRlUGFuZWxJbmZvL1NpZGVQYW5lbEluZm8udHN4P2YxOGEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9TaWRlUGFuZWxJbmZvL2luZGV4LnRzeD9iOWI3Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvbWFwSW5mb1BhbmVsLnRzeD84ODQzIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL2pzLXNlYXJjaC9kaXN0L2VzbS9qcy1zZWFyY2guanM/Yjk5OSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL01hcFNlYXJjaE1lc3NhZ2UvTWFwU2VhcmNoTWVzc2FnZS5tb2R1bGUuc2Nzcz85NzRmIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvTWFwU2VhcmNoTWVzc2FnZS9NYXBTZWFyY2hNZXNzYWdlLnRzeD8zZmFhIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvTWFwU2VhcmNoTWVzc2FnZS9pbmRleC50c3g/YzliMSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL01hcFNlYXJjaC9NYXBTZWFyY2gubW9kdWxlLnNjc3M/N2U1NyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL01hcFNlYXJjaC9NYXBTZWFyY2gudHN4Pzk2OWMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9NYXBTZWFyY2gvaW5kZXgudHN4P2I2MzEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9NYXBUcmFjdExheWVycy9NYXBUcmFjdExheWVycy50c3g/NzUxMyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL01hcFRyaWJhbExheWVycy9NYXBUcmliYWxMYXllcnMudHN4P2QyNTQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy90ZXJyaXRvcnlGb2N1c0NvbnRyb2wubW9kdWxlLnNjc3M/MDAwYyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL3RlcnJpdG9yeUZvY3VzQ29udHJvbC50c3g/MTRlNSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0o0ME1hcC5tb2R1bGUuc2Nzcz9iN2RiIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvQ3JlYXRlUmVwb3J0UGFuZWwvQ3JlYXRlUmVwb3J0UGFuZWwubW9kdWxlLnNjc3M/OWFlYiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy91c3dkcy9kaXN0L2ltZy91c2EtaWNvbnMvY2xvc2Uuc3ZnPzE2ZGIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9DcmVhdGVSZXBvcnRQYW5lbC9DcmVhdGVSZXBvcnRQYW5lbC50c3g/MDY1MyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0NyZWF0ZVJlcG9ydFBhbmVsL2luZGV4LnRzeD9lNTkyIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvSjQwTWFwLnRzeD9hZjc3Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL3BhZ2VzL2luZGV4LnRzeD80MWUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHZhciBmaWxlRG93bkljb24gPSBcIkV4cGxvcmVEYXRhQm94LW1vZHVsZS0tZmlsZURvd25JY29uLS1FTHBSZlwiO1xuZXhwb3J0IHZhciBzdW1tYXJ5Qm94Q29udGFpbmVyID0gXCJFeHBsb3JlRGF0YUJveC1tb2R1bGUtLXN1bW1hcnlCb3hDb250YWluZXItLTdEblRDXCI7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7U3VtbWFyeUJveCwgU3VtbWFyeUJveENvbnRlbnQsIFN1bW1hcnlCb3hIZWFkaW5nfSBmcm9tICdAdHJ1c3N3b3Jrcy9yZWFjdC11c3dkcyc7XG5pbXBvcnQge3VzZUludGx9IGZyb20gJ2dhdHNieS1wbHVnaW4taW50bCc7XG5cbmltcG9ydCAqIGFzIEVYUExPUkVfQ09QWSBmcm9tICcuLi8uLi9kYXRhL2NvcHkvZXhwbG9yZSc7XG5cbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuL0V4cGxvcmVEYXRhQm94Lm1vZHVsZS5zY3NzJztcblxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IGZpbGVEb3duSWNvbiBmcm9tICcvbm9kZV9tb2R1bGVzL3Vzd2RzL2Rpc3QvaW1nL3VzYS1pY29ucy9maWxlX2Rvd25sb2FkLnN2Zyc7XG5cblxuZXhwb3J0IGludGVyZmFjZSBJRXhwbG9yZURhdGFCb3hQcm9wcyB7fVxuXG5jb25zdCBFeHBsb3JlRGF0YUJveCA9ICh7fTogSUV4cGxvcmVEYXRhQm94UHJvcHMpID0+IHtcbiAgY29uc3QgaW50bCA9IHVzZUludGwoKTtcblxuICByZXR1cm4gKFxuICAgIDxTdW1tYXJ5Qm94IGNsYXNzTmFtZT17c3R5bGVzLnN1bW1hcnlCb3hDb250YWluZXJ9PlxuXG4gICAgICA8U3VtbWFyeUJveEhlYWRpbmcgaGVhZGluZ0xldmVsPSdoMic+XG4gICAgICAgIHtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLkVYUExPUkVfREFUQV9CT1guVElUTEUpfVxuICAgICAgICA8aW1nIHRhYkluZGV4PXswfSBjbGFzc05hbWU9e3N0eWxlcy5maWxlRG93bkljb259IHNyYz17ZmlsZURvd25JY29ufVxuICAgICAgICAgIGFsdD17aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRfU1RBVEVfSUNPTl9BTFRfVEVYVC5QTFVTKX1cbiAgICAgICAgLz5cbiAgICAgIDwvU3VtbWFyeUJveEhlYWRpbmc+XG5cbiAgICAgIDxTdW1tYXJ5Qm94Q29udGVudD5cbiAgICAgICAge0VYUExPUkVfQ09QWS5FWFBMT1JFX0RBVEFfQk9YX0JPRFl9XG4gICAgICA8L1N1bW1hcnlCb3hDb250ZW50PlxuXG4gICAgPC9TdW1tYXJ5Qm94PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRXhwbG9yZURhdGFCb3g7XG4iLCJpbXBvcnQgRXhwbG9yZURhdGFCb3ggZnJvbSAnLi9FeHBsb3JlRGF0YUJveCc7XG5leHBvcnQgZGVmYXVsdCBFeHBsb3JlRGF0YUJveDtcbiIsImZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICByZXR1cm4gX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAobikge1xuICAgIGZvciAodmFyIGUgPSAxOyBlIDwgYXJndW1lbnRzLmxlbmd0aDsgZSsrKSB7XG4gICAgICB2YXIgdCA9IGFyZ3VtZW50c1tlXTtcbiAgICAgIGZvciAodmFyIHIgaW4gdCkgKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIHIpICYmIChuW3JdID0gdFtyXSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9LCBfZXh0ZW5kcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuZXhwb3J0IHsgX2V4dGVuZHMgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5leHBvcnQgeyBfdHlwZW9mIGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgX3R5cGVvZiBmcm9tIFwiLi90eXBlb2YuanNcIjtcbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5leHBvcnQgeyB0b1ByaW1pdGl2ZSBhcyBkZWZhdWx0IH07IiwiaW1wb3J0IF90eXBlb2YgZnJvbSBcIi4vdHlwZW9mLmpzXCI7XG5pbXBvcnQgdG9QcmltaXRpdmUgZnJvbSBcIi4vdG9QcmltaXRpdmUuanNcIjtcbmZ1bmN0aW9uIHRvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IHRvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiO1xufVxuZXhwb3J0IHsgdG9Qcm9wZXJ0eUtleSBhcyBkZWZhdWx0IH07IiwiaW1wb3J0IHRvUHJvcGVydHlLZXkgZnJvbSBcIi4vdG9Qcm9wZXJ0eUtleS5qc1wiO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHtcbiAgcmV0dXJuIChyID0gdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG4gICAgdmFsdWU6IHQsXG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICB3cml0YWJsZTogITBcbiAgfSkgOiBlW3JdID0gdCwgZTtcbn1cbmV4cG9ydCB7IF9kZWZpbmVQcm9wZXJ0eSBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByO1xufVxuZXhwb3J0IHsgX2FycmF5V2l0aEhvbGVzIGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkge1xuICB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAobnVsbCAhPSB0KSB7XG4gICAgdmFyIGUsXG4gICAgICBuLFxuICAgICAgaSxcbiAgICAgIHUsXG4gICAgICBhID0gW10sXG4gICAgICBmID0gITAsXG4gICAgICBvID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHtcbiAgICAgICAgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuO1xuICAgICAgICBmID0gITE7XG4gICAgICB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7XG4gICAgfSBjYXRjaCAocikge1xuICAgICAgbyA9ICEwLCBuID0gcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5leHBvcnQgeyBfaXRlcmFibGVUb0FycmF5TGltaXQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5leHBvcnQgeyBfbm9uSXRlcmFibGVSZXN0IGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgYXJyYXlXaXRoSG9sZXMgZnJvbSBcIi4vYXJyYXlXaXRoSG9sZXMuanNcIjtcbmltcG9ydCBpdGVyYWJsZVRvQXJyYXlMaW1pdCBmcm9tIFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1wiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCI7XG5pbXBvcnQgbm9uSXRlcmFibGVSZXN0IGZyb20gXCIuL25vbkl0ZXJhYmxlUmVzdC5qc1wiO1xuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMocikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59XG5leHBvcnQgeyBfc2xpY2VkVG9BcnJheSBhcyBkZWZhdWx0IH07IiwiLyoqXG4gKiBDb21tb24gdXRpbGl0aWVzXG4gKiBAbW9kdWxlIGdsTWF0cml4XG4gKi9cbi8vIENvbmZpZ3VyYXRpb24gQ29uc3RhbnRzXG5leHBvcnQgdmFyIEVQU0lMT04gPSAwLjAwMDAwMTtcbmV4cG9ydCB2YXIgQVJSQVlfVFlQRSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5leHBvcnQgdmFyIFJBTkRPTSA9IE1hdGgucmFuZG9tO1xuLyoqXG4gKiBTZXRzIHRoZSB0eXBlIG9mIGFycmF5IHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmVjdG9ycyBhbmQgbWF0cmljZXNcbiAqXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3Rvcn0gdHlwZSBBcnJheSB0eXBlLCBzdWNoIGFzIEZsb2F0MzJBcnJheSBvciBBcnJheVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRNYXRyaXhBcnJheVR5cGUodHlwZSkge1xuICBBUlJBWV9UWVBFID0gdHlwZTtcbn1cbnZhciBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xuLyoqXG4gKiBDb252ZXJ0IERlZ3JlZSBUbyBSYWRpYW5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYSBBbmdsZSBpbiBEZWdyZWVzXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFuKGEpIHtcbiAgcmV0dXJuIGEgKiBkZWdyZWU7XG59XG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudHMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHZhbHVlLCB3aXRoaW4gYW4gYWJzb2x1dGVcbiAqIG9yIHJlbGF0aXZlIHRvbGVyYW5jZSBvZiBnbE1hdHJpeC5FUFNJTE9OIChhbiBhYnNvbHV0ZSB0b2xlcmFuY2UgaXMgdXNlZCBmb3IgdmFsdWVzIGxlc3NcbiAqIHRoYW4gb3IgZXF1YWwgdG8gMS4wLCBhbmQgYSByZWxhdGl2ZSB0b2xlcmFuY2UgaXMgdXNlZCBmb3IgbGFyZ2VyIHZhbHVlcylcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgbnVtYmVyIHRvIHRlc3QuXG4gKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgc2Vjb25kIG51bWJlciB0byB0ZXN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhKSwgTWF0aC5hYnMoYikpO1xufVxuaWYgKCFNYXRoLmh5cG90KSBNYXRoLmh5cG90ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgeSA9IDAsXG4gICAgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB5ICs9IGFyZ3VtZW50c1tpXSAqIGFyZ3VtZW50c1tpXTtcbiAgfVxuICByZXR1cm4gTWF0aC5zcXJ0KHkpO1xufTsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxuICogNCBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBtb2R1bGUgdmVjNFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjNFxuICpcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5LCB6LCB3KSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgb3V0WzNdID0gdztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeiwgdykge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gIG91dFszXSA9IGFbM10gKiBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIG91dFszXSA9IGFbM10gLyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gIG91dFszXSA9IE1hdGguY2VpbChhWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLmZsb29yKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gIG91dFszXSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gIG91dFszXSA9IE1hdGgubWF4KGFbM10sIGJbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gIG91dFszXSA9IE1hdGgucm91bmQoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNjYWxlcyBhIHZlYzQgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWRkcyB0d28gdmVjNCdzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICB2YXIgdyA9IGJbM10gLSBhWzNdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6LCB3KTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXTtcbiAgdmFyIHkgPSBiWzFdIC0gYVsxXTtcbiAgdmFyIHogPSBiWzJdIC0gYVsyXTtcbiAgdmFyIHcgPSBiWzNdIC0gYVszXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciB3ID0gYVszXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSwgeiwgdyk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciB3ID0gYVszXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3O1xufVxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gLWFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgb3V0WzNdID0gMS4wIC8gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIHcgPSBhWzNdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICB9XG4gIG91dFswXSA9IHggKiBsZW47XG4gIG91dFsxXSA9IHkgKiBsZW47XG4gIG91dFsyXSA9IHogKiBsZW47XG4gIG91dFszXSA9IHcgKiBsZW47XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl0gKyBhWzNdICogYlszXTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY3Jvc3MtcHJvZHVjdCBvZiB0aHJlZSB2ZWN0b3JzIGluIGEgNC1kaW1lbnNpb25hbCBzcGFjZVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSByZXN1bHQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBVIHRoZSBmaXJzdCB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBWIHRoZSBzZWNvbmQgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gVyB0aGUgdGhpcmQgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjNH0gcmVzdWx0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKG91dCwgdSwgdiwgdykge1xuICB2YXIgQSA9IHZbMF0gKiB3WzFdIC0gdlsxXSAqIHdbMF0sXG4gICAgQiA9IHZbMF0gKiB3WzJdIC0gdlsyXSAqIHdbMF0sXG4gICAgQyA9IHZbMF0gKiB3WzNdIC0gdlszXSAqIHdbMF0sXG4gICAgRCA9IHZbMV0gKiB3WzJdIC0gdlsyXSAqIHdbMV0sXG4gICAgRSA9IHZbMV0gKiB3WzNdIC0gdlszXSAqIHdbMV0sXG4gICAgRiA9IHZbMl0gKiB3WzNdIC0gdlszXSAqIHdbMl07XG4gIHZhciBHID0gdVswXTtcbiAgdmFyIEggPSB1WzFdO1xuICB2YXIgSSA9IHVbMl07XG4gIHZhciBKID0gdVszXTtcbiAgb3V0WzBdID0gSCAqIEYgLSBJICogRSArIEogKiBEO1xuICBvdXRbMV0gPSAtKEcgKiBGKSArIEkgKiBDIC0gSiAqIEI7XG4gIG91dFsyXSA9IEcgKiBFIC0gSCAqIEMgKyBKICogQTtcbiAgb3V0WzNdID0gLShHICogRCkgKyBIICogQiAtIEkgKiBBO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF07XG4gIHZhciBheSA9IGFbMV07XG4gIHZhciBheiA9IGFbMl07XG4gIHZhciBhdyA9IGFbM107XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gIG91dFszXSA9IGF3ICsgdCAqIChiWzNdIC0gYXcpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlIHx8IDEuMDsgLy8gTWFyc2FnbGlhLCBHZW9yZ2UuIENob29zaW5nIGEgUG9pbnQgZnJvbSB0aGUgU3VyZmFjZSBvZiBhXG4gIC8vIFNwaGVyZS4gQW5uLiBNYXRoLiBTdGF0aXN0LiA0MyAoMTk3MiksIG5vLiAyLCA2NDUtLTY0Ni5cbiAgLy8gaHR0cDovL3Byb2plY3RldWNsaWQub3JnL2V1Y2xpZC5hb21zLzExNzc2OTI2NDQ7XG5cbiAgdmFyIHYxLCB2MiwgdjMsIHY0O1xuICB2YXIgczEsIHMyO1xuICBkbyB7XG4gICAgdjEgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIgLSAxO1xuICAgIHYyID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICBzMSA9IHYxICogdjEgKyB2MiAqIHYyO1xuICB9IHdoaWxlIChzMSA+PSAxKTtcbiAgZG8ge1xuICAgIHYzID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICB2NCA9IGdsTWF0cml4LlJBTkRPTSgpICogMiAtIDE7XG4gICAgczIgPSB2MyAqIHYzICsgdjQgKiB2NDtcbiAgfSB3aGlsZSAoczIgPj0gMSk7XG4gIHZhciBkID0gTWF0aC5zcXJ0KCgxIC0gczEpIC8gczIpO1xuICBvdXRbMF0gPSBzY2FsZSAqIHYxO1xuICBvdXRbMV0gPSBzY2FsZSAqIHYyO1xuICBvdXRbMl0gPSBzY2FsZSAqIHYzICogZDtcbiAgb3V0WzNdID0gc2NhbGUgKiB2NCAqIGQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIG1hdDQuXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdLFxuICAgIHogPSBhWzJdLFxuICAgIHcgPSBhWzNdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSAqIHc7XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdICogdztcbiAgb3V0WzJdID0gbVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdICogdztcbiAgb3V0WzNdID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdICogdztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1RdWF0KG91dCwgYSwgcSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV0sXG4gICAgeiA9IGFbMl07XG4gIHZhciBxeCA9IHFbMF0sXG4gICAgcXkgPSBxWzFdLFxuICAgIHF6ID0gcVsyXSxcbiAgICBxdyA9IHFbM107IC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG5cbiAgdmFyIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuICB2YXIgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gIHZhciBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcbiAgdmFyIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejsgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG4gIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzQgdG8gemVyb1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHplcm8ob3V0KSB7XG4gIG91dFswXSA9IDAuMDtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIG91dFszXSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzQoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIpXCI7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICBhMSA9IGFbMV0sXG4gICAgYTIgPSBhWzJdLFxuICAgIGEzID0gYVszXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICBiMSA9IGJbMV0sXG4gICAgYjIgPSBiWzJdLFxuICAgIGIzID0gYlszXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKTtcbn1cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgZGl2ID0gZGl2aWRlO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgbGVuID0gbGVuZ3RoO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzQuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWM0cyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcbiAgICBpZiAoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gNDtcbiAgICB9XG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07XG4gICAgICB2ZWNbMV0gPSBhW2kgKyAxXTtcbiAgICAgIHZlY1syXSA9IGFbaSArIDJdO1xuICAgICAgdmVjWzNdID0gYVtpICsgM107XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICAgIGFbaSArIDJdID0gdmVjWzJdO1xuICAgICAgYVtpICsgM10gPSB2ZWNbM107XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xufSgpOyIsImltcG9ydCB7IHRyYW5zZm9ybU1hdDQsIHNjYWxlIH0gZnJvbSAnZ2wtbWF0cml4L3ZlYzQnO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1hdDQoKSB7XG4gIHJldHVybiBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG59XG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtVmVjdG9yKG1hdHJpeCwgdmVjdG9yKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHRyYW5zZm9ybU1hdDQoW10sIHZlY3RvciwgbWF0cml4KTtcbiAgc2NhbGUocmVzdWx0LCByZXN1bHQsIDEgLyByZXN1bHRbM10pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1vZCh2YWx1ZSwgZGl2aXNvcikge1xuICBjb25zdCBtb2R1bHVzID0gdmFsdWUgJSBkaXZpc29yO1xuICByZXR1cm4gbW9kdWx1cyA8IDAgPyBkaXZpc29yICsgbW9kdWx1cyA6IG1vZHVsdXM7XG59XG5leHBvcnQgZnVuY3Rpb24gbGVycChzdGFydCwgZW5kLCBzdGVwKSB7XG4gIHJldHVybiBzdGVwICogZW5kICsgKDEgLSBzdGVwKSAqIHN0YXJ0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKHgsIG1pbiwgbWF4KSB7XG4gIHJldHVybiB4IDwgbWluID8gbWluIDogeCA+IG1heCA/IG1heCA6IHg7XG59XG5mdW5jdGlvbiBpZUxvZzIoeCkge1xuICByZXR1cm4gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzJFO1xufVxuZXhwb3J0IGNvbnN0IGxvZzIgPSBNYXRoLmxvZzIgfHwgaWVMb2cyOyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXG4gKiA0eDQgTWF0cml4PGJyPkZvcm1hdDogY29sdW1uLW1ham9yLCB3aGVuIHR5cGVkIG91dCBpdCBsb29rcyBsaWtlIHJvdy1tYWpvcjxicj5UaGUgbWF0cmljZXMgYXJlIGJlaW5nIHBvc3QgbXVsdGlwbGllZC5cbiAqIEBtb2R1bGUgbWF0NFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQ0XG4gKlxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gIH1cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgb3V0WzldID0gYVs5XTtcbiAgb3V0WzEwXSA9IGFbMTBdO1xuICBvdXRbMTFdID0gYVsxMV07XG4gIG91dFsxMl0gPSBhWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdO1xuICBvdXRbMTRdID0gYVsxNF07XG4gIG91dFsxNV0gPSBhWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICBvdXRbOV0gPSBhWzldO1xuICBvdXRbMTBdID0gYVsxMF07XG4gIG91dFsxMV0gPSBhWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0NCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAzIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDMgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDUpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDYpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDgpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDkpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMyBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzAgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMTIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMiBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzMgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTUpXG4gKiBAcmV0dXJucyB7bWF0NH0gQSBuZXcgbWF0NFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMDM7XG4gIG91dFs0XSA9IG0xMDtcbiAgb3V0WzVdID0gbTExO1xuICBvdXRbNl0gPSBtMTI7XG4gIG91dFs3XSA9IG0xMztcbiAgb3V0WzhdID0gbTIwO1xuICBvdXRbOV0gPSBtMjE7XG4gIG91dFsxMF0gPSBtMjI7XG4gIG91dFsxMV0gPSBtMjM7XG4gIG91dFsxMl0gPSBtMzA7XG4gIG91dFsxM10gPSBtMzE7XG4gIG91dFsxNF0gPSBtMzI7XG4gIG91dFsxNV0gPSBtMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAzIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDMgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDUpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDYpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDgpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDkpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMyBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzAgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMTIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMiBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzMgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTUpXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMDM7XG4gIG91dFs0XSA9IG0xMDtcbiAgb3V0WzVdID0gbTExO1xuICBvdXRbNl0gPSBtMTI7XG4gIG91dFs3XSA9IG0xMztcbiAgb3V0WzhdID0gbTIwO1xuICBvdXRbOV0gPSBtMjE7XG4gIG91dFsxMF0gPSBtMjI7XG4gIG91dFsxMV0gPSBtMjM7XG4gIG91dFsxMl0gPSBtMzA7XG4gIG91dFsxM10gPSBtMzE7XG4gIG91dFsxNF0gPSBtMzI7XG4gIG91dFsxNV0gPSBtMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCBhIG1hdDQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICAgIHZhciBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgICB2YXIgYTIzID0gYVsxMV07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGEwMTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGEwMjtcbiAgICBvdXRbOV0gPSBhMTI7XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhMDM7XG4gICAgb3V0WzEzXSA9IGExMztcbiAgICBvdXRbMTRdID0gYTIzO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGFbMV07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGFbMl07XG4gICAgb3V0WzldID0gYVs2XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhWzNdO1xuICAgIG91dFsxM10gPSBhWzddO1xuICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICBhMDEgPSBhWzFdLFxuICAgIGEwMiA9IGFbMl0sXG4gICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgYTExID0gYVs1XSxcbiAgICBhMTIgPSBhWzZdLFxuICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgIGEyMSA9IGFbOV0sXG4gICAgYTIyID0gYVsxMF0sXG4gICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICBhMzEgPSBhWzEzXSxcbiAgICBhMzIgPSBhWzE0XSxcbiAgICBhMzMgPSBhWzE1XTtcbiAgdmFyIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgdmFyIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgdmFyIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgdmFyIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgdmFyIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgdmFyIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgdmFyIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgdmFyIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgdmFyIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgdmFyIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgdmFyIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgdmFyIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjsgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuXG4gIHZhciBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgIGEwMSA9IGFbMV0sXG4gICAgYTAyID0gYVsyXSxcbiAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICBhMTEgPSBhWzVdLFxuICAgIGExMiA9IGFbNl0sXG4gICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgYTIxID0gYVs5XSxcbiAgICBhMjIgPSBhWzEwXSxcbiAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgIGEzMSA9IGFbMTNdLFxuICAgIGEzMiA9IGFbMTRdLFxuICAgIGEzMyA9IGFbMTVdO1xuICBvdXRbMF0gPSBhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMik7XG4gIG91dFsxXSA9IC0oYTAxICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgb3V0WzJdID0gYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpO1xuICBvdXRbM10gPSAtKGEwMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTExICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gIG91dFs0XSA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgb3V0WzVdID0gYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpO1xuICBvdXRbNl0gPSAtKGEwMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTEwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gIG91dFs3XSA9IGEwMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTEwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKTtcbiAgb3V0WzhdID0gYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpO1xuICBvdXRbOV0gPSAtKGEwMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSk7XG4gIG91dFsxMF0gPSBhMDAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSk7XG4gIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gIG91dFsxMl0gPSAtKGExMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSk7XG4gIG91dFsxM10gPSBhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSk7XG4gIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gIG91dFsxNV0gPSBhMDAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgYTAxID0gYVsxXSxcbiAgICBhMDIgPSBhWzJdLFxuICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgIGExMSA9IGFbNV0sXG4gICAgYTEyID0gYVs2XSxcbiAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICBhMjEgPSBhWzldLFxuICAgIGEyMiA9IGFbMTBdLFxuICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgYTMxID0gYVsxM10sXG4gICAgYTMyID0gYVsxNF0sXG4gICAgYTMzID0gYVsxNV07XG4gIHZhciBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHZhciBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIHZhciBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIHZhciBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIHZhciBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIHZhciBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIHZhciBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIHZhciBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIHZhciBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIHZhciBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIHZhciBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIHZhciBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0c1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICBhMDEgPSBhWzFdLFxuICAgIGEwMiA9IGFbMl0sXG4gICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgYTExID0gYVs1XSxcbiAgICBhMTIgPSBhWzZdLFxuICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgIGEyMSA9IGFbOV0sXG4gICAgYTIyID0gYVsxMF0sXG4gICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICBhMzEgPSBhWzEzXSxcbiAgICBhMzIgPSBhWzE0XSxcbiAgICBhMzMgPSBhWzE1XTsgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG5cbiAgdmFyIGIwID0gYlswXSxcbiAgICBiMSA9IGJbMV0sXG4gICAgYjIgPSBiWzJdLFxuICAgIGIzID0gYlszXTtcbiAgb3V0WzBdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxXSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbMl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzNdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls0XTtcbiAgYjEgPSBiWzVdO1xuICBiMiA9IGJbNl07XG4gIGIzID0gYls3XTtcbiAgb3V0WzRdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFs1XSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbNl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzddID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls4XTtcbiAgYjEgPSBiWzldO1xuICBiMiA9IGJbMTBdO1xuICBiMyA9IGJbMTFdO1xuICBvdXRbOF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzldID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFsxMF0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzExXSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICBiMCA9IGJbMTJdO1xuICBiMSA9IGJbMTNdO1xuICBiMiA9IGJbMTRdO1xuICBiMyA9IGJbMTVdO1xuICBvdXRbMTJdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxM10gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzE0XSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbMTVdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDQgYnkgdGhlIGdpdmVuIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIHZhciB4ID0gdlswXSxcbiAgICB5ID0gdlsxXSxcbiAgICB6ID0gdlsyXTtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcbiAgaWYgKGEgPT09IG91dCkge1xuICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6ICsgYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICB9IGVsc2Uge1xuICAgIGEwMCA9IGFbMF07XG4gICAgYTAxID0gYVsxXTtcbiAgICBhMDIgPSBhWzJdO1xuICAgIGEwMyA9IGFbM107XG4gICAgYTEwID0gYVs0XTtcbiAgICBhMTEgPSBhWzVdO1xuICAgIGExMiA9IGFbNl07XG4gICAgYTEzID0gYVs3XTtcbiAgICBhMjAgPSBhWzhdO1xuICAgIGEyMSA9IGFbOV07XG4gICAgYTIyID0gYVsxMF07XG4gICAgYTIzID0gYVsxMV07XG4gICAgb3V0WzBdID0gYTAwO1xuICAgIG91dFsxXSA9IGEwMTtcbiAgICBvdXRbMl0gPSBhMDI7XG4gICAgb3V0WzNdID0gYTAzO1xuICAgIG91dFs0XSA9IGExMDtcbiAgICBvdXRbNV0gPSBhMTE7XG4gICAgb3V0WzZdID0gYTEyO1xuICAgIG91dFs3XSA9IGExMztcbiAgICBvdXRbOF0gPSBhMjA7XG4gICAgb3V0WzldID0gYTIxO1xuICAgIG91dFsxMF0gPSBhMjI7XG4gICAgb3V0WzExXSA9IGEyMztcbiAgICBvdXRbMTJdID0gYTAwICogeCArIGExMCAqIHkgKyBhMjAgKiB6ICsgYVsxMl07XG4gICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgIG91dFsxNF0gPSBhMDIgKiB4ICsgYTEyICogeSArIGEyMiAqIHogKyBhWzE0XTtcbiAgICBvdXRbMTVdID0gYTAzICogeCArIGExMyAqIHkgKyBhMjMgKiB6ICsgYVsxNV07XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzIG5vdCB1c2luZyB2ZWN0b3JpemF0aW9uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgeCA9IHZbMF0sXG4gICAgeSA9IHZbMV0sXG4gICAgeiA9IHZbMl07XG4gIG91dFswXSA9IGFbMF0gKiB4O1xuICBvdXRbMV0gPSBhWzFdICogeDtcbiAgb3V0WzJdID0gYVsyXSAqIHg7XG4gIG91dFszXSA9IGFbM10gKiB4O1xuICBvdXRbNF0gPSBhWzRdICogeTtcbiAgb3V0WzVdID0gYVs1XSAqIHk7XG4gIG91dFs2XSA9IGFbNl0gKiB5O1xuICBvdXRbN10gPSBhWzddICogeTtcbiAgb3V0WzhdID0gYVs4XSAqIHo7XG4gIG91dFs5XSA9IGFbOV0gKiB6O1xuICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIGdpdmVuIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCwgYXhpcykge1xuICB2YXIgeCA9IGF4aXNbMF0sXG4gICAgeSA9IGF4aXNbMV0sXG4gICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcbiAgdmFyIGIwMCwgYjAxLCBiMDI7XG4gIHZhciBiMTAsIGIxMSwgYjEyO1xuICB2YXIgYjIwLCBiMjEsIGIyMjtcbiAgaWYgKGxlbiA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZW4gPSAxIC8gbGVuO1xuICB4ICo9IGxlbjtcbiAgeSAqPSBsZW47XG4gIHogKj0gbGVuO1xuICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgYyA9IE1hdGguY29zKHJhZCk7XG4gIHQgPSAxIC0gYztcbiAgYTAwID0gYVswXTtcbiAgYTAxID0gYVsxXTtcbiAgYTAyID0gYVsyXTtcbiAgYTAzID0gYVszXTtcbiAgYTEwID0gYVs0XTtcbiAgYTExID0gYVs1XTtcbiAgYTEyID0gYVs2XTtcbiAgYTEzID0gYVs3XTtcbiAgYTIwID0gYVs4XTtcbiAgYTIxID0gYVs5XTtcbiAgYTIyID0gYVsxMF07XG4gIGEyMyA9IGFbMTFdOyAvLyBDb25zdHJ1Y3QgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3RhdGlvbiBtYXRyaXhcblxuICBiMDAgPSB4ICogeCAqIHQgKyBjO1xuICBiMDEgPSB5ICogeCAqIHQgKyB6ICogcztcbiAgYjAyID0geiAqIHggKiB0IC0geSAqIHM7XG4gIGIxMCA9IHggKiB5ICogdCAtIHogKiBzO1xuICBiMTEgPSB5ICogeSAqIHQgKyBjO1xuICBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgYjIwID0geCAqIHogKiB0ICsgeSAqIHM7XG4gIGIyMSA9IHkgKiB6ICogdCAtIHggKiBzO1xuICBiMjIgPSB6ICogeiAqIHQgKyBjOyAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgb3V0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyO1xuICBvdXRbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDI7XG4gIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcbiAgb3V0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICBvdXRbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTI7XG4gIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgb3V0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyO1xuICBvdXRbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjI7XG4gIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcbiAgb3V0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMjtcbiAgb3V0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMjtcbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgYTEwID0gYVs0XTtcbiAgdmFyIGExMSA9IGFbNV07XG4gIHZhciBhMTIgPSBhWzZdO1xuICB2YXIgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF07XG4gIHZhciBhMjEgPSBhWzldO1xuICB2YXIgYTIyID0gYVsxMF07XG4gIHZhciBhMjMgPSBhWzExXTtcbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzRdID0gYTEwICogYyArIGEyMCAqIHM7XG4gIG91dFs1XSA9IGExMSAqIGMgKyBhMjEgKiBzO1xuICBvdXRbNl0gPSBhMTIgKiBjICsgYTIyICogcztcbiAgb3V0WzddID0gYTEzICogYyArIGEyMyAqIHM7XG4gIG91dFs4XSA9IGEyMCAqIGMgLSBhMTAgKiBzO1xuICBvdXRbOV0gPSBhMjEgKiBjIC0gYTExICogcztcbiAgb3V0WzEwXSA9IGEyMiAqIGMgLSBhMTIgKiBzO1xuICBvdXRbMTFdID0gYTIzICogYyAtIGExMyAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgYTAwID0gYVswXTtcbiAgdmFyIGEwMSA9IGFbMV07XG4gIHZhciBhMDIgPSBhWzJdO1xuICB2YXIgYTAzID0gYVszXTtcbiAgdmFyIGEyMCA9IGFbOF07XG4gIHZhciBhMjEgPSBhWzldO1xuICB2YXIgYTIyID0gYVsxMF07XG4gIHZhciBhMjMgPSBhWzExXTtcbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gYTAwICogYyAtIGEyMCAqIHM7XG4gIG91dFsxXSA9IGEwMSAqIGMgLSBhMjEgKiBzO1xuICBvdXRbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcbiAgb3V0WzNdID0gYTAzICogYyAtIGEyMyAqIHM7XG4gIG91dFs4XSA9IGEwMCAqIHMgKyBhMjAgKiBjO1xuICBvdXRbOV0gPSBhMDEgKiBzICsgYTIxICogYztcbiAgb3V0WzEwXSA9IGEwMiAqIHMgKyBhMjIgKiBjO1xuICBvdXRbMTFdID0gYTAzICogcyArIGEyMyAqIGM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgYTAwID0gYVswXTtcbiAgdmFyIGEwMSA9IGFbMV07XG4gIHZhciBhMDIgPSBhWzJdO1xuICB2YXIgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF07XG4gIHZhciBhMTEgPSBhWzVdO1xuICB2YXIgYTEyID0gYVs2XTtcbiAgdmFyIGExMyA9IGFbN107XG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gYTAwICogYyArIGExMCAqIHM7XG4gIG91dFsxXSA9IGEwMSAqIGMgKyBhMTEgKiBzO1xuICBvdXRbMl0gPSBhMDIgKiBjICsgYTEyICogcztcbiAgb3V0WzNdID0gYTAzICogYyArIGExMyAqIHM7XG4gIG91dFs0XSA9IGExMCAqIGMgLSBhMDAgKiBzO1xuICBvdXRbNV0gPSBhMTEgKiBjIC0gYTAxICogcztcbiAgb3V0WzZdID0gYTEyICogYyAtIGEwMiAqIHM7XG4gIG91dFs3XSA9IGExMyAqIGMgLSBhMDMgKiBzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsIHYpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXTtcbiAgb3V0WzEzXSA9IHZbMV07XG4gIG91dFsxNF0gPSB2WzJdO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gdlsxXTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IHZbMl07XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGUgYXJvdW5kIGEgZ2l2ZW4gYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkLCBheGlzKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQsIGF4aXMpIHtcbiAgdmFyIHggPSBheGlzWzBdLFxuICAgIHkgPSBheGlzWzFdLFxuICAgIHogPSBheGlzWzJdO1xuICB2YXIgbGVuID0gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbiAgdmFyIHMsIGMsIHQ7XG4gIGlmIChsZW4gPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7IC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0geCAqIHggKiB0ICsgYztcbiAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgb3V0WzVdID0geSAqIHkgKiB0ICsgYztcbiAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzO1xuICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogcztcbiAgb3V0WzEwXSA9IHogKiB6ICogdCArIGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVYKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVhSb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTsgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IGM7XG4gIG91dFs2XSA9IHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IC1zO1xuICBvdXRbMTBdID0gYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpOyAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHM7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWihkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21aUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAtcztcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIHEsIHYpIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIHZhciB4ID0gcVswXSxcbiAgICB5ID0gcVsxXSxcbiAgICB6ID0gcVsyXSxcbiAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeHkgPSB4ICogeTI7XG4gIHZhciB4eiA9IHggKiB6MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgeXogPSB5ICogejI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgb3V0WzBdID0gMSAtICh5eSArIHp6KTtcbiAgb3V0WzFdID0geHkgKyB3ejtcbiAgb3V0WzJdID0geHogLSB3eTtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geHkgLSB3ejtcbiAgb3V0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgb3V0WzZdID0geXogKyB3eDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geHogKyB3eTtcbiAgb3V0WzldID0geXogLSB3eDtcbiAgb3V0WzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXTtcbiAgb3V0WzEzXSA9IHZbMV07XG4gIG91dFsxNF0gPSB2WzJdO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGZyb20gYSBkdWFsIHF1YXQuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgTWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgRHVhbCBRdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7bWF0NH0gbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUXVhdDIob3V0LCBhKSB7XG4gIHZhciB0cmFuc2xhdGlvbiA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICB2YXIgYnggPSAtYVswXSxcbiAgICBieSA9IC1hWzFdLFxuICAgIGJ6ID0gLWFbMl0sXG4gICAgYncgPSBhWzNdLFxuICAgIGF4ID0gYVs0XSxcbiAgICBheSA9IGFbNV0sXG4gICAgYXogPSBhWzZdLFxuICAgIGF3ID0gYVs3XTtcbiAgdmFyIG1hZ25pdHVkZSA9IGJ4ICogYnggKyBieSAqIGJ5ICsgYnogKiBieiArIGJ3ICogYnc7IC8vT25seSBzY2FsZSBpZiBpdCBtYWtlcyBzZW5zZVxuXG4gIGlmIChtYWduaXR1ZGUgPiAwKSB7XG4gICAgdHJhbnNsYXRpb25bMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyIC8gbWFnbml0dWRlO1xuICAgIHRyYW5zbGF0aW9uWzFdID0gKGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnopICogMiAvIG1hZ25pdHVkZTtcbiAgICB0cmFuc2xhdGlvblsyXSA9IChheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4KSAqIDIgLyBtYWduaXR1ZGU7XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNsYXRpb25bMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyO1xuICAgIHRyYW5zbGF0aW9uWzFdID0gKGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnopICogMjtcbiAgICB0cmFuc2xhdGlvblsyXSA9IChheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4KSAqIDI7XG4gIH1cbiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBhLCB0cmFuc2xhdGlvbik7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvbixcbiAqICB0aGUgcmV0dXJuZWQgdmVjdG9yIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvclxuICogIG9yaWdpbmFsbHkgc3VwcGxpZWQuXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgdHJhbnNsYXRpb24gY29tcG9uZW50XG4gKiBAcGFyYW0gIHtSZWFkb25seU1hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24ob3V0LCBtYXQpIHtcbiAgb3V0WzBdID0gbWF0WzEyXTtcbiAgb3V0WzFdID0gbWF0WzEzXTtcbiAgb3V0WzJdID0gbWF0WzE0XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgc2NhbGluZyBmYWN0b3IgY29tcG9uZW50IG9mIGEgdHJhbnNmb3JtYXRpb25cbiAqICBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGggZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZVxuICogIHdpdGggYSBub3JtYWxpemVkIFF1YXRlcm5pb24gcGFyYW10ZXIsIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZVxuICogIHRoZSBzYW1lIGFzIHRoZSBzY2FsaW5nIHZlY3RvclxuICogIG9yaWdpbmFsbHkgc3VwcGxpZWQuXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgc2NhbGluZyBmYWN0b3IgY29tcG9uZW50XG4gKiBAcGFyYW0gIHtSZWFkb25seU1hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGluZyhvdXQsIG1hdCkge1xuICB2YXIgbTExID0gbWF0WzBdO1xuICB2YXIgbTEyID0gbWF0WzFdO1xuICB2YXIgbTEzID0gbWF0WzJdO1xuICB2YXIgbTIxID0gbWF0WzRdO1xuICB2YXIgbTIyID0gbWF0WzVdO1xuICB2YXIgbTIzID0gbWF0WzZdO1xuICB2YXIgbTMxID0gbWF0WzhdO1xuICB2YXIgbTMyID0gbWF0WzldO1xuICB2YXIgbTMzID0gbWF0WzEwXTtcbiAgb3V0WzBdID0gTWF0aC5oeXBvdChtMTEsIG0xMiwgbTEzKTtcbiAgb3V0WzFdID0gTWF0aC5oeXBvdChtMjEsIG0yMiwgbTIzKTtcbiAgb3V0WzJdID0gTWF0aC5oeXBvdChtMzEsIG0zMiwgbTMzKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyBhIHF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSByb3RhdGlvbmFsIGNvbXBvbmVudFxuICogIG9mIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoXG4gKiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24sIHRoZSByZXR1cm5lZCBxdWF0ZXJuaW9uIHdpbGwgYmUgdGhlXG4gKiAgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBvcmlnaW5hbGx5IHN1cHBsaWVkLlxuICogQHBhcmFtIHtxdWF0fSBvdXQgUXVhdGVybmlvbiB0byByZWNlaXZlIHRoZSByb3RhdGlvbiBjb21wb25lbnRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxuICogQHJldHVybiB7cXVhdH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdGF0aW9uKG91dCwgbWF0KSB7XG4gIHZhciBzY2FsaW5nID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIGdldFNjYWxpbmcoc2NhbGluZywgbWF0KTtcbiAgdmFyIGlzMSA9IDEgLyBzY2FsaW5nWzBdO1xuICB2YXIgaXMyID0gMSAvIHNjYWxpbmdbMV07XG4gIHZhciBpczMgPSAxIC8gc2NhbGluZ1syXTtcbiAgdmFyIHNtMTEgPSBtYXRbMF0gKiBpczE7XG4gIHZhciBzbTEyID0gbWF0WzFdICogaXMyO1xuICB2YXIgc20xMyA9IG1hdFsyXSAqIGlzMztcbiAgdmFyIHNtMjEgPSBtYXRbNF0gKiBpczE7XG4gIHZhciBzbTIyID0gbWF0WzVdICogaXMyO1xuICB2YXIgc20yMyA9IG1hdFs2XSAqIGlzMztcbiAgdmFyIHNtMzEgPSBtYXRbOF0gKiBpczE7XG4gIHZhciBzbTMyID0gbWF0WzldICogaXMyO1xuICB2YXIgc20zMyA9IG1hdFsxMF0gKiBpczM7XG4gIHZhciB0cmFjZSA9IHNtMTEgKyBzbTIyICsgc20zMztcbiAgdmFyIFMgPSAwO1xuICBpZiAodHJhY2UgPiAwKSB7XG4gICAgUyA9IE1hdGguc3FydCh0cmFjZSArIDEuMCkgKiAyO1xuICAgIG91dFszXSA9IDAuMjUgKiBTO1xuICAgIG91dFswXSA9IChzbTIzIC0gc20zMikgLyBTO1xuICAgIG91dFsxXSA9IChzbTMxIC0gc20xMykgLyBTO1xuICAgIG91dFsyXSA9IChzbTEyIC0gc20yMSkgLyBTO1xuICB9IGVsc2UgaWYgKHNtMTEgPiBzbTIyICYmIHNtMTEgPiBzbTMzKSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTExIC0gc20yMiAtIHNtMzMpICogMjtcbiAgICBvdXRbM10gPSAoc20yMyAtIHNtMzIpIC8gUztcbiAgICBvdXRbMF0gPSAwLjI1ICogUztcbiAgICBvdXRbMV0gPSAoc20xMiArIHNtMjEpIC8gUztcbiAgICBvdXRbMl0gPSAoc20zMSArIHNtMTMpIC8gUztcbiAgfSBlbHNlIGlmIChzbTIyID4gc20zMykge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgc20yMiAtIHNtMTEgLSBzbTMzKSAqIDI7XG4gICAgb3V0WzNdID0gKHNtMzEgLSBzbTEzKSAvIFM7XG4gICAgb3V0WzBdID0gKHNtMTIgKyBzbTIxKSAvIFM7XG4gICAgb3V0WzFdID0gMC4yNSAqIFM7XG4gICAgb3V0WzJdID0gKHNtMjMgKyBzbTMyKSAvIFM7XG4gIH0gZWxzZSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTMzIC0gc20xMSAtIHNtMjIpICogMjtcbiAgICBvdXRbM10gPSAoc20xMiAtIHNtMjEpIC8gUztcbiAgICBvdXRbMF0gPSAoc20zMSArIHNtMTMpIC8gUztcbiAgICBvdXRbMV0gPSAoc20yMyArIHNtMzIpIC8gUztcbiAgICBvdXRbMl0gPSAwLjI1ICogUztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICBsZXQgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBzY2FsZSlcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZShvdXQsIHEsIHYsIHMpIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIHZhciB4ID0gcVswXSxcbiAgICB5ID0gcVsxXSxcbiAgICB6ID0gcVsyXSxcbiAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeHkgPSB4ICogeTI7XG4gIHZhciB4eiA9IHggKiB6MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgeXogPSB5ICogejI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgdmFyIHN4ID0gc1swXTtcbiAgdmFyIHN5ID0gc1sxXTtcbiAgdmFyIHN6ID0gc1syXTtcbiAgb3V0WzBdID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gIG91dFsxXSA9ICh4eSArIHd6KSAqIHN4O1xuICBvdXRbMl0gPSAoeHogLSB3eSkgKiBzeDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gKHh5IC0gd3opICogc3k7XG4gIG91dFs1XSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICBvdXRbNl0gPSAoeXogKyB3eCkgKiBzeTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gKHh6ICsgd3kpICogc3o7XG4gIG91dFs5XSA9ICh5eiAtIHd4KSAqIHN6O1xuICBvdXRbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXTtcbiAgb3V0WzEzXSA9IHZbMV07XG4gIG91dFsxNF0gPSB2WzJdO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGUsIHJvdGF0aW5nIGFuZCBzY2FsaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gb3JpZ2luXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIG9yaWdpbik7XG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgbmVnYXRpdmVPcmlnaW4pO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gcyBTY2FsaW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IG8gVGhlIG9yaWdpbiB2ZWN0b3IgYXJvdW5kIHdoaWNoIHRvIHNjYWxlIGFuZCByb3RhdGVcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbihvdXQsIHEsIHYsIHMsIG8pIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIHZhciB4ID0gcVswXSxcbiAgICB5ID0gcVsxXSxcbiAgICB6ID0gcVsyXSxcbiAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeHkgPSB4ICogeTI7XG4gIHZhciB4eiA9IHggKiB6MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgeXogPSB5ICogejI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgdmFyIHN4ID0gc1swXTtcbiAgdmFyIHN5ID0gc1sxXTtcbiAgdmFyIHN6ID0gc1syXTtcbiAgdmFyIG94ID0gb1swXTtcbiAgdmFyIG95ID0gb1sxXTtcbiAgdmFyIG96ID0gb1syXTtcbiAgdmFyIG91dDAgPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgdmFyIG91dDEgPSAoeHkgKyB3eikgKiBzeDtcbiAgdmFyIG91dDIgPSAoeHogLSB3eSkgKiBzeDtcbiAgdmFyIG91dDQgPSAoeHkgLSB3eikgKiBzeTtcbiAgdmFyIG91dDUgPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgdmFyIG91dDYgPSAoeXogKyB3eCkgKiBzeTtcbiAgdmFyIG91dDggPSAoeHogKyB3eSkgKiBzejtcbiAgdmFyIG91dDkgPSAoeXogLSB3eCkgKiBzejtcbiAgdmFyIG91dDEwID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gIG91dFswXSA9IG91dDA7XG4gIG91dFsxXSA9IG91dDE7XG4gIG91dFsyXSA9IG91dDI7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IG91dDQ7XG4gIG91dFs1XSA9IG91dDU7XG4gIG91dFs2XSA9IG91dDY7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IG91dDg7XG4gIG91dFs5XSA9IG91dDk7XG4gIG91dFsxMF0gPSBvdXQxMDtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdICsgb3ggLSAob3V0MCAqIG94ICsgb3V0NCAqIG95ICsgb3V0OCAqIG96KTtcbiAgb3V0WzEzXSA9IHZbMV0gKyBveSAtIChvdXQxICogb3ggKyBvdXQ1ICogb3kgKyBvdXQ5ICogb3opO1xuICBvdXRbMTRdID0gdlsyXSArIG96IC0gKG91dDIgKiBveCArIG91dDYgKiBveSArIG91dDEwICogb3opO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyBhIDR4NCBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4gKlxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUXVhdChvdXQsIHEpIHtcbiAgdmFyIHggPSBxWzBdLFxuICAgIHkgPSBxWzFdLFxuICAgIHogPSBxWzJdLFxuICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB5eCA9IHkgKiB4MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgenggPSB6ICogeDI7XG4gIHZhciB6eSA9IHogKiB5MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgb3V0WzFdID0geXggKyB3ejtcbiAgb3V0WzJdID0genggLSB3eTtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geXggLSB3ejtcbiAgb3V0WzVdID0gMSAtIHh4IC0geno7XG4gIG91dFs2XSA9IHp5ICsgd3g7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHp4ICsgd3k7XG4gIG91dFs5XSA9IHp5IC0gd3g7XG4gIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJ1c3R1bShvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gIHZhciBybCA9IDEgLyAocmlnaHQgLSBsZWZ0KTtcbiAgdmFyIHRiID0gMSAvICh0b3AgLSBib3R0b20pO1xuICB2YXIgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSBuZWFyICogMiAqIHJsO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBuZWFyICogMiAqIHRiO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gIG91dFsxMV0gPSAtMTtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gZmFyICogbmVhciAqIDIgKiBuZjtcbiAgb3V0WzE1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kcy5cbiAqIFRoZSBuZWFyL2ZhciBjbGlwIHBsYW5lcyBjb3JyZXNwb25kIHRvIGEgbm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZSBaIHJhbmdlIG9mIFstMSwgMV0sXG4gKiB3aGljaCBtYXRjaGVzIFdlYkdML09wZW5HTCdzIGNsaXAgdm9sdW1lLlxuICogUGFzc2luZyBudWxsL3VuZGVmaW5lZC9ubyB2YWx1ZSBmb3IgZmFyIHdpbGwgZ2VuZXJhdGUgaW5maW5pdGUgcHJvamVjdGlvbiBtYXRyaXguXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgVmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW0sIGNhbiBiZSBudWxsIG9yIEluZmluaXR5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlTk8ob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICBuZjtcbiAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gZjtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNV0gPSAwO1xuICBpZiAoZmFyICE9IG51bGwgJiYgZmFyICE9PSBJbmZpbml0eSkge1xuICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzE0XSA9IDIgKiBmYXIgKiBuZWFyICogbmY7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzEwXSA9IC0xO1xuICAgIG91dFsxNF0gPSAtMiAqIG5lYXI7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0LnBlcnNwZWN0aXZlTk99XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIHBlcnNwZWN0aXZlID0gcGVyc3BlY3RpdmVOTztcbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggc3VpdGFibGUgZm9yIFdlYkdQVSB3aXRoIHRoZSBnaXZlbiBib3VuZHMuXG4gKiBUaGUgbmVhci9mYXIgY2xpcCBwbGFuZXMgY29ycmVzcG9uZCB0byBhIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGUgWiByYW5nZSBvZiBbMCwgMV0sXG4gKiB3aGljaCBtYXRjaGVzIFdlYkdQVS9WdWxrYW4vRGlyZWN0WC9NZXRhbCdzIGNsaXAgdm9sdW1lLlxuICogUGFzc2luZyBudWxsL3VuZGVmaW5lZC9ubyB2YWx1ZSBmb3IgZmFyIHdpbGwgZ2VuZXJhdGUgaW5maW5pdGUgcHJvamVjdGlvbiBtYXRyaXguXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgVmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW0sIGNhbiBiZSBudWxsIG9yIEluZmluaXR5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlWk8ob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICBuZjtcbiAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gZjtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNV0gPSAwO1xuICBpZiAoZmFyICE9IG51bGwgJiYgZmFyICE9PSBJbmZpbml0eSkge1xuICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTBdID0gZmFyICogbmY7XG4gICAgb3V0WzE0XSA9IGZhciAqIG5lYXIgKiBuZjtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMTBdID0gLTE7XG4gICAgb3V0WzE0XSA9IC1uZWFyO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGZpZWxkIG9mIHZpZXcuXG4gKiBUaGlzIGlzIHByaW1hcmlseSB1c2VmdWwgZm9yIGdlbmVyYXRpbmcgcHJvamVjdGlvbiBtYXRyaWNlcyB0byBiZSB1c2VkXG4gKiB3aXRoIHRoZSBzdGlsbCBleHBlcmllbWVudGFsIFdlYlZSIEFQSS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge09iamVjdH0gZm92IE9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiB1cERlZ3JlZXMsIGRvd25EZWdyZWVzLCBsZWZ0RGVncmVlcywgcmlnaHREZWdyZWVzXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyhvdXQsIGZvdiwgbmVhciwgZmFyKSB7XG4gIHZhciB1cFRhbiA9IE1hdGgudGFuKGZvdi51cERlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgZG93blRhbiA9IE1hdGgudGFuKGZvdi5kb3duRGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciBsZWZ0VGFuID0gTWF0aC50YW4oZm92LmxlZnREZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIHJpZ2h0VGFuID0gTWF0aC50YW4oZm92LnJpZ2h0RGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciB4U2NhbGUgPSAyLjAgLyAobGVmdFRhbiArIHJpZ2h0VGFuKTtcbiAgdmFyIHlTY2FsZSA9IDIuMCAvICh1cFRhbiArIGRvd25UYW4pO1xuICBvdXRbMF0gPSB4U2NhbGU7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICBvdXRbM10gPSAwLjA7XG4gIG91dFs0XSA9IDAuMDtcbiAgb3V0WzVdID0geVNjYWxlO1xuICBvdXRbNl0gPSAwLjA7XG4gIG91dFs3XSA9IDAuMDtcbiAgb3V0WzhdID0gLSgobGVmdFRhbiAtIHJpZ2h0VGFuKSAqIHhTY2FsZSAqIDAuNSk7XG4gIG91dFs5XSA9ICh1cFRhbiAtIGRvd25UYW4pICogeVNjYWxlICogMC41O1xuICBvdXRbMTBdID0gZmFyIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMTFdID0gLTEuMDtcbiAgb3V0WzEyXSA9IDAuMDtcbiAgb3V0WzEzXSA9IDAuMDtcbiAgb3V0WzE0XSA9IGZhciAqIG5lYXIgLyAobmVhciAtIGZhcik7XG4gIG91dFsxNV0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzLlxuICogVGhlIG5lYXIvZmFyIGNsaXAgcGxhbmVzIGNvcnJlc3BvbmQgdG8gYSBub3JtYWxpemVkIGRldmljZSBjb29yZGluYXRlIFogcmFuZ2Ugb2YgWy0xLCAxXSxcbiAqIHdoaWNoIG1hdGNoZXMgV2ViR0wvT3BlbkdMJ3MgY2xpcCB2b2x1bWUuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG9ydGhvTk8ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICB2YXIgbHIgPSAxIC8gKGxlZnQgLSByaWdodCk7XG4gIHZhciBidCA9IDEgLyAoYm90dG9tIC0gdG9wKTtcbiAgdmFyIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gLTIgKiBscjtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gLTIgKiBidDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDIgKiBuZjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0Lm9ydGhvTk99XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIG9ydGhvID0gb3J0aG9OTztcbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHMuXG4gKiBUaGUgbmVhci9mYXIgY2xpcCBwbGFuZXMgY29ycmVzcG9uZCB0byBhIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGUgWiByYW5nZSBvZiBbMCwgMV0sXG4gKiB3aGljaCBtYXRjaGVzIFdlYkdQVS9WdWxrYW4vRGlyZWN0WC9NZXRhbCdzIGNsaXAgdm9sdW1lLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBvcnRob1pPKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpO1xuICB2YXIgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCk7XG4gIHZhciBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IC0yICogbHI7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IC0yICogYnQ7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSBuZjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgb3V0WzE0XSA9IG5lYXIgKiBuZjtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIGxvb2stYXQgbWF0cml4IHdpdGggdGhlIGdpdmVuIGV5ZSBwb3NpdGlvbiwgZm9jYWwgcG9pbnQsIGFuZCB1cCBheGlzLlxuICogSWYgeW91IHdhbnQgYSBtYXRyaXggdGhhdCBhY3R1YWxseSBtYWtlcyBhbiBvYmplY3QgbG9vayBhdCBhbm90aGVyIG9iamVjdCwgeW91IHNob3VsZCB1c2UgdGFyZ2V0VG8gaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsb29rQXQob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgdmFyIHgwLCB4MSwgeDIsIHkwLCB5MSwgeTIsIHowLCB6MSwgejIsIGxlbjtcbiAgdmFyIGV5ZXggPSBleWVbMF07XG4gIHZhciBleWV5ID0gZXllWzFdO1xuICB2YXIgZXlleiA9IGV5ZVsyXTtcbiAgdmFyIHVweCA9IHVwWzBdO1xuICB2YXIgdXB5ID0gdXBbMV07XG4gIHZhciB1cHogPSB1cFsyXTtcbiAgdmFyIGNlbnRlcnggPSBjZW50ZXJbMF07XG4gIHZhciBjZW50ZXJ5ID0gY2VudGVyWzFdO1xuICB2YXIgY2VudGVyeiA9IGNlbnRlclsyXTtcbiAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IGdsTWF0cml4LkVQU0lMT04gJiYgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJiBNYXRoLmFicyhleWV6IC0gY2VudGVyeikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5KG91dCk7XG4gIH1cbiAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgejEgPSBleWV5IC0gY2VudGVyeTtcbiAgejIgPSBleWV6IC0gY2VudGVyejtcbiAgbGVuID0gMSAvIE1hdGguaHlwb3QoejAsIHoxLCB6Mik7XG4gIHowICo9IGxlbjtcbiAgejEgKj0gbGVuO1xuICB6MiAqPSBsZW47XG4gIHgwID0gdXB5ICogejIgLSB1cHogKiB6MTtcbiAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xuICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gIGxlbiA9IE1hdGguaHlwb3QoeDAsIHgxLCB4Mik7XG4gIGlmICghbGVuKSB7XG4gICAgeDAgPSAwO1xuICAgIHgxID0gMDtcbiAgICB4MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4MCAqPSBsZW47XG4gICAgeDEgKj0gbGVuO1xuICAgIHgyICo9IGxlbjtcbiAgfVxuICB5MCA9IHoxICogeDIgLSB6MiAqIHgxO1xuICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICB5MiA9IHowICogeDEgLSB6MSAqIHgwO1xuICBsZW4gPSBNYXRoLmh5cG90KHkwLCB5MSwgeTIpO1xuICBpZiAoIWxlbikge1xuICAgIHkwID0gMDtcbiAgICB5MSA9IDA7XG4gICAgeTIgPSAwO1xuICB9IGVsc2Uge1xuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeTAgKj0gbGVuO1xuICAgIHkxICo9IGxlbjtcbiAgICB5MiAqPSBsZW47XG4gIH1cbiAgb3V0WzBdID0geDA7XG4gIG91dFsxXSA9IHkwO1xuICBvdXRbMl0gPSB6MDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geDE7XG4gIG91dFs1XSA9IHkxO1xuICBvdXRbNl0gPSB6MTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geDI7XG4gIG91dFs5XSA9IHkyO1xuICBvdXRbMTBdID0gejI7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xuICBvdXRbMTRdID0gLSh6MCAqIGV5ZXggKyB6MSAqIGV5ZXkgKyB6MiAqIGV5ZXopO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgbWF0cml4IHRoYXQgbWFrZXMgc29tZXRoaW5nIGxvb2sgYXQgc29tZXRoaW5nIGVsc2UuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdGFyZ2V0VG8ob3V0LCBleWUsIHRhcmdldCwgdXApIHtcbiAgdmFyIGV5ZXggPSBleWVbMF0sXG4gICAgZXlleSA9IGV5ZVsxXSxcbiAgICBleWV6ID0gZXllWzJdLFxuICAgIHVweCA9IHVwWzBdLFxuICAgIHVweSA9IHVwWzFdLFxuICAgIHVweiA9IHVwWzJdO1xuICB2YXIgejAgPSBleWV4IC0gdGFyZ2V0WzBdLFxuICAgIHoxID0gZXlleSAtIHRhcmdldFsxXSxcbiAgICB6MiA9IGV5ZXogLSB0YXJnZXRbMl07XG4gIHZhciBsZW4gPSB6MCAqIHowICsgejEgKiB6MSArIHoyICogejI7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgIHowICo9IGxlbjtcbiAgICB6MSAqPSBsZW47XG4gICAgejIgKj0gbGVuO1xuICB9XG4gIHZhciB4MCA9IHVweSAqIHoyIC0gdXB6ICogejEsXG4gICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyLFxuICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgbGVuID0geDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyO1xuICBpZiAobGVuID4gMCkge1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICB4MCAqPSBsZW47XG4gICAgeDEgKj0gbGVuO1xuICAgIHgyICo9IGxlbjtcbiAgfVxuICBvdXRbMF0gPSB4MDtcbiAgb3V0WzFdID0geDE7XG4gIG91dFsyXSA9IHgyO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgb3V0WzVdID0gejIgKiB4MCAtIHowICogeDI7XG4gIG91dFs2XSA9IHowICogeDEgLSB6MSAqIHgwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB6MDtcbiAgb3V0WzldID0gejE7XG4gIG91dFsxMF0gPSB6MjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSBleWV4O1xuICBvdXRbMTNdID0gZXlleTtcbiAgb3V0WzE0XSA9IGV5ZXo7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcIm1hdDQoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIsIFwiICsgYVs0XSArIFwiLCBcIiArIGFbNV0gKyBcIiwgXCIgKyBhWzZdICsgXCIsIFwiICsgYVs3XSArIFwiLCBcIiArIGFbOF0gKyBcIiwgXCIgKyBhWzldICsgXCIsIFwiICsgYVsxMF0gKyBcIiwgXCIgKyBhWzExXSArIFwiLCBcIiArIGFbMTJdICsgXCIsIFwiICsgYVsxM10gKyBcIiwgXCIgKyBhWzE0XSArIFwiLCBcIiArIGFbMTVdICsgXCIpXCI7XG59XG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5oeXBvdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdLCBhWzZdLCBhWzddLCBhWzhdLCBhWzldLCBhWzEwXSwgYVsxMV0sIGFbMTJdLCBhWzEzXSwgYVsxNF0sIGFbMTVdKTtcbn1cbi8qKlxuICogQWRkcyB0d28gbWF0NCdzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgb3V0WzddID0gYVs3XSArIGJbN107XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdO1xuICBvdXRbOV0gPSBhWzldICsgYls5XTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgYlsxMF07XG4gIG91dFsxMV0gPSBhWzExXSArIGJbMTFdO1xuICBvdXRbMTJdID0gYVsxMl0gKyBiWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgYlsxM107XG4gIG91dFsxNF0gPSBhWzE0XSArIGJbMTRdO1xuICBvdXRbMTVdID0gYVsxNV0gKyBiWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgb3V0WzZdID0gYVs2XSAtIGJbNl07XG4gIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgb3V0WzldID0gYVs5XSAtIGJbOV07XG4gIG91dFsxMF0gPSBhWzEwXSAtIGJbMTBdO1xuICBvdXRbMTFdID0gYVsxMV0gLSBiWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdIC0gYlsxMl07XG4gIG91dFsxM10gPSBhWzEzXSAtIGJbMTNdO1xuICBvdXRbMTRdID0gYVsxNF0gLSBiWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdIC0gYlsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgb3V0WzRdID0gYVs0XSAqIGI7XG4gIG91dFs1XSA9IGFbNV0gKiBiO1xuICBvdXRbNl0gPSBhWzZdICogYjtcbiAgb3V0WzddID0gYVs3XSAqIGI7XG4gIG91dFs4XSA9IGFbOF0gKiBiO1xuICBvdXRbOV0gPSBhWzldICogYjtcbiAgb3V0WzEwXSA9IGFbMTBdICogYjtcbiAgb3V0WzExXSA9IGFbMTFdICogYjtcbiAgb3V0WzEyXSA9IGFbMTJdICogYjtcbiAgb3V0WzEzXSA9IGFbMTNdICogYjtcbiAgb3V0WzE0XSA9IGFbMTRdICogYjtcbiAgb3V0WzE1XSA9IGFbMTVdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWRkcyB0d28gbWF0NCdzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF0gKiBzY2FsZTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV0gKiBzY2FsZTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl0gKiBzY2FsZTtcbiAgb3V0WzddID0gYVs3XSArIGJbN10gKiBzY2FsZTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF0gKiBzY2FsZTtcbiAgb3V0WzldID0gYVs5XSArIGJbOV0gKiBzY2FsZTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgYlsxMF0gKiBzY2FsZTtcbiAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV0gKiBzY2FsZTtcbiAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl0gKiBzY2FsZTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgYlsxM10gKiBzY2FsZTtcbiAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF0gKiBzY2FsZTtcbiAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmIGFbOF0gPT09IGJbOF0gJiYgYVs5XSA9PT0gYls5XSAmJiBhWzEwXSA9PT0gYlsxMF0gJiYgYVsxMV0gPT09IGJbMTFdICYmIGFbMTJdID09PSBiWzEyXSAmJiBhWzEzXSA9PT0gYlsxM10gJiYgYVsxNF0gPT09IGJbMTRdICYmIGFbMTVdID09PSBiWzE1XTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICBhMSA9IGFbMV0sXG4gICAgYTIgPSBhWzJdLFxuICAgIGEzID0gYVszXTtcbiAgdmFyIGE0ID0gYVs0XSxcbiAgICBhNSA9IGFbNV0sXG4gICAgYTYgPSBhWzZdLFxuICAgIGE3ID0gYVs3XTtcbiAgdmFyIGE4ID0gYVs4XSxcbiAgICBhOSA9IGFbOV0sXG4gICAgYTEwID0gYVsxMF0sXG4gICAgYTExID0gYVsxMV07XG4gIHZhciBhMTIgPSBhWzEyXSxcbiAgICBhMTMgPSBhWzEzXSxcbiAgICBhMTQgPSBhWzE0XSxcbiAgICBhMTUgPSBhWzE1XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICBiMSA9IGJbMV0sXG4gICAgYjIgPSBiWzJdLFxuICAgIGIzID0gYlszXTtcbiAgdmFyIGI0ID0gYls0XSxcbiAgICBiNSA9IGJbNV0sXG4gICAgYjYgPSBiWzZdLFxuICAgIGI3ID0gYls3XTtcbiAgdmFyIGI4ID0gYls4XSxcbiAgICBiOSA9IGJbOV0sXG4gICAgYjEwID0gYlsxMF0sXG4gICAgYjExID0gYlsxMV07XG4gIHZhciBiMTIgPSBiWzEyXSxcbiAgICBiMTMgPSBiWzEzXSxcbiAgICBiMTQgPSBiWzE0XSxcbiAgICBiMTUgPSBiWzE1XTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJiBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiYgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE2KSwgTWF0aC5hYnMoYjYpKSAmJiBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSkgJiYgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpICYmIE1hdGguYWJzKGE5IC0gYjkpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE5KSwgTWF0aC5hYnMoYjkpKSAmJiBNYXRoLmFicyhhMTAgLSBiMTApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMCksIE1hdGguYWJzKGIxMCkpICYmIE1hdGguYWJzKGExMSAtIGIxMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTExKSwgTWF0aC5hYnMoYjExKSkgJiYgTWF0aC5hYnMoYTEyIC0gYjEyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTIpLCBNYXRoLmFicyhiMTIpKSAmJiBNYXRoLmFicyhhMTMgLSBiMTMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMyksIE1hdGguYWJzKGIxMykpICYmIE1hdGguYWJzKGExNCAtIGIxNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE0KSwgTWF0aC5hYnMoYjE0KSkgJiYgTWF0aC5hYnMoYTE1IC0gYjE1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTUpLCBNYXRoLmFicyhiMTUpKTtcbn1cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0LnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxuICogMiBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBtb2R1bGUgdmVjMlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICpcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5KSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHkpIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWRkcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFkZHMgdHdvIHZlYzIncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICB5ID0gYlsxXSAtIGFbMV07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHkpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5KTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICByZXR1cm4geCAqIHggKyB5ICogeTtcbn1cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5O1xuICBpZiAobGVuID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICB9XG4gIG91dFswXSA9IGFbMF0gKiBsZW47XG4gIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICBvdXRbMF0gPSBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgYXkgPSBhWzFdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZTtcbiAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDIob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MmQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVsxM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZSBhIDJEIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgdmVjMiBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIGIsIHJhZCkge1xuICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIHZhciBwMCA9IGFbMF0gLSBiWzBdLFxuICAgIHAxID0gYVsxXSAtIGJbMV0sXG4gICAgc2luQyA9IE1hdGguc2luKHJhZCksXG4gICAgY29zQyA9IE1hdGguY29zKHJhZCk7IC8vcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSBwMCAqIGNvc0MgLSBwMSAqIHNpbkMgKyBiWzBdO1xuICBvdXRbMV0gPSBwMCAqIHNpbkMgKyBwMSAqIGNvc0MgKyBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDJEIHZlY3RvcnNcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgdmFyIHgxID0gYVswXSxcbiAgICB5MSA9IGFbMV0sXG4gICAgeDIgPSBiWzBdLFxuICAgIHkyID0gYlsxXSxcbiAgICAvLyBtYWcgaXMgdGhlIHByb2R1Y3Qgb2YgdGhlIG1hZ25pdHVkZXMgb2YgYSBhbmQgYlxuICAgIG1hZyA9IE1hdGguc3FydCh4MSAqIHgxICsgeTEgKiB5MSkgKiBNYXRoLnNxcnQoeDIgKiB4MiArIHkyICogeTIpLFxuICAgIC8vIG1hZyAmJi4uIHNob3J0IGNpcmN1aXRzIGlmIG1hZyA9PSAwXG4gICAgY29zaW5lID0gbWFnICYmICh4MSAqIHgyICsgeTEgKiB5MikgLyBtYWc7IC8vIE1hdGgubWluKE1hdGgubWF4KGNvc2luZSwgLTEpLCAxKSBjbGFtcHMgdGhlIGNvc2luZSBiZXR3ZWVuIC0xIGFuZCAxXG5cbiAgcmV0dXJuIE1hdGguYWNvcyhNYXRoLm1pbihNYXRoLm1heChjb3NpbmUsIC0xKSwgMSkpO1xufVxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHplcm9cbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzIoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiKVwiO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGV4YWN0bHkgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICBhMSA9IGFbMV07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgYjEgPSBiWzFdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKTtcbn1cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgbGVuID0gbGVuZ3RoO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0O1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBkaXYgPSBkaXZpZGU7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgZGlzdCA9IGRpc3RhbmNlO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcbiAgICBpZiAoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gMjtcbiAgICB9XG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07XG4gICAgICB2ZWNbMV0gPSBhW2kgKyAxXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxuICogMyBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBtb2R1bGUgdmVjM1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5LCB6KSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHopO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufVxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuICBpZiAobGVuID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICB9XG4gIG91dFswXSA9IGFbMF0gKiBsZW47XG4gIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICBheSA9IGFbMV0sXG4gICAgYXogPSBhWzJdO1xuICB2YXIgYnggPSBiWzBdLFxuICAgIGJ5ID0gYlsxXSxcbiAgICBieiA9IGJbMl07XG4gIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYng7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXTtcbiAgdmFyIGF5ID0gYVsxXTtcbiAgdmFyIGF6ID0gYVsyXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSBoZXJtaXRlIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBoZXJtaXRlKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIHZhciBmYWN0b3IxID0gZmFjdG9yVGltZXMyICogKDIgKiB0IC0gMykgKyAxO1xuICB2YXIgZmFjdG9yMiA9IGZhY3RvclRpbWVzMiAqICh0IC0gMikgKyB0O1xuICB2YXIgZmFjdG9yMyA9IGZhY3RvclRpbWVzMiAqICh0IC0gMSk7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogKDMgLSAyICogdCk7XG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgYmV6aWVyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBiZXppZXIob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBpbnZlcnNlRmFjdG9yID0gMSAtIHQ7XG4gIHZhciBpbnZlcnNlRmFjdG9yVGltZXNUd28gPSBpbnZlcnNlRmFjdG9yICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvclRpbWVzMiA9IHQgKiB0O1xuICB2YXIgZmFjdG9yMSA9IGludmVyc2VGYWN0b3JUaW1lc1R3byAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3IyID0gMyAqIHQgKiBpbnZlcnNlRmFjdG9yVGltZXNUd287XG4gIHZhciBmYWN0b3IzID0gMyAqIGZhY3RvclRpbWVzMiAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogdDtcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICB2YXIgeiA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wIC0gMS4wO1xuICB2YXIgelNjYWxlID0gTWF0aC5zcXJ0KDEuMCAtIHogKiB6KSAqIHNjYWxlO1xuICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZTtcbiAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiB6U2NhbGU7XG4gIG91dFsyXSA9IHogKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdLFxuICAgIHogPSBhWzJdO1xuICB2YXIgdyA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XTtcbiAgdyA9IHcgfHwgMS4wO1xuICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gdztcbiAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdKSAvIHc7XG4gIG91dFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0pIC8gdztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBtIHRoZSAzeDMgbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXSxcbiAgICB6ID0gYVsyXTtcbiAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdO1xuICBvdXRbMV0gPSB4ICogbVsxXSArIHkgKiBtWzRdICsgeiAqIG1bN107XG4gIG91dFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICogQ2FuIGFsc28gYmUgdXNlZCBmb3IgZHVhbCBxdWF0ZXJuaW9ucy4gKE11bHRpcGx5IGl0IHdpdGggdGhlIHJlYWwgcGFydClcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgLy8gYmVuY2htYXJrczogaHR0cHM6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tdHJhbnNmb3JtLXZlYzMtaW1wbGVtZW50YXRpb25zLWZpeGVkXG4gIHZhciBxeCA9IHFbMF0sXG4gICAgcXkgPSBxWzFdLFxuICAgIHF6ID0gcVsyXSxcbiAgICBxdyA9IHFbM107XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXSxcbiAgICB6ID0gYVsyXTsgLy8gdmFyIHF2ZWMgPSBbcXgsIHF5LCBxel07XG4gIC8vIHZhciB1diA9IHZlYzMuY3Jvc3MoW10sIHF2ZWMsIGEpO1xuXG4gIHZhciB1dnggPSBxeSAqIHogLSBxeiAqIHksXG4gICAgdXZ5ID0gcXogKiB4IC0gcXggKiB6LFxuICAgIHV2eiA9IHF4ICogeSAtIHF5ICogeDsgLy8gdmFyIHV1diA9IHZlYzMuY3Jvc3MoW10sIHF2ZWMsIHV2KTtcblxuICB2YXIgdXV2eCA9IHF5ICogdXZ6IC0gcXogKiB1dnksXG4gICAgdXV2eSA9IHF6ICogdXZ4IC0gcXggKiB1dnosXG4gICAgdXV2eiA9IHF4ICogdXZ5IC0gcXkgKiB1dng7IC8vIHZlYzMuc2NhbGUodXYsIHV2LCAyICogdyk7XG5cbiAgdmFyIHcyID0gcXcgKiAyO1xuICB1dnggKj0gdzI7XG4gIHV2eSAqPSB3MjtcbiAgdXZ6ICo9IHcyOyAvLyB2ZWMzLnNjYWxlKHV1diwgdXV2LCAyKTtcblxuICB1dXZ4ICo9IDI7XG4gIHV1dnkgKj0gMjtcbiAgdXV2eiAqPSAyOyAvLyByZXR1cm4gdmVjMy5hZGQob3V0LCBhLCB2ZWMzLmFkZChvdXQsIHV2LCB1dXYpKTtcblxuICBvdXRbMF0gPSB4ICsgdXZ4ICsgdXV2eDtcbiAgb3V0WzFdID0geSArIHV2eSArIHV1dnk7XG4gIG91dFsyXSA9IHogKyB1dnogKyB1dXZ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgYiwgcmFkKSB7XG4gIHZhciBwID0gW10sXG4gICAgciA9IFtdOyAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTsgLy9wZXJmb3JtIHJvdGF0aW9uXG5cbiAgclswXSA9IHBbMF07XG4gIHJbMV0gPSBwWzFdICogTWF0aC5jb3MocmFkKSAtIHBbMl0gKiBNYXRoLnNpbihyYWQpO1xuICByWzJdID0gcFsxXSAqIE1hdGguc2luKHJhZCkgKyBwWzJdICogTWF0aC5jb3MocmFkKTsgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCBiLCByYWQpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFsyXSAqIE1hdGguc2luKHJhZCkgKyBwWzBdICogTWF0aC5jb3MocmFkKTtcbiAgclsxXSA9IHBbMV07XG4gIHJbMl0gPSBwWzJdICogTWF0aC5jb3MocmFkKSAtIHBbMF0gKiBNYXRoLnNpbihyYWQpOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzBdICogTWF0aC5jb3MocmFkKSAtIHBbMV0gKiBNYXRoLnNpbihyYWQpO1xuICByWzFdID0gcFswXSAqIE1hdGguc2luKHJhZCkgKyBwWzFdICogTWF0aC5jb3MocmFkKTtcbiAgclsyXSA9IHBbMl07IC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDNEIHZlY3RvcnNcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICBheSA9IGFbMV0sXG4gICAgYXogPSBhWzJdLFxuICAgIGJ4ID0gYlswXSxcbiAgICBieSA9IGJbMV0sXG4gICAgYnogPSBiWzJdLFxuICAgIG1hZzEgPSBNYXRoLnNxcnQoYXggKiBheCArIGF5ICogYXkgKyBheiAqIGF6KSxcbiAgICBtYWcyID0gTWF0aC5zcXJ0KGJ4ICogYnggKyBieSAqIGJ5ICsgYnogKiBieiksXG4gICAgbWFnID0gbWFnMSAqIG1hZzIsXG4gICAgY29zaW5lID0gbWFnICYmIGRvdChhLCBiKSAvIG1hZztcbiAgcmV0dXJuIE1hdGguYWNvcyhNYXRoLm1pbihNYXRoLm1heChjb3NpbmUsIC0xKSwgMSkpO1xufVxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHplcm9cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwidmVjMyhcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiKVwiO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl07XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgIGExID0gYVsxXSxcbiAgICBhMiA9IGFbMl07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgYjEgPSBiWzFdLFxuICAgIGIyID0gYlsyXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpO1xufVxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0O1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBkaXYgPSBkaXZpZGU7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgZGlzdCA9IGRpc3RhbmNlO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBsZW4gPSBsZW5ndGg7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlYyA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIHZhciBpLCBsO1xuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSAzO1xuICAgIH1cbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oY291bnQgKiBzdHJpZGUgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICAgIGFbaSArIDJdID0gdmVjWzJdO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0BtYXRoLmdsL3dlYi1tZXJjYXRvcjogYXNzZXJ0aW9uIGZhaWxlZC4nKTtcbiAgfVxufSIsImltcG9ydCB7IGNyZWF0ZU1hdDQsIHRyYW5zZm9ybVZlY3RvciwgY2xhbXAsIGxvZzIgfSBmcm9tICcuL21hdGgtdXRpbHMnO1xuaW1wb3J0ICogYXMgbWF0NCBmcm9tICdnbC1tYXRyaXgvbWF0NCc7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJ2dsLW1hdHJpeC92ZWMyJztcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSAnZ2wtbWF0cml4L3ZlYzMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuL2Fzc2VydCc7XG5jb25zdCBQSSA9IE1hdGguUEk7XG5jb25zdCBQSV80ID0gUEkgLyA0O1xuY29uc3QgREVHUkVFU19UT19SQURJQU5TID0gUEkgLyAxODA7XG5jb25zdCBSQURJQU5TX1RPX0RFR1JFRVMgPSAxODAgLyBQSTtcbmNvbnN0IFRJTEVfU0laRSA9IDUxMjtcbmNvbnN0IEVBUlRIX0NJUkNVTUZFUkVOQ0UgPSA0MC4wM2U2O1xuZXhwb3J0IGNvbnN0IE1BWF9MQVRJVFVERSA9IDg1LjA1MTEyOTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX0FMVElUVURFID0gMS41O1xuZXhwb3J0IGZ1bmN0aW9uIHpvb21Ub1NjYWxlKHpvb20pIHtcbiAgcmV0dXJuIE1hdGgucG93KDIsIHpvb20pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlVG9ab29tKHNjYWxlKSB7XG4gIHJldHVybiBsb2cyKHNjYWxlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsbmdMYXRUb1dvcmxkKGxuZ0xhdCkge1xuICBjb25zdCBbbG5nLCBsYXRdID0gbG5nTGF0O1xuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGxuZykpO1xuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGxhdCkgJiYgbGF0ID49IC05MCAmJiBsYXQgPD0gOTAsICdpbnZhbGlkIGxhdGl0dWRlJyk7XG4gIGNvbnN0IGxhbWJkYTIgPSBsbmcgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHBoaTIgPSBsYXQgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHggPSBUSUxFX1NJWkUgKiAobGFtYmRhMiArIFBJKSAvICgyICogUEkpO1xuICBjb25zdCB5ID0gVElMRV9TSVpFICogKFBJICsgTWF0aC5sb2coTWF0aC50YW4oUElfNCArIHBoaTIgKiAwLjUpKSkgLyAoMiAqIFBJKTtcbiAgcmV0dXJuIFt4LCB5XTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3b3JsZFRvTG5nTGF0KHh5KSB7XG4gIGNvbnN0IFt4LCB5XSA9IHh5O1xuICBjb25zdCBsYW1iZGEyID0geCAvIFRJTEVfU0laRSAqICgyICogUEkpIC0gUEk7XG4gIGNvbnN0IHBoaTIgPSAyICogKE1hdGguYXRhbihNYXRoLmV4cCh5IC8gVElMRV9TSVpFICogKDIgKiBQSSkgLSBQSSkpIC0gUElfNCk7XG4gIHJldHVybiBbbGFtYmRhMiAqIFJBRElBTlNfVE9fREVHUkVFUywgcGhpMiAqIFJBRElBTlNfVE9fREVHUkVFU107XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TWV0ZXJab29tKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGxhdGl0dWRlXG4gIH0gPSBvcHRpb25zO1xuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGxhdGl0dWRlKSk7XG4gIGNvbnN0IGxhdENvc2luZSA9IE1hdGguY29zKGxhdGl0dWRlICogREVHUkVFU19UT19SQURJQU5TKTtcbiAgcmV0dXJuIHNjYWxlVG9ab29tKEVBUlRIX0NJUkNVTUZFUkVOQ0UgKiBsYXRDb3NpbmUpIC0gOTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1bml0c1Blck1ldGVyKGxhdGl0dWRlKSB7XG4gIGNvbnN0IGxhdENvc2luZSA9IE1hdGguY29zKGxhdGl0dWRlICogREVHUkVFU19UT19SQURJQU5TKTtcbiAgcmV0dXJuIFRJTEVfU0laRSAvIEVBUlRIX0NJUkNVTUZFUkVOQ0UgLyBsYXRDb3NpbmU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzdGFuY2VTY2FsZXMob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgbGF0aXR1ZGUsXG4gICAgbG9uZ2l0dWRlLFxuICAgIGhpZ2hQcmVjaXNpb24gPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShsYXRpdHVkZSkgJiYgTnVtYmVyLmlzRmluaXRlKGxvbmdpdHVkZSkpO1xuICBjb25zdCB3b3JsZFNpemUgPSBUSUxFX1NJWkU7XG4gIGNvbnN0IGxhdENvc2luZSA9IE1hdGguY29zKGxhdGl0dWRlICogREVHUkVFU19UT19SQURJQU5TKTtcbiAgY29uc3QgdW5pdHNQZXJEZWdyZWVYID0gd29ybGRTaXplIC8gMzYwO1xuICBjb25zdCB1bml0c1BlckRlZ3JlZVkgPSB1bml0c1BlckRlZ3JlZVggLyBsYXRDb3NpbmU7XG4gIGNvbnN0IGFsdFVuaXRzUGVyTWV0ZXIgPSB3b3JsZFNpemUgLyBFQVJUSF9DSVJDVU1GRVJFTkNFIC8gbGF0Q29zaW5lO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgdW5pdHNQZXJNZXRlcjogW2FsdFVuaXRzUGVyTWV0ZXIsIGFsdFVuaXRzUGVyTWV0ZXIsIGFsdFVuaXRzUGVyTWV0ZXJdLFxuICAgIG1ldGVyc1BlclVuaXQ6IFsxIC8gYWx0VW5pdHNQZXJNZXRlciwgMSAvIGFsdFVuaXRzUGVyTWV0ZXIsIDEgLyBhbHRVbml0c1Blck1ldGVyXSxcbiAgICB1bml0c1BlckRlZ3JlZTogW3VuaXRzUGVyRGVncmVlWCwgdW5pdHNQZXJEZWdyZWVZLCBhbHRVbml0c1Blck1ldGVyXSxcbiAgICBkZWdyZWVzUGVyVW5pdDogWzEgLyB1bml0c1BlckRlZ3JlZVgsIDEgLyB1bml0c1BlckRlZ3JlZVksIDEgLyBhbHRVbml0c1Blck1ldGVyXVxuICB9O1xuICBpZiAoaGlnaFByZWNpc2lvbikge1xuICAgIGNvbnN0IGxhdENvc2luZTIgPSBERUdSRUVTX1RPX1JBRElBTlMgKiBNYXRoLnRhbihsYXRpdHVkZSAqIERFR1JFRVNfVE9fUkFESUFOUykgLyBsYXRDb3NpbmU7XG4gICAgY29uc3QgdW5pdHNQZXJEZWdyZWVZMiA9IHVuaXRzUGVyRGVncmVlWCAqIGxhdENvc2luZTIgLyAyO1xuICAgIGNvbnN0IGFsdFVuaXRzUGVyRGVncmVlMiA9IHdvcmxkU2l6ZSAvIEVBUlRIX0NJUkNVTUZFUkVOQ0UgKiBsYXRDb3NpbmUyO1xuICAgIGNvbnN0IGFsdFVuaXRzUGVyTWV0ZXIyID0gYWx0VW5pdHNQZXJEZWdyZWUyIC8gdW5pdHNQZXJEZWdyZWVZICogYWx0VW5pdHNQZXJNZXRlcjtcbiAgICByZXN1bHQudW5pdHNQZXJEZWdyZWUyID0gWzAsIHVuaXRzUGVyRGVncmVlWTIsIGFsdFVuaXRzUGVyRGVncmVlMl07XG4gICAgcmVzdWx0LnVuaXRzUGVyTWV0ZXIyID0gW2FsdFVuaXRzUGVyTWV0ZXIyLCAwLCBhbHRVbml0c1Blck1ldGVyMl07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhZGRNZXRlcnNUb0xuZ0xhdChsbmdMYXRaLCB4eXopIHtcbiAgY29uc3QgW2xvbmdpdHVkZSwgbGF0aXR1ZGUsIHowXSA9IGxuZ0xhdFo7XG4gIGNvbnN0IFt4LCB5LCB6XSA9IHh5ejtcbiAgY29uc3Qge1xuICAgIHVuaXRzUGVyTWV0ZXIsXG4gICAgdW5pdHNQZXJNZXRlcjJcbiAgfSA9IGdldERpc3RhbmNlU2NhbGVzKHtcbiAgICBsb25naXR1ZGUsXG4gICAgbGF0aXR1ZGUsXG4gICAgaGlnaFByZWNpc2lvbjogdHJ1ZVxuICB9KTtcbiAgY29uc3Qgd29ybGRzcGFjZSA9IGxuZ0xhdFRvV29ybGQobG5nTGF0Wik7XG4gIHdvcmxkc3BhY2VbMF0gKz0geCAqICh1bml0c1Blck1ldGVyWzBdICsgdW5pdHNQZXJNZXRlcjJbMF0gKiB5KTtcbiAgd29ybGRzcGFjZVsxXSArPSB5ICogKHVuaXRzUGVyTWV0ZXJbMV0gKyB1bml0c1Blck1ldGVyMlsxXSAqIHkpO1xuICBjb25zdCBuZXdMbmdMYXQgPSB3b3JsZFRvTG5nTGF0KHdvcmxkc3BhY2UpO1xuICBjb25zdCBuZXdaID0gKHowIHx8IDApICsgKHogfHwgMCk7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUoejApIHx8IE51bWJlci5pc0Zpbml0ZSh6KSA/IFtuZXdMbmdMYXRbMF0sIG5ld0xuZ0xhdFsxXSwgbmV3Wl0gOiBuZXdMbmdMYXQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Vmlld01hdHJpeChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBoZWlnaHQsXG4gICAgcGl0Y2gsXG4gICAgYmVhcmluZyxcbiAgICBhbHRpdHVkZSxcbiAgICBzY2FsZSxcbiAgICBjZW50ZXJcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHZtID0gY3JlYXRlTWF0NCgpO1xuICBtYXQ0LnRyYW5zbGF0ZSh2bSwgdm0sIFswLCAwLCAtYWx0aXR1ZGVdKTtcbiAgbWF0NC5yb3RhdGVYKHZtLCB2bSwgLXBpdGNoICogREVHUkVFU19UT19SQURJQU5TKTtcbiAgbWF0NC5yb3RhdGVaKHZtLCB2bSwgYmVhcmluZyAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG4gIGNvbnN0IHJlbGF0aXZlU2NhbGUgPSBzY2FsZSAvIGhlaWdodDtcbiAgbWF0NC5zY2FsZSh2bSwgdm0sIFtyZWxhdGl2ZVNjYWxlLCByZWxhdGl2ZVNjYWxlLCByZWxhdGl2ZVNjYWxlXSk7XG4gIGlmIChjZW50ZXIpIHtcbiAgICBtYXQ0LnRyYW5zbGF0ZSh2bSwgdm0sIHZlYzMubmVnYXRlKFtdLCBjZW50ZXIpKTtcbiAgfVxuICByZXR1cm4gdm07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvamVjdGlvblBhcmFtZXRlcnMob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGFsdGl0dWRlLFxuICAgIHBpdGNoID0gMCxcbiAgICBvZmZzZXQsXG4gICAgY2VudGVyLFxuICAgIHNjYWxlLFxuICAgIG5lYXJaTXVsdGlwbGllciA9IDEsXG4gICAgZmFyWk11bHRpcGxpZXIgPSAxXG4gIH0gPSBvcHRpb25zO1xuICBsZXQge1xuICAgIGZvdnkgPSBhbHRpdHVkZVRvRm92eShERUZBVUxUX0FMVElUVURFKVxuICB9ID0gb3B0aW9ucztcbiAgaWYgKGFsdGl0dWRlICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3Z5ID0gYWx0aXR1ZGVUb0ZvdnkoYWx0aXR1ZGUpO1xuICB9XG4gIGNvbnN0IGZvdlJhZGlhbnMgPSBmb3Z5ICogREVHUkVFU19UT19SQURJQU5TO1xuICBjb25zdCBwaXRjaFJhZGlhbnMgPSBwaXRjaCAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgY29uc3QgZm9jYWxEaXN0YW5jZSA9IGZvdnlUb0FsdGl0dWRlKGZvdnkpO1xuICBsZXQgY2FtZXJhVG9TZWFMZXZlbERpc3RhbmNlID0gZm9jYWxEaXN0YW5jZTtcbiAgaWYgKGNlbnRlcikge1xuICAgIGNhbWVyYVRvU2VhTGV2ZWxEaXN0YW5jZSArPSBjZW50ZXJbMl0gKiBzY2FsZSAvIE1hdGguY29zKHBpdGNoUmFkaWFucykgLyBoZWlnaHQ7XG4gIH1cbiAgY29uc3QgZm92QWJvdmVDZW50ZXIgPSBmb3ZSYWRpYW5zICogKDAuNSArIChvZmZzZXQgPyBvZmZzZXRbMV0gOiAwKSAvIGhlaWdodCk7XG4gIGNvbnN0IHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgPSBNYXRoLnNpbihmb3ZBYm92ZUNlbnRlcikgKiBjYW1lcmFUb1NlYUxldmVsRGlzdGFuY2UgLyBNYXRoLnNpbihjbGFtcChNYXRoLlBJIC8gMiAtIHBpdGNoUmFkaWFucyAtIGZvdkFib3ZlQ2VudGVyLCAwLjAxLCBNYXRoLlBJIC0gMC4wMSkpO1xuICBjb25zdCBmdXJ0aGVzdERpc3RhbmNlID0gTWF0aC5zaW4ocGl0Y2hSYWRpYW5zKSAqIHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgKyBjYW1lcmFUb1NlYUxldmVsRGlzdGFuY2U7XG4gIGNvbnN0IGhvcml6b25EaXN0YW5jZSA9IGNhbWVyYVRvU2VhTGV2ZWxEaXN0YW5jZSAqIDEwO1xuICBjb25zdCBmYXJaID0gTWF0aC5taW4oZnVydGhlc3REaXN0YW5jZSAqIGZhclpNdWx0aXBsaWVyLCBob3Jpem9uRGlzdGFuY2UpO1xuICByZXR1cm4ge1xuICAgIGZvdjogZm92UmFkaWFucyxcbiAgICBhc3BlY3Q6IHdpZHRoIC8gaGVpZ2h0LFxuICAgIGZvY2FsRGlzdGFuY2UsXG4gICAgbmVhcjogbmVhclpNdWx0aXBsaWVyLFxuICAgIGZhcjogZmFyWlxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2plY3Rpb25NYXRyaXgob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgZm92LFxuICAgIGFzcGVjdCxcbiAgICBuZWFyLFxuICAgIGZhclxuICB9ID0gZ2V0UHJvamVjdGlvblBhcmFtZXRlcnMob3B0aW9ucyk7XG4gIGNvbnN0IHByb2plY3Rpb25NYXRyaXggPSBtYXQ0LnBlcnNwZWN0aXZlKFtdLCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyKTtcbiAgcmV0dXJuIHByb2plY3Rpb25NYXRyaXg7XG59XG5leHBvcnQgZnVuY3Rpb24gYWx0aXR1ZGVUb0ZvdnkoYWx0aXR1ZGUpIHtcbiAgcmV0dXJuIDIgKiBNYXRoLmF0YW4oMC41IC8gYWx0aXR1ZGUpICogUkFESUFOU19UT19ERUdSRUVTO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvdnlUb0FsdGl0dWRlKGZvdnkpIHtcbiAgcmV0dXJuIDAuNSAvIE1hdGgudGFuKDAuNSAqIGZvdnkgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdvcmxkVG9QaXhlbHMoeHl6LCBwaXhlbFByb2plY3Rpb25NYXRyaXgpIHtcbiAgY29uc3QgW3gsIHksIHogPSAwXSA9IHh5ejtcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh4KSAmJiBOdW1iZXIuaXNGaW5pdGUoeSkgJiYgTnVtYmVyLmlzRmluaXRlKHopKTtcbiAgcmV0dXJuIHRyYW5zZm9ybVZlY3RvcihwaXhlbFByb2plY3Rpb25NYXRyaXgsIFt4LCB5LCB6LCAxXSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGl4ZWxzVG9Xb3JsZCh4eXosIHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4KSB7XG4gIGxldCB0YXJnZXRaID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICBjb25zdCBbeCwgeSwgel0gPSB4eXo7XG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoeCkgJiYgTnVtYmVyLmlzRmluaXRlKHkpLCAnaW52YWxpZCBwaXhlbCBjb29yZGluYXRlJyk7XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoeikpIHtcbiAgICBjb25zdCBjb29yZCA9IHRyYW5zZm9ybVZlY3RvcihwaXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIHksIHosIDFdKTtcbiAgICByZXR1cm4gY29vcmQ7XG4gIH1cbiAgY29uc3QgY29vcmQwID0gdHJhbnNmb3JtVmVjdG9yKHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgeSwgMCwgMV0pO1xuICBjb25zdCBjb29yZDEgPSB0cmFuc2Zvcm1WZWN0b3IocGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIFt4LCB5LCAxLCAxXSk7XG4gIGNvbnN0IHowID0gY29vcmQwWzJdO1xuICBjb25zdCB6MSA9IGNvb3JkMVsyXTtcbiAgY29uc3QgdCA9IHowID09PSB6MSA/IDAgOiAoKHRhcmdldFogfHwgMCkgLSB6MCkgLyAoejEgLSB6MCk7XG4gIHJldHVybiB2ZWMyLmxlcnAoW10sIGNvb3JkMCwgY29vcmQxLCB0KTtcbn0iLCJpbXBvcnQgYXNzZXJ0IGZyb20gJy4vYXNzZXJ0JztcbmltcG9ydCB7IGxvZzIsIGNsYW1wIH0gZnJvbSAnLi9tYXRoLXV0aWxzJztcbmltcG9ydCB7IE1BWF9MQVRJVFVERSwgbG5nTGF0VG9Xb3JsZCwgd29ybGRUb0xuZ0xhdCB9IGZyb20gJy4vd2ViLW1lcmNhdG9yLXV0aWxzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpdEJvdW5kcyhvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgYm91bmRzLFxuICAgIG1pbkV4dGVudCA9IDAsXG4gICAgbWF4Wm9vbSA9IDI0LFxuICAgIG9mZnNldCA9IFswLCAwXVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgW1t3ZXN0LCBzb3V0aF0sIFtlYXN0LCBub3J0aF1dID0gYm91bmRzO1xuICBjb25zdCBwYWRkaW5nID0gZ2V0UGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcpO1xuICBjb25zdCBudyA9IGxuZ0xhdFRvV29ybGQoW3dlc3QsIGNsYW1wKG5vcnRoLCAtTUFYX0xBVElUVURFLCBNQVhfTEFUSVRVREUpXSk7XG4gIGNvbnN0IHNlID0gbG5nTGF0VG9Xb3JsZChbZWFzdCwgY2xhbXAoc291dGgsIC1NQVhfTEFUSVRVREUsIE1BWF9MQVRJVFVERSldKTtcbiAgY29uc3Qgc2l6ZSA9IFtNYXRoLm1heChNYXRoLmFicyhzZVswXSAtIG53WzBdKSwgbWluRXh0ZW50KSwgTWF0aC5tYXgoTWF0aC5hYnMoc2VbMV0gLSBud1sxXSksIG1pbkV4dGVudCldO1xuICBjb25zdCB0YXJnZXRTaXplID0gW3dpZHRoIC0gcGFkZGluZy5sZWZ0IC0gcGFkZGluZy5yaWdodCAtIE1hdGguYWJzKG9mZnNldFswXSkgKiAyLCBoZWlnaHQgLSBwYWRkaW5nLnRvcCAtIHBhZGRpbmcuYm90dG9tIC0gTWF0aC5hYnMob2Zmc2V0WzFdKSAqIDJdO1xuICBhc3NlcnQodGFyZ2V0U2l6ZVswXSA+IDAgJiYgdGFyZ2V0U2l6ZVsxXSA+IDApO1xuICBjb25zdCBzY2FsZVggPSB0YXJnZXRTaXplWzBdIC8gc2l6ZVswXTtcbiAgY29uc3Qgc2NhbGVZID0gdGFyZ2V0U2l6ZVsxXSAvIHNpemVbMV07XG4gIGNvbnN0IG9mZnNldFggPSAocGFkZGluZy5yaWdodCAtIHBhZGRpbmcubGVmdCkgLyAyIC8gc2NhbGVYO1xuICBjb25zdCBvZmZzZXRZID0gKHBhZGRpbmcudG9wIC0gcGFkZGluZy5ib3R0b20pIC8gMiAvIHNjYWxlWTtcbiAgY29uc3QgY2VudGVyID0gWyhzZVswXSArIG53WzBdKSAvIDIgKyBvZmZzZXRYLCAoc2VbMV0gKyBud1sxXSkgLyAyICsgb2Zmc2V0WV07XG4gIGNvbnN0IGNlbnRlckxuZ0xhdCA9IHdvcmxkVG9MbmdMYXQoY2VudGVyKTtcbiAgY29uc3Qgem9vbSA9IE1hdGgubWluKG1heFpvb20sIGxvZzIoTWF0aC5hYnMoTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpKSkpO1xuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHpvb20pKTtcbiAgcmV0dXJuIHtcbiAgICBsb25naXR1ZGU6IGNlbnRlckxuZ0xhdFswXSxcbiAgICBsYXRpdHVkZTogY2VudGVyTG5nTGF0WzFdLFxuICAgIHpvb21cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhZGRpbmdPYmplY3QoKSB7XG4gIGxldCBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICBpZiAodHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogcGFkZGluZyxcbiAgICAgIGJvdHRvbTogcGFkZGluZyxcbiAgICAgIGxlZnQ6IHBhZGRpbmcsXG4gICAgICByaWdodDogcGFkZGluZ1xuICAgIH07XG4gIH1cbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShwYWRkaW5nLnRvcCkgJiYgTnVtYmVyLmlzRmluaXRlKHBhZGRpbmcuYm90dG9tKSAmJiBOdW1iZXIuaXNGaW5pdGUocGFkZGluZy5sZWZ0KSAmJiBOdW1iZXIuaXNGaW5pdGUocGFkZGluZy5yaWdodCkpO1xuICByZXR1cm4gcGFkZGluZztcbn0iLCJpbXBvcnQgeyB3b3JsZFRvTG5nTGF0IH0gZnJvbSAnLi93ZWItbWVyY2F0b3ItdXRpbHMnO1xuaW1wb3J0ICogYXMgdmVjMiBmcm9tICdnbC1tYXRyaXgvdmVjMic7XG5pbXBvcnQgeyB0cmFuc2Zvcm1WZWN0b3IgfSBmcm9tICcuL21hdGgtdXRpbHMnO1xuY29uc3QgREVHUkVFU19UT19SQURJQU5TID0gTWF0aC5QSSAvIDE4MDtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvdW5kcyh2aWV3cG9ydCkge1xuICBsZXQgeiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB1bnByb2plY3RcbiAgfSA9IHZpZXdwb3J0O1xuICBjb25zdCB1bnByb2plY3RPcHMgPSB7XG4gICAgdGFyZ2V0WjogelxuICB9O1xuICBjb25zdCBib3R0b21MZWZ0ID0gdW5wcm9qZWN0KFswLCBoZWlnaHRdLCB1bnByb2plY3RPcHMpO1xuICBjb25zdCBib3R0b21SaWdodCA9IHVucHJvamVjdChbd2lkdGgsIGhlaWdodF0sIHVucHJvamVjdE9wcyk7XG4gIGxldCB0b3BMZWZ0O1xuICBsZXQgdG9wUmlnaHQ7XG4gIGNvbnN0IGhhbGZGb3YgPSB2aWV3cG9ydC5mb3Z5ID8gMC41ICogdmlld3BvcnQuZm92eSAqIERFR1JFRVNfVE9fUkFESUFOUyA6IE1hdGguYXRhbigwLjUgLyB2aWV3cG9ydC5hbHRpdHVkZSk7XG4gIGNvbnN0IGFuZ2xlVG9Hcm91bmQgPSAoOTAgLSB2aWV3cG9ydC5waXRjaCkgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGlmIChoYWxmRm92ID4gYW5nbGVUb0dyb3VuZCAtIDAuMDEpIHtcbiAgICB0b3BMZWZ0ID0gdW5wcm9qZWN0T25GYXJQbGFuZSh2aWV3cG9ydCwgMCwgeik7XG4gICAgdG9wUmlnaHQgPSB1bnByb2plY3RPbkZhclBsYW5lKHZpZXdwb3J0LCB3aWR0aCwgeik7XG4gIH0gZWxzZSB7XG4gICAgdG9wTGVmdCA9IHVucHJvamVjdChbMCwgMF0sIHVucHJvamVjdE9wcyk7XG4gICAgdG9wUmlnaHQgPSB1bnByb2plY3QoW3dpZHRoLCAwXSwgdW5wcm9qZWN0T3BzKTtcbiAgfVxuICByZXR1cm4gW2JvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCB0b3BSaWdodCwgdG9wTGVmdF07XG59XG5mdW5jdGlvbiB1bnByb2plY3RPbkZhclBsYW5lKHZpZXdwb3J0LCB4LCB0YXJnZXRaKSB7XG4gIGNvbnN0IHtcbiAgICBwaXhlbFVucHJvamVjdGlvbk1hdHJpeFxuICB9ID0gdmlld3BvcnQ7XG4gIGNvbnN0IGNvb3JkMCA9IHRyYW5zZm9ybVZlY3RvcihwaXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIDAsIDEsIDFdKTtcbiAgY29uc3QgY29vcmQxID0gdHJhbnNmb3JtVmVjdG9yKHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgdmlld3BvcnQuaGVpZ2h0LCAxLCAxXSk7XG4gIGNvbnN0IHogPSB0YXJnZXRaICogdmlld3BvcnQuZGlzdGFuY2VTY2FsZXMudW5pdHNQZXJNZXRlclsyXTtcbiAgY29uc3QgdCA9ICh6IC0gY29vcmQwWzJdKSAvIChjb29yZDFbMl0gLSBjb29yZDBbMl0pO1xuICBjb25zdCBjb29yZCA9IHZlYzIubGVycChbXSwgY29vcmQwLCBjb29yZDEsIHQpO1xuICBjb25zdCByZXN1bHQgPSB3b3JsZFRvTG5nTGF0KGNvb3JkKTtcbiAgcmVzdWx0LnB1c2godGFyZ2V0Wik7XG4gIHJldHVybiByZXN1bHQ7XG59IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCB7IGNyZWF0ZU1hdDQgfSBmcm9tICcuL21hdGgtdXRpbHMnO1xuaW1wb3J0IHsgem9vbVRvU2NhbGUsIHBpeGVsc1RvV29ybGQsIGxuZ0xhdFRvV29ybGQsIHdvcmxkVG9MbmdMYXQsIHdvcmxkVG9QaXhlbHMsIGFsdGl0dWRlVG9Gb3Z5LCBmb3Z5VG9BbHRpdHVkZSwgREVGQVVMVF9BTFRJVFVERSwgZ2V0UHJvamVjdGlvbk1hdHJpeCwgZ2V0RGlzdGFuY2VTY2FsZXMsIGdldFZpZXdNYXRyaXggfSBmcm9tICcuL3dlYi1tZXJjYXRvci11dGlscyc7XG5pbXBvcnQgZml0Qm91bmRzIGZyb20gJy4vZml0LWJvdW5kcyc7XG5pbXBvcnQgZ2V0Qm91bmRzIGZyb20gJy4vZ2V0LWJvdW5kcyc7XG5pbXBvcnQgKiBhcyBtYXQ0IGZyb20gJ2dsLW1hdHJpeC9tYXQ0JztcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnZ2wtbWF0cml4L3ZlYzInO1xuaW1wb3J0ICogYXMgdmVjMyBmcm9tICdnbC1tYXRyaXgvdmVjMyc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJNZXJjYXRvclZpZXdwb3J0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBsZXQgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHtcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgaGVpZ2h0OiAxXG4gICAgfTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJsYXRpdHVkZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxvbmdpdHVkZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInpvb21cIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwaXRjaFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJlYXJpbmdcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJhbHRpdHVkZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZvdnlcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRlck9mZnNldFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNlbnRlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndpZHRoXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkaXN0YW5jZVNjYWxlc1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZpZXdNYXRyaXhcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9qZWN0aW9uTWF0cml4XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidmlld1Byb2plY3Rpb25NYXRyaXhcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwaXhlbFByb2plY3Rpb25NYXRyaXhcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwaXhlbFVucHJvamVjdGlvbk1hdHJpeFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVxdWFsc1wiLCB2aWV3cG9ydCA9PiB7XG4gICAgICBpZiAoISh2aWV3cG9ydCBpbnN0YW5jZW9mIFdlYk1lcmNhdG9yVmlld3BvcnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2aWV3cG9ydC53aWR0aCA9PT0gdGhpcy53aWR0aCAmJiB2aWV3cG9ydC5oZWlnaHQgPT09IHRoaXMuaGVpZ2h0ICYmIG1hdDQuZXF1YWxzKHZpZXdwb3J0LnByb2plY3Rpb25NYXRyaXgsIHRoaXMucHJvamVjdGlvbk1hdHJpeCkgJiYgbWF0NC5lcXVhbHModmlld3BvcnQudmlld01hdHJpeCwgdGhpcy52aWV3TWF0cml4KTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9qZWN0XCIsIGZ1bmN0aW9uIChsbmdMYXRaKSB7XG4gICAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRvcExlZnQgPSB0cnVlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IHdvcmxkUG9zaXRpb24gPSBfdGhpcy5wcm9qZWN0UG9zaXRpb24obG5nTGF0Wik7XG4gICAgICBjb25zdCBjb29yZCA9IHdvcmxkVG9QaXhlbHMod29ybGRQb3NpdGlvbiwgX3RoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4KTtcbiAgICAgIGNvbnN0IFt4LCB5XSA9IGNvb3JkO1xuICAgICAgY29uc3QgeTIgPSB0b3BMZWZ0ID8geSA6IF90aGlzLmhlaWdodCAtIHk7XG4gICAgICByZXR1cm4gbG5nTGF0Wi5sZW5ndGggPT09IDIgPyBbeCwgeTJdIDogW3gsIHkyLCBjb29yZFsyXV07XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidW5wcm9qZWN0XCIsIGZ1bmN0aW9uICh4eXopIHtcbiAgICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdG9wTGVmdCA9IHRydWUsXG4gICAgICAgIHRhcmdldFogPSB1bmRlZmluZWRcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3QgW3gsIHksIHpdID0geHl6O1xuICAgICAgY29uc3QgeTIgPSB0b3BMZWZ0ID8geSA6IF90aGlzLmhlaWdodCAtIHk7XG4gICAgICBjb25zdCB0YXJnZXRaV29ybGQgPSB0YXJnZXRaICYmIHRhcmdldFogKiBfdGhpcy5kaXN0YW5jZVNjYWxlcy51bml0c1Blck1ldGVyWzJdO1xuICAgICAgY29uc3QgY29vcmQgPSBwaXhlbHNUb1dvcmxkKFt4LCB5Miwgel0sIF90aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCB0YXJnZXRaV29ybGQpO1xuICAgICAgY29uc3QgW1gsIFksIFpdID0gX3RoaXMudW5wcm9qZWN0UG9zaXRpb24oY29vcmQpO1xuICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh6KSkge1xuICAgICAgICByZXR1cm4gW1gsIFksIFpdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh0YXJnZXRaKSA/IFtYLCBZLCB0YXJnZXRaXSA6IFtYLCBZXTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9qZWN0UG9zaXRpb25cIiwgeHl6ID0+IHtcbiAgICAgIGNvbnN0IFtYLCBZXSA9IGxuZ0xhdFRvV29ybGQoeHl6KTtcbiAgICAgIGNvbnN0IFogPSAoeHl6WzJdIHx8IDApICogdGhpcy5kaXN0YW5jZVNjYWxlcy51bml0c1Blck1ldGVyWzJdO1xuICAgICAgcmV0dXJuIFtYLCBZLCBaXTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1bnByb2plY3RQb3NpdGlvblwiLCB4eXogPT4ge1xuICAgICAgY29uc3QgW1gsIFldID0gd29ybGRUb0xuZ0xhdCh4eXopO1xuICAgICAgY29uc3QgWiA9ICh4eXpbMl0gfHwgMCkgKiB0aGlzLmRpc3RhbmNlU2NhbGVzLm1ldGVyc1BlclVuaXRbMl07XG4gICAgICByZXR1cm4gW1gsIFksIFpdO1xuICAgIH0pO1xuICAgIGxldCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGFsdGl0dWRlID0gbnVsbCxcbiAgICAgIGZvdnkgPSBudWxsXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhdGl0dWRlID0gMCxcbiAgICAgIGxvbmdpdHVkZSA9IDAsXG4gICAgICB6b29tID0gMCxcbiAgICAgIHBpdGNoID0gMCxcbiAgICAgIGJlYXJpbmcgPSAwLFxuICAgICAgcG9zaXRpb24gPSBudWxsLFxuICAgICAgbmVhclpNdWx0aXBsaWVyID0gMC4wMixcbiAgICAgIGZhclpNdWx0aXBsaWVyID0gMS4wMVxuICAgIH0gPSBwcm9wcztcbiAgICB3aWR0aCA9IHdpZHRoIHx8IDE7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG4gICAgaWYgKGZvdnkgPT09IG51bGwgJiYgYWx0aXR1ZGUgPT09IG51bGwpIHtcbiAgICAgIGFsdGl0dWRlID0gREVGQVVMVF9BTFRJVFVERTtcbiAgICAgIGZvdnkgPSBhbHRpdHVkZVRvRm92eShhbHRpdHVkZSk7XG4gICAgfSBlbHNlIGlmIChmb3Z5ID09PSBudWxsKSB7XG4gICAgICBmb3Z5ID0gYWx0aXR1ZGVUb0ZvdnkoYWx0aXR1ZGUpO1xuICAgIH0gZWxzZSBpZiAoYWx0aXR1ZGUgPT09IG51bGwpIHtcbiAgICAgIGFsdGl0dWRlID0gZm92eVRvQWx0aXR1ZGUoZm92eSk7XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlID0gem9vbVRvU2NhbGUoem9vbSk7XG4gICAgYWx0aXR1ZGUgPSBNYXRoLm1heCgwLjc1LCBhbHRpdHVkZSk7XG4gICAgY29uc3QgZGlzdGFuY2VTY2FsZXMgPSBnZXREaXN0YW5jZVNjYWxlcyh7XG4gICAgICBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZVxuICAgIH0pO1xuICAgIGNvbnN0IGNlbnRlciA9IGxuZ0xhdFRvV29ybGQoW2xvbmdpdHVkZSwgbGF0aXR1ZGVdKTtcbiAgICBjZW50ZXIucHVzaCgwKTtcbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIHZlYzMuYWRkKGNlbnRlciwgY2VudGVyLCB2ZWMzLm11bChbXSwgcG9zaXRpb24sIGRpc3RhbmNlU2NhbGVzLnVuaXRzUGVyTWV0ZXIpKTtcbiAgICB9XG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gZ2V0UHJvamVjdGlvbk1hdHJpeCh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHNjYWxlLFxuICAgICAgY2VudGVyLFxuICAgICAgcGl0Y2gsXG4gICAgICBmb3Z5LFxuICAgICAgbmVhclpNdWx0aXBsaWVyLFxuICAgICAgZmFyWk11bHRpcGxpZXJcbiAgICB9KTtcbiAgICB0aGlzLnZpZXdNYXRyaXggPSBnZXRWaWV3TWF0cml4KHtcbiAgICAgIGhlaWdodCxcbiAgICAgIHNjYWxlLFxuICAgICAgY2VudGVyLFxuICAgICAgcGl0Y2gsXG4gICAgICBiZWFyaW5nLFxuICAgICAgYWx0aXR1ZGVcbiAgICB9KTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMubGF0aXR1ZGUgPSBsYXRpdHVkZTtcbiAgICB0aGlzLmxvbmdpdHVkZSA9IGxvbmdpdHVkZTtcbiAgICB0aGlzLnpvb20gPSB6b29tO1xuICAgIHRoaXMucGl0Y2ggPSBwaXRjaDtcbiAgICB0aGlzLmJlYXJpbmcgPSBiZWFyaW5nO1xuICAgIHRoaXMuYWx0aXR1ZGUgPSBhbHRpdHVkZTtcbiAgICB0aGlzLmZvdnkgPSBmb3Z5O1xuICAgIHRoaXMuY2VudGVyID0gY2VudGVyO1xuICAgIHRoaXMubWV0ZXJPZmZzZXQgPSBwb3NpdGlvbiB8fCBbMCwgMCwgMF07XG4gICAgdGhpcy5kaXN0YW5jZVNjYWxlcyA9IGRpc3RhbmNlU2NhbGVzO1xuICAgIHRoaXMuX2luaXRNYXRyaWNlcygpO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbiAgX2luaXRNYXRyaWNlcygpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHByb2plY3Rpb25NYXRyaXgsXG4gICAgICB2aWV3TWF0cml4XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgdnBtID0gY3JlYXRlTWF0NCgpO1xuICAgIG1hdDQubXVsdGlwbHkodnBtLCB2cG0sIHByb2plY3Rpb25NYXRyaXgpO1xuICAgIG1hdDQubXVsdGlwbHkodnBtLCB2cG0sIHZpZXdNYXRyaXgpO1xuICAgIHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXggPSB2cG07XG4gICAgY29uc3QgbSA9IGNyZWF0ZU1hdDQoKTtcbiAgICBtYXQ0LnNjYWxlKG0sIG0sIFt3aWR0aCAvIDIsIC1oZWlnaHQgLyAyLCAxXSk7XG4gICAgbWF0NC50cmFuc2xhdGUobSwgbSwgWzEsIC0xLCAwXSk7XG4gICAgbWF0NC5tdWx0aXBseShtLCBtLCB2cG0pO1xuICAgIGNvbnN0IG1JbnZlcnNlID0gbWF0NC5pbnZlcnQoY3JlYXRlTWF0NCgpLCBtKTtcbiAgICBpZiAoIW1JbnZlcnNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BpeGVsIHByb2plY3QgbWF0cml4IG5vdCBpbnZlcnRpYmxlJyk7XG4gICAgfVxuICAgIHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4ID0gbTtcbiAgICB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4ID0gbUludmVyc2U7XG4gIH1cbiAgcHJvamVjdEZsYXQobG5nTGF0KSB7XG4gICAgcmV0dXJuIGxuZ0xhdFRvV29ybGQobG5nTGF0KTtcbiAgfVxuICB1bnByb2plY3RGbGF0KHh5KSB7XG4gICAgcmV0dXJuIHdvcmxkVG9MbmdMYXQoeHkpO1xuICB9XG4gIGdldE1hcENlbnRlckJ5TG5nTGF0UG9zaXRpb24oX3JlZikge1xuICAgIGxldCB7XG4gICAgICBsbmdMYXQsXG4gICAgICBwb3NcbiAgICB9ID0gX3JlZjtcbiAgICBjb25zdCBmcm9tTG9jYXRpb24gPSBwaXhlbHNUb1dvcmxkKHBvcywgdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgY29uc3QgdG9Mb2NhdGlvbiA9IGxuZ0xhdFRvV29ybGQobG5nTGF0KTtcbiAgICBjb25zdCB0cmFuc2xhdGUgPSB2ZWMyLmFkZChbXSwgdG9Mb2NhdGlvbiwgdmVjMi5uZWdhdGUoW10sIGZyb21Mb2NhdGlvbikpO1xuICAgIGNvbnN0IG5ld0NlbnRlciA9IHZlYzIuYWRkKFtdLCB0aGlzLmNlbnRlciwgdHJhbnNsYXRlKTtcbiAgICByZXR1cm4gd29ybGRUb0xuZ0xhdChuZXdDZW50ZXIpO1xuICB9XG4gIGZpdEJvdW5kcyhib3VuZHMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZSxcbiAgICAgIHpvb21cbiAgICB9ID0gZml0Qm91bmRzKE9iamVjdC5hc3NpZ24oe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBib3VuZHNcbiAgICB9LCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGUsXG4gICAgICB6b29tXG4gICAgfSk7XG4gIH1cbiAgZ2V0Qm91bmRzKG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb3JuZXJzID0gdGhpcy5nZXRCb3VuZGluZ1JlZ2lvbihvcHRpb25zKTtcbiAgICBjb25zdCB3ZXN0ID0gTWF0aC5taW4oLi4uY29ybmVycy5tYXAocCA9PiBwWzBdKSk7XG4gICAgY29uc3QgZWFzdCA9IE1hdGgubWF4KC4uLmNvcm5lcnMubWFwKHAgPT4gcFswXSkpO1xuICAgIGNvbnN0IHNvdXRoID0gTWF0aC5taW4oLi4uY29ybmVycy5tYXAocCA9PiBwWzFdKSk7XG4gICAgY29uc3Qgbm9ydGggPSBNYXRoLm1heCguLi5jb3JuZXJzLm1hcChwID0+IHBbMV0pKTtcbiAgICByZXR1cm4gW1t3ZXN0LCBzb3V0aF0sIFtlYXN0LCBub3J0aF1dO1xuICB9XG4gIGdldEJvdW5kaW5nUmVnaW9uKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICByZXR1cm4gZ2V0Qm91bmRzKHRoaXMsIG9wdGlvbnMueiB8fCAwKTtcbiAgfVxuICBnZXRMb2NhdGlvbkF0UG9pbnQoX3JlZjIpIHtcbiAgICBsZXQge1xuICAgICAgbG5nTGF0LFxuICAgICAgcG9zXG4gICAgfSA9IF9yZWYyO1xuICAgIHJldHVybiB0aGlzLmdldE1hcENlbnRlckJ5TG5nTGF0UG9zaXRpb24oe1xuICAgICAgbG5nTGF0LFxuICAgICAgcG9zXG4gICAgfSk7XG4gIH1cbn0iLCJpbXBvcnQgeyB3b3JsZFRvTG5nTGF0IH0gZnJvbSAnLi93ZWItbWVyY2F0b3ItdXRpbHMnO1xuaW1wb3J0IHsgbW9kLCBsb2cyIH0gZnJvbSAnLi9tYXRoLXV0aWxzJztcbmNvbnN0IFRJTEVfU0laRSA9IDUxMjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vcm1hbGl6ZVZpZXdwb3J0UHJvcHMocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBwaXRjaCA9IDBcbiAgfSA9IHByb3BzO1xuICBsZXQge1xuICAgIGxvbmdpdHVkZSxcbiAgICBsYXRpdHVkZSxcbiAgICB6b29tLFxuICAgIGJlYXJpbmcgPSAwXG4gIH0gPSBwcm9wcztcbiAgaWYgKGxvbmdpdHVkZSA8IC0xODAgfHwgbG9uZ2l0dWRlID4gMTgwKSB7XG4gICAgbG9uZ2l0dWRlID0gbW9kKGxvbmdpdHVkZSArIDE4MCwgMzYwKSAtIDE4MDtcbiAgfVxuICBpZiAoYmVhcmluZyA8IC0xODAgfHwgYmVhcmluZyA+IDE4MCkge1xuICAgIGJlYXJpbmcgPSBtb2QoYmVhcmluZyArIDE4MCwgMzYwKSAtIDE4MDtcbiAgfVxuICBjb25zdCBtaW5ab29tID0gbG9nMihoZWlnaHQgLyBUSUxFX1NJWkUpO1xuICBpZiAoem9vbSA8PSBtaW5ab29tKSB7XG4gICAgem9vbSA9IG1pblpvb207XG4gICAgbGF0aXR1ZGUgPSAwO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGhhbGZIZWlnaHRQaXhlbHMgPSBoZWlnaHQgLyAyIC8gTWF0aC5wb3coMiwgem9vbSk7XG4gICAgY29uc3QgbWluTGF0aXR1ZGUgPSB3b3JsZFRvTG5nTGF0KFswLCBoYWxmSGVpZ2h0UGl4ZWxzXSlbMV07XG4gICAgaWYgKGxhdGl0dWRlIDwgbWluTGF0aXR1ZGUpIHtcbiAgICAgIGxhdGl0dWRlID0gbWluTGF0aXR1ZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1heExhdGl0dWRlID0gd29ybGRUb0xuZ0xhdChbMCwgVElMRV9TSVpFIC0gaGFsZkhlaWdodFBpeGVsc10pWzFdO1xuICAgICAgaWYgKGxhdGl0dWRlID4gbWF4TGF0aXR1ZGUpIHtcbiAgICAgICAgbGF0aXR1ZGUgPSBtYXhMYXRpdHVkZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbG9uZ2l0dWRlLFxuICAgIGxhdGl0dWRlLFxuICAgIHpvb20sXG4gICAgcGl0Y2gsXG4gICAgYmVhcmluZ1xuICB9O1xufSIsImltcG9ydCB7IGxlcnAgfSBmcm9tICcuL21hdGgtdXRpbHMnO1xuaW1wb3J0IHsgc2NhbGVUb1pvb20sIHpvb21Ub1NjYWxlLCBsbmdMYXRUb1dvcmxkLCB3b3JsZFRvTG5nTGF0IH0gZnJvbSAnLi93ZWItbWVyY2F0b3ItdXRpbHMnO1xuaW1wb3J0ICogYXMgdmVjMiBmcm9tICdnbC1tYXRyaXgvdmVjMic7XG5jb25zdCBFUFNJTE9OID0gMC4wMTtcbmNvbnN0IFZJRVdQT1JUX1RSQU5TSVRJT05fUFJPUFMgPSBbJ2xvbmdpdHVkZScsICdsYXRpdHVkZScsICd6b29tJ107XG5jb25zdCBERUZBVUxUX09QVFMgPSB7XG4gIGN1cnZlOiAxLjQxNCxcbiAgc3BlZWQ6IDEuMlxufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZseVRvVmlld3BvcnQoc3RhcnRQcm9wcywgZW5kUHJvcHMsIHQsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Wm9vbSxcbiAgICBzdGFydENlbnRlclhZLFxuICAgIHVEZWx0YSxcbiAgICB3MCxcbiAgICB1MSxcbiAgICBTLFxuICAgIHJobyxcbiAgICByaG8yLFxuICAgIHIwXG4gIH0gPSBnZXRGbHlUb1RyYW5zaXRpb25QYXJhbXMoc3RhcnRQcm9wcywgZW5kUHJvcHMsIG9wdGlvbnMpO1xuICBpZiAodTEgPCBFUFNJTE9OKSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBWSUVXUE9SVF9UUkFOU0lUSU9OX1BST1BTKSB7XG4gICAgICBjb25zdCBzdGFydFZhbHVlID0gc3RhcnRQcm9wc1trZXldO1xuICAgICAgY29uc3QgZW5kVmFsdWUgPSBlbmRQcm9wc1trZXldO1xuICAgICAgdmlld3BvcnRba2V5XSA9IGxlcnAoc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIHQpO1xuICAgIH1cbiAgICByZXR1cm4gdmlld3BvcnQ7XG4gIH1cbiAgY29uc3QgcyA9IHQgKiBTO1xuICBjb25zdCB3ID0gTWF0aC5jb3NoKHIwKSAvIE1hdGguY29zaChyMCArIHJobyAqIHMpO1xuICBjb25zdCB1ID0gdzAgKiAoKE1hdGguY29zaChyMCkgKiBNYXRoLnRhbmgocjAgKyByaG8gKiBzKSAtIE1hdGguc2luaChyMCkpIC8gcmhvMikgLyB1MTtcbiAgY29uc3Qgc2NhbGVJbmNyZW1lbnQgPSAxIC8gdztcbiAgY29uc3QgbmV3Wm9vbSA9IHN0YXJ0Wm9vbSArIHNjYWxlVG9ab29tKHNjYWxlSW5jcmVtZW50KTtcbiAgY29uc3QgbmV3Q2VudGVyV29ybGQgPSB2ZWMyLnNjYWxlKFtdLCB1RGVsdGEsIHUpO1xuICB2ZWMyLmFkZChuZXdDZW50ZXJXb3JsZCwgbmV3Q2VudGVyV29ybGQsIHN0YXJ0Q2VudGVyWFkpO1xuICBjb25zdCBuZXdDZW50ZXIgPSB3b3JsZFRvTG5nTGF0KG5ld0NlbnRlcldvcmxkKTtcbiAgcmV0dXJuIHtcbiAgICBsb25naXR1ZGU6IG5ld0NlbnRlclswXSxcbiAgICBsYXRpdHVkZTogbmV3Q2VudGVyWzFdLFxuICAgIHpvb206IG5ld1pvb21cbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRGbHlUb0R1cmF0aW9uKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgLi4uREVGQVVMVF9PUFRTLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3Qge1xuICAgIHNjcmVlblNwZWVkLFxuICAgIHNwZWVkLFxuICAgIG1heER1cmF0aW9uXG4gIH0gPSBvcHRzO1xuICBjb25zdCB7XG4gICAgUyxcbiAgICByaG9cbiAgfSA9IGdldEZseVRvVHJhbnNpdGlvblBhcmFtcyhzdGFydFByb3BzLCBlbmRQcm9wcywgb3B0cyk7XG4gIGNvbnN0IGxlbmd0aCA9IDEwMDAgKiBTO1xuICBsZXQgZHVyYXRpb247XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoc2NyZWVuU3BlZWQpKSB7XG4gICAgZHVyYXRpb24gPSBsZW5ndGggLyAoc2NyZWVuU3BlZWQgLyByaG8pO1xuICB9IGVsc2Uge1xuICAgIGR1cmF0aW9uID0gbGVuZ3RoIC8gc3BlZWQ7XG4gIH1cbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShtYXhEdXJhdGlvbikgJiYgZHVyYXRpb24gPiBtYXhEdXJhdGlvbiA/IDAgOiBkdXJhdGlvbjtcbn1cbmZ1bmN0aW9uIGdldEZseVRvVHJhbnNpdGlvblBhcmFtcyhzdGFydFByb3BzLCBlbmRQcm9wcywgb3B0cykge1xuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRTLCBvcHRzKTtcbiAgY29uc3QgcmhvID0gb3B0cy5jdXJ2ZTtcbiAgY29uc3Qgc3RhcnRab29tID0gc3RhcnRQcm9wcy56b29tO1xuICBjb25zdCBzdGFydENlbnRlciA9IFtzdGFydFByb3BzLmxvbmdpdHVkZSwgc3RhcnRQcm9wcy5sYXRpdHVkZV07XG4gIGNvbnN0IHN0YXJ0U2NhbGUgPSB6b29tVG9TY2FsZShzdGFydFpvb20pO1xuICBjb25zdCBlbmRab29tID0gZW5kUHJvcHMuem9vbTtcbiAgY29uc3QgZW5kQ2VudGVyID0gW2VuZFByb3BzLmxvbmdpdHVkZSwgZW5kUHJvcHMubGF0aXR1ZGVdO1xuICBjb25zdCBzY2FsZSA9IHpvb21Ub1NjYWxlKGVuZFpvb20gLSBzdGFydFpvb20pO1xuICBjb25zdCBzdGFydENlbnRlclhZID0gbG5nTGF0VG9Xb3JsZChzdGFydENlbnRlcik7XG4gIGNvbnN0IGVuZENlbnRlclhZID0gbG5nTGF0VG9Xb3JsZChlbmRDZW50ZXIpO1xuICBjb25zdCB1RGVsdGEgPSB2ZWMyLnN1YihbXSwgZW5kQ2VudGVyWFksIHN0YXJ0Q2VudGVyWFkpO1xuICBjb25zdCB3MCA9IE1hdGgubWF4KHN0YXJ0UHJvcHMud2lkdGgsIHN0YXJ0UHJvcHMuaGVpZ2h0KTtcbiAgY29uc3QgdzEgPSB3MCAvIHNjYWxlO1xuICBjb25zdCB1MSA9IHZlYzIubGVuZ3RoKHVEZWx0YSkgKiBzdGFydFNjYWxlO1xuICBjb25zdCBfdTEgPSBNYXRoLm1heCh1MSwgRVBTSUxPTik7XG4gIGNvbnN0IHJobzIgPSByaG8gKiByaG87XG4gIGNvbnN0IGIwID0gKHcxICogdzEgLSB3MCAqIHcwICsgcmhvMiAqIHJobzIgKiBfdTEgKiBfdTEpIC8gKDIgKiB3MCAqIHJobzIgKiBfdTEpO1xuICBjb25zdCBiMSA9ICh3MSAqIHcxIC0gdzAgKiB3MCAtIHJobzIgKiByaG8yICogX3UxICogX3UxKSAvICgyICogdzEgKiByaG8yICogX3UxKTtcbiAgY29uc3QgcjAgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjAgKiBiMCArIDEpIC0gYjApO1xuICBjb25zdCByMSA9IE1hdGgubG9nKE1hdGguc3FydChiMSAqIGIxICsgMSkgLSBiMSk7XG4gIGNvbnN0IFMgPSAocjEgLSByMCkgLyByaG87XG4gIHJldHVybiB7XG4gICAgc3RhcnRab29tLFxuICAgIHN0YXJ0Q2VudGVyWFksXG4gICAgdURlbHRhLFxuICAgIHcwLFxuICAgIHUxLFxuICAgIFMsXG4gICAgcmhvLFxuICAgIHJobzIsXG4gICAgcjAsXG4gICAgcjFcbiAgfTtcbn0iLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi93ZWItbWVyY2F0b3Itdmlld3BvcnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBXZWJNZXJjYXRvclZpZXdwb3J0IH0gZnJvbSAnLi93ZWItbWVyY2F0b3Itdmlld3BvcnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBnZXRCb3VuZHMgfSBmcm9tICcuL2dldC1ib3VuZHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmaXRCb3VuZHMgfSBmcm9tICcuL2ZpdC1ib3VuZHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBub3JtYWxpemVWaWV3cG9ydFByb3BzIH0gZnJvbSAnLi9ub3JtYWxpemUtdmlld3BvcnQtcHJvcHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmbHlUb1ZpZXdwb3J0LCBnZXRGbHlUb0R1cmF0aW9uIH0gZnJvbSAnLi9mbHktdG8tdmlld3BvcnQnO1xuZXhwb3J0IHsgTUFYX0xBVElUVURFLCBsbmdMYXRUb1dvcmxkLCB3b3JsZFRvTG5nTGF0LCB3b3JsZFRvUGl4ZWxzLCBwaXhlbHNUb1dvcmxkLCB6b29tVG9TY2FsZSwgc2NhbGVUb1pvb20sIGFsdGl0dWRlVG9Gb3Z5LCBmb3Z5VG9BbHRpdHVkZSwgZ2V0TWV0ZXJab29tLCB1bml0c1Blck1ldGVyLCBnZXREaXN0YW5jZVNjYWxlcywgYWRkTWV0ZXJzVG9MbmdMYXQsIGdldFZpZXdNYXRyaXgsIGdldFByb2plY3Rpb25NYXRyaXgsIGdldFByb2plY3Rpb25QYXJhbWV0ZXJzIH0gZnJvbSAnLi93ZWItbWVyY2F0b3ItdXRpbHMnOyIsImV4cG9ydCB7IFdlYk1lcmNhdG9yVmlld3BvcnQgYXMgZGVmYXVsdCB9IGZyb20gJ0BtYXRoLmdsL3dlYi1tZXJjYXRvcic7XG5leHBvcnQgKiBmcm9tICdAbWF0aC5nbC93ZWItbWVyY2F0b3InOyIsIi8qKlxyXG4gKiBBIGNvbGxlY3Rpb24gb2Ygc2hpbXMgdGhhdCBwcm92aWRlIG1pbmltYWwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgRVM2IGNvbGxlY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGVzZSBpbXBsZW1lbnRhdGlvbnMgYXJlIG5vdCBtZWFudCB0byBiZSB1c2VkIG91dHNpZGUgb2YgdGhlIFJlc2l6ZU9ic2VydmVyXHJcbiAqIG1vZHVsZXMgYXMgdGhleSBjb3ZlciBvbmx5IGEgbGltaXRlZCByYW5nZSBvZiB1c2UgY2FzZXMuXHJcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1qc2RvYywgdmFsaWQtanNkb2MgKi9cbnZhciBNYXBTaGltID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gTWFwO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgaW5kZXggaW4gcHJvdmlkZWQgYXJyYXkgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheTxBcnJheT59IGFyclxyXG4gICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SW5kZXgoYXJyLCBrZXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gLTE7XG4gICAgYXJyLnNvbWUoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xuICAgICAgaWYgKGVudHJ5WzBdID09PSBrZXkpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5kZXg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcbiAgICAgIHRoaXMuX19lbnRyaWVzX18gPSBbXTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgLyoqXHJcbiAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgKi9cbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2VudHJpZXNfXy5sZW5ndGg7XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXG4gICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcbiAgICAgIHZhciBlbnRyeSA9IHRoaXMuX19lbnRyaWVzX19baW5kZXhdO1xuICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzFdO1xuICAgIH07XG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cbiAgICBjbGFzc18xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcbiAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgdGhpcy5fX2VudHJpZXNfX1tpbmRleF1bMV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19lbnRyaWVzX18ucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cbiAgICBjbGFzc18xLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgZW50cmllcyA9IHRoaXMuX19lbnRyaWVzX187XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleChlbnRyaWVzLCBrZXkpO1xuICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xuICAgIGNsYXNzXzEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiAhIX5nZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xuICAgIH07XG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xuICAgIGNsYXNzXzEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fX2VudHJpZXNfXy5zcGxpY2UoMCk7XG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgKiBAcGFyYW0geyp9IFtjdHg9bnVsbF1cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXG4gICAgY2xhc3NfMS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY3R4KSB7XG4gICAgICBpZiAoY3R4ID09PSB2b2lkIDApIHtcbiAgICAgICAgY3R4ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9fZW50cmllc19fOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZW50cnkgPSBfYVtfaV07XG4gICAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBlbnRyeVsxXSwgZW50cnlbMF0pO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGNsYXNzXzE7XG4gIH0oKTtcbn0oKTtcblxuLyoqXHJcbiAqIERldGVjdHMgd2hldGhlciB3aW5kb3cgYW5kIGRvY3VtZW50IG9iamVjdHMgYXJlIGF2YWlsYWJsZSBpbiBjdXJyZW50IGVudmlyb25tZW50LlxyXG4gKi9cbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCA9PT0gZG9jdW1lbnQ7XG5cbi8vIFJldHVybnMgZ2xvYmFsIG9iamVjdCBvZiBhIGN1cnJlbnQgZW52aXJvbm1lbnQuXG52YXIgZ2xvYmFsJDEgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuTWF0aCA9PT0gTWF0aCkge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT09IE1hdGgpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT09IE1hdGgpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICByZXR1cm4gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbn0oKTtcblxuLyoqXHJcbiAqIEEgc2hpbSBmb3IgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSB3aGljaCBmYWxscyBiYWNrIHRvIHRoZSBzZXRUaW1lb3V0IGlmXHJcbiAqIGZpcnN0IG9uZSBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXF1ZXN0cycgaWRlbnRpZmllci5cclxuICovXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gSXQncyByZXF1aXJlZCB0byB1c2UgYSBib3VuZGVkIGZ1bmN0aW9uIGJlY2F1c2UgSUUgc29tZXRpbWVzIHRocm93c1xuICAgIC8vIGFuIFwiSW52YWxpZCBjYWxsaW5nIG9iamVjdFwiIGVycm9yIGlmIHJBRiBpcyBpbnZva2VkIHdpdGhvdXQgdGhlIGdsb2JhbFxuICAgIC8vIG9iamVjdCBvbiB0aGUgbGVmdCBoYW5kIHNpZGUuXG4gICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKGdsb2JhbCQxKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKERhdGUubm93KCkpO1xuICAgIH0sIDEwMDAgLyA2MCk7XG4gIH07XG59KCk7XG5cbi8vIERlZmluZXMgbWluaW11bSB0aW1lb3V0IGJlZm9yZSBhZGRpbmcgYSB0cmFpbGluZyBjYWxsLlxudmFyIHRyYWlsaW5nVGltZW91dCA9IDI7XG4vKipcclxuICogQ3JlYXRlcyBhIHdyYXBwZXIgZnVuY3Rpb24gd2hpY2ggZW5zdXJlcyB0aGF0IHByb3ZpZGVkIGNhbGxiYWNrIHdpbGwgYmVcclxuICogaW52b2tlZCBvbmx5IG9uY2UgZHVyaW5nIHRoZSBzcGVjaWZpZWQgZGVsYXkgcGVyaW9kLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIGRlbGF5IHBlcmlvZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IC0gRGVsYXkgYWZ0ZXIgd2hpY2ggdG8gaW52b2tlIGNhbGxiYWNrLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoY2FsbGJhY2ssIGRlbGF5KSB7XG4gIHZhciBsZWFkaW5nQ2FsbCA9IGZhbHNlLFxuICAgIHRyYWlsaW5nQ2FsbCA9IGZhbHNlLFxuICAgIGxhc3RDYWxsVGltZSA9IDA7XG4gIC8qKlxyXG4gICAqIEludm9rZXMgdGhlIG9yaWdpbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZCBzY2hlZHVsZXMgbmV3IGludm9jYXRpb24gaWZcclxuICAgKiB0aGUgXCJwcm94eVwiIHdhcyBjYWxsZWQgZHVyaW5nIGN1cnJlbnQgcmVxdWVzdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuICBmdW5jdGlvbiByZXNvbHZlUGVuZGluZygpIHtcbiAgICBpZiAobGVhZGluZ0NhbGwpIHtcbiAgICAgIGxlYWRpbmdDYWxsID0gZmFsc2U7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBpZiAodHJhaWxpbmdDYWxsKSB7XG4gICAgICBwcm94eSgpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBDYWxsYmFjayBpbnZva2VkIGFmdGVyIHRoZSBzcGVjaWZpZWQgZGVsYXkuIEl0IHdpbGwgZnVydGhlciBwb3N0cG9uZVxyXG4gICAqIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGRlbGVnYXRpbmcgaXQgdG8gdGhlXHJcbiAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG4gIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMShyZXNvbHZlUGVuZGluZyk7XG4gIH1cbiAgLyoqXHJcbiAgICogU2NoZWR1bGVzIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG4gIGZ1bmN0aW9uIHByb3h5KCkge1xuICAgIHZhciB0aW1lU3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuICAgICAgLy8gUmVqZWN0IGltbWVkaWF0ZWx5IGZvbGxvd2luZyBjYWxscy5cbiAgICAgIGlmICh0aW1lU3RhbXAgLSBsYXN0Q2FsbFRpbWUgPCB0cmFpbGluZ1RpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gU2NoZWR1bGUgbmV3IGNhbGwgdG8gYmUgaW4gaW52b2tlZCB3aGVuIHRoZSBwZW5kaW5nIG9uZSBpcyByZXNvbHZlZC5cbiAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGZvciBcInRyYW5zaXRpb25zXCIgd2hpY2ggbmV2ZXIgYWN0dWFsbHkgc3RhcnRcbiAgICAgIC8vIGltbWVkaWF0ZWx5IHNvIHRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgd2UgbWlnaHQgbWlzcyBvbmUgaWYgY2hhbmdlXG4gICAgICAvLyBoYXBwZW5zIGFtaWRzIHRoZSBwZW5kaW5nIGludm9jYXRpb24uXG4gICAgICB0cmFpbGluZ0NhbGwgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWFkaW5nQ2FsbCA9IHRydWU7XG4gICAgICB0cmFpbGluZ0NhbGwgPSBmYWxzZTtcbiAgICAgIHNldFRpbWVvdXQodGltZW91dENhbGxiYWNrLCBkZWxheSk7XG4gICAgfVxuICAgIGxhc3RDYWxsVGltZSA9IHRpbWVTdGFtcDtcbiAgfVxuICByZXR1cm4gcHJveHk7XG59XG5cbi8vIE1pbmltdW0gZGVsYXkgYmVmb3JlIGludm9raW5nIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2ZXJzLlxudmFyIFJFRlJFU0hfREVMQVkgPSAyMDtcbi8vIEEgbGlzdCBvZiBzdWJzdHJpbmdzIG9mIENTUyBwcm9wZXJ0aWVzIHVzZWQgdG8gZmluZCB0cmFuc2l0aW9uIGV2ZW50cyB0aGF0XG4vLyBtaWdodCBhZmZlY3QgZGltZW5zaW9ucyBvZiBvYnNlcnZlZCBlbGVtZW50cy5cbnZhciB0cmFuc2l0aW9uS2V5cyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JywgJ3dpZHRoJywgJ2hlaWdodCcsICdzaXplJywgJ3dlaWdodCddO1xuLy8gQ2hlY2sgaWYgTXV0YXRpb25PYnNlcnZlciBpcyBhdmFpbGFibGUuXG52YXIgbXV0YXRpb25PYnNlcnZlclN1cHBvcnRlZCA9IHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcbi8qKlxyXG4gKiBTaW5nbGV0b24gY29udHJvbGxlciBjbGFzcyB3aGljaCBoYW5kbGVzIHVwZGF0ZXMgb2YgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2VzLlxyXG4gKi9cbnZhciBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpIHtcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIERPTSBsaXN0ZW5lcnMgaGF2ZSBiZWVuIGFkZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIHtib29sZWFufVxyXG4gICAgICovXG4gICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB0aGF0IGNvbnRyb2xsZXIgaGFzIHN1YnNjcmliZWQgZm9yIE11dGF0aW9uIEV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cclxuICAgICAqL1xuICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcbiAgICAvKipcclxuICAgICAqIEtlZXBzIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb2YgTXV0YXRpb25PYnNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSB7TXV0YXRpb25PYnNlcnZlcn1cclxuICAgICAqL1xuICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcbiAgICAvKipcclxuICAgICAqIEEgbGlzdCBvZiBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIHtBcnJheTxSZXNpemVPYnNlcnZlclNQST59XHJcbiAgICAgKi9cbiAgICB0aGlzLm9ic2VydmVyc18gPSBbXTtcbiAgICB0aGlzLm9uVHJhbnNpdGlvbkVuZF8gPSB0aGlzLm9uVHJhbnNpdGlvbkVuZF8uYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlZnJlc2ggPSB0aHJvdHRsZSh0aGlzLnJlZnJlc2guYmluZCh0aGlzKSwgUkVGUkVTSF9ERUxBWSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQWRkcyBvYnNlcnZlciB0byBvYnNlcnZlcnMgbGlzdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJTUEl9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgYWRkZWQuXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG4gIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuYWRkT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICBpZiAoIX50aGlzLm9ic2VydmVyc18uaW5kZXhPZihvYnNlcnZlcikpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzXy5wdXNoKG9ic2VydmVyKTtcbiAgICB9XG4gICAgLy8gQWRkIGxpc3RlbmVycyBpZiB0aGV5IGhhdmVuJ3QgYmVlbiBhZGRlZCB5ZXQuXG4gICAgaWYgKCF0aGlzLmNvbm5lY3RlZF8pIHtcbiAgICAgIHRoaXMuY29ubmVjdF8oKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJTUEl9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgcmVtb3ZlZC5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cbiAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmVPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc187XG4gICAgdmFyIGluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpO1xuICAgIC8vIFJlbW92ZSBvYnNlcnZlciBpZiBpdCdzIHByZXNlbnQgaW4gcmVnaXN0cnkuXG4gICAgaWYgKH5pbmRleCkge1xuICAgICAgb2JzZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBsaXN0ZW5lcnMgaWYgY29udHJvbGxlciBoYXMgbm8gY29ubmVjdGVkIG9ic2VydmVycy5cbiAgICBpZiAoIW9ic2VydmVycy5sZW5ndGggJiYgdGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RfKCk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBJbnZva2VzIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2ZXJzLiBJdCB3aWxsIGNvbnRpbnVlIHJ1bm5pbmcgdXBkYXRlcyBpbnNvZmFyXHJcbiAgICogaXQgZGV0ZWN0cyBjaGFuZ2VzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG4gIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2hhbmdlc0RldGVjdGVkID0gdGhpcy51cGRhdGVPYnNlcnZlcnNfKCk7XG4gICAgLy8gQ29udGludWUgcnVubmluZyB1cGRhdGVzIGlmIGNoYW5nZXMgaGF2ZSBiZWVuIGRldGVjdGVkIGFzIHRoZXJlIG1pZ2h0XG4gICAgLy8gYmUgZnV0dXJlIG9uZXMgY2F1c2VkIGJ5IENTUyB0cmFuc2l0aW9ucy5cbiAgICBpZiAoY2hhbmdlc0RldGVjdGVkKSB7XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgZXZlcnkgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdCBhbmQgbm90aWZpZXMgdGhlbSBvZiBxdWV1ZWRcclxuICAgKiBlbnRyaWVzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBcInRydWVcIiBpZiBhbnkgb2JzZXJ2ZXIgaGFzIGRldGVjdGVkIGNoYW5nZXMgaW5cclxuICAgKiAgICAgIGRpbWVuc2lvbnMgb2YgaXQncyBlbGVtZW50cy5cclxuICAgKi9cbiAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVPYnNlcnZlcnNfID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIENvbGxlY3Qgb2JzZXJ2ZXJzIHRoYXQgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxuICAgIHZhciBhY3RpdmVPYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc18uZmlsdGVyKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgcmV0dXJuIG9ic2VydmVyLmdhdGhlckFjdGl2ZSgpLCBvYnNlcnZlci5oYXNBY3RpdmUoKTtcbiAgICB9KTtcbiAgICAvLyBEZWxpdmVyIG5vdGlmaWNhdGlvbnMgaW4gYSBzZXBhcmF0ZSBjeWNsZSBpbiBvcmRlciB0byBhdm9pZCBhbnlcbiAgICAvLyBjb2xsaXNpb25zIGJldHdlZW4gb2JzZXJ2ZXJzLCBlLmcuIHdoZW4gbXVsdGlwbGUgaW5zdGFuY2VzIG9mXG4gICAgLy8gUmVzaXplT2JzZXJ2ZXIgYXJlIHRyYWNraW5nIHRoZSBzYW1lIGVsZW1lbnQgYW5kIHRoZSBjYWxsYmFjayBvZiBvbmVcbiAgICAvLyBvZiB0aGVtIGNoYW5nZXMgY29udGVudCBkaW1lbnNpb25zIG9mIHRoZSBvYnNlcnZlZCB0YXJnZXQuIFNvbWV0aW1lc1xuICAgIC8vIHRoaXMgbWF5IHJlc3VsdCBpbiBub3RpZmljYXRpb25zIGJlaW5nIGJsb2NrZWQgZm9yIHRoZSByZXN0IG9mIG9ic2VydmVycy5cbiAgICBhY3RpdmVPYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiBvYnNlcnZlci5icm9hZGNhc3RBY3RpdmUoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWN0aXZlT2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XG4gIH07XG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmNvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xuICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IGFkZGVkLlxuICAgIGlmICghaXNCcm93c2VyIHx8IHRoaXMuY29ubmVjdGVkXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTdWJzY3JpcHRpb24gdG8gdGhlIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGlzIHVzZWQgYXMgYSB3b3JrYXJvdW5kIGZvclxuICAgIC8vIGRlbGF5ZWQgdHJhbnNpdGlvbnMuIFRoaXMgd2F5IGl0J3MgcG9zc2libGUgdG8gY2FwdHVyZSBhdCBsZWFzdCB0aGVcbiAgICAvLyBmaW5hbCBzdGF0ZSBvZiBhbiBlbGVtZW50LlxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xuICAgIGlmIChtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMucmVmcmVzaCk7XG4gICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5vYnNlcnZlKGRvY3VtZW50LCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTVN1YnRyZWVNb2RpZmllZCcsIHRoaXMucmVmcmVzaCk7XG4gICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0ZWRfID0gdHJ1ZTtcbiAgfTtcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBET00gbGlzdGVuZXJzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cbiAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5kaXNjb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBEbyBub3RoaW5nIGlmIHJ1bm5pbmcgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCBvciBpZiBsaXN0ZW5lcnNcbiAgICAvLyBoYXZlIGJlZW4gYWxyZWFkeSByZW1vdmVkLlxuICAgIGlmICghaXNCcm93c2VyIHx8ICF0aGlzLmNvbm5lY3RlZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XG4gICAgaWYgKHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfKSB7XG4gICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01TdWJ0cmVlTW9kaWZpZWQnLCB0aGlzLnJlZnJlc2gpO1xuICAgIH1cbiAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG51bGw7XG4gICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xuICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xuICB9O1xuICAvKipcclxuICAgKiBcIlRyYW5zaXRpb25lbmRcIiBldmVudCBoYW5kbGVyLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge1RyYW5zaXRpb25FdmVudH0gZXZlbnRcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cbiAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5vblRyYW5zaXRpb25FbmRfID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iID0gX2EucHJvcGVydHlOYW1lLFxuICAgICAgcHJvcGVydHlOYW1lID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2I7XG4gICAgLy8gRGV0ZWN0IHdoZXRoZXIgdHJhbnNpdGlvbiBtYXkgYWZmZWN0IGRpbWVuc2lvbnMgb2YgYW4gZWxlbWVudC5cbiAgICB2YXIgaXNSZWZsb3dQcm9wZXJ0eSA9IHRyYW5zaXRpb25LZXlzLnNvbWUoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuICEhfnByb3BlcnR5TmFtZS5pbmRleE9mKGtleSk7XG4gICAgfSk7XG4gICAgaWYgKGlzUmVmbG93UHJvcGVydHkpIHtcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogUmV0dXJucyBpbnN0YW5jZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn1cclxuICAgKi9cbiAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pbnN0YW5jZV8pIHtcbiAgICAgIHRoaXMuaW5zdGFuY2VfID0gbmV3IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZV87XG4gIH07XG4gIC8qKlxyXG4gICAqIEhvbGRzIHJlZmVyZW5jZSB0byB0aGUgY29udHJvbGxlcidzIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGUge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn1cclxuICAgKi9cbiAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmluc3RhbmNlXyA9IG51bGw7XG4gIHJldHVybiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXI7XG59KCk7XG5cbi8qKlxyXG4gKiBEZWZpbmVzIG5vbi13cml0YWJsZS9lbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHByb3ZpZGVkIHRhcmdldCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBPYmplY3QgZm9yIHdoaWNoIHRvIGRlZmluZSBwcm9wZXJ0aWVzLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBQcm9wZXJ0aWVzIHRvIGJlIGRlZmluZWQuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRhcmdldCBvYmplY3QuXHJcbiAqL1xudmFyIGRlZmluZUNvbmZpZ3VyYWJsZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhwcm9wcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIGtleSA9IF9hW19pXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICAgIHZhbHVlOiBwcm9wc1trZXldLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGdsb2JhbCBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcclxuICogQHJldHVybnMge09iamVjdH1cclxuICovXG52YXIgZ2V0V2luZG93T2YgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIC8vIEFzc3VtZSB0aGF0IHRoZSBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIE5vZGUsIHdoaWNoIG1lYW5zIHRoYXQgaXRcbiAgLy8gaGFzIHRoZSBcIm93bmVyRG9jdW1lbnRcIiBwcm9wZXJ0eSBmcm9tIHdoaWNoIHdlIGNhbiByZXRyaWV2ZSBhXG4gIC8vIGNvcnJlc3BvbmRpbmcgZ2xvYmFsIG9iamVjdC5cbiAgdmFyIG93bmVyR2xvYmFsID0gdGFyZ2V0ICYmIHRhcmdldC5vd25lckRvY3VtZW50ICYmIHRhcmdldC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAvLyBSZXR1cm4gdGhlIGxvY2FsIGdsb2JhbCBvYmplY3QgaWYgaXQncyBub3QgcG9zc2libGUgZXh0cmFjdCBvbmUgZnJvbVxuICAvLyBwcm92aWRlZCBlbGVtZW50LlxuICByZXR1cm4gb3duZXJHbG9iYWwgfHwgZ2xvYmFsJDE7XG59O1xuXG4vLyBQbGFjZWhvbGRlciBvZiBhbiBlbXB0eSBjb250ZW50IHJlY3RhbmdsZS5cbnZhciBlbXB0eVJlY3QgPSBjcmVhdGVSZWN0SW5pdCgwLCAwLCAwLCAwKTtcbi8qKlxyXG4gKiBDb252ZXJ0cyBwcm92aWRlZCBzdHJpbmcgdG8gYSBudW1iZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXG5mdW5jdGlvbiB0b0Zsb2F0KHZhbHVlKSB7XG4gIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwO1xufVxuLyoqXHJcbiAqIEV4dHJhY3RzIGJvcmRlcnMgc2l6ZSBmcm9tIHByb3ZpZGVkIHN0eWxlcy5cclxuICpcclxuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcclxuICogQHBhcmFtIHsuLi5zdHJpbmd9IHBvc2l0aW9ucyAtIEJvcmRlcnMgcG9zaXRpb25zICh0b3AsIHJpZ2h0LCAuLi4pXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xuZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzKSB7XG4gIHZhciBwb3NpdGlvbnMgPSBbXTtcbiAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBwb3NpdGlvbnNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gIH1cbiAgcmV0dXJuIHBvc2l0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHNpemUsIHBvc2l0aW9uKSB7XG4gICAgdmFyIHZhbHVlID0gc3R5bGVzWydib3JkZXItJyArIHBvc2l0aW9uICsgJy13aWR0aCddO1xuICAgIHJldHVybiBzaXplICsgdG9GbG9hdCh2YWx1ZSk7XG4gIH0sIDApO1xufVxuLyoqXHJcbiAqIEV4dHJhY3RzIHBhZGRpbmdzIHNpemVzIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBQYWRkaW5ncyBib3guXHJcbiAqL1xuZnVuY3Rpb24gZ2V0UGFkZGluZ3Moc3R5bGVzKSB7XG4gIHZhciBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuICB2YXIgcGFkZGluZ3MgPSB7fTtcbiAgZm9yICh2YXIgX2kgPSAwLCBwb3NpdGlvbnNfMSA9IHBvc2l0aW9uczsgX2kgPCBwb3NpdGlvbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgcG9zaXRpb24gPSBwb3NpdGlvbnNfMVtfaV07XG4gICAgdmFyIHZhbHVlID0gc3R5bGVzWydwYWRkaW5nLScgKyBwb3NpdGlvbl07XG4gICAgcGFkZGluZ3NbcG9zaXRpb25dID0gdG9GbG9hdCh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHBhZGRpbmdzO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgU1ZHIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U1ZHR3JhcGhpY3NFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHdoaWNoIG5lZWRzXHJcbiAqICAgICAgdG8gYmUgY2FsY3VsYXRlZC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cbmZ1bmN0aW9uIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCkge1xuICB2YXIgYmJveCA9IHRhcmdldC5nZXRCQm94KCk7XG4gIHJldHVybiBjcmVhdGVSZWN0SW5pdCgwLCAwLCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyBjb250ZW50IHJlY3RhbmdsZSBvZiBwcm92aWRlZCBIVE1MRWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBjb250ZW50IHJlY3RhbmdsZS5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cbmZ1bmN0aW9uIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KSB7XG4gIC8vIENsaWVudCB3aWR0aCAmIGhlaWdodCBwcm9wZXJ0aWVzIGNhbid0IGJlXG4gIC8vIHVzZWQgZXhjbHVzaXZlbHkgYXMgdGhleSBwcm92aWRlIHJvdW5kZWQgdmFsdWVzLlxuICB2YXIgY2xpZW50V2lkdGggPSB0YXJnZXQuY2xpZW50V2lkdGgsXG4gICAgY2xpZW50SGVpZ2h0ID0gdGFyZ2V0LmNsaWVudEhlaWdodDtcbiAgLy8gQnkgdGhpcyBjb25kaXRpb24gd2UgY2FuIGNhdGNoIGFsbCBub24tcmVwbGFjZWQgaW5saW5lLCBoaWRkZW4gYW5kXG4gIC8vIGRldGFjaGVkIGVsZW1lbnRzLiBUaG91Z2ggZWxlbWVudHMgd2l0aCB3aWR0aCAmIGhlaWdodCBwcm9wZXJ0aWVzIGxlc3NcbiAgLy8gdGhhbiAwLjUgd2lsbCBiZSBkaXNjYXJkZWQgYXMgd2VsbC5cbiAgLy9cbiAgLy8gV2l0aG91dCBpdCB3ZSB3b3VsZCBuZWVkIHRvIGltcGxlbWVudCBzZXBhcmF0ZSBtZXRob2RzIGZvciBlYWNoIG9mXG4gIC8vIHRob3NlIGNhc2VzIGFuZCBpdCdzIG5vdCBwb3NzaWJsZSB0byBwZXJmb3JtIGEgcHJlY2lzZSBhbmQgcGVyZm9ybWFuY2VcbiAgLy8gZWZmZWN0aXZlIHRlc3QgZm9yIGhpZGRlbiBlbGVtZW50cy4gRS5nLiBldmVuIGpRdWVyeSdzICc6dmlzaWJsZScgZmlsdGVyXG4gIC8vIGdpdmVzIHdyb25nIHJlc3VsdHMgZm9yIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgbGVzcyB0aGFuIDAuNS5cbiAgaWYgKCFjbGllbnRXaWR0aCAmJiAhY2xpZW50SGVpZ2h0KSB7XG4gICAgcmV0dXJuIGVtcHR5UmVjdDtcbiAgfVxuICB2YXIgc3R5bGVzID0gZ2V0V2luZG93T2YodGFyZ2V0KS5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gIHZhciBwYWRkaW5ncyA9IGdldFBhZGRpbmdzKHN0eWxlcyk7XG4gIHZhciBob3JpelBhZCA9IHBhZGRpbmdzLmxlZnQgKyBwYWRkaW5ncy5yaWdodDtcbiAgdmFyIHZlcnRQYWQgPSBwYWRkaW5ncy50b3AgKyBwYWRkaW5ncy5ib3R0b207XG4gIC8vIENvbXB1dGVkIHN0eWxlcyBvZiB3aWR0aCAmIGhlaWdodCBhcmUgYmVpbmcgdXNlZCBiZWNhdXNlIHRoZXkgYXJlIHRoZVxuICAvLyBvbmx5IGRpbWVuc2lvbnMgYXZhaWxhYmxlIHRvIEpTIHRoYXQgY29udGFpbiBub24tcm91bmRlZCB2YWx1ZXMuIEl0IGNvdWxkXG4gIC8vIGJlIHBvc3NpYmxlIHRvIHV0aWxpemUgdGhlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpZiBvbmx5IGl0J3MgZGF0YSB3YXNuJ3RcbiAgLy8gYWZmZWN0ZWQgYnkgQ1NTIHRyYW5zZm9ybWF0aW9ucyBsZXQgYWxvbmUgcGFkZGluZ3MsIGJvcmRlcnMgYW5kIHNjcm9sbCBiYXJzLlxuICB2YXIgd2lkdGggPSB0b0Zsb2F0KHN0eWxlcy53aWR0aCksXG4gICAgaGVpZ2h0ID0gdG9GbG9hdChzdHlsZXMuaGVpZ2h0KTtcbiAgLy8gV2lkdGggJiBoZWlnaHQgaW5jbHVkZSBwYWRkaW5ncyBhbmQgYm9yZGVycyB3aGVuIHRoZSAnYm9yZGVyLWJveCcgYm94XG4gIC8vIG1vZGVsIGlzIGFwcGxpZWQgKGV4Y2VwdCBmb3IgSUUpLlxuICBpZiAoc3R5bGVzLmJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnKSB7XG4gICAgLy8gRm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIHJlcXVpcmVkIHRvIGhhbmRsZSBJbnRlcm5ldCBFeHBsb3JlciB3aGljaFxuICAgIC8vIGRvZXNuJ3QgaW5jbHVkZSBwYWRkaW5ncyBhbmQgYm9yZGVycyB0byBjb21wdXRlZCBDU1MgZGltZW5zaW9ucy5cbiAgICAvL1xuICAgIC8vIFdlIGNhbiBzYXkgdGhhdCBpZiBDU1MgZGltZW5zaW9ucyArIHBhZGRpbmdzIGFyZSBlcXVhbCB0byB0aGUgXCJjbGllbnRcIlxuICAgIC8vIHByb3BlcnRpZXMgdGhlbiBpdCdzIGVpdGhlciBJRSwgYW5kIHRodXMgd2UgZG9uJ3QgbmVlZCB0byBzdWJ0cmFjdFxuICAgIC8vIGFueXRoaW5nLCBvciBhbiBlbGVtZW50IG1lcmVseSBkb2Vzbid0IGhhdmUgcGFkZGluZ3MvYm9yZGVycyBzdHlsZXMuXG4gICAgaWYgKE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgIT09IGNsaWVudFdpZHRoKSB7XG4gICAgICB3aWR0aCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICdsZWZ0JywgJ3JpZ2h0JykgKyBob3JpelBhZDtcbiAgICB9XG4gICAgaWYgKE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgIT09IGNsaWVudEhlaWdodCkge1xuICAgICAgaGVpZ2h0IC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3RvcCcsICdib3R0b20nKSArIHZlcnRQYWQ7XG4gICAgfVxuICB9XG4gIC8vIEZvbGxvd2luZyBzdGVwcyBjYW4ndCBiZSBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudCdzIHJvb3QgZWxlbWVudCBhcyBpdHNcbiAgLy8gY2xpZW50W1dpZHRoL0hlaWdodF0gcHJvcGVydGllcyByZXByZXNlbnQgdmlld3BvcnQgYXJlYSBvZiB0aGUgd2luZG93LlxuICAvLyBCZXNpZGVzLCBpdCdzIGFzIHdlbGwgbm90IG5lY2Vzc2FyeSBhcyB0aGUgPGh0bWw+IGl0c2VsZiBuZWl0aGVyIGhhc1xuICAvLyByZW5kZXJlZCBzY3JvbGwgYmFycyBub3IgaXQgY2FuIGJlIGNsaXBwZWQuXG4gIGlmICghaXNEb2N1bWVudEVsZW1lbnQodGFyZ2V0KSkge1xuICAgIC8vIEluIHNvbWUgYnJvd3NlcnMgKG9ubHkgaW4gRmlyZWZveCwgYWN0dWFsbHkpIENTUyB3aWR0aCAmIGhlaWdodFxuICAgIC8vIGluY2x1ZGUgc2Nyb2xsIGJhcnMgc2l6ZSB3aGljaCBjYW4gYmUgcmVtb3ZlZCBhdCB0aGlzIHN0ZXAgYXMgc2Nyb2xsXG4gICAgLy8gYmFycyBhcmUgdGhlIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIHJvdW5kZWQgZGltZW5zaW9ucyArIHBhZGRpbmdzXG4gICAgLy8gYW5kIFwiY2xpZW50XCIgcHJvcGVydGllcywgdGhvdWdoIHRoYXQgaXMgbm90IGFsd2F5cyB0cnVlIGluIENocm9tZS5cbiAgICB2YXIgdmVydFNjcm9sbGJhciA9IE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgLSBjbGllbnRXaWR0aDtcbiAgICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBNYXRoLnJvdW5kKGhlaWdodCArIHZlcnRQYWQpIC0gY2xpZW50SGVpZ2h0O1xuICAgIC8vIENocm9tZSBoYXMgYSByYXRoZXIgd2VpcmQgcm91bmRpbmcgb2YgXCJjbGllbnRcIiBwcm9wZXJ0aWVzLlxuICAgIC8vIEUuZy4gZm9yIGFuIGVsZW1lbnQgd2l0aCBjb250ZW50IHdpZHRoIG9mIDMxNC4ycHggaXQgc29tZXRpbWVzIGdpdmVzXG4gICAgLy8gdGhlIGNsaWVudCB3aWR0aCBvZiAzMTVweCBhbmQgZm9yIHRoZSB3aWR0aCBvZiAzMTQuN3B4IGl0IG1heSBnaXZlXG4gICAgLy8gMzE0cHguIEFuZCBpdCBkb2Vzbid0IGhhcHBlbiBhbGwgdGhlIHRpbWUuIFNvIGp1c3QgaWdub3JlIHRoaXMgZGVsdGFcbiAgICAvLyBhcyBhIG5vbi1yZWxldmFudC5cbiAgICBpZiAoTWF0aC5hYnModmVydFNjcm9sbGJhcikgIT09IDEpIHtcbiAgICAgIHdpZHRoIC09IHZlcnRTY3JvbGxiYXI7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhob3JpelNjcm9sbGJhcikgIT09IDEpIHtcbiAgICAgIGhlaWdodCAtPSBob3JpelNjcm9sbGJhcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVJlY3RJbml0KHBhZGRpbmdzLmxlZnQsIHBhZGRpbmdzLnRvcCwgd2lkdGgsIGhlaWdodCk7XG59XG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgU1ZHR3JhcGhpY3NFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xudmFyIGlzU1ZHR3JhcGhpY3NFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAvLyBTb21lIGJyb3dzZXJzLCBuYW1lbHkgSUUgYW5kIEVkZ2UsIGRvbid0IGhhdmUgdGhlIFNWR0dyYXBoaWNzRWxlbWVudFxuICAvLyBpbnRlcmZhY2UuXG4gIGlmICh0eXBlb2YgU1ZHR3JhcGhpY3NFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdHcmFwaGljc0VsZW1lbnQ7XG4gICAgfTtcbiAgfVxuICAvLyBJZiBpdCdzIHNvLCB0aGVuIGNoZWNrIHRoYXQgZWxlbWVudCBpcyBhdCBsZWFzdCBhbiBpbnN0YW5jZSBvZiB0aGVcbiAgLy8gU1ZHRWxlbWVudCBhbmQgdGhhdCBpdCBoYXMgdGhlIFwiZ2V0QkJveFwiIG1ldGhvZC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0VsZW1lbnQgJiYgdHlwZW9mIHRhcmdldC5nZXRCQm94ID09PSAnZnVuY3Rpb24nO1xuICB9O1xufSgpO1xuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHByb3ZpZGVkIGVsZW1lbnQgaXMgYSBkb2N1bWVudCBlbGVtZW50ICg8aHRtbD4pLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xuZnVuY3Rpb24gaXNEb2N1bWVudEVsZW1lbnQodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQgPT09IGdldFdpbmRvd09mKHRhcmdldCkuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYW4gYXBwcm9wcmlhdGUgY29udGVudCByZWN0YW5nbGUgZm9yIHByb3ZpZGVkIGh0bWwgb3Igc3ZnIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBjb250ZW50IHJlY3RhbmdsZSBvZiB3aGljaCBuZWVkcyB0byBiZSBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xuZnVuY3Rpb24gZ2V0Q29udGVudFJlY3QodGFyZ2V0KSB7XG4gIGlmICghaXNCcm93c2VyKSB7XG4gICAgcmV0dXJuIGVtcHR5UmVjdDtcbiAgfVxuICBpZiAoaXNTVkdHcmFwaGljc0VsZW1lbnQodGFyZ2V0KSkge1xuICAgIHJldHVybiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpO1xuICB9XG4gIHJldHVybiBnZXRIVE1MRWxlbWVudENvbnRlbnRSZWN0KHRhcmdldCk7XG59XG4vKipcclxuICogQ3JlYXRlcyByZWN0YW5nbGUgd2l0aCBhbiBpbnRlcmZhY2Ugb2YgdGhlIERPTVJlY3RSZWFkT25seS5cclxuICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RvbXJlY3RyZWFkb25seVxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTVJlY3RJbml0fSByZWN0SW5pdCAtIE9iamVjdCB3aXRoIHJlY3RhbmdsZSdzIHgveSBjb29yZGluYXRlcyBhbmQgZGltZW5zaW9ucy5cclxuICogQHJldHVybnMge0RPTVJlY3RSZWFkT25seX1cclxuICovXG5mdW5jdGlvbiBjcmVhdGVSZWFkT25seVJlY3QoX2EpIHtcbiAgdmFyIHggPSBfYS54LFxuICAgIHkgPSBfYS55LFxuICAgIHdpZHRoID0gX2Eud2lkdGgsXG4gICAgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAvLyBJZiBET01SZWN0UmVhZE9ubHkgaXMgYXZhaWxhYmxlIHVzZSBpdCBhcyBhIHByb3RvdHlwZSBmb3IgdGhlIHJlY3RhbmdsZS5cbiAgdmFyIENvbnN0ciA9IHR5cGVvZiBET01SZWN0UmVhZE9ubHkgIT09ICd1bmRlZmluZWQnID8gRE9NUmVjdFJlYWRPbmx5IDogT2JqZWN0O1xuICB2YXIgcmVjdCA9IE9iamVjdC5jcmVhdGUoQ29uc3RyLnByb3RvdHlwZSk7XG4gIC8vIFJlY3RhbmdsZSdzIHByb3BlcnRpZXMgYXJlIG5vdCB3cml0YWJsZSBhbmQgbm9uLWVudW1lcmFibGUuXG4gIGRlZmluZUNvbmZpZ3VyYWJsZShyZWN0LCB7XG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB0b3A6IHksXG4gICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICBib3R0b206IGhlaWdodCArIHksXG4gICAgbGVmdDogeFxuICB9KTtcbiAgcmV0dXJuIHJlY3Q7XG59XG4vKipcclxuICogQ3JlYXRlcyBET01SZWN0SW5pdCBvYmplY3QgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGRpbWVuc2lvbnMgYW5kIHRoZSB4L3kgY29vcmRpbmF0ZXMuXHJcbiAqIFNwZWM6IGh0dHBzOi8vZHJhZnRzLmZ4dGYub3JnL2dlb21ldHJ5LyNkaWN0ZGVmLWRvbXJlY3Rpbml0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gWCBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFkgY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gUmVjdGFuZ2xlJ3Mgd2lkdGguXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBSZWN0YW5nbGUncyBoZWlnaHQuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXG5mdW5jdGlvbiBjcmVhdGVSZWN0SW5pdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiB7XG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuXG4vKipcclxuICogQ2xhc3MgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgY29tcHV0YXRpb25zIG9mIHRoZSBjb250ZW50IHJlY3RhbmdsZSBvZlxyXG4gKiBwcm92aWRlZCBET00gZWxlbWVudCBhbmQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgaXQncyBjaGFuZ2VzLlxyXG4gKi9cbnZhciBSZXNpemVPYnNlcnZhdGlvbiA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2YXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICovXG4gIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmF0aW9uKHRhcmdldCkge1xuICAgIC8qKlxyXG4gICAgICogQnJvYWRjYXN0ZWQgd2lkdGggb2YgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xuICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSAwO1xuICAgIC8qKlxyXG4gICAgICogQnJvYWRjYXN0ZWQgaGVpZ2h0IG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cbiAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IDA7XG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGUge0RPTVJlY3RJbml0fVxyXG4gICAgICovXG4gICAgdGhpcy5jb250ZW50UmVjdF8gPSBjcmVhdGVSZWN0SW5pdCgwLCAwLCAwLCAwKTtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgfVxuICAvKipcclxuICAgKiBVcGRhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIGFuZCB0ZWxscyB3aGV0aGVyIGl0J3Mgd2lkdGggb3IgaGVpZ2h0IHByb3BlcnRpZXNcclxuICAgKiBoYXZlIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYnJvYWRjYXN0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXG4gIFJlc2l6ZU9ic2VydmF0aW9uLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdCA9IGdldENvbnRlbnRSZWN0KHRoaXMudGFyZ2V0KTtcbiAgICB0aGlzLmNvbnRlbnRSZWN0XyA9IHJlY3Q7XG4gICAgcmV0dXJuIHJlY3Qud2lkdGggIT09IHRoaXMuYnJvYWRjYXN0V2lkdGggfHwgcmVjdC5oZWlnaHQgIT09IHRoaXMuYnJvYWRjYXN0SGVpZ2h0O1xuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGVzICdicm9hZGNhc3RXaWR0aCcgYW5kICdicm9hZGNhc3RIZWlnaHQnIHByb3BlcnRpZXMgd2l0aCBhIGRhdGFcclxuICAgKiBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXMgb2YgdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9IExhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICovXG4gIFJlc2l6ZU9ic2VydmF0aW9uLnByb3RvdHlwZS5icm9hZGNhc3RSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWN0ID0gdGhpcy5jb250ZW50UmVjdF87XG4gICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgdGhpcy5icm9hZGNhc3RIZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICByZXR1cm4gcmVjdDtcbiAgfTtcbiAgcmV0dXJuIFJlc2l6ZU9ic2VydmF0aW9uO1xufSgpO1xudmFyIFJlc2l6ZU9ic2VydmVyRW50cnkgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyRW50cnkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdGhhdCBpcyBiZWluZyBvYnNlcnZlZC5cclxuICAgKiBAcGFyYW0ge0RPTVJlY3RJbml0fSByZWN0SW5pdCAtIERhdGEgb2YgdGhlIGVsZW1lbnQncyBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJFbnRyeSh0YXJnZXQsIHJlY3RJbml0KSB7XG4gICAgdmFyIGNvbnRlbnRSZWN0ID0gY3JlYXRlUmVhZE9ubHlSZWN0KHJlY3RJbml0KTtcbiAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmljYXRpb24gZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIG5vdCB3cml0YWJsZVxuICAgIC8vIGFuZCBhcmUgYWxzbyBub3QgZW51bWVyYWJsZSBpbiB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLlxuICAgIC8vXG4gICAgLy8gUHJvcGVydHkgYWNjZXNzb3JzIGFyZSBub3QgYmVpbmcgdXNlZCBhcyB0aGV5J2QgcmVxdWlyZSB0byBkZWZpbmUgYVxuICAgIC8vIHByaXZhdGUgV2Vha01hcCBzdG9yYWdlIHdoaWNoIG1heSBjYXVzZSBtZW1vcnkgbGVha3MgaW4gYnJvd3NlcnMgdGhhdFxuICAgIC8vIGRvbid0IHN1cHBvcnQgdGhpcyB0eXBlIG9mIGNvbGxlY3Rpb25zLlxuICAgIGRlZmluZUNvbmZpZ3VyYWJsZSh0aGlzLCB7XG4gICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgIGNvbnRlbnRSZWN0OiBjb250ZW50UmVjdFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5O1xufSgpO1xudmFyIFJlc2l6ZU9ic2VydmVyU1BJID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGludm9rZWRcclxuICAgKiAgICAgIHdoZW4gb25lIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2VzIGl0J3MgY29udGVudCBkaW1lbnNpb25zLlxyXG4gICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfSBjb250cm9sbGVyIC0gQ29udHJvbGxlciBpbnN0YW5jZSB3aGljaFxyXG4gICAqICAgICAgaXMgcmVzcG9uc2libGUgZm9yIHRoZSB1cGRhdGVzIG9mIG9ic2VydmVyLlxyXG4gICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJ9IGNhbGxiYWNrQ3R4IC0gUmVmZXJlbmNlIHRvIHRoZSBwdWJsaWNcclxuICAgKiAgICAgIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAqL1xuICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgY2FsbGJhY2tDdHgpIHtcbiAgICAvKipcclxuICAgICAqIENvbGxlY3Rpb24gb2YgcmVzaXplIG9ic2VydmF0aW9ucyB0aGF0IGhhdmUgZGV0ZWN0ZWQgY2hhbmdlcyBpbiBkaW1lbnNpb25zXHJcbiAgICAgKiBvZiBlbGVtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8UmVzaXplT2JzZXJ2YXRpb24+fVxyXG4gICAgICovXG4gICAgdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfID0gW107XG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RyeSBvZiB0aGUgUmVzaXplT2JzZXJ2YXRpb24gaW5zdGFuY2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIHtNYXA8RWxlbWVudCwgUmVzaXplT2JzZXJ2YXRpb24+fVxyXG4gICAgICovXG4gICAgdGhpcy5vYnNlcnZhdGlvbnNfID0gbmV3IE1hcFNoaW0oKTtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY2FsbGJhY2sgcHJvdmlkZWQgYXMgcGFyYW1ldGVyIDEgaXMgbm90IGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuICAgIHRoaXMuY2FsbGJhY2tfID0gY2FsbGJhY2s7XG4gICAgdGhpcy5jb250cm9sbGVyXyA9IGNvbnRyb2xsZXI7XG4gICAgdGhpcy5jYWxsYmFja0N0eF8gPSBjYWxsYmFja0N0eDtcbiAgfVxuICAvKipcclxuICAgKiBTdGFydHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG4gIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xuICAgIH1cbiAgICAvLyBEbyBub3RoaW5nIGlmIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHRoZSBFbGVtZW50IGludGVyZmFjZS5cbiAgICBpZiAodHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICEoRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XG4gICAgfVxuICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XG4gICAgLy8gRG8gbm90aGluZyBpZiBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgb2JzZXJ2ZWQuXG4gICAgaWYgKG9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvYnNlcnZhdGlvbnMuc2V0KHRhcmdldCwgbmV3IFJlc2l6ZU9ic2VydmF0aW9uKHRhcmdldCkpO1xuICAgIHRoaXMuY29udHJvbGxlcl8uYWRkT2JzZXJ2ZXIodGhpcyk7XG4gICAgLy8gRm9yY2UgdGhlIHVwZGF0ZSBvZiBvYnNlcnZhdGlvbnMuXG4gICAgdGhpcy5jb250cm9sbGVyXy5yZWZyZXNoKCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFN0b3BzIG9ic2VydmluZyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIHN0b3Agb2JzZXJ2aW5nLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUudW5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xuICAgIH1cbiAgICAvLyBEbyBub3RoaW5nIGlmIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHRoZSBFbGVtZW50IGludGVyZmFjZS5cbiAgICBpZiAodHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICEoRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XG4gICAgfVxuICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XG4gICAgLy8gRG8gbm90aGluZyBpZiBlbGVtZW50IGlzIG5vdCBiZWluZyBvYnNlcnZlZC5cbiAgICBpZiAoIW9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvYnNlcnZhdGlvbnMuZGVsZXRlKHRhcmdldCk7XG4gICAgaWYgKCFvYnNlcnZhdGlvbnMuc2l6ZSkge1xuICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIFN0b3BzIG9ic2VydmluZyBhbGwgZWxlbWVudHMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cbiAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xuICAgIHRoaXMub2JzZXJ2YXRpb25zXy5jbGVhcigpO1xuICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIENvbGxlY3RzIG9ic2VydmF0aW9uIGluc3RhbmNlcyB0aGUgYXNzb2NpYXRlZCBlbGVtZW50IG9mIHdoaWNoIGhhcyBjaGFuZ2VkXHJcbiAgICogaXQncyBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZ2F0aGVyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xuICAgIHRoaXMub2JzZXJ2YXRpb25zXy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZhdGlvbikge1xuICAgICAgaWYgKG9ic2VydmF0aW9uLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgX3RoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5wdXNoKG9ic2VydmF0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogSW52b2tlcyBpbml0aWFsIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYSBsaXN0IG9mIFJlc2l6ZU9ic2VydmVyRW50cnlcclxuICAgKiBpbnN0YW5jZXMgY29sbGVjdGVkIGZyb20gYWN0aXZlIHJlc2l6ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cbiAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmJyb2FkY2FzdEFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBEbyBub3RoaW5nIGlmIG9ic2VydmVyIGRvZXNuJ3QgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxuICAgIGlmICghdGhpcy5oYXNBY3RpdmUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY3R4ID0gdGhpcy5jYWxsYmFja0N0eF87XG4gICAgLy8gQ3JlYXRlIFJlc2l6ZU9ic2VydmVyRW50cnkgaW5zdGFuY2UgZm9yIGV2ZXJ5IGFjdGl2ZSBvYnNlcnZhdGlvbi5cbiAgICB2YXIgZW50cmllcyA9IHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5tYXAoZnVuY3Rpb24gKG9ic2VydmF0aW9uKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc2l6ZU9ic2VydmVyRW50cnkob2JzZXJ2YXRpb24udGFyZ2V0LCBvYnNlcnZhdGlvbi5icm9hZGNhc3RSZWN0KCkpO1xuICAgIH0pO1xuICAgIHRoaXMuY2FsbGJhY2tfLmNhbGwoY3R4LCBlbnRyaWVzLCBjdHgpO1xuICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2xlYXJzIHRoZSBjb2xsZWN0aW9uIG9mIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cbiAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmNsZWFyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5zcGxpY2UoMCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFRlbGxzIHdoZXRoZXIgb2JzZXJ2ZXIgaGFzIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cbiAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmhhc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLmxlbmd0aCA+IDA7XG4gIH07XG4gIHJldHVybiBSZXNpemVPYnNlcnZlclNQSTtcbn0oKTtcblxuLy8gUmVnaXN0cnkgb2YgaW50ZXJuYWwgb2JzZXJ2ZXJzLiBJZiBXZWFrTWFwIGlzIG5vdCBhdmFpbGFibGUgdXNlIGN1cnJlbnQgc2hpbVxuLy8gZm9yIHRoZSBNYXAgY29sbGVjdGlvbiBhcyBpdCBoYXMgYWxsIHJlcXVpcmVkIG1ldGhvZHMgYW5kIGJlY2F1c2UgV2Vha01hcFxuLy8gY2FuJ3QgYmUgZnVsbHkgcG9seWZpbGxlZCBhbnl3YXkuXG52YXIgb2JzZXJ2ZXJzID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnID8gbmV3IFdlYWtNYXAoKSA6IG5ldyBNYXBTaGltKCk7XG4vKipcclxuICogUmVzaXplT2JzZXJ2ZXIgQVBJLiBFbmNhcHN1bGF0ZXMgdGhlIFJlc2l6ZU9ic2VydmVyIFNQSSBpbXBsZW1lbnRhdGlvblxyXG4gKiBleHBvc2luZyBvbmx5IHRob3NlIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgdGhhdCBhcmUgZGVmaW5lZCBpbiB0aGUgc3BlYy5cclxuICovXG52YXIgUmVzaXplT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuXHJcbiAgICogICAgICBkaW1lbnNpb25zIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2UuXHJcbiAgICovXG4gIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc2l6ZU9ic2VydmVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uLicpO1xuICAgIH1cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcbiAgICB9XG4gICAgdmFyIGNvbnRyb2xsZXIgPSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXJTUEkoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIHRoaXMpO1xuICAgIG9ic2VydmVycy5zZXQodGhpcywgb2JzZXJ2ZXIpO1xuICB9XG4gIHJldHVybiBSZXNpemVPYnNlcnZlcjtcbn0oKTtcbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcyBvZiBSZXNpemVPYnNlcnZlci5cblsnb2JzZXJ2ZScsICd1bm9ic2VydmUnLCAnZGlzY29ubmVjdCddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IG9ic2VydmVycy5nZXQodGhpcykpW21ldGhvZF0uYXBwbHkoX2EsIGFyZ3VtZW50cyk7XG4gIH07XG59KTtcbnZhciBpbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gRXhwb3J0IGV4aXN0aW5nIGltcGxlbWVudGF0aW9uIGlmIGF2YWlsYWJsZS5cbiAgaWYgKHR5cGVvZiBnbG9iYWwkMS5SZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZ2xvYmFsJDEuUmVzaXplT2JzZXJ2ZXI7XG4gIH1cbiAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xufSgpO1xuZXhwb3J0IGRlZmF1bHQgaW5kZXg7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHtcbiAgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xufVxuZXhwb3J0IHsgX2NsYXNzQ2FsbENoZWNrIGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgdG9Qcm9wZXJ0eUtleSBmcm9tIFwiLi90b1Byb3BlcnR5S2V5LmpzXCI7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykge1xuICAgIHZhciBvID0gclt0XTtcbiAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkge1xuICByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6ICExXG4gIH0pLCBlO1xufVxuZXhwb3J0IHsgX2NyZWF0ZUNsYXNzIGFzIGRlZmF1bHQgfTsiLCJ2YXIgd2luZG93XyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsO1xudmFyIGdsb2JhbF8gPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdztcbnZhciBkb2N1bWVudF8gPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB7fTtcbmV4cG9ydCB7IHdpbmRvd18gYXMgd2luZG93LCBnbG9iYWxfIGFzIGdsb2JhbCwgZG9jdW1lbnRfIGFzIGRvY3VtZW50IH07IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0O1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChpdCkgbyA9IGl0O1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzOiBGLFxuICAgICAgICBuOiBmdW5jdGlvbiBuKCkge1xuICAgICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGU6IGZ1bmN0aW9uIGUoX2UpIHtcbiAgICAgICAgICB0aHJvdyBfZTtcbiAgICAgICAgfSxcbiAgICAgICAgZjogRlxuICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG4gIHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSxcbiAgICBkaWRFcnIgPSBmYWxzZSxcbiAgICBlcnI7XG4gIHJldHVybiB7XG4gICAgczogZnVuY3Rpb24gcygpIHtcbiAgICAgIGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfSxcbiAgICBuOiBmdW5jdGlvbiBuKCkge1xuICAgICAgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7XG4gICAgICBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lO1xuICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfSxcbiAgICBlOiBmdW5jdGlvbiBlKF9lMikge1xuICAgICAgZGlkRXJyID0gdHJ1ZTtcbiAgICAgIGVyciA9IF9lMjtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uIGYoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChkaWRFcnIpIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuICByZXR1cm4gYXJyMjtcbn1cbnZhciByZWZQcm9wcyA9IFsndHlwZScsICdzb3VyY2UnLCAnc291cmNlLWxheWVyJywgJ21pbnpvb20nLCAnbWF4em9vbScsICdmaWx0ZXInLCAnbGF5b3V0J107XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUoc3R5bGUpIHtcbiAgaWYgKCFzdHlsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG4gIGlmIChzdHlsZS50b0pTKSB7XG4gICAgc3R5bGUgPSBzdHlsZS50b0pTKCk7XG4gIH1cbiAgdmFyIGxheWVySW5kZXggPSB7fTtcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN0eWxlLmxheWVycyksXG4gICAgX3N0ZXA7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBsYXllciA9IF9zdGVwLnZhbHVlO1xuICAgICAgbGF5ZXJJbmRleFtsYXllci5pZF0gPSBsYXllcjtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuICB2YXIgbGF5ZXJzID0gc3R5bGUubGF5ZXJzLm1hcChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICB2YXIgbGF5ZXJSZWYgPSBsYXllckluZGV4W2xheWVyLnJlZl07XG4gICAgdmFyIG5vcm1hbGl6ZWRMYXllciA9IG51bGw7XG4gICAgaWYgKCdpbnRlcmFjdGl2ZScgaW4gbGF5ZXIpIHtcbiAgICAgIG5vcm1hbGl6ZWRMYXllciA9IF9vYmplY3RTcHJlYWQoe30sIGxheWVyKTtcbiAgICAgIGRlbGV0ZSBub3JtYWxpemVkTGF5ZXIuaW50ZXJhY3RpdmU7XG4gICAgfVxuICAgIGlmIChsYXllclJlZikge1xuICAgICAgbm9ybWFsaXplZExheWVyID0gbm9ybWFsaXplZExheWVyIHx8IF9vYmplY3RTcHJlYWQoe30sIGxheWVyKTtcbiAgICAgIGRlbGV0ZSBub3JtYWxpemVkTGF5ZXIucmVmO1xuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihyZWZQcm9wcyksXG4gICAgICAgIF9zdGVwMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgIGlmIChwcm9wTmFtZSBpbiBsYXllclJlZikge1xuICAgICAgICAgICAgbm9ybWFsaXplZExheWVyW3Byb3BOYW1lXSA9IGxheWVyUmVmW3Byb3BOYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZExheWVyIHx8IGxheWVyO1xuICB9KTtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3R5bGUpLCB7fSwge1xuICAgIGxheWVyczogbGF5ZXJzXG4gIH0pO1xufSIsImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCAqIGFzIFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGRvY3VtZW50IH0gZnJvbSAnLi4vdXRpbHMvZ2xvYmFscyc7XG5pbXBvcnQgeyBub3JtYWxpemVTdHlsZSB9IGZyb20gJy4uL3V0aWxzL3N0eWxlLXV0aWxzJztcbmZ1bmN0aW9uIG5vb3AoKSB7fVxuZnVuY3Rpb24gZGVmYXVsdE9uRXJyb3IoZXZlbnQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgY29uc29sZS5lcnJvcihldmVudC5lcnJvcik7XG4gIH1cbn1cbnZhciBwcm9wVHlwZXMgPSB7XG4gIGNvbnRhaW5lcjogUHJvcFR5cGVzLm9iamVjdCxcbiAgZ2w6IFByb3BUeXBlcy5vYmplY3QsXG4gIG1hcGJveEFwaUFjY2Vzc1Rva2VuOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBtYXBib3hBcGlVcmw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGF0dHJpYnV0aW9uQ29udHJvbDogUHJvcFR5cGVzLmJvb2wsXG4gIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogUHJvcFR5cGVzLmJvb2wsXG4gIHJldXNlTWFwczogUHJvcFR5cGVzLmJvb2wsXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFByb3BUeXBlcy5mdW5jLFxuICBtYXBPcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0LFxuICBtYXBTdHlsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pLFxuICBwcmV2ZW50U3R5bGVEaWZmaW5nOiBQcm9wVHlwZXMuYm9vbCxcbiAgdmlzaWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gIGFzeW5jUmVuZGVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgb25Mb2FkOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25FcnJvcjogUHJvcFR5cGVzLmZ1bmMsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHZpZXdTdGF0ZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgbG9uZ2l0dWRlOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsYXRpdHVkZTogUHJvcFR5cGVzLm51bWJlcixcbiAgem9vbTogUHJvcFR5cGVzLm51bWJlcixcbiAgYmVhcmluZzogUHJvcFR5cGVzLm51bWJlcixcbiAgcGl0Y2g6IFByb3BUeXBlcy5udW1iZXIsXG4gIGFsdGl0dWRlOiBQcm9wVHlwZXMubnVtYmVyXG59O1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogZ2V0QWNjZXNzVG9rZW4oKSxcbiAgbWFwYm94QXBpVXJsOiAnaHR0cHM6Ly9hcGkubWFwYm94LmNvbScsXG4gIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gIGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZSxcbiAgcmV1c2VNYXBzOiBmYWxzZSxcbiAgbWFwT3B0aW9uczoge30sXG4gIG1hcFN0eWxlOiAnbWFwYm94Oi8vc3R5bGVzL21hcGJveC9saWdodC12OCcsXG4gIHByZXZlbnRTdHlsZURpZmZpbmc6IGZhbHNlLFxuICB2aXNpYmxlOiB0cnVlLFxuICBhc3luY1JlbmRlcjogZmFsc2UsXG4gIG9uTG9hZDogbm9vcCxcbiAgb25FcnJvcjogZGVmYXVsdE9uRXJyb3IsXG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG4gIGxvbmdpdHVkZTogMCxcbiAgbGF0aXR1ZGU6IDAsXG4gIHpvb206IDAsXG4gIGJlYXJpbmc6IDAsXG4gIHBpdGNoOiAwLFxuICBhbHRpdHVkZTogMS41XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFjY2Vzc1Rva2VuKCkge1xuICB2YXIgYWNjZXNzVG9rZW4gPSBudWxsO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uKSB7XG4gICAgdmFyIG1hdGNoID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5tYXRjaCgvYWNjZXNzX3Rva2VuPShbXiZcXC9dKikvKTtcbiAgICBhY2Nlc3NUb2tlbiA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICB9XG4gIGlmICghYWNjZXNzVG9rZW4gJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbiB8fCBwcm9jZXNzLmVudi5NYXBib3hBY2Nlc3NUb2tlbiB8fCBwcm9jZXNzLmVudi5SRUFDVF9BUFBfTUFQQk9YX0FDQ0VTU19UT0tFTjtcbiAgfVxuICByZXR1cm4gYWNjZXNzVG9rZW4gfHwgJ25vLXRva2VuJztcbn1cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHByb3BzKSB7XG4gIHZhciBjb21wb25lbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdjb21wb25lbnQnO1xuICBpZiAocHJvcHMuZGVidWcpIHtcbiAgICBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBwcm9wcywgJ3Byb3AnLCBjb21wb25lbnQpO1xuICB9XG59XG52YXIgTWFwYm94ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXBib3gocHJvcHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXBib3gpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb3BzXCIsIGRlZmF1bHRQcm9wcyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2lkdGhcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGVpZ2h0XCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9maXJlTG9hZEV2ZW50XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnByb3BzLm9uTG9hZCh7XG4gICAgICAgIHR5cGU6ICdsb2FkJyxcbiAgICAgICAgdGFyZ2V0OiBfdGhpcy5fbWFwXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaGFuZGxlRXJyb3JcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBfdGhpcy5wcm9wcy5vbkVycm9yKGV2ZW50KTtcbiAgICB9KTtcbiAgICBpZiAoIXByb3BzLm1hcGJveGdsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hcGJveCBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxuICAgIHRoaXMubWFwYm94Z2wgPSBwcm9wcy5tYXBib3hnbDtcbiAgICBpZiAoIU1hcGJveC5pbml0aWFsaXplZCkge1xuICAgICAgTWFwYm94LmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2NoZWNrU3R5bGVTaGVldCh0aGlzLm1hcGJveGdsLnZlcnNpb24pO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsaXplKHByb3BzKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoTWFwYm94LCBbe1xuICAgIGtleTogXCJmaW5hbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5hbGl6ZSgpIHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3koKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQcm9wcyhwcm9wcykge1xuICAgICAgdGhpcy5fdXBkYXRlKHRoaXMucHJvcHMsIHByb3BzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVkcmF3KCkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgICAgIGlmIChtYXAuc3R5bGUpIHtcbiAgICAgICAgaWYgKG1hcC5fZnJhbWUpIHtcbiAgICAgICAgICBtYXAuX2ZyYW1lLmNhbmNlbCgpO1xuICAgICAgICAgIG1hcC5fZnJhbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG1hcC5fcmVuZGVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmV1c2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JldXNlKHByb3BzKSB7XG4gICAgICB0aGlzLl9tYXAgPSBNYXBib3guc2F2ZWRNYXA7XG4gICAgICB2YXIgb2xkQ29udGFpbmVyID0gdGhpcy5fbWFwLmdldENvbnRhaW5lcigpO1xuICAgICAgdmFyIG5ld0NvbnRhaW5lciA9IHByb3BzLmNvbnRhaW5lcjtcbiAgICAgIG5ld0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdtYXBib3hnbC1tYXAnKTtcbiAgICAgIHdoaWxlIChvbGRDb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5ld0NvbnRhaW5lci5hcHBlbmRDaGlsZChvbGRDb250YWluZXIuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tYXAuX2NvbnRhaW5lciA9IG5ld0NvbnRhaW5lcjtcbiAgICAgIE1hcGJveC5zYXZlZE1hcCA9IG51bGw7XG4gICAgICBpZiAocHJvcHMubWFwU3R5bGUpIHtcbiAgICAgICAgdGhpcy5fbWFwLnNldFN0eWxlKG5vcm1hbGl6ZVN0eWxlKHByb3BzLm1hcFN0eWxlKSwge1xuICAgICAgICAgIGRpZmY6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX21hcC5pc1N0eWxlTG9hZGVkKCkpIHtcbiAgICAgICAgdGhpcy5fZmlyZUxvYWRFdmVudCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbWFwLm9uY2UoJ3N0eWxlZGF0YScsIHRoaXMuX2ZpcmVMb2FkRXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGUocHJvcHMpIHtcbiAgICAgIGlmIChwcm9wcy5yZXVzZU1hcHMgJiYgTWFwYm94LnNhdmVkTWFwKSB7XG4gICAgICAgIHRoaXMuX3JldXNlKHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wcy5nbCkge1xuICAgICAgICAgIHZhciBnZXRDb250ZXh0ID0gSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLmdldENvbnRleHQ7XG4gICAgICAgICAgSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLmdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBIVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGdldENvbnRleHQ7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZ2w7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFwT3B0aW9ucyA9IHtcbiAgICAgICAgICBjb250YWluZXI6IHByb3BzLmNvbnRhaW5lcixcbiAgICAgICAgICBjZW50ZXI6IFswLCAwXSxcbiAgICAgICAgICB6b29tOiA4LFxuICAgICAgICAgIHBpdGNoOiAwLFxuICAgICAgICAgIGJlYXJpbmc6IDAsXG4gICAgICAgICAgbWF4Wm9vbTogMjQsXG4gICAgICAgICAgc3R5bGU6IG5vcm1hbGl6ZVN0eWxlKHByb3BzLm1hcFN0eWxlKSxcbiAgICAgICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgdHJhY2tSZXNpemU6IGZhbHNlLFxuICAgICAgICAgIGF0dHJpYnV0aW9uQ29udHJvbDogcHJvcHMuYXR0cmlidXRpb25Db250cm9sLFxuICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogcHJvcHMucHJlc2VydmVEcmF3aW5nQnVmZmVyXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9wcy50cmFuc2Zvcm1SZXF1ZXN0KSB7XG4gICAgICAgICAgbWFwT3B0aW9ucy50cmFuc2Zvcm1SZXF1ZXN0ID0gcHJvcHMudHJhbnNmb3JtUmVxdWVzdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgdGhpcy5tYXBib3hnbC5NYXAoT2JqZWN0LmFzc2lnbih7fSwgbWFwT3B0aW9ucywgcHJvcHMubWFwT3B0aW9ucykpO1xuICAgICAgICB0aGlzLl9tYXAub25jZSgnbG9hZCcsIHRoaXMuX2ZpcmVMb2FkRXZlbnQpO1xuICAgICAgICB0aGlzLl9tYXAub24oJ2Vycm9yJywgdGhpcy5faGFuZGxlRXJyb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgaWYgKCF0aGlzLl9tYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJvcHMucmV1c2VNYXBzICYmICFNYXBib3guc2F2ZWRNYXApIHtcbiAgICAgICAgTWFwYm94LnNhdmVkTWFwID0gdGhpcy5fbWFwO1xuICAgICAgICB0aGlzLl9tYXAub2ZmKCdsb2FkJywgdGhpcy5fZmlyZUxvYWRFdmVudCk7XG4gICAgICAgIHRoaXMuX21hcC5vZmYoJ2Vycm9yJywgdGhpcy5faGFuZGxlRXJyb3IpO1xuICAgICAgICB0aGlzLl9tYXAub2ZmKCdzdHlsZWRhdGEnLCB0aGlzLl9maXJlTG9hZEV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX21hcC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21hcCA9IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0aWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0aWFsaXplKHByb3BzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFByb3BzLCBwcm9wcyk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wcywgJ01hcGJveCcpO1xuICAgICAgdGhpcy5tYXBib3hnbC5hY2Nlc3NUb2tlbiA9IHByb3BzLm1hcGJveEFwaUFjY2Vzc1Rva2VuIHx8IGRlZmF1bHRQcm9wcy5tYXBib3hBcGlBY2Nlc3NUb2tlbjtcbiAgICAgIHRoaXMubWFwYm94Z2wuYmFzZUFwaVVybCA9IHByb3BzLm1hcGJveEFwaVVybDtcbiAgICAgIHRoaXMuX2NyZWF0ZShwcm9wcyk7XG4gICAgICB2YXIgX3Byb3BzID0gcHJvcHMsXG4gICAgICAgIGNvbnRhaW5lciA9IF9wcm9wcy5jb250YWluZXI7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udGFpbmVyLCAnb2Zmc2V0V2lkdGgnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udGFpbmVyLCAnY2xpZW50V2lkdGgnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udGFpbmVyLCAnb2Zmc2V0SGVpZ2h0Jywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250YWluZXIsICdjbGllbnRIZWlnaHQnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuX21hcC5nZXRDYW52YXMoKTtcbiAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgY2FudmFzLnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVNYXBWaWV3cG9ydCh7fSwgcHJvcHMpO1xuICAgICAgdGhpcy5fdXBkYXRlTWFwU2l6ZSh7fSwgcHJvcHMpO1xuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgICBpZiAoIXRoaXMuX21hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuZXdQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIG5ld1Byb3BzKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKG5ld1Byb3BzLCAnTWFwYm94Jyk7XG4gICAgICB2YXIgdmlld3BvcnRDaGFuZ2VkID0gdGhpcy5fdXBkYXRlTWFwVmlld3BvcnQob2xkUHJvcHMsIG5ld1Byb3BzKTtcbiAgICAgIHZhciBzaXplQ2hhbmdlZCA9IHRoaXMuX3VwZGF0ZU1hcFNpemUob2xkUHJvcHMsIG5ld1Byb3BzKTtcbiAgICAgIHRoaXMuX3VwZGF0ZU1hcFN0eWxlKG9sZFByb3BzLCBuZXdQcm9wcyk7XG4gICAgICBpZiAoIW5ld1Byb3BzLmFzeW5jUmVuZGVyICYmICh2aWV3cG9ydENoYW5nZWQgfHwgc2l6ZUNoYW5nZWQpKSB7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnByb3BzID0gbmV3UHJvcHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVNYXBTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlTWFwU3R5bGUob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgICB2YXIgc3R5bGVDaGFuZ2VkID0gb2xkUHJvcHMubWFwU3R5bGUgIT09IG5ld1Byb3BzLm1hcFN0eWxlO1xuICAgICAgaWYgKHN0eWxlQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLl9tYXAuc2V0U3R5bGUobm9ybWFsaXplU3R5bGUobmV3UHJvcHMubWFwU3R5bGUpLCB7XG4gICAgICAgICAgZGlmZjogIW5ld1Byb3BzLnByZXZlbnRTdHlsZURpZmZpbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVNYXBTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVNYXBTaXplKG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgICAgdmFyIHNpemVDaGFuZ2VkID0gb2xkUHJvcHMud2lkdGggIT09IG5ld1Byb3BzLndpZHRoIHx8IG9sZFByb3BzLmhlaWdodCAhPT0gbmV3UHJvcHMuaGVpZ2h0O1xuICAgICAgaWYgKHNpemVDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSBuZXdQcm9wcy53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBuZXdQcm9wcy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX21hcC5yZXNpemUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaXplQ2hhbmdlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZU1hcFZpZXdwb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVNYXBWaWV3cG9ydChvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICAgIHZhciBvbGRWaWV3U3RhdGUgPSB0aGlzLl9nZXRWaWV3U3RhdGUob2xkUHJvcHMpO1xuICAgICAgdmFyIG5ld1ZpZXdTdGF0ZSA9IHRoaXMuX2dldFZpZXdTdGF0ZShuZXdQcm9wcyk7XG4gICAgICB2YXIgdmlld3BvcnRDaGFuZ2VkID0gbmV3Vmlld1N0YXRlLmxhdGl0dWRlICE9PSBvbGRWaWV3U3RhdGUubGF0aXR1ZGUgfHwgbmV3Vmlld1N0YXRlLmxvbmdpdHVkZSAhPT0gb2xkVmlld1N0YXRlLmxvbmdpdHVkZSB8fCBuZXdWaWV3U3RhdGUuem9vbSAhPT0gb2xkVmlld1N0YXRlLnpvb20gfHwgbmV3Vmlld1N0YXRlLnBpdGNoICE9PSBvbGRWaWV3U3RhdGUucGl0Y2ggfHwgbmV3Vmlld1N0YXRlLmJlYXJpbmcgIT09IG9sZFZpZXdTdGF0ZS5iZWFyaW5nIHx8IG5ld1ZpZXdTdGF0ZS5hbHRpdHVkZSAhPT0gb2xkVmlld1N0YXRlLmFsdGl0dWRlO1xuICAgICAgaWYgKHZpZXdwb3J0Q2hhbmdlZCkge1xuICAgICAgICB0aGlzLl9tYXAuanVtcFRvKHRoaXMuX3ZpZXdTdGF0ZVRvTWFwYm94UHJvcHMobmV3Vmlld1N0YXRlKSk7XG4gICAgICAgIGlmIChuZXdWaWV3U3RhdGUuYWx0aXR1ZGUgIT09IG9sZFZpZXdTdGF0ZS5hbHRpdHVkZSkge1xuICAgICAgICAgIHRoaXMuX21hcC50cmFuc2Zvcm0uYWx0aXR1ZGUgPSBuZXdWaWV3U3RhdGUuYWx0aXR1ZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2aWV3cG9ydENoYW5nZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWaWV3U3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZpZXdTdGF0ZShwcm9wcykge1xuICAgICAgdmFyIF9yZWYgPSBwcm9wcy52aWV3U3RhdGUgfHwgcHJvcHMsXG4gICAgICAgIGxvbmdpdHVkZSA9IF9yZWYubG9uZ2l0dWRlLFxuICAgICAgICBsYXRpdHVkZSA9IF9yZWYubGF0aXR1ZGUsXG4gICAgICAgIHpvb20gPSBfcmVmLnpvb20sXG4gICAgICAgIF9yZWYkcGl0Y2ggPSBfcmVmLnBpdGNoLFxuICAgICAgICBwaXRjaCA9IF9yZWYkcGl0Y2ggPT09IHZvaWQgMCA/IDAgOiBfcmVmJHBpdGNoLFxuICAgICAgICBfcmVmJGJlYXJpbmcgPSBfcmVmLmJlYXJpbmcsXG4gICAgICAgIGJlYXJpbmcgPSBfcmVmJGJlYXJpbmcgPT09IHZvaWQgMCA/IDAgOiBfcmVmJGJlYXJpbmcsXG4gICAgICAgIF9yZWYkYWx0aXR1ZGUgPSBfcmVmLmFsdGl0dWRlLFxuICAgICAgICBhbHRpdHVkZSA9IF9yZWYkYWx0aXR1ZGUgPT09IHZvaWQgMCA/IDEuNSA6IF9yZWYkYWx0aXR1ZGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICAgICAgbGF0aXR1ZGU6IGxhdGl0dWRlLFxuICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICBwaXRjaDogcGl0Y2gsXG4gICAgICAgIGJlYXJpbmc6IGJlYXJpbmcsXG4gICAgICAgIGFsdGl0dWRlOiBhbHRpdHVkZVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NoZWNrU3R5bGVTaGVldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tTdHlsZVNoZWV0KCkge1xuICAgICAgdmFyIG1hcGJveFZlcnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcwLjQ3LjAnO1xuICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRlc3RFbGVtZW50LmNsYXNzTmFtZSA9ICdtYXBib3hnbC1tYXAnO1xuICAgICAgICB0ZXN0RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlc3RFbGVtZW50KTtcbiAgICAgICAgdmFyIGlzQ3NzTG9hZGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGVzdEVsZW1lbnQpLnBvc2l0aW9uICE9PSAnc3RhdGljJztcbiAgICAgICAgaWYgKCFpc0Nzc0xvYWRlZCkge1xuICAgICAgICAgIHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdyZWwnLCAnc3R5bGVzaGVldCcpO1xuICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBcImh0dHBzOi8vYXBpLnRpbGVzLm1hcGJveC5jb20vbWFwYm94LWdsLWpzL3ZcIi5jb25jYXQobWFwYm94VmVyc2lvbiwgXCIvbWFwYm94LWdsLmNzc1wiKSk7XG4gICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl92aWV3U3RhdGVUb01hcGJveFByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92aWV3U3RhdGVUb01hcGJveFByb3BzKHZpZXdTdGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2VudGVyOiBbdmlld1N0YXRlLmxvbmdpdHVkZSwgdmlld1N0YXRlLmxhdGl0dWRlXSxcbiAgICAgICAgem9vbTogdmlld1N0YXRlLnpvb20sXG4gICAgICAgIGJlYXJpbmc6IHZpZXdTdGF0ZS5iZWFyaW5nLFxuICAgICAgICBwaXRjaDogdmlld1N0YXRlLnBpdGNoXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTWFwYm94O1xufSgpO1xuX2RlZmluZVByb3BlcnR5KE1hcGJveCwgXCJpbml0aWFsaXplZFwiLCBmYWxzZSk7XG5fZGVmaW5lUHJvcGVydHkoTWFwYm94LCBcInByb3BUeXBlc1wiLCBwcm9wVHlwZXMpO1xuX2RlZmluZVByb3BlcnR5KE1hcGJveCwgXCJkZWZhdWx0UHJvcHNcIiwgZGVmYXVsdFByb3BzKTtcbl9kZWZpbmVQcm9wZXJ0eShNYXBib3gsIFwic2F2ZWRNYXBcIiwgbnVsbCk7XG5leHBvcnQgeyBNYXBib3ggYXMgZGVmYXVsdCB9OyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICdtYXBib3gtZ2wnOyIsInZhciBFUFNJTE9OID0gMWUtNztcbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNBcnJheShhKSAmJiBpc0FycmF5KGIpKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICghZXF1YWxzKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSBFUFNJTE9OO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbGVycChhLCBiLCB0KSB7XG4gIGlmIChpc0FycmF5KGEpKSB7XG4gICAgcmV0dXJuIGEubWFwKGZ1bmN0aW9uIChhaSwgaSkge1xuICAgICAgcmV0dXJuIGxlcnAoYWksIGJbaV0sIHQpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0ICogYiArICgxIC0gdCkgKiBhO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAncmVhY3QtbWFwLWdsOiBhc3NlcnRpb24gZmFpbGVkLicpO1xuICB9XG59IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmltcG9ydCBXZWJNZXJjYXRvclZpZXdwb3J0LCB7IG5vcm1hbGl6ZVZpZXdwb3J0UHJvcHMgfSBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi9tYXRoLXV0aWxzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi9hc3NlcnQnO1xuZXhwb3J0IHZhciBNQVBCT1hfTElNSVRTID0ge1xuICBtaW5ab29tOiAwLFxuICBtYXhab29tOiAyNCxcbiAgbWluUGl0Y2g6IDAsXG4gIG1heFBpdGNoOiA4NVxufTtcbnZhciBERUZBVUxUX1NUQVRFID0ge1xuICBwaXRjaDogMCxcbiAgYmVhcmluZzogMCxcbiAgYWx0aXR1ZGU6IDEuNVxufTtcbnZhciBQSVRDSF9NT1VTRV9USFJFU0hPTEQgPSA1O1xudmFyIFBJVENIX0FDQ0VMID0gMS4yO1xudmFyIE1hcFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXBTdGF0ZShfcmVmKSB7XG4gICAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgbGF0aXR1ZGUgPSBfcmVmLmxhdGl0dWRlLFxuICAgICAgbG9uZ2l0dWRlID0gX3JlZi5sb25naXR1ZGUsXG4gICAgICB6b29tID0gX3JlZi56b29tLFxuICAgICAgX3JlZiRiZWFyaW5nID0gX3JlZi5iZWFyaW5nLFxuICAgICAgYmVhcmluZyA9IF9yZWYkYmVhcmluZyA9PT0gdm9pZCAwID8gREVGQVVMVF9TVEFURS5iZWFyaW5nIDogX3JlZiRiZWFyaW5nLFxuICAgICAgX3JlZiRwaXRjaCA9IF9yZWYucGl0Y2gsXG4gICAgICBwaXRjaCA9IF9yZWYkcGl0Y2ggPT09IHZvaWQgMCA/IERFRkFVTFRfU1RBVEUucGl0Y2ggOiBfcmVmJHBpdGNoLFxuICAgICAgX3JlZiRhbHRpdHVkZSA9IF9yZWYuYWx0aXR1ZGUsXG4gICAgICBhbHRpdHVkZSA9IF9yZWYkYWx0aXR1ZGUgPT09IHZvaWQgMCA/IERFRkFVTFRfU1RBVEUuYWx0aXR1ZGUgOiBfcmVmJGFsdGl0dWRlLFxuICAgICAgX3JlZiRtYXhab29tID0gX3JlZi5tYXhab29tLFxuICAgICAgbWF4Wm9vbSA9IF9yZWYkbWF4Wm9vbSA9PT0gdm9pZCAwID8gTUFQQk9YX0xJTUlUUy5tYXhab29tIDogX3JlZiRtYXhab29tLFxuICAgICAgX3JlZiRtaW5ab29tID0gX3JlZi5taW5ab29tLFxuICAgICAgbWluWm9vbSA9IF9yZWYkbWluWm9vbSA9PT0gdm9pZCAwID8gTUFQQk9YX0xJTUlUUy5taW5ab29tIDogX3JlZiRtaW5ab29tLFxuICAgICAgX3JlZiRtYXhQaXRjaCA9IF9yZWYubWF4UGl0Y2gsXG4gICAgICBtYXhQaXRjaCA9IF9yZWYkbWF4UGl0Y2ggPT09IHZvaWQgMCA/IE1BUEJPWF9MSU1JVFMubWF4UGl0Y2ggOiBfcmVmJG1heFBpdGNoLFxuICAgICAgX3JlZiRtaW5QaXRjaCA9IF9yZWYubWluUGl0Y2gsXG4gICAgICBtaW5QaXRjaCA9IF9yZWYkbWluUGl0Y2ggPT09IHZvaWQgMCA/IE1BUEJPWF9MSU1JVFMubWluUGl0Y2ggOiBfcmVmJG1pblBpdGNoLFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gX3JlZi50cmFuc2l0aW9uRHVyYXRpb24sXG4gICAgICB0cmFuc2l0aW9uRWFzaW5nID0gX3JlZi50cmFuc2l0aW9uRWFzaW5nLFxuICAgICAgdHJhbnNpdGlvbkludGVycG9sYXRvciA9IF9yZWYudHJhbnNpdGlvbkludGVycG9sYXRvcixcbiAgICAgIHRyYW5zaXRpb25JbnRlcnJ1cHRpb24gPSBfcmVmLnRyYW5zaXRpb25JbnRlcnJ1cHRpb24sXG4gICAgICBzdGFydFBhbkxuZ0xhdCA9IF9yZWYuc3RhcnRQYW5MbmdMYXQsXG4gICAgICBzdGFydFpvb21MbmdMYXQgPSBfcmVmLnN0YXJ0Wm9vbUxuZ0xhdCxcbiAgICAgIHN0YXJ0Um90YXRlUG9zID0gX3JlZi5zdGFydFJvdGF0ZVBvcyxcbiAgICAgIHN0YXJ0QmVhcmluZyA9IF9yZWYuc3RhcnRCZWFyaW5nLFxuICAgICAgc3RhcnRQaXRjaCA9IF9yZWYuc3RhcnRQaXRjaCxcbiAgICAgIHN0YXJ0Wm9vbSA9IF9yZWYuc3RhcnRab29tO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXBTdGF0ZSk7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh3aWR0aCksICdgd2lkdGhgIG11c3QgYmUgc3VwcGxpZWQnKTtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGhlaWdodCksICdgaGVpZ2h0YCBtdXN0IGJlIHN1cHBsaWVkJyk7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShsb25naXR1ZGUpLCAnYGxvbmdpdHVkZWAgbXVzdCBiZSBzdXBwbGllZCcpO1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUobGF0aXR1ZGUpLCAnYGxhdGl0dWRlYCBtdXN0IGJlIHN1cHBsaWVkJyk7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh6b29tKSwgJ2B6b29tYCBtdXN0IGJlIHN1cHBsaWVkJyk7XG4gICAgdGhpcy5fdmlld3BvcnRQcm9wcyA9IHRoaXMuX2FwcGx5Q29uc3RyYWludHMoe1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICBsYXRpdHVkZTogbGF0aXR1ZGUsXG4gICAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICAgIHpvb206IHpvb20sXG4gICAgICBiZWFyaW5nOiBiZWFyaW5nLFxuICAgICAgcGl0Y2g6IHBpdGNoLFxuICAgICAgYWx0aXR1ZGU6IGFsdGl0dWRlLFxuICAgICAgbWF4Wm9vbTogbWF4Wm9vbSxcbiAgICAgIG1pblpvb206IG1pblpvb20sXG4gICAgICBtYXhQaXRjaDogbWF4UGl0Y2gsXG4gICAgICBtaW5QaXRjaDogbWluUGl0Y2gsXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb246IHRyYW5zaXRpb25EdXJhdGlvbixcbiAgICAgIHRyYW5zaXRpb25FYXNpbmc6IHRyYW5zaXRpb25FYXNpbmcsXG4gICAgICB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yOiB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yLFxuICAgICAgdHJhbnNpdGlvbkludGVycnVwdGlvbjogdHJhbnNpdGlvbkludGVycnVwdGlvblxuICAgIH0pO1xuICAgIHRoaXMuX3N0YXRlID0ge1xuICAgICAgc3RhcnRQYW5MbmdMYXQ6IHN0YXJ0UGFuTG5nTGF0LFxuICAgICAgc3RhcnRab29tTG5nTGF0OiBzdGFydFpvb21MbmdMYXQsXG4gICAgICBzdGFydFJvdGF0ZVBvczogc3RhcnRSb3RhdGVQb3MsXG4gICAgICBzdGFydEJlYXJpbmc6IHN0YXJ0QmVhcmluZyxcbiAgICAgIHN0YXJ0UGl0Y2g6IHN0YXJ0UGl0Y2gsXG4gICAgICBzdGFydFpvb206IHN0YXJ0Wm9vbVxuICAgIH07XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKE1hcFN0YXRlLCBbe1xuICAgIGtleTogXCJnZXRWaWV3cG9ydFByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpZXdwb3J0UHJvcHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRQcm9wcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhblN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhblN0YXJ0KF9yZWYyKSB7XG4gICAgICB2YXIgcG9zID0gX3JlZjIucG9zO1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZSh7XG4gICAgICAgIHN0YXJ0UGFuTG5nTGF0OiB0aGlzLl91bnByb2plY3QocG9zKVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYW4oX3JlZjMpIHtcbiAgICAgIHZhciBwb3MgPSBfcmVmMy5wb3MsXG4gICAgICAgIHN0YXJ0UG9zID0gX3JlZjMuc3RhcnRQb3M7XG4gICAgICB2YXIgc3RhcnRQYW5MbmdMYXQgPSB0aGlzLl9zdGF0ZS5zdGFydFBhbkxuZ0xhdCB8fCB0aGlzLl91bnByb2plY3Qoc3RhcnRQb3MpO1xuICAgICAgaWYgKCFzdGFydFBhbkxuZ0xhdCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBfdGhpcyRfY2FsY3VsYXRlTmV3TG4gPSB0aGlzLl9jYWxjdWxhdGVOZXdMbmdMYXQoe1xuICAgICAgICAgIHN0YXJ0UGFuTG5nTGF0OiBzdGFydFBhbkxuZ0xhdCxcbiAgICAgICAgICBwb3M6IHBvc1xuICAgICAgICB9KSxcbiAgICAgICAgX3RoaXMkX2NhbGN1bGF0ZU5ld0xuMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9jYWxjdWxhdGVOZXdMbiwgMiksXG4gICAgICAgIGxvbmdpdHVkZSA9IF90aGlzJF9jYWxjdWxhdGVOZXdMbjJbMF0sXG4gICAgICAgIGxhdGl0dWRlID0gX3RoaXMkX2NhbGN1bGF0ZU5ld0xuMlsxXTtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkTWFwU3RhdGUoe1xuICAgICAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICAgICAgbGF0aXR1ZGU6IGxhdGl0dWRlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFuRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhbkVuZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkTWFwU3RhdGUoe1xuICAgICAgICBzdGFydFBhbkxuZ0xhdDogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdGF0ZVN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdGF0ZVN0YXJ0KF9yZWY0KSB7XG4gICAgICB2YXIgcG9zID0gX3JlZjQucG9zO1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZSh7XG4gICAgICAgIHN0YXJ0Um90YXRlUG9zOiBwb3MsXG4gICAgICAgIHN0YXJ0QmVhcmluZzogdGhpcy5fdmlld3BvcnRQcm9wcy5iZWFyaW5nLFxuICAgICAgICBzdGFydFBpdGNoOiB0aGlzLl92aWV3cG9ydFByb3BzLnBpdGNoXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm90YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdGF0ZShfcmVmNSkge1xuICAgICAgdmFyIHBvcyA9IF9yZWY1LnBvcyxcbiAgICAgICAgX3JlZjUkZGVsdGFBbmdsZVggPSBfcmVmNS5kZWx0YUFuZ2xlWCxcbiAgICAgICAgZGVsdGFBbmdsZVggPSBfcmVmNSRkZWx0YUFuZ2xlWCA9PT0gdm9pZCAwID8gMCA6IF9yZWY1JGRlbHRhQW5nbGVYLFxuICAgICAgICBfcmVmNSRkZWx0YUFuZ2xlWSA9IF9yZWY1LmRlbHRhQW5nbGVZLFxuICAgICAgICBkZWx0YUFuZ2xlWSA9IF9yZWY1JGRlbHRhQW5nbGVZID09PSB2b2lkIDAgPyAwIDogX3JlZjUkZGVsdGFBbmdsZVk7XG4gICAgICB2YXIgX3RoaXMkX3N0YXRlID0gdGhpcy5fc3RhdGUsXG4gICAgICAgIHN0YXJ0Um90YXRlUG9zID0gX3RoaXMkX3N0YXRlLnN0YXJ0Um90YXRlUG9zLFxuICAgICAgICBzdGFydEJlYXJpbmcgPSBfdGhpcyRfc3RhdGUuc3RhcnRCZWFyaW5nLFxuICAgICAgICBzdGFydFBpdGNoID0gX3RoaXMkX3N0YXRlLnN0YXJ0UGl0Y2g7XG4gICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShzdGFydEJlYXJpbmcpIHx8ICFOdW1iZXIuaXNGaW5pdGUoc3RhcnRQaXRjaCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbmV3Um90YXRpb247XG4gICAgICBpZiAocG9zKSB7XG4gICAgICAgIG5ld1JvdGF0aW9uID0gdGhpcy5fY2FsY3VsYXRlTmV3UGl0Y2hBbmRCZWFyaW5nKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5fZ2V0Um90YXRpb25QYXJhbXMocG9zLCBzdGFydFJvdGF0ZVBvcykpLCB7fSwge1xuICAgICAgICAgIHN0YXJ0QmVhcmluZzogc3RhcnRCZWFyaW5nLFxuICAgICAgICAgIHN0YXJ0UGl0Y2g6IHN0YXJ0UGl0Y2hcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3Um90YXRpb24gPSB7XG4gICAgICAgICAgYmVhcmluZzogc3RhcnRCZWFyaW5nICsgZGVsdGFBbmdsZVgsXG4gICAgICAgICAgcGl0Y2g6IHN0YXJ0UGl0Y2ggKyBkZWx0YUFuZ2xlWVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZShuZXdSb3RhdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdGF0ZUVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3RhdGVFbmQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE1hcFN0YXRlKHtcbiAgICAgICAgc3RhcnRCZWFyaW5nOiBudWxsLFxuICAgICAgICBzdGFydFBpdGNoOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiem9vbVN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHpvb21TdGFydChfcmVmNikge1xuICAgICAgdmFyIHBvcyA9IF9yZWY2LnBvcztcbiAgICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkTWFwU3RhdGUoe1xuICAgICAgICBzdGFydFpvb21MbmdMYXQ6IHRoaXMuX3VucHJvamVjdChwb3MpLFxuICAgICAgICBzdGFydFpvb206IHRoaXMuX3ZpZXdwb3J0UHJvcHMuem9vbVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInpvb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gem9vbShfcmVmNykge1xuICAgICAgdmFyIHBvcyA9IF9yZWY3LnBvcyxcbiAgICAgICAgc3RhcnRQb3MgPSBfcmVmNy5zdGFydFBvcyxcbiAgICAgICAgc2NhbGUgPSBfcmVmNy5zY2FsZTtcbiAgICAgIGFzc2VydChzY2FsZSA+IDAsICdgc2NhbGVgIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgIHZhciBfdGhpcyRfc3RhdGUyID0gdGhpcy5fc3RhdGUsXG4gICAgICAgIHN0YXJ0Wm9vbSA9IF90aGlzJF9zdGF0ZTIuc3RhcnRab29tLFxuICAgICAgICBzdGFydFpvb21MbmdMYXQgPSBfdGhpcyRfc3RhdGUyLnN0YXJ0Wm9vbUxuZ0xhdDtcbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHN0YXJ0Wm9vbSkpIHtcbiAgICAgICAgc3RhcnRab29tID0gdGhpcy5fdmlld3BvcnRQcm9wcy56b29tO1xuICAgICAgICBzdGFydFpvb21MbmdMYXQgPSB0aGlzLl91bnByb2plY3Qoc3RhcnRQb3MpIHx8IHRoaXMuX3VucHJvamVjdChwb3MpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KHN0YXJ0Wm9vbUxuZ0xhdCwgJ2BzdGFydFpvb21MbmdMYXRgIHByb3AgaXMgcmVxdWlyZWQgJyArICdmb3Igem9vbSBiZWhhdmlvciB0byBjYWxjdWxhdGUgd2hlcmUgdG8gcG9zaXRpb24gdGhlIG1hcC4nKTtcbiAgICAgIHZhciB6b29tID0gdGhpcy5fY2FsY3VsYXRlTmV3Wm9vbSh7XG4gICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgc3RhcnRab29tOiBzdGFydFpvb20gfHwgMFxuICAgICAgfSk7XG4gICAgICB2YXIgem9vbWVkVmlld3BvcnQgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydChPYmplY3QuYXNzaWduKHt9LCB0aGlzLl92aWV3cG9ydFByb3BzLCB7XG4gICAgICAgIHpvb206IHpvb21cbiAgICAgIH0pKTtcbiAgICAgIHZhciBfem9vbWVkVmlld3BvcnQkZ2V0TWEgPSB6b29tZWRWaWV3cG9ydC5nZXRNYXBDZW50ZXJCeUxuZ0xhdFBvc2l0aW9uKHtcbiAgICAgICAgICBsbmdMYXQ6IHN0YXJ0Wm9vbUxuZ0xhdCxcbiAgICAgICAgICBwb3M6IHBvc1xuICAgICAgICB9KSxcbiAgICAgICAgX3pvb21lZFZpZXdwb3J0JGdldE1hMiA9IF9zbGljZWRUb0FycmF5KF96b29tZWRWaWV3cG9ydCRnZXRNYSwgMiksXG4gICAgICAgIGxvbmdpdHVkZSA9IF96b29tZWRWaWV3cG9ydCRnZXRNYTJbMF0sXG4gICAgICAgIGxhdGl0dWRlID0gX3pvb21lZFZpZXdwb3J0JGdldE1hMlsxXTtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkTWFwU3RhdGUoe1xuICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICAgICAgbGF0aXR1ZGU6IGxhdGl0dWRlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiem9vbUVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB6b29tRW5kKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZSh7XG4gICAgICAgIHN0YXJ0Wm9vbUxuZ0xhdDogbnVsbCxcbiAgICAgICAgc3RhcnRab29tOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFVwZGF0ZWRNYXBTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VXBkYXRlZE1hcFN0YXRlKG5ld1Byb3BzKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3ZpZXdwb3J0UHJvcHMsIHRoaXMuX3N0YXRlLCBuZXdQcm9wcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfYXBwbHlDb25zdHJhaW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwbHlDb25zdHJhaW50cyhwcm9wcykge1xuICAgICAgdmFyIG1heFpvb20gPSBwcm9wcy5tYXhab29tLFxuICAgICAgICBtaW5ab29tID0gcHJvcHMubWluWm9vbSxcbiAgICAgICAgem9vbSA9IHByb3BzLnpvb207XG4gICAgICBwcm9wcy56b29tID0gY2xhbXAoem9vbSwgbWluWm9vbSwgbWF4Wm9vbSk7XG4gICAgICB2YXIgbWF4UGl0Y2ggPSBwcm9wcy5tYXhQaXRjaCxcbiAgICAgICAgbWluUGl0Y2ggPSBwcm9wcy5taW5QaXRjaCxcbiAgICAgICAgcGl0Y2ggPSBwcm9wcy5waXRjaDtcbiAgICAgIHByb3BzLnBpdGNoID0gY2xhbXAocGl0Y2gsIG1pblBpdGNoLCBtYXhQaXRjaCk7XG4gICAgICBPYmplY3QuYXNzaWduKHByb3BzLCBub3JtYWxpemVWaWV3cG9ydFByb3BzKHByb3BzKSk7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91bnByb2plY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VucHJvamVjdChwb3MpIHtcbiAgICAgIHZhciB2aWV3cG9ydCA9IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHRoaXMuX3ZpZXdwb3J0UHJvcHMpO1xuICAgICAgcmV0dXJuIHBvcyAmJiB2aWV3cG9ydC51bnByb2plY3QocG9zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZU5ld0xuZ0xhdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlTmV3TG5nTGF0KF9yZWY4KSB7XG4gICAgICB2YXIgc3RhcnRQYW5MbmdMYXQgPSBfcmVmOC5zdGFydFBhbkxuZ0xhdCxcbiAgICAgICAgcG9zID0gX3JlZjgucG9zO1xuICAgICAgdmFyIHZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQodGhpcy5fdmlld3BvcnRQcm9wcyk7XG4gICAgICByZXR1cm4gdmlld3BvcnQuZ2V0TWFwQ2VudGVyQnlMbmdMYXRQb3NpdGlvbih7XG4gICAgICAgIGxuZ0xhdDogc3RhcnRQYW5MbmdMYXQsXG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZU5ld1pvb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZU5ld1pvb20oX3JlZjkpIHtcbiAgICAgIHZhciBzY2FsZSA9IF9yZWY5LnNjYWxlLFxuICAgICAgICBzdGFydFpvb20gPSBfcmVmOS5zdGFydFpvb207XG4gICAgICB2YXIgX3RoaXMkX3ZpZXdwb3J0UHJvcHMgPSB0aGlzLl92aWV3cG9ydFByb3BzLFxuICAgICAgICBtYXhab29tID0gX3RoaXMkX3ZpZXdwb3J0UHJvcHMubWF4Wm9vbSxcbiAgICAgICAgbWluWm9vbSA9IF90aGlzJF92aWV3cG9ydFByb3BzLm1pblpvb207XG4gICAgICB2YXIgem9vbSA9IHN0YXJ0Wm9vbSArIE1hdGgubG9nMihzY2FsZSk7XG4gICAgICByZXR1cm4gY2xhbXAoem9vbSwgbWluWm9vbSwgbWF4Wm9vbSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jYWxjdWxhdGVOZXdQaXRjaEFuZEJlYXJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZU5ld1BpdGNoQW5kQmVhcmluZyhfcmVmMTApIHtcbiAgICAgIHZhciBkZWx0YVNjYWxlWCA9IF9yZWYxMC5kZWx0YVNjYWxlWCxcbiAgICAgICAgZGVsdGFTY2FsZVkgPSBfcmVmMTAuZGVsdGFTY2FsZVksXG4gICAgICAgIHN0YXJ0QmVhcmluZyA9IF9yZWYxMC5zdGFydEJlYXJpbmcsXG4gICAgICAgIHN0YXJ0UGl0Y2ggPSBfcmVmMTAuc3RhcnRQaXRjaDtcbiAgICAgIGRlbHRhU2NhbGVZID0gY2xhbXAoZGVsdGFTY2FsZVksIC0xLCAxKTtcbiAgICAgIHZhciBfdGhpcyRfdmlld3BvcnRQcm9wczIgPSB0aGlzLl92aWV3cG9ydFByb3BzLFxuICAgICAgICBtaW5QaXRjaCA9IF90aGlzJF92aWV3cG9ydFByb3BzMi5taW5QaXRjaCxcbiAgICAgICAgbWF4UGl0Y2ggPSBfdGhpcyRfdmlld3BvcnRQcm9wczIubWF4UGl0Y2g7XG4gICAgICB2YXIgYmVhcmluZyA9IHN0YXJ0QmVhcmluZyArIDE4MCAqIGRlbHRhU2NhbGVYO1xuICAgICAgdmFyIHBpdGNoID0gc3RhcnRQaXRjaDtcbiAgICAgIGlmIChkZWx0YVNjYWxlWSA+IDApIHtcbiAgICAgICAgcGl0Y2ggPSBzdGFydFBpdGNoICsgZGVsdGFTY2FsZVkgKiAobWF4UGl0Y2ggLSBzdGFydFBpdGNoKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVsdGFTY2FsZVkgPCAwKSB7XG4gICAgICAgIHBpdGNoID0gc3RhcnRQaXRjaCAtIGRlbHRhU2NhbGVZICogKG1pblBpdGNoIC0gc3RhcnRQaXRjaCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwaXRjaDogcGl0Y2gsXG4gICAgICAgIGJlYXJpbmc6IGJlYXJpbmdcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRSb3RhdGlvblBhcmFtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Um90YXRpb25QYXJhbXMocG9zLCBzdGFydFBvcykge1xuICAgICAgdmFyIGRlbHRhWCA9IHBvc1swXSAtIHN0YXJ0UG9zWzBdO1xuICAgICAgdmFyIGRlbHRhWSA9IHBvc1sxXSAtIHN0YXJ0UG9zWzFdO1xuICAgICAgdmFyIGNlbnRlclkgPSBwb3NbMV07XG4gICAgICB2YXIgc3RhcnRZID0gc3RhcnRQb3NbMV07XG4gICAgICB2YXIgX3RoaXMkX3ZpZXdwb3J0UHJvcHMzID0gdGhpcy5fdmlld3BvcnRQcm9wcyxcbiAgICAgICAgd2lkdGggPSBfdGhpcyRfdmlld3BvcnRQcm9wczMud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF90aGlzJF92aWV3cG9ydFByb3BzMy5oZWlnaHQ7XG4gICAgICB2YXIgZGVsdGFTY2FsZVggPSBkZWx0YVggLyB3aWR0aDtcbiAgICAgIHZhciBkZWx0YVNjYWxlWSA9IDA7XG4gICAgICBpZiAoZGVsdGFZID4gMCkge1xuICAgICAgICBpZiAoTWF0aC5hYnMoaGVpZ2h0IC0gc3RhcnRZKSA+IFBJVENIX01PVVNFX1RIUkVTSE9MRCkge1xuICAgICAgICAgIGRlbHRhU2NhbGVZID0gZGVsdGFZIC8gKHN0YXJ0WSAtIGhlaWdodCkgKiBQSVRDSF9BQ0NFTDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkZWx0YVkgPCAwKSB7XG4gICAgICAgIGlmIChzdGFydFkgPiBQSVRDSF9NT1VTRV9USFJFU0hPTEQpIHtcbiAgICAgICAgICBkZWx0YVNjYWxlWSA9IDEgLSBjZW50ZXJZIC8gc3RhcnRZO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWx0YVNjYWxlWSA9IE1hdGgubWluKDEsIE1hdGgubWF4KC0xLCBkZWx0YVNjYWxlWSkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVsdGFTY2FsZVg6IGRlbHRhU2NhbGVYLFxuICAgICAgICBkZWx0YVNjYWxlWTogZGVsdGFTY2FsZVlcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNYXBTdGF0ZTtcbn0oKTtcbmV4cG9ydCB7IE1hcFN0YXRlIGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgeyBNQVBCT1hfTElNSVRTIH0gZnJvbSAnLi9tYXAtc3RhdGUnO1xuZnVuY3Rpb24gZGVjYXBpdGFsaXplKHMpIHtcbiAgcmV0dXJuIHNbMF0udG9Mb3dlckNhc2UoKSArIHMuc2xpY2UoMSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tWaXNpYmlsaXR5Q29uc3RyYWludHMocHJvcHMpIHtcbiAgdmFyIGNvbnN0cmFpbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBNQVBCT1hfTElNSVRTO1xuICBmb3IgKHZhciBjb25zdHJhaW50TmFtZSBpbiBjb25zdHJhaW50cykge1xuICAgIHZhciB0eXBlID0gY29uc3RyYWludE5hbWUuc2xpY2UoMCwgMyk7XG4gICAgdmFyIHByb3BOYW1lID0gZGVjYXBpdGFsaXplKGNvbnN0cmFpbnROYW1lLnNsaWNlKDMpKTtcbiAgICBpZiAodHlwZSA9PT0gJ21pbicgJiYgcHJvcHNbcHJvcE5hbWVdIDwgY29uc3RyYWludHNbY29uc3RyYWludE5hbWVdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnbWF4JyAmJiBwcm9wc1twcm9wTmFtZV0gPiBjb25zdHJhaW50c1tjb25zdHJhaW50TmFtZV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VTdGF0ZSwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbnZhciBNYXBDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7XG4gIHZpZXdwb3J0OiBudWxsLFxuICBtYXA6IG51bGwsXG4gIGNvbnRhaW5lcjogbnVsbCxcbiAgb25WaWV3cG9ydENoYW5nZTogbnVsbCxcbiAgb25WaWV3U3RhdGVDaGFuZ2U6IG51bGwsXG4gIGV2ZW50TWFuYWdlcjogbnVsbFxufSk7XG5leHBvcnQgdmFyIE1hcENvbnRleHRQcm92aWRlciA9IE1hcENvbnRleHQuUHJvdmlkZXI7XG5mdW5jdGlvbiBXcmFwcGVkUHJvdmlkZXIoX3JlZikge1xuICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlLFxuICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKG51bGwpLFxuICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgIG1hcCA9IF91c2VTdGF0ZTJbMF0sXG4gICAgc2V0TWFwID0gX3VzZVN0YXRlMlsxXTtcbiAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICB2YWx1ZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgc2V0TWFwOiBzZXRNYXBcbiAgfSwgY29udGV4dCksIHt9LCB7XG4gICAgbWFwOiBjb250ZXh0ICYmIGNvbnRleHQubWFwIHx8IG1hcFxuICB9LCB2YWx1ZSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcENvbnRleHRQcm92aWRlciwge1xuICAgIHZhbHVlOiB2YWx1ZVxuICB9LCBjaGlsZHJlbik7XG59XG5NYXBDb250ZXh0LlByb3ZpZGVyID0gV3JhcHBlZFByb3ZpZGVyO1xuZXhwb3J0IGRlZmF1bHQgTWFwQ29udGV4dDsiLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5leHBvcnQgZGVmYXVsdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0OyIsImV4cG9ydCBmdW5jdGlvbiBnZXRUZXJyYWluRWxldmF0aW9uKG1hcCwgX3JlZikge1xuICB2YXIgbG9uZ2l0dWRlID0gX3JlZi5sb25naXR1ZGUsXG4gICAgbGF0aXR1ZGUgPSBfcmVmLmxhdGl0dWRlO1xuICBpZiAobWFwICYmIG1hcC5xdWVyeVRlcnJhaW5FbGV2YXRpb24pIHtcbiAgICByZXR1cm4gbWFwLnF1ZXJ5VGVycmFpbkVsZXZhdGlvbihbbG9uZ2l0dWRlLCBsYXRpdHVkZV0pIHx8IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59IiwiaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBXZWJNZXJjYXRvclZpZXdwb3J0IGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QnO1xuaW1wb3J0IFJlc2l6ZU9ic2VydmVyIGZyb20gJ3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbCc7XG5pbXBvcnQgTWFwYm94IGZyb20gJy4uL21hcGJveC9tYXBib3gnO1xuaW1wb3J0IG1hcGJveGdsIGZyb20gJy4uL3V0aWxzL21hcGJveGdsJztcbmltcG9ydCB7IGNoZWNrVmlzaWJpbGl0eUNvbnN0cmFpbnRzIH0gZnJvbSAnLi4vdXRpbHMvbWFwLWNvbnN0cmFpbnRzJztcbmltcG9ydCB7IE1BUEJPWF9MSU1JVFMgfSBmcm9tICcuLi91dGlscy9tYXAtc3RhdGUnO1xuaW1wb3J0IE1hcENvbnRleHQsIHsgTWFwQ29udGV4dFByb3ZpZGVyIH0gZnJvbSAnLi9tYXAtY29udGV4dCc7XG5pbXBvcnQgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCBmcm9tICcuLi91dGlscy91c2UtaXNvbW9ycGhpYy1sYXlvdXQtZWZmZWN0JztcbmltcG9ydCB7IGdldFRlcnJhaW5FbGV2YXRpb24gfSBmcm9tICcuLi91dGlscy90ZXJyYWluJztcbnZhciBUT0tFTl9ET0NfVVJMID0gJ2h0dHBzOi8vdmlzZ2wuZ2l0aHViLmlvL3JlYWN0LW1hcC1nbC9kb2NzL2dldC1zdGFydGVkL21hcGJveC10b2tlbnMnO1xudmFyIE5PX1RPS0VOX1dBUk5JTkcgPSAnQSB2YWxpZCBBUEkgYWNjZXNzIHRva2VuIGlzIHJlcXVpcmVkIHRvIHVzZSBNYXBib3ggZGF0YSc7XG5mdW5jdGlvbiBub29wKCkge31cbmV4cG9ydCBmdW5jdGlvbiBnZXRWaWV3cG9ydChfcmVmKSB7XG4gIHZhciBtYXAgPSBfcmVmLm1hcCxcbiAgICBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0O1xuICB2YXIgdmlld3BvcnRQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHByb3BzLnZpZXdTdGF0ZSksIHt9LCB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH0pO1xuICB2aWV3cG9ydFByb3BzLnBvc2l0aW9uID0gWzAsIDAsIGdldFRlcnJhaW5FbGV2YXRpb24obWFwLCB2aWV3cG9ydFByb3BzKV07XG4gIHJldHVybiBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh2aWV3cG9ydFByb3BzKTtcbn1cbnZhciBVTkFVVEhPUklaRURfRVJST1JfQ09ERSA9IDQwMTtcbnZhciBDT05UQUlORVJfU1RZTEUgPSB7XG4gIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICB3aWR0aDogJzEwMCUnLFxuICBoZWlnaHQ6ICcxMDAlJyxcbiAgb3ZlcmZsb3c6ICdoaWRkZW4nXG59O1xudmFyIGRlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIE1hcGJveC5kZWZhdWx0UHJvcHMsIHtcbiAgZGlzYWJsZVRva2VuV2FybmluZzogZmFsc2UsXG4gIHZpc2libGU6IHRydWUsXG4gIG9uUmVzaXplOiBub29wLFxuICBjbGFzc05hbWU6ICcnLFxuICBzdHlsZTogbnVsbCxcbiAgdmlzaWJpbGl0eUNvbnN0cmFpbnRzOiBNQVBCT1hfTElNSVRTXG59KTtcbmZ1bmN0aW9uIE5vVG9rZW5XYXJuaW5nKCkge1xuICB2YXIgc3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDBcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGtleTogXCJ3YXJuaW5nXCIsXG4gICAgaWQ6IFwibm8tdG9rZW4td2FybmluZ1wiLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDNcIiwge1xuICAgIGtleTogXCJoZWFkZXJcIlxuICB9LCBOT19UT0tFTl9XQVJOSU5HKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAga2V5OiBcInRleHRcIlxuICB9LCBcIkZvciBpbmZvcm1hdGlvbiBvbiBzZXR0aW5nIHVwIHlvdXIgYmFzZW1hcCwgcmVhZFwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwge1xuICAgIGtleTogXCJsaW5rXCIsXG4gICAgaHJlZjogVE9LRU5fRE9DX1VSTFxuICB9LCBcIk5vdGUgb24gTWFwIFRva2Vuc1wiKSk7XG59XG5mdW5jdGlvbiBnZXRSZWZIYW5kbGVzKG1hcGJveFJlZikge1xuICByZXR1cm4ge1xuICAgIGdldE1hcDogZnVuY3Rpb24gZ2V0TWFwKCkge1xuICAgICAgcmV0dXJuIG1hcGJveFJlZi5jdXJyZW50ICYmIG1hcGJveFJlZi5jdXJyZW50LmdldE1hcCgpO1xuICAgIH0sXG4gICAgcXVlcnlSZW5kZXJlZEZlYXR1cmVzOiBmdW5jdGlvbiBxdWVyeVJlbmRlcmVkRmVhdHVyZXMoZ2VvbWV0cnkpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBtYXAgPSBtYXBib3hSZWYuY3VycmVudCAmJiBtYXBib3hSZWYuY3VycmVudC5nZXRNYXAoKTtcbiAgICAgIHJldHVybiBtYXAgJiYgbWFwLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhnZW9tZXRyeSwgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xufVxudmFyIFN0YXRpY01hcCA9IGZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKHRydWUpLFxuICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgIGFjY2Vzc1Rva2VuVmFsaWQgPSBfdXNlU3RhdGUyWzBdLFxuICAgIHNldFRva2VuU3RhdGUgPSBfdXNlU3RhdGUyWzFdO1xuICB2YXIgX3VzZVN0YXRlMyA9IHVzZVN0YXRlKHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfSksXG4gICAgX3VzZVN0YXRlNCA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZTMsIDIpLFxuICAgIHNpemUgPSBfdXNlU3RhdGU0WzBdLFxuICAgIHNldFNpemUgPSBfdXNlU3RhdGU0WzFdO1xuICB2YXIgbWFwYm94UmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgbWFwRGl2UmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgY29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgb3ZlcmxheVJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIVN0YXRpY01hcC5zdXBwb3J0ZWQoKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIG1hcGJveCA9IG5ldyBNYXBib3goX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwgc2l6ZSksIHt9LCB7XG4gICAgICBtYXBib3hnbDogbWFwYm94Z2wsXG4gICAgICBjb250YWluZXI6IG1hcERpdlJlZi5jdXJyZW50LFxuICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihldnQpIHtcbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSBldnQuZXJyb3IgJiYgZXZ0LmVycm9yLnN0YXR1cyB8fCBldnQuc3RhdHVzO1xuICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gVU5BVVRIT1JJWkVEX0VSUk9SX0NPREUgJiYgYWNjZXNzVG9rZW5WYWxpZCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoTk9fVE9LRU5fV0FSTklORyk7XG4gICAgICAgICAgc2V0VG9rZW5TdGF0ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcHMub25FcnJvcihldnQpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBtYXBib3hSZWYuY3VycmVudCA9IG1hcGJveDtcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LnNldE1hcCkge1xuICAgICAgY29udGV4dC5zZXRNYXAobWFwYm94LmdldE1hcCgpKTtcbiAgICB9XG4gICAgdmFyIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICBpZiAoZW50cmllc1swXS5jb250ZW50UmVjdCkge1xuICAgICAgICB2YXIgX2VudHJpZXMkMCRjb250ZW50UmVjID0gZW50cmllc1swXS5jb250ZW50UmVjdCxcbiAgICAgICAgICBfd2lkdGggPSBfZW50cmllcyQwJGNvbnRlbnRSZWMud2lkdGgsXG4gICAgICAgICAgX2hlaWdodCA9IF9lbnRyaWVzJDAkY29udGVudFJlYy5oZWlnaHQ7XG4gICAgICAgIHNldFNpemUoe1xuICAgICAgICAgIHdpZHRoOiBfd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBfaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcy5vblJlc2l6ZSh7XG4gICAgICAgICAgd2lkdGg6IF93aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IF9oZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXJSZWYuY3VycmVudCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIG1hcGJveC5maW5hbGl6ZSgpO1xuICAgICAgbWFwYm94UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG1hcGJveFJlZi5jdXJyZW50KSB7XG4gICAgICBtYXBib3hSZWYuY3VycmVudC5zZXRQcm9wcyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwgc2l6ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBtYXAgPSBtYXBib3hSZWYuY3VycmVudCAmJiBtYXBib3hSZWYuY3VycmVudC5nZXRNYXAoKTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0UmVmSGFuZGxlcyhtYXBib3hSZWYpO1xuICB9LCBbXSk7XG4gIHZhciBwcmV2ZW50U2Nyb2xsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHRhcmdldCA9IF9yZWYyLnRhcmdldDtcbiAgICBpZiAodGFyZ2V0ID09PSBvdmVybGF5UmVmLmN1cnJlbnQpIHtcbiAgICAgIHRhcmdldC5zY3JvbGxUbygwLCAwKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgdmFyIG92ZXJsYXlzID0gbWFwICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFwQ29udGV4dFByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY29udGV4dCksIHt9LCB7XG4gICAgICB2aWV3cG9ydDogY29udGV4dC52aWV3cG9ydCB8fCBnZXRWaWV3cG9ydChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgbWFwOiBtYXAsXG4gICAgICAgIHByb3BzOiBwcm9wc1xuICAgICAgfSwgc2l6ZSkpLFxuICAgICAgbWFwOiBtYXAsXG4gICAgICBjb250YWluZXI6IGNvbnRleHQuY29udGFpbmVyIHx8IGNvbnRhaW5lclJlZi5jdXJyZW50XG4gICAgfSlcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAga2V5OiBcIm1hcC1vdmVybGF5c1wiLFxuICAgIGNsYXNzTmFtZTogXCJvdmVybGF5c1wiLFxuICAgIHJlZjogb3ZlcmxheVJlZixcbiAgICBzdHlsZTogQ09OVEFJTkVSX1NUWUxFLFxuICAgIG9uU2Nyb2xsOiBwcmV2ZW50U2Nyb2xsXG4gIH0sIHByb3BzLmNoaWxkcmVuKSk7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgd2lkdGggPSBwcm9wcy53aWR0aCxcbiAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQsXG4gICAgc3R5bGUgPSBwcm9wcy5zdHlsZSxcbiAgICB2aXNpYmlsaXR5Q29uc3RyYWludHMgPSBwcm9wcy52aXNpYmlsaXR5Q29uc3RyYWludHM7XG4gIHZhciBtYXBDb250YWluZXJTdHlsZSA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gIH0sIHN0eWxlLCB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH0pO1xuICB2YXIgdmlzaWJsZSA9IHByb3BzLnZpc2libGUgJiYgY2hlY2tWaXNpYmlsaXR5Q29uc3RyYWludHMocHJvcHMudmlld1N0YXRlIHx8IHByb3BzLCB2aXNpYmlsaXR5Q29uc3RyYWludHMpO1xuICB2YXIgbWFwU3R5bGUgPSBPYmplY3QuYXNzaWduKHt9LCBDT05UQUlORVJfU1RZTEUsIHtcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlID8gJ2luaGVyaXQnIDogJ2hpZGRlbidcbiAgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IFwibWFwLWNvbnRhaW5lclwiLFxuICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgIHN0eWxlOiBtYXBDb250YWluZXJTdHlsZVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IFwibWFwLW1hcGJveFwiLFxuICAgIHJlZjogbWFwRGl2UmVmLFxuICAgIHN0eWxlOiBtYXBTdHlsZSxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICB9KSwgb3ZlcmxheXMsICFhY2Nlc3NUb2tlblZhbGlkICYmICFwcm9wcy5kaXNhYmxlVG9rZW5XYXJuaW5nICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTm9Ub2tlbldhcm5pbmcsIG51bGwpKTtcbn0pO1xuU3RhdGljTWFwLnN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG1hcGJveGdsICYmIG1hcGJveGdsLnN1cHBvcnRlZCgpO1xufTtcblN0YXRpY01hcC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBTdGF0aWNNYXA7IiwiaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0O1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChpdCkgbyA9IGl0O1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzOiBGLFxuICAgICAgICBuOiBmdW5jdGlvbiBuKCkge1xuICAgICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGU6IGZ1bmN0aW9uIGUoX2UpIHtcbiAgICAgICAgICB0aHJvdyBfZTtcbiAgICAgICAgfSxcbiAgICAgICAgZjogRlxuICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG4gIHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSxcbiAgICBkaWRFcnIgPSBmYWxzZSxcbiAgICBlcnI7XG4gIHJldHVybiB7XG4gICAgczogZnVuY3Rpb24gcygpIHtcbiAgICAgIGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfSxcbiAgICBuOiBmdW5jdGlvbiBuKCkge1xuICAgICAgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7XG4gICAgICBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lO1xuICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfSxcbiAgICBlOiBmdW5jdGlvbiBlKF9lMikge1xuICAgICAgZGlkRXJyID0gdHJ1ZTtcbiAgICAgIGVyciA9IF9lMjtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uIGYoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChkaWRFcnIpIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuICByZXR1cm4gYXJyMjtcbn1cbmltcG9ydCB7IGVxdWFscyB9IGZyb20gJy4uL21hdGgtdXRpbHMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi9hc3NlcnQnO1xudmFyIFRyYW5zaXRpb25JbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRyYW5zaXRpb25JbnRlcnBvbGF0b3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zaXRpb25JbnRlcnBvbGF0b3IpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb3BOYW1lc1wiLCBbXSk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFRyYW5zaXRpb25JbnRlcnBvbGF0b3IsIFt7XG4gICAga2V5OiBcImFyZVByb3BzRXF1YWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXJlUHJvcHNFcXVhbChjdXJyZW50UHJvcHMsIG5leHRQcm9wcykge1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMucHJvcE5hbWVzIHx8IFtdKSxcbiAgICAgICAgX3N0ZXA7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAoIWVxdWFscyhjdXJyZW50UHJvcHNba2V5XSwgbmV4dFByb3BzW2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbGl6ZVByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemVQcm9wcyhzdGFydFByb3BzLCBlbmRQcm9wcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0UHJvcHMsXG4gICAgICAgIGVuZDogZW5kUHJvcHNcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludGVycG9sYXRlUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJwb2xhdGVQcm9wcyhzdGFydFByb3BzLCBlbmRQcm9wcywgdCkge1xuICAgICAgYXNzZXJ0KGZhbHNlLCAnaW50ZXJwb2xhdGVQcm9wcyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RHVyYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RHVyYXRpb24oc3RhcnRQcm9wcywgZW5kUHJvcHMpIHtcbiAgICAgIHJldHVybiBlbmRQcm9wcy50cmFuc2l0aW9uRHVyYXRpb247XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUcmFuc2l0aW9uSW50ZXJwb2xhdG9yO1xufSgpO1xuZXhwb3J0IHsgVHJhbnNpdGlvbkludGVycG9sYXRvciBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChlKSB7XG4gIGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgcmV0dXJuIGU7XG59XG5leHBvcnQgeyBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgc2V0UHJvdG90eXBlT2YgZnJvbSBcIi4vc2V0UHJvdG90eXBlT2YuanNcIjtcbmZ1bmN0aW9uIF9pbmhlcml0cyh0LCBlKSB7XG4gIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogdCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICB9XG4gIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiAhMVxuICB9KSwgZSAmJiBzZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cbmV4cG9ydCB7IF9pbmhlcml0cyBhcyBkZWZhdWx0IH07IiwiaW1wb3J0IF90eXBlb2YgZnJvbSBcIi4vdHlwZW9mLmpzXCI7XG5pbXBvcnQgYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qc1wiO1xuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgZSkge1xuICBpZiAoZSAmJiAoXCJvYmplY3RcIiA9PSBfdHlwZW9mKGUpIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSkpIHJldHVybiBlO1xuICBpZiAodm9pZCAwICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQodCk7XG59XG5leHBvcnQgeyBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKHQpIHtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7XG4gIH0sIF9nZXRQcm90b3R5cGVPZih0KTtcbn1cbmV4cG9ydCB7IF9nZXRQcm90b3R5cGVPZiBhcyBkZWZhdWx0IH07IiwidmFyIFdSQVBQRURfQU5HVUxBUl9QUk9QUyA9IHtcbiAgbG9uZ2l0dWRlOiAxLFxuICBiZWFyaW5nOiAxXG59O1xuZXhwb3J0IGZ1bmN0aW9uIG1vZCh2YWx1ZSwgZGl2aXNvcikge1xuICB2YXIgbW9kdWx1cyA9IHZhbHVlICUgZGl2aXNvcjtcbiAgcmV0dXJuIG1vZHVsdXMgPCAwID8gZGl2aXNvciArIG1vZHVsdXMgOiBtb2R1bHVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWQocHJvcCkge1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHByb3ApIHx8IEFycmF5LmlzQXJyYXkocHJvcCk7XG59XG5mdW5jdGlvbiBpc1dyYXBwZWRBbmd1bGFyUHJvcChwcm9wTmFtZSkge1xuICByZXR1cm4gcHJvcE5hbWUgaW4gV1JBUFBFRF9BTkdVTEFSX1BST1BTO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEVuZFZhbHVlQnlTaG9ydGVzdFBhdGgocHJvcE5hbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlKSB7XG4gIGlmIChpc1dyYXBwZWRBbmd1bGFyUHJvcChwcm9wTmFtZSkgJiYgTWF0aC5hYnMoZW5kVmFsdWUgLSBzdGFydFZhbHVlKSA+IDE4MCkge1xuICAgIGVuZFZhbHVlID0gZW5kVmFsdWUgPCAwID8gZW5kVmFsdWUgKyAzNjAgOiBlbmRWYWx1ZSAtIDM2MDtcbiAgfVxuICByZXR1cm4gZW5kVmFsdWU7XG59IiwiaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2Fzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCI7XG5pbXBvcnQgX2luaGVyaXRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c1wiO1xuaW1wb3J0IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI7XG5pbXBvcnQgX2dldFByb3RvdHlwZU9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZlwiO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gIHZhciBpdDtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gRigpIHt9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgczogRixcbiAgICAgICAgbjogZnVuY3Rpb24gbigpIHtcbiAgICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlOiBmdW5jdGlvbiBlKF9lKSB7XG4gICAgICAgICAgdGhyb3cgX2U7XG4gICAgICAgIH0sXG4gICAgICAgIGY6IEZcbiAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuICB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsXG4gICAgZGlkRXJyID0gZmFsc2UsXG4gICAgZXJyO1xuICByZXR1cm4ge1xuICAgIHM6IGZ1bmN0aW9uIHMoKSB7XG4gICAgICBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH0sXG4gICAgbjogZnVuY3Rpb24gbigpIHtcbiAgICAgIHZhciBzdGVwID0gaXQubmV4dCgpO1xuICAgICAgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTtcbiAgICAgIHJldHVybiBzdGVwO1xuICAgIH0sXG4gICAgZTogZnVuY3Rpb24gZShfZTIpIHtcbiAgICAgIGRpZEVyciA9IHRydWU7XG4gICAgICBlcnIgPSBfZTI7XG4gICAgfSxcbiAgICBmOiBmdW5jdGlvbiBmKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgIHJlc3VsdDtcbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmltcG9ydCBhc3NlcnQgZnJvbSAnLi4vYXNzZXJ0JztcbmltcG9ydCBUcmFuc2l0aW9uSW50ZXJwb2xhdG9yIGZyb20gJy4vdHJhbnNpdGlvbi1pbnRlcnBvbGF0b3InO1xuaW1wb3J0IHsgZmx5VG9WaWV3cG9ydCwgZ2V0Rmx5VG9EdXJhdGlvbiB9IGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QnO1xuaW1wb3J0IHsgaXNWYWxpZCwgZ2V0RW5kVmFsdWVCeVNob3J0ZXN0UGF0aCB9IGZyb20gJy4vdHJhbnNpdGlvbi11dGlscyc7XG5pbXBvcnQgeyBsZXJwIH0gZnJvbSAnLi4vbWF0aC11dGlscyc7XG52YXIgVklFV1BPUlRfVFJBTlNJVElPTl9QUk9QUyA9IFsnbG9uZ2l0dWRlJywgJ2xhdGl0dWRlJywgJ3pvb20nLCAnYmVhcmluZycsICdwaXRjaCddO1xudmFyIFJFUVVJUkVEX1BST1BTID0gWydsYXRpdHVkZScsICdsb25naXR1ZGUnLCAnem9vbScsICd3aWR0aCcsICdoZWlnaHQnXTtcbnZhciBMSU5FQVJMWV9JTlRFUlBPTEFURURfUFJPUFMgPSBbJ2JlYXJpbmcnLCAncGl0Y2gnXTtcbnZhciBERUZBVUxUX09QVFMgPSB7XG4gIHNwZWVkOiAxLjIsXG4gIGN1cnZlOiAxLjQxNFxufTtcbnZhciBWaWV3cG9ydEZseVRvSW50ZXJwb2xhdG9yID0gZnVuY3Rpb24gKF9UcmFuc2l0aW9uSW50ZXJwb2xhdCkge1xuICBfaW5oZXJpdHMoVmlld3BvcnRGbHlUb0ludGVycG9sYXRvciwgX1RyYW5zaXRpb25JbnRlcnBvbGF0KTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihWaWV3cG9ydEZseVRvSW50ZXJwb2xhdG9yKTtcbiAgZnVuY3Rpb24gVmlld3BvcnRGbHlUb0ludGVycG9sYXRvcigpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlld3BvcnRGbHlUb0ludGVycG9sYXRvcik7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwicHJvcE5hbWVzXCIsIFZJRVdQT1JUX1RSQU5TSVRJT05fUFJPUFMpO1xuICAgIF90aGlzLnByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRTLCBwcm9wcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhWaWV3cG9ydEZseVRvSW50ZXJwb2xhdG9yLCBbe1xuICAgIGtleTogXCJpbml0aWFsaXplUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZVByb3BzKHN0YXJ0UHJvcHMsIGVuZFByb3BzKSB7XG4gICAgICB2YXIgc3RhcnRWaWV3cG9ydFByb3BzID0ge307XG4gICAgICB2YXIgZW5kVmlld3BvcnRQcm9wcyA9IHt9O1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKFJFUVVJUkVEX1BST1BTKSxcbiAgICAgICAgX3N0ZXA7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgc3RhcnRWYWx1ZSA9IHN0YXJ0UHJvcHNba2V5XTtcbiAgICAgICAgICB2YXIgZW5kVmFsdWUgPSBlbmRQcm9wc1trZXldO1xuICAgICAgICAgIGFzc2VydChpc1ZhbGlkKHN0YXJ0VmFsdWUpICYmIGlzVmFsaWQoZW5kVmFsdWUpLCBcIlwiLmNvbmNhdChrZXksIFwiIG11c3QgYmUgc3VwcGxpZWQgZm9yIHRyYW5zaXRpb25cIikpO1xuICAgICAgICAgIHN0YXJ0Vmlld3BvcnRQcm9wc1trZXldID0gc3RhcnRWYWx1ZTtcbiAgICAgICAgICBlbmRWaWV3cG9ydFByb3BzW2tleV0gPSBnZXRFbmRWYWx1ZUJ5U2hvcnRlc3RQYXRoKGtleSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKExJTkVBUkxZX0lOVEVSUE9MQVRFRF9QUk9QUyksXG4gICAgICAgIF9zdGVwMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9rZXkgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgdmFyIF9zdGFydFZhbHVlID0gc3RhcnRQcm9wc1tfa2V5XSB8fCAwO1xuICAgICAgICAgIHZhciBfZW5kVmFsdWUgPSBlbmRQcm9wc1tfa2V5XSB8fCAwO1xuICAgICAgICAgIHN0YXJ0Vmlld3BvcnRQcm9wc1tfa2V5XSA9IF9zdGFydFZhbHVlO1xuICAgICAgICAgIGVuZFZpZXdwb3J0UHJvcHNbX2tleV0gPSBnZXRFbmRWYWx1ZUJ5U2hvcnRlc3RQYXRoKF9rZXksIF9zdGFydFZhbHVlLCBfZW5kVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBzdGFydFZpZXdwb3J0UHJvcHMsXG4gICAgICAgIGVuZDogZW5kVmlld3BvcnRQcm9wc1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJwb2xhdGVQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnBvbGF0ZVByb3BzKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCB0KSB7XG4gICAgICB2YXIgdmlld3BvcnQgPSBmbHlUb1ZpZXdwb3J0KHN0YXJ0UHJvcHMsIGVuZFByb3BzLCB0LCB0aGlzLnByb3BzKTtcbiAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoTElORUFSTFlfSU5URVJQT0xBVEVEX1BST1BTKSxcbiAgICAgICAgX3N0ZXAzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIga2V5ID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICAgIHZpZXdwb3J0W2tleV0gPSBsZXJwKHN0YXJ0UHJvcHNba2V5XSwgZW5kUHJvcHNba2V5XSwgdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZpZXdwb3J0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREdXJhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREdXJhdGlvbihzdGFydFByb3BzLCBlbmRQcm9wcykge1xuICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IGVuZFByb3BzLnRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICAgIGlmICh0cmFuc2l0aW9uRHVyYXRpb24gPT09ICdhdXRvJykge1xuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSBnZXRGbHlUb0R1cmF0aW9uKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCB0aGlzLnByb3BzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2l0aW9uRHVyYXRpb247XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBWaWV3cG9ydEZseVRvSW50ZXJwb2xhdG9yO1xufShUcmFuc2l0aW9uSW50ZXJwb2xhdG9yKTtcbmV4cG9ydCB7IFZpZXdwb3J0Rmx5VG9JbnRlcnBvbGF0b3IgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2luaGVyaXRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c1wiO1xuaW1wb3J0IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI7XG5pbXBvcnQgX2dldFByb3RvdHlwZU9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZlwiO1xuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0O1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChpdCkgbyA9IGl0O1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzOiBGLFxuICAgICAgICBuOiBmdW5jdGlvbiBuKCkge1xuICAgICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGU6IGZ1bmN0aW9uIGUoX2UpIHtcbiAgICAgICAgICB0aHJvdyBfZTtcbiAgICAgICAgfSxcbiAgICAgICAgZjogRlxuICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG4gIHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSxcbiAgICBkaWRFcnIgPSBmYWxzZSxcbiAgICBlcnI7XG4gIHJldHVybiB7XG4gICAgczogZnVuY3Rpb24gcygpIHtcbiAgICAgIGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfSxcbiAgICBuOiBmdW5jdGlvbiBuKCkge1xuICAgICAgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7XG4gICAgICBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lO1xuICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfSxcbiAgICBlOiBmdW5jdGlvbiBlKF9lMikge1xuICAgICAgZGlkRXJyID0gdHJ1ZTtcbiAgICAgIGVyciA9IF9lMjtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uIGYoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChkaWRFcnIpIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuICByZXR1cm4gYXJyMjtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgcmVzdWx0O1xuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuaW1wb3J0IFdlYk1lcmNhdG9yVmlld3BvcnQgZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uL2Fzc2VydCc7XG5pbXBvcnQgVHJhbnNpdGlvbkludGVycG9sYXRvciBmcm9tICcuL3RyYW5zaXRpb24taW50ZXJwb2xhdG9yJztcbmltcG9ydCB7IGlzVmFsaWQsIGdldEVuZFZhbHVlQnlTaG9ydGVzdFBhdGggfSBmcm9tICcuL3RyYW5zaXRpb24tdXRpbHMnO1xuaW1wb3J0IHsgbGVycCB9IGZyb20gJy4uL21hdGgtdXRpbHMnO1xudmFyIFZJRVdQT1JUX1RSQU5TSVRJT05fUFJPUFMgPSBbJ2xvbmdpdHVkZScsICdsYXRpdHVkZScsICd6b29tJywgJ2JlYXJpbmcnLCAncGl0Y2gnXTtcbnZhciBMaW5lYXJJbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiAoX1RyYW5zaXRpb25JbnRlcnBvbGF0KSB7XG4gIF9pbmhlcml0cyhMaW5lYXJJbnRlcnBvbGF0b3IsIF9UcmFuc2l0aW9uSW50ZXJwb2xhdCk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTGluZWFySW50ZXJwb2xhdG9yKTtcbiAgZnVuY3Rpb24gTGluZWFySW50ZXJwb2xhdG9yKCkge1xuICAgIHZhciBfdGhpcztcbiAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmVhckludGVycG9sYXRvcik7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgb3B0cyA9IHtcbiAgICAgICAgdHJhbnNpdGlvblByb3BzOiBvcHRzXG4gICAgICB9O1xuICAgIH1cbiAgICBfdGhpcy5wcm9wTmFtZXMgPSBvcHRzLnRyYW5zaXRpb25Qcm9wcyB8fCBWSUVXUE9SVF9UUkFOU0lUSU9OX1BST1BTO1xuICAgIGlmIChvcHRzLmFyb3VuZCkge1xuICAgICAgX3RoaXMuYXJvdW5kID0gb3B0cy5hcm91bmQ7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfY3JlYXRlQ2xhc3MoTGluZWFySW50ZXJwb2xhdG9yLCBbe1xuICAgIGtleTogXCJpbml0aWFsaXplUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZVByb3BzKHN0YXJ0UHJvcHMsIGVuZFByb3BzKSB7XG4gICAgICB2YXIgc3RhcnRWaWV3cG9ydFByb3BzID0ge307XG4gICAgICB2YXIgZW5kVmlld3BvcnRQcm9wcyA9IHt9O1xuICAgICAgaWYgKHRoaXMuYXJvdW5kKSB7XG4gICAgICAgIHN0YXJ0Vmlld3BvcnRQcm9wcy5hcm91bmQgPSB0aGlzLmFyb3VuZDtcbiAgICAgICAgdmFyIGFyb3VuZExuZ0xhdCA9IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHN0YXJ0UHJvcHMpLnVucHJvamVjdCh0aGlzLmFyb3VuZCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZW5kVmlld3BvcnRQcm9wcywgZW5kUHJvcHMsIHtcbiAgICAgICAgICBhcm91bmQ6IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KGVuZFByb3BzKS5wcm9qZWN0KGFyb3VuZExuZ0xhdCksXG4gICAgICAgICAgYXJvdW5kTG5nTGF0OiBhcm91bmRMbmdMYXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5wcm9wTmFtZXMpLFxuICAgICAgICBfc3RlcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBzdGFydFZhbHVlID0gc3RhcnRQcm9wc1trZXldO1xuICAgICAgICAgIHZhciBlbmRWYWx1ZSA9IGVuZFByb3BzW2tleV07XG4gICAgICAgICAgYXNzZXJ0KGlzVmFsaWQoc3RhcnRWYWx1ZSkgJiYgaXNWYWxpZChlbmRWYWx1ZSksIFwiXCIuY29uY2F0KGtleSwgXCIgbXVzdCBiZSBzdXBwbGllZCBmb3IgdHJhbnNpdGlvblwiKSk7XG4gICAgICAgICAgc3RhcnRWaWV3cG9ydFByb3BzW2tleV0gPSBzdGFydFZhbHVlO1xuICAgICAgICAgIGVuZFZpZXdwb3J0UHJvcHNba2V5XSA9IGdldEVuZFZhbHVlQnlTaG9ydGVzdFBhdGgoa2V5LCBzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBzdGFydFZpZXdwb3J0UHJvcHMsXG4gICAgICAgIGVuZDogZW5kVmlld3BvcnRQcm9wc1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJwb2xhdGVQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnBvbGF0ZVByb3BzKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCB0KSB7XG4gICAgICB2YXIgdmlld3BvcnQgPSB7fTtcbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5wcm9wTmFtZXMpLFxuICAgICAgICBfc3RlcDI7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgdmlld3BvcnRba2V5XSA9IGxlcnAoc3RhcnRQcm9wc1trZXldLCBlbmRQcm9wc1trZXldLCB0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG4gICAgICBpZiAoZW5kUHJvcHMuYXJvdW5kKSB7XG4gICAgICAgIHZhciBfV2ViTWVyY2F0b3JWaWV3cG9ydCQgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydChPYmplY3QuYXNzaWduKHt9LCBlbmRQcm9wcywgdmlld3BvcnQpKS5nZXRNYXBDZW50ZXJCeUxuZ0xhdFBvc2l0aW9uKHtcbiAgICAgICAgICAgIGxuZ0xhdDogZW5kUHJvcHMuYXJvdW5kTG5nTGF0LFxuICAgICAgICAgICAgcG9zOiBsZXJwKHN0YXJ0UHJvcHMuYXJvdW5kLCBlbmRQcm9wcy5hcm91bmQsIHQpXG4gICAgICAgICAgfSksXG4gICAgICAgICAgX1dlYk1lcmNhdG9yVmlld3BvcnQkMiA9IF9zbGljZWRUb0FycmF5KF9XZWJNZXJjYXRvclZpZXdwb3J0JCwgMiksXG4gICAgICAgICAgbG9uZ2l0dWRlID0gX1dlYk1lcmNhdG9yVmlld3BvcnQkMlswXSxcbiAgICAgICAgICBsYXRpdHVkZSA9IF9XZWJNZXJjYXRvclZpZXdwb3J0JDJbMV07XG4gICAgICAgIHZpZXdwb3J0LmxvbmdpdHVkZSA9IGxvbmdpdHVkZTtcbiAgICAgICAgdmlld3BvcnQubGF0aXR1ZGUgPSBsYXRpdHVkZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2aWV3cG9ydDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIExpbmVhckludGVycG9sYXRvcjtcbn0oVHJhbnNpdGlvbkludGVycG9sYXRvcik7XG5leHBvcnQgeyBMaW5lYXJJbnRlcnBvbGF0b3IgYXMgZGVmYXVsdCB9OyIsImV4cG9ydCB7IGRlZmF1bHQgYXMgVHJhbnNpdGlvbkludGVycG9sYXRvciB9IGZyb20gJy4vdHJhbnNpdGlvbi1pbnRlcnBvbGF0b3InO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBWaWV3cG9ydEZseVRvSW50ZXJwb2xhdG9yIH0gZnJvbSAnLi92aWV3cG9ydC1mbHktdG8taW50ZXJwb2xhdG9yJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGluZWFySW50ZXJwb2xhdG9yIH0gZnJvbSAnLi9saW5lYXItaW50ZXJwb2xhdG9yJzsiLCJpbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4vYXNzZXJ0JztcbmltcG9ydCB7IExpbmVhckludGVycG9sYXRvciB9IGZyb20gJy4vdHJhbnNpdGlvbic7XG5pbXBvcnQgTWFwU3RhdGUgZnJvbSAnLi9tYXAtc3RhdGUnO1xudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5leHBvcnQgZnVuY3Rpb24gY3JvcEVhc2luZ0Z1bmN0aW9uKGVhc2luZywgeDApIHtcbiAgdmFyIHkwID0gZWFzaW5nKHgwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIDEgLyAoMSAtIHkwKSAqIChlYXNpbmcodCAqICgxIC0geDApICsgeDApIC0geTApO1xuICB9O1xufVxuZXhwb3J0IHZhciBUUkFOU0lUSU9OX0VWRU5UUyA9IHtcbiAgQlJFQUs6IDEsXG4gIFNOQVBfVE9fRU5EOiAyLFxuICBJR05PUkU6IDMsXG4gIFVQREFURTogNFxufTtcbnZhciBERUZBVUxUX1BST1BTID0ge1xuICB0cmFuc2l0aW9uRHVyYXRpb246IDAsXG4gIHRyYW5zaXRpb25FYXNpbmc6IGZ1bmN0aW9uIHRyYW5zaXRpb25FYXNpbmcodCkge1xuICAgIHJldHVybiB0O1xuICB9LFxuICB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yOiBuZXcgTGluZWFySW50ZXJwb2xhdG9yKCksXG4gIHRyYW5zaXRpb25JbnRlcnJ1cHRpb246IFRSQU5TSVRJT05fRVZFTlRTLkJSRUFLLFxuICBvblRyYW5zaXRpb25TdGFydDogbm9vcCxcbiAgb25UcmFuc2l0aW9uSW50ZXJydXB0OiBub29wLFxuICBvblRyYW5zaXRpb25FbmQ6IG5vb3Bcbn07XG52YXIgVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRyYW5zaXRpb25NYW5hZ2VyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2l0aW9uTWFuYWdlcik7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2FuaW1hdGlvbkZyYW1lXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9vblRyYW5zaXRpb25GcmFtZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5fYW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMuX29uVHJhbnNpdGlvbkZyYW1lKTtcbiAgICAgIF90aGlzLl91cGRhdGVWaWV3cG9ydCgpO1xuICAgIH0pO1xuICAgIHRoaXMucHJvcHMgPSBudWxsO1xuICAgIHRoaXMub25WaWV3cG9ydENoYW5nZSA9IG9wdHMub25WaWV3cG9ydENoYW5nZSB8fCBub29wO1xuICAgIHRoaXMub25TdGF0ZUNoYW5nZSA9IG9wdHMub25TdGF0ZUNoYW5nZSB8fCBub29wO1xuICAgIHRoaXMudGltZSA9IG9wdHMuZ2V0VGltZSB8fCBEYXRlLm5vdztcbiAgfVxuICBfY3JlYXRlQ2xhc3MoVHJhbnNpdGlvbk1hbmFnZXIsIFt7XG4gICAga2V5OiBcImdldFZpZXdwb3J0SW5UcmFuc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpZXdwb3J0SW5UcmFuc2l0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGlvbkZyYW1lID8gdGhpcy5zdGF0ZS5wcm9wc0luVHJhbnNpdGlvbiA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NWaWV3cG9ydENoYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmlld3BvcnRDaGFuZ2UobmV4dFByb3BzKSB7XG4gICAgICB2YXIgY3VycmVudFByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHRoaXMucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICBpZiAoIWN1cnJlbnRQcm9wcyB8fCB0aGlzLl9zaG91bGRJZ25vcmVWaWV3cG9ydENoYW5nZShjdXJyZW50UHJvcHMsIG5leHRQcm9wcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbkVuYWJsZWQobmV4dFByb3BzKSkge1xuICAgICAgICB2YXIgc3RhcnRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnRQcm9wcyk7XG4gICAgICAgIHZhciBlbmRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG5leHRQcm9wcyk7XG4gICAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25JblByb2dyZXNzKCkpIHtcbiAgICAgICAgICBjdXJyZW50UHJvcHMub25UcmFuc2l0aW9uSW50ZXJydXB0KCk7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUuaW50ZXJydXB0aW9uID09PSBUUkFOU0lUSU9OX0VWRU5UUy5TTkFQX1RPX0VORCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdGFydFByb3BzLCB0aGlzLnN0YXRlLmVuZFByb3BzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdGFydFByb3BzLCB0aGlzLnN0YXRlLnByb3BzSW5UcmFuc2l0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUuaW50ZXJydXB0aW9uID09PSBUUkFOU0lUSU9OX0VWRU5UUy5VUERBVEUpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMudGltZSgpO1xuICAgICAgICAgICAgdmFyIHgwID0gKGN1cnJlbnRUaW1lIC0gdGhpcy5zdGF0ZS5zdGFydFRpbWUpIC8gdGhpcy5zdGF0ZS5kdXJhdGlvbjtcbiAgICAgICAgICAgIGVuZFByb3BzLnRyYW5zaXRpb25EdXJhdGlvbiA9IHRoaXMuc3RhdGUuZHVyYXRpb24gLSAoY3VycmVudFRpbWUgLSB0aGlzLnN0YXRlLnN0YXJ0VGltZSk7XG4gICAgICAgICAgICBlbmRQcm9wcy50cmFuc2l0aW9uRWFzaW5nID0gY3JvcEVhc2luZ0Z1bmN0aW9uKHRoaXMuc3RhdGUuZWFzaW5nLCB4MCk7XG4gICAgICAgICAgICBlbmRQcm9wcy50cmFuc2l0aW9uSW50ZXJwb2xhdG9yID0gc3RhcnRQcm9wcy50cmFuc2l0aW9uSW50ZXJwb2xhdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbmRQcm9wcy5vblRyYW5zaXRpb25TdGFydCgpO1xuICAgICAgICB0aGlzLl90cmlnZ2VyVHJhbnNpdGlvbihzdGFydFByb3BzLCBlbmRQcm9wcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbkluUHJvZ3Jlc3MoKSkge1xuICAgICAgICBjdXJyZW50UHJvcHMub25UcmFuc2l0aW9uSW50ZXJydXB0KCk7XG4gICAgICAgIHRoaXMuX2VuZFRyYW5zaXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzVHJhbnNpdGlvbkluUHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzVHJhbnNpdGlvbkluUHJvZ3Jlc3MoKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9hbmltYXRpb25GcmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pc1RyYW5zaXRpb25FbmFibGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1RyYW5zaXRpb25FbmFibGVkKHByb3BzKSB7XG4gICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gcHJvcHMudHJhbnNpdGlvbkR1cmF0aW9uLFxuICAgICAgICB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yID0gcHJvcHMudHJhbnNpdGlvbkludGVycG9sYXRvcjtcbiAgICAgIHJldHVybiAodHJhbnNpdGlvbkR1cmF0aW9uID4gMCB8fCB0cmFuc2l0aW9uRHVyYXRpb24gPT09ICdhdXRvJykgJiYgQm9vbGVhbih0cmFuc2l0aW9uSW50ZXJwb2xhdG9yKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzVXBkYXRlRHVlVG9DdXJyZW50VHJhbnNpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNVcGRhdGVEdWVUb0N1cnJlbnRUcmFuc2l0aW9uKHByb3BzKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5wcm9wc0luVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pbnRlcnBvbGF0b3IuYXJlUHJvcHNFcXVhbChwcm9wcywgdGhpcy5zdGF0ZS5wcm9wc0luVHJhbnNpdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zaG91bGRJZ25vcmVWaWV3cG9ydENoYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvdWxkSWdub3JlVmlld3BvcnRDaGFuZ2UoY3VycmVudFByb3BzLCBuZXh0UHJvcHMpIHtcbiAgICAgIGlmICghY3VycmVudFByb3BzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbkluUHJvZ3Jlc3MoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pbnRlcnJ1cHRpb24gPT09IFRSQU5TSVRJT05fRVZFTlRTLklHTk9SRSB8fCB0aGlzLl9pc1VwZGF0ZUR1ZVRvQ3VycmVudFRyYW5zaXRpb24obmV4dFByb3BzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25FbmFibGVkKG5leHRQcm9wcykpIHtcbiAgICAgICAgcmV0dXJuIG5leHRQcm9wcy50cmFuc2l0aW9uSW50ZXJwb2xhdG9yLmFyZVByb3BzRXF1YWwoY3VycmVudFByb3BzLCBuZXh0UHJvcHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl90cmlnZ2VyVHJhbnNpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJpZ2dlclRyYW5zaXRpb24oc3RhcnRQcm9wcywgZW5kUHJvcHMpIHtcbiAgICAgIGFzc2VydCh0aGlzLl9pc1RyYW5zaXRpb25FbmFibGVkKGVuZFByb3BzKSk7XG4gICAgICBpZiAodGhpcy5fYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fYW5pbWF0aW9uRnJhbWUpO1xuICAgICAgfVxuICAgICAgdmFyIHRyYW5zaXRpb25JbnRlcnBvbGF0b3IgPSBlbmRQcm9wcy50cmFuc2l0aW9uSW50ZXJwb2xhdG9yO1xuICAgICAgdmFyIGR1cmF0aW9uID0gdHJhbnNpdGlvbkludGVycG9sYXRvci5nZXREdXJhdGlvbiA/IHRyYW5zaXRpb25JbnRlcnBvbGF0b3IuZ2V0RHVyYXRpb24oc3RhcnRQcm9wcywgZW5kUHJvcHMpIDogZW5kUHJvcHMudHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbml0aWFsUHJvcHMgPSBlbmRQcm9wcy50cmFuc2l0aW9uSW50ZXJwb2xhdG9yLmluaXRpYWxpemVQcm9wcyhzdGFydFByb3BzLCBlbmRQcm9wcyk7XG4gICAgICB2YXIgaW50ZXJhY3Rpb25TdGF0ZSA9IHtcbiAgICAgICAgaW5UcmFuc2l0aW9uOiB0cnVlLFxuICAgICAgICBpc1pvb21pbmc6IHN0YXJ0UHJvcHMuem9vbSAhPT0gZW5kUHJvcHMuem9vbSxcbiAgICAgICAgaXNQYW5uaW5nOiBzdGFydFByb3BzLmxvbmdpdHVkZSAhPT0gZW5kUHJvcHMubG9uZ2l0dWRlIHx8IHN0YXJ0UHJvcHMubGF0aXR1ZGUgIT09IGVuZFByb3BzLmxhdGl0dWRlLFxuICAgICAgICBpc1JvdGF0aW5nOiBzdGFydFByb3BzLmJlYXJpbmcgIT09IGVuZFByb3BzLmJlYXJpbmcgfHwgc3RhcnRQcm9wcy5waXRjaCAhPT0gZW5kUHJvcHMucGl0Y2hcbiAgICAgIH07XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIGVhc2luZzogZW5kUHJvcHMudHJhbnNpdGlvbkVhc2luZyxcbiAgICAgICAgaW50ZXJwb2xhdG9yOiBlbmRQcm9wcy50cmFuc2l0aW9uSW50ZXJwb2xhdG9yLFxuICAgICAgICBpbnRlcnJ1cHRpb246IGVuZFByb3BzLnRyYW5zaXRpb25JbnRlcnJ1cHRpb24sXG4gICAgICAgIHN0YXJ0VGltZTogdGhpcy50aW1lKCksXG4gICAgICAgIHN0YXJ0UHJvcHM6IGluaXRpYWxQcm9wcy5zdGFydCxcbiAgICAgICAgZW5kUHJvcHM6IGluaXRpYWxQcm9wcy5lbmQsXG4gICAgICAgIGFuaW1hdGlvbjogbnVsbCxcbiAgICAgICAgcHJvcHNJblRyYW5zaXRpb246IHt9XG4gICAgICB9O1xuICAgICAgdGhpcy5fb25UcmFuc2l0aW9uRnJhbWUoKTtcbiAgICAgIHRoaXMub25TdGF0ZUNoYW5nZShpbnRlcmFjdGlvblN0YXRlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2VuZFRyYW5zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VuZFRyYW5zaXRpb24oKSB7XG4gICAgICBpZiAodGhpcy5fYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fYW5pbWF0aW9uRnJhbWUpO1xuICAgICAgICB0aGlzLl9hbmltYXRpb25GcmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLm9uU3RhdGVDaGFuZ2Uoe1xuICAgICAgICBpblRyYW5zaXRpb246IGZhbHNlLFxuICAgICAgICBpc1pvb21pbmc6IGZhbHNlLFxuICAgICAgICBpc1Bhbm5pbmc6IGZhbHNlLFxuICAgICAgICBpc1JvdGF0aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVWaWV3cG9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlVmlld3BvcnQoKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLnRpbWUoKTtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZSA9IHRoaXMuc3RhdGUsXG4gICAgICAgIHN0YXJ0VGltZSA9IF90aGlzJHN0YXRlLnN0YXJ0VGltZSxcbiAgICAgICAgZHVyYXRpb24gPSBfdGhpcyRzdGF0ZS5kdXJhdGlvbixcbiAgICAgICAgZWFzaW5nID0gX3RoaXMkc3RhdGUuZWFzaW5nLFxuICAgICAgICBpbnRlcnBvbGF0b3IgPSBfdGhpcyRzdGF0ZS5pbnRlcnBvbGF0b3IsXG4gICAgICAgIHN0YXJ0UHJvcHMgPSBfdGhpcyRzdGF0ZS5zdGFydFByb3BzLFxuICAgICAgICBlbmRQcm9wcyA9IF90aGlzJHN0YXRlLmVuZFByb3BzO1xuICAgICAgdmFyIHNob3VsZEVuZCA9IGZhbHNlO1xuICAgICAgdmFyIHQgPSAoY3VycmVudFRpbWUgLSBzdGFydFRpbWUpIC8gZHVyYXRpb247XG4gICAgICBpZiAodCA+PSAxKSB7XG4gICAgICAgIHQgPSAxO1xuICAgICAgICBzaG91bGRFbmQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdCA9IGVhc2luZyh0KTtcbiAgICAgIHZhciB2aWV3cG9ydCA9IGludGVycG9sYXRvci5pbnRlcnBvbGF0ZVByb3BzKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCB0KTtcbiAgICAgIHZhciBtYXBTdGF0ZSA9IG5ldyBNYXBTdGF0ZShPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB2aWV3cG9ydCkpO1xuICAgICAgdGhpcy5zdGF0ZS5wcm9wc0luVHJhbnNpdGlvbiA9IG1hcFN0YXRlLmdldFZpZXdwb3J0UHJvcHMoKTtcbiAgICAgIHRoaXMub25WaWV3cG9ydENoYW5nZSh0aGlzLnN0YXRlLnByb3BzSW5UcmFuc2l0aW9uLCB0aGlzLnByb3BzKTtcbiAgICAgIGlmIChzaG91bGRFbmQpIHtcbiAgICAgICAgdGhpcy5fZW5kVHJhbnNpdGlvbigpO1xuICAgICAgICB0aGlzLnByb3BzLm9uVHJhbnNpdGlvbkVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVHJhbnNpdGlvbk1hbmFnZXI7XG59KCk7XG5fZGVmaW5lUHJvcGVydHkoVHJhbnNpdGlvbk1hbmFnZXIsIFwiZGVmYXVsdFByb3BzXCIsIERFRkFVTFRfUFJPUFMpO1xuZXhwb3J0IHsgVHJhbnNpdGlvbk1hbmFnZXIgYXMgZGVmYXVsdCB9OyIsIi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIG92ZXJyaWRlcyB0aGUgZGVmYXVsdFxuICogaGFtbWVyLmpzIGZ1bmN0aW9ucyB0byBhZGQgb3VyIG93biB1dGlsaXR5XG4gKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKiBIYW1tZXIuanMgY29uc3RhbnRzICovXG5jb25zdCBJTlBVVF9TVEFSVCA9IDE7XG5jb25zdCBJTlBVVF9NT1ZFID0gMjtcbmNvbnN0IElOUFVUX0VORCA9IDQ7XG5jb25zdCBNT1VTRV9JTlBVVF9NQVAgPSB7XG4gIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcbiAgbW91c2V1cDogSU5QVVRfRU5EXG59O1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgYW55IGVsZW1lbnQgaW4gYW4gYXJyYXkgbWVldHMgZ2l2ZW4gY3JpdGVyaWEuXG4gKiBCZWNhdXNlIG9sZGVyIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGBBcnJheS5wcm90b3R5cGUuc29tZWBcbiAqIEBwYXJhbXMgYXJyYXkge0FycmF5fVxuICogQHBhcmFtcyBwcmVkaWN0IHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gc29tZShhcnJheSwgcHJlZGljdCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHByZWRpY3QoYXJyYXlbaV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5leHBvcnQgZnVuY3Rpb24gZW5oYW5jZVBvaW50ZXJFdmVudElucHV0KFBvaW50ZXJFdmVudElucHV0KSB7XG4gIGNvbnN0IG9sZEhhbmRsZXIgPSBQb2ludGVyRXZlbnRJbnB1dC5wcm90b3R5cGUuaGFuZGxlcjtcbiAgLy8gb3ZlcnJpZGVzIFBvaW50ZXJFdmVudElucHV0LmhhbmRsZXIgdG8gYWNjZXB0IHJpZ2h0IG1vdXNlIGJ1dHRvblxuICBQb2ludGVyRXZlbnRJbnB1dC5wcm90b3R5cGUuaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZXYpIHtcbiAgICBjb25zdCBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgLy8gQWxsb3cgbm9uLWxlZnQgbW91c2UgYnV0dG9ucyB0aHJvdWdoXG4gICAgaWYgKGV2LmJ1dHRvbiA+IDAgJiYgZXYudHlwZSA9PT0gJ3BvaW50ZXJkb3duJykge1xuICAgICAgaWYgKCFzb21lKHN0b3JlLCBlID0+IGUucG9pbnRlcklkID09PSBldi5wb2ludGVySWQpKSB7XG4gICAgICAgIHN0b3JlLnB1c2goZXYpO1xuICAgICAgfVxuICAgIH1cbiAgICBvbGRIYW5kbGVyLmNhbGwodGhpcywgZXYpO1xuICB9O1xufVxuLy8gb3ZlcnJpZGVzIE1vdXNlSW5wdXQuaGFuZGxlciB0byBhY2NlcHQgcmlnaHQgbW91c2UgYnV0dG9uXG5leHBvcnQgZnVuY3Rpb24gZW5oYW5jZU1vdXNlSW5wdXQoTW91c2VJbnB1dCkge1xuICBNb3VzZUlucHV0LnByb3RvdHlwZS5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgIGxldCBldmVudFR5cGUgPSBNT1VTRV9JTlBVVF9NQVBbZXYudHlwZV07XG4gICAgLy8gb24gc3RhcnQgd2Ugd2FudCB0byBoYXZlIHRoZSBtb3VzZSBidXR0b24gZG93blxuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBldi5idXR0b24gPj0gMCkge1xuICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYuYnV0dG9ucyA9PT0gMCkge1xuICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xuICAgIH1cbiAgICAvLyBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgcG9pbnRlcnM6IFtldl0sXG4gICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICBwb2ludGVyVHlwZTogJ21vdXNlJyxcbiAgICAgIHNyY0V2ZW50OiBldlxuICAgIH0pO1xuICB9O1xufSIsImltcG9ydCAqIGFzIGhhbW1lcmpzIGZyb20gJ2hhbW1lcmpzJztcbmltcG9ydCB7IGVuaGFuY2VQb2ludGVyRXZlbnRJbnB1dCwgZW5oYW5jZU1vdXNlSW5wdXQgfSBmcm9tICcuL2hhbW1lci1vdmVycmlkZXMnO1xuZW5oYW5jZVBvaW50ZXJFdmVudElucHV0KGhhbW1lcmpzLlBvaW50ZXJFdmVudElucHV0KTtcbmVuaGFuY2VNb3VzZUlucHV0KGhhbW1lcmpzLk1vdXNlSW5wdXQpO1xuZXhwb3J0IGNvbnN0IE1hbmFnZXIgPSBoYW1tZXJqcy5NYW5hZ2VyO1xuZXhwb3J0IGRlZmF1bHQgaGFtbWVyanM7IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGVuYWJsZTogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICB9XG59IiwiaW1wb3J0IEhhbW1lciBmcm9tICcuL3V0aWxzL2hhbW1lcic7XG4vLyBUaGlzIG1vZHVsZSBjb250YWlucyBjb25zdGFudHMgdGhhdCBtdXN0IGJlIGNvbmRpdGlvbmFsbHkgcmVxdWlyZWRcbi8vIGR1ZSB0byBgd2luZG93YC9gZG9jdW1lbnRgIHJlZmVyZW5jZXMgZG93bnN0cmVhbS5cbmV4cG9ydCBjb25zdCBSRUNPR05JWkVSUyA9IEhhbW1lciA/IFtbSGFtbWVyLlBhbiwge1xuICBldmVudDogJ3RyaXBhbicsXG4gIHBvaW50ZXJzOiAzLFxuICB0aHJlc2hvbGQ6IDAsXG4gIGVuYWJsZTogZmFsc2Vcbn1dLCBbSGFtbWVyLlJvdGF0ZSwge1xuICBlbmFibGU6IGZhbHNlXG59XSwgW0hhbW1lci5QaW5jaCwge1xuICBlbmFibGU6IGZhbHNlXG59XSwgW0hhbW1lci5Td2lwZSwge1xuICBlbmFibGU6IGZhbHNlXG59XSwgW0hhbW1lci5QYW4sIHtcbiAgdGhyZXNob2xkOiAwLFxuICBlbmFibGU6IGZhbHNlXG59XSwgW0hhbW1lci5QcmVzcywge1xuICBlbmFibGU6IGZhbHNlXG59XSwgW0hhbW1lci5UYXAsIHtcbiAgZXZlbnQ6ICdkb3VibGV0YXAnLFxuICB0YXBzOiAyLFxuICBlbmFibGU6IGZhbHNlXG59XSxcbi8vIFRPRE8gLSByZW5hbWUgdG8gJ3RhcCcgYW5kICdzaW5nbGV0YXAnIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2VcbltIYW1tZXIuVGFwLCB7XG4gIGV2ZW50OiAnYW55dGFwJyxcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtIYW1tZXIuVGFwLCB7XG4gIGVuYWJsZTogZmFsc2Vcbn1dXSA6IG51bGw7XG4vLyBSZWNvZ25pemUgdGhlIGZvbGxvd2luZyBnZXN0dXJlcyBldmVuIGlmIGEgZ2l2ZW4gcmVjb2duaXplciBzdWNjZWVkc1xuZXhwb3J0IGNvbnN0IFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVAgPSB7XG4gIHRyaXBhbjogWydyb3RhdGUnLCAncGluY2gnLCAncGFuJ10sXG4gIHJvdGF0ZTogWydwaW5jaCddLFxuICBwaW5jaDogWydwYW4nXSxcbiAgcGFuOiBbJ3ByZXNzJywgJ2RvdWJsZXRhcCcsICdhbnl0YXAnLCAndGFwJ10sXG4gIGRvdWJsZXRhcDogWydhbnl0YXAnXSxcbiAgYW55dGFwOiBbJ3RhcCddXG59O1xuLy8gUmVjb2duaXplIHRoZSBmb2xsaW5nIGdlc3R1cmVzIG9ubHkgaWYgYSBnaXZlbiByZWNvZ25pemVyIGZhaWxzXG5leHBvcnQgY29uc3QgUkVDT0dOSVpFUl9GQUxMQkFDS19NQVAgPSB7XG4gIGRvdWJsZXRhcDogWyd0YXAnXVxufTtcbi8qKlxuICogT25seSBvbmUgc2V0IG9mIGJhc2ljIGlucHV0IGV2ZW50cyB3aWxsIGJlIGZpcmVkIGJ5IEhhbW1lci5qczpcbiAqIGVpdGhlciBwb2ludGVyLCB0b3VjaCwgb3IgbW91c2UsIGRlcGVuZGluZyBvbiBzeXN0ZW0gc3VwcG9ydC5cbiAqIEluIG9yZGVyIHRvIGVuYWJsZSBhbiBhcHBsaWNhdGlvbiB0byBiZSBhZ25vc3RpYyBvZiBzeXN0ZW0gc3VwcG9ydCxcbiAqIGFsaWFzIGJhc2ljIGlucHV0IGV2ZW50cyBpbnRvIFwiY2xhc3Nlc1wiIG9mIGV2ZW50czogZG93biwgbW92ZSwgYW5kIHVwLlxuICogU2VlIGBfb25CYXNpY0lucHV0KClgIGZvciB1c2FnZSBvZiB0aGVzZSBhbGlhc2VzLlxuICovXG5leHBvcnQgY29uc3QgQkFTSUNfRVZFTlRfQUxJQVNFUyA9IHtcbiAgcG9pbnRlcmRvd246ICdwb2ludGVyZG93bicsXG4gIHBvaW50ZXJtb3ZlOiAncG9pbnRlcm1vdmUnLFxuICBwb2ludGVydXA6ICdwb2ludGVydXAnLFxuICB0b3VjaHN0YXJ0OiAncG9pbnRlcmRvd24nLFxuICB0b3VjaG1vdmU6ICdwb2ludGVybW92ZScsXG4gIHRvdWNoZW5kOiAncG9pbnRlcnVwJyxcbiAgbW91c2Vkb3duOiAncG9pbnRlcmRvd24nLFxuICBtb3VzZW1vdmU6ICdwb2ludGVybW92ZScsXG4gIG1vdXNldXA6ICdwb2ludGVydXAnXG59O1xuZXhwb3J0IGNvbnN0IElOUFVUX0VWRU5UX1RZUEVTID0ge1xuICBLRVlfRVZFTlRTOiBbJ2tleWRvd24nLCAna2V5dXAnXSxcbiAgTU9VU0VfRVZFTlRTOiBbJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCcsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2VsZWF2ZSddLFxuICBXSEVFTF9FVkVOVFM6IFtcbiAgLy8gQ2hyb21lLCBTYWZhcmlcbiAgJ3doZWVsJyxcbiAgLy8gSUVcbiAgJ21vdXNld2hlZWwnXVxufTtcbi8qKlxuICogXCJHZXN0dXJhbFwiIGV2ZW50cyBhcmUgdGhvc2UgdGhhdCBoYXZlIHNlbWFudGljIG1lYW5pbmcgYmV5b25kIHRoZSBiYXNpYyBpbnB1dCBldmVudCxcbiAqIGUuZy4gYSBjbGljayBvciB0YXAgaXMgYSBzZXF1ZW5jZSBvZiBgZG93bmAgYW5kIGB1cGAgZXZlbnRzIHdpdGggbm8gYG1vdmVgIGV2ZW50IGluIGJldHdlZW4uXG4gKiBIYW1tZXIuanMgaGFuZGxlcyB0aGVzZSB3aXRoIGl0cyBSZWNvZ25pemVyIHN5c3RlbTtcbiAqIHRoaXMgYmxvY2sgbWFwcyBldmVudCBuYW1lcyB0byB0aGUgUmVjb2duaXplcnMgcmVxdWlyZWQgdG8gZGV0ZWN0IHRoZSBldmVudHMuXG4gKi9cbmV4cG9ydCBjb25zdCBFVkVOVF9SRUNPR05JWkVSX01BUCA9IHtcbiAgdGFwOiAndGFwJyxcbiAgYW55dGFwOiAnYW55dGFwJyxcbiAgZG91YmxldGFwOiAnZG91YmxldGFwJyxcbiAgcHJlc3M6ICdwcmVzcycsXG4gIHBpbmNoOiAncGluY2gnLFxuICBwaW5jaGluOiAncGluY2gnLFxuICBwaW5jaG91dDogJ3BpbmNoJyxcbiAgcGluY2hzdGFydDogJ3BpbmNoJyxcbiAgcGluY2htb3ZlOiAncGluY2gnLFxuICBwaW5jaGVuZDogJ3BpbmNoJyxcbiAgcGluY2hjYW5jZWw6ICdwaW5jaCcsXG4gIHJvdGF0ZTogJ3JvdGF0ZScsXG4gIHJvdGF0ZXN0YXJ0OiAncm90YXRlJyxcbiAgcm90YXRlbW92ZTogJ3JvdGF0ZScsXG4gIHJvdGF0ZWVuZDogJ3JvdGF0ZScsXG4gIHJvdGF0ZWNhbmNlbDogJ3JvdGF0ZScsXG4gIHRyaXBhbjogJ3RyaXBhbicsXG4gIHRyaXBhbnN0YXJ0OiAndHJpcGFuJyxcbiAgdHJpcGFubW92ZTogJ3RyaXBhbicsXG4gIHRyaXBhbnVwOiAndHJpcGFuJyxcbiAgdHJpcGFuZG93bjogJ3RyaXBhbicsXG4gIHRyaXBhbmxlZnQ6ICd0cmlwYW4nLFxuICB0cmlwYW5yaWdodDogJ3RyaXBhbicsXG4gIHRyaXBhbmVuZDogJ3RyaXBhbicsXG4gIHRyaXBhbmNhbmNlbDogJ3RyaXBhbicsXG4gIHBhbjogJ3BhbicsXG4gIHBhbnN0YXJ0OiAncGFuJyxcbiAgcGFubW92ZTogJ3BhbicsXG4gIHBhbnVwOiAncGFuJyxcbiAgcGFuZG93bjogJ3BhbicsXG4gIHBhbmxlZnQ6ICdwYW4nLFxuICBwYW5yaWdodDogJ3BhbicsXG4gIHBhbmVuZDogJ3BhbicsXG4gIHBhbmNhbmNlbDogJ3BhbicsXG4gIHN3aXBlOiAnc3dpcGUnLFxuICBzd2lwZWxlZnQ6ICdzd2lwZScsXG4gIHN3aXBlcmlnaHQ6ICdzd2lwZScsXG4gIHN3aXBldXA6ICdzd2lwZScsXG4gIHN3aXBlZG93bjogJ3N3aXBlJ1xufTtcbi8qKlxuICogTWFwIGdlc3R1cmFsIGV2ZW50cyB0eXBpY2FsbHkgcHJvdmlkZWQgYnkgYnJvd3NlcnNcbiAqIHRoYXQgYXJlIG5vdCByZXBvcnRlZCBpbiAnaGFtbWVyLmlucHV0JyBldmVudHNcbiAqIHRvIGNvcnJlc3BvbmRpbmcgSGFtbWVyLmpzIGdlc3R1cmVzLlxuICovXG5leHBvcnQgY29uc3QgR0VTVFVSRV9FVkVOVF9BTElBU0VTID0ge1xuICBjbGljazogJ3RhcCcsXG4gIGFueWNsaWNrOiAnYW55dGFwJyxcbiAgZGJsY2xpY2s6ICdkb3VibGV0YXAnLFxuICBtb3VzZWRvd246ICdwb2ludGVyZG93bicsXG4gIG1vdXNlbW92ZTogJ3BvaW50ZXJtb3ZlJyxcbiAgbW91c2V1cDogJ3BvaW50ZXJ1cCcsXG4gIG1vdXNlb3ZlcjogJ3BvaW50ZXJvdmVyJyxcbiAgbW91c2VvdXQ6ICdwb2ludGVyb3V0JyxcbiAgbW91c2VsZWF2ZTogJ3BvaW50ZXJsZWF2ZSdcbn07IiwiLy8gUHVycG9zZTogaW5jbHVkZSB0aGlzIGluIHlvdXIgbW9kdWxlIHRvIGF2b2lkcyBhZGRpbmcgZGVwZW5kZW5jaWVzIG9uXG4vLyBtaWNybyBtb2R1bGVzIGxpa2UgJ2dsb2JhbCdcbi8qIGdsb2JhbCB3aW5kb3csIGdsb2JhbCwgZG9jdW1lbnQsIG5hdmlnYXRvciAqL1xuZXhwb3J0IGNvbnN0IHVzZXJBZ2VudCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgPyBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkgOiAnJztcbmNvbnN0IHdpbmRvd18gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbDtcbmNvbnN0IGdsb2JhbF8gPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdztcbmNvbnN0IGRvY3VtZW50XyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHt9O1xuZXhwb3J0IHsgd2luZG93XyBhcyB3aW5kb3csIGdsb2JhbF8gYXMgZ2xvYmFsLCBkb2N1bWVudF8gYXMgZG9jdW1lbnQgfTtcbi8qXG4gKiBEZXRlY3Qgd2hldGhlciBwYXNzaXZlIG9wdGlvbiBpcyBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyXG4gICAjU2FmZWx5X2RldGVjdGluZ19vcHRpb25fc3VwcG9ydFxuICovXG5sZXQgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuLyogZXNsaW50LWRpc2FibGUgYWNjZXNzb3ItcGFpcnMsIG5vLWVtcHR5ICovXG50cnkge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYnJvd3NlclxuICAgIC8vIGF0dGVtcHRzIHRvIGFjY2VzcyB0aGUgcGFzc2l2ZSBwcm9wZXJ0eS5cbiAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuICB3aW5kb3dfLmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgd2luZG93Xy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCk7XG59IGNhdGNoIChlcnIpIHtcbiAgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xufVxuZXhwb3J0IHsgcGFzc2l2ZVN1cHBvcnRlZCB9OyIsImltcG9ydCBJbnB1dCBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IElOUFVUX0VWRU5UX1RZUEVTIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IHdpbmRvdywgdXNlckFnZW50LCBwYXNzaXZlU3VwcG9ydGVkIH0gZnJvbSAnLi4vdXRpbHMvZ2xvYmFscyc7XG5jb25zdCBmaXJlZm94ID0gdXNlckFnZW50LmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTE7XG5jb25zdCB7XG4gIFdIRUVMX0VWRU5UU1xufSA9IElOUFVUX0VWRU5UX1RZUEVTO1xuY29uc3QgRVZFTlRfVFlQRSA9ICd3aGVlbCc7XG4vLyBDb25zdGFudHMgZm9yIG5vcm1hbGl6aW5nIGlucHV0IGRlbHRhXG5jb25zdCBXSEVFTF9ERUxUQV9NQUdJQ19TQ0FMRVIgPSA0LjAwMDI0NDE0MDYyNTtcbmNvbnN0IFdIRUVMX0RFTFRBX1BFUl9MSU5FID0gNDA7XG4vLyBTbG93IGRvd24gem9vbSBpZiBzaGlmdCBrZXkgaXMgaGVsZCBmb3IgbW9yZSBwcmVjaXNlIHpvb21pbmdcbmNvbnN0IFNISUZUX01VTFRJUExJRVIgPSAwLjI1O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2hlZWxJbnB1dCBleHRlbmRzIElucHV0IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBzdXBlcihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHMgKi9cbiAgICB0aGlzLmhhbmRsZUV2ZW50ID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZW5hYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB2YWx1ZSA9IGV2ZW50LmRlbHRhWTtcbiAgICAgIGlmICh3aW5kb3cuV2hlZWxFdmVudCkge1xuICAgICAgICAvLyBGaXJlZm94IGRvdWJsZXMgdGhlIHZhbHVlcyBvbiByZXRpbmEgc2NyZWVucy4uLlxuICAgICAgICBpZiAoZmlyZWZveCAmJiBldmVudC5kZWx0YU1vZGUgPT09IHdpbmRvdy5XaGVlbEV2ZW50LkRPTV9ERUxUQV9QSVhFTCkge1xuICAgICAgICAgIHZhbHVlIC89IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5kZWx0YU1vZGUgPT09IHdpbmRvdy5XaGVlbEV2ZW50LkRPTV9ERUxUQV9MSU5FKSB7XG4gICAgICAgICAgdmFsdWUgKj0gV0hFRUxfREVMVEFfUEVSX0xJTkU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAhPT0gMCAmJiB2YWx1ZSAlIFdIRUVMX0RFTFRBX01BR0lDX1NDQUxFUiA9PT0gMCkge1xuICAgICAgICAvLyBUaGlzIG9uZSBpcyBkZWZpbml0ZWx5IGEgbW91c2Ugd2hlZWwgZXZlbnQuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGlzIHZhbHVlIHRvIG1hdGNoIHRyYWNrcGFkLlxuICAgICAgICB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUgLyBXSEVFTF9ERUxUQV9NQUdJQ19TQ0FMRVIpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5ICYmIHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgKiBTSElGVF9NVUxUSVBMSUVSO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxsYmFjayh7XG4gICAgICAgIHR5cGU6IEVWRU5UX1RZUEUsXG4gICAgICAgIGNlbnRlcjoge1xuICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgICAgICB9LFxuICAgICAgICBkZWx0YTogLXZhbHVlLFxuICAgICAgICBzcmNFdmVudDogZXZlbnQsXG4gICAgICAgIHBvaW50ZXJUeXBlOiAnbW91c2UnLFxuICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldFxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLmV2ZW50cyA9ICh0aGlzLm9wdGlvbnMuZXZlbnRzIHx8IFtdKS5jb25jYXQoV0hFRUxfRVZFTlRTKTtcbiAgICB0aGlzLmV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5oYW5kbGVFdmVudCwgcGFzc2l2ZVN1cHBvcnRlZCA/IHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSA6IGZhbHNlKSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZUV2ZW50KSk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGlzIGlucHV0IChiZWdpbiBwcm9jZXNzaW5nIGV2ZW50cylcbiAgICogaWYgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlIGlzIGFtb25nIHRob3NlIGhhbmRsZWQgYnkgdGhpcyBpbnB1dC5cbiAgICovXG4gIGVuYWJsZUV2ZW50VHlwZShldmVudFR5cGUsIGVuYWJsZWQpIHtcbiAgICBpZiAoZXZlbnRUeXBlID09PSBFVkVOVF9UWVBFKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlID0gZW5hYmxlZDtcbiAgICB9XG4gIH1cbn0iLCJpbXBvcnQgSW5wdXQgZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBJTlBVVF9FVkVOVF9UWVBFUyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5jb25zdCB7XG4gIE1PVVNFX0VWRU5UU1xufSA9IElOUFVUX0VWRU5UX1RZUEVTO1xuY29uc3QgTU9WRV9FVkVOVF9UWVBFID0gJ3BvaW50ZXJtb3ZlJztcbmNvbnN0IE9WRVJfRVZFTlRfVFlQRSA9ICdwb2ludGVyb3Zlcic7XG5jb25zdCBPVVRfRVZFTlRfVFlQRSA9ICdwb2ludGVyb3V0JztcbmNvbnN0IEVOVEVSX0VWRU5UX1RZUEUgPSAncG9pbnRlcmVudGVyJztcbmNvbnN0IExFQVZFX0VWRU5UX1RZUEUgPSAncG9pbnRlcmxlYXZlJztcbi8qKlxuICogSGFtbWVyLmpzIHN3YWxsb3dzICdtb3ZlJyBldmVudHMgKGZvciBwb2ludGVyL3RvdWNoL21vdXNlKVxuICogd2hlbiB0aGUgcG9pbnRlciBpcyBub3QgZG93bi4gVGhpcyBjbGFzcyBzZXRzIHVwIGEgaGFuZGxlclxuICogc3BlY2lmaWNhbGx5IGZvciB0aGVzZSBldmVudHMgdG8gd29yayBhcm91bmQgdGhpcyBsaW1pdGF0aW9uLlxuICogTm90ZSB0aGF0IHRoaXMgY291bGQgYmUgZXh0ZW5kZWQgdG8gbW9yZSBpbnRlbGxpZ2VudGx5IGhhbmRsZVxuICogbW92ZSBldmVudHMgYWNyb3NzIGlucHV0IHR5cGVzLCBlLmcuIHN0b3JpbmcgbXVsdGlwbGUgc2ltdWx0YW5lb3VzXG4gKiBwb2ludGVyL3RvdWNoIGV2ZW50cywgY2FsY3VsYXRpbmcgc3BlZWQvZGlyZWN0aW9uLCBldGMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vdmVJbnB1dCBleHRlbmRzIElucHV0IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBzdXBlcihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgdGhpcy5oYW5kbGVFdmVudCA9IGV2ZW50ID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlT3ZlckV2ZW50KGV2ZW50KTtcbiAgICAgIHRoaXMuaGFuZGxlT3V0RXZlbnQoZXZlbnQpO1xuICAgICAgdGhpcy5oYW5kbGVFbnRlckV2ZW50KGV2ZW50KTtcbiAgICAgIHRoaXMuaGFuZGxlTGVhdmVFdmVudChldmVudCk7XG4gICAgICB0aGlzLmhhbmRsZU1vdmVFdmVudChldmVudCk7XG4gICAgfTtcbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICBjb25zdCB7XG4gICAgICBlbmFibGVcbiAgICB9ID0gdGhpcy5vcHRpb25zO1xuICAgIHRoaXMuZW5hYmxlTW92ZUV2ZW50ID0gZW5hYmxlO1xuICAgIHRoaXMuZW5hYmxlTGVhdmVFdmVudCA9IGVuYWJsZTtcbiAgICB0aGlzLmVuYWJsZUVudGVyRXZlbnQgPSBlbmFibGU7XG4gICAgdGhpcy5lbmFibGVPdXRFdmVudCA9IGVuYWJsZTtcbiAgICB0aGlzLmVuYWJsZU92ZXJFdmVudCA9IGVuYWJsZTtcbiAgICB0aGlzLmV2ZW50cyA9ICh0aGlzLm9wdGlvbnMuZXZlbnRzIHx8IFtdKS5jb25jYXQoTU9VU0VfRVZFTlRTKTtcbiAgICB0aGlzLmV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5oYW5kbGVFdmVudCkpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ldmVudHMuZm9yRWFjaChldmVudCA9PiB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5oYW5kbGVFdmVudCkpO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGUgdGhpcyBpbnB1dCAoYmVnaW4gcHJvY2Vzc2luZyBldmVudHMpXG4gICAqIGlmIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZSBpcyBhbW9uZyB0aG9zZSBoYW5kbGVkIGJ5IHRoaXMgaW5wdXQuXG4gICAqL1xuICBlbmFibGVFdmVudFR5cGUoZXZlbnRUeXBlLCBlbmFibGVkKSB7XG4gICAgaWYgKGV2ZW50VHlwZSA9PT0gTU9WRV9FVkVOVF9UWVBFKSB7XG4gICAgICB0aGlzLmVuYWJsZU1vdmVFdmVudCA9IGVuYWJsZWQ7XG4gICAgfVxuICAgIGlmIChldmVudFR5cGUgPT09IE9WRVJfRVZFTlRfVFlQRSkge1xuICAgICAgdGhpcy5lbmFibGVPdmVyRXZlbnQgPSBlbmFibGVkO1xuICAgIH1cbiAgICBpZiAoZXZlbnRUeXBlID09PSBPVVRfRVZFTlRfVFlQRSkge1xuICAgICAgdGhpcy5lbmFibGVPdXRFdmVudCA9IGVuYWJsZWQ7XG4gICAgfVxuICAgIGlmIChldmVudFR5cGUgPT09IEVOVEVSX0VWRU5UX1RZUEUpIHtcbiAgICAgIHRoaXMuZW5hYmxlRW50ZXJFdmVudCA9IGVuYWJsZWQ7XG4gICAgfVxuICAgIGlmIChldmVudFR5cGUgPT09IExFQVZFX0VWRU5UX1RZUEUpIHtcbiAgICAgIHRoaXMuZW5hYmxlTGVhdmVFdmVudCA9IGVuYWJsZWQ7XG4gICAgfVxuICB9XG4gIGhhbmRsZU92ZXJFdmVudChldmVudCkge1xuICAgIGlmICh0aGlzLmVuYWJsZU92ZXJFdmVudCkge1xuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZW92ZXInKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoT1ZFUl9FVkVOVF9UWVBFLCBldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhbmRsZU91dEV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZW5hYmxlT3V0RXZlbnQpIHtcbiAgICAgIGlmIChldmVudC50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoT1VUX0VWRU5UX1RZUEUsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlRW50ZXJFdmVudChldmVudCkge1xuICAgIGlmICh0aGlzLmVuYWJsZUVudGVyRXZlbnQpIHtcbiAgICAgIGlmIChldmVudC50eXBlID09PSAnbW91c2VlbnRlcicpIHtcbiAgICAgICAgdGhpcy5fZW1pdChFTlRFUl9FVkVOVF9UWVBFLCBldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhbmRsZUxlYXZlRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5lbmFibGVMZWF2ZUV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlbGVhdmUnKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoTEVBVkVfRVZFTlRfVFlQRSwgZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYW5kbGVNb3ZlRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5lbmFibGVNb3ZlRXZlbnQpIHtcbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICAgIGlmIChldmVudC5idXR0b24gPj0gMCkge1xuICAgICAgICAgICAgLy8gQnV0dG9uIGlzIGRvd25cbiAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICAgIC8vIE1vdmUgZXZlbnRzIHVzZSBgYm90dG9uc2AgdG8gdHJhY2sgdGhlIGJ1dHRvbiBiZWluZyBwcmVzc2VkXG4gICAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbnMgPT09IDApIHtcbiAgICAgICAgICAgIC8vIEJ1dHRvbiBpcyBub3QgZG93blxuICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5wcmVzc2VkKSB7XG4gICAgICAgICAgICAvLyBEcmFnIGV2ZW50cyBhcmUgZW1pdHRlZCBieSBoYW1tZXIgYWxyZWFkeVxuICAgICAgICAgICAgLy8gd2UganVzdCBuZWVkIHRvIGVtaXQgdGhlIG1vdmUgZXZlbnQgb24gaG92ZXJcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoTU9WRV9FVkVOVF9UWVBFLCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2VtaXQodHlwZSwgZXZlbnQpIHtcbiAgICB0aGlzLmNhbGxiYWNrKHtcbiAgICAgIHR5cGUsXG4gICAgICBjZW50ZXI6IHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgICAgfSxcbiAgICAgIHNyY0V2ZW50OiBldmVudCxcbiAgICAgIHBvaW50ZXJUeXBlOiAnbW91c2UnLFxuICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXRcbiAgICB9KTtcbiAgfVxufSIsImltcG9ydCBJbnB1dCBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IElOUFVUX0VWRU5UX1RZUEVTIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmNvbnN0IHtcbiAgS0VZX0VWRU5UU1xufSA9IElOUFVUX0VWRU5UX1RZUEVTO1xuY29uc3QgRE9XTl9FVkVOVF9UWVBFID0gJ2tleWRvd24nO1xuY29uc3QgVVBfRVZFTlRfVFlQRSA9ICdrZXl1cCc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLZXlJbnB1dCBleHRlbmRzIElucHV0IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBzdXBlcihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgdGhpcy5oYW5kbGVFdmVudCA9IGV2ZW50ID0+IHtcbiAgICAgIC8vIElnbm9yZSBpZiBmb2N1c2VkIG9uIHRleHQgaW5wdXRcbiAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBldmVudC50YXJnZXQgfHwgZXZlbnQuc3JjRWxlbWVudDtcbiAgICAgIGlmICh0YXJnZXRFbGVtZW50LnRhZ05hbWUgPT09ICdJTlBVVCcgJiYgdGFyZ2V0RWxlbWVudC50eXBlID09PSAndGV4dCcgfHwgdGFyZ2V0RWxlbWVudC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuYWJsZURvd25FdmVudCAmJiBldmVudC50eXBlID09PSAna2V5ZG93bicpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayh7XG4gICAgICAgICAgdHlwZTogRE9XTl9FVkVOVF9UWVBFLFxuICAgICAgICAgIHNyY0V2ZW50OiBldmVudCxcbiAgICAgICAgICBrZXk6IGV2ZW50LmtleSxcbiAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuYWJsZVVwRXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrKHtcbiAgICAgICAgICB0eXBlOiBVUF9FVkVOVF9UWVBFLFxuICAgICAgICAgIHNyY0V2ZW50OiBldmVudCxcbiAgICAgICAgICBrZXk6IGV2ZW50LmtleSxcbiAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZW5hYmxlRG93bkV2ZW50ID0gdGhpcy5vcHRpb25zLmVuYWJsZTtcbiAgICB0aGlzLmVuYWJsZVVwRXZlbnQgPSB0aGlzLm9wdGlvbnMuZW5hYmxlO1xuICAgIHRoaXMuZXZlbnRzID0gKHRoaXMub3B0aW9ucy5ldmVudHMgfHwgW10pLmNvbmNhdChLRVlfRVZFTlRTKTtcbiAgICBlbGVtZW50LnRhYkluZGV4ID0gdGhpcy5vcHRpb25zLnRhYkluZGV4IHx8IDA7XG4gICAgZWxlbWVudC5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xuICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZUV2ZW50KSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZUV2ZW50KSk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGlzIGlucHV0IChiZWdpbiBwcm9jZXNzaW5nIGV2ZW50cylcbiAgICogaWYgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlIGlzIGFtb25nIHRob3NlIGhhbmRsZWQgYnkgdGhpcyBpbnB1dC5cbiAgICovXG4gIGVuYWJsZUV2ZW50VHlwZShldmVudFR5cGUsIGVuYWJsZWQpIHtcbiAgICBpZiAoZXZlbnRUeXBlID09PSBET1dOX0VWRU5UX1RZUEUpIHtcbiAgICAgIHRoaXMuZW5hYmxlRG93bkV2ZW50ID0gZW5hYmxlZDtcbiAgICB9XG4gICAgaWYgKGV2ZW50VHlwZSA9PT0gVVBfRVZFTlRfVFlQRSkge1xuICAgICAgdGhpcy5lbmFibGVVcEV2ZW50ID0gZW5hYmxlZDtcbiAgICB9XG4gIH1cbn0iLCJpbXBvcnQgSW5wdXQgZnJvbSAnLi9pbnB1dCc7XG5jb25zdCBFVkVOVF9UWVBFID0gJ2NvbnRleHRtZW51JztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRleHRtZW51SW5wdXQgZXh0ZW5kcyBJbnB1dCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgIHRoaXMuaGFuZGxlRXZlbnQgPSBldmVudCA9PiB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxsYmFjayh7XG4gICAgICAgIHR5cGU6IEVWRU5UX1RZUEUsXG4gICAgICAgIGNlbnRlcjoge1xuICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgICAgICB9LFxuICAgICAgICBzcmNFdmVudDogZXZlbnQsXG4gICAgICAgIHBvaW50ZXJUeXBlOiAnbW91c2UnLFxuICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5oYW5kbGVFdmVudCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIHRoaXMgaW5wdXQgKGJlZ2luIHByb2Nlc3NpbmcgZXZlbnRzKVxuICAgKiBpZiB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUgaXMgYW1vbmcgdGhvc2UgaGFuZGxlZCBieSB0aGlzIGlucHV0LlxuICAgKi9cbiAgZW5hYmxlRXZlbnRUeXBlKGV2ZW50VHlwZSwgZW5hYmxlZCkge1xuICAgIGlmIChldmVudFR5cGUgPT09IEVWRU5UX1RZUEUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5lbmFibGUgPSBlbmFibGVkO1xuICAgIH1cbiAgfVxufSIsIi8qIENvbnN0YW50cyAqL1xuY29uc3QgRE9XTl9FVkVOVCA9IDE7XG5jb25zdCBNT1ZFX0VWRU5UID0gMjtcbmNvbnN0IFVQX0VWRU5UID0gNDtcbmNvbnN0IE1PVVNFX0VWRU5UUyA9IHtcbiAgcG9pbnRlcmRvd246IERPV05fRVZFTlQsXG4gIHBvaW50ZXJtb3ZlOiBNT1ZFX0VWRU5ULFxuICBwb2ludGVydXA6IFVQX0VWRU5ULFxuICBtb3VzZWRvd246IERPV05fRVZFTlQsXG4gIG1vdXNlbW92ZTogTU9WRV9FVkVOVCxcbiAgbW91c2V1cDogVVBfRVZFTlRcbn07XG4vLyBNb3VzZUV2ZW50LmJ1dHRvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC9idXR0b25cbmNvbnN0IE1PVVNFX0VWRU5UX0JVVFRPTl9MRUZUID0gMDtcbmNvbnN0IE1PVVNFX0VWRU5UX0JVVFRPTl9NSURETEUgPSAxO1xuY29uc3QgTU9VU0VfRVZFTlRfQlVUVE9OX1JJR0hUID0gMjtcbi8vIE1vdXNlRXZlbnQuYnV0dG9ucyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC9idXR0b25zXG5jb25zdCBNT1VTRV9FVkVOVF9CVVRUT05TX0xFRlRfTUFTSyA9IDE7XG5jb25zdCBNT1VTRV9FVkVOVF9CVVRUT05TX1JJR0hUX01BU0sgPSAyO1xuY29uc3QgTU9VU0VfRVZFTlRfQlVUVE9OU19NSURETEVfTUFTSyA9IDQ7XG4vKipcbiAqIEV4dHJhY3QgdGhlIGludm9sdmVkIG1vdXNlIGJ1dHRvblxuICovXG5leHBvcnQgZnVuY3Rpb24gd2hpY2hCdXR0b25zKGV2ZW50KSB7XG4gIGNvbnN0IGV2ZW50VHlwZSA9IE1PVVNFX0VWRU5UU1tldmVudC5zcmNFdmVudC50eXBlXTtcbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICAvLyBOb3QgYSBtb3VzZSBldmV0XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qge1xuICAgIGJ1dHRvbnMsXG4gICAgYnV0dG9uXG4gIH0gPSBldmVudC5zcmNFdmVudDtcbiAgbGV0IGxlZnRCdXR0b24gPSBmYWxzZTtcbiAgbGV0IG1pZGRsZUJ1dHRvbiA9IGZhbHNlO1xuICBsZXQgcmlnaHRCdXR0b24gPSBmYWxzZTtcbiAgaWYgKGV2ZW50VHlwZSA9PT0gTU9WRV9FVkVOVCkge1xuICAgIGxlZnRCdXR0b24gPSBCb29sZWFuKGJ1dHRvbnMgJiBNT1VTRV9FVkVOVF9CVVRUT05TX0xFRlRfTUFTSyk7XG4gICAgbWlkZGxlQnV0dG9uID0gQm9vbGVhbihidXR0b25zICYgTU9VU0VfRVZFTlRfQlVUVE9OU19NSURETEVfTUFTSyk7XG4gICAgcmlnaHRCdXR0b24gPSBCb29sZWFuKGJ1dHRvbnMgJiBNT1VTRV9FVkVOVF9CVVRUT05TX1JJR0hUX01BU0spO1xuICB9IGVsc2Uge1xuICAgIGxlZnRCdXR0b24gPSBidXR0b24gPT09IE1PVVNFX0VWRU5UX0JVVFRPTl9MRUZUO1xuICAgIG1pZGRsZUJ1dHRvbiA9IGJ1dHRvbiA9PT0gTU9VU0VfRVZFTlRfQlVUVE9OX01JRERMRTtcbiAgICByaWdodEJ1dHRvbiA9IGJ1dHRvbiA9PT0gTU9VU0VfRVZFTlRfQlVUVE9OX1JJR0hUO1xuICB9XG4gIHJldHVybiB7XG4gICAgbGVmdEJ1dHRvbixcbiAgICBtaWRkbGVCdXR0b24sXG4gICAgcmlnaHRCdXR0b25cbiAgfTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIGV2ZW50IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSByb290IGVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9mZnNldFBvc2l0aW9uKGV2ZW50LCByb290RWxlbWVudCkge1xuICBjb25zdCBjZW50ZXIgPSBldmVudC5jZW50ZXI7XG4gIC8vIGBjZW50ZXJgIGlzIGEgaGFtbWVyLmpzIGV2ZW50IHByb3BlcnR5XG4gIGlmICghY2VudGVyKSB7XG4gICAgLy8gTm90IGEgZ2VzdHVyYWwgZXZlbnRcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCByZWN0ID0gcm9vdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIC8vIEZpeCBzY2FsZSBmb3IgbWFwIGFmZmVjdGVkIGJ5IGEgQ1NTIHRyYW5zZm9ybS5cbiAgLy8gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjg5MzY2My8zNTI4NTMzXG4gIGNvbnN0IHNjYWxlWCA9IHJlY3Qud2lkdGggLyByb290RWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxO1xuICBjb25zdCBzY2FsZVkgPSByZWN0LmhlaWdodCAvIHJvb3RFbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxO1xuICAvLyBDYWxjdWxhdGUgY2VudGVyIHJlbGF0aXZlIHRvIHRoZSByb290IGVsZW1lbnRcbiAgY29uc3Qgb2Zmc2V0Q2VudGVyID0ge1xuICAgIHg6IChjZW50ZXIueCAtIHJlY3QubGVmdCAtIHJvb3RFbGVtZW50LmNsaWVudExlZnQpIC8gc2NhbGVYLFxuICAgIHk6IChjZW50ZXIueSAtIHJlY3QudG9wIC0gcm9vdEVsZW1lbnQuY2xpZW50VG9wKSAvIHNjYWxlWVxuICB9O1xuICByZXR1cm4ge1xuICAgIGNlbnRlcixcbiAgICBvZmZzZXRDZW50ZXJcbiAgfTtcbn0iLCJpbXBvcnQgeyB3aGljaEJ1dHRvbnMsIGdldE9mZnNldFBvc2l0aW9uIH0gZnJvbSAnLi9ldmVudC11dGlscyc7XG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XG4gIHNyY0VsZW1lbnQ6ICdyb290JyxcbiAgcHJpb3JpdHk6IDBcbn07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudFJlZ2lzdHJhciB7XG4gIGNvbnN0cnVjdG9yKGV2ZW50TWFuYWdlcikge1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgaGFtbWVyanMgZXZlbnRcbiAgICAgKi9cbiAgICB0aGlzLmhhbmRsZUV2ZW50ID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1qb2xuaXJFdmVudCA9IHRoaXMuX25vcm1hbGl6ZUV2ZW50KGV2ZW50KTtcbiAgICAgIGxldCB0YXJnZXQgPSBldmVudC5zcmNFdmVudC50YXJnZXQ7XG4gICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gbWpvbG5pckV2ZW50LnJvb3RFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX2VtaXQobWpvbG5pckV2ZW50LCB0YXJnZXQpO1xuICAgICAgICBpZiAobWpvbG5pckV2ZW50LmhhbmRsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICB0aGlzLl9lbWl0KG1qb2xuaXJFdmVudCwgJ3Jvb3QnKTtcbiAgICB9O1xuICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICAvLyBFbGVtZW50IC0+IGhhbmRsZXIgbWFwXG4gICAgdGhpcy5oYW5kbGVyc0J5RWxlbWVudCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgfVxuICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIG5vIG5vbi1wYXNzaXZlIGhhbmRsZXJzXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLl9hY3RpdmU7XG4gIH1cbiAgYWRkKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBsZXQgb25jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gICAgbGV0IHBhc3NpdmUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuICAgIGNvbnN0IHtcbiAgICAgIGhhbmRsZXJzLFxuICAgICAgaGFuZGxlcnNCeUVsZW1lbnRcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgb3B0cyA9IERFRkFVTFRfT1BUSU9OUztcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnIHx8IG9wdGlvbnMgJiYgb3B0aW9ucy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAvLyBpcyBET00gZWxlbWVudCwgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgb3B0cyA9IHtcbiAgICAgICAgLi4uREVGQVVMVF9PUFRJT05TLFxuICAgICAgICBzcmNFbGVtZW50OiBvcHRpb25zXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucykge1xuICAgICAgb3B0cyA9IHtcbiAgICAgICAgLi4uREVGQVVMVF9PUFRJT05TLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgZW50cmllcyA9IGhhbmRsZXJzQnlFbGVtZW50LmdldChvcHRzLnNyY0VsZW1lbnQpO1xuICAgIGlmICghZW50cmllcykge1xuICAgICAgZW50cmllcyA9IFtdO1xuICAgICAgaGFuZGxlcnNCeUVsZW1lbnQuc2V0KG9wdHMuc3JjRWxlbWVudCwgZW50cmllcyk7XG4gICAgfVxuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgdHlwZSxcbiAgICAgIGhhbmRsZXIsXG4gICAgICBzcmNFbGVtZW50OiBvcHRzLnNyY0VsZW1lbnQsXG4gICAgICBwcmlvcml0eTogb3B0cy5wcmlvcml0eVxuICAgIH07XG4gICAgaWYgKG9uY2UpIHtcbiAgICAgIGVudHJ5Lm9uY2UgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocGFzc2l2ZSkge1xuICAgICAgZW50cnkucGFzc2l2ZSA9IHRydWU7XG4gICAgfVxuICAgIGhhbmRsZXJzLnB1c2goZW50cnkpO1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCAhZW50cnkucGFzc2l2ZTtcbiAgICAvLyBTb3J0IGhhbmRsZXJzIGJ5IGRlc2NlbmRpbmcgcHJpb3JpdHlcbiAgICAvLyBIYW5kbGVycyB3aXRoIHRoZSBzYW1lIHByaW9yaXR5IGFyZSBleGN1dGVkIGluIHRoZSBvcmRlciBvZiByZWdpc3RyYXRpb25cbiAgICBsZXQgaW5zZXJ0UG9zaXRpb24gPSBlbnRyaWVzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGluc2VydFBvc2l0aW9uID49IDApIHtcbiAgICAgIGlmIChlbnRyaWVzW2luc2VydFBvc2l0aW9uXS5wcmlvcml0eSA+PSBlbnRyeS5wcmlvcml0eSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGluc2VydFBvc2l0aW9uLS07XG4gICAgfVxuICAgIGVudHJpZXMuc3BsaWNlKGluc2VydFBvc2l0aW9uICsgMSwgMCwgZW50cnkpO1xuICB9XG4gIHJlbW92ZSh0eXBlLCBoYW5kbGVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGFuZGxlcnMsXG4gICAgICBoYW5kbGVyc0J5RWxlbWVudFxuICAgIH0gPSB0aGlzO1xuICAgIGZvciAobGV0IGkgPSBoYW5kbGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgZW50cnkgPSBoYW5kbGVyc1tpXTtcbiAgICAgIGlmIChlbnRyeS50eXBlID09PSB0eXBlICYmIGVudHJ5LmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gaGFuZGxlcnNCeUVsZW1lbnQuZ2V0KGVudHJ5LnNyY0VsZW1lbnQpO1xuICAgICAgICBlbnRyaWVzLnNwbGljZShlbnRyaWVzLmluZGV4T2YoZW50cnkpLCAxKTtcbiAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaGFuZGxlcnNCeUVsZW1lbnQuZGVsZXRlKGVudHJ5LnNyY0VsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZSA9IGhhbmRsZXJzLnNvbWUoZW50cnkgPT4gIWVudHJ5LnBhc3NpdmUpO1xuICB9XG4gIC8qKlxuICAgKiBJbnZva2UgaGFuZGxlcnMgb24gYSBwYXJ0aWN1bGFyIGVsZW1lbnRcbiAgICovXG4gIF9lbWl0KGV2ZW50LCBzcmNFbGVtZW50KSB7XG4gICAgY29uc3QgZW50cmllcyA9IHRoaXMuaGFuZGxlcnNCeUVsZW1lbnQuZ2V0KHNyY0VsZW1lbnQpO1xuICAgIGlmIChlbnRyaWVzKSB7XG4gICAgICBsZXQgaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG4gICAgICAvLyBQcmV2ZW50cyB0aGUgY3VycmVudCBldmVudCBmcm9tIGJ1YmJsaW5nIHVwXG4gICAgICBjb25zdCBzdG9wUHJvcGFnYXRpb24gPSAoKSA9PiB7XG4gICAgICAgIGV2ZW50LmhhbmRsZWQgPSB0cnVlO1xuICAgICAgfTtcbiAgICAgIC8vIFByZXZlbnQgYW55IHJlbWFpbmluZyBsaXN0ZW5lcnMgZnJvbSBiZWluZyBjYWxsZWRcbiAgICAgIGNvbnN0IHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9ICgpID0+IHtcbiAgICAgICAgZXZlbnQuaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIGltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gICAgICB9O1xuICAgICAgY29uc3QgZW50cmllc1RvUmVtb3ZlID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICBvbmNlXG4gICAgICAgIH0gPSBlbnRyaWVzW2ldO1xuICAgICAgICBoYW5kbGVyKHtcbiAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBzdG9wUHJvcGFnYXRpb24sXG4gICAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob25jZSkge1xuICAgICAgICAgIGVudHJpZXNUb1JlbW92ZS5wdXNoKGVudHJpZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzVG9SZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgaGFuZGxlclxuICAgICAgICB9ID0gZW50cmllc1RvUmVtb3ZlW2ldO1xuICAgICAgICB0aGlzLnJlbW92ZSh0eXBlLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgaGFtbWVyanMgYW5kIGN1c3RvbSBldmVudHMgdG8gaGF2ZSBwcmVkaWN0YWJsZSBmaWVsZHMuXG4gICAqL1xuICBfbm9ybWFsaXplRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCByb290RWxlbWVudCA9IHRoaXMuZXZlbnRNYW5hZ2VyLmdldEVsZW1lbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZXZlbnQsXG4gICAgICAuLi53aGljaEJ1dHRvbnMoZXZlbnQpLFxuICAgICAgLi4uZ2V0T2Zmc2V0UG9zaXRpb24oZXZlbnQsIHJvb3RFbGVtZW50KSxcbiAgICAgIHByZXZlbnREZWZhdWx0OiAoKSA9PiB7XG4gICAgICAgIGV2ZW50LnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9LFxuICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBudWxsLFxuICAgICAgc3RvcFByb3BhZ2F0aW9uOiBudWxsLFxuICAgICAgaGFuZGxlZDogZmFsc2UsXG4gICAgICByb290RWxlbWVudFxuICAgIH07XG4gIH1cbn0iLCJpbXBvcnQgeyBNYW5hZ2VyIH0gZnJvbSAnLi91dGlscy9oYW1tZXInO1xuaW1wb3J0IFdoZWVsSW5wdXQgZnJvbSAnLi9pbnB1dHMvd2hlZWwtaW5wdXQnO1xuaW1wb3J0IE1vdmVJbnB1dCBmcm9tICcuL2lucHV0cy9tb3ZlLWlucHV0JztcbmltcG9ydCBLZXlJbnB1dCBmcm9tICcuL2lucHV0cy9rZXktaW5wdXQnO1xuaW1wb3J0IENvbnRleHRtZW51SW5wdXQgZnJvbSAnLi9pbnB1dHMvY29udGV4dG1lbnUtaW5wdXQnO1xuaW1wb3J0IEV2ZW50UmVnaXN0cmFyIGZyb20gJy4vdXRpbHMvZXZlbnQtcmVnaXN0cmFyJztcbmltcG9ydCB7IEJBU0lDX0VWRU5UX0FMSUFTRVMsIEVWRU5UX1JFQ09HTklaRVJfTUFQLCBHRVNUVVJFX0VWRU5UX0FMSUFTRVMsIFJFQ09HTklaRVJTLCBSRUNPR05JWkVSX0NPTVBBVElCTEVfTUFQLCBSRUNPR05JWkVSX0ZBTExCQUNLX01BUCB9IGZyb20gJy4vY29uc3RhbnRzJztcbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgZXZlbnRzOiBudWxsLFxuICAvLyBjdXN0b20gcmVjb2duaXplcnNcbiAgcmVjb2duaXplcnM6IG51bGwsXG4gIHJlY29nbml6ZXJPcHRpb25zOiB7fSxcbiAgLy8gTWFuYWdlciBjbGFzc1xuICBNYW5hZ2VyLFxuICAvLyBhbGxvdyBicm93c2VyIGRlZmF1bHQgdG91Y2ggYWN0aW9uXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91YmVyL3JlYWN0LW1hcC1nbC9pc3N1ZXMvNTA2XG4gIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gIHRhYkluZGV4OiAwXG59O1xuLy8gVW5pZmllZCBBUEkgZm9yIHN1YnNjcmliaW5nIHRvIGV2ZW50cyBhYm91dCBib3RoXG4vLyBiYXNpYyBpbnB1dCBldmVudHMgKGUuZy4gJ21vdXNlbW92ZScsICd0b3VjaHN0YXJ0JywgJ3doZWVsJylcbi8vIGFuZCBnZXN0dXJhbCBpbnB1dCAoZS5nLiAnY2xpY2snLCAndGFwJywgJ3BhbnN0YXJ0JykuXG4vLyBEZWxlZ2F0ZXMgZ2VzdHVyZSByZWxhdGVkIGV2ZW50IHJlZ2lzdHJhdGlvbiBhbmQgaGFuZGxpbmcgdG8gSGFtbWVyLmpzLlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IGVsZW1lbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYmFzaWMgZXZlbnRzIHVzaW5nIHRoZSAnaGFtbWVyLmlucHV0JyBIYW1tZXIuanMgQVBJOlxuICAgICAqIEJlZm9yZSBydW5uaW5nIFJlY29nbml6ZXJzLCBIYW1tZXIgZW1pdHMgYSAnaGFtbWVyLmlucHV0JyBldmVudFxuICAgICAqIHdpdGggdGhlIGJhc2ljIGV2ZW50IGluZm8uIFRoaXMgZnVuY3Rpb24gZW1pdHMgYWxsIGJhc2ljIGV2ZW50c1xuICAgICAqIGFsaWFzZWQgdG8gdGhlIFwiY2xhc3NcIiBvZiBldmVudCByZWNlaXZlZC5cbiAgICAgKiBTZWUgY29uc3RhbnRzLkJBU0lDX0VWRU5UX0NMQVNTRVMgYmFzaWMgZXZlbnQgY2xhc3MgZGVmaW5pdGlvbnMuXG4gICAgICovXG4gICAgdGhpcy5fb25CYXNpY0lucHV0ID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzcmNFdmVudFxuICAgICAgfSA9IGV2ZW50O1xuICAgICAgY29uc3QgYWxpYXMgPSBCQVNJQ19FVkVOVF9BTElBU0VTW3NyY0V2ZW50LnR5cGVdO1xuICAgICAgaWYgKGFsaWFzKSB7XG4gICAgICAgIC8vIGZpcmUgYWxsIGV2ZW50cyBhbGlhc2VkIHRvIHNyY0V2ZW50LnR5cGVcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQoYWxpYXMsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBldmVudHMgbm90IHN1cHBvcnRlZCBieSBIYW1tZXIuanMsXG4gICAgICogYW5kIHBpcGUgYmFjayBvdXQgdGhyb3VnaCBzYW1lIChIYW1tZXIpIGNoYW5uZWwgdXNlZCBieSBvdGhlciBldmVudHMuXG4gICAgICovXG4gICAgdGhpcy5fb25PdGhlckV2ZW50ID0gZXZlbnQgPT4ge1xuICAgICAgLy8gY29uc29sZS5sb2coJ29ub3RoZXJldmVudCcsIGV2ZW50LnR5cGUsIGV2ZW50KVxuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQoZXZlbnQudHlwZSwgZXZlbnQpO1xuICAgIH07XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgLi4uREVGQVVMVF9PUFRJT05TLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgdGhpcy5ldmVudHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5zZXRFbGVtZW50KGVsZW1lbnQpO1xuICAgIC8vIFJlZ2lzdGVyIGFsbCBwYXNzZWQgZXZlbnRzLlxuICAgIGNvbnN0IHtcbiAgICAgIGV2ZW50c1xuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgdGhpcy5vbihldmVudHMpO1xuICAgIH1cbiAgfVxuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XG4gIH1cbiAgc2V0RWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgLy8gdW5yZWdpc3RlciBhbGwgZXZlbnRzXG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgb3B0aW9uc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IE1hbmFnZXJDbGFzcyA9IG9wdGlvbnMuTWFuYWdlcjtcbiAgICB0aGlzLm1hbmFnZXIgPSBuZXcgTWFuYWdlckNsYXNzKGVsZW1lbnQsIHtcbiAgICAgIHRvdWNoQWN0aW9uOiBvcHRpb25zLnRvdWNoQWN0aW9uLFxuICAgICAgcmVjb2duaXplcnM6IG9wdGlvbnMucmVjb2duaXplcnMgfHwgUkVDT0dOSVpFUlNcbiAgICB9KS5vbignaGFtbWVyLmlucHV0JywgdGhpcy5fb25CYXNpY0lucHV0KTtcbiAgICBpZiAoIW9wdGlvbnMucmVjb2duaXplcnMpIHtcbiAgICAgIC8vIFNldCBkZWZhdWx0IHJlY29nbml6ZSB3aXRoc1xuICAgICAgLy8gaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9yZWNvZ25pemUtd2l0aC9cbiAgICAgIE9iamVjdC5rZXlzKFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVApLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlY29nbml6ZXIgPSB0aGlzLm1hbmFnZXIuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgICAgIFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVBbbmFtZV0uZm9yRWFjaChvdGhlck5hbWUgPT4ge1xuICAgICAgICAgICAgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKG90aGVyTmFtZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBTZXQgcmVjb2duaXplciBvcHRpb25zXG4gICAgZm9yIChjb25zdCByZWNvZ25pemVyTmFtZSBpbiBvcHRpb25zLnJlY29nbml6ZXJPcHRpb25zKSB7XG4gICAgICBjb25zdCByZWNvZ25pemVyID0gdGhpcy5tYW5hZ2VyLmdldChyZWNvZ25pemVyTmFtZSk7XG4gICAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgICBjb25zdCByZWNvZ25pemVyT3B0aW9uID0gb3B0aW9ucy5yZWNvZ25pemVyT3B0aW9uc1tyZWNvZ25pemVyTmFtZV07XG4gICAgICAgIC8vIGBlbmFibGVgIGlzIG1hbmFnZWQgYnkgdGhlIGV2ZW50IHJlZ2lzdHJhdGlvbnNcbiAgICAgICAgZGVsZXRlIHJlY29nbml6ZXJPcHRpb24uZW5hYmxlO1xuICAgICAgICByZWNvZ25pemVyLnNldChyZWNvZ25pemVyT3B0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gSGFuZGxlIGV2ZW50cyBub3QgaGFuZGxlZCBieSBIYW1tZXIuanM6XG4gICAgLy8gLSBtb3VzZSB3aGVlbFxuICAgIC8vIC0gcG9pbnRlci90b3VjaC9tb3VzZSBtb3ZlXG4gICAgdGhpcy53aGVlbElucHV0ID0gbmV3IFdoZWVsSW5wdXQoZWxlbWVudCwgdGhpcy5fb25PdGhlckV2ZW50LCB7XG4gICAgICBlbmFibGU6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5tb3ZlSW5wdXQgPSBuZXcgTW92ZUlucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge1xuICAgICAgZW5hYmxlOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMua2V5SW5wdXQgPSBuZXcgS2V5SW5wdXQoZWxlbWVudCwgdGhpcy5fb25PdGhlckV2ZW50LCB7XG4gICAgICBlbmFibGU6IGZhbHNlLFxuICAgICAgdGFiSW5kZXg6IG9wdGlvbnMudGFiSW5kZXhcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRleHRtZW51SW5wdXQgPSBuZXcgQ29udGV4dG1lbnVJbnB1dChlbGVtZW50LCB0aGlzLl9vbk90aGVyRXZlbnQsIHtcbiAgICAgIGVuYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgICAvLyBSZWdpc3RlciBhbGwgZXhpc3RpbmcgZXZlbnRzXG4gICAgZm9yIChjb25zdCBbZXZlbnRBbGlhcywgZXZlbnRSZWdpc3RyYXJdIG9mIHRoaXMuZXZlbnRzKSB7XG4gICAgICBpZiAoIWV2ZW50UmVnaXN0cmFyLmlzRW1wdHkoKSkge1xuICAgICAgICAvLyBFbmFibGUgcmVjb2duaXplciBmb3IgdGhpcyBldmVudC5cbiAgICAgICAgdGhpcy5fdG9nZ2xlUmVjb2duaXplcihldmVudFJlZ2lzdHJhci5yZWNvZ25pemVyTmFtZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMubWFuYWdlci5vbihldmVudEFsaWFzLCBldmVudFJlZ2lzdHJhci5oYW5kbGVFdmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFRlYXIgZG93biBpbnRlcm5hbCBldmVudCBtYW5hZ2VtZW50IGltcGxlbWVudGF0aW9ucy5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICAvLyB3aGVlbElucHV0IGV0Yy4gYXJlIGNyZWF0ZWQgaW4gc2V0RWxlbWVudCgpIGFuZCB0aGVyZWZvcmVcbiAgICAgIC8vIGNhbm5vdCBleGlzdCBpZiB0aGVyZSBpcyBubyBlbGVtZW50XG4gICAgICB0aGlzLndoZWVsSW5wdXQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5tb3ZlSW5wdXQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5rZXlJbnB1dC5kZXN0cm95KCk7XG4gICAgICB0aGlzLmNvbnRleHRtZW51SW5wdXQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5tYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMud2hlZWxJbnB1dCA9IG51bGw7XG4gICAgICB0aGlzLm1vdmVJbnB1dCA9IG51bGw7XG4gICAgICB0aGlzLmtleUlucHV0ID0gbnVsbDtcbiAgICAgIHRoaXMuY29udGV4dG1lbnVJbnB1dCA9IG51bGw7XG4gICAgICB0aGlzLm1hbmFnZXIgPSBudWxsO1xuICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqIFJlZ2lzdGVyIGFuIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGBldmVudGAgKi9cbiAgb24oZXZlbnQsIGhhbmRsZXIsIG9wdHMpIHtcbiAgICB0aGlzLl9hZGRFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIsIG9wdHMsIGZhbHNlKTtcbiAgfVxuICBvbmNlKGV2ZW50LCBoYW5kbGVyLCBvcHRzKSB7XG4gICAgdGhpcy5fYWRkRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBvcHRzLCB0cnVlKTtcbiAgfVxuICB3YXRjaChldmVudCwgaGFuZGxlciwgb3B0cykge1xuICAgIHRoaXMuX2FkZEV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlciwgb3B0cywgZmFsc2UsIHRydWUpO1xuICB9XG4gIG9mZihldmVudCwgaGFuZGxlcikge1xuICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcik7XG4gIH1cbiAgLypcbiAgICogRW5hYmxlL2Rpc2FibGUgcmVjb2duaXplciBmb3IgdGhlIGdpdmVuIGV2ZW50XG4gICAqL1xuICBfdG9nZ2xlUmVjb2duaXplcihuYW1lLCBlbmFibGVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWFuYWdlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWFuYWdlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWNvZ25pemVyID0gbWFuYWdlci5nZXQobmFtZSk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChyZWNvZ25pemVyICYmIHJlY29nbml6ZXIub3B0aW9ucy5lbmFibGUgIT09IGVuYWJsZWQpIHtcbiAgICAgIHJlY29nbml6ZXIuc2V0KHtcbiAgICAgICAgZW5hYmxlOiBlbmFibGVkXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrUmVjb2duaXplcnMgPSBSRUNPR05JWkVSX0ZBTExCQUNLX01BUFtuYW1lXTtcbiAgICAgIGlmIChmYWxsYmFja1JlY29nbml6ZXJzICYmICF0aGlzLm9wdGlvbnMucmVjb2duaXplcnMpIHtcbiAgICAgICAgLy8gU2V0IGRlZmF1bHQgcmVxdWlyZSBmYWlsdXJlc1xuICAgICAgICAvLyBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL3JlcXVpcmUtZmFpbHVyZS9cbiAgICAgICAgZmFsbGJhY2tSZWNvZ25pemVycy5mb3JFYWNoKG90aGVyTmFtZSA9PiB7XG4gICAgICAgICAgY29uc3Qgb3RoZXJSZWNvZ25pemVyID0gbWFuYWdlci5nZXQob3RoZXJOYW1lKTtcbiAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhpcyByZWNvZ25pemVyIHRvIGZhaWxcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZXF1aXJlRmFpbHVyZShuYW1lKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBzZWVtcyB0byBiZSBhIGJ1ZyBpbiBoYW1tZXJqczpcbiAgICAgICAgICAgICAqIHJlcXVpcmVGYWlsdXJlKCkgYWRkcyBib3RoIHdheXNcbiAgICAgICAgICAgICAqIGRyb3BSZXF1aXJlRmFpbHVyZSgpIG9ubHkgZHJvcHMgb25lIHdheVxuICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL2hhbW1lcmpzL2hhbW1lci5qcy9ibG9iL21hc3Rlci9zcmMvcmVjb2duaXplcmpzL1xuICAgICAgICAgICAgICAgcmVjb2duaXplci1jb25zdHJ1Y3Rvci5qcyNMMTM2XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlY29nbml6ZXIuZHJvcFJlcXVpcmVGYWlsdXJlKG90aGVyTmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCB3YWl0IGZvciB0aGlzIHJlY29nbml6ZXIgdG8gZmFpbFxuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLmRyb3BSZXF1aXJlRmFpbHVyZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndoZWVsSW5wdXQuZW5hYmxlRXZlbnRUeXBlKG5hbWUsIGVuYWJsZWQpO1xuICAgIHRoaXMubW92ZUlucHV0LmVuYWJsZUV2ZW50VHlwZShuYW1lLCBlbmFibGVkKTtcbiAgICB0aGlzLmtleUlucHV0LmVuYWJsZUV2ZW50VHlwZShuYW1lLCBlbmFibGVkKTtcbiAgICB0aGlzLmNvbnRleHRtZW51SW5wdXQuZW5hYmxlRXZlbnRUeXBlKG5hbWUsIGVuYWJsZWQpO1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBldmVudCByZWdpc3RyYXRpb24gZm9yIGEgc2luZ2xlIGV2ZW50ICsgaGFuZGxlci5cbiAgICovXG4gIF9hZGRFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIsIG9wdHMsIG9uY2UsIHBhc3NpdmUpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgb3B0cyA9IGhhbmRsZXI7XG4gICAgICAvLyBJZiBgZXZlbnRgIGlzIGEgbWFwLCBjYWxsIGBvbigpYCBmb3IgZWFjaCBlbnRyeS5cbiAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIGluIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50SGFuZGxlcihldmVudE5hbWUsIGV2ZW50W2V2ZW50TmFtZV0sIG9wdHMsIG9uY2UsIHBhc3NpdmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBtYW5hZ2VyLFxuICAgICAgZXZlbnRzXG4gICAgfSA9IHRoaXM7XG4gICAgLy8gQWxpYXMgdG8gYSByZWNvZ25pemVkIGdlc3R1cmUgYXMgbmVjZXNzYXJ5LlxuICAgIGNvbnN0IGV2ZW50QWxpYXMgPSBHRVNUVVJFX0VWRU5UX0FMSUFTRVNbZXZlbnRdIHx8IGV2ZW50O1xuICAgIGxldCBldmVudFJlZ2lzdHJhciA9IGV2ZW50cy5nZXQoZXZlbnRBbGlhcyk7XG4gICAgaWYgKCFldmVudFJlZ2lzdHJhcikge1xuICAgICAgZXZlbnRSZWdpc3RyYXIgPSBuZXcgRXZlbnRSZWdpc3RyYXIodGhpcyk7XG4gICAgICBldmVudHMuc2V0KGV2ZW50QWxpYXMsIGV2ZW50UmVnaXN0cmFyKTtcbiAgICAgIC8vIEVuYWJsZSByZWNvZ25pemVyIGZvciB0aGlzIGV2ZW50LlxuICAgICAgZXZlbnRSZWdpc3RyYXIucmVjb2duaXplck5hbWUgPSBFVkVOVF9SRUNPR05JWkVSX01BUFtldmVudEFsaWFzXSB8fCBldmVudEFsaWFzO1xuICAgICAgLy8gTGlzdGVuIHRvIHRoZSBldmVudFxuICAgICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgICAgbWFuYWdlci5vbihldmVudEFsaWFzLCBldmVudFJlZ2lzdHJhci5oYW5kbGVFdmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGV2ZW50UmVnaXN0cmFyLmFkZChldmVudCwgaGFuZGxlciwgb3B0cywgb25jZSwgcGFzc2l2ZSk7XG4gICAgaWYgKCFldmVudFJlZ2lzdHJhci5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuX3RvZ2dsZVJlY29nbml6ZXIoZXZlbnRSZWdpc3RyYXIucmVjb2duaXplck5hbWUsIHRydWUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgZXZlbnQgZGVyZWdpc3RyYXRpb24gZm9yIGEgc2luZ2xlIGV2ZW50ICsgaGFuZGxlci5cbiAgICovXG4gIF9yZW1vdmVFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgLy8gSWYgYGV2ZW50YCBpcyBhIG1hcCwgY2FsbCBgb2ZmKClgIGZvciBlYWNoIGVudHJ5LlxuICAgICAgZm9yIChjb25zdCBldmVudE5hbWUgaW4gZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRIYW5kbGVyKGV2ZW50TmFtZSwgZXZlbnRbZXZlbnROYW1lXSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGV2ZW50c1xuICAgIH0gPSB0aGlzO1xuICAgIC8vIEFsaWFzIHRvIGEgcmVjb2duaXplZCBnZXN0dXJlIGFzIG5lY2Vzc2FyeS5cbiAgICBjb25zdCBldmVudEFsaWFzID0gR0VTVFVSRV9FVkVOVF9BTElBU0VTW2V2ZW50XSB8fCBldmVudDtcbiAgICBjb25zdCBldmVudFJlZ2lzdHJhciA9IGV2ZW50cy5nZXQoZXZlbnRBbGlhcyk7XG4gICAgaWYgKCFldmVudFJlZ2lzdHJhcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudFJlZ2lzdHJhci5yZW1vdmUoZXZlbnQsIGhhbmRsZXIpO1xuICAgIGlmIChldmVudFJlZ2lzdHJhci5pc0VtcHR5KCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjb2duaXplck5hbWVcbiAgICAgIH0gPSBldmVudFJlZ2lzdHJhcjtcbiAgICAgIC8vIERpc2FibGUgcmVjb2duaXplciBpZiBubyBtb3JlIGhhbmRsZXJzIGFyZSBhdHRhY2hlZCB0byBpdHMgZXZlbnRzXG4gICAgICBsZXQgaXNSZWNvZ25pemVyVXNlZCA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBlaCBvZiBldmVudHMudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKGVoLnJlY29nbml6ZXJOYW1lID09PSByZWNvZ25pemVyTmFtZSAmJiAhZWguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgaXNSZWNvZ25pemVyVXNlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNSZWNvZ25pemVyVXNlZCkge1xuICAgICAgICB0aGlzLl90b2dnbGVSZWNvZ25pemVyKHJlY29nbml6ZXJOYW1lLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59IiwiZXhwb3J0IHsgZGVmYXVsdCBhcyBFdmVudE1hbmFnZXIgfSBmcm9tICcuL2V2ZW50LW1hbmFnZXInOyIsImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuaW1wb3J0IE1hcFN0YXRlIGZyb20gJy4vbWFwLXN0YXRlJztcbmltcG9ydCB7IExpbmVhckludGVycG9sYXRvciB9IGZyb20gJy4vdHJhbnNpdGlvbic7XG5pbXBvcnQgVHJhbnNpdGlvbk1hbmFnZXIsIHsgVFJBTlNJVElPTl9FVkVOVFMgfSBmcm9tICcuL3RyYW5zaXRpb24tbWFuYWdlcic7XG52YXIgTk9fVFJBTlNJVElPTl9QUk9QUyA9IHtcbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiAwXG59O1xuZXhwb3J0IHZhciBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyA9IHtcbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiAzMDAsXG4gIHRyYW5zaXRpb25FYXNpbmc6IGZ1bmN0aW9uIHRyYW5zaXRpb25FYXNpbmcodCkge1xuICAgIHJldHVybiB0O1xuICB9LFxuICB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yOiBuZXcgTGluZWFySW50ZXJwb2xhdG9yKCksXG4gIHRyYW5zaXRpb25JbnRlcnJ1cHRpb246IFRSQU5TSVRJT05fRVZFTlRTLkJSRUFLXG59O1xudmFyIERFRkFVTFRfSU5FUlRJQSA9IDMwMDtcbnZhciBJTkVSVElBX0VBU0lORyA9IGZ1bmN0aW9uIElORVJUSUFfRUFTSU5HKHQpIHtcbiAgcmV0dXJuIDEgLSAoMSAtIHQpICogKDEgLSB0KTtcbn07XG52YXIgRVZFTlRfVFlQRVMgPSB7XG4gIFdIRUVMOiBbJ3doZWVsJ10sXG4gIFBBTjogWydwYW5zdGFydCcsICdwYW5tb3ZlJywgJ3BhbmVuZCddLFxuICBQSU5DSDogWydwaW5jaHN0YXJ0JywgJ3BpbmNobW92ZScsICdwaW5jaGVuZCddLFxuICBUUklQTEVfUEFOOiBbJ3RyaXBhbnN0YXJ0JywgJ3RyaXBhbm1vdmUnLCAndHJpcGFuZW5kJ10sXG4gIERPVUJMRV9UQVA6IFsnZG91YmxldGFwJ10sXG4gIEtFWUJPQVJEOiBbJ2tleWRvd24nXVxufTtcbnZhciBNYXBDb250cm9sbGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXBDb250cm9sbGVyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcENvbnRyb2xsZXIpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV2ZW50c1wiLCBbXSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2Nyb2xsWm9vbVwiLCB0cnVlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkcmFnUGFuXCIsIHRydWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRyYWdSb3RhdGVcIiwgdHJ1ZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZG91YmxlQ2xpY2tab29tXCIsIHRydWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvdWNoWm9vbVwiLCB0cnVlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3VjaFJvdGF0ZVwiLCBmYWxzZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5Ym9hcmRcIiwgdHJ1ZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludGVyYWN0aW9uU3RhdGVcIiwge1xuICAgICAgaXNEcmFnZ2luZzogZmFsc2VcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZXZlbnRzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2V0SW50ZXJhY3Rpb25TdGF0ZVwiLCBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oX3RoaXMuX2ludGVyYWN0aW9uU3RhdGUsIG5ld1N0YXRlKTtcbiAgICAgIGlmIChfdGhpcy5vblN0YXRlQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLm9uU3RhdGVDaGFuZ2UoX3RoaXMuX2ludGVyYWN0aW9uU3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9vblRyYW5zaXRpb25cIiwgZnVuY3Rpb24gKG5ld1ZpZXdwb3J0LCBvbGRWaWV3cG9ydCkge1xuICAgICAgX3RoaXMub25WaWV3cG9ydENoYW5nZShuZXdWaWV3cG9ydCwgX3RoaXMuX2ludGVyYWN0aW9uU3RhdGUsIG9sZFZpZXdwb3J0KTtcbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZUV2ZW50ID0gdGhpcy5oYW5kbGVFdmVudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3RyYW5zaXRpb25NYW5hZ2VyID0gbmV3IFRyYW5zaXRpb25NYW5hZ2VyKHtcbiAgICAgIG9uVmlld3BvcnRDaGFuZ2U6IHRoaXMuX29uVHJhbnNpdGlvbixcbiAgICAgIG9uU3RhdGVDaGFuZ2U6IHRoaXMuX3NldEludGVyYWN0aW9uU3RhdGVcbiAgICB9KTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoTWFwQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwiaGFuZGxlRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgIHRoaXMubWFwU3RhdGUgPSB0aGlzLmdldE1hcFN0YXRlKCk7XG4gICAgICB2YXIgZXZlbnRTdGFydEJsb2NrZWQgPSB0aGlzLl9ldmVudFN0YXJ0QmxvY2tlZDtcbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlICdwYW5zdGFydCc6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50U3RhcnRCbG9ja2VkID8gZmFsc2UgOiB0aGlzLl9vblBhblN0YXJ0KGV2ZW50KTtcbiAgICAgICAgY2FzZSAncGFubW92ZSc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29uUGFuKGV2ZW50KTtcbiAgICAgICAgY2FzZSAncGFuZW5kJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb25QYW5FbmQoZXZlbnQpO1xuICAgICAgICBjYXNlICdwaW5jaHN0YXJ0JzpcbiAgICAgICAgICByZXR1cm4gZXZlbnRTdGFydEJsb2NrZWQgPyBmYWxzZSA6IHRoaXMuX29uUGluY2hTdGFydChldmVudCk7XG4gICAgICAgIGNhc2UgJ3BpbmNobW92ZSc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29uUGluY2goZXZlbnQpO1xuICAgICAgICBjYXNlICdwaW5jaGVuZCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29uUGluY2hFbmQoZXZlbnQpO1xuICAgICAgICBjYXNlICd0cmlwYW5zdGFydCc6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50U3RhcnRCbG9ja2VkID8gZmFsc2UgOiB0aGlzLl9vblRyaXBsZVBhblN0YXJ0KGV2ZW50KTtcbiAgICAgICAgY2FzZSAndHJpcGFubW92ZSc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29uVHJpcGxlUGFuKGV2ZW50KTtcbiAgICAgICAgY2FzZSAndHJpcGFuZW5kJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb25UcmlwbGVQYW5FbmQoZXZlbnQpO1xuICAgICAgICBjYXNlICdkb3VibGV0YXAnOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9vbkRvdWJsZVRhcChldmVudCk7XG4gICAgICAgIGNhc2UgJ3doZWVsJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb25XaGVlbChldmVudCk7XG4gICAgICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9vbktleURvd24oZXZlbnQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENlbnRlcihldmVudCkge1xuICAgICAgdmFyIF9ldmVudCRvZmZzZXRDZW50ZXIgPSBldmVudC5vZmZzZXRDZW50ZXIsXG4gICAgICAgIHggPSBfZXZlbnQkb2Zmc2V0Q2VudGVyLngsXG4gICAgICAgIHkgPSBfZXZlbnQkb2Zmc2V0Q2VudGVyLnk7XG4gICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0Z1bmN0aW9uS2V5UHJlc3NlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Z1bmN0aW9uS2V5UHJlc3NlZChldmVudCkge1xuICAgICAgdmFyIHNyY0V2ZW50ID0gZXZlbnQuc3JjRXZlbnQ7XG4gICAgICByZXR1cm4gQm9vbGVhbihzcmNFdmVudC5tZXRhS2V5IHx8IHNyY0V2ZW50LmFsdEtleSB8fCBzcmNFdmVudC5jdHJsS2V5IHx8IHNyY0V2ZW50LnNoaWZ0S2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmxvY2tFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmxvY2tFdmVudHModGltZW91dCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzMi5fZXZlbnRTdGFydEJsb2NrZWQgPT09IHRpbWVyKSB7XG4gICAgICAgICAgX3RoaXMyLl9ldmVudFN0YXJ0QmxvY2tlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgdGhpcy5fZXZlbnRTdGFydEJsb2NrZWQgPSB0aW1lcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlVmlld3BvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIGV4dHJhUHJvcHMsIGludGVyYWN0aW9uU3RhdGUpIHtcbiAgICAgIHZhciBvbGRWaWV3cG9ydCA9IHRoaXMubWFwU3RhdGUgaW5zdGFuY2VvZiBNYXBTdGF0ZSA/IHRoaXMubWFwU3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpIDogdGhpcy5tYXBTdGF0ZTtcbiAgICAgIHZhciBuZXdWaWV3cG9ydCA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbmV3TWFwU3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpKSwgZXh0cmFQcm9wcyk7XG4gICAgICB2YXIgdmlld1N0YXRlQ2hhbmdlZCA9IE9iamVjdC5rZXlzKG5ld1ZpZXdwb3J0KS5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIG9sZFZpZXdwb3J0W2tleV0gIT09IG5ld1ZpZXdwb3J0W2tleV07XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3N0YXRlID0gbmV3TWFwU3RhdGUuZ2V0U3RhdGUoKTtcbiAgICAgIHRoaXMuX3NldEludGVyYWN0aW9uU3RhdGUoaW50ZXJhY3Rpb25TdGF0ZSk7XG4gICAgICBpZiAodmlld1N0YXRlQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLm9uVmlld3BvcnRDaGFuZ2UobmV3Vmlld3BvcnQsIHRoaXMuX2ludGVyYWN0aW9uU3RhdGUsIG9sZFZpZXdwb3J0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWFwU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWFwU3RhdGUob3ZlcnJpZGVzKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcFN0YXRlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLm1hcFN0YXRlUHJvcHMpLCB0aGlzLl9zdGF0ZSksIG92ZXJyaWRlcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0RyYWdnaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRHJhZ2dpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW50ZXJhY3Rpb25TdGF0ZS5pc0RyYWdnaW5nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdmFyIG9uVmlld3BvcnRDaGFuZ2UgPSBvcHRpb25zLm9uVmlld3BvcnRDaGFuZ2UsXG4gICAgICAgIG9uU3RhdGVDaGFuZ2UgPSBvcHRpb25zLm9uU3RhdGVDaGFuZ2UsXG4gICAgICAgIF9vcHRpb25zJGV2ZW50TWFuYWdlciA9IG9wdGlvbnMuZXZlbnRNYW5hZ2VyLFxuICAgICAgICBldmVudE1hbmFnZXIgPSBfb3B0aW9ucyRldmVudE1hbmFnZXIgPT09IHZvaWQgMCA/IHRoaXMuZXZlbnRNYW5hZ2VyIDogX29wdGlvbnMkZXZlbnRNYW5hZ2VyLFxuICAgICAgICBfb3B0aW9ucyRpc0ludGVyYWN0aXYgPSBvcHRpb25zLmlzSW50ZXJhY3RpdmUsXG4gICAgICAgIGlzSW50ZXJhY3RpdmUgPSBfb3B0aW9ucyRpc0ludGVyYWN0aXYgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRpc0ludGVyYWN0aXYsXG4gICAgICAgIF9vcHRpb25zJHNjcm9sbFpvb20gPSBvcHRpb25zLnNjcm9sbFpvb20sXG4gICAgICAgIHNjcm9sbFpvb20gPSBfb3B0aW9ucyRzY3JvbGxab29tID09PSB2b2lkIDAgPyB0aGlzLnNjcm9sbFpvb20gOiBfb3B0aW9ucyRzY3JvbGxab29tLFxuICAgICAgICBfb3B0aW9ucyRkcmFnUGFuID0gb3B0aW9ucy5kcmFnUGFuLFxuICAgICAgICBkcmFnUGFuID0gX29wdGlvbnMkZHJhZ1BhbiA9PT0gdm9pZCAwID8gdGhpcy5kcmFnUGFuIDogX29wdGlvbnMkZHJhZ1BhbixcbiAgICAgICAgX29wdGlvbnMkZHJhZ1JvdGF0ZSA9IG9wdGlvbnMuZHJhZ1JvdGF0ZSxcbiAgICAgICAgZHJhZ1JvdGF0ZSA9IF9vcHRpb25zJGRyYWdSb3RhdGUgPT09IHZvaWQgMCA/IHRoaXMuZHJhZ1JvdGF0ZSA6IF9vcHRpb25zJGRyYWdSb3RhdGUsXG4gICAgICAgIF9vcHRpb25zJGRvdWJsZUNsaWNrWiA9IG9wdGlvbnMuZG91YmxlQ2xpY2tab29tLFxuICAgICAgICBkb3VibGVDbGlja1pvb20gPSBfb3B0aW9ucyRkb3VibGVDbGlja1ogPT09IHZvaWQgMCA/IHRoaXMuZG91YmxlQ2xpY2tab29tIDogX29wdGlvbnMkZG91YmxlQ2xpY2taLFxuICAgICAgICBfb3B0aW9ucyR0b3VjaFpvb20gPSBvcHRpb25zLnRvdWNoWm9vbSxcbiAgICAgICAgdG91Y2hab29tID0gX29wdGlvbnMkdG91Y2hab29tID09PSB2b2lkIDAgPyB0aGlzLnRvdWNoWm9vbSA6IF9vcHRpb25zJHRvdWNoWm9vbSxcbiAgICAgICAgX29wdGlvbnMkdG91Y2hSb3RhdGUgPSBvcHRpb25zLnRvdWNoUm90YXRlLFxuICAgICAgICB0b3VjaFJvdGF0ZSA9IF9vcHRpb25zJHRvdWNoUm90YXRlID09PSB2b2lkIDAgPyB0aGlzLnRvdWNoUm90YXRlIDogX29wdGlvbnMkdG91Y2hSb3RhdGUsXG4gICAgICAgIF9vcHRpb25zJGtleWJvYXJkID0gb3B0aW9ucy5rZXlib2FyZCxcbiAgICAgICAga2V5Ym9hcmQgPSBfb3B0aW9ucyRrZXlib2FyZCA9PT0gdm9pZCAwID8gdGhpcy5rZXlib2FyZCA6IF9vcHRpb25zJGtleWJvYXJkO1xuICAgICAgdGhpcy5vblZpZXdwb3J0Q2hhbmdlID0gb25WaWV3cG9ydENoYW5nZTtcbiAgICAgIHRoaXMub25TdGF0ZUNoYW5nZSA9IG9uU3RhdGVDaGFuZ2U7XG4gICAgICB2YXIgcHJldk9wdGlvbnMgPSB0aGlzLm1hcFN0YXRlUHJvcHMgfHwge307XG4gICAgICB2YXIgZGltZW5zaW9uQ2hhbmdlZCA9IHByZXZPcHRpb25zLmhlaWdodCAhPT0gb3B0aW9ucy5oZWlnaHQgfHwgcHJldk9wdGlvbnMud2lkdGggIT09IG9wdGlvbnMud2lkdGg7XG4gICAgICB0aGlzLm1hcFN0YXRlUHJvcHMgPSBvcHRpb25zO1xuICAgICAgaWYgKGRpbWVuc2lvbkNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5tYXBTdGF0ZSA9IHByZXZPcHRpb25zO1xuICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ldyBNYXBTdGF0ZShvcHRpb25zKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl90cmFuc2l0aW9uTWFuYWdlci5wcm9jZXNzVmlld3BvcnRDaGFuZ2Uob3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5ldmVudE1hbmFnZXIgIT09IGV2ZW50TWFuYWdlcikge1xuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgICAgIHRoaXMudG9nZ2xlRXZlbnRzKHRoaXMuZXZlbnRzLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLldIRUVMLCBpc0ludGVyYWN0aXZlICYmIEJvb2xlYW4oc2Nyb2xsWm9vbSkpO1xuICAgICAgdGhpcy50b2dnbGVFdmVudHMoRVZFTlRfVFlQRVMuUEFOLCBpc0ludGVyYWN0aXZlICYmIEJvb2xlYW4oZHJhZ1BhbiB8fCBkcmFnUm90YXRlKSk7XG4gICAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5QSU5DSCwgaXNJbnRlcmFjdGl2ZSAmJiBCb29sZWFuKHRvdWNoWm9vbSB8fCB0b3VjaFJvdGF0ZSkpO1xuICAgICAgdGhpcy50b2dnbGVFdmVudHMoRVZFTlRfVFlQRVMuVFJJUExFX1BBTiwgaXNJbnRlcmFjdGl2ZSAmJiBCb29sZWFuKHRvdWNoUm90YXRlKSk7XG4gICAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5ET1VCTEVfVEFQLCBpc0ludGVyYWN0aXZlICYmIEJvb2xlYW4oZG91YmxlQ2xpY2tab29tKSk7XG4gICAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5LRVlCT0FSRCwgaXNJbnRlcmFjdGl2ZSAmJiBCb29sZWFuKGtleWJvYXJkKSk7XG4gICAgICB0aGlzLnNjcm9sbFpvb20gPSBzY3JvbGxab29tO1xuICAgICAgdGhpcy5kcmFnUGFuID0gZHJhZ1BhbjtcbiAgICAgIHRoaXMuZHJhZ1JvdGF0ZSA9IGRyYWdSb3RhdGU7XG4gICAgICB0aGlzLmRvdWJsZUNsaWNrWm9vbSA9IGRvdWJsZUNsaWNrWm9vbTtcbiAgICAgIHRoaXMudG91Y2hab29tID0gdG91Y2hab29tO1xuICAgICAgdGhpcy50b3VjaFJvdGF0ZSA9IHRvdWNoUm90YXRlO1xuICAgICAgdGhpcy5rZXlib2FyZCA9IGtleWJvYXJkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlRXZlbnRzKGV2ZW50TmFtZXMsIGVuYWJsZWQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuZXZlbnRNYW5hZ2VyKSB7XG4gICAgICAgIGV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgaWYgKF90aGlzMy5fZXZlbnRzW2V2ZW50TmFtZV0gIT09IGVuYWJsZWQpIHtcbiAgICAgICAgICAgIF90aGlzMy5fZXZlbnRzW2V2ZW50TmFtZV0gPSBlbmFibGVkO1xuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmV2ZW50TWFuYWdlci5vbihldmVudE5hbWUsIF90aGlzMy5oYW5kbGVFdmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpczMuZXZlbnRNYW5hZ2VyLm9mZihldmVudE5hbWUsIF90aGlzMy5oYW5kbGVFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uUGFuU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUGFuU3RhcnQoZXZlbnQpIHtcbiAgICAgIHZhciBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgICB0aGlzLl9wYW5Sb3RhdGUgPSB0aGlzLmlzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KSB8fCBldmVudC5yaWdodEJ1dHRvbjtcbiAgICAgIHZhciBuZXdNYXBTdGF0ZSA9IHRoaXMuX3BhblJvdGF0ZSA/IHRoaXMubWFwU3RhdGUucm90YXRlU3RhcnQoe1xuICAgICAgICBwb3M6IHBvc1xuICAgICAgfSkgOiB0aGlzLm1hcFN0YXRlLnBhblN0YXJ0KHtcbiAgICAgICAgcG9zOiBwb3NcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgTk9fVFJBTlNJVElPTl9QUk9QUywge1xuICAgICAgICBpc0RyYWdnaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25QYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUGFuKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9wYW5Sb3RhdGUgPyB0aGlzLl9vblBhblJvdGF0ZShldmVudCkgOiB0aGlzLl9vblBhbk1vdmUoZXZlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25QYW5FbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUGFuRW5kKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9wYW5Sb3RhdGUgPyB0aGlzLl9vblBhblJvdGF0ZUVuZChldmVudCkgOiB0aGlzLl9vblBhbk1vdmVFbmQoZXZlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25QYW5Nb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblBhbk1vdmUoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5kcmFnUGFuKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnBhbih7XG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIE5PX1RSQU5TSVRJT05fUFJPUFMsIHtcbiAgICAgICAgaXNQYW5uaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25QYW5Nb3ZlRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblBhbk1vdmVFbmQoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLmRyYWdQYW4pIHtcbiAgICAgICAgdmFyIF90aGlzJGRyYWdQYW4kaW5lcnRpYSA9IHRoaXMuZHJhZ1Bhbi5pbmVydGlhLFxuICAgICAgICAgIGluZXJ0aWEgPSBfdGhpcyRkcmFnUGFuJGluZXJ0aWEgPT09IHZvaWQgMCA/IERFRkFVTFRfSU5FUlRJQSA6IF90aGlzJGRyYWdQYW4kaW5lcnRpYTtcbiAgICAgICAgaWYgKGluZXJ0aWEgJiYgZXZlbnQudmVsb2NpdHkpIHtcbiAgICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgICAgICAgIHZhciBlbmRQb3MgPSBbcG9zWzBdICsgZXZlbnQudmVsb2NpdHlYICogaW5lcnRpYSAvIDIsIHBvc1sxXSArIGV2ZW50LnZlbG9jaXR5WSAqIGluZXJ0aWEgLyAyXTtcbiAgICAgICAgICB2YXIgbmV3Q29udHJvbGxlclN0YXRlID0gdGhpcy5tYXBTdGF0ZS5wYW4oe1xuICAgICAgICAgICAgcG9zOiBlbmRQb3NcbiAgICAgICAgICB9KS5wYW5FbmQoKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld0NvbnRyb2xsZXJTdGF0ZSwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyksIHt9LCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGluZXJ0aWEsXG4gICAgICAgICAgICB0cmFuc2l0aW9uRWFzaW5nOiBJTkVSVElBX0VBU0lOR1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUGFubmluZzogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnBhbkVuZCgpO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgbnVsbCwge1xuICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgaXNQYW5uaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uUGFuUm90YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblBhblJvdGF0ZShldmVudCkge1xuICAgICAgaWYgKCF0aGlzLmRyYWdSb3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgIHZhciBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucm90YXRlKHtcbiAgICAgICAgcG9zOiBwb3NcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgTk9fVFJBTlNJVElPTl9QUk9QUywge1xuICAgICAgICBpc1JvdGF0aW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25QYW5Sb3RhdGVFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUGFuUm90YXRlRW5kKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5kcmFnUm90YXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyRkcmFnUm90YXRlJGluZXIgPSB0aGlzLmRyYWdSb3RhdGUuaW5lcnRpYSxcbiAgICAgICAgICBpbmVydGlhID0gX3RoaXMkZHJhZ1JvdGF0ZSRpbmVyID09PSB2b2lkIDAgPyBERUZBVUxUX0lORVJUSUEgOiBfdGhpcyRkcmFnUm90YXRlJGluZXI7XG4gICAgICAgIGlmIChpbmVydGlhICYmIGV2ZW50LnZlbG9jaXR5KSB7XG4gICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgICAgICB2YXIgZW5kUG9zID0gW3Bvc1swXSArIGV2ZW50LnZlbG9jaXR5WCAqIGluZXJ0aWEgLyAyLCBwb3NbMV0gKyBldmVudC52ZWxvY2l0eVkgKiBpbmVydGlhIC8gMl07XG4gICAgICAgICAgdmFyIG5ld0NvbnRyb2xsZXJTdGF0ZSA9IHRoaXMubWFwU3RhdGUucm90YXRlKHtcbiAgICAgICAgICAgIHBvczogZW5kUG9zXG4gICAgICAgICAgfSkucm90YXRlRW5kKCk7XG4gICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdDb250cm9sbGVyU3RhdGUsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgTElORUFSX1RSQU5TSVRJT05fUFJPUFMpLCB7fSwge1xuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBpbmVydGlhLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkVhc2luZzogSU5FUlRJQV9FQVNJTkdcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICBpc1JvdGF0aW5nOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucGFuRW5kKCk7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlLCBudWxsLCB7XG4gICAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICBpc1JvdGF0aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uV2hlZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uV2hlZWwoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5zY3JvbGxab29tKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBfdGhpcyRzY3JvbGxab29tID0gdGhpcy5zY3JvbGxab29tLFxuICAgICAgICBfdGhpcyRzY3JvbGxab29tJHNwZWUgPSBfdGhpcyRzY3JvbGxab29tLnNwZWVkLFxuICAgICAgICBzcGVlZCA9IF90aGlzJHNjcm9sbFpvb20kc3BlZSA9PT0gdm9pZCAwID8gMC4wMSA6IF90aGlzJHNjcm9sbFpvb20kc3BlZSxcbiAgICAgICAgX3RoaXMkc2Nyb2xsWm9vbSRzbW9vID0gX3RoaXMkc2Nyb2xsWm9vbS5zbW9vdGgsXG4gICAgICAgIHNtb290aCA9IF90aGlzJHNjcm9sbFpvb20kc21vbyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfdGhpcyRzY3JvbGxab29tJHNtb287XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgIHZhciBkZWx0YSA9IGV2ZW50LmRlbHRhO1xuICAgICAgdmFyIHNjYWxlID0gMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGRlbHRhICogc3BlZWQpKSk7XG4gICAgICBpZiAoZGVsdGEgPCAwICYmIHNjYWxlICE9PSAwKSB7XG4gICAgICAgIHNjYWxlID0gMSAvIHNjYWxlO1xuICAgICAgfVxuICAgICAgdmFyIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS56b29tKHtcbiAgICAgICAgcG9zOiBwb3MsXG4gICAgICAgIHNjYWxlOiBzY2FsZVxuICAgICAgfSk7XG4gICAgICBpZiAobmV3TWFwU3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpLnpvb20gPT09IHRoaXMubWFwU3RhdGVQcm9wcy56b29tKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgTElORUFSX1RSQU5TSVRJT05fUFJPUFMpLCB7fSwge1xuICAgICAgICB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yOiBuZXcgTGluZWFySW50ZXJwb2xhdG9yKHtcbiAgICAgICAgICBhcm91bmQ6IHBvc1xuICAgICAgICB9KSxcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBzbW9vdGggPyAyNTAgOiAxXG4gICAgICB9KSwge1xuICAgICAgICBpc1Bhbm5pbmc6IHRydWUsXG4gICAgICAgIGlzWm9vbWluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uUGluY2hTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25QaW5jaFN0YXJ0KGV2ZW50KSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgICAgdmFyIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS56b29tU3RhcnQoe1xuICAgICAgICBwb3M6IHBvc1xuICAgICAgfSkucm90YXRlU3RhcnQoe1xuICAgICAgICBwb3M6IHBvc1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zdGFydFBpbmNoUm90YXRpb24gPSBldmVudC5yb3RhdGlvbjtcbiAgICAgIHRoaXMuX2xhc3RQaW5jaEV2ZW50ID0gZXZlbnQ7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlLCBOT19UUkFOU0lUSU9OX1BST1BTLCB7XG4gICAgICAgIGlzRHJhZ2dpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblBpbmNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblBpbmNoKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy50b3VjaFpvb20gJiYgIXRoaXMudG91Y2hSb3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZTtcbiAgICAgIGlmICh0aGlzLnRvdWNoWm9vbSkge1xuICAgICAgICB2YXIgc2NhbGUgPSBldmVudC5zY2FsZTtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgICAgbmV3TWFwU3RhdGUgPSBuZXdNYXBTdGF0ZS56b29tKHtcbiAgICAgICAgICBwb3M6IHBvcyxcbiAgICAgICAgICBzY2FsZTogc2NhbGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50b3VjaFJvdGF0ZSkge1xuICAgICAgICB2YXIgcm90YXRpb24gPSBldmVudC5yb3RhdGlvbjtcbiAgICAgICAgbmV3TWFwU3RhdGUgPSBuZXdNYXBTdGF0ZS5yb3RhdGUoe1xuICAgICAgICAgIGRlbHRhQW5nbGVYOiB0aGlzLl9zdGFydFBpbmNoUm90YXRpb24gLSByb3RhdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIE5PX1RSQU5TSVRJT05fUFJPUFMsIHtcbiAgICAgICAgaXNEcmFnZ2luZzogdHJ1ZSxcbiAgICAgICAgaXNQYW5uaW5nOiBCb29sZWFuKHRoaXMudG91Y2hab29tKSxcbiAgICAgICAgaXNab29taW5nOiBCb29sZWFuKHRoaXMudG91Y2hab29tKSxcbiAgICAgICAgaXNSb3RhdGluZzogQm9vbGVhbih0aGlzLnRvdWNoUm90YXRlKVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9sYXN0UGluY2hFdmVudCA9IGV2ZW50O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblBpbmNoRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblBpbmNoRW5kKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRvdWNoWm9vbSkge1xuICAgICAgICB2YXIgX3RoaXMkdG91Y2hab29tJGluZXJ0ID0gdGhpcy50b3VjaFpvb20uaW5lcnRpYSxcbiAgICAgICAgICBpbmVydGlhID0gX3RoaXMkdG91Y2hab29tJGluZXJ0ID09PSB2b2lkIDAgPyBERUZBVUxUX0lORVJUSUEgOiBfdGhpcyR0b3VjaFpvb20kaW5lcnQ7XG4gICAgICAgIHZhciBfbGFzdFBpbmNoRXZlbnQgPSB0aGlzLl9sYXN0UGluY2hFdmVudDtcbiAgICAgICAgaWYgKGluZXJ0aWEgJiYgX2xhc3RQaW5jaEV2ZW50ICYmIGV2ZW50LnNjYWxlICE9PSBfbGFzdFBpbmNoRXZlbnQuc2NhbGUpIHtcbiAgICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgICAgICAgIHZhciBfbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnJvdGF0ZUVuZCgpO1xuICAgICAgICAgIHZhciB6ID0gTWF0aC5sb2cyKGV2ZW50LnNjYWxlKTtcbiAgICAgICAgICB2YXIgdmVsb2NpdHlaID0gKHogLSBNYXRoLmxvZzIoX2xhc3RQaW5jaEV2ZW50LnNjYWxlKSkgLyAoZXZlbnQuZGVsdGFUaW1lIC0gX2xhc3RQaW5jaEV2ZW50LmRlbHRhVGltZSk7XG4gICAgICAgICAgdmFyIGVuZFNjYWxlID0gTWF0aC5wb3coMiwgeiArIHZlbG9jaXR5WiAqIGluZXJ0aWEgLyAyKTtcbiAgICAgICAgICBfbmV3TWFwU3RhdGUgPSBfbmV3TWFwU3RhdGUuem9vbSh7XG4gICAgICAgICAgICBwb3M6IHBvcyxcbiAgICAgICAgICAgIHNjYWxlOiBlbmRTY2FsZVxuICAgICAgICAgIH0pLnpvb21FbmQoKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KF9uZXdNYXBTdGF0ZSwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyksIHt9LCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yOiBuZXcgTGluZWFySW50ZXJwb2xhdG9yKHtcbiAgICAgICAgICAgICAgYXJvdW5kOiBwb3NcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBpbmVydGlhLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkVhc2luZzogSU5FUlRJQV9FQVNJTkdcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICBpc1Bhbm5pbmc6IEJvb2xlYW4odGhpcy50b3VjaFpvb20pLFxuICAgICAgICAgICAgaXNab29taW5nOiBCb29sZWFuKHRoaXMudG91Y2hab29tKSxcbiAgICAgICAgICAgIGlzUm90YXRpbmc6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5ibG9ja0V2ZW50cyhpbmVydGlhKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS56b29tRW5kKCkucm90YXRlRW5kKCk7XG4gICAgICB0aGlzLl9zdGF0ZS5zdGFydFBpbmNoUm90YXRpb24gPSAwO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgbnVsbCwge1xuICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgaXNQYW5uaW5nOiBmYWxzZSxcbiAgICAgICAgaXNab29taW5nOiBmYWxzZSxcbiAgICAgICAgaXNSb3RhdGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc3RhcnRQaW5jaFJvdGF0aW9uID0gbnVsbDtcbiAgICAgIHRoaXMuX2xhc3RQaW5jaEV2ZW50ID0gbnVsbDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25UcmlwbGVQYW5TdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25UcmlwbGVQYW5TdGFydChldmVudCkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgIHZhciBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucm90YXRlU3RhcnQoe1xuICAgICAgICBwb3M6IHBvc1xuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlLCBOT19UUkFOU0lUSU9OX1BST1BTLCB7XG4gICAgICAgIGlzRHJhZ2dpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblRyaXBsZVBhblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25UcmlwbGVQYW4oZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnRvdWNoUm90YXRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgICBwb3NbMF0gLT0gZXZlbnQuZGVsdGFYO1xuICAgICAgdmFyIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS5yb3RhdGUoe1xuICAgICAgICBwb3M6IHBvc1xuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlLCBOT19UUkFOU0lUSU9OX1BST1BTLCB7XG4gICAgICAgIGlzUm90YXRpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblRyaXBsZVBhbkVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25UcmlwbGVQYW5FbmQoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudG91Y2hSb3RhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzJHRvdWNoUm90YXRlJGluZSA9IHRoaXMudG91Y2hSb3RhdGUuaW5lcnRpYSxcbiAgICAgICAgICBpbmVydGlhID0gX3RoaXMkdG91Y2hSb3RhdGUkaW5lID09PSB2b2lkIDAgPyBERUZBVUxUX0lORVJUSUEgOiBfdGhpcyR0b3VjaFJvdGF0ZSRpbmU7XG4gICAgICAgIGlmIChpbmVydGlhICYmIGV2ZW50LnZlbG9jaXR5WSkge1xuICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgICAgICAgdmFyIGVuZFBvcyA9IFtwb3NbMF0sIHBvc1sxXSArPSBldmVudC52ZWxvY2l0eVkgKiBpbmVydGlhIC8gMl07XG4gICAgICAgICAgdmFyIF9uZXdNYXBTdGF0ZTIgPSB0aGlzLm1hcFN0YXRlLnJvdGF0ZSh7XG4gICAgICAgICAgICBwb3M6IGVuZFBvc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQoX25ld01hcFN0YXRlMiwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyksIHt9LCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGluZXJ0aWEsXG4gICAgICAgICAgICB0cmFuc2l0aW9uRWFzaW5nOiBJTkVSVElBX0VBU0lOR1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUm90YXRpbmc6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmJsb2NrRXZlbnRzKGluZXJ0aWEpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS5yb3RhdGVFbmQoKTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIG51bGwsIHtcbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIGlzUm90YXRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25Eb3VibGVUYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRG91YmxlVGFwKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuZG91YmxlQ2xpY2tab29tKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgICB2YXIgaXNab29tT3V0ID0gdGhpcy5pc0Z1bmN0aW9uS2V5UHJlc3NlZChldmVudCk7XG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnpvb20oe1xuICAgICAgICBwb3M6IHBvcyxcbiAgICAgICAgc2NhbGU6IGlzWm9vbU91dCA/IDAuNSA6IDJcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgT2JqZWN0LmFzc2lnbih7fSwgTElORUFSX1RSQU5TSVRJT05fUFJPUFMsIHtcbiAgICAgICAgdHJhbnNpdGlvbkludGVycG9sYXRvcjogbmV3IExpbmVhckludGVycG9sYXRvcih7XG4gICAgICAgICAgYXJvdW5kOiBwb3NcbiAgICAgICAgfSlcbiAgICAgIH0pLCB7XG4gICAgICAgIGlzWm9vbWluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uS2V5RG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMua2V5Ym9hcmQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGZ1bmNLZXkgPSB0aGlzLmlzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KTtcbiAgICAgIHZhciBfdGhpcyRrZXlib2FyZCA9IHRoaXMua2V5Ym9hcmQsXG4gICAgICAgIF90aGlzJGtleWJvYXJkJHpvb21TcCA9IF90aGlzJGtleWJvYXJkLnpvb21TcGVlZCxcbiAgICAgICAgem9vbVNwZWVkID0gX3RoaXMka2V5Ym9hcmQkem9vbVNwID09PSB2b2lkIDAgPyAyIDogX3RoaXMka2V5Ym9hcmQkem9vbVNwLFxuICAgICAgICBfdGhpcyRrZXlib2FyZCRtb3ZlU3AgPSBfdGhpcyRrZXlib2FyZC5tb3ZlU3BlZWQsXG4gICAgICAgIG1vdmVTcGVlZCA9IF90aGlzJGtleWJvYXJkJG1vdmVTcCA9PT0gdm9pZCAwID8gMTAwIDogX3RoaXMka2V5Ym9hcmQkbW92ZVNwLFxuICAgICAgICBfdGhpcyRrZXlib2FyZCRyb3RhdGUgPSBfdGhpcyRrZXlib2FyZC5yb3RhdGVTcGVlZFgsXG4gICAgICAgIHJvdGF0ZVNwZWVkWCA9IF90aGlzJGtleWJvYXJkJHJvdGF0ZSA9PT0gdm9pZCAwID8gMTUgOiBfdGhpcyRrZXlib2FyZCRyb3RhdGUsXG4gICAgICAgIF90aGlzJGtleWJvYXJkJHJvdGF0ZTIgPSBfdGhpcyRrZXlib2FyZC5yb3RhdGVTcGVlZFksXG4gICAgICAgIHJvdGF0ZVNwZWVkWSA9IF90aGlzJGtleWJvYXJkJHJvdGF0ZTIgPT09IHZvaWQgMCA/IDEwIDogX3RoaXMka2V5Ym9hcmQkcm90YXRlMjtcbiAgICAgIHZhciBtYXBTdGF0ZVByb3BzID0gdGhpcy5tYXBTdGF0ZVByb3BzO1xuICAgICAgdmFyIG5ld01hcFN0YXRlO1xuICAgICAgc3dpdGNoIChldmVudC5zcmNFdmVudC5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgMTg5OlxuICAgICAgICAgIGlmIChmdW5jS2V5KSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMuZ2V0TWFwU3RhdGUoe1xuICAgICAgICAgICAgICB6b29tOiBtYXBTdGF0ZVByb3BzLnpvb20gLSBNYXRoLmxvZzIoem9vbVNwZWVkKSAtIDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMuZ2V0TWFwU3RhdGUoe1xuICAgICAgICAgICAgICB6b29tOiBtYXBTdGF0ZVByb3BzLnpvb20gLSBNYXRoLmxvZzIoem9vbVNwZWVkKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE4NzpcbiAgICAgICAgICBpZiAoZnVuY0tleSkge1xuICAgICAgICAgICAgbmV3TWFwU3RhdGUgPSB0aGlzLmdldE1hcFN0YXRlKHtcbiAgICAgICAgICAgICAgem9vbTogbWFwU3RhdGVQcm9wcy56b29tICsgTWF0aC5sb2cyKHpvb21TcGVlZCkgKyAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TWFwU3RhdGUgPSB0aGlzLmdldE1hcFN0YXRlKHtcbiAgICAgICAgICAgICAgem9vbTogbWFwU3RhdGVQcm9wcy56b29tICsgTWF0aC5sb2cyKHpvb21TcGVlZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICBpZiAoZnVuY0tleSkge1xuICAgICAgICAgICAgbmV3TWFwU3RhdGUgPSB0aGlzLmdldE1hcFN0YXRlKHtcbiAgICAgICAgICAgICAgYmVhcmluZzogbWFwU3RhdGVQcm9wcy5iZWFyaW5nIC0gcm90YXRlU3BlZWRYXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnBhbih7XG4gICAgICAgICAgICAgIHBvczogW21vdmVTcGVlZCwgMF0sXG4gICAgICAgICAgICAgIHN0YXJ0UG9zOiBbMCwgMF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICBpZiAoZnVuY0tleSkge1xuICAgICAgICAgICAgbmV3TWFwU3RhdGUgPSB0aGlzLmdldE1hcFN0YXRlKHtcbiAgICAgICAgICAgICAgYmVhcmluZzogbWFwU3RhdGVQcm9wcy5iZWFyaW5nICsgcm90YXRlU3BlZWRYXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnBhbih7XG4gICAgICAgICAgICAgIHBvczogWy1tb3ZlU3BlZWQsIDBdLFxuICAgICAgICAgICAgICBzdGFydFBvczogWzAsIDBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgaWYgKGZ1bmNLZXkpIHtcbiAgICAgICAgICAgIG5ld01hcFN0YXRlID0gdGhpcy5nZXRNYXBTdGF0ZSh7XG4gICAgICAgICAgICAgIHBpdGNoOiBtYXBTdGF0ZVByb3BzLnBpdGNoICsgcm90YXRlU3BlZWRZXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnBhbih7XG4gICAgICAgICAgICAgIHBvczogWzAsIG1vdmVTcGVlZF0sXG4gICAgICAgICAgICAgIHN0YXJ0UG9zOiBbMCwgMF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICBpZiAoZnVuY0tleSkge1xuICAgICAgICAgICAgbmV3TWFwU3RhdGUgPSB0aGlzLmdldE1hcFN0YXRlKHtcbiAgICAgICAgICAgICAgcGl0Y2g6IG1hcFN0YXRlUHJvcHMucGl0Y2ggLSByb3RhdGVTcGVlZFlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucGFuKHtcbiAgICAgICAgICAgICAgcG9zOiBbMCwgLW1vdmVTcGVlZF0sXG4gICAgICAgICAgICAgIHN0YXJ0UG9zOiBbMCwgMF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgTElORUFSX1RSQU5TSVRJT05fUFJPUFMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTWFwQ29udHJvbGxlcjtcbn0oKTtcbmV4cG9ydCB7IE1hcENvbnRyb2xsZXIgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXlcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZVJlZiwgdXNlTWVtbywgdXNlRWZmZWN0LCB1c2VJbXBlcmF0aXZlSGFuZGxlLCBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFN0YXRpY01hcCwgeyBnZXRWaWV3cG9ydCB9IGZyb20gJy4vc3RhdGljLW1hcCc7XG5pbXBvcnQgeyBNQVBCT1hfTElNSVRTIH0gZnJvbSAnLi4vdXRpbHMvbWFwLXN0YXRlJztcbmltcG9ydCBUcmFuc2l0aW9uTWFuYWdlciBmcm9tICcuLi91dGlscy90cmFuc2l0aW9uLW1hbmFnZXInO1xuaW1wb3J0IE1hcENvbnRleHQsIHsgTWFwQ29udGV4dFByb3ZpZGVyIH0gZnJvbSAnLi9tYXAtY29udGV4dCc7XG5pbXBvcnQgeyBFdmVudE1hbmFnZXIgfSBmcm9tICdtam9sbmlyLmpzJztcbmltcG9ydCBNYXBDb250cm9sbGVyIGZyb20gJy4uL3V0aWxzL21hcC1jb250cm9sbGVyJztcbmltcG9ydCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IGZyb20gJy4uL3V0aWxzL3VzZS1pc29tb3JwaGljLWxheW91dC1lZmZlY3QnO1xuaW1wb3J0IHsgZ2V0VGVycmFpbkVsZXZhdGlvbiB9IGZyb20gJy4uL3V0aWxzL3RlcnJhaW4nO1xudmFyIHByb3BUeXBlcyA9IE9iamVjdC5hc3NpZ24oe30sIFN0YXRpY01hcC5wcm9wVHlwZXMsIHtcbiAgbWF4Wm9vbTogUHJvcFR5cGVzLm51bWJlcixcbiAgbWluWm9vbTogUHJvcFR5cGVzLm51bWJlcixcbiAgbWF4UGl0Y2g6IFByb3BUeXBlcy5udW1iZXIsXG4gIG1pblBpdGNoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvblZpZXdTdGF0ZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uVmlld3BvcnRDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICBvbkludGVyYWN0aW9uU3RhdGVDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICB0cmFuc2l0aW9uRHVyYXRpb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgdHJhbnNpdGlvbkludGVycG9sYXRvcjogUHJvcFR5cGVzLm9iamVjdCxcbiAgdHJhbnNpdGlvbkludGVycnVwdGlvbjogUHJvcFR5cGVzLm51bWJlcixcbiAgdHJhbnNpdGlvbkVhc2luZzogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uVHJhbnNpdGlvblN0YXJ0OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25UcmFuc2l0aW9uSW50ZXJydXB0OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25UcmFuc2l0aW9uRW5kOiBQcm9wVHlwZXMuZnVuYyxcbiAgc2Nyb2xsWm9vbTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgZHJhZ1BhbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgZHJhZ1JvdGF0ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgZG91YmxlQ2xpY2tab29tOiBQcm9wVHlwZXMuYm9vbCxcbiAgdG91Y2hab29tOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICB0b3VjaFJvdGF0ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAga2V5Ym9hcmQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMub2JqZWN0XSksXG4gIG9uSG92ZXI6IFByb3BUeXBlcy5mdW5jLFxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25EYmxDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uQ29udGV4dE1lbnU6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlRG93bjogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uTW91c2VNb3ZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZVVwOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Ub3VjaFN0YXJ0OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Ub3VjaE1vdmU6IFByb3BUeXBlcy5mdW5jLFxuICBvblRvdWNoRW5kOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZUVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZU91dDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uV2hlZWw6IFByb3BUeXBlcy5mdW5jLFxuICB0b3VjaEFjdGlvbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgZXZlbnRSZWNvZ25pemVyT3B0aW9uczogUHJvcFR5cGVzLm9iamVjdCxcbiAgY2xpY2tSYWRpdXM6IFByb3BUeXBlcy5udW1iZXIsXG4gIGludGVyYWN0aXZlTGF5ZXJJZHM6IFByb3BUeXBlcy5hcnJheSxcbiAgZ2V0Q3Vyc29yOiBQcm9wVHlwZXMuZnVuYyxcbiAgY29udHJvbGxlcjogUHJvcFR5cGVzLmluc3RhbmNlT2YoTWFwQ29udHJvbGxlcilcbn0pO1xudmFyIGdldERlZmF1bHRDdXJzb3IgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q3Vyc29yKF9yZWYpIHtcbiAgdmFyIGlzRHJhZ2dpbmcgPSBfcmVmLmlzRHJhZ2dpbmcsXG4gICAgaXNIb3ZlcmluZyA9IF9yZWYuaXNIb3ZlcmluZztcbiAgcmV0dXJuIGlzRHJhZ2dpbmcgPyAnZ3JhYmJpbmcnIDogaXNIb3ZlcmluZyA/ICdwb2ludGVyJyA6ICdncmFiJztcbn07XG52YXIgZGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgU3RhdGljTWFwLmRlZmF1bHRQcm9wcywgTUFQQk9YX0xJTUlUUywgVHJhbnNpdGlvbk1hbmFnZXIuZGVmYXVsdFByb3BzLCB7XG4gIG9uVmlld1N0YXRlQ2hhbmdlOiBudWxsLFxuICBvblZpZXdwb3J0Q2hhbmdlOiBudWxsLFxuICBvbkNsaWNrOiBudWxsLFxuICBvbk5hdGl2ZUNsaWNrOiBudWxsLFxuICBvbkhvdmVyOiBudWxsLFxuICBvbkNvbnRleHRNZW51OiBmdW5jdGlvbiBvbkNvbnRleHRNZW51KGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH0sXG4gIHNjcm9sbFpvb206IHRydWUsXG4gIGRyYWdQYW46IHRydWUsXG4gIGRyYWdSb3RhdGU6IHRydWUsXG4gIGRvdWJsZUNsaWNrWm9vbTogdHJ1ZSxcbiAgdG91Y2hab29tOiB0cnVlLFxuICB0b3VjaFJvdGF0ZTogZmFsc2UsXG4gIGtleWJvYXJkOiB0cnVlLFxuICB0b3VjaEFjdGlvbjogJ25vbmUnLFxuICBldmVudFJlY29nbml6ZXJPcHRpb25zOiB7fSxcbiAgY2xpY2tSYWRpdXM6IDAsXG4gIGdldEN1cnNvcjogZ2V0RGVmYXVsdEN1cnNvclxufSk7XG5mdW5jdGlvbiBub3JtYWxpemVFdmVudChldmVudCkge1xuICBpZiAoZXZlbnQubG5nTGF0IHx8ICFldmVudC5vZmZzZXRDZW50ZXIpIHtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgdmFyIF9ldmVudCRvZmZzZXRDZW50ZXIgPSBldmVudC5vZmZzZXRDZW50ZXIsXG4gICAgeCA9IF9ldmVudCRvZmZzZXRDZW50ZXIueCxcbiAgICB5ID0gX2V2ZW50JG9mZnNldENlbnRlci55O1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSB8fCAhTnVtYmVyLmlzRmluaXRlKHkpKSB7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIHZhciBwb3MgPSBbeCwgeV07XG4gIGV2ZW50LnBvaW50ID0gcG9zO1xuICBpZiAodGhpcy5tYXApIHtcbiAgICB2YXIgbG9jYXRpb24gPSB0aGlzLm1hcC51bnByb2plY3QocG9zKTtcbiAgICBldmVudC5sbmdMYXQgPSBbbG9jYXRpb24ubG5nLCBsb2NhdGlvbi5sYXRdO1xuICB9XG4gIHJldHVybiBldmVudDtcbn1cbmZ1bmN0aW9uIGdldEZlYXR1cmVzKHBvcykge1xuICB2YXIgbWFwID0gdGhpcy5tYXA7XG4gIGlmICghbWFwIHx8ICFwb3MpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcXVlcnlQYXJhbXMgPSB7fTtcbiAgdmFyIHNpemUgPSB0aGlzLnByb3BzLmNsaWNrUmFkaXVzO1xuICBpZiAodGhpcy5wcm9wcy5pbnRlcmFjdGl2ZUxheWVySWRzKSB7XG4gICAgcXVlcnlQYXJhbXMubGF5ZXJzID0gdGhpcy5wcm9wcy5pbnRlcmFjdGl2ZUxheWVySWRzO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIG1hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoc2l6ZSA/IFtbcG9zWzBdIC0gc2l6ZSwgcG9zWzFdICsgc2l6ZV0sIFtwb3NbMF0gKyBzaXplLCBwb3NbMV0gLSBzaXplXV0gOiBwb3MsIHF1ZXJ5UGFyYW1zKTtcbiAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBvbkV2ZW50KGNhbGxiYWNrTmFtZSwgZXZlbnQpIHtcbiAgdmFyIGZ1bmMgPSB0aGlzLnByb3BzW2NhbGxiYWNrTmFtZV07XG4gIGlmIChmdW5jKSB7XG4gICAgZnVuYyhub3JtYWxpemVFdmVudC5jYWxsKHRoaXMsIGV2ZW50KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgb25FdmVudC5jYWxsKHRoaXMsIGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnID8gJ29uVG91Y2hTdGFydCcgOiAnb25Nb3VzZURvd24nLCBldmVudCk7XG59XG5mdW5jdGlvbiBvblBvaW50ZXJVcChldmVudCkge1xuICBvbkV2ZW50LmNhbGwodGhpcywgZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgPyAnb25Ub3VjaEVuZCcgOiAnb25Nb3VzZVVwJywgZXZlbnQpO1xufVxuZnVuY3Rpb24gb25Qb2ludGVyTW92ZShldmVudCkge1xuICBvbkV2ZW50LmNhbGwodGhpcywgZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgPyAnb25Ub3VjaE1vdmUnIDogJ29uTW91c2VNb3ZlJywgZXZlbnQpO1xuICBpZiAoIXRoaXMuc3RhdGUuaXNEcmFnZ2luZykge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICBvbkhvdmVyID0gX3RoaXMkcHJvcHMub25Ib3ZlcixcbiAgICAgIGludGVyYWN0aXZlTGF5ZXJJZHMgPSBfdGhpcyRwcm9wcy5pbnRlcmFjdGl2ZUxheWVySWRzO1xuICAgIHZhciBmZWF0dXJlcztcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50LmNhbGwodGhpcywgZXZlbnQpO1xuICAgIGlmIChpbnRlcmFjdGl2ZUxheWVySWRzIHx8IG9uSG92ZXIpIHtcbiAgICAgIGZlYXR1cmVzID0gZ2V0RmVhdHVyZXMuY2FsbCh0aGlzLCBldmVudC5wb2ludCk7XG4gICAgfVxuICAgIHZhciBpc0hvdmVyaW5nID0gQm9vbGVhbihpbnRlcmFjdGl2ZUxheWVySWRzICYmIGZlYXR1cmVzICYmIGZlYXR1cmVzLmxlbmd0aCA+IDApO1xuICAgIHZhciBpc0VudGVyaW5nID0gaXNIb3ZlcmluZyAmJiAhdGhpcy5zdGF0ZS5pc0hvdmVyaW5nO1xuICAgIHZhciBpc0V4aXRpbmcgPSAhaXNIb3ZlcmluZyAmJiB0aGlzLnN0YXRlLmlzSG92ZXJpbmc7XG4gICAgaWYgKG9uSG92ZXIgfHwgaXNFbnRlcmluZykge1xuICAgICAgZXZlbnQuZmVhdHVyZXMgPSBmZWF0dXJlcztcbiAgICAgIGlmIChvbkhvdmVyKSB7XG4gICAgICAgIG9uSG92ZXIoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNFbnRlcmluZykge1xuICAgICAgb25FdmVudC5jYWxsKHRoaXMsICdvbk1vdXNlRW50ZXInLCBldmVudCk7XG4gICAgfVxuICAgIGlmIChpc0V4aXRpbmcpIHtcbiAgICAgIG9uRXZlbnQuY2FsbCh0aGlzLCAnb25Nb3VzZUxlYXZlJywgZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNFbnRlcmluZyB8fCBpc0V4aXRpbmcpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc0hvdmVyaW5nOiBpc0hvdmVyaW5nXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG9uUG9pbnRlckNsaWNrKGV2ZW50KSB7XG4gIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgIG9uQ2xpY2sgPSBfdGhpcyRwcm9wczIub25DbGljayxcbiAgICBvbk5hdGl2ZUNsaWNrID0gX3RoaXMkcHJvcHMyLm9uTmF0aXZlQ2xpY2ssXG4gICAgb25EYmxDbGljayA9IF90aGlzJHByb3BzMi5vbkRibENsaWNrLFxuICAgIGRvdWJsZUNsaWNrWm9vbSA9IF90aGlzJHByb3BzMi5kb3VibGVDbGlja1pvb207XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIGlzRG91YmxlQ2xpY2tFbmFibGVkID0gb25EYmxDbGljayB8fCBkb3VibGVDbGlja1pvb207XG4gIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgIGNhc2UgJ2FueWNsaWNrJzpcbiAgICAgIGNhbGxiYWNrcy5wdXNoKG9uTmF0aXZlQ2xpY2spO1xuICAgICAgaWYgKCFpc0RvdWJsZUNsaWNrRW5hYmxlZCkge1xuICAgICAgICBjYWxsYmFja3MucHVzaChvbkNsaWNrKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgIGlmIChpc0RvdWJsZUNsaWNrRW5hYmxlZCkge1xuICAgICAgICBjYWxsYmFja3MucHVzaChvbkNsaWNrKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gIH1cbiAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLmZpbHRlcihCb29sZWFuKTtcbiAgaWYgKGNhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50LmNhbGwodGhpcywgZXZlbnQpO1xuICAgIGV2ZW50LmZlYXR1cmVzID0gZ2V0RmVhdHVyZXMuY2FsbCh0aGlzLCBldmVudC5wb2ludCk7XG4gICAgY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICByZXR1cm4gY2IoZXZlbnQpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZWZIYW5kbGVzKHN0YXRpY01hcFJlZikge1xuICByZXR1cm4ge1xuICAgIGdldE1hcDogc3RhdGljTWFwUmVmLmN1cnJlbnQgJiYgc3RhdGljTWFwUmVmLmN1cnJlbnQuZ2V0TWFwLFxuICAgIHF1ZXJ5UmVuZGVyZWRGZWF0dXJlczogc3RhdGljTWFwUmVmLmN1cnJlbnQgJiYgc3RhdGljTWFwUmVmLmN1cnJlbnQucXVlcnlSZW5kZXJlZEZlYXR1cmVzXG4gIH07XG59XG52YXIgSW50ZXJhY3RpdmVNYXAgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gIHZhciBwYXJlbnRDb250ZXh0ID0gdXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgdmFyIGNvbnRyb2xsZXIgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvcHMuY29udHJvbGxlciB8fCBuZXcgTWFwQ29udHJvbGxlcigpO1xuICB9LCBbXSk7XG4gIHZhciBldmVudE1hbmFnZXIgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEV2ZW50TWFuYWdlcihudWxsLCB7XG4gICAgICB0b3VjaEFjdGlvbjogcHJvcHMudG91Y2hBY3Rpb24sXG4gICAgICByZWNvZ25pemVyT3B0aW9uczogcHJvcHMuZXZlbnRSZWNvZ25pemVyT3B0aW9uc1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIHZhciBldmVudENhbnZhc1JlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHN0YXRpY01hcFJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIF90aGlzUmVmID0gdXNlUmVmKHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgc3RhdGU6IHtcbiAgICAgIGlzSG92ZXJpbmc6IGZhbHNlLFxuICAgICAgaXNEcmFnZ2luZzogZmFsc2VcbiAgICB9XG4gIH0pO1xuICB2YXIgdGhpc1JlZiA9IF90aGlzUmVmLmN1cnJlbnQ7XG4gIHRoaXNSZWYucHJvcHMgPSBwcm9wcztcbiAgdGhpc1JlZi5tYXAgPSBzdGF0aWNNYXBSZWYuY3VycmVudCAmJiBzdGF0aWNNYXBSZWYuY3VycmVudC5nZXRNYXAoKTtcbiAgdGhpc1JlZi5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICAgIHRoaXNSZWYuc3RhdGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXNSZWYuc3RhdGUpLCBuZXdTdGF0ZSk7XG4gICAgZXZlbnRDYW52YXNSZWYuY3VycmVudC5zdHlsZS5jdXJzb3IgPSBwcm9wcy5nZXRDdXJzb3IodGhpc1JlZi5zdGF0ZSk7XG4gIH07XG4gIHZhciBpblJlbmRlciA9IHRydWU7XG4gIHZhciB2aWV3cG9ydFVwZGF0ZVJlcXVlc3RlZDtcbiAgdmFyIHN0YXRlVXBkYXRlUmVxdWVzdGVkO1xuICB2YXIgaGFuZGxlVmlld3BvcnRDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVWaWV3cG9ydENoYW5nZSh2aWV3U3RhdGUsIGludGVyYWN0aW9uU3RhdGUsIG9sZFZpZXdTdGF0ZSkge1xuICAgIGlmIChpblJlbmRlcikge1xuICAgICAgdmlld3BvcnRVcGRhdGVSZXF1ZXN0ZWQgPSBbdmlld1N0YXRlLCBpbnRlcmFjdGlvblN0YXRlLCBvbGRWaWV3U3RhdGVdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgX3RoaXNSZWYkcHJvcHMgPSB0aGlzUmVmLnByb3BzLFxuICAgICAgb25WaWV3U3RhdGVDaGFuZ2UgPSBfdGhpc1JlZiRwcm9wcy5vblZpZXdTdGF0ZUNoYW5nZSxcbiAgICAgIG9uVmlld3BvcnRDaGFuZ2UgPSBfdGhpc1JlZiRwcm9wcy5vblZpZXdwb3J0Q2hhbmdlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2aWV3U3RhdGUsICdwb3NpdGlvbicsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gWzAsIDAsIGdldFRlcnJhaW5FbGV2YXRpb24odGhpc1JlZi5tYXAsIHZpZXdTdGF0ZSldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChvblZpZXdTdGF0ZUNoYW5nZSkge1xuICAgICAgb25WaWV3U3RhdGVDaGFuZ2Uoe1xuICAgICAgICB2aWV3U3RhdGU6IHZpZXdTdGF0ZSxcbiAgICAgICAgaW50ZXJhY3Rpb25TdGF0ZTogaW50ZXJhY3Rpb25TdGF0ZSxcbiAgICAgICAgb2xkVmlld1N0YXRlOiBvbGRWaWV3U3RhdGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob25WaWV3cG9ydENoYW5nZSkge1xuICAgICAgb25WaWV3cG9ydENoYW5nZSh2aWV3U3RhdGUsIGludGVyYWN0aW9uU3RhdGUsIG9sZFZpZXdTdGF0ZSk7XG4gICAgfVxuICB9O1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRSZWZIYW5kbGVzKHN0YXRpY01hcFJlZik7XG4gIH0sIFtdKTtcbiAgdmFyIGNvbnRleHQgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwYXJlbnRDb250ZXh0KSwge30sIHtcbiAgICAgIGV2ZW50TWFuYWdlcjogZXZlbnRNYW5hZ2VyLFxuICAgICAgY29udGFpbmVyOiBwYXJlbnRDb250ZXh0LmNvbnRhaW5lciB8fCBldmVudENhbnZhc1JlZi5jdXJyZW50XG4gICAgfSk7XG4gIH0sIFtwYXJlbnRDb250ZXh0LCBldmVudENhbnZhc1JlZi5jdXJyZW50XSk7XG4gIGNvbnRleHQub25WaWV3cG9ydENoYW5nZSA9IGhhbmRsZVZpZXdwb3J0Q2hhbmdlO1xuICBjb250ZXh0LnZpZXdwb3J0ID0gcGFyZW50Q29udGV4dC52aWV3cG9ydCB8fCBnZXRWaWV3cG9ydCh0aGlzUmVmKTtcbiAgdGhpc1JlZi52aWV3cG9ydCA9IGNvbnRleHQudmlld3BvcnQ7XG4gIHZhciBoYW5kbGVJbnRlcmFjdGlvblN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlSW50ZXJhY3Rpb25TdGF0ZUNoYW5nZShpbnRlcmFjdGlvblN0YXRlKSB7XG4gICAgdmFyIF9pbnRlcmFjdGlvblN0YXRlJGlzRCA9IGludGVyYWN0aW9uU3RhdGUuaXNEcmFnZ2luZyxcbiAgICAgIGlzRHJhZ2dpbmcgPSBfaW50ZXJhY3Rpb25TdGF0ZSRpc0QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2ludGVyYWN0aW9uU3RhdGUkaXNEO1xuICAgIGlmIChpc0RyYWdnaW5nICE9PSB0aGlzUmVmLnN0YXRlLmlzRHJhZ2dpbmcpIHtcbiAgICAgIHRoaXNSZWYuc2V0U3RhdGUoe1xuICAgICAgICBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGluUmVuZGVyKSB7XG4gICAgICBzdGF0ZVVwZGF0ZVJlcXVlc3RlZCA9IGludGVyYWN0aW9uU3RhdGU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBvbkludGVyYWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzUmVmLnByb3BzLm9uSW50ZXJhY3Rpb25TdGF0ZUNoYW5nZTtcbiAgICBpZiAob25JbnRlcmFjdGlvblN0YXRlQ2hhbmdlKSB7XG4gICAgICBvbkludGVyYWN0aW9uU3RhdGVDaGFuZ2UoaW50ZXJhY3Rpb25TdGF0ZSk7XG4gICAgfVxuICB9O1xuICB2YXIgdXBkYXRlQ29udHJvbGxlck9wdHMgPSBmdW5jdGlvbiB1cGRhdGVDb250cm9sbGVyT3B0cygpIHtcbiAgICBpZiAodGhpc1JlZi53aWR0aCAmJiB0aGlzUmVmLmhlaWdodCkge1xuICAgICAgY29udHJvbGxlci5zZXRPcHRpb25zKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzUmVmLnByb3BzKSwgdGhpc1JlZi5wcm9wcy52aWV3U3RhdGUpLCB7fSwge1xuICAgICAgICBpc0ludGVyYWN0aXZlOiBCb29sZWFuKHRoaXNSZWYucHJvcHMub25WaWV3U3RhdGVDaGFuZ2UgfHwgdGhpc1JlZi5wcm9wcy5vblZpZXdwb3J0Q2hhbmdlKSxcbiAgICAgICAgb25WaWV3cG9ydENoYW5nZTogaGFuZGxlVmlld3BvcnRDaGFuZ2UsXG4gICAgICAgIG9uU3RhdGVDaGFuZ2U6IGhhbmRsZUludGVyYWN0aW9uU3RhdGVDaGFuZ2UsXG4gICAgICAgIGV2ZW50TWFuYWdlcjogZXZlbnRNYW5hZ2VyLFxuICAgICAgICB3aWR0aDogdGhpc1JlZi53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzUmVmLmhlaWdodFxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcbiAgdmFyIG9uUmVzaXplID0gZnVuY3Rpb24gb25SZXNpemUoX3JlZjIpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodDtcbiAgICB0aGlzUmVmLndpZHRoID0gd2lkdGg7XG4gICAgdGhpc1JlZi5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdXBkYXRlQ29udHJvbGxlck9wdHMoKTtcbiAgICB0aGlzUmVmLnByb3BzLm9uUmVzaXplKHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfSk7XG4gIH07XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgZXZlbnRNYW5hZ2VyLnNldEVsZW1lbnQoZXZlbnRDYW52YXNSZWYuY3VycmVudCk7XG4gICAgZXZlbnRNYW5hZ2VyLm9uKHtcbiAgICAgIHBvaW50ZXJkb3duOiBvblBvaW50ZXJEb3duLmJpbmQodGhpc1JlZiksXG4gICAgICBwb2ludGVybW92ZTogb25Qb2ludGVyTW92ZS5iaW5kKHRoaXNSZWYpLFxuICAgICAgcG9pbnRlcnVwOiBvblBvaW50ZXJVcC5iaW5kKHRoaXNSZWYpLFxuICAgICAgcG9pbnRlcmxlYXZlOiBvbkV2ZW50LmJpbmQodGhpc1JlZiwgJ29uTW91c2VPdXQnKSxcbiAgICAgIGNsaWNrOiBvblBvaW50ZXJDbGljay5iaW5kKHRoaXNSZWYpLFxuICAgICAgYW55Y2xpY2s6IG9uUG9pbnRlckNsaWNrLmJpbmQodGhpc1JlZiksXG4gICAgICBkYmxjbGljazogb25FdmVudC5iaW5kKHRoaXNSZWYsICdvbkRibENsaWNrJyksXG4gICAgICB3aGVlbDogb25FdmVudC5iaW5kKHRoaXNSZWYsICdvbldoZWVsJyksXG4gICAgICBjb250ZXh0bWVudTogb25FdmVudC5iaW5kKHRoaXNSZWYsICdvbkNvbnRleHRNZW51JylcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZXZlbnRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICh2aWV3cG9ydFVwZGF0ZVJlcXVlc3RlZCkge1xuICAgICAgaGFuZGxlVmlld3BvcnRDaGFuZ2UuYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkodmlld3BvcnRVcGRhdGVSZXF1ZXN0ZWQpKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlVXBkYXRlUmVxdWVzdGVkKSB7XG4gICAgICBoYW5kbGVJbnRlcmFjdGlvblN0YXRlQ2hhbmdlKHN0YXRlVXBkYXRlUmVxdWVzdGVkKTtcbiAgICB9XG4gIH0pO1xuICB1cGRhdGVDb250cm9sbGVyT3B0cygpO1xuICB2YXIgd2lkdGggPSBwcm9wcy53aWR0aCxcbiAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQsXG4gICAgc3R5bGUgPSBwcm9wcy5zdHlsZSxcbiAgICBnZXRDdXJzb3IgPSBwcm9wcy5nZXRDdXJzb3I7XG4gIHZhciBldmVudENhbnZhc1N0eWxlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgIH0sIHN0eWxlKSwge30sIHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgY3Vyc29yOiBnZXRDdXJzb3IodGhpc1JlZi5zdGF0ZSlcbiAgICB9KTtcbiAgfSwgW3N0eWxlLCB3aWR0aCwgaGVpZ2h0LCBnZXRDdXJzb3IsIHRoaXNSZWYuc3RhdGVdKTtcbiAgaWYgKCF2aWV3cG9ydFVwZGF0ZVJlcXVlc3RlZCB8fCAhdGhpc1JlZi5fY2hpbGQpIHtcbiAgICB0aGlzUmVmLl9jaGlsZCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFwQ29udGV4dFByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogY29udGV4dFxuICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAga2V5OiBcImV2ZW50LWNhbnZhc1wiLFxuICAgICAgcmVmOiBldmVudENhbnZhc1JlZixcbiAgICAgIHN0eWxlOiBldmVudENhbnZhc1N0eWxlXG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChTdGF0aWNNYXAsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgIHN0eWxlOiBudWxsLFxuICAgICAgb25SZXNpemU6IG9uUmVzaXplLFxuICAgICAgcmVmOiBzdGF0aWNNYXBSZWZcbiAgICB9KSkpKTtcbiAgfVxuICBpblJlbmRlciA9IGZhbHNlO1xuICByZXR1cm4gdGhpc1JlZi5fY2hpbGQ7XG59KTtcbkludGVyYWN0aXZlTWFwLnN1cHBvcnRlZCA9IFN0YXRpY01hcC5zdXBwb3J0ZWQ7XG5JbnRlcmFjdGl2ZU1hcC5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5JbnRlcmFjdGl2ZU1hcC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBJbnRlcmFjdGl2ZU1hcDsiLCJpbXBvcnQgX3R5cGVvZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghYSB8fCAhYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShiKSB8fCBhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWRlZXBFcXVhbChhW2ldLCBiW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKF90eXBlb2YoYSkgPT09ICdvYmplY3QnICYmIF90eXBlb2YoYikgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gICAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMCwgX2FLZXlzID0gYUtleXM7IF9pIDwgX2FLZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGtleSA9IF9hS2V5c1tfaV07XG4gICAgICBpZiAoIWIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59IiwiaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVN0YXRlLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjbG9uZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgTWFwQ29udGV4dCBmcm9tICcuL21hcC1jb250ZXh0JztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi4vdXRpbHMvYXNzZXJ0JztcbmltcG9ydCBkZWVwRXF1YWwgZnJvbSAnLi4vdXRpbHMvZGVlcC1lcXVhbCc7XG52YXIgc291cmNlQ291bnRlciA9IDA7XG5mdW5jdGlvbiBjcmVhdGVTb3VyY2UobWFwLCBpZCwgcHJvcHMpIHtcbiAgaWYgKG1hcCAmJiBtYXAuc3R5bGUgJiYgbWFwLnN0eWxlLl9sb2FkZWQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIHByb3BzKTtcbiAgICBkZWxldGUgb3B0aW9ucy5pZDtcbiAgICBkZWxldGUgb3B0aW9ucy5jaGlsZHJlbjtcbiAgICBtYXAuYWRkU291cmNlKGlkLCBvcHRpb25zKTtcbiAgICByZXR1cm4gbWFwLmdldFNvdXJjZShpZCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1cGRhdGVTb3VyY2Uoc291cmNlLCBwcm9wcywgcHJldlByb3BzKSB7XG4gIGFzc2VydChwcm9wcy5pZCA9PT0gcHJldlByb3BzLmlkLCAnc291cmNlIGlkIGNoYW5nZWQnKTtcbiAgYXNzZXJ0KHByb3BzLnR5cGUgPT09IHByZXZQcm9wcy50eXBlLCAnc291cmNlIHR5cGUgY2hhbmdlZCcpO1xuICB2YXIgY2hhbmdlZEtleSA9ICcnO1xuICB2YXIgY2hhbmdlZEtleUNvdW50ID0gMDtcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdpZCcgJiYgIWRlZXBFcXVhbChwcmV2UHJvcHNba2V5XSwgcHJvcHNba2V5XSkpIHtcbiAgICAgIGNoYW5nZWRLZXkgPSBrZXk7XG4gICAgICBjaGFuZ2VkS2V5Q291bnQrKztcbiAgICB9XG4gIH1cbiAgaWYgKCFjaGFuZ2VkS2V5Q291bnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wcy50eXBlO1xuICBpZiAodHlwZSA9PT0gJ2dlb2pzb24nKSB7XG4gICAgc291cmNlLnNldERhdGEocHJvcHMuZGF0YSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2ltYWdlJykge1xuICAgIHNvdXJjZS51cGRhdGVJbWFnZSh7XG4gICAgICB1cmw6IHByb3BzLnVybCxcbiAgICAgIGNvb3JkaW5hdGVzOiBwcm9wcy5jb29yZGluYXRlc1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCh0eXBlID09PSAnY2FudmFzJyB8fCB0eXBlID09PSAndmlkZW8nKSAmJiBjaGFuZ2VkS2V5Q291bnQgPT09IDEgJiYgY2hhbmdlZEtleSA9PT0gJ2Nvb3JkaW5hdGVzJykge1xuICAgIHNvdXJjZS5zZXRDb29yZGluYXRlcyhwcm9wcy5jb29yZGluYXRlcyk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3ZlY3RvcicgJiYgc291cmNlLnNldFVybCkge1xuICAgIHN3aXRjaCAoY2hhbmdlZEtleSkge1xuICAgICAgY2FzZSAndXJsJzpcbiAgICAgICAgc291cmNlLnNldFVybChwcm9wcy51cmwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RpbGVzJzpcbiAgICAgICAgc291cmNlLnNldFRpbGVzKHByb3BzLnRpbGVzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gdXBkYXRlIDxTb3VyY2U+IHByb3A6IFwiLmNvbmNhdChjaGFuZ2VkS2V5KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIFNvdXJjZShwcm9wcykge1xuICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gIHZhciBwcm9wc1JlZiA9IHVzZVJlZih7XG4gICAgaWQ6IHByb3BzLmlkLFxuICAgIHR5cGU6IHByb3BzLnR5cGVcbiAgfSk7XG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZSgwKSxcbiAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICBzZXRTdHlsZUxvYWRlZCA9IF91c2VTdGF0ZTJbMV07XG4gIHZhciBpZCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9wcy5pZCB8fCBcImpzeC1zb3VyY2UtXCIuY29uY2F0KHNvdXJjZUNvdW50ZXIrKyk7XG4gIH0sIFtdKTtcbiAgdmFyIG1hcCA9IGNvbnRleHQubWFwO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChtYXApIHtcbiAgICAgIHZhciBmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gc2V0U3R5bGVMb2FkZWQoZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgICAgICAgICByZXR1cm4gdmVyc2lvbiArIDE7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIG1hcC5vbignc3R5bGVkYXRhJywgZm9yY2VVcGRhdGUpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWFwLm9mZignc3R5bGVkYXRhJywgZm9yY2VVcGRhdGUpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChtYXAuc3R5bGUgJiYgbWFwLnN0eWxlLl9sb2FkZWQgJiYgbWFwLmdldFNvdXJjZShpZCkpIHtcbiAgICAgICAgICAgIG1hcC5yZW1vdmVTb3VyY2UoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LCBbbWFwLCBpZF0pO1xuICB2YXIgc291cmNlID0gbWFwICYmIG1hcC5zdHlsZSAmJiBtYXAuZ2V0U291cmNlKGlkKTtcbiAgaWYgKHNvdXJjZSkge1xuICAgIHVwZGF0ZVNvdXJjZShzb3VyY2UsIHByb3BzLCBwcm9wc1JlZi5jdXJyZW50KTtcbiAgfSBlbHNlIHtcbiAgICBzb3VyY2UgPSBjcmVhdGVTb3VyY2UobWFwLCBpZCwgcHJvcHMpO1xuICB9XG4gIHByb3BzUmVmLmN1cnJlbnQgPSBwcm9wcztcbiAgcmV0dXJuIHNvdXJjZSAmJiBSZWFjdC5DaGlsZHJlbi5tYXAocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZCAmJiBjbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgIHNvdXJjZTogaWRcbiAgICB9KTtcbiAgfSkgfHwgbnVsbDtcbn1cbmV4cG9ydCBkZWZhdWx0IFNvdXJjZTsiLCJmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShyLCBlKSB7XG4gIGlmIChudWxsID09IHIpIHJldHVybiB7fTtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgbiBpbiByKSBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChyLCBuKSkge1xuICAgIGlmIChlLmluY2x1ZGVzKG4pKSBjb250aW51ZTtcbiAgICB0W25dID0gcltuXTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmV4cG9ydCB7IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiLi9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzXCI7XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZSwgdCkge1xuICBpZiAobnVsbCA9PSBlKSByZXR1cm4ge307XG4gIHZhciBvLFxuICAgIHIsXG4gICAgaSA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoZSwgdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIGZvciAociA9IDA7IHIgPCBzLmxlbmd0aDsgcisrKSBvID0gc1tyXSwgdC5pbmNsdWRlcyhvKSB8fCB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIG8pICYmIChpW29dID0gZVtvXSk7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5leHBvcnQgeyBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlU3RhdGUsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBNYXBDb250ZXh0IGZyb20gJy4vbWFwLWNvbnRleHQnO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi91dGlscy9hc3NlcnQnO1xuaW1wb3J0IGRlZXBFcXVhbCBmcm9tICcuLi91dGlscy9kZWVwLWVxdWFsJztcbnZhciBMQVlFUl9UWVBFUyA9IFsnZmlsbCcsICdsaW5lJywgJ3N5bWJvbCcsICdjaXJjbGUnLCAnZmlsbC1leHRydXNpb24nLCAncmFzdGVyJywgJ2JhY2tncm91bmQnLCAnaGVhdG1hcCcsICdoaWxsc2hhZGUnLCAnc2t5J107XG52YXIgcHJvcFR5cGVzID0ge1xuICB0eXBlOiBQcm9wVHlwZXMub25lT2YoTEFZRVJfVFlQRVMpLmlzUmVxdWlyZWQsXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzb3VyY2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGJlZm9yZUlkOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuZnVuY3Rpb24gZGlmZkxheWVyU3R5bGVzKG1hcCwgaWQsIHByb3BzLCBwcmV2UHJvcHMpIHtcbiAgdmFyIF9wcm9wcyRsYXlvdXQgPSBwcm9wcy5sYXlvdXQsXG4gICAgbGF5b3V0ID0gX3Byb3BzJGxheW91dCA9PT0gdm9pZCAwID8ge30gOiBfcHJvcHMkbGF5b3V0LFxuICAgIF9wcm9wcyRwYWludCA9IHByb3BzLnBhaW50LFxuICAgIHBhaW50ID0gX3Byb3BzJHBhaW50ID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRwYWludCxcbiAgICBmaWx0ZXIgPSBwcm9wcy5maWx0ZXIsXG4gICAgbWluem9vbSA9IHByb3BzLm1pbnpvb20sXG4gICAgbWF4em9vbSA9IHByb3BzLm1heHpvb20sXG4gICAgYmVmb3JlSWQgPSBwcm9wcy5iZWZvcmVJZCxcbiAgICBvdGhlclByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJsYXlvdXRcIiwgXCJwYWludFwiLCBcImZpbHRlclwiLCBcIm1pbnpvb21cIiwgXCJtYXh6b29tXCIsIFwiYmVmb3JlSWRcIl0pO1xuICBpZiAoYmVmb3JlSWQgIT09IHByZXZQcm9wcy5iZWZvcmVJZCkge1xuICAgIG1hcC5tb3ZlTGF5ZXIoaWQsIGJlZm9yZUlkKTtcbiAgfVxuICBpZiAobGF5b3V0ICE9PSBwcmV2UHJvcHMubGF5b3V0KSB7XG4gICAgdmFyIHByZXZMYXlvdXQgPSBwcmV2UHJvcHMubGF5b3V0IHx8IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBsYXlvdXQpIHtcbiAgICAgIGlmICghZGVlcEVxdWFsKGxheW91dFtrZXldLCBwcmV2TGF5b3V0W2tleV0pKSB7XG4gICAgICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShpZCwga2V5LCBsYXlvdXRba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIF9rZXkgaW4gcHJldkxheW91dCkge1xuICAgICAgaWYgKCFsYXlvdXQuaGFzT3duUHJvcGVydHkoX2tleSkpIHtcbiAgICAgICAgbWFwLnNldExheW91dFByb3BlcnR5KGlkLCBfa2V5LCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocGFpbnQgIT09IHByZXZQcm9wcy5wYWludCkge1xuICAgIHZhciBwcmV2UGFpbnQgPSBwcmV2UHJvcHMucGFpbnQgfHwge307XG4gICAgZm9yICh2YXIgX2tleTIgaW4gcGFpbnQpIHtcbiAgICAgIGlmICghZGVlcEVxdWFsKHBhaW50W19rZXkyXSwgcHJldlBhaW50W19rZXkyXSkpIHtcbiAgICAgICAgbWFwLnNldFBhaW50UHJvcGVydHkoaWQsIF9rZXkyLCBwYWludFtfa2V5Ml0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBfa2V5MyBpbiBwcmV2UGFpbnQpIHtcbiAgICAgIGlmICghcGFpbnQuaGFzT3duUHJvcGVydHkoX2tleTMpKSB7XG4gICAgICAgIG1hcC5zZXRQYWludFByb3BlcnR5KGlkLCBfa2V5MywgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFkZWVwRXF1YWwoZmlsdGVyLCBwcmV2UHJvcHMuZmlsdGVyKSkge1xuICAgIG1hcC5zZXRGaWx0ZXIoaWQsIGZpbHRlcik7XG4gIH1cbiAgaWYgKG1pbnpvb20gIT09IHByZXZQcm9wcy5taW56b29tIHx8IG1heHpvb20gIT09IHByZXZQcm9wcy5tYXh6b29tKSB7XG4gICAgbWFwLnNldExheWVyWm9vbVJhbmdlKGlkLCBtaW56b29tLCBtYXh6b29tKTtcbiAgfVxuICBmb3IgKHZhciBfa2V5NCBpbiBvdGhlclByb3BzKSB7XG4gICAgaWYgKCFkZWVwRXF1YWwob3RoZXJQcm9wc1tfa2V5NF0sIHByZXZQcm9wc1tfa2V5NF0pKSB7XG4gICAgICBtYXAuc2V0TGF5ZXJQcm9wZXJ0eShpZCwgX2tleTQsIG90aGVyUHJvcHNbX2tleTRdKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUxheWVyKG1hcCwgaWQsIHByb3BzKSB7XG4gIGlmIChtYXAuc3R5bGUgJiYgbWFwLnN0eWxlLl9sb2FkZWQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgaWQ6IGlkXG4gICAgfSk7XG4gICAgZGVsZXRlIG9wdGlvbnMuYmVmb3JlSWQ7XG4gICAgbWFwLmFkZExheWVyKG9wdGlvbnMsIHByb3BzLmJlZm9yZUlkKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlTGF5ZXIobWFwLCBpZCwgcHJvcHMsIHByZXZQcm9wcykge1xuICBhc3NlcnQocHJvcHMuaWQgPT09IHByZXZQcm9wcy5pZCwgJ2xheWVyIGlkIGNoYW5nZWQnKTtcbiAgYXNzZXJ0KHByb3BzLnR5cGUgPT09IHByZXZQcm9wcy50eXBlLCAnbGF5ZXIgdHlwZSBjaGFuZ2VkJyk7XG4gIHRyeSB7XG4gICAgZGlmZkxheWVyU3R5bGVzKG1hcCwgaWQsIHByb3BzLCBwcmV2UHJvcHMpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gIH1cbn1cbnZhciBsYXllckNvdW50ZXIgPSAwO1xuZnVuY3Rpb24gTGF5ZXIocHJvcHMpIHtcbiAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICB2YXIgcHJvcHNSZWYgPSB1c2VSZWYoe1xuICAgIGlkOiBwcm9wcy5pZCxcbiAgICB0eXBlOiBwcm9wcy50eXBlXG4gIH0pO1xuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoMCksXG4gICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgc2V0U3R5bGVMb2FkZWQgPSBfdXNlU3RhdGUyWzFdO1xuICB2YXIgaWQgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvcHMuaWQgfHwgXCJqc3gtbGF5ZXItXCIuY29uY2F0KGxheWVyQ291bnRlcisrKTtcbiAgfSwgW10pO1xuICB2YXIgbWFwID0gY29udGV4dC5tYXA7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG1hcCkge1xuICAgICAgdmFyIGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIHJldHVybiBzZXRTdHlsZUxvYWRlZChmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgIHJldHVybiB2ZXJzaW9uICsgMTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgbWFwLm9uKCdzdHlsZWRhdGEnLCBmb3JjZVVwZGF0ZSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBtYXAub2ZmKCdzdHlsZWRhdGEnLCBmb3JjZVVwZGF0ZSk7XG4gICAgICAgIGlmIChtYXAuc3R5bGUgJiYgbWFwLnN0eWxlLl9sb2FkZWQpIHtcbiAgICAgICAgICBtYXAucmVtb3ZlTGF5ZXIoaWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LCBbbWFwXSk7XG4gIHZhciBsYXllciA9IG1hcCAmJiBtYXAuc3R5bGUgJiYgbWFwLmdldExheWVyKGlkKTtcbiAgaWYgKGxheWVyKSB7XG4gICAgdXBkYXRlTGF5ZXIobWFwLCBpZCwgcHJvcHMsIHByb3BzUmVmLmN1cnJlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNyZWF0ZUxheWVyKG1hcCwgaWQsIHByb3BzKTtcbiAgfVxuICBwcm9wc1JlZi5jdXJyZW50ID0gcHJvcHM7XG4gIHJldHVybiBudWxsO1xufVxuTGF5ZXIucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuZXhwb3J0IGRlZmF1bHQgTGF5ZXI7IiwiaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgTWFwQ29udGV4dCBmcm9tICcuL21hcC1jb250ZXh0JztcbmV4cG9ydCB2YXIgbWFwQ29udHJvbERlZmF1bHRQcm9wcyA9IHtcbiAgY2FwdHVyZVNjcm9sbDogZmFsc2UsXG4gIGNhcHR1cmVEcmFnOiB0cnVlLFxuICBjYXB0dXJlQ2xpY2s6IHRydWUsXG4gIGNhcHR1cmVEb3VibGVDbGljazogdHJ1ZSxcbiAgY2FwdHVyZVBvaW50ZXJNb3ZlOiBmYWxzZVxufTtcbmV4cG9ydCB2YXIgbWFwQ29udHJvbFByb3BUeXBlcyA9IHtcbiAgY2FwdHVyZVNjcm9sbDogUHJvcFR5cGVzLmJvb2wsXG4gIGNhcHR1cmVEcmFnOiBQcm9wVHlwZXMuYm9vbCxcbiAgY2FwdHVyZUNsaWNrOiBQcm9wVHlwZXMuYm9vbCxcbiAgY2FwdHVyZURvdWJsZUNsaWNrOiBQcm9wVHlwZXMuYm9vbCxcbiAgY2FwdHVyZVBvaW50ZXJNb3ZlOiBQcm9wVHlwZXMuYm9vbFxufTtcbmZ1bmN0aW9uIG9uTW91bnQodGhpc1JlZikge1xuICB2YXIgcmVmID0gdGhpc1JlZi5jb250YWluZXJSZWYuY3VycmVudDtcbiAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXNSZWYuY29udGV4dC5ldmVudE1hbmFnZXI7XG4gIGlmICghcmVmIHx8ICFldmVudE1hbmFnZXIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHZhciBldmVudHMgPSB7XG4gICAgd2hlZWw6IGZ1bmN0aW9uIHdoZWVsKGV2dCkge1xuICAgICAgdmFyIHByb3BzID0gdGhpc1JlZi5wcm9wcztcbiAgICAgIGlmIChwcm9wcy5jYXB0dXJlU2Nyb2xsKSB7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5vblNjcm9sbCkge1xuICAgICAgICBwcm9wcy5vblNjcm9sbChldnQsIHRoaXNSZWYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGFuc3RhcnQ6IGZ1bmN0aW9uIHBhbnN0YXJ0KGV2dCkge1xuICAgICAgdmFyIHByb3BzID0gdGhpc1JlZi5wcm9wcztcbiAgICAgIGlmIChwcm9wcy5jYXB0dXJlRHJhZykge1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMub25EcmFnU3RhcnQpIHtcbiAgICAgICAgcHJvcHMub25EcmFnU3RhcnQoZXZ0LCB0aGlzUmVmKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFueWNsaWNrOiBmdW5jdGlvbiBhbnljbGljayhldnQpIHtcbiAgICAgIHZhciBwcm9wcyA9IHRoaXNSZWYucHJvcHM7XG4gICAgICBpZiAocHJvcHMuY2FwdHVyZUNsaWNrKSB7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5vbk5hdGl2ZUNsaWNrKSB7XG4gICAgICAgIHByb3BzLm9uTmF0aXZlQ2xpY2soZXZ0LCB0aGlzUmVmKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljayhldnQpIHtcbiAgICAgIHZhciBwcm9wcyA9IHRoaXNSZWYucHJvcHM7XG4gICAgICBpZiAocHJvcHMuY2FwdHVyZUNsaWNrKSB7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5vbkNsaWNrKSB7XG4gICAgICAgIHByb3BzLm9uQ2xpY2soZXZ0LCB0aGlzUmVmKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRibGNsaWNrOiBmdW5jdGlvbiBkYmxjbGljayhldnQpIHtcbiAgICAgIHZhciBwcm9wcyA9IHRoaXNSZWYucHJvcHM7XG4gICAgICBpZiAocHJvcHMuY2FwdHVyZURvdWJsZUNsaWNrKSB7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5vbkRvdWJsZUNsaWNrKSB7XG4gICAgICAgIHByb3BzLm9uRG91YmxlQ2xpY2soZXZ0LCB0aGlzUmVmKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBvaW50ZXJtb3ZlOiBmdW5jdGlvbiBwb2ludGVybW92ZShldnQpIHtcbiAgICAgIHZhciBwcm9wcyA9IHRoaXNSZWYucHJvcHM7XG4gICAgICBpZiAocHJvcHMuY2FwdHVyZVBvaW50ZXJNb3ZlKSB7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5vblBvaW50ZXJNb3ZlKSB7XG4gICAgICAgIHByb3BzLm9uUG9pbnRlck1vdmUoZXZ0LCB0aGlzUmVmKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGV2ZW50TWFuYWdlci53YXRjaChldmVudHMsIHJlZik7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZXZlbnRNYW5hZ2VyLm9mZihldmVudHMpO1xuICB9O1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlTWFwQ29udHJvbCgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICB2YXIgY29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgX3RoaXNSZWYgPSB1c2VSZWYoe1xuICAgIHByb3BzOiBwcm9wcyxcbiAgICBzdGF0ZToge30sXG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICBjb250YWluZXJSZWY6IGNvbnRhaW5lclJlZlxuICB9KTtcbiAgdmFyIHRoaXNSZWYgPSBfdGhpc1JlZi5jdXJyZW50O1xuICB0aGlzUmVmLnByb3BzID0gcHJvcHM7XG4gIHRoaXNSZWYuY29udGV4dCA9IGNvbnRleHQ7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG9uTW91bnQodGhpc1JlZik7XG4gIH0sIFtjb250ZXh0LmV2ZW50TWFuYWdlcl0pO1xuICByZXR1cm4gdGhpc1JlZjtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiO1xuaW1wb3J0IF9pbmhlcml0cyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNcIjtcbmltcG9ydCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiO1xuaW1wb3J0IF9nZXRQcm90b3R5cGVPZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2ZcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgIHJlc3VsdDtcbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFB1cmVDb21wb25lbnQsIGNyZWF0ZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VNYXBDb250cm9sLCB7IG1hcENvbnRyb2xEZWZhdWx0UHJvcHMsIG1hcENvbnRyb2xQcm9wVHlwZXMgfSBmcm9tICcuL3VzZS1tYXAtY29udHJvbCc7XG5mdW5jdGlvbiBDb250cm9sKHByb3BzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHByb3BzLmluc3RhbmNlO1xuICB2YXIgX3VzZU1hcENvbnRyb2wgPSB1c2VNYXBDb250cm9sKHByb3BzKSxcbiAgICBjb250ZXh0ID0gX3VzZU1hcENvbnRyb2wuY29udGV4dCxcbiAgICBjb250YWluZXJSZWYgPSBfdXNlTWFwQ29udHJvbC5jb250YWluZXJSZWY7XG4gIGluc3RhbmNlLl9jb250ZXh0ID0gY29udGV4dDtcbiAgaW5zdGFuY2UuX2NvbnRhaW5lclJlZiA9IGNvbnRhaW5lclJlZjtcbiAgcmV0dXJuIGluc3RhbmNlLl9yZW5kZXIoKTtcbn1cbnZhciBCYXNlQ29udHJvbCA9IGZ1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQmFzZUNvbnRyb2wsIF9QdXJlQ29tcG9uZW50KTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihCYXNlQ29udHJvbCk7XG4gIGZ1bmN0aW9uIEJhc2VDb250cm9sKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZUNvbnRyb2wpO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbC5hcHBseShfc3VwZXIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfY29udGV4dFwiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9jb250YWluZXJSZWZcIiwgY3JlYXRlUmVmKCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfb25TY3JvbGxcIiwgZnVuY3Rpb24gKGV2dCkge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfb25EcmFnU3RhcnRcIiwgZnVuY3Rpb24gKGV2dCkge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfb25EYmxDbGlja1wiLCBmdW5jdGlvbiAoZXZ0KSB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9vbkNsaWNrXCIsIGZ1bmN0aW9uIChldnQpIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX29uUG9pbnRlck1vdmVcIiwgZnVuY3Rpb24gKGV2dCkge30pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfY3JlYXRlQ2xhc3MoQmFzZUNvbnRyb2wsIFt7XG4gICAga2V5OiBcIl9yZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlcigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignX3JlbmRlcigpIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udHJvbCwgX2V4dGVuZHMoe1xuICAgICAgICBpbnN0YW5jZTogdGhpc1xuICAgICAgfSwgdGhpcy5wcm9wcywge1xuICAgICAgICBvblNjcm9sbDogdGhpcy5fb25TY3JvbGwsXG4gICAgICAgIG9uRHJhZ1N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgICAgICAgb25EYmxDbGljazogdGhpcy5fb25EYmxDbGljayxcbiAgICAgICAgb25DbGljazogdGhpcy5fb25DbGljayxcbiAgICAgICAgb25Qb2ludGVyTW92ZTogdGhpcy5fb25Qb2ludGVyTW92ZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQmFzZUNvbnRyb2w7XG59KFB1cmVDb21wb25lbnQpO1xuX2RlZmluZVByb3BlcnR5KEJhc2VDb250cm9sLCBcInByb3BUeXBlc1wiLCBtYXBDb250cm9sUHJvcFR5cGVzKTtcbl9kZWZpbmVQcm9wZXJ0eShCYXNlQ29udHJvbCwgXCJkZWZhdWx0UHJvcHNcIiwgbWFwQ29udHJvbERlZmF1bHRQcm9wcyk7XG5leHBvcnQgeyBCYXNlQ29udHJvbCBhcyBkZWZhdWx0IH07IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5pbXBvcnQgKiBhcyBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZU1hcENvbnRyb2wsIHsgbWFwQ29udHJvbERlZmF1bHRQcm9wcywgbWFwQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4vdXNlLW1hcC1jb250cm9sJztcbmV4cG9ydCB2YXIgZHJhZ2dhYmxlQ29udHJvbFByb3BUeXBlcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hcENvbnRyb2xQcm9wVHlwZXMsIHtcbiAgZHJhZ2dhYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgb25EcmFnOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25EcmFnRW5kOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25EcmFnU3RhcnQ6IFByb3BUeXBlcy5mdW5jLFxuICBvZmZzZXRMZWZ0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBvZmZzZXRUb3A6IFByb3BUeXBlcy5udW1iZXJcbn0pO1xuZXhwb3J0IHZhciBkcmFnZ2FibGVDb250cm9sRGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbWFwQ29udHJvbERlZmF1bHRQcm9wcywge1xuICBkcmFnZ2FibGU6IGZhbHNlLFxuICBvZmZzZXRMZWZ0OiAwLFxuICBvZmZzZXRUb3A6IDBcbn0pO1xuZnVuY3Rpb24gZ2V0RHJhZ0V2ZW50UG9zaXRpb24oZXZlbnQpIHtcbiAgdmFyIF9ldmVudCRvZmZzZXRDZW50ZXIgPSBldmVudC5vZmZzZXRDZW50ZXIsXG4gICAgeCA9IF9ldmVudCRvZmZzZXRDZW50ZXIueCxcbiAgICB5ID0gX2V2ZW50JG9mZnNldENlbnRlci55O1xuICByZXR1cm4gW3gsIHldO1xufVxuZnVuY3Rpb24gZ2V0RHJhZ0V2ZW50T2Zmc2V0KGV2ZW50LCBjb250YWluZXIpIHtcbiAgdmFyIF9ldmVudCRjZW50ZXIgPSBldmVudC5jZW50ZXIsXG4gICAgeCA9IF9ldmVudCRjZW50ZXIueCxcbiAgICB5ID0gX2V2ZW50JGNlbnRlci55O1xuICBpZiAoY29udGFpbmVyKSB7XG4gICAgdmFyIHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIFtyZWN0LmxlZnQgLSB4LCByZWN0LnRvcCAtIHldO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RHJhZ0xuZ0xhdChkcmFnUG9zLCBkcmFnT2Zmc2V0LCBwcm9wcywgY29udGV4dCkge1xuICB2YXIgeCA9IGRyYWdQb3NbMF0gKyBkcmFnT2Zmc2V0WzBdIC0gcHJvcHMub2Zmc2V0TGVmdDtcbiAgdmFyIHkgPSBkcmFnUG9zWzFdICsgZHJhZ09mZnNldFsxXSAtIHByb3BzLm9mZnNldFRvcDtcbiAgcmV0dXJuIGNvbnRleHQudmlld3BvcnQudW5wcm9qZWN0KFt4LCB5XSk7XG59XG5mdW5jdGlvbiBvbkRyYWdTdGFydChldmVudCwgX3JlZikge1xuICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgIGNhbGxiYWNrcyA9IF9yZWYuY2FsbGJhY2tzLFxuICAgIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxuICAgIGNvbnRhaW5lclJlZiA9IF9yZWYuY29udGFpbmVyUmVmO1xuICB2YXIgZHJhZ2dhYmxlID0gcHJvcHMuZHJhZ2dhYmxlO1xuICBpZiAoIWRyYWdnYWJsZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgdmFyIGRyYWdQb3MgPSBnZXREcmFnRXZlbnRQb3NpdGlvbihldmVudCk7XG4gIHZhciBkcmFnT2Zmc2V0ID0gZ2V0RHJhZ0V2ZW50T2Zmc2V0KGV2ZW50LCBjb250YWluZXJSZWYuY3VycmVudCk7XG4gIHN0YXRlLnNldERyYWdQb3MoZHJhZ1Bvcyk7XG4gIHN0YXRlLnNldERyYWdPZmZzZXQoZHJhZ09mZnNldCk7XG4gIGlmIChjYWxsYmFja3Mub25EcmFnU3RhcnQgJiYgZHJhZ09mZnNldCkge1xuICAgIHZhciBjYWxsYmFja0V2ZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQpO1xuICAgIGNhbGxiYWNrRXZlbnQubG5nTGF0ID0gZ2V0RHJhZ0xuZ0xhdChkcmFnUG9zLCBkcmFnT2Zmc2V0LCBwcm9wcywgY29udGV4dCk7XG4gICAgY2FsbGJhY2tzLm9uRHJhZ1N0YXJ0KGNhbGxiYWNrRXZlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBvbkRyYWcoZXZlbnQsIF9yZWYyKSB7XG4gIHZhciBwcm9wcyA9IF9yZWYyLnByb3BzLFxuICAgIGNhbGxiYWNrcyA9IF9yZWYyLmNhbGxiYWNrcyxcbiAgICBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgIGNvbnRleHQgPSBfcmVmMi5jb250ZXh0O1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgdmFyIGRyYWdQb3MgPSBnZXREcmFnRXZlbnRQb3NpdGlvbihldmVudCk7XG4gIHN0YXRlLnNldERyYWdQb3MoZHJhZ1Bvcyk7XG4gIHZhciBkcmFnT2Zmc2V0ID0gc3RhdGUuZHJhZ09mZnNldDtcbiAgaWYgKGNhbGxiYWNrcy5vbkRyYWcgJiYgZHJhZ09mZnNldCkge1xuICAgIHZhciBjYWxsYmFja0V2ZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQpO1xuICAgIGNhbGxiYWNrRXZlbnQubG5nTGF0ID0gZ2V0RHJhZ0xuZ0xhdChkcmFnUG9zLCBkcmFnT2Zmc2V0LCBwcm9wcywgY29udGV4dCk7XG4gICAgY2FsbGJhY2tzLm9uRHJhZyhjYWxsYmFja0V2ZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gb25EcmFnRW5kKGV2ZW50LCBfcmVmMykge1xuICB2YXIgcHJvcHMgPSBfcmVmMy5wcm9wcyxcbiAgICBjYWxsYmFja3MgPSBfcmVmMy5jYWxsYmFja3MsXG4gICAgc3RhdGUgPSBfcmVmMy5zdGF0ZSxcbiAgICBjb250ZXh0ID0gX3JlZjMuY29udGV4dDtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIHZhciBkcmFnUG9zID0gc3RhdGUuZHJhZ1BvcyxcbiAgICBkcmFnT2Zmc2V0ID0gc3RhdGUuZHJhZ09mZnNldDtcbiAgc3RhdGUuc2V0RHJhZ1BvcyhudWxsKTtcbiAgc3RhdGUuc2V0RHJhZ09mZnNldChudWxsKTtcbiAgaWYgKGNhbGxiYWNrcy5vbkRyYWdFbmQgJiYgZHJhZ1BvcyAmJiBkcmFnT2Zmc2V0KSB7XG4gICAgdmFyIGNhbGxiYWNrRXZlbnQgPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCk7XG4gICAgY2FsbGJhY2tFdmVudC5sbmdMYXQgPSBnZXREcmFnTG5nTGF0KGRyYWdQb3MsIGRyYWdPZmZzZXQsIHByb3BzLCBjb250ZXh0KTtcbiAgICBjYWxsYmFja3Mub25EcmFnRW5kKGNhbGxiYWNrRXZlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBvbkRyYWdDYW5jZWwoZXZlbnQsIF9yZWY0KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWY0LnN0YXRlO1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgc3RhdGUuc2V0RHJhZ1BvcyhudWxsKTtcbiAgc3RhdGUuc2V0RHJhZ09mZnNldChudWxsKTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRzKHRoaXNSZWYpIHtcbiAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXNSZWYuY29udGV4dC5ldmVudE1hbmFnZXI7XG4gIGlmICghZXZlbnRNYW5hZ2VyIHx8ICF0aGlzUmVmLnN0YXRlLmRyYWdQb3MpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHZhciBldmVudHMgPSB7XG4gICAgcGFubW92ZTogZnVuY3Rpb24gcGFubW92ZShldnQpIHtcbiAgICAgIHJldHVybiBvbkRyYWcoZXZ0LCB0aGlzUmVmKTtcbiAgICB9LFxuICAgIHBhbmVuZDogZnVuY3Rpb24gcGFuZW5kKGV2dCkge1xuICAgICAgcmV0dXJuIG9uRHJhZ0VuZChldnQsIHRoaXNSZWYpO1xuICAgIH0sXG4gICAgcGFuY2FuY2VsOiBmdW5jdGlvbiBwYW5jYW5jZWwoZXZ0KSB7XG4gICAgICByZXR1cm4gb25EcmFnQ2FuY2VsKGV2dCwgdGhpc1JlZik7XG4gICAgfVxuICB9O1xuICBldmVudE1hbmFnZXIud2F0Y2goZXZlbnRzKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBldmVudE1hbmFnZXIub2ZmKGV2ZW50cyk7XG4gIH07XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VEcmFnZ2FibGVDb250cm9sKHByb3BzKSB7XG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShudWxsKSxcbiAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICBkcmFnUG9zID0gX3VzZVN0YXRlMlswXSxcbiAgICBzZXREcmFnUG9zID0gX3VzZVN0YXRlMlsxXTtcbiAgdmFyIF91c2VTdGF0ZTMgPSB1c2VTdGF0ZShudWxsKSxcbiAgICBfdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMywgMiksXG4gICAgZHJhZ09mZnNldCA9IF91c2VTdGF0ZTRbMF0sXG4gICAgc2V0RHJhZ09mZnNldCA9IF91c2VTdGF0ZTRbMV07XG4gIHZhciB0aGlzUmVmID0gdXNlTWFwQ29udHJvbChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwge30sIHtcbiAgICBvbkRyYWdTdGFydDogb25EcmFnU3RhcnRcbiAgfSkpO1xuICB0aGlzUmVmLmNhbGxiYWNrcyA9IHByb3BzO1xuICB0aGlzUmVmLnN0YXRlLmRyYWdQb3MgPSBkcmFnUG9zO1xuICB0aGlzUmVmLnN0YXRlLnNldERyYWdQb3MgPSBzZXREcmFnUG9zO1xuICB0aGlzUmVmLnN0YXRlLmRyYWdPZmZzZXQgPSBkcmFnT2Zmc2V0O1xuICB0aGlzUmVmLnN0YXRlLnNldERyYWdPZmZzZXQgPSBzZXREcmFnT2Zmc2V0O1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZWdpc3RlckV2ZW50cyh0aGlzUmVmKTtcbiAgfSwgW3RoaXNSZWYuY29udGV4dC5ldmVudE1hbmFnZXIsIEJvb2xlYW4oZHJhZ1BvcyldKTtcbiAgcmV0dXJuIHRoaXNSZWY7XG59IiwidmFyIHBpeGVsUmF0aW8gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuZXhwb3J0IHZhciBjcmlzcFBpeGVsID0gZnVuY3Rpb24gY3Jpc3BQaXhlbChzaXplKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHNpemUgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW87XG59O1xuZXhwb3J0IHZhciBjcmlzcFBlcmNlbnRhZ2UgPSBmdW5jdGlvbiBjcmlzcFBlcmNlbnRhZ2UoZWwsIHBlcmNlbnRhZ2UpIHtcbiAgdmFyIGRpbWVuc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ3gnO1xuICBpZiAoZWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gcGVyY2VudGFnZTtcbiAgfVxuICB2YXIgb3JpZ1NpemUgPSBkaW1lbnNpb24gPT09ICd4JyA/IGVsLm9mZnNldFdpZHRoIDogZWwub2Zmc2V0SGVpZ2h0O1xuICByZXR1cm4gY3Jpc3BQaXhlbChwZXJjZW50YWdlIC8gMTAwICogb3JpZ1NpemUpIC8gb3JpZ1NpemUgKiAxMDA7XG59OyIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VEcmFnZ2FibGVDb250cm9sLCB7IGRyYWdnYWJsZUNvbnRyb2xEZWZhdWx0UHJvcHMsIGRyYWdnYWJsZUNvbnRyb2xQcm9wVHlwZXMgfSBmcm9tICcuL2RyYWdnYWJsZS1jb250cm9sJztcbmltcG9ydCB7IGNyaXNwUGl4ZWwgfSBmcm9tICcuLi91dGlscy9jcmlzcC1waXhlbCc7XG5pbXBvcnQgeyBnZXRUZXJyYWluRWxldmF0aW9uIH0gZnJvbSAnLi4vdXRpbHMvdGVycmFpbic7XG52YXIgZGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgZHJhZ2dhYmxlQ29udHJvbERlZmF1bHRQcm9wcywge1xuICBjbGFzc05hbWU6ICcnXG59KTtcbmZ1bmN0aW9uIGdldFBvc2l0aW9uKF9yZWYpIHtcbiAgdmFyIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgY29udGV4dCA9IF9yZWYuY29udGV4dDtcbiAgdmFyIGxvbmdpdHVkZSA9IHByb3BzLmxvbmdpdHVkZSxcbiAgICBsYXRpdHVkZSA9IHByb3BzLmxhdGl0dWRlLFxuICAgIG9mZnNldExlZnQgPSBwcm9wcy5vZmZzZXRMZWZ0LFxuICAgIG9mZnNldFRvcCA9IHByb3BzLm9mZnNldFRvcDtcbiAgdmFyIGRyYWdQb3MgPSBzdGF0ZS5kcmFnUG9zLFxuICAgIGRyYWdPZmZzZXQgPSBzdGF0ZS5kcmFnT2Zmc2V0O1xuICB2YXIgdmlld3BvcnQgPSBjb250ZXh0LnZpZXdwb3J0LFxuICAgIG1hcCA9IGNvbnRleHQubWFwO1xuICBpZiAoZHJhZ1BvcyAmJiBkcmFnT2Zmc2V0KSB7XG4gICAgcmV0dXJuIFtkcmFnUG9zWzBdICsgZHJhZ09mZnNldFswXSwgZHJhZ1Bvc1sxXSArIGRyYWdPZmZzZXRbMV1dO1xuICB9XG4gIHZhciBhbHRpdHVkZSA9IGdldFRlcnJhaW5FbGV2YXRpb24obWFwLCB7XG4gICAgbG9uZ2l0dWRlOiBsb25naXR1ZGUsXG4gICAgbGF0aXR1ZGU6IGxhdGl0dWRlXG4gIH0pO1xuICB2YXIgX3ZpZXdwb3J0JHByb2plY3QgPSB2aWV3cG9ydC5wcm9qZWN0KFtsb25naXR1ZGUsIGxhdGl0dWRlLCBhbHRpdHVkZV0pLFxuICAgIF92aWV3cG9ydCRwcm9qZWN0MiA9IF9zbGljZWRUb0FycmF5KF92aWV3cG9ydCRwcm9qZWN0LCAyKSxcbiAgICB4ID0gX3ZpZXdwb3J0JHByb2plY3QyWzBdLFxuICAgIHkgPSBfdmlld3BvcnQkcHJvamVjdDJbMV07XG4gIHggKz0gb2Zmc2V0TGVmdDtcbiAgeSArPSBvZmZzZXRUb3A7XG4gIHJldHVybiBbeCwgeV07XG59XG5mdW5jdGlvbiBNYXJrZXIocHJvcHMpIHtcbiAgdmFyIHRoaXNSZWYgPSB1c2VEcmFnZ2FibGVDb250cm9sKHByb3BzKTtcbiAgdmFyIHN0YXRlID0gdGhpc1JlZi5zdGF0ZSxcbiAgICBjb250YWluZXJSZWYgPSB0aGlzUmVmLmNvbnRhaW5lclJlZjtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgIGRyYWdnYWJsZSA9IHByb3BzLmRyYWdnYWJsZSxcbiAgICBzdHlsZSA9IHByb3BzLnN0eWxlO1xuICB2YXIgZHJhZ1BvcyA9IHN0YXRlLmRyYWdQb3M7XG4gIHZhciBfZ2V0UG9zaXRpb24gPSBnZXRQb3NpdGlvbih0aGlzUmVmKSxcbiAgICBfZ2V0UG9zaXRpb24yID0gX3NsaWNlZFRvQXJyYXkoX2dldFBvc2l0aW9uLCAyKSxcbiAgICB4ID0gX2dldFBvc2l0aW9uMlswXSxcbiAgICB5ID0gX2dldFBvc2l0aW9uMlsxXTtcbiAgdmFyIHRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdChjcmlzcFBpeGVsKHgpLCBcInB4LCBcIikuY29uY2F0KGNyaXNwUGl4ZWwoeSksIFwicHgpXCIpO1xuICB2YXIgY3Vyc29yID0gZHJhZ2dhYmxlID8gZHJhZ1BvcyA/ICdncmFiYmluZycgOiAnZ3JhYicgOiAnYXV0byc7XG4gIHZhciBjb250cm9sID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRhaW5lclN0eWxlID0gX29iamVjdFNwcmVhZCh7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgIGN1cnNvcjogY3Vyc29yXG4gICAgfSwgc3R5bGUpO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1tYXJrZXIgXCIuY29uY2F0KGNsYXNzTmFtZSksXG4gICAgICByZWY6IHRoaXNSZWYuY29udGFpbmVyUmVmLFxuICAgICAgc3R5bGU6IGNvbnRhaW5lclN0eWxlXG4gICAgfSwgY2hpbGRyZW4pO1xuICB9LCBbY2hpbGRyZW4sIGNsYXNzTmFtZV0pO1xuICB2YXIgY29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gIGlmIChjb250YWluZXIpIHtcbiAgICBjb250YWluZXIuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGNvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gIH1cbiAgcmV0dXJuIGNvbnRyb2w7XG59XG5NYXJrZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhNYXJrZXIpOyIsImV4cG9ydCB2YXIgQU5DSE9SX1BPU0lUSU9OID0ge1xuICB0b3A6IHtcbiAgICB4OiAwLjUsXG4gICAgeTogMFxuICB9LFxuICAndG9wLWxlZnQnOiB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH0sXG4gICd0b3AtcmlnaHQnOiB7XG4gICAgeDogMSxcbiAgICB5OiAwXG4gIH0sXG4gIGJvdHRvbToge1xuICAgIHg6IDAuNSxcbiAgICB5OiAxXG4gIH0sXG4gICdib3R0b20tbGVmdCc6IHtcbiAgICB4OiAwLFxuICAgIHk6IDFcbiAgfSxcbiAgJ2JvdHRvbS1yaWdodCc6IHtcbiAgICB4OiAxLFxuICAgIHk6IDFcbiAgfSxcbiAgbGVmdDoge1xuICAgIHg6IDAsXG4gICAgeTogMC41XG4gIH0sXG4gIHJpZ2h0OiB7XG4gICAgeDogMSxcbiAgICB5OiAwLjVcbiAgfVxufTtcbnZhciBBTkNIT1JfVFlQRVMgPSBPYmplY3Qua2V5cyhBTkNIT1JfUE9TSVRJT04pO1xuZXhwb3J0IGZ1bmN0aW9uIGdldER5bmFtaWNQb3NpdGlvbihfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgIHkgPSBfcmVmLnksXG4gICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgIHNlbGZXaWR0aCA9IF9yZWYuc2VsZldpZHRoLFxuICAgIHNlbGZIZWlnaHQgPSBfcmVmLnNlbGZIZWlnaHQsXG4gICAgYW5jaG9yID0gX3JlZi5hbmNob3IsXG4gICAgX3JlZiRwYWRkaW5nID0gX3JlZi5wYWRkaW5nLFxuICAgIHBhZGRpbmcgPSBfcmVmJHBhZGRpbmcgPT09IHZvaWQgMCA/IDAgOiBfcmVmJHBhZGRpbmc7XG4gIHZhciBfQU5DSE9SX1BPU0lUSU9OJGFuY2ggPSBBTkNIT1JfUE9TSVRJT05bYW5jaG9yXSxcbiAgICBhbmNob3JYID0gX0FOQ0hPUl9QT1NJVElPTiRhbmNoLngsXG4gICAgYW5jaG9yWSA9IF9BTkNIT1JfUE9TSVRJT04kYW5jaC55O1xuICB2YXIgdG9wID0geSAtIGFuY2hvclkgKiBzZWxmSGVpZ2h0O1xuICB2YXIgYm90dG9tID0gdG9wICsgc2VsZkhlaWdodDtcbiAgdmFyIGN1dG9mZlkgPSBNYXRoLm1heCgwLCBwYWRkaW5nIC0gdG9wKSArIE1hdGgubWF4KDAsIGJvdHRvbSAtIGhlaWdodCArIHBhZGRpbmcpO1xuICBpZiAoY3V0b2ZmWSA+IDApIHtcbiAgICB2YXIgYmVzdEFuY2hvclkgPSBhbmNob3JZO1xuICAgIHZhciBtaW5DdXRvZmYgPSBjdXRvZmZZO1xuICAgIGZvciAoYW5jaG9yWSA9IDA7IGFuY2hvclkgPD0gMTsgYW5jaG9yWSArPSAwLjUpIHtcbiAgICAgIHRvcCA9IHkgLSBhbmNob3JZICogc2VsZkhlaWdodDtcbiAgICAgIGJvdHRvbSA9IHRvcCArIHNlbGZIZWlnaHQ7XG4gICAgICBjdXRvZmZZID0gTWF0aC5tYXgoMCwgcGFkZGluZyAtIHRvcCkgKyBNYXRoLm1heCgwLCBib3R0b20gLSBoZWlnaHQgKyBwYWRkaW5nKTtcbiAgICAgIGlmIChjdXRvZmZZIDwgbWluQ3V0b2ZmKSB7XG4gICAgICAgIG1pbkN1dG9mZiA9IGN1dG9mZlk7XG4gICAgICAgIGJlc3RBbmNob3JZID0gYW5jaG9yWTtcbiAgICAgIH1cbiAgICB9XG4gICAgYW5jaG9yWSA9IGJlc3RBbmNob3JZO1xuICB9XG4gIHZhciB4U3RlcCA9IDAuNTtcbiAgaWYgKGFuY2hvclkgPT09IDAuNSkge1xuICAgIGFuY2hvclggPSBNYXRoLmZsb29yKGFuY2hvclgpO1xuICAgIHhTdGVwID0gMTtcbiAgfVxuICB2YXIgbGVmdCA9IHggLSBhbmNob3JYICogc2VsZldpZHRoO1xuICB2YXIgcmlnaHQgPSBsZWZ0ICsgc2VsZldpZHRoO1xuICB2YXIgY3V0b2ZmWCA9IE1hdGgubWF4KDAsIHBhZGRpbmcgLSBsZWZ0KSArIE1hdGgubWF4KDAsIHJpZ2h0IC0gd2lkdGggKyBwYWRkaW5nKTtcbiAgaWYgKGN1dG9mZlggPiAwKSB7XG4gICAgdmFyIGJlc3RBbmNob3JYID0gYW5jaG9yWDtcbiAgICB2YXIgX21pbkN1dG9mZiA9IGN1dG9mZlg7XG4gICAgZm9yIChhbmNob3JYID0gMDsgYW5jaG9yWCA8PSAxOyBhbmNob3JYICs9IHhTdGVwKSB7XG4gICAgICBsZWZ0ID0geCAtIGFuY2hvclggKiBzZWxmV2lkdGg7XG4gICAgICByaWdodCA9IGxlZnQgKyBzZWxmV2lkdGg7XG4gICAgICBjdXRvZmZYID0gTWF0aC5tYXgoMCwgcGFkZGluZyAtIGxlZnQpICsgTWF0aC5tYXgoMCwgcmlnaHQgLSB3aWR0aCArIHBhZGRpbmcpO1xuICAgICAgaWYgKGN1dG9mZlggPCBfbWluQ3V0b2ZmKSB7XG4gICAgICAgIF9taW5DdXRvZmYgPSBjdXRvZmZYO1xuICAgICAgICBiZXN0QW5jaG9yWCA9IGFuY2hvclg7XG4gICAgICB9XG4gICAgfVxuICAgIGFuY2hvclggPSBiZXN0QW5jaG9yWDtcbiAgfVxuICByZXR1cm4gQU5DSE9SX1RZUEVTLmZpbmQoZnVuY3Rpb24gKHBvc2l0aW9uVHlwZSkge1xuICAgIHZhciBhbmNob3JQb3NpdGlvbiA9IEFOQ0hPUl9QT1NJVElPTltwb3NpdGlvblR5cGVdO1xuICAgIHJldHVybiBhbmNob3JQb3NpdGlvbi54ID09PSBhbmNob3JYICYmIGFuY2hvclBvc2l0aW9uLnkgPT09IGFuY2hvclk7XG4gIH0pIHx8IGFuY2hvcjtcbn0iLCJpbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sRGVmYXVsdFByb3BzLCBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi91c2UtbWFwLWNvbnRyb2wnO1xuaW1wb3J0IHsgZ2V0RHluYW1pY1Bvc2l0aW9uLCBBTkNIT1JfUE9TSVRJT04gfSBmcm9tICcuLi91dGlscy9keW5hbWljLXBvc2l0aW9uJztcbmltcG9ydCB7IGdldFRlcnJhaW5FbGV2YXRpb24gfSBmcm9tICcuLi91dGlscy90ZXJyYWluJztcbmltcG9ydCB7IGNyaXNwUGVyY2VudGFnZSwgY3Jpc3BQaXhlbCB9IGZyb20gJy4uL3V0aWxzL2NyaXNwLXBpeGVsJztcbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXBDb250cm9sRGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogJycsXG4gIG9mZnNldExlZnQ6IDAsXG4gIG9mZnNldFRvcDogMCxcbiAgdGlwU2l6ZTogMTAsXG4gIGFuY2hvcjogJ2JvdHRvbScsXG4gIGR5bmFtaWNQb3NpdGlvbjogdHJ1ZSxcbiAgc29ydEJ5RGVwdGg6IGZhbHNlLFxuICBjbG9zZUJ1dHRvbjogdHJ1ZSxcbiAgY2xvc2VPbkNsaWNrOiB0cnVlLFxuICBvbkNsb3NlOiBmdW5jdGlvbiBvbkNsb3NlKCkge31cbn0pO1xuZnVuY3Rpb24gZ2V0UG9zaXRpb24ocHJvcHMsIHZpZXdwb3J0LCBlbCwgX3JlZikge1xuICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICB4ID0gX3JlZjJbMF0sXG4gICAgeSA9IF9yZWYyWzFdO1xuICB2YXIgYW5jaG9yID0gcHJvcHMuYW5jaG9yLFxuICAgIGR5bmFtaWNQb3NpdGlvbiA9IHByb3BzLmR5bmFtaWNQb3NpdGlvbixcbiAgICB0aXBTaXplID0gcHJvcHMudGlwU2l6ZTtcbiAgaWYgKGVsKSB7XG4gICAgcmV0dXJuIGR5bmFtaWNQb3NpdGlvbiA/IGdldER5bmFtaWNQb3NpdGlvbih7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgcGFkZGluZzogdGlwU2l6ZSxcbiAgICAgIHdpZHRoOiB2aWV3cG9ydC53aWR0aCxcbiAgICAgIGhlaWdodDogdmlld3BvcnQuaGVpZ2h0LFxuICAgICAgc2VsZldpZHRoOiBlbC5jbGllbnRXaWR0aCxcbiAgICAgIHNlbGZIZWlnaHQ6IGVsLmNsaWVudEhlaWdodFxuICAgIH0pIDogYW5jaG9yO1xuICB9XG4gIHJldHVybiBhbmNob3I7XG59XG5mdW5jdGlvbiBnZXRDb250YWluZXJTdHlsZShwcm9wcywgdmlld3BvcnQsIGVsLCBfcmVmMywgcG9zaXRpb25UeXBlKSB7XG4gIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAzKSxcbiAgICB4ID0gX3JlZjRbMF0sXG4gICAgeSA9IF9yZWY0WzFdLFxuICAgIHogPSBfcmVmNFsyXTtcbiAgdmFyIG9mZnNldExlZnQgPSBwcm9wcy5vZmZzZXRMZWZ0LFxuICAgIG9mZnNldFRvcCA9IHByb3BzLm9mZnNldFRvcCxcbiAgICBzb3J0QnlEZXB0aCA9IHByb3BzLnNvcnRCeURlcHRoO1xuICB2YXIgYW5jaG9yUG9zaXRpb24gPSBBTkNIT1JfUE9TSVRJT05bcG9zaXRpb25UeXBlXTtcbiAgdmFyIGxlZnQgPSB4ICsgb2Zmc2V0TGVmdDtcbiAgdmFyIHRvcCA9IHkgKyBvZmZzZXRUb3A7XG4gIHZhciB4UGVyY2VudGFnZSA9IGNyaXNwUGVyY2VudGFnZShlbCwgLWFuY2hvclBvc2l0aW9uLnggKiAxMDApO1xuICB2YXIgeVBlcmNlbnRhZ2UgPSBjcmlzcFBlcmNlbnRhZ2UoZWwsIC1hbmNob3JQb3NpdGlvbi55ICogMTAwLCAneScpO1xuICB2YXIgc3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdHJhbnNmb3JtOiBcIlxcbiAgICAgIHRyYW5zbGF0ZShcIi5jb25jYXQoeFBlcmNlbnRhZ2UsIFwiJSwgXCIpLmNvbmNhdCh5UGVyY2VudGFnZSwgXCIlKVxcbiAgICAgIHRyYW5zbGF0ZShcIikuY29uY2F0KGNyaXNwUGl4ZWwobGVmdCksIFwicHgsIFwiKS5jb25jYXQoY3Jpc3BQaXhlbCh0b3ApLCBcInB4KVxcbiAgICBcIiksXG4gICAgZGlzcGxheTogdW5kZWZpbmVkLFxuICAgIHpJbmRleDogdW5kZWZpbmVkXG4gIH07XG4gIGlmICghc29ydEJ5RGVwdGgpIHtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cbiAgaWYgKHogPiAxIHx8IHogPCAtMSB8fCB4IDwgMCB8fCB4ID4gdmlld3BvcnQud2lkdGggfHwgeSA8IDAgfHwgeSA+IHZpZXdwb3J0LmhlaWdodCkge1xuICAgIHN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUuekluZGV4ID0gTWF0aC5mbG9vcigoMSAtIHopIC8gMiAqIDEwMDAwMCk7XG4gIH1cbiAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gUG9wdXAocHJvcHMpIHtcbiAgdmFyIGNvbnRlbnRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciB0aGlzUmVmID0gdXNlTWFwQ29udHJvbChwcm9wcyk7XG4gIHZhciBjb250ZXh0ID0gdGhpc1JlZi5jb250ZXh0LFxuICAgIGNvbnRhaW5lclJlZiA9IHRoaXNSZWYuY29udGFpbmVyUmVmO1xuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoZmFsc2UpLFxuICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgIHNldExvYWRlZCA9IF91c2VTdGF0ZTJbMV07XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgc2V0TG9hZGVkKHRydWUpO1xuICB9LCBbY29udGVudFJlZi5jdXJyZW50XSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbnRleHQuZXZlbnRNYW5hZ2VyICYmIHByb3BzLmNsb3NlT25DbGljaykge1xuICAgICAgdmFyIGNsaWNrQ2FsbGJhY2sgPSBmdW5jdGlvbiBjbGlja0NhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpc1JlZi5wcm9wcy5vbkNsb3NlKCk7XG4gICAgICB9O1xuICAgICAgY29udGV4dC5ldmVudE1hbmFnZXIub24oJ2FueWNsaWNrJywgY2xpY2tDYWxsYmFjayk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZXh0LmV2ZW50TWFuYWdlci5vZmYoJ2FueWNsaWNrJywgY2xpY2tDYWxsYmFjayk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LCBbY29udGV4dC5ldmVudE1hbmFnZXIsIHByb3BzLmNsb3NlT25DbGlja10pO1xuICB2YXIgdmlld3BvcnQgPSBjb250ZXh0LnZpZXdwb3J0LFxuICAgIG1hcCA9IGNvbnRleHQubWFwO1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgIGxvbmdpdHVkZSA9IHByb3BzLmxvbmdpdHVkZSxcbiAgICBsYXRpdHVkZSA9IHByb3BzLmxhdGl0dWRlLFxuICAgIHRpcFNpemUgPSBwcm9wcy50aXBTaXplLFxuICAgIGNsb3NlQnV0dG9uID0gcHJvcHMuY2xvc2VCdXR0b24sXG4gICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGFsdGl0dWRlID0gcHJvcHMuYWx0aXR1ZGU7XG4gIGlmIChhbHRpdHVkZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYWx0aXR1ZGUgPSBnZXRUZXJyYWluRWxldmF0aW9uKG1hcCwge1xuICAgICAgbG9uZ2l0dWRlOiBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZTogbGF0aXR1ZGVcbiAgICB9KTtcbiAgfVxuICB2YXIgcG9zaXRpb24gPSB2aWV3cG9ydC5wcm9qZWN0KFtsb25naXR1ZGUsIGxhdGl0dWRlLCBhbHRpdHVkZV0pO1xuICB2YXIgcG9zaXRpb25UeXBlID0gZ2V0UG9zaXRpb24ocHJvcHMsIHZpZXdwb3J0LCBjb250ZW50UmVmLmN1cnJlbnQsIHBvc2l0aW9uKTtcbiAgdmFyIGNvbnRhaW5lclN0eWxlID0gZ2V0Q29udGFpbmVyU3R5bGUocHJvcHMsIHZpZXdwb3J0LCBjb250YWluZXJSZWYuY3VycmVudCwgcG9zaXRpb24sIHBvc2l0aW9uVHlwZSk7XG4gIHZhciBvbkNsaWNrQ2xvc2VCdXR0b24gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZ0KSB7XG4gICAgdGhpc1JlZi5wcm9wcy5vbkNsb3NlKCk7XG4gICAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXNSZWYuY29udGV4dC5ldmVudE1hbmFnZXI7XG4gICAgaWYgKGV2ZW50TWFuYWdlcikge1xuICAgICAgZXZlbnRNYW5hZ2VyLm9uY2UoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9LCBldnQudGFyZ2V0KTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1wb3B1cCBtYXBib3hnbC1wb3B1cC1hbmNob3ItXCIuY29uY2F0KHBvc2l0aW9uVHlwZSwgXCIgXCIpLmNvbmNhdChjbGFzc05hbWUpLFxuICAgIHN0eWxlOiBjb250YWluZXJTdHlsZSxcbiAgICByZWY6IGNvbnRhaW5lclJlZlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IFwidGlwXCIsXG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLXBvcHVwLXRpcFwiLFxuICAgIHN0eWxlOiB7XG4gICAgICBib3JkZXJXaWR0aDogdGlwU2l6ZVxuICAgIH1cbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgcmVmOiBjb250ZW50UmVmLFxuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1wb3B1cC1jb250ZW50XCJcbiAgfSwgY2xvc2VCdXR0b24gJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAga2V5OiBcImNsb3NlLWJ1dHRvblwiLFxuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1wb3B1cC1jbG9zZS1idXR0b25cIixcbiAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgIG9uQ2xpY2s6IG9uQ2xpY2tDbG9zZUJ1dHRvblxuICB9LCBcIlxceEQ3XCIpLCBjaGlsZHJlbikpO1xufVxuUG9wdXAuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhQb3B1cCk7IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IG1hcGJveGdsIGZyb20gJy4uL3V0aWxzL21hcGJveGdsJztcbmltcG9ydCB1c2VNYXBDb250cm9sLCB7IG1hcENvbnRyb2xEZWZhdWx0UHJvcHMsIG1hcENvbnRyb2xQcm9wVHlwZXMgfSBmcm9tICcuL3VzZS1tYXAtY29udHJvbCc7XG52YXIgZGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbWFwQ29udHJvbERlZmF1bHRQcm9wcywge1xuICBjbGFzc05hbWU6ICcnLFxuICB0b2dnbGVMYWJlbDogJ1RvZ2dsZSBBdHRyaWJ1dGlvbidcbn0pO1xuZnVuY3Rpb24gc2V0dXBBdHRyaWJ1dGlvbmNvbnRyb2wob3B0cywgbWFwLCBjb250YWluZXIsIGF0dHJpYnV0aW9uQ29udGFpbmVyKSB7XG4gIHZhciBjb250cm9sID0gbmV3IG1hcGJveGdsLkF0dHJpYnV0aW9uQ29udHJvbChvcHRzKTtcbiAgY29udHJvbC5fbWFwID0gbWFwO1xuICBjb250cm9sLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gIGNvbnRyb2wuX2lubmVyQ29udGFpbmVyID0gYXR0cmlidXRpb25Db250YWluZXI7XG4gIGNvbnRyb2wuX3VwZGF0ZUF0dHJpYnV0aW9ucygpO1xuICBjb250cm9sLl91cGRhdGVFZGl0TGluaygpO1xuICBtYXAub24oJ3N0eWxlZGF0YScsIGNvbnRyb2wuX3VwZGF0ZURhdGEpO1xuICBtYXAub24oJ3NvdXJjZWRhdGEnLCBjb250cm9sLl91cGRhdGVEYXRhKTtcbiAgcmV0dXJuIGNvbnRyb2w7XG59XG5mdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGlvbkNvbnRyb2woY29udHJvbCkge1xuICBjb250cm9sLl9tYXAub2ZmKCdzdHlsZWRhdGEnLCBjb250cm9sLl91cGRhdGVEYXRhKTtcbiAgY29udHJvbC5fbWFwLm9mZignc291cmNlZGF0YScsIGNvbnRyb2wuX3VwZGF0ZURhdGEpO1xufVxuZnVuY3Rpb24gQXR0cmlidXRpb25Db250cm9sKHByb3BzKSB7XG4gIHZhciBfdXNlTWFwQ29udHJvbCA9IHVzZU1hcENvbnRyb2wocHJvcHMpLFxuICAgIGNvbnRleHQgPSBfdXNlTWFwQ29udHJvbC5jb250ZXh0LFxuICAgIGNvbnRhaW5lclJlZiA9IF91c2VNYXBDb250cm9sLmNvbnRhaW5lclJlZjtcbiAgdmFyIGlubmVyQ29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoZmFsc2UpLFxuICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgIHNob3dDb21wYWN0ID0gX3VzZVN0YXRlMlswXSxcbiAgICBzZXRTaG93Q29tcGFjdCA9IF91c2VTdGF0ZTJbMV07XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRyb2w7XG4gICAgaWYgKGNvbnRleHQubWFwKSB7XG4gICAgICBjb250cm9sID0gc2V0dXBBdHRyaWJ1dGlvbmNvbnRyb2woe1xuICAgICAgICBjdXN0b21BdHRyaWJ1dGlvbjogcHJvcHMuY3VzdG9tQXR0cmlidXRpb25cbiAgICAgIH0sIGNvbnRleHQubWFwLCBjb250YWluZXJSZWYuY3VycmVudCwgaW5uZXJDb250YWluZXJSZWYuY3VycmVudCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY29udHJvbCAmJiByZW1vdmVBdHRyaWJ1dGlvbkNvbnRyb2woY29udHJvbCk7XG4gICAgfTtcbiAgfSwgW2NvbnRleHQubWFwXSk7XG4gIHZhciBjb21wYWN0ID0gcHJvcHMuY29tcGFjdCA9PT0gdW5kZWZpbmVkID8gY29udGV4dC52aWV3cG9ydC53aWR0aCA8PSA2NDAgOiBwcm9wcy5jb21wYWN0O1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghY29tcGFjdCAmJiBzaG93Q29tcGFjdCkge1xuICAgICAgc2V0U2hvd0NvbXBhY3QoZmFsc2UpO1xuICAgIH1cbiAgfSwgW2NvbXBhY3RdKTtcbiAgdmFyIHRvZ2dsZUF0dHJpYnV0aW9uID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzZXRTaG93Q29tcGFjdChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiAhdmFsdWU7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgdmFyIHN0eWxlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LCBwcm9wcy5zdHlsZSk7XG4gIH0sIFtwcm9wcy5zdHlsZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIGNsYXNzTmFtZTogcHJvcHMuY2xhc3NOYW1lXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgIFwiYXJpYS1wcmVzc2VkXCI6IHNob3dDb21wYWN0LFxuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsIG1hcGJveGdsLWN0cmwtYXR0cmliIFwiLmNvbmNhdChjb21wYWN0ID8gJ21hcGJveGdsLWNvbXBhY3QnIDogJycsIFwiIFwiKS5jb25jYXQoc2hvd0NvbXBhY3QgPyAnbWFwYm94Z2wtY29tcGFjdC1zaG93JyA6ICcnKVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsLWF0dHJpYi1idXR0b25cIixcbiAgICB0aXRsZTogcHJvcHMudG9nZ2xlTGFiZWwsXG4gICAgb25DbGljazogdG9nZ2xlQXR0cmlidXRpb25cbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogaW5uZXJDb250YWluZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwtYXR0cmliLWlubmVyXCIsXG4gICAgcm9sZTogXCJsaXN0XCJcbiAgfSkpKTtcbn1cbkF0dHJpYnV0aW9uQ29udHJvbC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKEF0dHJpYnV0aW9uQ29udHJvbCk7IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5pbXBvcnQgeyBkb2N1bWVudCB9IGZyb20gJy4uL3V0aWxzL2dsb2JhbHMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBtYXBib3hnbCBmcm9tICcuLi91dGlscy9tYXBib3hnbCc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sRGVmYXVsdFByb3BzLCBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi91c2UtbWFwLWNvbnRyb2wnO1xudmFyIGRlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hcENvbnRyb2xEZWZhdWx0UHJvcHMsIHtcbiAgY2xhc3NOYW1lOiAnJyxcbiAgY29udGFpbmVyOiBudWxsLFxuICBsYWJlbDogJ1RvZ2dsZSBmdWxsc2NyZWVuJ1xufSk7XG5mdW5jdGlvbiBGdWxsc2NyZWVuQ29udHJvbChwcm9wcykge1xuICB2YXIgX3VzZU1hcENvbnRyb2wgPSB1c2VNYXBDb250cm9sKHByb3BzKSxcbiAgICBjb250ZXh0ID0gX3VzZU1hcENvbnRyb2wuY29udGV4dCxcbiAgICBjb250YWluZXJSZWYgPSBfdXNlTWFwQ29udHJvbC5jb250YWluZXJSZWY7XG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShmYWxzZSksXG4gICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgaXNGdWxsc2NyZWVuID0gX3VzZVN0YXRlMlswXSxcbiAgICBzZXRJc0Z1bGxzY3JlZW4gPSBfdXNlU3RhdGUyWzFdO1xuICB2YXIgX3VzZVN0YXRlMyA9IHVzZVN0YXRlKGZhbHNlKSxcbiAgICBfdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMywgMiksXG4gICAgc2hvd0J1dHRvbiA9IF91c2VTdGF0ZTRbMF0sXG4gICAgc2V0U2hvd0J1dHRvbiA9IF91c2VTdGF0ZTRbMV07XG4gIHZhciBfdXNlU3RhdGU1ID0gdXNlU3RhdGUobnVsbCksXG4gICAgX3VzZVN0YXRlNiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZTUsIDIpLFxuICAgIG1hcGJveEZ1bGxzY3JlZW5Db250cm9sID0gX3VzZVN0YXRlNlswXSxcbiAgICBjcmVhdGVNYXBib3hGdWxsc2NyZWVuQ29udHJvbCA9IF91c2VTdGF0ZTZbMV07XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRyb2wgPSBuZXcgbWFwYm94Z2wuRnVsbHNjcmVlbkNvbnRyb2woKTtcbiAgICBjcmVhdGVNYXBib3hGdWxsc2NyZWVuQ29udHJvbChjb250cm9sKTtcbiAgICBzZXRTaG93QnV0dG9uKGNvbnRyb2wuX2NoZWNrRnVsbHNjcmVlblN1cHBvcnQoKSk7XG4gICAgdmFyIG9uRnVsbHNjcmVlbkNoYW5nZSA9IGZ1bmN0aW9uIG9uRnVsbHNjcmVlbkNoYW5nZSgpIHtcbiAgICAgIHZhciBuZXh0U3RhdGUgPSAhY29udHJvbC5fZnVsbHNjcmVlbjtcbiAgICAgIGNvbnRyb2wuX2Z1bGxzY3JlZW4gPSBuZXh0U3RhdGU7XG4gICAgICBzZXRJc0Z1bGxzY3JlZW4obmV4dFN0YXRlKTtcbiAgICB9O1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoY29udHJvbC5fZnVsbHNjcmVlbmNoYW5nZSwgb25GdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihjb250cm9sLl9mdWxsc2NyZWVuY2hhbmdlLCBvbkZ1bGxzY3JlZW5DaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgdmFyIG9uQ2xpY2tGdWxsc2NyZWVuID0gZnVuY3Rpb24gb25DbGlja0Z1bGxzY3JlZW4oKSB7XG4gICAgaWYgKG1hcGJveEZ1bGxzY3JlZW5Db250cm9sKSB7XG4gICAgICBtYXBib3hGdWxsc2NyZWVuQ29udHJvbC5fY29udGFpbmVyID0gcHJvcHMuY29udGFpbmVyIHx8IGNvbnRleHQuY29udGFpbmVyO1xuICAgICAgbWFwYm94RnVsbHNjcmVlbkNvbnRyb2wuX29uQ2xpY2tGdWxsc2NyZWVuKCk7XG4gICAgfVxuICB9O1xuICB2YXIgc3R5bGUgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sIHByb3BzLnN0eWxlKTtcbiAgfSwgW3Byb3BzLnN0eWxlXSk7XG4gIGlmICghc2hvd0J1dHRvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgbGFiZWwgPSBwcm9wcy5sYWJlbDtcbiAgdmFyIHR5cGUgPSBpc0Z1bGxzY3JlZW4gPyAnc2hyaW5rJyA6ICdmdWxsc2NyZWVuJztcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHN0eWxlOiBzdHlsZSxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybCBtYXBib3hnbC1jdHJsLWdyb3VwXCIsXG4gICAgcmVmOiBjb250YWluZXJSZWZcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAga2V5OiB0eXBlLFxuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsLWljb24gbWFwYm94Z2wtY3RybC1cIi5jb25jYXQodHlwZSksXG4gICAgdHlwZTogXCJidXR0b25cIixcbiAgICB0aXRsZTogbGFiZWwsXG4gICAgb25DbGljazogb25DbGlja0Z1bGxzY3JlZW5cbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsLWljb25cIixcbiAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiXG4gIH0pKSkpO1xufVxuRnVsbHNjcmVlbkNvbnRyb2wuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhGdWxsc2NyZWVuQ29udHJvbCk7IiwidmFyIHN1cHBvcnRlZDtcbmV4cG9ydCBmdW5jdGlvbiBpc0dlb2xvY2F0aW9uU3VwcG9ydGVkKCkge1xuICBpZiAoc3VwcG9ydGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHN1cHBvcnRlZCk7XG4gIH1cbiAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IucGVybWlzc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5KHtcbiAgICAgIG5hbWU6ICdnZW9sb2NhdGlvbidcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChwKSB7XG4gICAgICBzdXBwb3J0ZWQgPSBwLnN0YXRlICE9PSAnZGVuaWVkJztcbiAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gICAgfSk7XG4gIH1cbiAgc3VwcG9ydGVkID0gQm9vbGVhbih3aW5kb3cubmF2aWdhdG9yLmdlb2xvY2F0aW9uKTtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzdXBwb3J0ZWQpO1xufSIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlUmVmLCB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGRvY3VtZW50IH0gZnJvbSAnLi4vdXRpbHMvZ2xvYmFscyc7XG5pbXBvcnQgbWFwYm94Z2wgZnJvbSAnLi4vdXRpbHMvbWFwYm94Z2wnO1xuaW1wb3J0IE1hcFN0YXRlIGZyb20gJy4uL3V0aWxzL21hcC1zdGF0ZSc7XG5pbXBvcnQgeyBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyB9IGZyb20gJy4uL3V0aWxzL21hcC1jb250cm9sbGVyJztcbmltcG9ydCB7IGlzR2VvbG9jYXRpb25TdXBwb3J0ZWQgfSBmcm9tICcuLi91dGlscy9nZW9sb2NhdGUtdXRpbHMnO1xuaW1wb3J0IHVzZU1hcENvbnRyb2wsIHsgbWFwQ29udHJvbERlZmF1bHRQcm9wcywgbWFwQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4vdXNlLW1hcC1jb250cm9sJztcbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xudmFyIGRlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hcENvbnRyb2xEZWZhdWx0UHJvcHMsIHtcbiAgY2xhc3NOYW1lOiAnJyxcbiAgbGFiZWw6ICdGaW5kIE15IExvY2F0aW9uJyxcbiAgZGlzYWJsZWRMYWJlbDogJ0xvY2F0aW9uIE5vdCBBdmFpbGFibGUnLFxuICBhdXRvOiBmYWxzZSxcbiAgcG9zaXRpb25PcHRpb25zOiB7XG4gICAgZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZSxcbiAgICB0aW1lb3V0OiA2MDAwXG4gIH0sXG4gIGZpdEJvdW5kc09wdGlvbnM6IHtcbiAgICBtYXhab29tOiAxNVxuICB9LFxuICB0cmFja1VzZXJMb2NhdGlvbjogZmFsc2UsXG4gIHNob3dVc2VyTG9jYXRpb246IHRydWUsXG4gIHNob3dVc2VySGVhZGluZzogZmFsc2UsXG4gIHNob3dBY2N1cmFjeUNpcmNsZTogdHJ1ZSxcbiAgb25HZW9sb2NhdGU6IGZ1bmN0aW9uIG9uR2VvbG9jYXRlKCkge31cbn0pO1xuZnVuY3Rpb24gZ2V0Qm91bmRzKHBvc2l0aW9uKSB7XG4gIHZhciBjZW50ZXIgPSBuZXcgbWFwYm94Z2wuTG5nTGF0KHBvc2l0aW9uLmNvb3Jkcy5sb25naXR1ZGUsIHBvc2l0aW9uLmNvb3Jkcy5sYXRpdHVkZSk7XG4gIHZhciByYWRpdXMgPSBwb3NpdGlvbi5jb29yZHMuYWNjdXJhY3k7XG4gIHZhciBib3VuZHMgPSBjZW50ZXIudG9Cb3VuZHMocmFkaXVzKTtcbiAgcmV0dXJuIFtbYm91bmRzLl9uZS5sbmcsIGJvdW5kcy5fbmUubGF0XSwgW2JvdW5kcy5fc3cubG5nLCBib3VuZHMuX3N3LmxhdF1dO1xufVxuZnVuY3Rpb24gc2V0dXBNYXBib3hHZW9sb2NhdGVDb250cm9sKGNvbnRleHQsIHByb3BzLCBnZW9sb2NhdGVCdXR0b24pIHtcbiAgdmFyIGNvbnRyb2wgPSBuZXcgbWFwYm94Z2wuR2VvbG9jYXRlQ29udHJvbChwcm9wcyk7XG4gIGNvbnRyb2wuX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb250cm9sLl9tYXAgPSB7XG4gICAgb246IGZ1bmN0aW9uIG9uKCkge30sXG4gICAgX2dldFVJU3RyaW5nOiBmdW5jdGlvbiBfZ2V0VUlTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9O1xuICBjb250cm9sLl9zZXR1cFVJKHRydWUpO1xuICBjb250cm9sLl9tYXAgPSBjb250ZXh0Lm1hcDtcbiAgY29udHJvbC5fZ2VvbG9jYXRlQnV0dG9uID0gZ2VvbG9jYXRlQnV0dG9uO1xuICB2YXIgZXZlbnRNYW5hZ2VyID0gY29udGV4dC5ldmVudE1hbmFnZXI7XG4gIGlmIChjb250cm9sLm9wdGlvbnMudHJhY2tVc2VyTG9jYXRpb24gJiYgZXZlbnRNYW5hZ2VyKSB7XG4gICAgZXZlbnRNYW5hZ2VyLm9uKCdwYW5zdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjb250cm9sLl93YXRjaFN0YXRlID09PSAnQUNUSVZFX0xPQ0snKSB7XG4gICAgICAgIGNvbnRyb2wuX3dhdGNoU3RhdGUgPSAnQkFDS0dST1VORCc7XG4gICAgICAgIGdlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kJyk7XG4gICAgICAgIGdlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb250cm9sLm9uKCdnZW9sb2NhdGUnLCBwcm9wcy5vbkdlb2xvY2F0ZSk7XG4gIHJldHVybiBjb250cm9sO1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FtZXJhKHBvc2l0aW9uLCBfcmVmKSB7XG4gIHZhciBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxuICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgdmFyIGJvdW5kcyA9IGdldEJvdW5kcyhwb3NpdGlvbik7XG4gIHZhciBfY29udGV4dCR2aWV3cG9ydCRmaXQgPSBjb250ZXh0LnZpZXdwb3J0LmZpdEJvdW5kcyhib3VuZHMsIHByb3BzLmZpdEJvdW5kc09wdGlvbnMpLFxuICAgIGxvbmdpdHVkZSA9IF9jb250ZXh0JHZpZXdwb3J0JGZpdC5sb25naXR1ZGUsXG4gICAgbGF0aXR1ZGUgPSBfY29udGV4dCR2aWV3cG9ydCRmaXQubGF0aXR1ZGUsXG4gICAgem9vbSA9IF9jb250ZXh0JHZpZXdwb3J0JGZpdC56b29tO1xuICB2YXIgbmV3Vmlld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dC52aWV3cG9ydCwge1xuICAgIGxvbmdpdHVkZTogbG9uZ2l0dWRlLFxuICAgIGxhdGl0dWRlOiBsYXRpdHVkZSxcbiAgICB6b29tOiB6b29tXG4gIH0pO1xuICB2YXIgbWFwU3RhdGUgPSBuZXcgTWFwU3RhdGUobmV3Vmlld1N0YXRlKTtcbiAgdmFyIHZpZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1hcFN0YXRlLmdldFZpZXdwb3J0UHJvcHMoKSwgTElORUFSX1RSQU5TSVRJT05fUFJPUFMpO1xuICB2YXIgb25WaWV3cG9ydENoYW5nZSA9IHByb3BzLm9uVmlld3BvcnRDaGFuZ2UgfHwgY29udGV4dC5vblZpZXdwb3J0Q2hhbmdlIHx8IG5vb3A7XG4gIHZhciBvblZpZXdTdGF0ZUNoYW5nZSA9IHByb3BzLm9uVmlld1N0YXRlQ2hhbmdlIHx8IGNvbnRleHQub25WaWV3U3RhdGVDaGFuZ2UgfHwgbm9vcDtcbiAgb25WaWV3U3RhdGVDaGFuZ2Uoe1xuICAgIHZpZXdTdGF0ZTogdmlld1N0YXRlXG4gIH0pO1xuICBvblZpZXdwb3J0Q2hhbmdlKHZpZXdTdGF0ZSk7XG59XG5mdW5jdGlvbiBHZW9sb2NhdGVDb250cm9sKHByb3BzKSB7XG4gIHZhciB0aGlzUmVmID0gdXNlTWFwQ29udHJvbChwcm9wcyk7XG4gIHZhciBjb250ZXh0ID0gdGhpc1JlZi5jb250ZXh0LFxuICAgIGNvbnRhaW5lclJlZiA9IHRoaXNSZWYuY29udGFpbmVyUmVmO1xuICB2YXIgZ2VvbG9jYXRlQnV0dG9uUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUobnVsbCksXG4gICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgbWFwYm94R2VvbG9jYXRlQ29udHJvbCA9IF91c2VTdGF0ZTJbMF0sXG4gICAgY3JlYXRlTWFwYm94R2VvbG9jYXRlQ29udHJvbCA9IF91c2VTdGF0ZTJbMV07XG4gIHZhciBfdXNlU3RhdGUzID0gdXNlU3RhdGUoZmFsc2UpLFxuICAgIF91c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUzLCAyKSxcbiAgICBzdXBwb3J0c0dlb2xvY2F0aW9uID0gX3VzZVN0YXRlNFswXSxcbiAgICBzZXRTdXBwb3J0c0dlb2xvY2F0aW9uID0gX3VzZVN0YXRlNFsxXTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udHJvbDtcbiAgICBpZiAoY29udGV4dC5tYXApIHtcbiAgICAgIGlzR2VvbG9jYXRpb25TdXBwb3J0ZWQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgc2V0U3VwcG9ydHNHZW9sb2NhdGlvbihyZXN1bHQpO1xuICAgICAgICBpZiAoZ2VvbG9jYXRlQnV0dG9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBjb250cm9sID0gc2V0dXBNYXBib3hHZW9sb2NhdGVDb250cm9sKGNvbnRleHQsIHByb3BzLCBnZW9sb2NhdGVCdXR0b25SZWYuY3VycmVudCk7XG4gICAgICAgICAgY29udHJvbC5fdXBkYXRlQ2FtZXJhID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlQ2FtZXJhKHBvc2l0aW9uLCB0aGlzUmVmKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNyZWF0ZU1hcGJveEdlb2xvY2F0ZUNvbnRyb2woY29udHJvbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNvbnRyb2wpIHtcbiAgICAgICAgY29udHJvbC5fY2xlYXJXYXRjaCgpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtjb250ZXh0Lm1hcF0pO1xuICB2YXIgdHJpZ2dlckdlb2xvY2F0ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobWFwYm94R2VvbG9jYXRlQ29udHJvbCkge1xuICAgICAgbWFwYm94R2VvbG9jYXRlQ29udHJvbC5vcHRpb25zID0gdGhpc1JlZi5wcm9wcztcbiAgICAgIG1hcGJveEdlb2xvY2F0ZUNvbnRyb2wudHJpZ2dlcigpO1xuICAgIH1cbiAgfSwgW21hcGJveEdlb2xvY2F0ZUNvbnRyb2xdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJvcHMuYXV0bykge1xuICAgICAgdHJpZ2dlckdlb2xvY2F0ZSgpO1xuICAgIH1cbiAgfSwgW21hcGJveEdlb2xvY2F0ZUNvbnRyb2wsIHByb3BzLmF1dG9dKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobWFwYm94R2VvbG9jYXRlQ29udHJvbCkge1xuICAgICAgbWFwYm94R2VvbG9jYXRlQ29udHJvbC5fb25ab29tKCk7XG4gICAgfVxuICB9LCBbY29udGV4dC52aWV3cG9ydC56b29tXSk7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgbGFiZWwgPSBwcm9wcy5sYWJlbCxcbiAgICBkaXNhYmxlZExhYmVsID0gcHJvcHMuZGlzYWJsZWRMYWJlbCxcbiAgICB0cmFja1VzZXJMb2NhdGlvbiA9IHByb3BzLnRyYWNrVXNlckxvY2F0aW9uO1xuICB2YXIgc3R5bGUgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sIHByb3BzLnN0eWxlKTtcbiAgfSwgW3Byb3BzLnN0eWxlXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAga2V5OiBcImdlb2xvY2F0ZS1jb250cm9sXCIsXG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwgbWFwYm94Z2wtY3RybC1ncm91cFwiLFxuICAgIHJlZjogY29udGFpbmVyUmVmXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIGtleTogXCJnZW9sb2NhdGVcIixcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybC1pY29uIG1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlXCIsXG4gICAgcmVmOiBnZW9sb2NhdGVCdXR0b25SZWYsXG4gICAgZGlzYWJsZWQ6ICFzdXBwb3J0c0dlb2xvY2F0aW9uLFxuICAgIFwiYXJpYS1wcmVzc2VkXCI6ICF0cmFja1VzZXJMb2NhdGlvbixcbiAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgIHRpdGxlOiBzdXBwb3J0c0dlb2xvY2F0aW9uID8gbGFiZWwgOiBkaXNhYmxlZExhYmVsLFxuICAgIFwiYXJpYS1sYWJlbFwiOiBzdXBwb3J0c0dlb2xvY2F0aW9uID8gbGFiZWwgOiBkaXNhYmxlZExhYmVsLFxuICAgIG9uQ2xpY2s6IHRyaWdnZXJHZW9sb2NhdGVcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsLWljb25cIixcbiAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiXG4gIH0pKSkpO1xufVxuR2VvbG9jYXRlQ29udHJvbC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKEdlb2xvY2F0ZUNvbnRyb2wpOyIsImV4cG9ydCBmdW5jdGlvbiBjb21wYXJlVmVyc2lvbnModmVyc2lvbjEsIHZlcnNpb24yKSB7XG4gIHZhciB2MSA9ICh2ZXJzaW9uMSB8fCAnJykuc3BsaXQoJy4nKS5tYXAoTnVtYmVyKTtcbiAgdmFyIHYyID0gKHZlcnNpb24yIHx8ICcnKS5zcGxpdCgnLicpLm1hcChOdW1iZXIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHZhciBwYXJ0MSA9IHYxW2ldIHx8IDA7XG4gICAgdmFyIHBhcnQyID0gdjJbaV0gfHwgMDtcbiAgICBpZiAocGFydDEgPCBwYXJ0Mikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAocGFydDEgPiBwYXJ0Mikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufSIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgTWFwU3RhdGUgZnJvbSAnLi4vdXRpbHMvbWFwLXN0YXRlJztcbmltcG9ydCB7IExJTkVBUl9UUkFOU0lUSU9OX1BST1BTIH0gZnJvbSAnLi4vdXRpbHMvbWFwLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgY29tcGFyZVZlcnNpb25zIH0gZnJvbSAnLi4vdXRpbHMvdmVyc2lvbic7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sRGVmYXVsdFByb3BzLCBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi91c2UtbWFwLWNvbnRyb2wnO1xudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG52YXIgZGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbWFwQ29udHJvbERlZmF1bHRQcm9wcywge1xuICBjbGFzc05hbWU6ICcnLFxuICBzaG93Q29tcGFzczogdHJ1ZSxcbiAgc2hvd1pvb206IHRydWUsXG4gIHpvb21JbkxhYmVsOiAnWm9vbSBJbicsXG4gIHpvb21PdXRMYWJlbDogJ1pvb20gT3V0JyxcbiAgY29tcGFzc0xhYmVsOiAnUmVzZXQgTm9ydGgnXG59KTtcbnZhciBWRVJTSU9OX0xFR0FDWSA9IDE7XG52YXIgVkVSU0lPTl8xXzYgPSAyO1xuZnVuY3Rpb24gZ2V0VUlWZXJzaW9uKG1hcGJveFZlcnNpb24pIHtcbiAgcmV0dXJuIGNvbXBhcmVWZXJzaW9ucyhtYXBib3hWZXJzaW9uLCAnMS42LjAnKSA+PSAwID8gVkVSU0lPTl8xXzYgOiBWRVJTSU9OX0xFR0FDWTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVZpZXdwb3J0KGNvbnRleHQsIHByb3BzLCBvcHRzKSB7XG4gIHZhciB2aWV3cG9ydCA9IGNvbnRleHQudmlld3BvcnQ7XG4gIHZhciBtYXBTdGF0ZSA9IG5ldyBNYXBTdGF0ZShPYmplY3QuYXNzaWduKHt9LCB2aWV3cG9ydCwgb3B0cykpO1xuICB2YXIgdmlld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgbWFwU3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpLCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyk7XG4gIHZhciBvblZpZXdwb3J0Q2hhbmdlID0gcHJvcHMub25WaWV3cG9ydENoYW5nZSB8fCBjb250ZXh0Lm9uVmlld3BvcnRDaGFuZ2UgfHwgbm9vcDtcbiAgdmFyIG9uVmlld1N0YXRlQ2hhbmdlID0gcHJvcHMub25WaWV3U3RhdGVDaGFuZ2UgfHwgY29udGV4dC5vblZpZXdTdGF0ZUNoYW5nZSB8fCBub29wO1xuICBvblZpZXdTdGF0ZUNoYW5nZSh7XG4gICAgdmlld1N0YXRlOiB2aWV3U3RhdGVcbiAgfSk7XG4gIG9uVmlld3BvcnRDaGFuZ2Uodmlld1N0YXRlKTtcbn1cbmZ1bmN0aW9uIHJlbmRlckJ1dHRvbih0eXBlLCBsYWJlbCwgY2FsbGJhY2ssIGNoaWxkcmVuKSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICBrZXk6IHR5cGUsXG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwtaWNvbiBtYXBib3hnbC1jdHJsLVwiLmNvbmNhdCh0eXBlKSxcbiAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgIHRpdGxlOiBsYWJlbCxcbiAgICBvbkNsaWNrOiBjYWxsYmFja1xuICB9LCBjaGlsZHJlbiB8fCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwtaWNvblwiLFxuICAgIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCJcbiAgfSkpO1xufVxuZnVuY3Rpb24gcmVuZGVyQ29tcGFzcyhjb250ZXh0KSB7XG4gIHZhciB1aVZlcnNpb24gPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29udGV4dC5tYXAgPyBnZXRVSVZlcnNpb24oY29udGV4dC5tYXAudmVyc2lvbikgOiBWRVJTSU9OXzFfNjtcbiAgfSwgW2NvbnRleHQubWFwXSk7XG4gIHZhciBiZWFyaW5nID0gY29udGV4dC52aWV3cG9ydC5iZWFyaW5nO1xuICB2YXIgc3R5bGUgPSB7XG4gICAgdHJhbnNmb3JtOiBcInJvdGF0ZShcIi5jb25jYXQoLWJlYXJpbmcsIFwiZGVnKVwiKVxuICB9O1xuICByZXR1cm4gdWlWZXJzaW9uID09PSBWRVJTSU9OXzFfNiA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybC1pY29uXCIsXG4gICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIixcbiAgICBzdHlsZTogc3R5bGVcbiAgfSkgOiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwtY29tcGFzcy1hcnJvd1wiLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9KTtcbn1cbmZ1bmN0aW9uIE5hdmlnYXRpb25Db250cm9sKHByb3BzKSB7XG4gIHZhciBfdXNlTWFwQ29udHJvbCA9IHVzZU1hcENvbnRyb2wocHJvcHMpLFxuICAgIGNvbnRleHQgPSBfdXNlTWFwQ29udHJvbC5jb250ZXh0LFxuICAgIGNvbnRhaW5lclJlZiA9IF91c2VNYXBDb250cm9sLmNvbnRhaW5lclJlZjtcbiAgdmFyIG9uWm9vbUluID0gZnVuY3Rpb24gb25ab29tSW4oKSB7XG4gICAgdXBkYXRlVmlld3BvcnQoY29udGV4dCwgcHJvcHMsIHtcbiAgICAgIHpvb206IGNvbnRleHQudmlld3BvcnQuem9vbSArIDFcbiAgICB9KTtcbiAgfTtcbiAgdmFyIG9uWm9vbU91dCA9IGZ1bmN0aW9uIG9uWm9vbU91dCgpIHtcbiAgICB1cGRhdGVWaWV3cG9ydChjb250ZXh0LCBwcm9wcywge1xuICAgICAgem9vbTogY29udGV4dC52aWV3cG9ydC56b29tIC0gMVxuICAgIH0pO1xuICB9O1xuICB2YXIgb25SZXNldE5vcnRoID0gZnVuY3Rpb24gb25SZXNldE5vcnRoKCkge1xuICAgIHVwZGF0ZVZpZXdwb3J0KGNvbnRleHQsIHByb3BzLCB7XG4gICAgICBiZWFyaW5nOiAwLFxuICAgICAgcGl0Y2g6IDBcbiAgICB9KTtcbiAgfTtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICBzaG93Q29tcGFzcyA9IHByb3BzLnNob3dDb21wYXNzLFxuICAgIHNob3dab29tID0gcHJvcHMuc2hvd1pvb20sXG4gICAgem9vbUluTGFiZWwgPSBwcm9wcy56b29tSW5MYWJlbCxcbiAgICB6b29tT3V0TGFiZWwgPSBwcm9wcy56b29tT3V0TGFiZWwsXG4gICAgY29tcGFzc0xhYmVsID0gcHJvcHMuY29tcGFzc0xhYmVsO1xuICB2YXIgc3R5bGUgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sIHByb3BzLnN0eWxlKTtcbiAgfSwgW3Byb3BzLnN0eWxlXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwgbWFwYm94Z2wtY3RybC1ncm91cFwiLFxuICAgIHJlZjogY29udGFpbmVyUmVmXG4gIH0sIHNob3dab29tICYmIHJlbmRlckJ1dHRvbignem9vbS1pbicsIHpvb21JbkxhYmVsLCBvblpvb21JbiksIHNob3dab29tICYmIHJlbmRlckJ1dHRvbignem9vbS1vdXQnLCB6b29tT3V0TGFiZWwsIG9uWm9vbU91dCksIHNob3dDb21wYXNzICYmIHJlbmRlckJ1dHRvbignY29tcGFzcycsIGNvbXBhc3NMYWJlbCwgb25SZXNldE5vcnRoLCByZW5kZXJDb21wYXNzKGNvbnRleHQpKSkpO1xufVxuTmF2aWdhdGlvbkNvbnRyb2wuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhOYXZpZ2F0aW9uQ29udHJvbCk7IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IG1hcGJveGdsIGZyb20gJy4uL3V0aWxzL21hcGJveGdsJztcbmltcG9ydCB1c2VNYXBDb250cm9sLCB7IG1hcENvbnRyb2xEZWZhdWx0UHJvcHMsIG1hcENvbnRyb2xQcm9wVHlwZXMgfSBmcm9tICcuL3VzZS1tYXAtY29udHJvbCc7XG52YXIgZGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbWFwQ29udHJvbERlZmF1bHRQcm9wcywge1xuICBjbGFzc05hbWU6ICcnLFxuICBtYXhXaWR0aDogMTAwLFxuICB1bml0OiAnbWV0cmljJ1xufSk7XG5mdW5jdGlvbiBTY2FsZUNvbnRyb2wocHJvcHMpIHtcbiAgdmFyIF91c2VNYXBDb250cm9sID0gdXNlTWFwQ29udHJvbChwcm9wcyksXG4gICAgY29udGV4dCA9IF91c2VNYXBDb250cm9sLmNvbnRleHQsXG4gICAgY29udGFpbmVyUmVmID0gX3VzZU1hcENvbnRyb2wuY29udGFpbmVyUmVmO1xuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUobnVsbCksXG4gICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgbWFwYm94U2NhbGVDb250cm9sID0gX3VzZVN0YXRlMlswXSxcbiAgICBjcmVhdGVNYXBib3hTY2FsZUNvbnRyb2wgPSBfdXNlU3RhdGUyWzFdO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb250ZXh0Lm1hcCkge1xuICAgICAgdmFyIGNvbnRyb2wgPSBuZXcgbWFwYm94Z2wuU2NhbGVDb250cm9sKCk7XG4gICAgICBjb250cm9sLl9tYXAgPSBjb250ZXh0Lm1hcDtcbiAgICAgIGNvbnRyb2wuX2NvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgY3JlYXRlTWFwYm94U2NhbGVDb250cm9sKGNvbnRyb2wpO1xuICAgIH1cbiAgfSwgW2NvbnRleHQubWFwXSk7XG4gIGlmIChtYXBib3hTY2FsZUNvbnRyb2wpIHtcbiAgICBtYXBib3hTY2FsZUNvbnRyb2wub3B0aW9ucyA9IHByb3BzO1xuICAgIGlmIChtYXBib3hTY2FsZUNvbnRyb2wuX29uTW92ZSkgbWFwYm94U2NhbGVDb250cm9sLl9vbk1vdmUoKTtcbiAgfVxuICB2YXIgc3R5bGUgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sIHByb3BzLnN0eWxlKTtcbiAgfSwgW3Byb3BzLnN0eWxlXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgY2xhc3NOYW1lOiBwcm9wcy5jbGFzc05hbWVcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwgbWFwYm94Z2wtY3RybC1zY2FsZVwiXG4gIH0pKTtcbn1cblNjYWxlQ29udHJvbC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKFNjYWxlQ29udHJvbCk7IiwiaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZU1hcENvbnRyb2wsIHsgbWFwQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4uL2NvbXBvbmVudHMvdXNlLW1hcC1jb250cm9sJztcbnZhciBwaXhlbFJhdGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGNhcHR1cmVTY3JvbGw6IGZhbHNlLFxuICBjYXB0dXJlRHJhZzogZmFsc2UsXG4gIGNhcHR1cmVDbGljazogZmFsc2UsXG4gIGNhcHR1cmVEb3VibGVDbGljazogZmFsc2UsXG4gIGNhcHR1cmVQb2ludGVyTW92ZTogZmFsc2Vcbn07XG5mdW5jdGlvbiBDYW52YXNPdmVybGF5KHByb3BzKSB7XG4gIHZhciBfdXNlTWFwQ29udHJvbCA9IHVzZU1hcENvbnRyb2wocHJvcHMpLFxuICAgIGNvbnRleHQgPSBfdXNlTWFwQ29udHJvbC5jb250ZXh0LFxuICAgIGNvbnRhaW5lclJlZiA9IF91c2VNYXBDb250cm9sLmNvbnRhaW5lclJlZjtcbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKG51bGwpLFxuICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgIGN0eCA9IF91c2VTdGF0ZTJbMF0sXG4gICAgc2V0RHJhd2luZ0NvbnRleHQgPSBfdXNlU3RhdGUyWzFdO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHNldERyYXdpbmdDb250ZXh0KGNvbnRhaW5lclJlZi5jdXJyZW50LmdldENvbnRleHQoJzJkJykpO1xuICB9LCBbXSk7XG4gIHZhciB2aWV3cG9ydCA9IGNvbnRleHQudmlld3BvcnQsXG4gICAgaXNEcmFnZ2luZyA9IGNvbnRleHQuaXNEcmFnZ2luZztcbiAgaWYgKGN0eCkge1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgIHByb3BzLnJlZHJhdyh7XG4gICAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgICBoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCxcbiAgICAgIGN0eDogY3R4LFxuICAgICAgaXNEcmFnZ2luZzogaXNEcmFnZ2luZyxcbiAgICAgIHByb2plY3Q6IHZpZXdwb3J0LnByb2plY3QsXG4gICAgICB1bnByb2plY3Q6IHZpZXdwb3J0LnVucHJvamVjdFxuICAgIH0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiwge1xuICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgIHdpZHRoOiB2aWV3cG9ydC53aWR0aCAqIHBpeGVsUmF0aW8sXG4gICAgaGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHQgKiBwaXhlbFJhdGlvLFxuICAgIHN0eWxlOiB7XG4gICAgICB3aWR0aDogXCJcIi5jb25jYXQodmlld3BvcnQud2lkdGgsIFwicHhcIiksXG4gICAgICBoZWlnaHQ6IFwiXCIuY29uY2F0KHZpZXdwb3J0LmhlaWdodCwgXCJweFwiKSxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMFxuICAgIH1cbiAgfSk7XG59XG5DYW52YXNPdmVybGF5LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbmV4cG9ydCBkZWZhdWx0IENhbnZhc092ZXJsYXk7IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZU1hcENvbnRyb2wsIHsgbWFwQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4uL2NvbXBvbmVudHMvdXNlLW1hcC1jb250cm9sJztcbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGNhcHR1cmVTY3JvbGw6IGZhbHNlLFxuICBjYXB0dXJlRHJhZzogZmFsc2UsXG4gIGNhcHR1cmVDbGljazogZmFsc2UsXG4gIGNhcHR1cmVEb3VibGVDbGljazogZmFsc2UsXG4gIGNhcHR1cmVQb2ludGVyTW92ZTogZmFsc2Vcbn07XG5mdW5jdGlvbiBIVE1MT3ZlcmxheShwcm9wcykge1xuICB2YXIgX3VzZU1hcENvbnRyb2wgPSB1c2VNYXBDb250cm9sKHByb3BzKSxcbiAgICBjb250ZXh0ID0gX3VzZU1hcENvbnRyb2wuY29udGV4dCxcbiAgICBjb250YWluZXJSZWYgPSBfdXNlTWFwQ29udHJvbC5jb250YWluZXJSZWY7XG4gIHZhciB2aWV3cG9ydCA9IGNvbnRleHQudmlld3BvcnQsXG4gICAgaXNEcmFnZ2luZyA9IGNvbnRleHQuaXNEcmFnZ2luZztcbiAgdmFyIHN0eWxlID0gX29iamVjdFNwcmVhZCh7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gICAgd2lkdGg6IHZpZXdwb3J0LndpZHRoLFxuICAgIGhlaWdodDogdmlld3BvcnQuaGVpZ2h0XG4gIH0sIHByb3BzLnN0eWxlKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9LCBwcm9wcy5yZWRyYXcoe1xuICAgIHdpZHRoOiB2aWV3cG9ydC53aWR0aCxcbiAgICBoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCxcbiAgICBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nLFxuICAgIHByb2plY3Q6IHZpZXdwb3J0LnByb2plY3QsXG4gICAgdW5wcm9qZWN0OiB2aWV3cG9ydC51bnByb2plY3RcbiAgfSkpO1xufVxuSFRNTE92ZXJsYXkuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuZXhwb3J0IGRlZmF1bHQgSFRNTE92ZXJsYXk7IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZU1hcENvbnRyb2wsIHsgbWFwQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4uL2NvbXBvbmVudHMvdXNlLW1hcC1jb250cm9sJztcbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGNhcHR1cmVTY3JvbGw6IGZhbHNlLFxuICBjYXB0dXJlRHJhZzogZmFsc2UsXG4gIGNhcHR1cmVDbGljazogZmFsc2UsXG4gIGNhcHR1cmVEb3VibGVDbGljazogZmFsc2UsXG4gIGNhcHR1cmVQb2ludGVyTW92ZTogZmFsc2Vcbn07XG5mdW5jdGlvbiBTVkdPdmVybGF5KHByb3BzKSB7XG4gIHZhciBfdXNlTWFwQ29udHJvbCA9IHVzZU1hcENvbnRyb2wocHJvcHMpLFxuICAgIGNvbnRleHQgPSBfdXNlTWFwQ29udHJvbC5jb250ZXh0LFxuICAgIGNvbnRhaW5lclJlZiA9IF91c2VNYXBDb250cm9sLmNvbnRhaW5lclJlZjtcbiAgdmFyIHZpZXdwb3J0ID0gY29udGV4dC52aWV3cG9ydCxcbiAgICBpc0RyYWdnaW5nID0gY29udGV4dC5pc0RyYWdnaW5nO1xuICB2YXIgc3R5bGUgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMFxuICB9LCBwcm9wcy5zdHlsZSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgaGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHQsXG4gICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgc3R5bGU6IHN0eWxlXG4gIH0sIHByb3BzLnJlZHJhdyh7XG4gICAgd2lkdGg6IHZpZXdwb3J0LndpZHRoLFxuICAgIGhlaWdodDogdmlld3BvcnQuaGVpZ2h0LFxuICAgIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmcsXG4gICAgcHJvamVjdDogdmlld3BvcnQucHJvamVjdCxcbiAgICB1bnByb2plY3Q6IHZpZXdwb3J0LnVucHJvamVjdFxuICB9KSk7XG59XG5TVkdPdmVybGF5LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbmV4cG9ydCBkZWZhdWx0IFNWR092ZXJsYXk7IiwiaW1wb3J0IG1hcGJveGdsIGZyb20gJy4vbWFwYm94Z2wnO1xudmFyIHNldFJUTFRleHRQbHVnaW4gPSBtYXBib3hnbCA/IG1hcGJveGdsLnNldFJUTFRleHRQbHVnaW4gOiBmdW5jdGlvbiAoKSB7fTtcbmV4cG9ydCBkZWZhdWx0IHNldFJUTFRleHRQbHVnaW47IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vY29tcG9uZW50cy9pbnRlcmFjdGl2ZS1tYXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJbnRlcmFjdGl2ZU1hcCB9IGZyb20gJy4vY29tcG9uZW50cy9pbnRlcmFjdGl2ZS1tYXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdGF0aWNNYXAgfSBmcm9tICcuL2NvbXBvbmVudHMvc3RhdGljLW1hcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNvdXJjZSB9IGZyb20gJy4vY29tcG9uZW50cy9zb3VyY2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMYXllciB9IGZyb20gJy4vY29tcG9uZW50cy9sYXllcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJhc2VDb250cm9sIH0gZnJvbSAnLi9jb21wb25lbnRzL2Jhc2UtY29udHJvbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1hcmtlciB9IGZyb20gJy4vY29tcG9uZW50cy9tYXJrZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb3B1cCB9IGZyb20gJy4vY29tcG9uZW50cy9wb3B1cCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEF0dHJpYnV0aW9uQ29udHJvbCB9IGZyb20gJy4vY29tcG9uZW50cy9hdHRyaWJ1dGlvbi1jb250cm9sJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRnVsbHNjcmVlbkNvbnRyb2wgfSBmcm9tICcuL2NvbXBvbmVudHMvZnVsbHNjcmVlbi1jb250cm9sJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR2VvbG9jYXRlQ29udHJvbCB9IGZyb20gJy4vY29tcG9uZW50cy9nZW9sb2NhdGUtY29udHJvbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5hdmlnYXRpb25Db250cm9sIH0gZnJvbSAnLi9jb21wb25lbnRzL25hdmlnYXRpb24tY29udHJvbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNjYWxlQ29udHJvbCB9IGZyb20gJy4vY29tcG9uZW50cy9zY2FsZS1jb250cm9sJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2FudmFzT3ZlcmxheSB9IGZyb20gJy4vb3ZlcmxheXMvY2FudmFzLW92ZXJsYXknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBIVE1MT3ZlcmxheSB9IGZyb20gJy4vb3ZlcmxheXMvaHRtbC1vdmVybGF5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU1ZHT3ZlcmxheSB9IGZyb20gJy4vb3ZlcmxheXMvc3ZnLW92ZXJsYXknO1xuZXhwb3J0IHsgVFJBTlNJVElPTl9FVkVOVFMgfSBmcm9tICcuL3V0aWxzL3RyYW5zaXRpb24tbWFuYWdlcic7XG5leHBvcnQgeyBUcmFuc2l0aW9uSW50ZXJwb2xhdG9yLCBMaW5lYXJJbnRlcnBvbGF0b3IsIFZpZXdwb3J0Rmx5VG9JbnRlcnBvbGF0b3IgYXMgRmx5VG9JbnRlcnBvbGF0b3IgfSBmcm9tICcuL3V0aWxzL3RyYW5zaXRpb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXBDb250cm9sbGVyIH0gZnJvbSAnLi91dGlscy9tYXAtY29udHJvbGxlcic7XG5leHBvcnQgeyBXZWJNZXJjYXRvclZpZXdwb3J0IH0gZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHNldFJUTFRleHRQbHVnaW4gfSBmcm9tICcuL3V0aWxzL3NldC1ydGwtdGV4dC1wbHVnaW4nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXBDb250ZXh0IH0gZnJvbSAnLi9jb21wb25lbnRzL21hcC1jb250ZXh0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgX3VzZU1hcENvbnRyb2wgfSBmcm9tICcuL2NvbXBvbmVudHMvdXNlLW1hcC1jb250cm9sJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgX01hcENvbnRleHQgfSBmcm9tICcuL2NvbXBvbmVudHMvbWFwLWNvbnRleHQnOyIsIi8qKlxuICogQG1vZHVsZSBoZWxwZXJzXG4gKi9cbi8qKlxuICogRWFydGggUmFkaXVzIHVzZWQgd2l0aCB0aGUgSGFydmVzaW5lIGZvcm11bGEgYW5kIGFwcHJveGltYXRlcyB1c2luZyBhIHNwaGVyaWNhbCAobm9uLWVsbGlwc29pZCkgRWFydGguXG4gKlxuICogQG1lbWJlcm9mIGhlbHBlcnNcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgZWFydGhSYWRpdXMgPSA2MzcxMDA4Ljg7XG4vKipcbiAqIFVuaXQgb2YgbWVhc3VyZW1lbnQgZmFjdG9ycyB1c2luZyBhIHNwaGVyaWNhbCAobm9uLWVsbGlwc29pZCkgZWFydGggcmFkaXVzLlxuICpcbiAqIEBtZW1iZXJvZiBoZWxwZXJzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnQgdmFyIGZhY3RvcnMgPSB7XG4gIGNlbnRpbWV0ZXJzOiBlYXJ0aFJhZGl1cyAqIDEwMCxcbiAgY2VudGltZXRyZXM6IGVhcnRoUmFkaXVzICogMTAwLFxuICBkZWdyZWVzOiBlYXJ0aFJhZGl1cyAvIDExMTMyNSxcbiAgZmVldDogZWFydGhSYWRpdXMgKiAzLjI4MDg0LFxuICBpbmNoZXM6IGVhcnRoUmFkaXVzICogMzkuMzcsXG4gIGtpbG9tZXRlcnM6IGVhcnRoUmFkaXVzIC8gMTAwMCxcbiAga2lsb21ldHJlczogZWFydGhSYWRpdXMgLyAxMDAwLFxuICBtZXRlcnM6IGVhcnRoUmFkaXVzLFxuICBtZXRyZXM6IGVhcnRoUmFkaXVzLFxuICBtaWxlczogZWFydGhSYWRpdXMgLyAxNjA5LjM0NCxcbiAgbWlsbGltZXRlcnM6IGVhcnRoUmFkaXVzICogMTAwMCxcbiAgbWlsbGltZXRyZXM6IGVhcnRoUmFkaXVzICogMTAwMCxcbiAgbmF1dGljYWxtaWxlczogZWFydGhSYWRpdXMgLyAxODUyLFxuICByYWRpYW5zOiAxLFxuICB5YXJkczogZWFydGhSYWRpdXMgKiAxLjA5MzZcbn07XG4vKipcbiAqIFVuaXRzIG9mIG1lYXN1cmVtZW50IGZhY3RvcnMgYmFzZWQgb24gMSBtZXRlci5cbiAqXG4gKiBAbWVtYmVyb2YgaGVscGVyc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0IHZhciB1bml0c0ZhY3RvcnMgPSB7XG4gIGNlbnRpbWV0ZXJzOiAxMDAsXG4gIGNlbnRpbWV0cmVzOiAxMDAsXG4gIGRlZ3JlZXM6IDEgLyAxMTEzMjUsXG4gIGZlZXQ6IDMuMjgwODQsXG4gIGluY2hlczogMzkuMzcsXG4gIGtpbG9tZXRlcnM6IDEgLyAxMDAwLFxuICBraWxvbWV0cmVzOiAxIC8gMTAwMCxcbiAgbWV0ZXJzOiAxLFxuICBtZXRyZXM6IDEsXG4gIG1pbGVzOiAxIC8gMTYwOS4zNDQsXG4gIG1pbGxpbWV0ZXJzOiAxMDAwLFxuICBtaWxsaW1ldHJlczogMTAwMCxcbiAgbmF1dGljYWxtaWxlczogMSAvIDE4NTIsXG4gIHJhZGlhbnM6IDEgLyBlYXJ0aFJhZGl1cyxcbiAgeWFyZHM6IDEuMDkzNjEzM1xufTtcbi8qKlxuICogQXJlYSBvZiBtZWFzdXJlbWVudCBmYWN0b3JzIGJhc2VkIG9uIDEgc3F1YXJlIG1ldGVyLlxuICpcbiAqIEBtZW1iZXJvZiBoZWxwZXJzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnQgdmFyIGFyZWFGYWN0b3JzID0ge1xuICBhY3JlczogMC4wMDAyNDcxMDUsXG4gIGNlbnRpbWV0ZXJzOiAxMDAwMCxcbiAgY2VudGltZXRyZXM6IDEwMDAwLFxuICBmZWV0OiAxMC43NjM5MTA0MTcsXG4gIGhlY3RhcmVzOiAwLjAwMDEsXG4gIGluY2hlczogMTU1MC4wMDMxMDAwMDYsXG4gIGtpbG9tZXRlcnM6IDAuMDAwMDAxLFxuICBraWxvbWV0cmVzOiAwLjAwMDAwMSxcbiAgbWV0ZXJzOiAxLFxuICBtZXRyZXM6IDEsXG4gIG1pbGVzOiAzLjg2ZS03LFxuICBtaWxsaW1ldGVyczogMTAwMDAwMCxcbiAgbWlsbGltZXRyZXM6IDEwMDAwMDAsXG4gIHlhcmRzOiAxLjE5NTk5MDA0NlxufTtcbi8qKlxuICogV3JhcHMgYSBHZW9KU09OIHtAbGluayBHZW9tZXRyeX0gaW4gYSBHZW9KU09OIHtAbGluayBGZWF0dXJlfS5cbiAqXG4gKiBAbmFtZSBmZWF0dXJlXG4gKiBAcGFyYW0ge0dlb21ldHJ5fSBnZW9tZXRyeSBpbnB1dCBnZW9tZXRyeVxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlfSBhIEdlb0pTT04gRmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBnZW9tZXRyeSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgXCJjb29yZGluYXRlc1wiOiBbMTEwLCA1MF1cbiAqIH07XG4gKlxuICogdmFyIGZlYXR1cmUgPSB0dXJmLmZlYXR1cmUoZ2VvbWV0cnkpO1xuICpcbiAqIC8vPWZlYXR1cmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHZhciBmZWF0ID0ge1xuICAgIHR5cGU6IFwiRmVhdHVyZVwiXG4gIH07XG4gIGlmIChvcHRpb25zLmlkID09PSAwIHx8IG9wdGlvbnMuaWQpIHtcbiAgICBmZWF0LmlkID0gb3B0aW9ucy5pZDtcbiAgfVxuICBpZiAob3B0aW9ucy5iYm94KSB7XG4gICAgZmVhdC5iYm94ID0gb3B0aW9ucy5iYm94O1xuICB9XG4gIGZlYXQucHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG4gIGZlYXQuZ2VvbWV0cnkgPSBnZW9tO1xuICByZXR1cm4gZmVhdDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIEdlb0pTT04ge0BsaW5rIEdlb21ldHJ5fSBmcm9tIGEgR2VvbWV0cnkgc3RyaW5nIHR5cGUgJiBjb29yZGluYXRlcy5cbiAqIEZvciBHZW9tZXRyeUNvbGxlY3Rpb24gdHlwZSB1c2UgYGhlbHBlcnMuZ2VvbWV0cnlDb2xsZWN0aW9uYFxuICpcbiAqIEBuYW1lIGdlb21ldHJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBHZW9tZXRyeSBUeXBlXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtHZW9tZXRyeX0gYSBHZW9KU09OIEdlb21ldHJ5XG4gKiBAZXhhbXBsZVxuICogdmFyIHR5cGUgPSBcIlBvaW50XCI7XG4gKiB2YXIgY29vcmRpbmF0ZXMgPSBbMTEwLCA1MF07XG4gKiB2YXIgZ2VvbWV0cnkgPSB0dXJmLmdlb21ldHJ5KHR5cGUsIGNvb3JkaW5hdGVzKTtcbiAqIC8vID0+IGdlb21ldHJ5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW9tZXRyeSh0eXBlLCBjb29yZGluYXRlcywgX29wdGlvbnMpIHtcbiAgaWYgKF9vcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBfb3B0aW9ucyA9IHt9O1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgcmV0dXJuIHBvaW50KGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcbiAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgcmV0dXJuIGxpbmVTdHJpbmcoY29vcmRpbmF0ZXMpLmdlb21ldHJ5O1xuICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICByZXR1cm4gcG9seWdvbihjb29yZGluYXRlcykuZ2VvbWV0cnk7XG4gICAgY2FzZSBcIk11bHRpUG9pbnRcIjpcbiAgICAgIHJldHVybiBtdWx0aVBvaW50KGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcbiAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6XG4gICAgICByZXR1cm4gbXVsdGlMaW5lU3RyaW5nKGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcbiAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6XG4gICAgICByZXR1cm4gbXVsdGlQb2x5Z29uKGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKHR5cGUgKyBcIiBpcyBpbnZhbGlkXCIpO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUG9pbnR9IHtAbGluayBGZWF0dXJlfSBmcm9tIGEgUG9zaXRpb24uXG4gKlxuICogQG5hbWUgcG9pbnRcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29vcmRpbmF0ZXMgbG9uZ2l0dWRlLCBsYXRpdHVkZSBwb3NpdGlvbiAoZWFjaCBpbiBkZWNpbWFsIGRlZ3JlZXMpXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmU8UG9pbnQ+fSBhIFBvaW50IGZlYXR1cmVcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9pbnQgPSB0dXJmLnBvaW50KFstNzUuMzQzLCAzOS45ODRdKTtcbiAqXG4gKiAvLz1wb2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9pbnQoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAoIWNvb3JkaW5hdGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29vcmRpbmF0ZXMgaXMgcmVxdWlyZWRcIik7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvb3JkaW5hdGVzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvb3JkaW5hdGVzIG11c3QgYmUgYW4gQXJyYXlcIik7XG4gIH1cbiAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBtdXN0IGJlIGF0IGxlYXN0IDIgbnVtYmVycyBsb25nXCIpO1xuICB9XG4gIGlmICghaXNOdW1iZXIoY29vcmRpbmF0ZXNbMF0pIHx8ICFpc051bWJlcihjb29yZGluYXRlc1sxXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBtdXN0IGNvbnRhaW4gbnVtYmVyc1wiKTtcbiAgfVxuICB2YXIgZ2VvbSA9IHtcbiAgICB0eXBlOiBcIlBvaW50XCIsXG4gICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzXG4gIH07XG4gIHJldHVybiBmZWF0dXJlKGdlb20sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIFBvaW50fSB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259IGZyb20gYW4gQXJyYXkgb2YgUG9pbnQgY29vcmRpbmF0ZXMuXG4gKlxuICogQG5hbWUgcG9pbnRzXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBQb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gVHJhbnNsYXRlIHRoZXNlIHByb3BlcnRpZXMgdG8gZWFjaCBGZWF0dXJlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdXG4gKiBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZUNvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IFBvaW50IEZlYXR1cmVcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9pbnRzID0gdHVyZi5wb2ludHMoW1xuICogICBbLTc1LCAzOV0sXG4gKiAgIFstODAsIDQ1XSxcbiAqICAgWy03OCwgNTBdXG4gKiBdKTtcbiAqXG4gKiAvLz1wb2ludHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvaW50cyhjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbihjb29yZGluYXRlcy5tYXAoZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgIHJldHVybiBwb2ludChjb29yZHMsIHByb3BlcnRpZXMpO1xuICB9KSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUG9seWdvbn0ge0BsaW5rIEZlYXR1cmV9IGZyb20gYW4gQXJyYXkgb2YgTGluZWFyUmluZ3MuXG4gKlxuICogQG5hbWUgcG9seWdvblxuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIExpbmVhclJpbmdzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmU8UG9seWdvbj59IFBvbHlnb24gRmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5Z29uID0gdHVyZi5wb2x5Z29uKFtbWy01LCA1Ml0sIFstNCwgNTZdLCBbLTIsIDUxXSwgWy03LCA1NF0sIFstNSwgNTJdXV0sIHsgbmFtZTogJ3BvbHkxJyB9KTtcbiAqXG4gKiAvLz1wb2x5Z29uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgZm9yICh2YXIgX2kgPSAwLCBjb29yZGluYXRlc18xID0gY29vcmRpbmF0ZXM7IF9pIDwgY29vcmRpbmF0ZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgcmluZyA9IGNvb3JkaW5hdGVzXzFbX2ldO1xuICAgIGlmIChyaW5nLmxlbmd0aCA8IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVhY2ggTGluZWFyUmluZyBvZiBhIFBvbHlnb24gbXVzdCBoYXZlIDQgb3IgbW9yZSBQb3NpdGlvbnMuXCIpO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmdbcmluZy5sZW5ndGggLSAxXS5sZW5ndGg7IGorKykge1xuICAgICAgLy8gQ2hlY2sgaWYgZmlyc3QgcG9pbnQgb2YgUG9seWdvbiBjb250YWlucyB0d28gbnVtYmVyc1xuICAgICAgaWYgKHJpbmdbcmluZy5sZW5ndGggLSAxXVtqXSAhPT0gcmluZ1swXVtqXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCBhbmQgbGFzdCBQb3NpdGlvbiBhcmUgbm90IGVxdWl2YWxlbnQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZ2VvbSA9IHtcbiAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgfTtcbiAgcmV0dXJuIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUG9seWdvbn0ge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBmcm9tIGFuIEFycmF5IG9mIFBvbHlnb24gY29vcmRpbmF0ZXMuXG4gKlxuICogQG5hbWUgcG9seWdvbnNcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9seWdvbiBjb29yZGluYXRlc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IFBvbHlnb24gRmVhdHVyZUNvbGxlY3Rpb25cbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seWdvbnMgPSB0dXJmLnBvbHlnb25zKFtcbiAqICAgW1tbLTUsIDUyXSwgWy00LCA1Nl0sIFstMiwgNTFdLCBbLTcsIDU0XSwgWy01LCA1Ml1dXSxcbiAqICAgW1tbLTE1LCA0Ml0sIFstMTQsIDQ2XSwgWy0xMiwgNDFdLCBbLTE3LCA0NF0sIFstMTUsIDQyXV1dLFxuICogXSk7XG4gKlxuICogLy89cG9seWdvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvbHlnb25zKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKGNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgcmV0dXJuIHBvbHlnb24oY29vcmRzLCBwcm9wZXJ0aWVzKTtcbiAgfSksIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIExpbmVTdHJpbmd9IHtAbGluayBGZWF0dXJlfSBmcm9tIGFuIEFycmF5IG9mIFBvc2l0aW9ucy5cbiAqXG4gKiBAbmFtZSBsaW5lU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBQb3NpdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gTGluZVN0cmluZyBGZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmVzdHJpbmcxID0gdHVyZi5saW5lU3RyaW5nKFtbLTI0LCA2M10sIFstMjMsIDYwXSwgWy0yNSwgNjVdLCBbLTIwLCA2OV1dLCB7bmFtZTogJ2xpbmUgMSd9KTtcbiAqIHZhciBsaW5lc3RyaW5nMiA9IHR1cmYubGluZVN0cmluZyhbWy0xNCwgNDNdLCBbLTEzLCA0MF0sIFstMTUsIDQ1XSwgWy0xMCwgNDldXSwge25hbWU6ICdsaW5lIDInfSk7XG4gKlxuICogLy89bGluZXN0cmluZzFcbiAqIC8vPWxpbmVzdHJpbmcyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lU3RyaW5nKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBtdXN0IGJlIGFuIGFycmF5IG9mIHR3byBvciBtb3JlIHBvc2l0aW9uc1wiKTtcbiAgfVxuICB2YXIgZ2VvbSA9IHtcbiAgICB0eXBlOiBcIkxpbmVTdHJpbmdcIixcbiAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgfTtcbiAgcmV0dXJuIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgTGluZVN0cmluZ30ge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBmcm9tIGFuIEFycmF5IG9mIExpbmVTdHJpbmcgY29vcmRpbmF0ZXMuXG4gKlxuICogQG5hbWUgbGluZVN0cmluZ3NcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBMaW5lYXJSaW5nc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdXG4gKiBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZUNvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxMaW5lU3RyaW5nPn0gTGluZVN0cmluZyBGZWF0dXJlQ29sbGVjdGlvblxuICogQGV4YW1wbGVcbiAqIHZhciBsaW5lc3RyaW5ncyA9IHR1cmYubGluZVN0cmluZ3MoW1xuICogICBbWy0yNCwgNjNdLCBbLTIzLCA2MF0sIFstMjUsIDY1XSwgWy0yMCwgNjldXSxcbiAqICAgW1stMTQsIDQzXSwgWy0xMywgNDBdLCBbLTE1LCA0NV0sIFstMTAsIDQ5XV1cbiAqIF0pO1xuICpcbiAqIC8vPWxpbmVzdHJpbmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lU3RyaW5ncyhjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbihjb29yZGluYXRlcy5tYXAoZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgIHJldHVybiBsaW5lU3RyaW5nKGNvb3JkcywgcHJvcGVydGllcyk7XG4gIH0pLCBvcHRpb25zKTtcbn1cbi8qKlxuICogVGFrZXMgb25lIG9yIG1vcmUge0BsaW5rIEZlYXR1cmV8RmVhdHVyZXN9IGFuZCBjcmVhdGVzIGEge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufS5cbiAqXG4gKiBAbmFtZSBmZWF0dXJlQ29sbGVjdGlvblxuICogQHBhcmFtIHtGZWF0dXJlW119IGZlYXR1cmVzIGlucHV0IGZlYXR1cmVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbn0gRmVhdHVyZUNvbGxlY3Rpb24gb2YgRmVhdHVyZXNcbiAqIEBleGFtcGxlXG4gKiB2YXIgbG9jYXRpb25BID0gdHVyZi5wb2ludChbLTc1LjM0MywgMzkuOTg0XSwge25hbWU6ICdMb2NhdGlvbiBBJ30pO1xuICogdmFyIGxvY2F0aW9uQiA9IHR1cmYucG9pbnQoWy03NS44MzMsIDM5LjI4NF0sIHtuYW1lOiAnTG9jYXRpb24gQid9KTtcbiAqIHZhciBsb2NhdGlvbkMgPSB0dXJmLnBvaW50KFstNzUuNTM0LCAzOS4xMjNdLCB7bmFtZTogJ0xvY2F0aW9uIEMnfSk7XG4gKlxuICogdmFyIGNvbGxlY3Rpb24gPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgbG9jYXRpb25BLFxuICogICBsb2NhdGlvbkIsXG4gKiAgIGxvY2F0aW9uQ1xuICogXSk7XG4gKlxuICogLy89Y29sbGVjdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZmVhdHVyZUNvbGxlY3Rpb24oZmVhdHVyZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICB2YXIgZmMgPSB7XG4gICAgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiXG4gIH07XG4gIGlmIChvcHRpb25zLmlkKSB7XG4gICAgZmMuaWQgPSBvcHRpb25zLmlkO1xuICB9XG4gIGlmIChvcHRpb25zLmJib3gpIHtcbiAgICBmYy5iYm94ID0gb3B0aW9ucy5iYm94O1xuICB9XG4gIGZjLmZlYXR1cmVzID0gZmVhdHVyZXM7XG4gIHJldHVybiBmYztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBGZWF0dXJlPE11bHRpTGluZVN0cmluZz59IGJhc2VkIG9uIGFcbiAqIGNvb3JkaW5hdGUgYXJyYXkuIFByb3BlcnRpZXMgY2FuIGJlIGFkZGVkIG9wdGlvbmFsbHkuXG4gKlxuICogQG5hbWUgbXVsdGlMaW5lU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEFycmF5PG51bWJlcj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgTGluZVN0cmluZ3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxNdWx0aUxpbmVTdHJpbmc+fSBhIE11bHRpTGluZVN0cmluZyBmZWF0dXJlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gY29vcmRpbmF0ZXMgYXJlIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aUxpbmUgPSB0dXJmLm11bHRpTGluZVN0cmluZyhbW1swLDBdLFsxMCwxMF1dXSk7XG4gKlxuICogLy89bXVsdGlMaW5lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aUxpbmVTdHJpbmcoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICB2YXIgZ2VvbSA9IHtcbiAgICB0eXBlOiBcIk11bHRpTGluZVN0cmluZ1wiLFxuICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICB9O1xuICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBGZWF0dXJlPE11bHRpUG9pbnQ+fSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIG11bHRpUG9pbnRcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIFBvc2l0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPE11bHRpUG9pbnQ+fSBhIE11bHRpUG9pbnQgZmVhdHVyZVxuICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGNvb3JkaW5hdGVzIGFyZSBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKiB2YXIgbXVsdGlQdCA9IHR1cmYubXVsdGlQb2ludChbWzAsMF0sWzEwLDEwXV0pO1xuICpcbiAqIC8vPW11bHRpUHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpUG9pbnQoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICB2YXIgZ2VvbSA9IHtcbiAgICB0eXBlOiBcIk11bHRpUG9pbnRcIixcbiAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgfTtcbiAgcmV0dXJuIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZTxNdWx0aVBvbHlnb24+fSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIG11bHRpUG9seWdvblxuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBQb2x5Z29uc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPE11bHRpUG9seWdvbj59IGEgbXVsdGlwb2x5Z29uIGZlYXR1cmVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBjb29yZGluYXRlcyBhcmUgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpUG9seSA9IHR1cmYubXVsdGlQb2x5Z29uKFtbW1swLDBdLFswLDEwXSxbMTAsMTBdLFsxMCwwXSxbMCwwXV1dXSk7XG4gKlxuICogLy89bXVsdGlQb2x5XG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlQb2x5Z29uKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgdmFyIGdlb20gPSB7XG4gICAgdHlwZTogXCJNdWx0aVBvbHlnb25cIixcbiAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgfTtcbiAgcmV0dXJuIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZTxHZW9tZXRyeUNvbGxlY3Rpb24+fSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIGdlb21ldHJ5Q29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheTxHZW9tZXRyeT59IGdlb21ldHJpZXMgYW4gYXJyYXkgb2YgR2VvSlNPTiBHZW9tZXRyaWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmU8R2VvbWV0cnlDb2xsZWN0aW9uPn0gYSBHZW9KU09OIEdlb21ldHJ5Q29sbGVjdGlvbiBGZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIHB0ID0gdHVyZi5nZW9tZXRyeShcIlBvaW50XCIsIFsxMDAsIDBdKTtcbiAqIHZhciBsaW5lID0gdHVyZi5nZW9tZXRyeShcIkxpbmVTdHJpbmdcIiwgW1sxMDEsIDBdLCBbMTAyLCAxXV0pO1xuICogdmFyIGNvbGxlY3Rpb24gPSB0dXJmLmdlb21ldHJ5Q29sbGVjdGlvbihbcHQsIGxpbmVdKTtcbiAqXG4gKiAvLyA9PiBjb2xsZWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cmllcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHZhciBnZW9tID0ge1xuICAgIHR5cGU6IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXG4gICAgZ2VvbWV0cmllczogZ2VvbWV0cmllc1xuICB9O1xuICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbi8qKlxuICogUm91bmQgbnVtYmVyIHRvIHByZWNpc2lvblxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gTnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBQcmVjaXNpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IHJvdW5kZWQgbnVtYmVyXG4gKiBAZXhhbXBsZVxuICogdHVyZi5yb3VuZCgxMjAuNDMyMSlcbiAqIC8vPTEyMFxuICpcbiAqIHR1cmYucm91bmQoMTIwLjQzMjEsIDIpXG4gKiAvLz0xMjAuNDNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kKG51bSwgcHJlY2lzaW9uKSB7XG4gIGlmIChwcmVjaXNpb24gPT09IHZvaWQgMCkge1xuICAgIHByZWNpc2lvbiA9IDA7XG4gIH1cbiAgaWYgKHByZWNpc2lvbiAmJiAhKHByZWNpc2lvbiA+PSAwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInByZWNpc2lvbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICB9XG4gIHZhciBtdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbiB8fCAwKTtcbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICogbXVsdGlwbGllcikgLyBtdWx0aXBsaWVyO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgZGlzdGFuY2UgbWVhc3VyZW1lbnQgKGFzc3VtaW5nIGEgc3BoZXJpY2FsIEVhcnRoKSBmcm9tIHJhZGlhbnMgdG8gYSBtb3JlIGZyaWVuZGx5IHVuaXQuXG4gKiBWYWxpZCB1bml0czogbWlsZXMsIG5hdXRpY2FsbWlsZXMsIGluY2hlcywgeWFyZHMsIG1ldGVycywgbWV0cmVzLCBraWxvbWV0ZXJzLCBjZW50aW1ldGVycywgZmVldFxuICpcbiAqIEBuYW1lIHJhZGlhbnNUb0xlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbnMgaW4gcmFkaWFucyBhY3Jvc3MgdGhlIHNwaGVyZVxuICogQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1cImtpbG9tZXRlcnNcIl0gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBpbmNoZXMsIHlhcmRzLCBtZXRyZXMsXG4gKiBtZXRlcnMsIGtpbG9tZXRyZXMsIGtpbG9tZXRlcnMuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkaXN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFkaWFuc1RvTGVuZ3RoKHJhZGlhbnMsIHVuaXRzKSB7XG4gIGlmICh1bml0cyA9PT0gdm9pZCAwKSB7XG4gICAgdW5pdHMgPSBcImtpbG9tZXRlcnNcIjtcbiAgfVxuICB2YXIgZmFjdG9yID0gZmFjdG9yc1t1bml0c107XG4gIGlmICghZmFjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVuaXRzICsgXCIgdW5pdHMgaXMgaW52YWxpZFwiKTtcbiAgfVxuICByZXR1cm4gcmFkaWFucyAqIGZhY3Rvcjtcbn1cbi8qKlxuICogQ29udmVydCBhIGRpc3RhbmNlIG1lYXN1cmVtZW50IChhc3N1bWluZyBhIHNwaGVyaWNhbCBFYXJ0aCkgZnJvbSBhIHJlYWwtd29ybGQgdW5pdCBpbnRvIHJhZGlhbnNcbiAqIFZhbGlkIHVuaXRzOiBtaWxlcywgbmF1dGljYWxtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0ZXJzLCBtZXRyZXMsIGtpbG9tZXRlcnMsIGNlbnRpbWV0ZXJzLCBmZWV0XG4gKlxuICogQG5hbWUgbGVuZ3RoVG9SYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgaW4gcmVhbCB1bml0c1xuICogQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1cImtpbG9tZXRlcnNcIl0gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBpbmNoZXMsIHlhcmRzLCBtZXRyZXMsXG4gKiBtZXRlcnMsIGtpbG9tZXRyZXMsIGtpbG9tZXRlcnMuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSByYWRpYW5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGhUb1JhZGlhbnMoZGlzdGFuY2UsIHVuaXRzKSB7XG4gIGlmICh1bml0cyA9PT0gdm9pZCAwKSB7XG4gICAgdW5pdHMgPSBcImtpbG9tZXRlcnNcIjtcbiAgfVxuICB2YXIgZmFjdG9yID0gZmFjdG9yc1t1bml0c107XG4gIGlmICghZmFjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVuaXRzICsgXCIgdW5pdHMgaXMgaW52YWxpZFwiKTtcbiAgfVxuICByZXR1cm4gZGlzdGFuY2UgLyBmYWN0b3I7XG59XG4vKipcbiAqIENvbnZlcnQgYSBkaXN0YW5jZSBtZWFzdXJlbWVudCAoYXNzdW1pbmcgYSBzcGhlcmljYWwgRWFydGgpIGZyb20gYSByZWFsLXdvcmxkIHVuaXQgaW50byBkZWdyZWVzXG4gKiBWYWxpZCB1bml0czogbWlsZXMsIG5hdXRpY2FsbWlsZXMsIGluY2hlcywgeWFyZHMsIG1ldGVycywgbWV0cmVzLCBjZW50aW1ldGVycywga2lsb21ldHJlcywgZmVldFxuICpcbiAqIEBuYW1lIGxlbmd0aFRvRGVncmVlc1xuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIGluIHJlYWwgdW5pdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9XCJraWxvbWV0ZXJzXCJdIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0cmVzLFxuICogbWV0ZXJzLCBraWxvbWV0cmVzLCBraWxvbWV0ZXJzLlxuICogQHJldHVybnMge251bWJlcn0gZGVncmVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoVG9EZWdyZWVzKGRpc3RhbmNlLCB1bml0cykge1xuICByZXR1cm4gcmFkaWFuc1RvRGVncmVlcyhsZW5ndGhUb1JhZGlhbnMoZGlzdGFuY2UsIHVuaXRzKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFueSBiZWFyaW5nIGFuZ2xlIGZyb20gdGhlIG5vcnRoIGxpbmUgZGlyZWN0aW9uIChwb3NpdGl2ZSBjbG9ja3dpc2UpXG4gKiBhbmQgcmV0dXJucyBhbiBhbmdsZSBiZXR3ZWVuIDAtMzYwIGRlZ3JlZXMgKHBvc2l0aXZlIGNsb2Nrd2lzZSksIDAgYmVpbmcgdGhlIG5vcnRoIGxpbmVcbiAqXG4gKiBAbmFtZSBiZWFyaW5nVG9BemltdXRoXG4gKiBAcGFyYW0ge251bWJlcn0gYmVhcmluZyBhbmdsZSwgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGFuZ2xlIGJldHdlZW4gMCBhbmQgMzYwIGRlZ3JlZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlYXJpbmdUb0F6aW11dGgoYmVhcmluZykge1xuICB2YXIgYW5nbGUgPSBiZWFyaW5nICUgMzYwO1xuICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgYW5nbGUgKz0gMzYwO1xuICB9XG4gIHJldHVybiBhbmdsZTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gYW5nbGUgaW4gcmFkaWFucyB0byBkZWdyZWVzXG4gKlxuICogQG5hbWUgcmFkaWFuc1RvRGVncmVlc1xuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbnMgYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybnMge251bWJlcn0gZGVncmVlcyBiZXR3ZWVuIDAgYW5kIDM2MCBkZWdyZWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYWRpYW5zVG9EZWdyZWVzKHJhZGlhbnMpIHtcbiAgdmFyIGRlZ3JlZXMgPSByYWRpYW5zICUgKDIgKiBNYXRoLlBJKTtcbiAgcmV0dXJuIGRlZ3JlZXMgKiAxODAgLyBNYXRoLlBJO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhbmdsZSBpbiBkZWdyZWVzIHRvIHJhZGlhbnNcbiAqXG4gKiBAbmFtZSBkZWdyZWVzVG9SYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gZGVncmVlcyBhbmdsZSBiZXR3ZWVuIDAgYW5kIDM2MCBkZWdyZWVzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWdyZWVzVG9SYWRpYW5zKGRlZ3JlZXMpIHtcbiAgdmFyIHJhZGlhbnMgPSBkZWdyZWVzICUgMzYwO1xuICByZXR1cm4gcmFkaWFucyAqIE1hdGguUEkgLyAxODA7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgbGVuZ3RoIHRvIHRoZSByZXF1ZXN0ZWQgdW5pdC5cbiAqIFZhbGlkIHVuaXRzOiBtaWxlcywgbmF1dGljYWxtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0ZXJzLCBtZXRyZXMsIGtpbG9tZXRlcnMsIGNlbnRpbWV0ZXJzLCBmZWV0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCB0byBiZSBjb252ZXJ0ZWRcbiAqIEBwYXJhbSB7VW5pdHN9IFtvcmlnaW5hbFVuaXQ9XCJraWxvbWV0ZXJzXCJdIG9mIHRoZSBsZW5ndGhcbiAqIEBwYXJhbSB7VW5pdHN9IFtmaW5hbFVuaXQ9XCJraWxvbWV0ZXJzXCJdIHJldHVybmVkIHVuaXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjb252ZXJ0ZWQgbGVuZ3RoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0TGVuZ3RoKGxlbmd0aCwgb3JpZ2luYWxVbml0LCBmaW5hbFVuaXQpIHtcbiAgaWYgKG9yaWdpbmFsVW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgb3JpZ2luYWxVbml0ID0gXCJraWxvbWV0ZXJzXCI7XG4gIH1cbiAgaWYgKGZpbmFsVW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgZmluYWxVbml0ID0gXCJraWxvbWV0ZXJzXCI7XG4gIH1cbiAgaWYgKCEobGVuZ3RoID49IDApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gIH1cbiAgcmV0dXJuIHJhZGlhbnNUb0xlbmd0aChsZW5ndGhUb1JhZGlhbnMobGVuZ3RoLCBvcmlnaW5hbFVuaXQpLCBmaW5hbFVuaXQpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGFyZWEgdG8gdGhlIHJlcXVlc3RlZCB1bml0LlxuICogVmFsaWQgdW5pdHM6IGtpbG9tZXRlcnMsIGtpbG9tZXRyZXMsIG1ldGVycywgbWV0cmVzLCBjZW50aW1ldHJlcywgbWlsbGltZXRlcnMsIGFjcmVzLCBtaWxlcywgeWFyZHMsIGZlZXQsIGluY2hlcywgaGVjdGFyZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmVhIHRvIGJlIGNvbnZlcnRlZFxuICogQHBhcmFtIHtVbml0c30gW29yaWdpbmFsVW5pdD1cIm1ldGVyc1wiXSBvZiB0aGUgZGlzdGFuY2VcbiAqIEBwYXJhbSB7VW5pdHN9IFtmaW5hbFVuaXQ9XCJraWxvbWV0ZXJzXCJdIHJldHVybmVkIHVuaXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjb252ZXJ0ZWQgYXJlYVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydEFyZWEoYXJlYSwgb3JpZ2luYWxVbml0LCBmaW5hbFVuaXQpIHtcbiAgaWYgKG9yaWdpbmFsVW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgb3JpZ2luYWxVbml0ID0gXCJtZXRlcnNcIjtcbiAgfVxuICBpZiAoZmluYWxVbml0ID09PSB2b2lkIDApIHtcbiAgICBmaW5hbFVuaXQgPSBcImtpbG9tZXRlcnNcIjtcbiAgfVxuICBpZiAoIShhcmVhID49IDApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYXJlYSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICB9XG4gIHZhciBzdGFydEZhY3RvciA9IGFyZWFGYWN0b3JzW29yaWdpbmFsVW5pdF07XG4gIGlmICghc3RhcnRGYWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG9yaWdpbmFsIHVuaXRzXCIpO1xuICB9XG4gIHZhciBmaW5hbEZhY3RvciA9IGFyZWFGYWN0b3JzW2ZpbmFsVW5pdF07XG4gIGlmICghZmluYWxGYWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZpbmFsIHVuaXRzXCIpO1xuICB9XG4gIHJldHVybiBhcmVhIC8gc3RhcnRGYWN0b3IgKiBmaW5hbEZhY3Rvcjtcbn1cbi8qKlxuICogaXNOdW1iZXJcbiAqXG4gKiBAcGFyYW0geyp9IG51bSBOdW1iZXIgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlL2ZhbHNlXG4gKiBAZXhhbXBsZVxuICogdHVyZi5pc051bWJlcigxMjMpXG4gKiAvLz10cnVlXG4gKiB0dXJmLmlzTnVtYmVyKCdmb28nKVxuICogLy89ZmFsc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKG51bSkge1xuICByZXR1cm4gIWlzTmFOKG51bSkgJiYgbnVtICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KG51bSk7XG59XG4vKipcbiAqIGlzT2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSBpbnB1dCB2YXJpYWJsZSB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUvZmFsc2VcbiAqIEBleGFtcGxlXG4gKiB0dXJmLmlzT2JqZWN0KHtlbGV2YXRpb246IDEwfSlcbiAqIC8vPXRydWVcbiAqIHR1cmYuaXNPYmplY3QoJ2ZvbycpXG4gKiAvLz1mYWxzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgcmV0dXJuICEhaW5wdXQgJiYgaW5wdXQuY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn1cbi8qKlxuICogVmFsaWRhdGUgQkJveFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGJib3ggQkJveCB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAdGhyb3dzIEVycm9yIGlmIEJCb3ggaXMgbm90IHZhbGlkXG4gKiBAZXhhbXBsZVxuICogdmFsaWRhdGVCQm94KFstMTgwLCAtNDAsIDExMCwgNTBdKVxuICogLy89T0tcbiAqIHZhbGlkYXRlQkJveChbLTE4MCwgLTQwXSlcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUJCb3goJ0ZvbycpXG4gKiAvLz1FcnJvclxuICogdmFsaWRhdGVCQm94KDUpXG4gKiAvLz1FcnJvclxuICogdmFsaWRhdGVCQm94KG51bGwpXG4gKiAvLz1FcnJvclxuICogdmFsaWRhdGVCQm94KHVuZGVmaW5lZClcbiAqIC8vPUVycm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJCb3goYmJveCkge1xuICBpZiAoIWJib3gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYm94IGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShiYm94KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImJib3ggbXVzdCBiZSBhbiBBcnJheVwiKTtcbiAgfVxuICBpZiAoYmJveC5sZW5ndGggIT09IDQgJiYgYmJveC5sZW5ndGggIT09IDYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYm94IG11c3QgYmUgYW4gQXJyYXkgb2YgNCBvciA2IG51bWJlcnNcIik7XG4gIH1cbiAgYmJveC5mb3JFYWNoKGZ1bmN0aW9uIChudW0pIHtcbiAgICBpZiAoIWlzTnVtYmVyKG51bSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJib3ggbXVzdCBvbmx5IGNvbnRhaW4gbnVtYmVyc1wiKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBWYWxpZGF0ZSBJZFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGlkIElkIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEB0aHJvd3MgRXJyb3IgaWYgSWQgaXMgbm90IHZhbGlkXG4gKiBAZXhhbXBsZVxuICogdmFsaWRhdGVJZChbLTE4MCwgLTQwLCAxMTAsIDUwXSlcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUlkKFstMTgwLCAtNDBdKVxuICogLy89RXJyb3JcbiAqIHZhbGlkYXRlSWQoJ0ZvbycpXG4gKiAvLz1PS1xuICogdmFsaWRhdGVJZCg1KVxuICogLy89T0tcbiAqIHZhbGlkYXRlSWQobnVsbClcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUlkKHVuZGVmaW5lZClcbiAqIC8vPUVycm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUlkKGlkKSB7XG4gIGlmICghaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpZCBpcyByZXF1aXJlZFwiKTtcbiAgfVxuICBpZiAoW1wic3RyaW5nXCIsIFwibnVtYmVyXCJdLmluZGV4T2YodHlwZW9mIGlkKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpZCBtdXN0IGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nXCIpO1xuICB9XG59IiwiaW1wb3J0IHsgZmVhdHVyZSwgbGluZVN0cmluZywgaXNPYmplY3QsIHBvaW50IH0gZnJvbSAnQHR1cmYvaGVscGVycyc7XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGNvb3JkRWFjaFxuICpcbiAqIEBjYWxsYmFjayBjb29yZEVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjdXJyZW50Q29vcmQgVGhlIGN1cnJlbnQgY29vcmRpbmF0ZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gY29vcmRJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgY29vcmRpbmF0ZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aUZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgTXVsdGktRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZ2VvbWV0cnlJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgR2VvbWV0cnkgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGNvb3JkaW5hdGVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5mb3JFYWNoKClcbiAqXG4gKiBAbmFtZSBjb29yZEVhY2hcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRDb29yZCwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4Y2x1ZGVXcmFwQ29vcmQ9ZmFsc2VdIHdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgdGhlIGZpbmFsIGNvb3JkaW5hdGUgb2YgTGluZWFyUmluZ3MgdGhhdCB3cmFwcyB0aGUgcmluZyBpbiBpdHMgaXRlcmF0aW9uLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtcImZvb1wiOiBcImJhclwifSksXG4gKiAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtcImhlbGxvXCI6IFwid29ybGRcIn0pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLmNvb3JkRWFjaChmZWF0dXJlcywgZnVuY3Rpb24gKGN1cnJlbnRDb29yZCwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICogICAvLz1jdXJyZW50Q29vcmRcbiAqICAgLy89Y29vcmRJbmRleFxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgLy89bXVsdGlGZWF0dXJlSW5kZXhcbiAqICAgLy89Z2VvbWV0cnlJbmRleFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGNvb3JkRWFjaChnZW9qc29uLCBjYWxsYmFjaywgZXhjbHVkZVdyYXBDb29yZCkge1xuICAvLyBIYW5kbGVzIG51bGwgR2VvbWV0cnkgLS0gU2tpcHMgdGhpcyBHZW9KU09OXG4gIGlmIChnZW9qc29uID09PSBudWxsKSByZXR1cm47XG4gIHZhciBqLFxuICAgIGssXG4gICAgbCxcbiAgICBnZW9tZXRyeSxcbiAgICBzdG9wRyxcbiAgICBjb29yZHMsXG4gICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24sXG4gICAgd3JhcFNocmluayA9IDAsXG4gICAgY29vcmRJbmRleCA9IDAsXG4gICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24sXG4gICAgdHlwZSA9IGdlb2pzb24udHlwZSxcbiAgICBpc0ZlYXR1cmVDb2xsZWN0aW9uID0gdHlwZSA9PT0gXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICAgIGlzRmVhdHVyZSA9IHR5cGUgPT09IFwiRmVhdHVyZVwiLFxuICAgIHN0b3AgPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggOiAxO1xuXG4gIC8vIFRoaXMgbG9naWMgbWF5IGxvb2sgYSBsaXR0bGUgd2VpcmQuIFRoZSByZWFzb24gd2h5IGl0IGlzIHRoYXQgd2F5XG4gIC8vIGlzIGJlY2F1c2UgaXQncyB0cnlpbmcgdG8gYmUgZmFzdC4gR2VvSlNPTiBzdXBwb3J0cyBtdWx0aXBsZSBraW5kc1xuICAvLyBvZiBvYmplY3RzIGF0IGl0cyByb290OiBGZWF0dXJlQ29sbGVjdGlvbiwgRmVhdHVyZXMsIEdlb21ldHJpZXMuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaGFzIHRoZSByZXNwb25zaWJpbGl0eSBvZiBoYW5kbGluZyBhbGwgb2YgdGhlbSwgYW5kIHRoYXRcbiAgLy8gbWVhbnMgdGhhdCBzb21lIG9mIHRoZSBgZm9yYCBsb29wcyB5b3Ugc2VlIGJlbG93IGFjdHVhbGx5IGp1c3QgZG9uJ3QgYXBwbHlcbiAgLy8gdG8gY2VydGFpbiBpbnB1dHMuIEZvciBpbnN0YW5jZSwgaWYgeW91IGdpdmUgdGhpcyBqdXN0IGFcbiAgLy8gUG9pbnQgZ2VvbWV0cnksIHRoZW4gYm90aCBsb29wcyBhcmUgc2hvcnQtY2lyY3VpdGVkIGFuZCBhbGwgd2UgZG9cbiAgLy8gaXMgZ3JhZHVhbGx5IHJlbmFtZSB0aGUgaW5wdXQgdW50aWwgaXQncyBjYWxsZWQgJ2dlb21ldHJ5Jy5cbiAgLy9cbiAgLy8gVGhpcyBhbHNvIGFpbXMgdG8gYWxsb2NhdGUgYXMgZmV3IHJlc291cmNlcyBhcyBwb3NzaWJsZToganVzdCBhXG4gIC8vIGZldyBudW1iZXJzIGFuZCBib29sZWFucywgcmF0aGVyIHRoYW4gYW55IHRlbXBvcmFyeSBhcnJheXMgYXMgd291bGRcbiAgLy8gYmUgcmVxdWlyZWQgd2l0aCB0aGUgbm9ybWFsaXphdGlvbiBhcHByb2FjaC5cbiAgZm9yICh2YXIgZmVhdHVyZUluZGV4ID0gMDsgZmVhdHVyZUluZGV4IDwgc3RvcDsgZmVhdHVyZUluZGV4KyspIHtcbiAgICBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbiA9IGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBnZW9qc29uLmZlYXR1cmVzW2ZlYXR1cmVJbmRleF0uZ2VvbWV0cnkgOiBpc0ZlYXR1cmUgPyBnZW9qc29uLmdlb21ldHJ5IDogZ2VvanNvbjtcbiAgICBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24udHlwZSA9PT0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIiA6IGZhbHNlO1xuICAgIHN0b3BHID0gaXNHZW9tZXRyeUNvbGxlY3Rpb24gPyBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi5nZW9tZXRyaWVzLmxlbmd0aCA6IDE7XG4gICAgZm9yICh2YXIgZ2VvbUluZGV4ID0gMDsgZ2VvbUluZGV4IDwgc3RvcEc7IGdlb21JbmRleCsrKSB7XG4gICAgICB2YXIgbXVsdGlGZWF0dXJlSW5kZXggPSAwO1xuICAgICAgdmFyIGdlb21ldHJ5SW5kZXggPSAwO1xuICAgICAgZ2VvbWV0cnkgPSBpc0dlb21ldHJ5Q29sbGVjdGlvbiA/IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLmdlb21ldHJpZXNbZ2VvbUluZGV4XSA6IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uO1xuXG4gICAgICAvLyBIYW5kbGVzIG51bGwgR2VvbWV0cnkgLS0gU2tpcHMgdGhpcyBnZW9tZXRyeVxuICAgICAgaWYgKGdlb21ldHJ5ID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIGNvb3JkcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgdmFyIGdlb21UeXBlID0gZ2VvbWV0cnkudHlwZTtcbiAgICAgIHdyYXBTaHJpbmsgPSBleGNsdWRlV3JhcENvb3JkICYmIChnZW9tVHlwZSA9PT0gXCJQb2x5Z29uXCIgfHwgZ2VvbVR5cGUgPT09IFwiTXVsdGlQb2x5Z29uXCIpID8gMSA6IDA7XG4gICAgICBzd2l0Y2ggKGdlb21UeXBlKSB7XG4gICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlBvaW50XCI6XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGNvb3JkcywgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgY29vcmRJbmRleCsrO1xuICAgICAgICAgIG11bHRpRmVhdHVyZUluZGV4Kys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGNvb3Jkc1tqXSwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb29yZEluZGV4Kys7XG4gICAgICAgICAgICBpZiAoZ2VvbVR5cGUgPT09IFwiTXVsdGlQb2ludFwiKSBtdWx0aUZlYXR1cmVJbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZ2VvbVR5cGUgPT09IFwiTGluZVN0cmluZ1wiKSBtdWx0aUZlYXR1cmVJbmRleCsrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgICAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGNvb3Jkc1tqXS5sZW5ndGggLSB3cmFwU2hyaW5rOyBrKyspIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGNvb3Jkc1tqXVtrXSwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIGNvb3JkSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZW9tVHlwZSA9PT0gXCJNdWx0aUxpbmVTdHJpbmdcIikgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICAgIGlmIChnZW9tVHlwZSA9PT0gXCJQb2x5Z29uXCIpIGdlb21ldHJ5SW5kZXgrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGdlb21UeXBlID09PSBcIlBvbHlnb25cIikgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGdlb21ldHJ5SW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGNvb3Jkc1tqXS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICBmb3IgKGwgPSAwOyBsIDwgY29vcmRzW2pdW2tdLmxlbmd0aCAtIHdyYXBTaHJpbms7IGwrKykge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhjb29yZHNbal1ba11bbF0sIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvb3JkSW5kZXgrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBnZW9tZXRyeUluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtdWx0aUZlYXR1cmVJbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOlxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaisrKSBpZiAoY29vcmRFYWNoKGdlb21ldHJ5Lmdlb21ldHJpZXNbal0sIGNhbGxiYWNrLCBleGNsdWRlV3JhcENvb3JkKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEdlb21ldHJ5IFR5cGVcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGNvb3JkUmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgY29vcmRSZWR1Y2VDYWxsYmFja1xuICogQHBhcmFtIHsqfSBwcmV2aW91c1ZhbHVlIFRoZSBhY2N1bXVsYXRlZCB2YWx1ZSBwcmV2aW91c2x5IHJldHVybmVkIGluIHRoZSBsYXN0IGludm9jYXRpb25cbiAqIG9mIHRoZSBjYWxsYmFjaywgb3IgaW5pdGlhbFZhbHVlLCBpZiBzdXBwbGllZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY3VycmVudENvb3JkIFRoZSBjdXJyZW50IGNvb3JkaW5hdGUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvb3JkSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIGNvb3JkaW5hdGUgYmVpbmcgcHJvY2Vzc2VkLlxuICogU3RhcnRzIGF0IGluZGV4IDAsIGlmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCwgYW5kIGF0IGluZGV4IDEgb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbXVsdGlGZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIE11bHRpLUZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGdlb21ldHJ5SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSBjb29yZGluYXRlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkucmVkdWNlKClcbiAqXG4gKiBAbmFtZSBjb29yZFJlZHVjZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxHZW9tZXRyeXxGZWF0dXJlfSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudENvb3JkLCBjb29yZEluZGV4KVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4Y2x1ZGVXcmFwQ29vcmQ9ZmFsc2VdIHdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgdGhlIGZpbmFsIGNvb3JkaW5hdGUgb2YgTGluZWFyUmluZ3MgdGhhdCB3cmFwcyB0aGUgcmluZyBpbiBpdHMgaXRlcmF0aW9uLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICB0dXJmLnBvaW50KFsyNiwgMzddLCB7XCJmb29cIjogXCJiYXJcIn0pLFxuICogICB0dXJmLnBvaW50KFszNiwgNTNdLCB7XCJoZWxsb1wiOiBcIndvcmxkXCJ9KVxuICogXSk7XG4gKlxuICogdHVyZi5jb29yZFJlZHVjZShmZWF0dXJlcywgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRDb29yZCwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRDb29yZFxuICogICAvLz1jb29yZEluZGV4XG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1tdWx0aUZlYXR1cmVJbmRleFxuICogICAvLz1nZW9tZXRyeUluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50Q29vcmQ7XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gY29vcmRSZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSwgZXhjbHVkZVdyYXBDb29yZCkge1xuICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgY29vcmRFYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjdXJyZW50Q29vcmQsIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpIHtcbiAgICBpZiAoY29vcmRJbmRleCA9PT0gMCAmJiBpbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCkgcHJldmlvdXNWYWx1ZSA9IGN1cnJlbnRDb29yZDtlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50Q29vcmQsIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpO1xuICB9LCBleGNsdWRlV3JhcENvb3JkKTtcbiAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIHByb3BFYWNoXG4gKlxuICogQGNhbGxiYWNrIHByb3BFYWNoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdXJyZW50UHJvcGVydGllcyBUaGUgY3VycmVudCBQcm9wZXJ0aWVzIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIHByb3BlcnRpZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LmZvckVhY2goKVxuICpcbiAqIEBuYW1lIHByb3BFYWNoXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChjdXJyZW50UHJvcGVydGllcywgZmVhdHVyZUluZGV4KVxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgICB0dXJmLnBvaW50KFszNiwgNTNdLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdHVyZi5wcm9wRWFjaChmZWF0dXJlcywgZnVuY3Rpb24gKGN1cnJlbnRQcm9wZXJ0aWVzLCBmZWF0dXJlSW5kZXgpIHtcbiAqICAgLy89Y3VycmVudFByb3BlcnRpZXNcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gcHJvcEVhY2goZ2VvanNvbiwgY2FsbGJhY2spIHtcbiAgdmFyIGk7XG4gIHN3aXRjaCAoZ2VvanNvbi50eXBlKSB7XG4gICAgY2FzZSBcIkZlYXR1cmVDb2xsZWN0aW9uXCI6XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY2FsbGJhY2soZ2VvanNvbi5mZWF0dXJlc1tpXS5wcm9wZXJ0aWVzLCBpKSA9PT0gZmFsc2UpIGJyZWFrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkZlYXR1cmVcIjpcbiAgICAgIGNhbGxiYWNrKGdlb2pzb24ucHJvcGVydGllcywgMCk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBwcm9wUmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgcHJvcFJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHsqfSBjdXJyZW50UHJvcGVydGllcyBUaGUgY3VycmVudCBQcm9wZXJ0aWVzIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogUmVkdWNlIHByb3BlcnRpZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0IGludG8gYSBzaW5nbGUgdmFsdWUsXG4gKiBzaW1pbGFyIHRvIGhvdyBBcnJheS5yZWR1Y2Ugd29ya3MuIEhvd2V2ZXIsIGluIHRoaXMgY2FzZSB3ZSBsYXppbHkgcnVuXG4gKiB0aGUgcmVkdWN0aW9uLCBzbyBhbiBhcnJheSBvZiBhbGwgcHJvcGVydGllcyBpcyB1bm5lY2Vzc2FyeS5cbiAqXG4gKiBAbmFtZSBwcm9wUmVkdWNlXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50UHJvcGVydGllcywgZmVhdHVyZUluZGV4KVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgdGhhdCByZXN1bHRzIGZyb20gdGhlIHJlZHVjdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtoZWxsbzogJ3dvcmxkJ30pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLnByb3BSZWR1Y2UoZmVhdHVyZXMsIGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50UHJvcGVydGllcywgZmVhdHVyZUluZGV4KSB7XG4gKiAgIC8vPXByZXZpb3VzVmFsdWVcbiAqICAgLy89Y3VycmVudFByb3BlcnRpZXNcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50UHJvcGVydGllc1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHByb3BSZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgcHJvcEVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGN1cnJlbnRQcm9wZXJ0aWVzLCBmZWF0dXJlSW5kZXgpIHtcbiAgICBpZiAoZmVhdHVyZUluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudFByb3BlcnRpZXM7ZWxzZSBwcmV2aW91c1ZhbHVlID0gY2FsbGJhY2socHJldmlvdXNWYWx1ZSwgY3VycmVudFByb3BlcnRpZXMsIGZlYXR1cmVJbmRleCk7XG4gIH0pO1xuICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgZmVhdHVyZUVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgZmVhdHVyZUVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtGZWF0dXJlPGFueT59IGN1cnJlbnRGZWF0dXJlIFRoZSBjdXJyZW50IEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvXG4gKiBBcnJheS5mb3JFYWNoLlxuICpcbiAqIEBuYW1lIGZlYXR1cmVFYWNoXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4KVxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtmb286ICdiYXInfSksXG4gKiAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtoZWxsbzogJ3dvcmxkJ30pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLmZlYXR1cmVFYWNoKGZlYXR1cmVzLCBmdW5jdGlvbiAoY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCkge1xuICogICAvLz1jdXJyZW50RmVhdHVyZVxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBmZWF0dXJlRWFjaChnZW9qc29uLCBjYWxsYmFjaykge1xuICBpZiAoZ2VvanNvbi50eXBlID09PSBcIkZlYXR1cmVcIikge1xuICAgIGNhbGxiYWNrKGdlb2pzb24sIDApO1xuICB9IGVsc2UgaWYgKGdlb2pzb24udHlwZSA9PT0gXCJGZWF0dXJlQ29sbGVjdGlvblwiKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY2FsbGJhY2soZ2VvanNvbi5mZWF0dXJlc1tpXSwgaSkgPT09IGZhbHNlKSBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgZmVhdHVyZVJlZHVjZVxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzIGRlcGVuZFxuICogb24gd2hldGhlciB0aGUgcmVkdWNlIG1ldGhvZCBoYXMgYW4gaW5pdGlhbFZhbHVlIGFyZ3VtZW50LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCB0byB0aGUgcmVkdWNlIG1ldGhvZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIGluaXRpYWxWYWx1ZS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBub3QgcHJvdmlkZWQ6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogQGNhbGxiYWNrIGZlYXR1cmVSZWR1Y2VDYWxsYmFja1xuICogQHBhcmFtIHsqfSBwcmV2aW91c1ZhbHVlIFRoZSBhY2N1bXVsYXRlZCB2YWx1ZSBwcmV2aW91c2x5IHJldHVybmVkIGluIHRoZSBsYXN0IGludm9jYXRpb25cbiAqIG9mIHRoZSBjYWxsYmFjaywgb3IgaW5pdGlhbFZhbHVlLCBpZiBzdXBwbGllZC5cbiAqIEBwYXJhbSB7RmVhdHVyZX0gY3VycmVudEZlYXR1cmUgVGhlIGN1cnJlbnQgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSBmZWF0dXJlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkucmVkdWNlKCkuXG4gKlxuICogQG5hbWUgZmVhdHVyZVJlZHVjZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleClcbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gVmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHRoZSByZWR1Y3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtcImZvb1wiOiBcImJhclwifSksXG4gKiAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtcImhlbGxvXCI6IFwid29ybGRcIn0pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLmZlYXR1cmVSZWR1Y2UoZmVhdHVyZXMsIGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4KSB7XG4gKiAgIC8vPXByZXZpb3VzVmFsdWVcbiAqICAgLy89Y3VycmVudEZlYXR1cmVcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50RmVhdHVyZVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGZlYXR1cmVSZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgZmVhdHVyZUVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgpIHtcbiAgICBpZiAoZmVhdHVyZUluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudEZlYXR1cmU7ZWxzZSBwcmV2aW91c1ZhbHVlID0gY2FsbGJhY2socHJldmlvdXNWYWx1ZSwgY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCk7XG4gIH0pO1xuICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cblxuLyoqXG4gKiBHZXQgYWxsIGNvb3JkaW5hdGVzIGZyb20gYW55IEdlb0pTT04gb2JqZWN0LlxuICpcbiAqIEBuYW1lIGNvb3JkQWxsXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNvb3JkaW5hdGUgcG9zaXRpb24gYXJyYXlcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgdHVyZi5wb2ludChbMzYsIDUzXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHZhciBjb29yZHMgPSB0dXJmLmNvb3JkQWxsKGZlYXR1cmVzKTtcbiAqIC8vPSBbWzI2LCAzN10sIFszNiwgNTNdXVxuICovXG5mdW5jdGlvbiBjb29yZEFsbChnZW9qc29uKSB7XG4gIHZhciBjb29yZHMgPSBbXTtcbiAgY29vcmRFYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjb29yZCkge1xuICAgIGNvb3Jkcy5wdXNoKGNvb3JkKTtcbiAgfSk7XG4gIHJldHVybiBjb29yZHM7XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGdlb21FYWNoXG4gKlxuICogQGNhbGxiYWNrIGdlb21FYWNoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGN1cnJlbnRHZW9tZXRyeSBUaGUgY3VycmVudCBHZW9tZXRyeSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBmZWF0dXJlUHJvcGVydGllcyBUaGUgY3VycmVudCBGZWF0dXJlIFByb3BlcnRpZXMgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmZWF0dXJlQkJveCBUaGUgY3VycmVudCBGZWF0dXJlIEJCb3ggYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBmZWF0dXJlSWQgVGhlIGN1cnJlbnQgRmVhdHVyZSBJZCBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgZWFjaCBnZW9tZXRyeSBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkuZm9yRWFjaCgpXG4gKlxuICogQG5hbWUgZ2VvbUVhY2hcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRHZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZClcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtmb286ICdiYXInfSksXG4gKiAgICAgdHVyZi5wb2ludChbMzYsIDUzXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuZ2VvbUVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjdXJyZW50R2VvbWV0cnksIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpIHtcbiAqICAgLy89Y3VycmVudEdlb21ldHJ5XG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1mZWF0dXJlUHJvcGVydGllc1xuICogICAvLz1mZWF0dXJlQkJveFxuICogICAvLz1mZWF0dXJlSWRcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBnZW9tRWFjaChnZW9qc29uLCBjYWxsYmFjaykge1xuICB2YXIgaSxcbiAgICBqLFxuICAgIGcsXG4gICAgZ2VvbWV0cnksXG4gICAgc3RvcEcsXG4gICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24sXG4gICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24sXG4gICAgZmVhdHVyZVByb3BlcnRpZXMsXG4gICAgZmVhdHVyZUJCb3gsXG4gICAgZmVhdHVyZUlkLFxuICAgIGZlYXR1cmVJbmRleCA9IDAsXG4gICAgaXNGZWF0dXJlQ29sbGVjdGlvbiA9IGdlb2pzb24udHlwZSA9PT0gXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICAgIGlzRmVhdHVyZSA9IGdlb2pzb24udHlwZSA9PT0gXCJGZWF0dXJlXCIsXG4gICAgc3RvcCA9IGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aCA6IDE7XG5cbiAgLy8gVGhpcyBsb2dpYyBtYXkgbG9vayBhIGxpdHRsZSB3ZWlyZC4gVGhlIHJlYXNvbiB3aHkgaXQgaXMgdGhhdCB3YXlcbiAgLy8gaXMgYmVjYXVzZSBpdCdzIHRyeWluZyB0byBiZSBmYXN0LiBHZW9KU09OIHN1cHBvcnRzIG11bHRpcGxlIGtpbmRzXG4gIC8vIG9mIG9iamVjdHMgYXQgaXRzIHJvb3Q6IEZlYXR1cmVDb2xsZWN0aW9uLCBGZWF0dXJlcywgR2VvbWV0cmllcy5cbiAgLy8gVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIGhhbmRsaW5nIGFsbCBvZiB0aGVtLCBhbmQgdGhhdFxuICAvLyBtZWFucyB0aGF0IHNvbWUgb2YgdGhlIGBmb3JgIGxvb3BzIHlvdSBzZWUgYmVsb3cgYWN0dWFsbHkganVzdCBkb24ndCBhcHBseVxuICAvLyB0byBjZXJ0YWluIGlucHV0cy4gRm9yIGluc3RhbmNlLCBpZiB5b3UgZ2l2ZSB0aGlzIGp1c3QgYVxuICAvLyBQb2ludCBnZW9tZXRyeSwgdGhlbiBib3RoIGxvb3BzIGFyZSBzaG9ydC1jaXJjdWl0ZWQgYW5kIGFsbCB3ZSBkb1xuICAvLyBpcyBncmFkdWFsbHkgcmVuYW1lIHRoZSBpbnB1dCB1bnRpbCBpdCdzIGNhbGxlZCAnZ2VvbWV0cnknLlxuICAvL1xuICAvLyBUaGlzIGFsc28gYWltcyB0byBhbGxvY2F0ZSBhcyBmZXcgcmVzb3VyY2VzIGFzIHBvc3NpYmxlOiBqdXN0IGFcbiAgLy8gZmV3IG51bWJlcnMgYW5kIGJvb2xlYW5zLCByYXRoZXIgdGhhbiBhbnkgdGVtcG9yYXJ5IGFycmF5cyBhcyB3b3VsZFxuICAvLyBiZSByZXF1aXJlZCB3aXRoIHRoZSBub3JtYWxpemF0aW9uIGFwcHJvYWNoLlxuICBmb3IgKGkgPSAwOyBpIDwgc3RvcDsgaSsrKSB7XG4gICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24gPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gZ2VvanNvbi5mZWF0dXJlc1tpXS5nZW9tZXRyeSA6IGlzRmVhdHVyZSA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uO1xuICAgIGZlYXR1cmVQcm9wZXJ0aWVzID0gaXNGZWF0dXJlQ29sbGVjdGlvbiA/IGdlb2pzb24uZmVhdHVyZXNbaV0ucHJvcGVydGllcyA6IGlzRmVhdHVyZSA/IGdlb2pzb24ucHJvcGVydGllcyA6IHt9O1xuICAgIGZlYXR1cmVCQm94ID0gaXNGZWF0dXJlQ29sbGVjdGlvbiA/IGdlb2pzb24uZmVhdHVyZXNbaV0uYmJveCA6IGlzRmVhdHVyZSA/IGdlb2pzb24uYmJveCA6IHVuZGVmaW5lZDtcbiAgICBmZWF0dXJlSWQgPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gZ2VvanNvbi5mZWF0dXJlc1tpXS5pZCA6IGlzRmVhdHVyZSA/IGdlb2pzb24uaWQgOiB1bmRlZmluZWQ7XG4gICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbiA/IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIgOiBmYWxzZTtcbiAgICBzdG9wRyA9IGlzR2VvbWV0cnlDb2xsZWN0aW9uID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllcy5sZW5ndGggOiAxO1xuICAgIGZvciAoZyA9IDA7IGcgPCBzdG9wRzsgZysrKSB7XG4gICAgICBnZW9tZXRyeSA9IGlzR2VvbWV0cnlDb2xsZWN0aW9uID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllc1tnXSA6IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uO1xuXG4gICAgICAvLyBIYW5kbGUgbnVsbCBHZW9tZXRyeVxuICAgICAgaWYgKGdlb21ldHJ5ID09PSBudWxsKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhudWxsLCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIlBvaW50XCI6XG4gICAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjpcbiAgICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayhnZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2VvbWV0cnkuZ2VvbWV0cmllcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2soZ2VvbWV0cnkuZ2VvbWV0cmllc1tqXSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBHZW9tZXRyeSBUeXBlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBPbmx5IGluY3JlYXNlIGBmZWF0dXJlSW5kZXhgIHBlciBlYWNoIGZlYXR1cmVcbiAgICBmZWF0dXJlSW5kZXgrKztcbiAgfVxufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBnZW9tUmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgZ2VvbVJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtHZW9tZXRyeX0gY3VycmVudEdlb21ldHJ5IFRoZSBjdXJyZW50IEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmVQcm9wZXJ0aWVzIFRoZSBjdXJyZW50IEZlYXR1cmUgUHJvcGVydGllcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZlYXR1cmVCQm94IFRoZSBjdXJyZW50IEZlYXR1cmUgQkJveCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGZlYXR1cmVJZCBUaGUgY3VycmVudCBGZWF0dXJlIElkIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSBnZW9tZXRyeSBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkucmVkdWNlKCkuXG4gKlxuICogQG5hbWUgZ2VvbVJlZHVjZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudEdlb21ldHJ5LCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgdGhhdCByZXN1bHRzIGZyb20gdGhlIHJlZHVjdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtoZWxsbzogJ3dvcmxkJ30pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLmdlb21SZWR1Y2UoZmVhdHVyZXMsIGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50R2VvbWV0cnksIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpIHtcbiAqICAgLy89cHJldmlvdXNWYWx1ZVxuICogICAvLz1jdXJyZW50R2VvbWV0cnlcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPWZlYXR1cmVQcm9wZXJ0aWVzXG4gKiAgIC8vPWZlYXR1cmVCQm94XG4gKiAgIC8vPWZlYXR1cmVJZFxuICogICByZXR1cm4gY3VycmVudEdlb21ldHJ5XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gZ2VvbVJlZHVjZShnZW9qc29uLCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBwcmV2aW91c1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBnZW9tRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY3VycmVudEdlb21ldHJ5LCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKSB7XG4gICAgaWYgKGZlYXR1cmVJbmRleCA9PT0gMCAmJiBpbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCkgcHJldmlvdXNWYWx1ZSA9IGN1cnJlbnRHZW9tZXRyeTtlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50R2VvbWV0cnksIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpO1xuICB9KTtcbiAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGZsYXR0ZW5FYWNoXG4gKlxuICogQGNhbGxiYWNrIGZsYXR0ZW5FYWNoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RmVhdHVyZX0gY3VycmVudEZlYXR1cmUgVGhlIGN1cnJlbnQgZmxhdHRlbmVkIGZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbXVsdGlGZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIE11bHRpLUZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGZsYXR0ZW5lZCBmZWF0dXJlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG9cbiAqIEFycmF5LmZvckVhY2guXG4gKlxuICogQG5hbWUgZmxhdHRlbkVhY2hcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KVxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtmb286ICdiYXInfSksXG4gKiAgICAgdHVyZi5tdWx0aVBvaW50KFtbNDAsIDMwXSwgWzM2LCA1M11dLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdHVyZi5mbGF0dGVuRWFjaChmZWF0dXJlcywgZnVuY3Rpb24gKGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KSB7XG4gKiAgIC8vPWN1cnJlbnRGZWF0dXJlXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1tdWx0aUZlYXR1cmVJbmRleFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5FYWNoKGdlb2pzb24sIGNhbGxiYWNrKSB7XG4gIGdlb21FYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChnZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBwcm9wZXJ0aWVzLCBiYm94LCBpZCkge1xuICAgIC8vIENhbGxiYWNrIGZvciBzaW5nbGUgZ2VvbWV0cnlcbiAgICB2YXIgdHlwZSA9IGdlb21ldHJ5ID09PSBudWxsID8gbnVsbCA6IGdlb21ldHJ5LnR5cGU7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIG51bGw6XG4gICAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgICAgICBpZiAoY2FsbGJhY2soZmVhdHVyZShnZW9tZXRyeSwgcHJvcGVydGllcywge1xuICAgICAgICAgIGJib3g6IGJib3gsXG4gICAgICAgICAgaWQ6IGlkXG4gICAgICAgIH0pLCBmZWF0dXJlSW5kZXgsIDApID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBnZW9tVHlwZTtcblxuICAgIC8vIENhbGxiYWNrIGZvciBtdWx0aS1nZW9tZXRyeVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjpcbiAgICAgICAgZ2VvbVR5cGUgPSBcIlBvaW50XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgICAgICBnZW9tVHlwZSA9IFwiTGluZVN0cmluZ1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgICAgZ2VvbVR5cGUgPSBcIlBvbHlnb25cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAodmFyIG11bHRpRmVhdHVyZUluZGV4ID0gMDsgbXVsdGlGZWF0dXJlSW5kZXggPCBnZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGg7IG11bHRpRmVhdHVyZUluZGV4KyspIHtcbiAgICAgIHZhciBjb29yZGluYXRlID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXNbbXVsdGlGZWF0dXJlSW5kZXhdO1xuICAgICAgdmFyIGdlb20gPSB7XG4gICAgICAgIHR5cGU6IGdlb21UeXBlLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZVxuICAgICAgfTtcbiAgICAgIGlmIChjYWxsYmFjayhmZWF0dXJlKGdlb20sIHByb3BlcnRpZXMpLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBmbGF0dGVuUmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgZmxhdHRlblJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtGZWF0dXJlfSBjdXJyZW50RmVhdHVyZSBUaGUgY3VycmVudCBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSBmbGF0dGVuZWQgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpLlxuICpcbiAqIEBuYW1lIGZsYXR0ZW5SZWR1Y2VcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgdGhhdCByZXN1bHRzIGZyb20gdGhlIHJlZHVjdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICAgIHR1cmYubXVsdGlQb2ludChbWzQwLCAzMF0sIFszNiwgNTNdXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuZmxhdHRlblJlZHVjZShmZWF0dXJlcywgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KSB7XG4gKiAgIC8vPXByZXZpb3VzVmFsdWVcbiAqICAgLy89Y3VycmVudEZlYXR1cmVcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPW11bHRpRmVhdHVyZUluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50RmVhdHVyZVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5SZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgZmxhdHRlbkVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KSB7XG4gICAgaWYgKGZlYXR1cmVJbmRleCA9PT0gMCAmJiBtdWx0aUZlYXR1cmVJbmRleCA9PT0gMCAmJiBpbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCkgcHJldmlvdXNWYWx1ZSA9IGN1cnJlbnRGZWF0dXJlO2Vsc2UgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KTtcbiAgfSk7XG4gIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBzZWdtZW50RWFjaFxuICpcbiAqIEBjYWxsYmFjayBzZWdtZW50RWFjaENhbGxiYWNrXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZz59IGN1cnJlbnRTZWdtZW50IFRoZSBjdXJyZW50IFNlZ21lbnQgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbXVsdGlGZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIE11bHRpLUZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGdlb21ldHJ5SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIFNlZ21lbnQgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgMi12ZXJ0ZXggbGluZSBzZWdtZW50IGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5mb3JFYWNoKClcbiAqIChNdWx0aSlQb2ludCBnZW9tZXRyaWVzIGRvIG5vdCBjb250YWluIHNlZ21lbnRzIHRoZXJlZm9yZSB0aGV5IGFyZSBpZ25vcmVkIGR1cmluZyB0aGlzIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gYW55IEdlb0pTT05cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRTZWdtZW50LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4LCBzZWdtZW50SW5kZXgpXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seWdvbiA9IHR1cmYucG9seWdvbihbW1stNTAsIDVdLCBbLTQwLCAtMTBdLCBbLTUwLCAtMTBdLCBbLTQwLCA1XSwgWy01MCwgNV1dXSk7XG4gKlxuICogLy8gSXRlcmF0ZSBvdmVyIEdlb0pTT04gYnkgMi12ZXJ0ZXggc2VnbWVudHNcbiAqIHR1cmYuc2VnbWVudEVhY2gocG9seWdvbiwgZnVuY3Rpb24gKGN1cnJlbnRTZWdtZW50LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4LCBzZWdtZW50SW5kZXgpIHtcbiAqICAgLy89Y3VycmVudFNlZ21lbnRcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPW11bHRpRmVhdHVyZUluZGV4XG4gKiAgIC8vPWdlb21ldHJ5SW5kZXhcbiAqICAgLy89c2VnbWVudEluZGV4XG4gKiB9KTtcbiAqXG4gKiAvLyBDYWxjdWxhdGUgdGhlIHRvdGFsIG51bWJlciBvZiBzZWdtZW50c1xuICogdmFyIHRvdGFsID0gMDtcbiAqIHR1cmYuc2VnbWVudEVhY2gocG9seWdvbiwgZnVuY3Rpb24gKCkge1xuICogICAgIHRvdGFsKys7XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gc2VnbWVudEVhY2goZ2VvanNvbiwgY2FsbGJhY2spIHtcbiAgZmxhdHRlbkVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGZlYXR1cmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpIHtcbiAgICB2YXIgc2VnbWVudEluZGV4ID0gMDtcblxuICAgIC8vIEV4Y2x1ZGUgbnVsbCBHZW9tZXRyaWVzXG4gICAgaWYgKCFmZWF0dXJlLmdlb21ldHJ5KSByZXR1cm47XG4gICAgLy8gKE11bHRpKVBvaW50IGdlb21ldHJpZXMgZG8gbm90IGNvbnRhaW4gc2VnbWVudHMgdGhlcmVmb3JlIHRoZXkgYXJlIGlnbm9yZWQgZHVyaW5nIHRoaXMgb3BlcmF0aW9uLlxuICAgIHZhciB0eXBlID0gZmVhdHVyZS5nZW9tZXRyeS50eXBlO1xuICAgIGlmICh0eXBlID09PSBcIlBvaW50XCIgfHwgdHlwZSA9PT0gXCJNdWx0aVBvaW50XCIpIHJldHVybjtcblxuICAgIC8vIEdlbmVyYXRlIDItdmVydGV4IGxpbmUgc2VnbWVudHNcbiAgICB2YXIgcHJldmlvdXNDb29yZHM7XG4gICAgdmFyIHByZXZpb3VzRmVhdHVyZUluZGV4ID0gMDtcbiAgICB2YXIgcHJldmlvdXNNdWx0aUluZGV4ID0gMDtcbiAgICB2YXIgcHJldkdlb21JbmRleCA9IDA7XG4gICAgaWYgKGNvb3JkRWFjaChmZWF0dXJlLCBmdW5jdGlvbiAoY3VycmVudENvb3JkLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXhDb29yZCwgbXVsdGlQYXJ0SW5kZXhDb29yZCwgZ2VvbWV0cnlJbmRleCkge1xuICAgICAgLy8gU2ltdWxhdGluZyBhIG1ldGEuY29vcmRSZWR1Y2UoKSBzaW5jZSBgcmVkdWNlYCBvcGVyYXRpb25zIGNhbm5vdCBiZSBzdG9wcGVkIGJ5IHJldHVybmluZyBgZmFsc2VgXG4gICAgICBpZiAocHJldmlvdXNDb29yZHMgPT09IHVuZGVmaW5lZCB8fCBmZWF0dXJlSW5kZXggPiBwcmV2aW91c0ZlYXR1cmVJbmRleCB8fCBtdWx0aVBhcnRJbmRleENvb3JkID4gcHJldmlvdXNNdWx0aUluZGV4IHx8IGdlb21ldHJ5SW5kZXggPiBwcmV2R2VvbUluZGV4KSB7XG4gICAgICAgIHByZXZpb3VzQ29vcmRzID0gY3VycmVudENvb3JkO1xuICAgICAgICBwcmV2aW91c0ZlYXR1cmVJbmRleCA9IGZlYXR1cmVJbmRleDtcbiAgICAgICAgcHJldmlvdXNNdWx0aUluZGV4ID0gbXVsdGlQYXJ0SW5kZXhDb29yZDtcbiAgICAgICAgcHJldkdlb21JbmRleCA9IGdlb21ldHJ5SW5kZXg7XG4gICAgICAgIHNlZ21lbnRJbmRleCA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjdXJyZW50U2VnbWVudCA9IGxpbmVTdHJpbmcoW3ByZXZpb3VzQ29vcmRzLCBjdXJyZW50Q29vcmRdLCBmZWF0dXJlLnByb3BlcnRpZXMpO1xuICAgICAgaWYgKGNhbGxiYWNrKGN1cnJlbnRTZWdtZW50LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4LCBzZWdtZW50SW5kZXgpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgc2VnbWVudEluZGV4Kys7XG4gICAgICBwcmV2aW91c0Nvb3JkcyA9IGN1cnJlbnRDb29yZDtcbiAgICB9KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIHNlZ21lbnRSZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBzZWdtZW50UmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZz59IGN1cnJlbnRTZWdtZW50IFRoZSBjdXJyZW50IFNlZ21lbnQgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbXVsdGlGZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIE11bHRpLUZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGdlb21ldHJ5SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIFNlZ21lbnQgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogUmVkdWNlIDItdmVydGV4IGxpbmUgc2VnbWVudCBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkucmVkdWNlKClcbiAqIChNdWx0aSlQb2ludCBnZW9tZXRyaWVzIGRvIG5vdCBjb250YWluIHNlZ21lbnRzIHRoZXJlZm9yZSB0aGV5IGFyZSBpZ25vcmVkIGR1cmluZyB0aGlzIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gYW55IEdlb0pTT05cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRTZWdtZW50LCBjdXJyZW50SW5kZXgpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHlnb24gPSB0dXJmLnBvbHlnb24oW1tbLTUwLCA1XSwgWy00MCwgLTEwXSwgWy01MCwgLTEwXSwgWy00MCwgNV0sIFstNTAsIDVdXV0pO1xuICpcbiAqIC8vIEl0ZXJhdGUgb3ZlciBHZW9KU09OIGJ5IDItdmVydGV4IHNlZ21lbnRzXG4gKiB0dXJmLnNlZ21lbnRSZWR1Y2UocG9seWdvbiwgZnVuY3Rpb24gKHByZXZpb3VzU2VnbWVudCwgY3VycmVudFNlZ21lbnQsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgsIHNlZ21lbnRJbmRleCkge1xuICogICAvLz0gcHJldmlvdXNTZWdtZW50XG4gKiAgIC8vPSBjdXJyZW50U2VnbWVudFxuICogICAvLz0gZmVhdHVyZUluZGV4XG4gKiAgIC8vPSBtdWx0aUZlYXR1cmVJbmRleFxuICogICAvLz0gZ2VvbWV0cnlJbmRleFxuICogICAvLz0gc2VnbWVudEluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50U2VnbWVudFxuICogfSk7XG4gKlxuICogLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBudW1iZXIgb2Ygc2VnbWVudHNcbiAqIHZhciBpbml0aWFsVmFsdWUgPSAwXG4gKiB2YXIgdG90YWwgPSB0dXJmLnNlZ21lbnRSZWR1Y2UocG9seWdvbiwgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUpIHtcbiAqICAgICBwcmV2aW91c1ZhbHVlKys7XG4gKiAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG4gKiB9LCBpbml0aWFsVmFsdWUpO1xuICovXG5mdW5jdGlvbiBzZWdtZW50UmVkdWNlKGdlb2pzb24sIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgdmFyIHByZXZpb3VzVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIHZhciBzdGFydGVkID0gZmFsc2U7XG4gIHNlZ21lbnRFYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KSB7XG4gICAgaWYgKHN0YXJ0ZWQgPT09IGZhbHNlICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudFNlZ21lbnQ7ZWxzZSBwcmV2aW91c1ZhbHVlID0gY2FsbGJhY2socHJldmlvdXNWYWx1ZSwgY3VycmVudFNlZ21lbnQsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgsIHNlZ21lbnRJbmRleCk7XG4gICAgc3RhcnRlZCA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgbGluZUVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgbGluZUVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBjdXJyZW50TGluZSBUaGUgY3VycmVudCBMaW5lU3RyaW5nfExpbmVhclJpbmcgYmVpbmcgcHJvY2Vzc2VkXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IGdlb21ldHJ5SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZFxuICovXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGxpbmUgb3IgcmluZyBjb29yZGluYXRlcyBpbiBMaW5lU3RyaW5nLCBQb2x5Z29uLCBNdWx0aUxpbmVTdHJpbmcsIE11bHRpUG9seWdvbiBGZWF0dXJlcyBvciBHZW9tZXRyaWVzLFxuICogc2ltaWxhciB0byBBcnJheS5mb3JFYWNoLlxuICpcbiAqIEBuYW1lIGxpbmVFYWNoXG4gKiBAcGFyYW0ge0dlb21ldHJ5fEZlYXR1cmU8TGluZVN0cmluZ3xQb2x5Z29ufE11bHRpTGluZVN0cmluZ3xNdWx0aVBvbHlnb24+fSBnZW9qc29uIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudExpbmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpTGluZSA9IHR1cmYubXVsdGlMaW5lU3RyaW5nKFtcbiAqICAgW1syNiwgMzddLCBbMzUsIDQ1XV0sXG4gKiAgIFtbMzYsIDUzXSwgWzM4LCA1MF0sIFs0MSwgNTVdXVxuICogXSk7XG4gKlxuICogdHVyZi5saW5lRWFjaChtdWx0aUxpbmUsIGZ1bmN0aW9uIChjdXJyZW50TGluZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICogICAvLz1jdXJyZW50TGluZVxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgLy89bXVsdGlGZWF0dXJlSW5kZXhcbiAqICAgLy89Z2VvbWV0cnlJbmRleFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGxpbmVFYWNoKGdlb2pzb24sIGNhbGxiYWNrKSB7XG4gIC8vIHZhbGlkYXRpb25cbiAgaWYgKCFnZW9qc29uKSB0aHJvdyBuZXcgRXJyb3IoXCJnZW9qc29uIGlzIHJlcXVpcmVkXCIpO1xuICBmbGF0dGVuRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoZmVhdHVyZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCkge1xuICAgIGlmIChmZWF0dXJlLmdlb21ldHJ5ID09PSBudWxsKSByZXR1cm47XG4gICAgdmFyIHR5cGUgPSBmZWF0dXJlLmdlb21ldHJ5LnR5cGU7XG4gICAgdmFyIGNvb3JkcyA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgICBpZiAoY2FsbGJhY2soZmVhdHVyZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgMCwgMCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgICAgZm9yICh2YXIgZ2VvbWV0cnlJbmRleCA9IDA7IGdlb21ldHJ5SW5kZXggPCBjb29yZHMubGVuZ3RoOyBnZW9tZXRyeUluZGV4KyspIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sobGluZVN0cmluZyhjb29yZHNbZ2VvbWV0cnlJbmRleF0sIGZlYXR1cmUucHJvcGVydGllcyksIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGxpbmVSZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBsaW5lUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZz59IGN1cnJlbnRMaW5lIFRoZSBjdXJyZW50IExpbmVTdHJpbmd8TGluZWFyUmluZyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IGdlb21ldHJ5SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZFxuICovXG5cbi8qKlxuICogUmVkdWNlIGZlYXR1cmVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5yZWR1Y2UoKS5cbiAqXG4gKiBAbmFtZSBsaW5lUmVkdWNlXG4gKiBAcGFyYW0ge0dlb21ldHJ5fEZlYXR1cmU8TGluZVN0cmluZ3xQb2x5Z29ufE11bHRpTGluZVN0cmluZ3xNdWx0aVBvbHlnb24+fSBnZW9qc29uIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudExpbmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aVBvbHkgPSB0dXJmLm11bHRpUG9seWdvbihbXG4gKiAgIHR1cmYucG9seWdvbihbW1sxMiw0OF0sWzIsNDFdLFsyNCwzOF0sWzEyLDQ4XV0sIFtbOSw0NF0sWzEzLDQxXSxbMTMsNDVdLFs5LDQ0XV1dKSxcbiAqICAgdHVyZi5wb2x5Z29uKFtbWzUsIDVdLCBbMCwgMF0sIFsyLCAyXSwgWzQsIDRdLCBbNSwgNV1dXSlcbiAqIF0pO1xuICpcbiAqIHR1cmYubGluZVJlZHVjZShtdWx0aVBvbHksIGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50TGluZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRMaW5lXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1tdWx0aUZlYXR1cmVJbmRleFxuICogICAvLz1nZW9tZXRyeUluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50TGluZVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGxpbmVSZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgbGluZUVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGN1cnJlbnRMaW5lLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSB7XG4gICAgaWYgKGZlYXR1cmVJbmRleCA9PT0gMCAmJiBpbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCkgcHJldmlvdXNWYWx1ZSA9IGN1cnJlbnRMaW5lO2Vsc2UgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRMaW5lLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KTtcbiAgfSk7XG4gIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuXG4vKipcbiAqIEZpbmRzIGEgcGFydGljdWxhciAyLXZlcnRleCBMaW5lU3RyaW5nIFNlZ21lbnQgZnJvbSBhIEdlb0pTT04gdXNpbmcgYEB0dXJmL21ldGFgIGluZGV4ZXMuXG4gKlxuICogTmVnYXRpdmUgaW5kZXhlcyBhcmUgcGVybWl0dGVkLlxuICogUG9pbnQgJiBNdWx0aVBvaW50IHdpbGwgYWx3YXlzIHJldHVybiBudWxsLlxuICpcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBBbnkgR2VvSlNPTiBGZWF0dXJlIG9yIEdlb21ldHJ5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5mZWF0dXJlSW5kZXg9MF0gRmVhdHVyZSBJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm11bHRpRmVhdHVyZUluZGV4PTBdIE11bHRpLUZlYXR1cmUgSW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5nZW9tZXRyeUluZGV4PTBdIEdlb21ldHJ5IEluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2VnbWVudEluZGV4PTBdIFNlZ21lbnQgSW5kZXhcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wcm9wZXJ0aWVzPXt9XSBUcmFuc2xhdGUgUHJvcGVydGllcyB0byBvdXRwdXQgTGluZVN0cmluZ1xuICogQHBhcmFtIHtCQm94fSBbb3B0aW9ucy5iYm94PXt9XSBUcmFuc2xhdGUgQkJveCB0byBvdXRwdXQgTGluZVN0cmluZ1xuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0aW9ucy5pZD17fV0gVHJhbnNsYXRlIElkIHRvIG91dHB1dCBMaW5lU3RyaW5nXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gMi12ZXJ0ZXggR2VvSlNPTiBGZWF0dXJlIExpbmVTdHJpbmdcbiAqIEBleGFtcGxlXG4gKiB2YXIgbXVsdGlMaW5lID0gdHVyZi5tdWx0aUxpbmVTdHJpbmcoW1xuICogICAgIFtbMTAsIDEwXSwgWzUwLCAzMF0sIFszMCwgNDBdXSxcbiAqICAgICBbWy0xMCwgLTEwXSwgWy01MCwgLTMwXSwgWy0zMCwgLTQwXV1cbiAqIF0pO1xuICpcbiAqIC8vIEZpcnN0IFNlZ21lbnQgKGRlZmF1bHRzIGFyZSAwKVxuICogdHVyZi5maW5kU2VnbWVudChtdWx0aUxpbmUpO1xuICogLy8gPT4gRmVhdHVyZTxMaW5lU3RyaW5nPFtbMTAsIDEwXSwgWzUwLCAzMF1dPj5cbiAqXG4gKiAvLyBGaXJzdCBTZWdtZW50IG9mIDJuZCBNdWx0aSBGZWF0dXJlXG4gKiB0dXJmLmZpbmRTZWdtZW50KG11bHRpTGluZSwge211bHRpRmVhdHVyZUluZGV4OiAxfSk7XG4gKiAvLyA9PiBGZWF0dXJlPExpbmVTdHJpbmc8W1stMTAsIC0xMF0sIFstNTAsIC0zMF1dPj5cbiAqXG4gKiAvLyBMYXN0IFNlZ21lbnQgb2YgTGFzdCBNdWx0aSBGZWF0dXJlXG4gKiB0dXJmLmZpbmRTZWdtZW50KG11bHRpTGluZSwge211bHRpRmVhdHVyZUluZGV4OiAtMSwgc2VnbWVudEluZGV4OiAtMX0pO1xuICogLy8gPT4gRmVhdHVyZTxMaW5lU3RyaW5nPFtbLTUwLCAtMzBdLCBbLTMwLCAtNDBdXT4+XG4gKi9cbmZ1bmN0aW9uIGZpbmRTZWdtZW50KGdlb2pzb24sIG9wdGlvbnMpIHtcbiAgLy8gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCFpc09iamVjdChvcHRpb25zKSkgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucyBpcyBpbnZhbGlkXCIpO1xuICB2YXIgZmVhdHVyZUluZGV4ID0gb3B0aW9ucy5mZWF0dXJlSW5kZXggfHwgMDtcbiAgdmFyIG11bHRpRmVhdHVyZUluZGV4ID0gb3B0aW9ucy5tdWx0aUZlYXR1cmVJbmRleCB8fCAwO1xuICB2YXIgZ2VvbWV0cnlJbmRleCA9IG9wdGlvbnMuZ2VvbWV0cnlJbmRleCB8fCAwO1xuICB2YXIgc2VnbWVudEluZGV4ID0gb3B0aW9ucy5zZWdtZW50SW5kZXggfHwgMDtcblxuICAvLyBGaW5kIEZlYXR1cmVJbmRleFxuICB2YXIgcHJvcGVydGllcyA9IG9wdGlvbnMucHJvcGVydGllcztcbiAgdmFyIGdlb21ldHJ5O1xuICBzd2l0Y2ggKGdlb2pzb24udHlwZSkge1xuICAgIGNhc2UgXCJGZWF0dXJlQ29sbGVjdGlvblwiOlxuICAgICAgaWYgKGZlYXR1cmVJbmRleCA8IDApIGZlYXR1cmVJbmRleCA9IGdlb2pzb24uZmVhdHVyZXMubGVuZ3RoICsgZmVhdHVyZUluZGV4O1xuICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwgZ2VvanNvbi5mZWF0dXJlc1tmZWF0dXJlSW5kZXhdLnByb3BlcnRpZXM7XG4gICAgICBnZW9tZXRyeSA9IGdlb2pzb24uZmVhdHVyZXNbZmVhdHVyZUluZGV4XS5nZW9tZXRyeTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJGZWF0dXJlXCI6XG4gICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCBnZW9qc29uLnByb3BlcnRpZXM7XG4gICAgICBnZW9tZXRyeSA9IGdlb2pzb24uZ2VvbWV0cnk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjpcbiAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6XG4gICAgICBnZW9tZXRyeSA9IGdlb2pzb247XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2VvanNvbiBpcyBpbnZhbGlkXCIpO1xuICB9XG5cbiAgLy8gRmluZCBTZWdtZW50SW5kZXhcbiAgaWYgKGdlb21ldHJ5ID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgdmFyIGNvb3JkcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICBzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcbiAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgIGlmIChzZWdtZW50SW5kZXggPCAwKSBzZWdtZW50SW5kZXggPSBjb29yZHMubGVuZ3RoICsgc2VnbWVudEluZGV4IC0gMTtcbiAgICAgIHJldHVybiBsaW5lU3RyaW5nKFtjb29yZHNbc2VnbWVudEluZGV4XSwgY29vcmRzW3NlZ21lbnRJbmRleCArIDFdXSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG4gICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgIGlmIChnZW9tZXRyeUluZGV4IDwgMCkgZ2VvbWV0cnlJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBnZW9tZXRyeUluZGV4O1xuICAgICAgaWYgKHNlZ21lbnRJbmRleCA8IDApIHNlZ21lbnRJbmRleCA9IGNvb3Jkc1tnZW9tZXRyeUluZGV4XS5sZW5ndGggKyBzZWdtZW50SW5kZXggLSAxO1xuICAgICAgcmV0dXJuIGxpbmVTdHJpbmcoW2Nvb3Jkc1tnZW9tZXRyeUluZGV4XVtzZWdtZW50SW5kZXhdLCBjb29yZHNbZ2VvbWV0cnlJbmRleF1bc2VnbWVudEluZGV4ICsgMV1dLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6XG4gICAgICBpZiAobXVsdGlGZWF0dXJlSW5kZXggPCAwKSBtdWx0aUZlYXR1cmVJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBtdWx0aUZlYXR1cmVJbmRleDtcbiAgICAgIGlmIChzZWdtZW50SW5kZXggPCAwKSBzZWdtZW50SW5kZXggPSBjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdLmxlbmd0aCArIHNlZ21lbnRJbmRleCAtIDE7XG4gICAgICByZXR1cm4gbGluZVN0cmluZyhbY29vcmRzW211bHRpRmVhdHVyZUluZGV4XVtzZWdtZW50SW5kZXhdLCBjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW3NlZ21lbnRJbmRleCArIDFdXSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG4gICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgICAgaWYgKG11bHRpRmVhdHVyZUluZGV4IDwgMCkgbXVsdGlGZWF0dXJlSW5kZXggPSBjb29yZHMubGVuZ3RoICsgbXVsdGlGZWF0dXJlSW5kZXg7XG4gICAgICBpZiAoZ2VvbWV0cnlJbmRleCA8IDApIGdlb21ldHJ5SW5kZXggPSBjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdLmxlbmd0aCArIGdlb21ldHJ5SW5kZXg7XG4gICAgICBpZiAoc2VnbWVudEluZGV4IDwgMCkgc2VnbWVudEluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XVtnZW9tZXRyeUluZGV4XS5sZW5ndGggLSBzZWdtZW50SW5kZXggLSAxO1xuICAgICAgcmV0dXJuIGxpbmVTdHJpbmcoW2Nvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bZ2VvbWV0cnlJbmRleF1bc2VnbWVudEluZGV4XSwgY29vcmRzW211bHRpRmVhdHVyZUluZGV4XVtnZW9tZXRyeUluZGV4XVtzZWdtZW50SW5kZXggKyAxXV0sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcImdlb2pzb24gaXMgaW52YWxpZFwiKTtcbn1cblxuLyoqXG4gKiBGaW5kcyBhIHBhcnRpY3VsYXIgUG9pbnQgZnJvbSBhIEdlb0pTT04gdXNpbmcgYEB0dXJmL21ldGFgIGluZGV4ZXMuXG4gKlxuICogTmVnYXRpdmUgaW5kZXhlcyBhcmUgcGVybWl0dGVkLlxuICpcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBBbnkgR2VvSlNPTiBGZWF0dXJlIG9yIEdlb21ldHJ5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5mZWF0dXJlSW5kZXg9MF0gRmVhdHVyZSBJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm11bHRpRmVhdHVyZUluZGV4PTBdIE11bHRpLUZlYXR1cmUgSW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5nZW9tZXRyeUluZGV4PTBdIEdlb21ldHJ5IEluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29vcmRJbmRleD0wXSBDb29yZCBJbmRleFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnByb3BlcnRpZXM9e31dIFRyYW5zbGF0ZSBQcm9wZXJ0aWVzIHRvIG91dHB1dCBQb2ludFxuICogQHBhcmFtIHtCQm94fSBbb3B0aW9ucy5iYm94PXt9XSBUcmFuc2xhdGUgQkJveCB0byBvdXRwdXQgUG9pbnRcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdGlvbnMuaWQ9e31dIFRyYW5zbGF0ZSBJZCB0byBvdXRwdXQgUG9pbnRcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvaW50Pn0gMi12ZXJ0ZXggR2VvSlNPTiBGZWF0dXJlIFBvaW50XG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpTGluZSA9IHR1cmYubXVsdGlMaW5lU3RyaW5nKFtcbiAqICAgICBbWzEwLCAxMF0sIFs1MCwgMzBdLCBbMzAsIDQwXV0sXG4gKiAgICAgW1stMTAsIC0xMF0sIFstNTAsIC0zMF0sIFstMzAsIC00MF1dXG4gKiBdKTtcbiAqXG4gKiAvLyBGaXJzdCBTZWdtZW50IChkZWZhdWx0cyBhcmUgMClcbiAqIHR1cmYuZmluZFBvaW50KG11bHRpTGluZSk7XG4gKiAvLyA9PiBGZWF0dXJlPFBvaW50PFsxMCwgMTBdPj5cbiAqXG4gKiAvLyBGaXJzdCBTZWdtZW50IG9mIHRoZSAybmQgTXVsdGktRmVhdHVyZVxuICogdHVyZi5maW5kUG9pbnQobXVsdGlMaW5lLCB7bXVsdGlGZWF0dXJlSW5kZXg6IDF9KTtcbiAqIC8vID0+IEZlYXR1cmU8UG9pbnQ8Wy0xMCwgLTEwXT4+XG4gKlxuICogLy8gTGFzdCBTZWdtZW50IG9mIGxhc3QgTXVsdGktRmVhdHVyZVxuICogdHVyZi5maW5kUG9pbnQobXVsdGlMaW5lLCB7bXVsdGlGZWF0dXJlSW5kZXg6IC0xLCBjb29yZEluZGV4OiAtMX0pO1xuICogLy8gPT4gRmVhdHVyZTxQb2ludDxbLTMwLCAtNDBdPj5cbiAqL1xuZnVuY3Rpb24gZmluZFBvaW50KGdlb2pzb24sIG9wdGlvbnMpIHtcbiAgLy8gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCFpc09iamVjdChvcHRpb25zKSkgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucyBpcyBpbnZhbGlkXCIpO1xuICB2YXIgZmVhdHVyZUluZGV4ID0gb3B0aW9ucy5mZWF0dXJlSW5kZXggfHwgMDtcbiAgdmFyIG11bHRpRmVhdHVyZUluZGV4ID0gb3B0aW9ucy5tdWx0aUZlYXR1cmVJbmRleCB8fCAwO1xuICB2YXIgZ2VvbWV0cnlJbmRleCA9IG9wdGlvbnMuZ2VvbWV0cnlJbmRleCB8fCAwO1xuICB2YXIgY29vcmRJbmRleCA9IG9wdGlvbnMuY29vcmRJbmRleCB8fCAwO1xuXG4gIC8vIEZpbmQgRmVhdHVyZUluZGV4XG4gIHZhciBwcm9wZXJ0aWVzID0gb3B0aW9ucy5wcm9wZXJ0aWVzO1xuICB2YXIgZ2VvbWV0cnk7XG4gIHN3aXRjaCAoZ2VvanNvbi50eXBlKSB7XG4gICAgY2FzZSBcIkZlYXR1cmVDb2xsZWN0aW9uXCI6XG4gICAgICBpZiAoZmVhdHVyZUluZGV4IDwgMCkgZmVhdHVyZUluZGV4ID0gZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggKyBmZWF0dXJlSW5kZXg7XG4gICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCBnZW9qc29uLmZlYXR1cmVzW2ZlYXR1cmVJbmRleF0ucHJvcGVydGllcztcbiAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbi5mZWF0dXJlc1tmZWF0dXJlSW5kZXhdLmdlb21ldHJ5O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkZlYXR1cmVcIjpcbiAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IGdlb2pzb24ucHJvcGVydGllcztcbiAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbi5nZW9tZXRyeTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQb2ludFwiOlxuICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZW9qc29uIGlzIGludmFsaWRcIik7XG4gIH1cblxuICAvLyBGaW5kIENvb3JkIEluZGV4XG4gIGlmIChnZW9tZXRyeSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHZhciBjb29yZHMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgc3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XG4gICAgY2FzZSBcIlBvaW50XCI6XG4gICAgICByZXR1cm4gcG9pbnQoY29vcmRzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgaWYgKG11bHRpRmVhdHVyZUluZGV4IDwgMCkgbXVsdGlGZWF0dXJlSW5kZXggPSBjb29yZHMubGVuZ3RoICsgbXVsdGlGZWF0dXJlSW5kZXg7XG4gICAgICByZXR1cm4gcG9pbnQoY29vcmRzW211bHRpRmVhdHVyZUluZGV4XSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG4gICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgIGlmIChjb29yZEluZGV4IDwgMCkgY29vcmRJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBjb29yZEluZGV4O1xuICAgICAgcmV0dXJuIHBvaW50KGNvb3Jkc1tjb29yZEluZGV4XSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG4gICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgIGlmIChnZW9tZXRyeUluZGV4IDwgMCkgZ2VvbWV0cnlJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBnZW9tZXRyeUluZGV4O1xuICAgICAgaWYgKGNvb3JkSW5kZXggPCAwKSBjb29yZEluZGV4ID0gY29vcmRzW2dlb21ldHJ5SW5kZXhdLmxlbmd0aCArIGNvb3JkSW5kZXg7XG4gICAgICByZXR1cm4gcG9pbnQoY29vcmRzW2dlb21ldHJ5SW5kZXhdW2Nvb3JkSW5kZXhdLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6XG4gICAgICBpZiAobXVsdGlGZWF0dXJlSW5kZXggPCAwKSBtdWx0aUZlYXR1cmVJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBtdWx0aUZlYXR1cmVJbmRleDtcbiAgICAgIGlmIChjb29yZEluZGV4IDwgMCkgY29vcmRJbmRleCA9IGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF0ubGVuZ3RoICsgY29vcmRJbmRleDtcbiAgICAgIHJldHVybiBwb2ludChjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW2Nvb3JkSW5kZXhdLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6XG4gICAgICBpZiAobXVsdGlGZWF0dXJlSW5kZXggPCAwKSBtdWx0aUZlYXR1cmVJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBtdWx0aUZlYXR1cmVJbmRleDtcbiAgICAgIGlmIChnZW9tZXRyeUluZGV4IDwgMCkgZ2VvbWV0cnlJbmRleCA9IGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF0ubGVuZ3RoICsgZ2VvbWV0cnlJbmRleDtcbiAgICAgIGlmIChjb29yZEluZGV4IDwgMCkgY29vcmRJbmRleCA9IGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bZ2VvbWV0cnlJbmRleF0ubGVuZ3RoIC0gY29vcmRJbmRleDtcbiAgICAgIHJldHVybiBwb2ludChjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW2dlb21ldHJ5SW5kZXhdW2Nvb3JkSW5kZXhdLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJnZW9qc29uIGlzIGludmFsaWRcIik7XG59XG5leHBvcnQgeyBjb29yZEFsbCwgY29vcmRFYWNoLCBjb29yZFJlZHVjZSwgZmVhdHVyZUVhY2gsIGZlYXR1cmVSZWR1Y2UsIGZpbmRQb2ludCwgZmluZFNlZ21lbnQsIGZsYXR0ZW5FYWNoLCBmbGF0dGVuUmVkdWNlLCBnZW9tRWFjaCwgZ2VvbVJlZHVjZSwgbGluZUVhY2gsIGxpbmVSZWR1Y2UsIHByb3BFYWNoLCBwcm9wUmVkdWNlLCBzZWdtZW50RWFjaCwgc2VnbWVudFJlZHVjZSB9OyIsImltcG9ydCB7IGNvb3JkRWFjaCB9IGZyb20gXCJAdHVyZi9tZXRhXCI7XG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIGZlYXR1cmVzLCBjYWxjdWxhdGVzIHRoZSBiYm94IG9mIGFsbCBpbnB1dCBmZWF0dXJlcywgYW5kIHJldHVybnMgYSBib3VuZGluZyBib3guXG4gKlxuICogQG5hbWUgYmJveFxuICogQHBhcmFtIHtHZW9KU09OfSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHJldHVybnMge0JCb3h9IGJib3ggZXh0ZW50IGluIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBvcmRlclxuICogQGV4YW1wbGVcbiAqIHZhciBsaW5lID0gdHVyZi5saW5lU3RyaW5nKFtbLTc0LCA0MF0sIFstNzgsIDQyXSwgWy04MiwgMzVdXSk7XG4gKiB2YXIgYmJveCA9IHR1cmYuYmJveChsaW5lKTtcbiAqIHZhciBiYm94UG9seWdvbiA9IHR1cmYuYmJveFBvbHlnb24oYmJveCk7XG4gKlxuICogLy9hZGRUb01hcFxuICogdmFyIGFkZFRvTWFwID0gW2xpbmUsIGJib3hQb2x5Z29uXVxuICovXG5mdW5jdGlvbiBiYm94KGdlb2pzb24pIHtcbiAgdmFyIHJlc3VsdCA9IFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcbiAgY29vcmRFYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjb29yZCkge1xuICAgIGlmIChyZXN1bHRbMF0gPiBjb29yZFswXSkge1xuICAgICAgcmVzdWx0WzBdID0gY29vcmRbMF07XG4gICAgfVxuICAgIGlmIChyZXN1bHRbMV0gPiBjb29yZFsxXSkge1xuICAgICAgcmVzdWx0WzFdID0gY29vcmRbMV07XG4gICAgfVxuICAgIGlmIChyZXN1bHRbMl0gPCBjb29yZFswXSkge1xuICAgICAgcmVzdWx0WzJdID0gY29vcmRbMF07XG4gICAgfVxuICAgIGlmIChyZXN1bHRbM10gPCBjb29yZFsxXSkge1xuICAgICAgcmVzdWx0WzNdID0gY29vcmRbMV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmJib3hbXCJkZWZhdWx0XCJdID0gYmJveDtcbmV4cG9ydCBkZWZhdWx0IGJib3g7IiwiZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW4odCkge1xuICByZXR1cm4gdCAqIHQgKiB0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcbiAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY0luT3V0KHQpIHtcbiAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gdCAqIHQgKiB0IDogKHQgLT0gMikgKiB0ICogdCArIDIpIC8gMjtcbn0iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlU3RhdGUsIHVzZVJlZiwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNCcm93c2VyLCBub29wIH0gZnJvbSAnLi9taXNjL3V0aWwnO1xudmFyIHVzZUxvY2FsU3RvcmFnZSA9IGZ1bmN0aW9uIChrZXksIGluaXRpYWxWYWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIWlzQnJvd3Nlcikge1xuICAgIHJldHVybiBbaW5pdGlhbFZhbHVlLCBub29wLCBub29wXTtcbiAgfVxuICBpZiAoIWtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlTG9jYWxTdG9yYWdlIGtleSBtYXkgbm90IGJlIGZhbHN5Jyk7XG4gIH1cbiAgdmFyIGRlc2VyaWFsaXplciA9IG9wdGlvbnMgPyBvcHRpb25zLnJhdyA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSA6IG9wdGlvbnMuZGVzZXJpYWxpemVyIDogSlNPTi5wYXJzZTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gIHZhciBpbml0aWFsaXplciA9IHVzZVJlZihmdW5jdGlvbiAoa2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBzZXJpYWxpemVyID0gb3B0aW9ucyA/IG9wdGlvbnMucmF3ID8gU3RyaW5nIDogb3B0aW9ucy5zZXJpYWxpemVyIDogSlNPTi5zdHJpbmdpZnk7XG4gICAgICB2YXIgbG9jYWxTdG9yYWdlVmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgaWYgKGxvY2FsU3RvcmFnZVZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZXIobG9jYWxTdG9yYWdlVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbFZhbHVlICYmIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgc2VyaWFsaXplcihpbml0aWFsVmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfYSkge1xuICAgICAgLy8gSWYgdXNlciBpcyBpbiBwcml2YXRlIG1vZGUgb3IgaGFzIHN0b3JhZ2UgcmVzdHJpY3Rpb25cbiAgICAgIC8vIGxvY2FsU3RvcmFnZSBjYW4gdGhyb3cuIEpTT04ucGFyc2UgYW5kIEpTT04uc3RyaW5naWZ5XG4gICAgICAvLyBjYW4gdGhyb3csIHRvby5cbiAgICAgIHJldHVybiBpbml0aWFsVmFsdWU7XG4gICAgfVxuICB9KTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gIHZhciBfYSA9IHVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbml0aWFsaXplci5jdXJyZW50KGtleSk7XG4gICAgfSksXG4gICAgc3RhdGUgPSBfYVswXSxcbiAgICBzZXRTdGF0ZSA9IF9hWzFdO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgdXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2V0U3RhdGUoaW5pdGlhbGl6ZXIuY3VycmVudChrZXkpKTtcbiAgfSwgW2tleV0pO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgdmFyIHNldCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWxPckZ1bmMpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIG5ld1N0YXRlID0gdHlwZW9mIHZhbE9yRnVuYyA9PT0gJ2Z1bmN0aW9uJyA/IHZhbE9yRnVuYyhzdGF0ZSkgOiB2YWxPckZ1bmM7XG4gICAgICBpZiAodHlwZW9mIG5ld1N0YXRlID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmF3KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXdTdGF0ZSA9PT0gJ3N0cmluZycpIHZhbHVlID0gbmV3U3RhdGU7ZWxzZSB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KG5ld1N0YXRlKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnNlcmlhbGl6ZXIpIHZhbHVlID0gb3B0aW9ucy5zZXJpYWxpemVyKG5ld1N0YXRlKTtlbHNlIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkobmV3U3RhdGUpO1xuICAgICAgfSBlbHNlIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkobmV3U3RhdGUpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgICBzZXRTdGF0ZShkZXNlcmlhbGl6ZXIodmFsdWUpKTtcbiAgICB9IGNhdGNoIChfYSkge1xuICAgICAgLy8gSWYgdXNlciBpcyBpbiBwcml2YXRlIG1vZGUgb3IgaGFzIHN0b3JhZ2UgcmVzdHJpY3Rpb25cbiAgICAgIC8vIGxvY2FsU3RvcmFnZSBjYW4gdGhyb3cuIEFsc28gSlNPTi5zdHJpbmdpZnkgY2FuIHRocm93LlxuICAgIH1cbiAgfSwgW2tleSwgc2V0U3RhdGVdKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gIHZhciByZW1vdmUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICBzZXRTdGF0ZSh1bmRlZmluZWQpO1xuICAgIH0gY2F0Y2ggKF9hKSB7XG4gICAgICAvLyBJZiB1c2VyIGlzIGluIHByaXZhdGUgbW9kZSBvciBoYXMgc3RvcmFnZSByZXN0cmljdGlvblxuICAgICAgLy8gbG9jYWxTdG9yYWdlIGNhbiB0aHJvdy5cbiAgICB9XG4gIH0sIFtrZXksIHNldFN0YXRlXSk7XG4gIHJldHVybiBbc3RhdGUsIHNldCwgcmVtb3ZlXTtcbn07XG5leHBvcnQgZGVmYXVsdCB1c2VMb2NhbFN0b3JhZ2U7IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIGRpc2FkdmFudGFnZWREb3RCaWcgPSBcIkRpc2FkdmFudGFnZURvdC1tb2R1bGUtLWRpc2FkdmFudGFnZWREb3RCaWctLXVFaitZXCI7XG5leHBvcnQgdmFyIGRpc2FkdmFudGFnZWREb3RTbWFsbCA9IFwiRGlzYWR2YW50YWdlRG90LW1vZHVsZS0tZGlzYWR2YW50YWdlZERvdFNtYWxsLS03NU5tUFwiOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuL0Rpc2FkdmFudGFnZURvdC5tb2R1bGUuc2Nzcyc7XG5cbmludGVyZmFjZSBJRGlzYWR2YW50YWdlRG90IHtcbiAgaXNEaXNhZHZhbnRhZ2VkPzogYm9vbGVhbiB8IG51bGw7XG4gIGlzQmlnPzogYm9vbGVhbjtcbn1cbmNvbnN0IERpc2FkdmFudGFnZURvdCA9ICh7aXNEaXNhZHZhbnRhZ2VkID0gZmFsc2UsIGlzQmlnfTpJRGlzYWR2YW50YWdlRG90KSA9PiB7XG4gIGxldCBjb21wdXRlZENsYXNzID0gJyc7XG5cbiAgaWYgKGlzQmlnKSB7XG4gICAgY29tcHV0ZWRDbGFzcyA9IHN0eWxlcy5kaXNhZHZhbnRhZ2VkRG90QmlnO1xuICB9IGVsc2Uge1xuICAgIGNvbXB1dGVkQ2xhc3MgPSBpc0Rpc2FkdmFudGFnZWQgPyBzdHlsZXMuZGlzYWR2YW50YWdlZERvdFNtYWxsIDogJyc7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjb21wdXRlZENsYXNzfSAvPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRGlzYWR2YW50YWdlRG90O1xuIiwiaW1wb3J0IERpc2FkdmFudGFnZURvdCBmcm9tICcuL0Rpc2FkdmFudGFnZURvdCc7XG5cbmV4cG9ydCBkZWZhdWx0IERpc2FkdmFudGFnZURvdDtcbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHZhciBjYXRlZ29yeSA9IFwiQ2F0ZWdvcnktbW9kdWxlLS1jYXRlZ29yeS0tUWl5R0JcIjtcbmV4cG9ydCB2YXIgY2F0ZWdvcnlDb250YWluZXIgPSBcIkNhdGVnb3J5LW1vZHVsZS0tY2F0ZWdvcnlDb250YWluZXItLWhKUXlkXCI7XG5leHBvcnQgdmFyIGRpc0NhdGVnb3J5Q29udGFpbmVyID0gXCJDYXRlZ29yeS1tb2R1bGUtLWRpc0NhdGVnb3J5Q29udGFpbmVyLS1LN1ppd1wiOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRGlzYWR2YW50YWdlRG90IGZyb20gJy4uL0Rpc2FkdmFudGFnZURvdCc7XG5cbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuL0NhdGVnb3J5Lm1vZHVsZS5zY3NzJztcblxuaW50ZXJmYWNlIElDYXRlZ29yeSB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGlzRGlzYWR2YW50YWdlZDogYm9vbGVhbiB8IG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgY29udHJvbHMgdGhlIENhdGVnb3JpZXMgb24gdGhlIHNpZGUgcGFuZWwuXG4gKlxuICogVGhlIGNhdGVnb3J5IHdpbGwgYmUgc3R5bGVkIGRpZmZlcmVudGx5IGRpZmZlcmVudGx5IGRlcGVuZGluZyBvblxuICogaWYgdGhlIGNhdGVnb3J5IGlzIGRpc2FkdmFudGFnZWQgb3Igbm90LiBUaGUgSlNYIGluIHRoZSByZXR1cm5cbiAqIHN0YXRlbWVudCBpcyBpZGVudGljYWwgaG93ZXZlciBpbiB0aGUgZ2xvYmFsIENTUyBmaWxlLCB3ZVxuICogb3ZlcnJpZGUgdGhlIGRpc2FkdmFudGFnZWQgY2FzZSB3aXRoIGEgcHN1ZWRvLXNlbGVjdG9yICg6aGFzKSB0aGF0XG4gKiBpcyBuZXcuIEluIG9yZGVyIHRvIGZhbGxiYWNrIGdyYWNlZnVsbHkgZm9yIGJyb3dzZXJzIHRoYXQgZG9cbiAqIG5vdCB5ZXQgc3VwcG9ydCB0aGUgXCI6aGFzXCIgcHN1ZWRvIHNlbGVjdG9yLCB0aGlzIHJlZHVuZGFudCBKU1hcbiAqIHdpbGwgYWxsb3cgdGhlIGRpc2FkdmFudGFnZWQgY2FzZSBzaG93IHRoZSBvbGRlciBjYXRlZ29yeSBzdHlsaW5nXG4gKiB3aGlsZSBicm93c2VycyB0aGF0IGRvIHN1cHBvcnQgdGhlIFwiOmhhc1wiIHBzdWVkbyBzZWxlY3RvciB3aWxsXG4gKiByZW5kZXIgdGhlIG5ld2VyIGNhdGVnb3J5IHN0eWxlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRGlzYWR2YWd0YWdlZFxuICogQHJldHVybiB7SlNYLkVsZW1lbnR9XG4gKi9cbmNvbnN0IENhdGVnb3J5ID0gKHtuYW1lLCBpc0Rpc2FkdmFudGFnZWR9OklDYXRlZ29yeSkgPT4ge1xuICByZXR1cm4gaXNEaXNhZHZhbnRhZ2VkID8gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZGlzQ2F0ZWdvcnlDb250YWluZXJ9PlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jYXRlZ29yeX0+XG4gICAgICAgIHtuYW1lfVxuICAgICAgPC9kaXY+XG4gICAgICA8RGlzYWR2YW50YWdlRG90IGlzRGlzYWR2YW50YWdlZD17aXNEaXNhZHZhbnRhZ2VkfS8+XG4gICAgPC9kaXY+XG4gICkgOiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jYXRlZ29yeUNvbnRhaW5lcn0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNhdGVnb3J5fT5cbiAgICAgICAge25hbWV9XG4gICAgICA8L2Rpdj5cbiAgICAgIDxEaXNhZHZhbnRhZ2VEb3QgaXNEaXNhZHZhbnRhZ2VkPXtpc0Rpc2FkdmFudGFnZWR9Lz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5leHBvcnQgZGVmYXVsdCBDYXRlZ29yeTtcbiIsImltcG9ydCBDYXRlZ29yeSBmcm9tICcuL0NhdGVnb3J5JztcblxuZXhwb3J0IGRlZmF1bHQgQ2F0ZWdvcnk7XG4iLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiBJbiB0aGUgYnJvd3NlciB3ZSB0aGVyZWZvcmVcbi8vIHJlcXVpcmUgdGhlIGNyeXB0byBBUEkgYW5kIGRvIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGZhbGxiYWNrIHRvIGxvd2VyIHF1YWxpdHkgcmFuZG9tIG51bWJlclxuLy8gZ2VuZXJhdG9ycyAobGlrZSBNYXRoLnJhbmRvbSgpKS5cbi8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi4gQWxzbyxcbi8vIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byAobXNDcnlwdG8pIG9uIElFMTEuXG52YXIgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pIHx8IHR5cGVvZiBtc0NyeXB0byAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pO1xudmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJuZygpIHtcbiAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gIH1cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59IiwiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4OyAvLyBqb2luIHVzZWQgdG8gZml4IG1lbW9yeSBpc3N1ZSBjYXVzZWQgYnkgY29uY2F0ZW5hdGlvbjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzE3NSNjNFxuXG4gIHJldHVybiBbYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJywgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dXS5qb2luKCcnKTtcbn1cbmV4cG9ydCBkZWZhdWx0IGJ5dGVzVG9VdWlkOyIsImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IGJ5dGVzVG9VdWlkIGZyb20gJy4vYnl0ZXNUb1V1aWQuanMnO1xuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnc3RyaW5nJykge1xuICAgIGJ1ZiA9IG9wdGlvbnMgPT09ICdiaW5hcnknID8gbmV3IEFycmF5KDE2KSA6IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7ICsraWkpIHtcbiAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBidWYgfHwgYnl0ZXNUb1V1aWQocm5kcyk7XG59XG5leHBvcnQgZGVmYXVsdCB2NDsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IHY0IH0gZnJvbSAndXVpZCc7XG5mdW5jdGlvbiBvd25LZXlzJDIob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGkgJSAyID8gb3duS2V5cyQyKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMkMihPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICB9XG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICByZXN1bHQ7XG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07XG4gIGlmICghaXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKCkge307XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzOiBGLFxuICAgICAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9LFxuICAgICAgICBmOiBGXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cbiAgdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLFxuICAgIGRpZEVyciA9IGZhbHNlLFxuICAgIGVycjtcbiAgcmV0dXJuIHtcbiAgICBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpdCA9IGl0LmNhbGwobyk7XG4gICAgfSxcbiAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0Lm5leHQoKTtcbiAgICAgIG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7XG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICBkaWRFcnIgPSB0cnVlO1xuICAgICAgZXJyID0gZTtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsJGEgPVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbmNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8IGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAtLSBzYWZlXG5jaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fCBjaGVjayh0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwpIHx8XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gZmFsbGJhY2tcbmZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KCkgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSB7fTtcbnZhciBmYWlscyQ5ID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG52YXIgZmFpbHMkOCA9IGZhaWxzJDk7XG5cbi8vIERldGVjdCBJRTgncyBpbmNvbXBsZXRlIGRlZmluZVByb3BlcnR5IGltcGxlbWVudGF0aW9uXG52YXIgZGVzY3JpcHRvcnMgPSAhZmFpbHMkOChmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgMSwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDc7XG4gICAgfVxuICB9KVsxXSAhPSA3O1xufSk7XG52YXIgZmFpbHMkNyA9IGZhaWxzJDk7XG52YXIgZnVuY3Rpb25CaW5kTmF0aXZlID0gIWZhaWxzJDcoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZnVuY3Rpb24tcHJvdG90eXBlLWJpbmQgLS0gc2FmZVxuICB2YXIgdGVzdCA9IGZ1bmN0aW9uICgpIHsvKiBlbXB0eSAqL30uYmluZCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcbnZhciBOQVRJVkVfQklORCQyID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xudmFyIGNhbGwkNCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xudmFyIGZ1bmN0aW9uQ2FsbCA9IE5BVElWRV9CSU5EJDIgPyBjYWxsJDQuYmluZChjYWxsJDQpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbCQ0LmFwcGx5KGNhbGwkNCwgYXJndW1lbnRzKTtcbn07XG52YXIgb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUgPSB7fTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHtcbiAgMTogMlxufSwgMSk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxub2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKHRoaXMsIFYpO1xuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiAkcHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcbnZhciBOQVRJVkVfQklORCQxID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDEgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgY2FsbCQzID0gRnVuY3Rpb25Qcm90b3R5cGUkMS5jYWxsO1xudmFyIHVuY3VycnlUaGlzV2l0aEJpbmQgPSBOQVRJVkVfQklORCQxICYmIEZ1bmN0aW9uUHJvdG90eXBlJDEuYmluZC5iaW5kKGNhbGwkMywgY2FsbCQzKTtcbnZhciBmdW5jdGlvblVuY3VycnlUaGlzUmF3ID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBOQVRJVkVfQklORCQxID8gdW5jdXJyeVRoaXNXaXRoQmluZChmbikgOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGwkMy5hcHBseShmbiwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG52YXIgdW5jdXJyeVRoaXNSYXckMSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXNSYXc7XG52YXIgdG9TdHJpbmckMSA9IHVuY3VycnlUaGlzUmF3JDEoe30udG9TdHJpbmcpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXNSYXckMSgnJy5zbGljZSk7XG52YXIgY2xhc3NvZlJhdyQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBzdHJpbmdTbGljZSh0b1N0cmluZyQxKGl0KSwgOCwgLTEpO1xufTtcbnZhciBjbGFzc29mUmF3JDEgPSBjbGFzc29mUmF3JDI7XG52YXIgdW5jdXJyeVRoaXNSYXcgPSBmdW5jdGlvblVuY3VycnlUaGlzUmF3O1xudmFyIGZ1bmN0aW9uVW5jdXJyeVRoaXMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgLy8gTmFzaG9ybiBidWc6XG4gIC8vICAgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzExMjhcbiAgLy8gICBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTEzMFxuICBpZiAoY2xhc3NvZlJhdyQxKGZuKSA9PT0gJ0Z1bmN0aW9uJykgcmV0dXJuIHVuY3VycnlUaGlzUmF3KGZuKTtcbn07XG52YXIgdW5jdXJyeVRoaXMkOSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkNiA9IGZhaWxzJDk7XG52YXIgY2xhc3NvZiQzID0gY2xhc3NvZlJhdyQyO1xudmFyICRPYmplY3QkMyA9IE9iamVjdDtcbnZhciBzcGxpdCA9IHVuY3VycnlUaGlzJDkoJycuc3BsaXQpO1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGluZGV4ZWRPYmplY3QgPSBmYWlscyQ2KGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuICEkT2JqZWN0JDMoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mJDMoaXQpID09ICdTdHJpbmcnID8gc3BsaXQoaXQsICcnKSA6ICRPYmplY3QkMyhpdCk7XG59IDogJE9iamVjdCQzO1xuXG4vLyB3ZSBjYW4ndCB1c2UganVzdCBgaXQgPT0gbnVsbGAgc2luY2Ugb2YgYGRvY3VtZW50LmFsbGAgc3BlY2lhbCBjYXNlXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLUlzSFRNTEREQS1pbnRlcm5hbC1zbG90LWFlY1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID09PSBudWxsIHx8IGl0ID09PSB1bmRlZmluZWQ7XG59O1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkJDEgPSBpc051bGxPclVuZGVmaW5lZCQyO1xudmFyICRUeXBlRXJyb3IkNSA9IFR5cGVFcnJvcjtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc051bGxPclVuZGVmaW5lZCQxKGl0KSkgdGhyb3cgJFR5cGVFcnJvciQ1KFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbi8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSW5kZXhlZE9iamVjdCQxID0gaW5kZXhlZE9iamVjdDtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDI7XG52YXIgdG9JbmRleGVkT2JqZWN0JDQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QkMShyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEoaXQpKTtcbn07XG52YXIgZG9jdW1lbnRBbGwkMiA9IHR5cGVvZiBkb2N1bWVudCA9PSAnb2JqZWN0JyAmJiBkb2N1bWVudC5hbGw7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtSXNIVE1MRERBLWludGVybmFsLXNsb3RcbnZhciBJU19IVE1MRERBID0gdHlwZW9mIGRvY3VtZW50QWxsJDIgPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnRBbGwkMiAhPT0gdW5kZWZpbmVkO1xudmFyIGRvY3VtZW50QWxsXzEgPSB7XG4gIGFsbDogZG9jdW1lbnRBbGwkMixcbiAgSVNfSFRNTEREQTogSVNfSFRNTEREQVxufTtcbnZhciAkZG9jdW1lbnRBbGwkMSA9IGRvY3VtZW50QWxsXzE7XG52YXIgZG9jdW1lbnRBbGwkMSA9ICRkb2N1bWVudEFsbCQxLmFsbDtcblxuLy8gYElzQ2FsbGFibGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXG52YXIgaXNDYWxsYWJsZSRjID0gJGRvY3VtZW50QWxsJDEuSVNfSFRNTEREQSA/IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbicgfHwgYXJndW1lbnQgPT09IGRvY3VtZW50QWxsJDE7XG59IDogZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJztcbn07XG52YXIgaXNDYWxsYWJsZSRiID0gaXNDYWxsYWJsZSRjO1xudmFyICRkb2N1bWVudEFsbCA9IGRvY3VtZW50QWxsXzE7XG52YXIgZG9jdW1lbnRBbGwgPSAkZG9jdW1lbnRBbGwuYWxsO1xudmFyIGlzT2JqZWN0JDYgPSAkZG9jdW1lbnRBbGwuSVNfSFRNTEREQSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlJGIoaXQpIHx8IGl0ID09PSBkb2N1bWVudEFsbDtcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZSRiKGl0KTtcbn07XG52YXIgZ2xvYmFsJDkgPSBnbG9iYWwkYTtcbnZhciBpc0NhbGxhYmxlJGEgPSBpc0NhbGxhYmxlJGM7XG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJGEoYXJndW1lbnQpID8gYXJndW1lbnQgOiB1bmRlZmluZWQ7XG59O1xudmFyIGdldEJ1aWx0SW4kNSA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1ldGhvZCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24oZ2xvYmFsJDlbbmFtZXNwYWNlXSkgOiBnbG9iYWwkOVtuYW1lc3BhY2VdICYmIGdsb2JhbCQ5W25hbWVzcGFjZV1bbWV0aG9kXTtcbn07XG52YXIgdW5jdXJyeVRoaXMkOCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgb2JqZWN0SXNQcm90b3R5cGVPZiA9IHVuY3VycnlUaGlzJDgoe30uaXNQcm90b3R5cGVPZik7XG52YXIgZ2V0QnVpbHRJbiQ0ID0gZ2V0QnVpbHRJbiQ1O1xudmFyIGVuZ2luZVVzZXJBZ2VudCA9IGdldEJ1aWx0SW4kNCgnbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xudmFyIGdsb2JhbCQ4ID0gZ2xvYmFsJGE7XG52YXIgdXNlckFnZW50ID0gZW5naW5lVXNlckFnZW50O1xudmFyIHByb2Nlc3MgPSBnbG9iYWwkOC5wcm9jZXNzO1xudmFyIERlbm8gPSBnbG9iYWwkOC5EZW5vO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zIHx8IERlbm8gJiYgRGVuby52ZXJzaW9uO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuICAvLyBpbiBvbGQgQ2hyb21lLCB2ZXJzaW9ucyBvZiBWOCBpc24ndCBWOCA9IENocm9tZSAvIDEwXG4gIC8vIGJ1dCB0aGVpciBjb3JyZWN0IHZlcnNpb25zIGFyZSBub3QgaW50ZXJlc3RpbmcgZm9yIHVzXG4gIHZlcnNpb24gPSBtYXRjaFswXSA+IDAgJiYgbWF0Y2hbMF0gPCA0ID8gMSA6ICsobWF0Y2hbMF0gKyBtYXRjaFsxXSk7XG59XG5cbi8vIEJyb3dzZXJGUyBOb2RlSlMgYHByb2Nlc3NgIHBvbHlmaWxsIGluY29ycmVjdGx5IHNldCBgLnY4YCB0byBgMC4wYFxuLy8gc28gY2hlY2sgYHVzZXJBZ2VudGAgZXZlbiBpZiBgLnY4YCBleGlzdHMsIGJ1dCAwXG5pZiAoIXZlcnNpb24gJiYgdXNlckFnZW50KSB7XG4gIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gK21hdGNoWzFdO1xuICB9XG59XG52YXIgZW5naW5lVjhWZXJzaW9uID0gdmVyc2lvbjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cbnZhciBWOF9WRVJTSU9OID0gZW5naW5lVjhWZXJzaW9uO1xudmFyIGZhaWxzJDUgPSBmYWlscyQ5O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIHN5bWJvbENvbnN0cnVjdG9yRGV0ZWN0aW9uID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyQ1KGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXG4gIHJldHVybiAhU3RyaW5nKHN5bWJvbCkgfHwgIShPYmplY3Qoc3ltYm9sKSBpbnN0YW5jZW9mIFN5bWJvbCkgfHxcbiAgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcbiAgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04gJiYgVjhfVkVSU0lPTiA8IDQxO1xufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG52YXIgTkFUSVZFX1NZTUJPTCQxID0gc3ltYm9sQ29uc3RydWN0b3JEZXRlY3Rpb247XG52YXIgdXNlU3ltYm9sQXNVaWQgPSBOQVRJVkVfU1lNQk9MJDEgJiYgIVN5bWJvbC5zaGFtICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG52YXIgZ2V0QnVpbHRJbiQzID0gZ2V0QnVpbHRJbiQ1O1xudmFyIGlzQ2FsbGFibGUkOSA9IGlzQ2FsbGFibGUkYztcbnZhciBpc1Byb3RvdHlwZU9mID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCQxID0gdXNlU3ltYm9sQXNVaWQ7XG52YXIgJE9iamVjdCQyID0gT2JqZWN0O1xudmFyIGlzU3ltYm9sJDIgPSBVU0VfU1lNQk9MX0FTX1VJRCQxID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciAkU3ltYm9sID0gZ2V0QnVpbHRJbiQzKCdTeW1ib2wnKTtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkOSgkU3ltYm9sKSAmJiBpc1Byb3RvdHlwZU9mKCRTeW1ib2wucHJvdG90eXBlLCAkT2JqZWN0JDIoaXQpKTtcbn07XG52YXIgJFN0cmluZyQxID0gU3RyaW5nO1xudmFyIHRyeVRvU3RyaW5nJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJFN0cmluZyQxKGFyZ3VtZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cbn07XG52YXIgaXNDYWxsYWJsZSQ4ID0gaXNDYWxsYWJsZSRjO1xudmFyIHRyeVRvU3RyaW5nID0gdHJ5VG9TdHJpbmckMTtcbnZhciAkVHlwZUVycm9yJDQgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IElzQ2FsbGFibGUoYXJndW1lbnQpIGlzIHRydWVgXG52YXIgYUNhbGxhYmxlJDIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ2FsbGFibGUkOChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ0KHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbn07XG52YXIgYUNhbGxhYmxlJDEgPSBhQ2FsbGFibGUkMjtcbnZhciBpc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkJDI7XG5cbi8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRtZXRob2RcbnZhciBnZXRNZXRob2QkMSA9IGZ1bmN0aW9uIChWLCBQKSB7XG4gIHZhciBmdW5jID0gVltQXTtcbiAgcmV0dXJuIGlzTnVsbE9yVW5kZWZpbmVkKGZ1bmMpID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlJDEoZnVuYyk7XG59O1xudmFyIGNhbGwkMiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBpc0NhbGxhYmxlJDcgPSBpc0NhbGxhYmxlJGM7XG52YXIgaXNPYmplY3QkNSA9IGlzT2JqZWN0JDY7XG52YXIgJFR5cGVFcnJvciQzID0gVHlwZUVycm9yO1xuXG4vLyBgT3JkaW5hcnlUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9yZGluYXJ5dG9wcmltaXRpdmVcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlJDEgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChwcmVmID09PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlJDcoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0JDUodmFsID0gY2FsbCQyKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAoaXNDYWxsYWJsZSQ3KGZuID0gaW5wdXQudmFsdWVPZikgJiYgIWlzT2JqZWN0JDUodmFsID0gY2FsbCQyKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAocHJlZiAhPT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZSQ3KGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCQ1KHZhbCA9IGNhbGwkMihmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgJFR5cGVFcnJvciQzKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbnZhciBzaGFyZWQkMyA9IHtcbiAgZXhwb3J0czoge31cbn07XG52YXIgZ2xvYmFsJDcgPSBnbG9iYWwkYTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkkMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQyKGdsb2JhbCQ3LCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsJDdba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgZ2xvYmFsJDYgPSBnbG9iYWwkYTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSQzID0gZ2xvYmFsJDZbU0hBUkVEXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyKFNIQVJFRCwge30pO1xudmFyIHNoYXJlZFN0b3JlID0gc3RvcmUkMztcbnZhciBzdG9yZSQyID0gc2hhcmVkU3RvcmU7XG4oc2hhcmVkJDMuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZSQyW2tleV0gfHwgKHN0b3JlJDJba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuMjUuNScsXG4gIG1vZGU6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE0LTIwMjIgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknLFxuICBsaWNlbnNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My4yNS41L0xJQ0VOU0UnLFxuICBzb3VyY2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcydcbn0pO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDI7XG52YXIgJE9iamVjdCQxID0gT2JqZWN0O1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxudmFyIHRvT2JqZWN0JDIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuICRPYmplY3QkMShyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KSk7XG59O1xudmFyIHVuY3VycnlUaGlzJDcgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvT2JqZWN0JDEgPSB0b09iamVjdCQyO1xudmFyIGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMkNyh7fS5oYXNPd25Qcm9wZXJ0eSk7XG5cbi8vIGBIYXNPd25Qcm9wZXJ0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWhhc293bnByb3BlcnR5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWhhc293biAtLSBzYWZlXG52YXIgaGFzT3duUHJvcGVydHlfMSA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5KHRvT2JqZWN0JDEoaXQpLCBrZXkpO1xufTtcbnZhciB1bmN1cnJ5VGhpcyQ2ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG52YXIgdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyQ2KDEuMC50b1N0cmluZyk7XG52YXIgdWlkJDIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyAoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgdG9TdHJpbmcoKytpZCArIHBvc3RmaXgsIDM2KTtcbn07XG52YXIgZ2xvYmFsJDUgPSBnbG9iYWwkYTtcbnZhciBzaGFyZWQkMiA9IHNoYXJlZCQzLmV4cG9ydHM7XG52YXIgaGFzT3duJDYgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHVpZCQxID0gdWlkJDI7XG52YXIgTkFUSVZFX1NZTUJPTCA9IHN5bWJvbENvbnN0cnVjdG9yRGV0ZWN0aW9uO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gdXNlU3ltYm9sQXNVaWQ7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkJDIoJ3drcycpO1xudmFyIFN5bWJvbCQxID0gZ2xvYmFsJDUuU3ltYm9sO1xudmFyIHN5bWJvbEZvciA9IFN5bWJvbCQxICYmIFN5bWJvbCQxWydmb3InXTtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbCQxIDogU3ltYm9sJDEgJiYgU3ltYm9sJDEud2l0aG91dFNldHRlciB8fCB1aWQkMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkNSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzT3duJDYoV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSAnU3ltYm9sLicgKyBuYW1lO1xuICAgIGlmIChOQVRJVkVfU1lNQk9MICYmIGhhc093biQ2KFN5bWJvbCQxLCBuYW1lKSkge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gU3ltYm9sJDFbbmFtZV07XG4gICAgfSBlbHNlIGlmIChVU0VfU1lNQk9MX0FTX1VJRCAmJiBzeW1ib2xGb3IpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IHN5bWJvbEZvcihkZXNjcmlwdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xudmFyIGNhbGwkMSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBpc09iamVjdCQ0ID0gaXNPYmplY3QkNjtcbnZhciBpc1N5bWJvbCQxID0gaXNTeW1ib2wkMjtcbnZhciBnZXRNZXRob2QgPSBnZXRNZXRob2QkMTtcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gb3JkaW5hcnlUb1ByaW1pdGl2ZSQxO1xudmFyIHdlbGxLbm93blN5bWJvbCQ0ID0gd2VsbEtub3duU3ltYm9sJDU7XG52YXIgJFR5cGVFcnJvciQyID0gVHlwZUVycm9yO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCQ0KCd0b1ByaW1pdGl2ZScpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxudmFyIHRvUHJpbWl0aXZlJDEgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgaWYgKCFpc09iamVjdCQ0KGlucHV0KSB8fCBpc1N5bWJvbCQxKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kKGlucHV0LCBUT19QUklNSVRJVkUpO1xuICB2YXIgcmVzdWx0O1xuICBpZiAoZXhvdGljVG9QcmltKSB7XG4gICAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdkZWZhdWx0JztcbiAgICByZXN1bHQgPSBjYWxsJDEoZXhvdGljVG9QcmltLCBpbnB1dCwgcHJlZik7XG4gICAgaWYgKCFpc09iamVjdCQ0KHJlc3VsdCkgfHwgaXNTeW1ib2wkMShyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHRocm93ICRUeXBlRXJyb3IkMihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbiAgfVxuICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ251bWJlcic7XG4gIHJldHVybiBvcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBwcmVmKTtcbn07XG52YXIgdG9QcmltaXRpdmUgPSB0b1ByaW1pdGl2ZSQxO1xudmFyIGlzU3ltYm9sID0gaXNTeW1ib2wkMjtcblxuLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XG52YXIgdG9Qcm9wZXJ0eUtleSQyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ3N0cmluZycpO1xuICByZXR1cm4gaXNTeW1ib2woa2V5KSA/IGtleSA6IGtleSArICcnO1xufTtcbnZhciBnbG9iYWwkNCA9IGdsb2JhbCRhO1xudmFyIGlzT2JqZWN0JDMgPSBpc09iamVjdCQ2O1xudmFyIGRvY3VtZW50JDEgPSBnbG9iYWwkNC5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyQxID0gaXNPYmplY3QkMyhkb2N1bWVudCQxKSAmJiBpc09iamVjdCQzKGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudCk7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50JDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyQxID8gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbnZhciBERVNDUklQVE9SUyQ3ID0gZGVzY3JpcHRvcnM7XG52YXIgZmFpbHMkNCA9IGZhaWxzJDk7XG52YXIgY3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxO1xuXG4vLyBUaGFua3MgdG8gSUU4IGZvciBpdHMgZnVubnkgZGVmaW5lUHJvcGVydHlcbnZhciBpZThEb21EZWZpbmUgPSAhREVTQ1JJUFRPUlMkNyAmJiAhZmFpbHMkNChmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gNztcbiAgICB9XG4gIH0pLmEgIT0gNztcbn0pO1xudmFyIERFU0NSSVBUT1JTJDYgPSBkZXNjcmlwdG9ycztcbnZhciBjYWxsID0gZnVuY3Rpb25DYWxsO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMjtcbnZhciB0b0luZGV4ZWRPYmplY3QkMyA9IHRvSW5kZXhlZE9iamVjdCQ0O1xudmFyIHRvUHJvcGVydHlLZXkkMSA9IHRvUHJvcGVydHlLZXkkMjtcbnZhciBoYXNPd24kNSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgSUU4X0RPTV9ERUZJTkUkMSA9IGllOERvbURlZmluZTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxub2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmYgPSBERVNDUklQVE9SUyQ2ID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdCQzKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQxKFApO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUkMSkgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikgey8qIGVtcHR5ICovfVxuICBpZiAoaGFzT3duJDUoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSghY2FsbChwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLCBPLCBQKSwgT1tQXSk7XG59O1xudmFyIG9iamVjdERlZmluZVByb3BlcnR5ID0ge307XG52YXIgREVTQ1JJUFRPUlMkNSA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJDMgPSBmYWlscyQ5O1xuXG4vLyBWOCB+IENocm9tZSAzNi1cbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMzMzRcbnZhciB2OFByb3RvdHlwZURlZmluZUJ1ZyA9IERFU0NSSVBUT1JTJDUgJiYgZmFpbHMkMyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7LyogZW1wdHkgKi99LCAncHJvdG90eXBlJywge1xuICAgIHZhbHVlOiA0MixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSkucHJvdG90eXBlICE9IDQyO1xufSk7XG52YXIgaXNPYmplY3QkMiA9IGlzT2JqZWN0JDY7XG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yJDEgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IFR5cGUoYXJndW1lbnQpIGlzIE9iamVjdGBcbnZhciBhbk9iamVjdCQ0ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc09iamVjdCQyKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJDEoJFN0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbn07XG52YXIgREVTQ1JJUFRPUlMkNCA9IGRlc2NyaXB0b3JzO1xudmFyIElFOF9ET01fREVGSU5FID0gaWU4RG9tRGVmaW5lO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHJDEgPSB2OFByb3RvdHlwZURlZmluZUJ1ZztcbnZhciBhbk9iamVjdCQzID0gYW5PYmplY3QkNDtcbnZhciB0b1Byb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleSQyO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcbnZhciBDT05GSUdVUkFCTEUkMSA9ICdjb25maWd1cmFibGUnO1xudmFyIFdSSVRBQkxFID0gJ3dyaXRhYmxlJztcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxub2JqZWN0RGVmaW5lUHJvcGVydHkuZiA9IERFU0NSSVBUT1JTJDQgPyBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxID8gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdCQzKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QkMyhBdHRyaWJ1dGVzKTtcbiAgaWYgKHR5cGVvZiBPID09PSAnZnVuY3Rpb24nICYmIFAgPT09ICdwcm90b3R5cGUnICYmICd2YWx1ZScgaW4gQXR0cmlidXRlcyAmJiBXUklUQUJMRSBpbiBBdHRyaWJ1dGVzICYmICFBdHRyaWJ1dGVzW1dSSVRBQkxFXSkge1xuICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50W1dSSVRBQkxFXSkge1xuICAgICAgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gICAgICBBdHRyaWJ1dGVzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IENPTkZJR1VSQUJMRSQxIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0NPTkZJR1VSQUJMRSQxXSA6IGN1cnJlbnRbQ09ORklHVVJBQkxFJDFdLFxuICAgICAgICBlbnVtZXJhYmxlOiBFTlVNRVJBQkxFIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0VOVU1FUkFCTEVdIDogY3VycmVudFtFTlVNRVJBQkxFXSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xufSA6ICRkZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QkMyhPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGFuT2JqZWN0JDMoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgey8qIGVtcHR5ICovfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyAkVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xudmFyIERFU0NSSVBUT1JTJDMgPSBkZXNjcmlwdG9ycztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDI7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDIgPSBERVNDUklQVE9SUyQzID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUkMy5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xudmFyIG1ha2VCdWlsdEluJDIgPSB7XG4gIGV4cG9ydHM6IHt9XG59O1xudmFyIERFU0NSSVBUT1JTJDIgPSBkZXNjcmlwdG9ycztcbnZhciBoYXNPd24kNCA9IGhhc093blByb3BlcnR5XzE7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0RGVzY3JpcHRvciA9IERFU0NSSVBUT1JTJDIgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBFWElTVFMgPSBoYXNPd24kNChGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKTtcbi8vIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBmcm9tIG1pbmlmaWVkIC8gbWFuZ2xlZCAvIGRyb3BwZWQgZnVuY3Rpb24gbmFtZXNcbnZhciBQUk9QRVIgPSBFWElTVFMgJiYgZnVuY3Rpb24gc29tZXRoaW5nKCkgey8qIGVtcHR5ICovfS5uYW1lID09PSAnc29tZXRoaW5nJztcbnZhciBDT05GSUdVUkFCTEUgPSBFWElTVFMgJiYgKCFERVNDUklQVE9SUyQyIHx8IERFU0NSSVBUT1JTJDIgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKS5jb25maWd1cmFibGUpO1xudmFyIGZ1bmN0aW9uTmFtZSA9IHtcbiAgRVhJU1RTOiBFWElTVFMsXG4gIFBST1BFUjogUFJPUEVSLFxuICBDT05GSUdVUkFCTEU6IENPTkZJR1VSQUJMRVxufTtcbnZhciB1bmN1cnJ5VGhpcyQ1ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc0NhbGxhYmxlJDYgPSBpc0NhbGxhYmxlJGM7XG52YXIgc3RvcmUkMSA9IHNoYXJlZFN0b3JlO1xudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyQ1KEZ1bmN0aW9uLnRvU3RyaW5nKTtcblxuLy8gdGhpcyBoZWxwZXIgYnJva2VuIGluIGBjb3JlLWpzQDMuNC4xLTMuNC40YCwgc28gd2UgY2FuJ3QgdXNlIGBzaGFyZWRgIGhlbHBlclxuaWYgKCFpc0NhbGxhYmxlJDYoc3RvcmUkMS5pbnNwZWN0U291cmNlKSkge1xuICBzdG9yZSQxLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Ub1N0cmluZyhpdCk7XG4gIH07XG59XG52YXIgaW5zcGVjdFNvdXJjZSQyID0gc3RvcmUkMS5pbnNwZWN0U291cmNlO1xudmFyIGdsb2JhbCQzID0gZ2xvYmFsJGE7XG52YXIgaXNDYWxsYWJsZSQ1ID0gaXNDYWxsYWJsZSRjO1xudmFyIFdlYWtNYXAkMSA9IGdsb2JhbCQzLldlYWtNYXA7XG52YXIgd2Vha01hcEJhc2ljRGV0ZWN0aW9uID0gaXNDYWxsYWJsZSQ1KFdlYWtNYXAkMSkgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFN0cmluZyhXZWFrTWFwJDEpKTtcbnZhciBzaGFyZWQkMSA9IHNoYXJlZCQzLmV4cG9ydHM7XG52YXIgdWlkID0gdWlkJDI7XG52YXIga2V5cyA9IHNoYXJlZCQxKCdrZXlzJyk7XG52YXIgc2hhcmVkS2V5JDIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG52YXIgaGlkZGVuS2V5cyQ0ID0ge307XG52YXIgTkFUSVZFX1dFQUtfTUFQID0gd2Vha01hcEJhc2ljRGV0ZWN0aW9uO1xudmFyIGdsb2JhbCQyID0gZ2xvYmFsJGE7XG52YXIgaXNPYmplY3QkMSA9IGlzT2JqZWN0JDY7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMjtcbnZhciBoYXNPd24kMyA9IGhhc093blByb3BlcnR5XzE7XG52YXIgc2hhcmVkID0gc2hhcmVkU3RvcmU7XG52YXIgc2hhcmVkS2V5JDEgPSBzaGFyZWRLZXkkMjtcbnZhciBoaWRkZW5LZXlzJDMgPSBoaWRkZW5LZXlzJDQ7XG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciQxID0gZ2xvYmFsJDIuVHlwZUVycm9yO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwkMi5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldChpdCkgOiBzZXQoaXQsIHt9KTtcbn07XG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcbiAgICBpZiAoIWlzT2JqZWN0JDEoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvciQxKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuaWYgKE5BVElWRV9XRUFLX01BUCB8fCBzaGFyZWQuc3RhdGUpIHtcbiAgdmFyIHN0b3JlID0gc2hhcmVkLnN0YXRlIHx8IChzaGFyZWQuc3RhdGUgPSBuZXcgV2Vha01hcCgpKTtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1hc3NpZ24gLS0gcHJvdG90eXBlIG1ldGhvZHMgcHJvdGVjdGlvbiAqL1xuICBzdG9yZS5nZXQgPSBzdG9yZS5nZXQ7XG4gIHN0b3JlLmhhcyA9IHN0b3JlLmhhcztcbiAgc3RvcmUuc2V0ID0gc3RvcmUuc2V0O1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtYXNzaWduIC0tIHByb3RvdHlwZSBtZXRob2RzIHByb3RlY3Rpb24gKi9cbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChzdG9yZS5oYXMoaXQpKSB0aHJvdyBUeXBlRXJyb3IkMShPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgc3RvcmUuc2V0KGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gc3RvcmUuZ2V0KGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHN0b3JlLmhhcyhpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkkMSgnc3RhdGUnKTtcbiAgaGlkZGVuS2V5cyQzW1NUQVRFXSA9IHRydWU7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAoaGFzT3duJDMoaXQsIFNUQVRFKSkgdGhyb3cgVHlwZUVycm9yJDEoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxKGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093biQzKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093biQzKGl0LCBTVEFURSk7XG4gIH07XG59XG52YXIgaW50ZXJuYWxTdGF0ZSA9IHtcbiAgc2V0OiBzZXQsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG52YXIgZmFpbHMkMiA9IGZhaWxzJDk7XG52YXIgaXNDYWxsYWJsZSQ0ID0gaXNDYWxsYWJsZSRjO1xudmFyIGhhc093biQyID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBERVNDUklQVE9SUyQxID0gZGVzY3JpcHRvcnM7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSBmdW5jdGlvbk5hbWUuQ09ORklHVVJBQkxFO1xudmFyIGluc3BlY3RTb3VyY2UkMSA9IGluc3BlY3RTb3VyY2UkMjtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gaW50ZXJuYWxTdGF0ZTtcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIENPTkZJR1VSQUJMRV9MRU5HVEggPSBERVNDUklQVE9SUyQxICYmICFmYWlscyQyKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5JDEoZnVuY3Rpb24gKCkgey8qIGVtcHR5ICovfSwgJ2xlbmd0aCcsIHtcbiAgICB2YWx1ZTogOFxuICB9KS5sZW5ndGggIT09IDg7XG59KTtcbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcbnZhciBtYWtlQnVpbHRJbiQxID0gbWFrZUJ1aWx0SW4kMi5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBvcHRpb25zKSB7XG4gIGlmIChTdHJpbmcobmFtZSkuc2xpY2UoMCwgNykgPT09ICdTeW1ib2woJykge1xuICAgIG5hbWUgPSAnWycgKyBTdHJpbmcobmFtZSkucmVwbGFjZSgvXlN5bWJvbFxcKChbXildKilcXCkvLCAnJDEnKSArICddJztcbiAgfVxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdldHRlcikgbmFtZSA9ICdnZXQgJyArIG5hbWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2V0dGVyKSBuYW1lID0gJ3NldCAnICsgbmFtZTtcbiAgaWYgKCFoYXNPd24kMih2YWx1ZSwgJ25hbWUnKSB8fCBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSAmJiB2YWx1ZS5uYW1lICE9PSBuYW1lKSB7XG4gICAgaWYgKERFU0NSSVBUT1JTJDEpIGRlZmluZVByb3BlcnR5JDEodmFsdWUsICduYW1lJywge1xuICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtlbHNlIHZhbHVlLm5hbWUgPSBuYW1lO1xuICB9XG4gIGlmIChDT05GSUdVUkFCTEVfTEVOR1RIICYmIG9wdGlvbnMgJiYgaGFzT3duJDIob3B0aW9ucywgJ2FyaXR5JykgJiYgdmFsdWUubGVuZ3RoICE9PSBvcHRpb25zLmFyaXR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkkMSh2YWx1ZSwgJ2xlbmd0aCcsIHtcbiAgICAgIHZhbHVlOiBvcHRpb25zLmFyaXR5XG4gICAgfSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAob3B0aW9ucyAmJiBoYXNPd24kMihvcHRpb25zLCAnY29uc3RydWN0b3InKSAmJiBvcHRpb25zLmNvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAoREVTQ1JJUFRPUlMkMSkgZGVmaW5lUHJvcGVydHkkMSh2YWx1ZSwgJ3Byb3RvdHlwZScsIHtcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIC8vIGluIFY4IH4gQ2hyb21lIDUzLCBwcm90b3R5cGVzIG9mIHNvbWUgbWV0aG9kcywgbGlrZSBgQXJyYXkucHJvdG90eXBlLnZhbHVlc2AsIGFyZSBub24td3JpdGFibGVcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnByb3RvdHlwZSkgdmFsdWUucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICB9IGNhdGNoIChlcnJvcikgey8qIGVtcHR5ICovfVxuICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSk7XG4gIGlmICghaGFzT3duJDIoc3RhdGUsICdzb3VyY2UnKSkge1xuICAgIHN0YXRlLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgPyBuYW1lIDogJycpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dGVuZC1uYXRpdmUgLS0gcmVxdWlyZWRcbkZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IG1ha2VCdWlsdEluJDEoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJDQodGhpcykgJiYgZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSQxKHRoaXMpO1xufSwgJ3RvU3RyaW5nJyk7XG52YXIgaXNDYWxsYWJsZSQzID0gaXNDYWxsYWJsZSRjO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDIgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBtYWtlQnVpbHRJbiA9IG1ha2VCdWlsdEluJDIuZXhwb3J0cztcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQxID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcbnZhciBkZWZpbmVCdWlsdEluJDEgPSBmdW5jdGlvbiAoTywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgdmFyIHNpbXBsZSA9IG9wdGlvbnMuZW51bWVyYWJsZTtcbiAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubmFtZSA6IGtleTtcbiAgaWYgKGlzQ2FsbGFibGUkMyh2YWx1ZSkpIG1ha2VCdWlsdEluKHZhbHVlLCBuYW1lLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMuZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7ZWxzZSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQxKGtleSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW9wdGlvbnMudW5zYWZlKSBkZWxldGUgT1trZXldO2Vsc2UgaWYgKE9ba2V5XSkgc2ltcGxlID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikgey8qIGVtcHR5ICovfVxuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO2Vsc2UgZGVmaW5lUHJvcGVydHlNb2R1bGUkMi5mKE8sIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6ICFvcHRpb25zLm5vbkNvbmZpZ3VyYWJsZSxcbiAgICAgIHdyaXRhYmxlOiAhb3B0aW9ucy5ub25Xcml0YWJsZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBPO1xufTtcbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzID0ge307XG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBNYXRoLnRydW5jYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWF0aC50cnVuY1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW1hdGgtdHJ1bmMgLS0gc2FmZVxudmFyIG1hdGhUcnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gdHJ1bmMoeCkge1xuICB2YXIgbiA9ICt4O1xuICByZXR1cm4gKG4gPiAwID8gZmxvb3IgOiBjZWlsKShuKTtcbn07XG52YXIgdHJ1bmMgPSBtYXRoVHJ1bmM7XG5cbi8vIGBUb0ludGVnZXJPckluZmluaXR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbnRlZ2Vyb3JpbmZpbml0eVxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgbnVtYmVyID0gK2FyZ3VtZW50O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICByZXR1cm4gbnVtYmVyICE9PSBudW1iZXIgfHwgbnVtYmVyID09PSAwID8gMCA6IHRydW5jKG51bWJlcik7XG59O1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMSA9IHRvSW50ZWdlck9ySW5maW5pdHkkMjtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4kMSA9IE1hdGgubWluO1xuXG4vLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcbi8vIExldCBpbnRlZ2VyIGJlID8gVG9JbnRlZ2VyKGluZGV4KS5cbi8vIElmIGludGVnZXIgPCAwLCBsZXQgcmVzdWx0IGJlIG1heCgobGVuZ3RoICsgaW50ZWdlciksIDApOyBlbHNlIGxldCByZXN1bHQgYmUgbWluKGludGVnZXIsIGxlbmd0aCkuXG52YXIgdG9BYnNvbHV0ZUluZGV4JDEgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlck9ySW5maW5pdHkkMShpbmRleCk7XG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heChpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbiQxKGludGVnZXIsIGxlbmd0aCk7XG59O1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSB0b0ludGVnZXJPckluZmluaXR5JDI7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG52YXIgdG9MZW5ndGgkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlck9ySW5maW5pdHkoYXJndW1lbnQpLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG52YXIgdG9MZW5ndGggPSB0b0xlbmd0aCQxO1xuXG4vLyBgTGVuZ3RoT2ZBcnJheUxpa2VgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1sZW5ndGhvZmFycmF5bGlrZVxudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDIgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b0xlbmd0aChvYmoubGVuZ3RoKTtcbn07XG52YXIgdG9JbmRleGVkT2JqZWN0JDIgPSB0b0luZGV4ZWRPYmplY3QkNDtcbnZhciB0b0Fic29sdXRlSW5kZXggPSB0b0Fic29sdXRlSW5kZXgkMTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQxID0gbGVuZ3RoT2ZBcnJheUxpa2UkMjtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QkMSA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkMigkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDEoTyk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG52YXIgYXJyYXlJbmNsdWRlcyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QkMSh0cnVlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuICBpbmRleE9mOiBjcmVhdGVNZXRob2QkMShmYWxzZSlcbn07XG52YXIgdW5jdXJyeVRoaXMkNCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaGFzT3duJDEgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHRvSW5kZXhlZE9iamVjdCQxID0gdG9JbmRleGVkT2JqZWN0JDQ7XG52YXIgaW5kZXhPZiA9IGFycmF5SW5jbHVkZXMuaW5kZXhPZjtcbnZhciBoaWRkZW5LZXlzJDIgPSBoaWRkZW5LZXlzJDQ7XG52YXIgcHVzaCQxID0gdW5jdXJyeVRoaXMkNChbXS5wdXNoKTtcbnZhciBvYmplY3RLZXlzSW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQxKG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzT3duJDEoaGlkZGVuS2V5cyQyLCBrZXkpICYmIGhhc093biQxKE8sIGtleSkgJiYgcHVzaCQxKHJlc3VsdCwga2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhc093biQxKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHB1c2gkMShyZXN1bHQsIGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xudmFyIGVudW1CdWdLZXlzJDMgPSBbJ2NvbnN0cnVjdG9yJywgJ2hhc093blByb3BlcnR5JywgJ2lzUHJvdG90eXBlT2YnLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAndG9Mb2NhbGVTdHJpbmcnLCAndG9TdHJpbmcnLCAndmFsdWVPZiddO1xudmFyIGludGVybmFsT2JqZWN0S2V5cyQxID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzJDIgPSBlbnVtQnVnS2V5cyQzO1xudmFyIGhpZGRlbktleXMkMSA9IGVudW1CdWdLZXlzJDIuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMkMShPLCBoaWRkZW5LZXlzJDEpO1xufTtcbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldEJ1aWx0SW4kMiA9IGdldEJ1aWx0SW4kNTtcbnZhciB1bmN1cnJ5VGhpcyQzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgYW5PYmplY3QkMiA9IGFuT2JqZWN0JDQ7XG52YXIgY29uY2F0ID0gdW5jdXJyeVRoaXMkMyhbXS5jb25jYXQpO1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgb3duS2V5cyQxID0gZ2V0QnVpbHRJbiQyKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0JDIoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0KGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG52YXIgaGFzT3duID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBvd25LZXlzID0gb3duS2V5cyQxO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQxID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBleGNlcHRpb25zKSB7XG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpICYmICEoZXhjZXB0aW9ucyAmJiBoYXNPd24oZXhjZXB0aW9ucywga2V5KSkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbn07XG52YXIgZmFpbHMkMSA9IGZhaWxzJDk7XG52YXIgaXNDYWxsYWJsZSQyID0gaXNDYWxsYWJsZSRjO1xudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcbnZhciBpc0ZvcmNlZCQxID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG4gIHJldHVybiB2YWx1ZSA9PSBQT0xZRklMTCA/IHRydWUgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZSA6IGlzQ2FsbGFibGUkMihkZXRlY3Rpb24pID8gZmFpbHMkMShkZXRlY3Rpb24pIDogISFkZXRlY3Rpb247XG59O1xudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkJDEubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcbnZhciBkYXRhID0gaXNGb3JjZWQkMS5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQkMS5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZCQxLlBPTFlGSUxMID0gJ1AnO1xudmFyIGlzRm9yY2VkXzEgPSBpc0ZvcmNlZCQxO1xudmFyIGdsb2JhbCQxID0gZ2xvYmFsJGE7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDI7XG52YXIgZGVmaW5lQnVpbHRJbiA9IGRlZmluZUJ1aWx0SW4kMTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMkMTtcbnZhciBpc0ZvcmNlZCA9IGlzRm9yY2VkXzE7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAgICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMuZG9udENhbGxHZXRTZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4gIG9wdGlvbnMubmFtZSAgICAgICAgICAgLSB0aGUgLm5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlmIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBrZXlcbiovXG52YXIgX2V4cG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG4gIGlmIChHTE9CQUwpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWwkMTtcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWwkMVtUQVJHRVRdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5KFRBUkdFVCwge30pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IChnbG9iYWwkMVtUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG4gIH1cbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAob3B0aW9ucy5kb250Q2FsbEdldFNldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgIC8vIGNvbnRhaW5lZCBpbiB0YXJnZXRcbiAgICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8IHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG4gICAgZGVmaW5lQnVpbHRJbih0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xudmFyIHVuY3VycnlUaGlzJDIgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGFDYWxsYWJsZSA9IGFDYWxsYWJsZSQyO1xudmFyIE5BVElWRV9CSU5EID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xudmFyIGJpbmQkMSA9IHVuY3VycnlUaGlzJDIodW5jdXJyeVRoaXMkMi5iaW5kKTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgZnVuY3Rpb25CaW5kQ29udGV4dCA9IGZ1bmN0aW9uIChmbiwgdGhhdCkge1xuICBhQ2FsbGFibGUoZm4pO1xuICByZXR1cm4gdGhhdCA9PT0gdW5kZWZpbmVkID8gZm4gOiBOQVRJVkVfQklORCA/IGJpbmQkMShmbiwgdGhhdCkgOiBmdW5jdGlvbiAvKiAuLi5hcmdzICovXG4gICgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG52YXIgY2xhc3NvZiQyID0gY2xhc3NvZlJhdyQyO1xuXG4vLyBgSXNBcnJheWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzYXJyYXlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1pc2FycmF5IC0tIHNhZmVcbnZhciBpc0FycmF5JDEgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGNsYXNzb2YkMihhcmd1bWVudCkgPT0gJ0FycmF5Jztcbn07XG52YXIgd2VsbEtub3duU3ltYm9sJDMgPSB3ZWxsS25vd25TeW1ib2wkNTtcbnZhciBUT19TVFJJTkdfVEFHJDEgPSB3ZWxsS25vd25TeW1ib2wkMygndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0ID0ge307XG50ZXN0W1RPX1NUUklOR19UQUckMV0gPSAneic7XG52YXIgdG9TdHJpbmdUYWdTdXBwb3J0ID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gdG9TdHJpbmdUYWdTdXBwb3J0O1xudmFyIGlzQ2FsbGFibGUkMSA9IGlzQ2FsbGFibGUkYztcbnZhciBjbGFzc29mUmF3ID0gY2xhc3NvZlJhdyQyO1xudmFyIHdlbGxLbm93blN5bWJvbCQyID0gd2VsbEtub3duU3ltYm9sJDU7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCQyKCd0b1N0cmluZ1RhZycpO1xudmFyICRPYmplY3QgPSBPYmplY3Q7XG5cbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cztcbn0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsvKiBlbXB0eSAqL31cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BcbnZhciBjbGFzc29mJDEgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSAkT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnXG4gIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09ICdPYmplY3QnICYmIGlzQ2FsbGFibGUkMShPLmNhbGxlZSkgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG52YXIgdW5jdXJyeVRoaXMkMSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMgPSBmYWlscyQ5O1xudmFyIGlzQ2FsbGFibGUgPSBpc0NhbGxhYmxlJGM7XG52YXIgY2xhc3NvZiA9IGNsYXNzb2YkMTtcbnZhciBnZXRCdWlsdEluJDEgPSBnZXRCdWlsdEluJDU7XG52YXIgaW5zcGVjdFNvdXJjZSA9IGluc3BlY3RTb3VyY2UkMjtcbnZhciBub29wID0gZnVuY3Rpb24gKCkgey8qIGVtcHR5ICovfTtcbnZhciBlbXB0eSA9IFtdO1xudmFyIGNvbnN0cnVjdCA9IGdldEJ1aWx0SW4kMSgnUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcbnZhciBjb25zdHJ1Y3RvclJlZ0V4cCA9IC9eXFxzKig/OmNsYXNzfGZ1bmN0aW9uKVxcYi87XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzJDEoY29uc3RydWN0b3JSZWdFeHAuZXhlYyk7XG52YXIgSU5DT1JSRUNUX1RPX1NUUklORyA9ICFjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKG5vb3ApO1xudmFyIGlzQ29uc3RydWN0b3JNb2Rlcm4gPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gIGlmICghaXNDYWxsYWJsZShhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdHJ1Y3Qobm9vcCwgZW1wdHksIGFyZ3VtZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG52YXIgaXNDb25zdHJ1Y3RvckxlZ2FjeSA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKGNsYXNzb2YoYXJndW1lbnQpKSB7XG4gICAgY2FzZSAnQXN5bmNGdW5jdGlvbic6XG4gICAgY2FzZSAnR2VuZXJhdG9yRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxuICAgIC8vIGBGdW5jdGlvbiN0b1N0cmluZ2AgdGhyb3dzIG9uIHNvbWUgYnVpbHQtaXQgZnVuY3Rpb24gaW4gc29tZSBsZWdhY3kgZW5naW5lc1xuICAgIC8vIChmb3IgZXhhbXBsZSwgYERPTVF1YWRgIGFuZCBzaW1pbGFyIGluIEZGNDEtKVxuICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyhjb25zdHJ1Y3RvclJlZ0V4cCwgaW5zcGVjdFNvdXJjZShhcmd1bWVudCkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuaXNDb25zdHJ1Y3RvckxlZ2FjeS5zaGFtID0gdHJ1ZTtcblxuLy8gYElzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NvbnN0cnVjdG9yXG52YXIgaXNDb25zdHJ1Y3RvciQxID0gIWNvbnN0cnVjdCB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsZWQ7XG4gIHJldHVybiBpc0NvbnN0cnVjdG9yTW9kZXJuKGlzQ29uc3RydWN0b3JNb2Rlcm4uY2FsbCkgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oT2JqZWN0KSB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgfSkgfHwgY2FsbGVkO1xufSkgPyBpc0NvbnN0cnVjdG9yTGVnYWN5IDogaXNDb25zdHJ1Y3Rvck1vZGVybjtcbnZhciBpc0FycmF5ID0gaXNBcnJheSQxO1xudmFyIGlzQ29uc3RydWN0b3IgPSBpc0NvbnN0cnVjdG9yJDE7XG52YXIgaXNPYmplY3QgPSBpc09iamVjdCQ2O1xudmFyIHdlbGxLbm93blN5bWJvbCQxID0gd2VsbEtub3duU3ltYm9sJDU7XG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCQxKCdzcGVjaWVzJyk7XG52YXIgJEFycmF5ID0gQXJyYXk7XG5cbi8vIGEgcGFydCBvZiBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG52YXIgYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5KSB7XG4gIHZhciBDO1xuICBpZiAoaXNBcnJheShvcmlnaW5hbEFycmF5KSkge1xuICAgIEMgPSBvcmlnaW5hbEFycmF5LmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKGlzQ29uc3RydWN0b3IoQykgJiYgKEMgPT09ICRBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7ZWxzZSBpZiAoaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgPyAkQXJyYXkgOiBDO1xufTtcbnZhciBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciA9IGFycmF5U3BlY2llc0NvbnN0cnVjdG9yJDE7XG5cbi8vIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUkMSA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoYXJyYXlTcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWxBcnJheSkpKGxlbmd0aCA9PT0gMCA/IDAgOiBsZW5ndGgpO1xufTtcbnZhciBiaW5kID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciB1bmN1cnJ5VGhpcyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgSW5kZXhlZE9iamVjdCA9IGluZGV4ZWRPYmplY3Q7XG52YXIgdG9PYmplY3QgPSB0b09iamVjdCQyO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gbGVuZ3RoT2ZBcnJheUxpa2UkMjtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSBhcnJheVNwZWNpZXNDcmVhdGUkMTtcbnZhciBwdXNoID0gdW5jdXJyeVRoaXMoW10ucHVzaCk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBmb3JFYWNoLCBtYXAsIGZpbHRlciwgc29tZSwgZXZlcnksIGZpbmQsIGZpbmRJbmRleCwgZmlsdGVyUmVqZWN0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoVFlQRSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIElTX0ZJTFRFUl9SRUpFQ1QgPSBUWVBFID09IDc7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0LCBzcGVjaWZpY0NyZWF0ZSkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2tmbiwgdGhhdCk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKHNlbGYpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNyZWF0ZSA9IHNwZWNpZmljQ3JlYXRlIHx8IGFycmF5U3BlY2llc0NyZWF0ZTtcbiAgICB2YXIgdGFyZ2V0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSIHx8IElTX0ZJTFRFUl9SRUpFQ1QgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWx1ZSwgcmVzdWx0O1xuICAgIGZvciAoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbHVlID0gc2VsZltpbmRleF07XG4gICAgICByZXN1bHQgPSBib3VuZEZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSB0YXJnZXRbaW5kZXhdID0gcmVzdWx0OyAvLyBtYXBcbiAgICAgICAgZWxzZSBpZiAocmVzdWx0KSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcHVzaCh0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAvLyBldmVyeVxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHB1c2godGFyZ2V0LCB2YWx1ZSk7XG4gICAgICAgICAgLy8gZmlsdGVyUmVqZWN0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHRhcmdldDtcbiAgfTtcbn07XG52YXIgYXJyYXlJdGVyYXRpb24gPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbiAgZm9yRWFjaDogY3JlYXRlTWV0aG9kKDApLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuICBtYXA6IGNyZWF0ZU1ldGhvZCgxKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbiAgZmlsdGVyOiBjcmVhdGVNZXRob2QoMiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcbiAgc29tZTogY3JlYXRlTWV0aG9kKDMpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZXZlcnlcbiAgZXZlcnk6IGNyZWF0ZU1ldGhvZCg0KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuICBmaW5kOiBjcmVhdGVNZXRob2QoNSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZEluZGV4XG4gIGZpbmRJbmRleDogY3JlYXRlTWV0aG9kKDYpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlclJlamVjdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFycmF5LWZpbHRlcmluZ1xuICBmaWx0ZXJSZWplY3Q6IGNyZWF0ZU1ldGhvZCg3KVxufTtcbnZhciBvYmplY3REZWZpbmVQcm9wZXJ0aWVzID0ge307XG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzJDEgPSBlbnVtQnVnS2V5cyQzO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1rZXlzIC0tIHNhZmVcbnZhciBvYmplY3RLZXlzJDEgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyQxKTtcbn07XG52YXIgREVTQ1JJUFRPUlMgPSBkZXNjcmlwdG9ycztcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IHY4UHJvdG90eXBlRGVmaW5lQnVnO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgYW5PYmplY3QkMSA9IGFuT2JqZWN0JDQ7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gdG9JbmRleGVkT2JqZWN0JDQ7XG52YXIgb2JqZWN0S2V5cyA9IG9iamVjdEtleXMkMTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydGllcyAtLSBzYWZlXG5vYmplY3REZWZpbmVQcm9wZXJ0aWVzLmYgPSBERVNDUklQVE9SUyAmJiAhVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdCQxKE8pO1xuICB2YXIgcHJvcHMgPSB0b0luZGV4ZWRPYmplY3QoUHJvcGVydGllcyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoTywga2V5ID0ga2V5c1tpbmRleCsrXSwgcHJvcHNba2V5XSk7XG4gIHJldHVybiBPO1xufTtcbnZhciBnZXRCdWlsdEluID0gZ2V0QnVpbHRJbiQ1O1xudmFyIGh0bWwkMSA9IGdldEJ1aWx0SW4oJ2RvY3VtZW50JywgJ2RvY3VtZW50RWxlbWVudCcpO1xuXG4vKiBnbG9iYWwgQWN0aXZlWE9iamVjdCAtLSBvbGQgSUUsIFdTSCAqL1xuXG52YXIgYW5PYmplY3QgPSBhbk9iamVjdCQ0O1xudmFyIGRlZmluZVByb3BlcnRpZXNNb2R1bGUgPSBvYmplY3REZWZpbmVQcm9wZXJ0aWVzO1xudmFyIGVudW1CdWdLZXlzID0gZW51bUJ1Z0tleXMkMztcbnZhciBoaWRkZW5LZXlzID0gaGlkZGVuS2V5cyQ0O1xudmFyIGh0bWwgPSBodG1sJDE7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDE7XG52YXIgc2hhcmVkS2V5ID0gc2hhcmVkS2V5JDI7XG52YXIgR1QgPSAnPic7XG52YXIgTFQgPSAnPCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsvKiBlbXB0eSAqL307XG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgYWN0aXZlWERvY3VtZW50ID0gbnVsbDsgLy8gYXZvaWQgbWVtb3J5IGxlYWtcbiAgcmV0dXJuIHRlbXA7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG59O1xuXG4vLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4vLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4vLyBhdm9pZCBJRSBHQyBidWdcbnZhciBhY3RpdmVYRG9jdW1lbnQ7XG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGFjdGl2ZVhEb2N1bWVudCA9IG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikgey8qIGlnbm9yZSAqL31cbiAgTnVsbFByb3RvT2JqZWN0ID0gdHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnID8gZG9jdW1lbnQuZG9tYWluICYmIGFjdGl2ZVhEb2N1bWVudCA/IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KSAvLyBvbGQgSUVcbiAgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKSA6IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KTsgLy8gV1NIXG4gIHZhciBsZW5ndGggPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkgZGVsZXRlIE51bGxQcm90b09iamVjdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2xlbmd0aF1dO1xuICByZXR1cm4gTnVsbFByb3RvT2JqZWN0KCk7XG59O1xuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtY3JlYXRlIC0tIHNhZmVcbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5Q29uc3RydWN0b3IoKTtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllc01vZHVsZS5mKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHdlbGxLbm93blN5bWJvbCQ1O1xudmFyIGNyZWF0ZSA9IG9iamVjdENyZWF0ZTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgVU5TQ09QQUJMRVMgPSB3ZWxsS25vd25TeW1ib2woJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuaWYgKEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHtcbiAgZGVmaW5lUHJvcGVydHkoQXJyYXlQcm90b3R5cGUsIFVOU0NPUEFCTEVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBjcmVhdGUobnVsbClcbiAgfSk7XG59XG5cbi8vIGFkZCBhIGtleSB0byBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBhZGRUb1Vuc2NvcGFibGVzJDEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG52YXIgJCA9IF9leHBvcnQ7XG52YXIgJGZpbmQgPSBhcnJheUl0ZXJhdGlvbi5maW5kO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBhZGRUb1Vuc2NvcGFibGVzJDE7XG52YXIgRklORCA9ICdmaW5kJztcbnZhciBTS0lQU19IT0xFUyA9IHRydWU7XG5cbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZiAoRklORCBpbiBbXSkgQXJyYXkoMSlbRklORF0oZnVuY3Rpb24gKCkge1xuICBTS0lQU19IT0xFUyA9IGZhbHNlO1xufSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kXG4kKHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiBTS0lQU19IT0xFU1xufSwge1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoRklORCk7XG52YXIgQ09OU1RBTlQgPSB7XG4gIEdMT0JBTDoge1xuICAgIEhJREU6ICdfX3JlYWN0X3Rvb2x0aXBfaGlkZV9ldmVudCcsXG4gICAgUkVCVUlMRDogJ19fcmVhY3RfdG9vbHRpcF9yZWJ1aWxkX2V2ZW50JyxcbiAgICBTSE9XOiAnX19yZWFjdF90b29sdGlwX3Nob3dfZXZlbnQnXG4gIH1cbn07XG5cbi8qKlxuICogU3RhdGljIG1ldGhvZHMgZm9yIHJlYWN0LXRvb2x0aXBcbiAqL1xudmFyIGRpc3BhdGNoR2xvYmFsRXZlbnQgPSBmdW5jdGlvbiBkaXNwYXRjaEdsb2JhbEV2ZW50KGV2ZW50TmFtZSwgb3B0cykge1xuICAvLyBDb21wYXRpYmxlIHdpdGggSUVcbiAgLy8gQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI2NTk2MTIzL2ludGVybmV0LWV4cGxvcmVyLTktMTAtMTEtZXZlbnQtY29uc3RydWN0b3ItZG9lc250LXdvcmtcbiAgLy8gQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvQ3VzdG9tRXZlbnRcbiAgdmFyIGV2ZW50O1xuICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50ID0gbmV3IHdpbmRvdy5DdXN0b21FdmVudChldmVudE5hbWUsIHtcbiAgICAgIGRldGFpbDogb3B0c1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KGV2ZW50TmFtZSwgZmFsc2UsIHRydWUsIG9wdHMpO1xuICB9XG4gIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn07XG5mdW5jdGlvbiBzdGF0aWNNZXRob2RzKHRhcmdldCkge1xuICAvKipcbiAgICogSGlkZSBhbGwgdG9vbHRpcFxuICAgKiBAdHJpZ2dlciBSZWFjdFRvb2x0aXAuaGlkZSgpXG4gICAqL1xuICB0YXJnZXQuaGlkZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBkaXNwYXRjaEdsb2JhbEV2ZW50KENPTlNUQU5ULkdMT0JBTC5ISURFLCB7XG4gICAgICB0YXJnZXQ6IHRhcmdldFxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWJ1aWxkIGFsbCB0b29sdGlwXG4gICAqIEB0cmlnZ2VyIFJlYWN0VG9vbHRpcC5yZWJ1aWxkKClcbiAgICovXG4gIHRhcmdldC5yZWJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgIGRpc3BhdGNoR2xvYmFsRXZlbnQoQ09OU1RBTlQuR0xPQkFMLlJFQlVJTEQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IHNwZWNpZmljIHRvb2x0aXBcbiAgICogQHRyaWdnZXIgUmVhY3RUb29sdGlwLnNob3coKVxuICAgKi9cbiAgdGFyZ2V0LnNob3cgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZGlzcGF0Y2hHbG9iYWxFdmVudChDT05TVEFOVC5HTE9CQUwuU0hPVywge1xuICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICB9KTtcbiAgfTtcbiAgdGFyZ2V0LnByb3RvdHlwZS5nbG9iYWxSZWJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm1vdW50KSB7XG4gICAgICB0aGlzLnVuYmluZExpc3RlbmVyKCk7XG4gICAgICB0aGlzLmJpbmRMaXN0ZW5lcigpO1xuICAgIH1cbiAgfTtcbiAgdGFyZ2V0LnByb3RvdHlwZS5nbG9iYWxTaG93ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMubW91bnQpIHtcbiAgICAgIHZhciBoYXNUYXJnZXQgPSBldmVudCAmJiBldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnRhcmdldCAmJiB0cnVlIHx8IGZhbHNlO1xuICAgICAgLy8gQ3JlYXRlIGEgZmFrZSBldmVudCwgc3BlY2lmaWMgc2hvdyB3aWxsIGxpbWl0IHRoZSB0eXBlIHRvIGBzb2xpZGBcbiAgICAgIC8vIG9ubHkgYGZsb2F0YCB0eXBlIGNhcmVzIGUuY2xpZW50WCBlLmNsaWVudFlcbiAgICAgIHRoaXMuc2hvd1Rvb2x0aXAoe1xuICAgICAgICBjdXJyZW50VGFyZ2V0OiBoYXNUYXJnZXQgJiYgZXZlbnQuZGV0YWlsLnRhcmdldFxuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuICB9O1xuICB0YXJnZXQucHJvdG90eXBlLmdsb2JhbEhpZGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5tb3VudCkge1xuICAgICAgdmFyIGhhc1RhcmdldCA9IGV2ZW50ICYmIGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudGFyZ2V0ICYmIHRydWUgfHwgZmFsc2U7XG4gICAgICB0aGlzLmhpZGVUb29sdGlwKHtcbiAgICAgICAgY3VycmVudFRhcmdldDogaGFzVGFyZ2V0ICYmIGV2ZW50LmRldGFpbC50YXJnZXRcbiAgICAgIH0sIGhhc1RhcmdldCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEV2ZW50cyB0aGF0IHNob3VsZCBiZSBib3VuZCB0byB0aGUgd2luZG93XG4gKi9cbmZ1bmN0aW9uIHdpbmRvd0xpc3RlbmVyKHRhcmdldCkge1xuICB0YXJnZXQucHJvdG90eXBlLmJpbmRXaW5kb3dFdmVudHMgPSBmdW5jdGlvbiAocmVzaXplSGlkZSkge1xuICAgIC8vIFJlYWN0VG9vbHRpcC5oaWRlXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoQ09OU1RBTlQuR0xPQkFMLkhJREUsIHRoaXMuZ2xvYmFsSGlkZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoQ09OU1RBTlQuR0xPQkFMLkhJREUsIHRoaXMuZ2xvYmFsSGlkZSwgZmFsc2UpO1xuXG4gICAgLy8gUmVhY3RUb29sdGlwLnJlYnVpbGRcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihDT05TVEFOVC5HTE9CQUwuUkVCVUlMRCwgdGhpcy5nbG9iYWxSZWJ1aWxkKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihDT05TVEFOVC5HTE9CQUwuUkVCVUlMRCwgdGhpcy5nbG9iYWxSZWJ1aWxkLCBmYWxzZSk7XG5cbiAgICAvLyBSZWFjdFRvb2x0aXAuc2hvd1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKENPTlNUQU5ULkdMT0JBTC5TSE9XLCB0aGlzLmdsb2JhbFNob3cpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKENPTlNUQU5ULkdMT0JBTC5TSE9XLCB0aGlzLmdsb2JhbFNob3csIGZhbHNlKTtcblxuICAgIC8vIFJlc2l6ZVxuICAgIGlmIChyZXNpemVIaWRlKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5vbldpbmRvd1Jlc2l6ZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5vbldpbmRvd1Jlc2l6ZSwgZmFsc2UpO1xuICAgIH1cbiAgfTtcbiAgdGFyZ2V0LnByb3RvdHlwZS51bmJpbmRXaW5kb3dFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoQ09OU1RBTlQuR0xPQkFMLkhJREUsIHRoaXMuZ2xvYmFsSGlkZSk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoQ09OU1RBTlQuR0xPQkFMLlJFQlVJTEQsIHRoaXMuZ2xvYmFsUmVidWlsZCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoQ09OU1RBTlQuR0xPQkFMLlNIT1csIHRoaXMuZ2xvYmFsU2hvdyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMub25XaW5kb3dSZXNpemUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBpbnZva2VkIGJ5IHJlc2l6ZSBldmVudCBvZiB3aW5kb3dcbiAgICovXG4gIHRhcmdldC5wcm90b3R5cGUub25XaW5kb3dSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLm1vdW50KSByZXR1cm47XG4gICAgdGhpcy5oaWRlVG9vbHRpcCgpO1xuICB9O1xufVxuXG4vKipcbiAqIEN1c3RvbSBldmVudHMgdG8gY29udHJvbCBzaG93aW5nIGFuZCBoaWRpbmcgb2YgdG9vbHRpcFxuICpcbiAqIEBhdHRyaWJ1dGVzXG4gKiAtIGBldmVudGAge1N0cmluZ31cbiAqIC0gYGV2ZW50T2ZmYCB7U3RyaW5nfVxuICovXG5cbnZhciBjaGVja1N0YXR1cyA9IGZ1bmN0aW9uIGNoZWNrU3RhdHVzKGRhdGFFdmVudE9mZiwgZSkge1xuICB2YXIgc2hvdyA9IHRoaXMuc3RhdGUuc2hvdztcbiAgdmFyIGlkID0gdGhpcy5wcm9wcy5pZDtcbiAgdmFyIGlzQ2FwdHVyZSA9IHRoaXMuaXNDYXB0dXJlKGUuY3VycmVudFRhcmdldCk7XG4gIHZhciBjdXJyZW50SXRlbSA9IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2N1cnJlbnRJdGVtJyk7XG4gIGlmICghaXNDYXB0dXJlKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICBpZiAoc2hvdyAmJiBjdXJyZW50SXRlbSA9PT0gJ3RydWUnKSB7XG4gICAgaWYgKCFkYXRhRXZlbnRPZmYpIHRoaXMuaGlkZVRvb2x0aXAoZSk7XG4gIH0gZWxzZSB7XG4gICAgZS5jdXJyZW50VGFyZ2V0LnNldEF0dHJpYnV0ZSgnY3VycmVudEl0ZW0nLCAndHJ1ZScpO1xuICAgIHNldFVudGFyZ2V0SXRlbXMoZS5jdXJyZW50VGFyZ2V0LCB0aGlzLmdldFRhcmdldEFycmF5KGlkKSk7XG4gICAgdGhpcy5zaG93VG9vbHRpcChlKTtcbiAgfVxufTtcbnZhciBzZXRVbnRhcmdldEl0ZW1zID0gZnVuY3Rpb24gc2V0VW50YXJnZXRJdGVtcyhjdXJyZW50VGFyZ2V0LCB0YXJnZXRBcnJheSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGN1cnJlbnRUYXJnZXQgIT09IHRhcmdldEFycmF5W2ldKSB7XG4gICAgICB0YXJnZXRBcnJheVtpXS5zZXRBdHRyaWJ1dGUoJ2N1cnJlbnRJdGVtJywgJ2ZhbHNlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldEFycmF5W2ldLnNldEF0dHJpYnV0ZSgnY3VycmVudEl0ZW0nLCAndHJ1ZScpO1xuICAgIH1cbiAgfVxufTtcbnZhciBjdXN0b21MaXN0ZW5lcnMgPSB7XG4gIGlkOiAnOWI2OWY5MmUtZDNmZS00OThiLWIxYjQtYzVlNjNhNTFiMGNmJyxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodGFyZ2V0LCBldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAodGhpcy5pZCBpbiB0YXJnZXQpIHtcbiAgICAgIHZhciBtYXAgPSB0YXJnZXRbdGhpcy5pZF07XG4gICAgICBtYXBbZXZlbnRdID0gbGlzdGVuZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoaXMgaXMgd29ya2Fyb3VuZCBmb3IgV2Vha01hcCwgd2hpY2ggaXMgbm90IHN1cHBvcnRlZCBpbiBvbGRlciBicm93c2Vycywgc3VjaCBhcyBJRVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgdGhpcy5pZCwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBfZGVmaW5lUHJvcGVydHkoe30sIGV2ZW50LCBsaXN0ZW5lcilcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBldmVudCkge1xuICAgIHZhciBtYXAgPSB0YXJnZXRbdGhpcy5pZF07XG4gICAgaWYgKG1hcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbWFwW2V2ZW50XTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBjdXN0b21FdmVudCh0YXJnZXQpIHtcbiAgdGFyZ2V0LnByb3RvdHlwZS5pc0N1c3RvbUV2ZW50ID0gZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBldmVudCA9IHRoaXMuc3RhdGUuZXZlbnQ7XG4gICAgcmV0dXJuIGV2ZW50IHx8ICEhZWxlLmdldEF0dHJpYnV0ZSgnZGF0YS1ldmVudCcpO1xuICB9O1xuXG4gIC8qIEJpbmQgbGlzdGVuZXIgZm9yIGN1c3RvbSBldmVudCAqL1xuICB0YXJnZXQucHJvdG90eXBlLmN1c3RvbUJpbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBfdGhpcyRzdGF0ZSA9IHRoaXMuc3RhdGUsXG4gICAgICBldmVudCA9IF90aGlzJHN0YXRlLmV2ZW50LFxuICAgICAgZXZlbnRPZmYgPSBfdGhpcyRzdGF0ZS5ldmVudE9mZjtcbiAgICB2YXIgZGF0YUV2ZW50ID0gZWxlLmdldEF0dHJpYnV0ZSgnZGF0YS1ldmVudCcpIHx8IGV2ZW50O1xuICAgIHZhciBkYXRhRXZlbnRPZmYgPSBlbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWV2ZW50LW9mZicpIHx8IGV2ZW50T2ZmO1xuICAgIGRhdGFFdmVudC5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBlbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY3VzdG9tTGlzdGVuZXJzLmdldChlbGUsIGV2ZW50KSk7XG4gICAgICB2YXIgY3VzdG9tTGlzdGVuZXIgPSBjaGVja1N0YXR1cy5iaW5kKF90aGlzLCBkYXRhRXZlbnRPZmYpO1xuICAgICAgY3VzdG9tTGlzdGVuZXJzLnNldChlbGUsIGV2ZW50LCBjdXN0b21MaXN0ZW5lcik7XG4gICAgICBlbGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY3VzdG9tTGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9KTtcbiAgICBpZiAoZGF0YUV2ZW50T2ZmKSB7XG4gICAgICBkYXRhRXZlbnRPZmYuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBlbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMuaGlkZVRvb2x0aXApO1xuICAgICAgICBlbGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMuaGlkZVRvb2x0aXAsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKiBVbmJpbmQgbGlzdGVuZXIgZm9yIGN1c3RvbSBldmVudCAqL1xuICB0YXJnZXQucHJvdG90eXBlLmN1c3RvbVVuYmluZExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBfdGhpcyRzdGF0ZTIgPSB0aGlzLnN0YXRlLFxuICAgICAgZXZlbnQgPSBfdGhpcyRzdGF0ZTIuZXZlbnQsXG4gICAgICBldmVudE9mZiA9IF90aGlzJHN0YXRlMi5ldmVudE9mZjtcbiAgICB2YXIgZGF0YUV2ZW50ID0gZXZlbnQgfHwgZWxlLmdldEF0dHJpYnV0ZSgnZGF0YS1ldmVudCcpO1xuICAgIHZhciBkYXRhRXZlbnRPZmYgPSBldmVudE9mZiB8fCBlbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWV2ZW50LW9mZicpO1xuICAgIGVsZS5yZW1vdmVFdmVudExpc3RlbmVyKGRhdGFFdmVudCwgY3VzdG9tTGlzdGVuZXJzLmdldChlbGUsIGV2ZW50KSk7XG4gICAgaWYgKGRhdGFFdmVudE9mZikgZWxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZGF0YUV2ZW50T2ZmLCB0aGlzLmhpZGVUb29sdGlwKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBVdGlsIG1ldGhvZCB0byBqdWRnZSBpZiBpdCBzaG91bGQgZm9sbG93IGNhcHR1cmUgbW9kZWxcbiAqL1xuXG5mdW5jdGlvbiBpc0NhcHR1cmUodGFyZ2V0KSB7XG4gIHRhcmdldC5wcm90b3R5cGUuaXNDYXB0dXJlID0gZnVuY3Rpb24gKGN1cnJlbnRUYXJnZXQpIHtcbiAgICByZXR1cm4gY3VycmVudFRhcmdldCAmJiBjdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1pc2NhcHR1cmUnKSA9PT0gJ3RydWUnIHx8IHRoaXMucHJvcHMuaXNDYXB0dXJlIHx8IGZhbHNlO1xuICB9O1xufVxuXG4vKipcbiAqIFV0aWwgbWV0aG9kIHRvIGdldCBlZmZlY3RcbiAqL1xuXG5mdW5jdGlvbiBnZXRFZmZlY3QodGFyZ2V0KSB7XG4gIHRhcmdldC5wcm90b3R5cGUuZ2V0RWZmZWN0ID0gZnVuY3Rpb24gKGN1cnJlbnRUYXJnZXQpIHtcbiAgICB2YXIgZGF0YUVmZmVjdCA9IGN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWVmZmVjdCcpO1xuICAgIHJldHVybiBkYXRhRWZmZWN0IHx8IHRoaXMucHJvcHMuZWZmZWN0IHx8ICdmbG9hdCc7XG4gIH07XG59XG5cbi8qKlxuICogVXRpbCBtZXRob2QgdG8gZ2V0IGVmZmVjdFxuICovXG52YXIgbWFrZVByb3h5ID0gZnVuY3Rpb24gbWFrZVByb3h5KGUpIHtcbiAgdmFyIHByb3h5ID0ge307XG4gIGZvciAodmFyIGtleSBpbiBlKSB7XG4gICAgaWYgKHR5cGVvZiBlW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3h5W2tleV0gPSBlW2tleV0uYmluZChlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJveHlba2V5XSA9IGVba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3h5O1xufTtcbnZhciBib2R5TGlzdGVuZXIgPSBmdW5jdGlvbiBib2R5TGlzdGVuZXIoY2FsbGJhY2ssIG9wdGlvbnMsIGUpIHtcbiAgdmFyIF9vcHRpb25zJHJlc3BlY3RFZmZlYyA9IG9wdGlvbnMucmVzcGVjdEVmZmVjdCxcbiAgICByZXNwZWN0RWZmZWN0ID0gX29wdGlvbnMkcmVzcGVjdEVmZmVjID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJlc3BlY3RFZmZlYyxcbiAgICBfb3B0aW9ucyRjdXN0b21FdmVudCA9IG9wdGlvbnMuY3VzdG9tRXZlbnQsXG4gICAgY3VzdG9tRXZlbnQgPSBfb3B0aW9ucyRjdXN0b21FdmVudCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRjdXN0b21FdmVudDtcbiAgdmFyIGlkID0gdGhpcy5wcm9wcy5pZDtcbiAgdmFyIHRpcCA9IG51bGw7XG4gIHZhciBmb3JJZDtcbiAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICB2YXIgbGFzdFRhcmdldDtcbiAgLy8gd2FsayB1cCBwYXJlbnQgY2hhaW4gdW50aWwgdGlwIGlzIGZvdW5kXG4gIC8vIHRoZXJlIGlzIG5vIG1hdGNoIGlmIHBhcmVudCB2aXNpYmxlIGFyZWEgaXMgbWF0Y2hlZCBieSBtb3VzZSBwb3NpdGlvbiwgc28gc29tZSBjb3JuZXIgY2FzZXMgbWlnaHQgbm90IHdvcmsgYXMgZXhwZWN0ZWRcbiAgd2hpbGUgKHRpcCA9PT0gbnVsbCAmJiB0YXJnZXQgIT09IG51bGwpIHtcbiAgICBsYXN0VGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRpcCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGlwJykgfHwgbnVsbDtcbiAgICBmb3JJZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZm9yJykgfHwgbnVsbDtcbiAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudDtcbiAgfVxuICB0YXJnZXQgPSBsYXN0VGFyZ2V0IHx8IGUudGFyZ2V0O1xuICBpZiAodGhpcy5pc0N1c3RvbUV2ZW50KHRhcmdldCkgJiYgIWN1c3RvbUV2ZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpc1RhcmdldEJlbG9uZ3NUb1Rvb2x0aXAgPSBpZCA9PSBudWxsICYmIGZvcklkID09IG51bGwgfHwgZm9ySWQgPT09IGlkO1xuICBpZiAodGlwICE9IG51bGwgJiYgKCFyZXNwZWN0RWZmZWN0IHx8IHRoaXMuZ2V0RWZmZWN0KHRhcmdldCkgPT09ICdmbG9hdCcpICYmIGlzVGFyZ2V0QmVsb25nc1RvVG9vbHRpcCkge1xuICAgIHZhciBwcm94eSA9IG1ha2VQcm94eShlKTtcbiAgICBwcm94eS5jdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGNhbGxiYWNrKHByb3h5KTtcbiAgfVxufTtcbnZhciBmaW5kQ3VzdG9tRXZlbnRzID0gZnVuY3Rpb24gZmluZEN1c3RvbUV2ZW50cyh0YXJnZXRBcnJheSwgZGF0YUF0dHJpYnV0ZSkge1xuICB2YXIgZXZlbnRzID0ge307XG4gIHRhcmdldEFycmF5LmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHZhciBldmVudCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoZGF0YUF0dHJpYnV0ZSk7XG4gICAgaWYgKGV2ZW50KSBldmVudC5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnRzW2V2ZW50XSA9IHRydWU7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZXZlbnRzO1xufTtcbnZhciBnZXRCb2R5ID0gZnVuY3Rpb24gZ2V0Qm9keSgpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07XG59O1xuZnVuY3Rpb24gYm9keU1vZGUodGFyZ2V0KSB7XG4gIHRhcmdldC5wcm90b3R5cGUuaXNCb2R5TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLnByb3BzLmJvZHlNb2RlO1xuICB9O1xuICB0YXJnZXQucHJvdG90eXBlLmJpbmRCb2R5TGlzdGVuZXIgPSBmdW5jdGlvbiAodGFyZ2V0QXJyYXkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBfdGhpcyRzdGF0ZSA9IHRoaXMuc3RhdGUsXG4gICAgICBldmVudCA9IF90aGlzJHN0YXRlLmV2ZW50LFxuICAgICAgZXZlbnRPZmYgPSBfdGhpcyRzdGF0ZS5ldmVudE9mZixcbiAgICAgIHBvc3NpYmxlQ3VzdG9tRXZlbnRzID0gX3RoaXMkc3RhdGUucG9zc2libGVDdXN0b21FdmVudHMsXG4gICAgICBwb3NzaWJsZUN1c3RvbUV2ZW50c09mZiA9IF90aGlzJHN0YXRlLnBvc3NpYmxlQ3VzdG9tRXZlbnRzT2ZmO1xuICAgIHZhciBib2R5ID0gZ2V0Qm9keSgpO1xuICAgIHZhciBjdXN0b21FdmVudHMgPSBmaW5kQ3VzdG9tRXZlbnRzKHRhcmdldEFycmF5LCAnZGF0YS1ldmVudCcpO1xuICAgIHZhciBjdXN0b21FdmVudHNPZmYgPSBmaW5kQ3VzdG9tRXZlbnRzKHRhcmdldEFycmF5LCAnZGF0YS1ldmVudC1vZmYnKTtcbiAgICBpZiAoZXZlbnQgIT0gbnVsbCkgY3VzdG9tRXZlbnRzW2V2ZW50XSA9IHRydWU7XG4gICAgaWYgKGV2ZW50T2ZmICE9IG51bGwpIGN1c3RvbUV2ZW50c09mZltldmVudE9mZl0gPSB0cnVlO1xuICAgIHBvc3NpYmxlQ3VzdG9tRXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBjdXN0b21FdmVudHNbZXZlbnRdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBwb3NzaWJsZUN1c3RvbUV2ZW50c09mZi5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gY3VzdG9tRXZlbnRzT2ZmW2V2ZW50XSA9IHRydWU7XG4gICAgfSk7XG4gICAgdGhpcy51bmJpbmRCb2R5TGlzdGVuZXIoYm9keSk7XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuYm9keU1vZGVMaXN0ZW5lcnMgPSB7fTtcbiAgICBpZiAoZXZlbnQgPT0gbnVsbCkge1xuICAgICAgbGlzdGVuZXJzLm1vdXNlb3ZlciA9IGJvZHlMaXN0ZW5lci5iaW5kKHRoaXMsIHRoaXMuc2hvd1Rvb2x0aXAsIHt9KTtcbiAgICAgIGxpc3RlbmVycy5tb3VzZW1vdmUgPSBib2R5TGlzdGVuZXIuYmluZCh0aGlzLCB0aGlzLnVwZGF0ZVRvb2x0aXAsIHtcbiAgICAgICAgcmVzcGVjdEVmZmVjdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBsaXN0ZW5lcnMubW91c2VvdXQgPSBib2R5TGlzdGVuZXIuYmluZCh0aGlzLCB0aGlzLmhpZGVUb29sdGlwLCB7fSk7XG4gICAgfVxuICAgIGZvciAodmFyIF9ldmVudCBpbiBjdXN0b21FdmVudHMpIHtcbiAgICAgIGxpc3RlbmVyc1tfZXZlbnRdID0gYm9keUxpc3RlbmVyLmJpbmQodGhpcywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHRhcmdldEV2ZW50T2ZmID0gZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1ldmVudC1vZmYnKSB8fCBldmVudE9mZjtcbiAgICAgICAgY2hlY2tTdGF0dXMuY2FsbChfdGhpcywgdGFyZ2V0RXZlbnRPZmYsIGUpO1xuICAgICAgfSwge1xuICAgICAgICBjdXN0b21FdmVudDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAodmFyIF9ldmVudDIgaW4gY3VzdG9tRXZlbnRzT2ZmKSB7XG4gICAgICBsaXN0ZW5lcnNbX2V2ZW50Ml0gPSBib2R5TGlzdGVuZXIuYmluZCh0aGlzLCB0aGlzLmhpZGVUb29sdGlwLCB7XG4gICAgICAgIGN1c3RvbUV2ZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2V2ZW50MyBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcihfZXZlbnQzLCBsaXN0ZW5lcnNbX2V2ZW50M10pO1xuICAgIH1cbiAgfTtcbiAgdGFyZ2V0LnByb3RvdHlwZS51bmJpbmRCb2R5TGlzdGVuZXIgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgIGJvZHkgPSBib2R5IHx8IGdldEJvZHkoKTtcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5ib2R5TW9kZUxpc3RlbmVycztcbiAgICBmb3IgKHZhciBldmVudCBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIGJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2V2ZW50XSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFRyYWNraW5nIHRhcmdldCByZW1vdmluZyBmcm9tIERPTS5cbiAqIEl0J3MgbmVjZXNzYXJ5IHRvIGhpZGUgdG9vbHRpcCB3aGVuIGl0J3MgdGFyZ2V0IGRpc2FwcGVhcnMuXG4gKiBPdGhlcndpc2UsIHRoZSB0b29sdGlwIHdvdWxkIGJlIHNob3duIGZvcmV2ZXIgdW50aWwgYW5vdGhlciB0YXJnZXRcbiAqIGlzIHRyaWdnZXJlZC5cbiAqXG4gKiBJZiBNdXRhdGlvbk9ic2VydmVyIGlzIG5vdCBhdmFpbGFibGUsIHRoaXMgZmVhdHVyZSBqdXN0IGRvZXNuJ3Qgd29yay5cbiAqL1xuXG4vLyBodHRwczovL2hhY2tzLm1vemlsbGEub3JnLzIwMTIvMDUvZG9tLW11dGF0aW9ub2JzZXJ2ZXItcmVhY3RpbmctdG8tZG9tLWNoYW5nZXMtd2l0aG91dC1raWxsaW5nLWJyb3dzZXItcGVyZm9ybWFuY2UvXG52YXIgZ2V0TXV0YXRpb25PYnNlcnZlckNsYXNzID0gZnVuY3Rpb24gZ2V0TXV0YXRpb25PYnNlcnZlckNsYXNzKCkge1xuICByZXR1cm4gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93Lk1vek11dGF0aW9uT2JzZXJ2ZXI7XG59O1xuZnVuY3Rpb24gdHJhY2tSZW1vdmFsKHRhcmdldCkge1xuICB0YXJnZXQucHJvdG90eXBlLmJpbmRSZW1vdmFsVHJhY2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBNdXRhdGlvbk9ic2VydmVyID0gZ2V0TXV0YXRpb25PYnNlcnZlckNsYXNzKCk7XG4gICAgaWYgKE11dGF0aW9uT2JzZXJ2ZXIgPT0gbnVsbCkgcmV0dXJuO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIG0xID0gMDsgbTEgPCBtdXRhdGlvbnMubGVuZ3RoOyBtMSsrKSB7XG4gICAgICAgIHZhciBtdXRhdGlvbiA9IG11dGF0aW9uc1ttMV07XG4gICAgICAgIGZvciAodmFyIG0yID0gMDsgbTIgPCBtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoOyBtMisrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSBtdXRhdGlvbi5yZW1vdmVkTm9kZXNbbTJdO1xuICAgICAgICAgIGlmIChlbGVtZW50ID09PSBfdGhpcy5zdGF0ZS5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICBfdGhpcy5oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUod2luZG93LmRvY3VtZW50LCB7XG4gICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5yZW1vdmFsVHJhY2tlciA9IG9ic2VydmVyO1xuICB9O1xuICB0YXJnZXQucHJvdG90eXBlLnVuYmluZFJlbW92YWxUcmFja2VyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnJlbW92YWxUcmFja2VyKSB7XG4gICAgICB0aGlzLnJlbW92YWxUcmFja2VyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMucmVtb3ZhbFRyYWNrZXIgPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9mIHRvb2x0aXBcbiAqXG4gKiBAcGFyYW1zXG4gKiAtIGBlYCB7RXZlbnR9IHRoZSBldmVudCBvZiBjdXJyZW50IG1vdXNlXG4gKiAtIGB0YXJnZXRgIHtFbGVtZW50fSB0aGUgY3VycmVudFRhcmdldCBvZiB0aGUgZXZlbnRcbiAqIC0gYG5vZGVgIHtET019IHRoZSByZWFjdC10b29sdGlwIG9iamVjdFxuICogLSBgcGxhY2VgIHtTdHJpbmd9IHRvcCAvIHJpZ2h0IC8gYm90dG9tIC8gbGVmdFxuICogLSBgZWZmZWN0YCB7U3RyaW5nfSBmbG9hdCAvIHNvbGlkXG4gKiAtIGBvZmZzZXRgIHtPYmplY3R9IHRoZSBvZmZzZXQgdG8gZGVmYXVsdCBwb3NpdGlvblxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIC0gYGlzTmV3U3RhdGVgIHtCb29sfSByZXF1aXJlZFxuICogLSBgbmV3U3RhdGVgIHtPYmplY3R9XG4gKiAtIGBwb3NpdGlvbmAge09iamVjdH0ge2xlZnQ6IHtOdW1iZXJ9LCB0b3A6IHtOdW1iZXJ9fVxuICovXG5mdW5jdGlvbiBnZXRQb3NpdGlvbihlLCB0YXJnZXQsIG5vZGUsIHBsYWNlLCBkZXNpcmVkUGxhY2UsIGVmZmVjdCwgb2Zmc2V0KSB7XG4gIHZhciBfZ2V0RGltZW5zaW9ucyA9IGdldERpbWVuc2lvbnMobm9kZSksXG4gICAgdGlwV2lkdGggPSBfZ2V0RGltZW5zaW9ucy53aWR0aCxcbiAgICB0aXBIZWlnaHQgPSBfZ2V0RGltZW5zaW9ucy5oZWlnaHQ7XG4gIHZhciBfZ2V0RGltZW5zaW9uczIgPSBnZXREaW1lbnNpb25zKHRhcmdldCksXG4gICAgdGFyZ2V0V2lkdGggPSBfZ2V0RGltZW5zaW9uczIud2lkdGgsXG4gICAgdGFyZ2V0SGVpZ2h0ID0gX2dldERpbWVuc2lvbnMyLmhlaWdodDtcbiAgdmFyIF9nZXRDdXJyZW50T2Zmc2V0ID0gZ2V0Q3VycmVudE9mZnNldChlLCB0YXJnZXQsIGVmZmVjdCksXG4gICAgbW91c2VYID0gX2dldEN1cnJlbnRPZmZzZXQubW91c2VYLFxuICAgIG1vdXNlWSA9IF9nZXRDdXJyZW50T2Zmc2V0Lm1vdXNlWTtcbiAgdmFyIGRlZmF1bHRPZmZzZXQgPSBnZXREZWZhdWx0UG9zaXRpb24oZWZmZWN0LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCB0aXBXaWR0aCwgdGlwSGVpZ2h0KTtcbiAgdmFyIF9jYWxjdWxhdGVPZmZzZXQgPSBjYWxjdWxhdGVPZmZzZXQob2Zmc2V0KSxcbiAgICBleHRyYU9mZnNldFggPSBfY2FsY3VsYXRlT2Zmc2V0LmV4dHJhT2Zmc2V0WCxcbiAgICBleHRyYU9mZnNldFkgPSBfY2FsY3VsYXRlT2Zmc2V0LmV4dHJhT2Zmc2V0WTtcbiAgdmFyIHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gIHZhciB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIHZhciBfZ2V0UGFyZW50ID0gZ2V0UGFyZW50KG5vZGUpLFxuICAgIHBhcmVudFRvcCA9IF9nZXRQYXJlbnQucGFyZW50VG9wLFxuICAgIHBhcmVudExlZnQgPSBfZ2V0UGFyZW50LnBhcmVudExlZnQ7XG5cbiAgLy8gR2V0IHRoZSBlZGdlIG9mZnNldCBvZiB0aGUgdG9vbHRpcFxuICB2YXIgZ2V0VGlwT2Zmc2V0TGVmdCA9IGZ1bmN0aW9uIGdldFRpcE9mZnNldExlZnQocGxhY2UpIHtcbiAgICB2YXIgb2Zmc2V0WCA9IGRlZmF1bHRPZmZzZXRbcGxhY2VdLmw7XG4gICAgcmV0dXJuIG1vdXNlWCArIG9mZnNldFggKyBleHRyYU9mZnNldFg7XG4gIH07XG4gIHZhciBnZXRUaXBPZmZzZXRSaWdodCA9IGZ1bmN0aW9uIGdldFRpcE9mZnNldFJpZ2h0KHBsYWNlKSB7XG4gICAgdmFyIG9mZnNldFggPSBkZWZhdWx0T2Zmc2V0W3BsYWNlXS5yO1xuICAgIHJldHVybiBtb3VzZVggKyBvZmZzZXRYICsgZXh0cmFPZmZzZXRYO1xuICB9O1xuICB2YXIgZ2V0VGlwT2Zmc2V0VG9wID0gZnVuY3Rpb24gZ2V0VGlwT2Zmc2V0VG9wKHBsYWNlKSB7XG4gICAgdmFyIG9mZnNldFkgPSBkZWZhdWx0T2Zmc2V0W3BsYWNlXS50O1xuICAgIHJldHVybiBtb3VzZVkgKyBvZmZzZXRZICsgZXh0cmFPZmZzZXRZO1xuICB9O1xuICB2YXIgZ2V0VGlwT2Zmc2V0Qm90dG9tID0gZnVuY3Rpb24gZ2V0VGlwT2Zmc2V0Qm90dG9tKHBsYWNlKSB7XG4gICAgdmFyIG9mZnNldFkgPSBkZWZhdWx0T2Zmc2V0W3BsYWNlXS5iO1xuICAgIHJldHVybiBtb3VzZVkgKyBvZmZzZXRZICsgZXh0cmFPZmZzZXRZO1xuICB9O1xuXG4gIC8vXG4gIC8vIEZ1bmN0aW9ucyB0byB0ZXN0IHdoZXRoZXIgdGhlIHRvb2x0aXAncyBzaWRlcyBhcmUgaW5zaWRlXG4gIC8vIHRoZSBjbGllbnQgd2luZG93IGZvciBhIGdpdmVuIG9yaWVudGF0aW9uIHBcbiAgLy9cbiAgLy8gIF9fX19fX19fX19fX19cbiAgLy8gfCAgICAgICAgICAgICB8IDwtLSBSaWdodCBzaWRlXG4gIC8vIHwgcCA9ICdsZWZ0JyAgfFxcXG4gIC8vIHwgICAgICAgICAgICAgfC8gIHxcXFxuICAvLyB8X19fX19fX19fX19fX3wgICB8X1xcICA8LS0gTW91c2VcbiAgLy8gICAgICAvIFxcICAgICAgICAgICB8XG4gIC8vICAgICAgIHxcbiAgLy8gICAgICAgfFxuICAvLyAgQm90dG9tIHNpZGVcbiAgLy9cbiAgdmFyIG91dHNpZGVMZWZ0ID0gZnVuY3Rpb24gb3V0c2lkZUxlZnQocCkge1xuICAgIHJldHVybiBnZXRUaXBPZmZzZXRMZWZ0KHApIDwgMDtcbiAgfTtcbiAgdmFyIG91dHNpZGVSaWdodCA9IGZ1bmN0aW9uIG91dHNpZGVSaWdodChwKSB7XG4gICAgcmV0dXJuIGdldFRpcE9mZnNldFJpZ2h0KHApID4gd2luZG93V2lkdGg7XG4gIH07XG4gIHZhciBvdXRzaWRlVG9wID0gZnVuY3Rpb24gb3V0c2lkZVRvcChwKSB7XG4gICAgcmV0dXJuIGdldFRpcE9mZnNldFRvcChwKSA8IDA7XG4gIH07XG4gIHZhciBvdXRzaWRlQm90dG9tID0gZnVuY3Rpb24gb3V0c2lkZUJvdHRvbShwKSB7XG4gICAgcmV0dXJuIGdldFRpcE9mZnNldEJvdHRvbShwKSA+IHdpbmRvd0hlaWdodDtcbiAgfTtcblxuICAvLyBDaGVjayB3aGV0aGVyIHRoZSB0b29sdGlwIHdpdGggb3JpZW50YXRpb24gcCBpcyBjb21wbGV0ZWx5IGluc2lkZSB0aGUgY2xpZW50IHdpbmRvd1xuICB2YXIgb3V0c2lkZSA9IGZ1bmN0aW9uIG91dHNpZGUocCkge1xuICAgIHJldHVybiBvdXRzaWRlTGVmdChwKSB8fCBvdXRzaWRlUmlnaHQocCkgfHwgb3V0c2lkZVRvcChwKSB8fCBvdXRzaWRlQm90dG9tKHApO1xuICB9O1xuICB2YXIgaW5zaWRlID0gZnVuY3Rpb24gaW5zaWRlKHApIHtcbiAgICByZXR1cm4gIW91dHNpZGUocCk7XG4gIH07XG4gIHZhciBwbGFjZUlzSW5zaWRlID0ge1xuICAgIHRvcDogaW5zaWRlKCd0b3AnKSxcbiAgICBib3R0b206IGluc2lkZSgnYm90dG9tJyksXG4gICAgbGVmdDogaW5zaWRlKCdsZWZ0JyksXG4gICAgcmlnaHQ6IGluc2lkZSgncmlnaHQnKVxuICB9O1xuICBmdW5jdGlvbiBjaG9vc2UoKSB7XG4gICAgdmFyIGFsbFBsYWNlcyA9IGRlc2lyZWRQbGFjZS5zcGxpdCgnLCcpLmNvbmNhdChwbGFjZSwgWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnXSk7XG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGFsbFBsYWNlcyksXG4gICAgICBfc3RlcDtcbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgaWYgKHBsYWNlSXNJbnNpZGVbZF0pIHJldHVybiBkO1xuICAgICAgfVxuICAgICAgLy8gaWYgbm90aGluZyBpcyBpbnNpZGUsIGp1c3QgdXNlIHRoZSBvbGQgcGxhY2UuXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IuZigpO1xuICAgIH1cbiAgICByZXR1cm4gcGxhY2U7XG4gIH1cbiAgdmFyIGNob3NlbiA9IGNob29zZSgpO1xuICB2YXIgaXNOZXdTdGF0ZSA9IGZhbHNlO1xuICB2YXIgbmV3UGxhY2U7XG4gIGlmIChjaG9zZW4gJiYgY2hvc2VuICE9PSBwbGFjZSkge1xuICAgIGlzTmV3U3RhdGUgPSB0cnVlO1xuICAgIG5ld1BsYWNlID0gY2hvc2VuO1xuICB9XG4gIGlmIChpc05ld1N0YXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTmV3U3RhdGU6IHRydWUsXG4gICAgICBuZXdTdGF0ZToge1xuICAgICAgICBwbGFjZTogbmV3UGxhY2VcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNOZXdTdGF0ZTogZmFsc2UsXG4gICAgcG9zaXRpb246IHtcbiAgICAgIGxlZnQ6IHBhcnNlSW50KGdldFRpcE9mZnNldExlZnQocGxhY2UpIC0gcGFyZW50TGVmdCwgMTApLFxuICAgICAgdG9wOiBwYXJzZUludChnZXRUaXBPZmZzZXRUb3AocGxhY2UpIC0gcGFyZW50VG9wLCAxMClcbiAgICB9XG4gIH07XG59XG52YXIgZ2V0RGltZW5zaW9ucyA9IGZ1bmN0aW9uIGdldERpbWVuc2lvbnMobm9kZSkge1xuICB2YXIgX25vZGUkZ2V0Qm91bmRpbmdDbGllID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICBoZWlnaHQgPSBfbm9kZSRnZXRCb3VuZGluZ0NsaWUuaGVpZ2h0LFxuICAgIHdpZHRoID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLndpZHRoO1xuICByZXR1cm4ge1xuICAgIGhlaWdodDogcGFyc2VJbnQoaGVpZ2h0LCAxMCksXG4gICAgd2lkdGg6IHBhcnNlSW50KHdpZHRoLCAxMClcbiAgfTtcbn07XG5cbi8vIEdldCBjdXJyZW50IG1vdXNlIG9mZnNldFxudmFyIGdldEN1cnJlbnRPZmZzZXQgPSBmdW5jdGlvbiBnZXRDdXJyZW50T2Zmc2V0KGUsIGN1cnJlbnRUYXJnZXQsIGVmZmVjdCkge1xuICB2YXIgYm91bmRpbmdDbGllbnRSZWN0ID0gY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHRhcmdldFRvcCA9IGJvdW5kaW5nQ2xpZW50UmVjdC50b3A7XG4gIHZhciB0YXJnZXRMZWZ0ID0gYm91bmRpbmdDbGllbnRSZWN0LmxlZnQ7XG4gIHZhciBfZ2V0RGltZW5zaW9uczMgPSBnZXREaW1lbnNpb25zKGN1cnJlbnRUYXJnZXQpLFxuICAgIHRhcmdldFdpZHRoID0gX2dldERpbWVuc2lvbnMzLndpZHRoLFxuICAgIHRhcmdldEhlaWdodCA9IF9nZXREaW1lbnNpb25zMy5oZWlnaHQ7XG4gIGlmIChlZmZlY3QgPT09ICdmbG9hdCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbW91c2VYOiBlLmNsaWVudFgsXG4gICAgICBtb3VzZVk6IGUuY2xpZW50WVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtb3VzZVg6IHRhcmdldExlZnQgKyB0YXJnZXRXaWR0aCAvIDIsXG4gICAgbW91c2VZOiB0YXJnZXRUb3AgKyB0YXJnZXRIZWlnaHQgLyAyXG4gIH07XG59O1xuXG4vLyBMaXN0IGFsbCBwb3NzaWJpbGl0eSBvZiB0b29sdGlwIGZpbmFsIG9mZnNldFxuLy8gVGhpcyBpcyB1c2VmdWwgaW4ganVkZ2luZyBpZiBpdCBpcyBuZWNlc3NhcnkgZm9yIHRvb2x0aXAgdG8gc3dpdGNoIHBvc2l0aW9uIHdoZW4gb3V0IG9mIHdpbmRvd1xudmFyIGdldERlZmF1bHRQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldERlZmF1bHRQb3NpdGlvbihlZmZlY3QsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIHRpcFdpZHRoLCB0aXBIZWlnaHQpIHtcbiAgdmFyIHRvcDtcbiAgdmFyIHJpZ2h0O1xuICB2YXIgYm90dG9tO1xuICB2YXIgbGVmdDtcbiAgdmFyIGRpc1RvTW91c2UgPSAzO1xuICB2YXIgdHJpYW5nbGVIZWlnaHQgPSAyO1xuICB2YXIgY3Vyc29ySGVpZ2h0ID0gMTI7IC8vIE9wdGltaXplIGZvciBmbG9hdCBib3R0b20gb25seSwgY2F1c2UgdGhlIGN1cnNvciB3aWxsIGhpZGUgdGhlIHRvb2x0aXBcblxuICBpZiAoZWZmZWN0ID09PSAnZmxvYXQnKSB7XG4gICAgdG9wID0ge1xuICAgICAgbDogLSh0aXBXaWR0aCAvIDIpLFxuICAgICAgcjogdGlwV2lkdGggLyAyLFxuICAgICAgdDogLSh0aXBIZWlnaHQgKyBkaXNUb01vdXNlICsgdHJpYW5nbGVIZWlnaHQpLFxuICAgICAgYjogLWRpc1RvTW91c2VcbiAgICB9O1xuICAgIGJvdHRvbSA9IHtcbiAgICAgIGw6IC0odGlwV2lkdGggLyAyKSxcbiAgICAgIHI6IHRpcFdpZHRoIC8gMixcbiAgICAgIHQ6IGRpc1RvTW91c2UgKyBjdXJzb3JIZWlnaHQsXG4gICAgICBiOiB0aXBIZWlnaHQgKyBkaXNUb01vdXNlICsgdHJpYW5nbGVIZWlnaHQgKyBjdXJzb3JIZWlnaHRcbiAgICB9O1xuICAgIGxlZnQgPSB7XG4gICAgICBsOiAtKHRpcFdpZHRoICsgZGlzVG9Nb3VzZSArIHRyaWFuZ2xlSGVpZ2h0KSxcbiAgICAgIHI6IC1kaXNUb01vdXNlLFxuICAgICAgdDogLSh0aXBIZWlnaHQgLyAyKSxcbiAgICAgIGI6IHRpcEhlaWdodCAvIDJcbiAgICB9O1xuICAgIHJpZ2h0ID0ge1xuICAgICAgbDogZGlzVG9Nb3VzZSxcbiAgICAgIHI6IHRpcFdpZHRoICsgZGlzVG9Nb3VzZSArIHRyaWFuZ2xlSGVpZ2h0LFxuICAgICAgdDogLSh0aXBIZWlnaHQgLyAyKSxcbiAgICAgIGI6IHRpcEhlaWdodCAvIDJcbiAgICB9O1xuICB9IGVsc2UgaWYgKGVmZmVjdCA9PT0gJ3NvbGlkJykge1xuICAgIHRvcCA9IHtcbiAgICAgIGw6IC0odGlwV2lkdGggLyAyKSxcbiAgICAgIHI6IHRpcFdpZHRoIC8gMixcbiAgICAgIHQ6IC0odGFyZ2V0SGVpZ2h0IC8gMiArIHRpcEhlaWdodCArIHRyaWFuZ2xlSGVpZ2h0KSxcbiAgICAgIGI6IC0odGFyZ2V0SGVpZ2h0IC8gMilcbiAgICB9O1xuICAgIGJvdHRvbSA9IHtcbiAgICAgIGw6IC0odGlwV2lkdGggLyAyKSxcbiAgICAgIHI6IHRpcFdpZHRoIC8gMixcbiAgICAgIHQ6IHRhcmdldEhlaWdodCAvIDIsXG4gICAgICBiOiB0YXJnZXRIZWlnaHQgLyAyICsgdGlwSGVpZ2h0ICsgdHJpYW5nbGVIZWlnaHRcbiAgICB9O1xuICAgIGxlZnQgPSB7XG4gICAgICBsOiAtKHRpcFdpZHRoICsgdGFyZ2V0V2lkdGggLyAyICsgdHJpYW5nbGVIZWlnaHQpLFxuICAgICAgcjogLSh0YXJnZXRXaWR0aCAvIDIpLFxuICAgICAgdDogLSh0aXBIZWlnaHQgLyAyKSxcbiAgICAgIGI6IHRpcEhlaWdodCAvIDJcbiAgICB9O1xuICAgIHJpZ2h0ID0ge1xuICAgICAgbDogdGFyZ2V0V2lkdGggLyAyLFxuICAgICAgcjogdGlwV2lkdGggKyB0YXJnZXRXaWR0aCAvIDIgKyB0cmlhbmdsZUhlaWdodCxcbiAgICAgIHQ6IC0odGlwSGVpZ2h0IC8gMiksXG4gICAgICBiOiB0aXBIZWlnaHQgLyAyXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvcDogdG9wLFxuICAgIGJvdHRvbTogYm90dG9tLFxuICAgIGxlZnQ6IGxlZnQsXG4gICAgcmlnaHQ6IHJpZ2h0XG4gIH07XG59O1xuXG4vLyBDb25zaWRlciBhZGRpdGlvbmFsIG9mZnNldCBpbnRvIHBvc2l0aW9uIGNhbGN1bGF0aW9uXG52YXIgY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9mZnNldCkge1xuICB2YXIgZXh0cmFPZmZzZXRYID0gMDtcbiAgdmFyIGV4dHJhT2Zmc2V0WSA9IDA7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KG9mZnNldCkgPT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgb2Zmc2V0ID0gSlNPTi5wYXJzZShvZmZzZXQudG9TdHJpbmcoKS5yZXBsYWNlKC8nL2csICdcIicpKTtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gb2Zmc2V0KSB7XG4gICAgaWYgKGtleSA9PT0gJ3RvcCcpIHtcbiAgICAgIGV4dHJhT2Zmc2V0WSAtPSBwYXJzZUludChvZmZzZXRba2V5XSwgMTApO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnYm90dG9tJykge1xuICAgICAgZXh0cmFPZmZzZXRZICs9IHBhcnNlSW50KG9mZnNldFtrZXldLCAxMCk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdsZWZ0Jykge1xuICAgICAgZXh0cmFPZmZzZXRYIC09IHBhcnNlSW50KG9mZnNldFtrZXldLCAxMCk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdyaWdodCcpIHtcbiAgICAgIGV4dHJhT2Zmc2V0WCArPSBwYXJzZUludChvZmZzZXRba2V5XSwgMTApO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGV4dHJhT2Zmc2V0WDogZXh0cmFPZmZzZXRYLFxuICAgIGV4dHJhT2Zmc2V0WTogZXh0cmFPZmZzZXRZXG4gIH07XG59O1xuXG4vLyBHZXQgdGhlIG9mZnNldCBvZiB0aGUgcGFyZW50IGVsZW1lbnRzXG52YXIgZ2V0UGFyZW50ID0gZnVuY3Rpb24gZ2V0UGFyZW50KGN1cnJlbnRUYXJnZXQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50VGFyZ2V0O1xuICB3aGlsZSAoY3VycmVudFBhcmVudCkge1xuICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY3VycmVudFBhcmVudCk7XG4gICAgLy8gdHJhbnNmb3JtIGFuZCB3aWxsLWNoYW5nZTogdHJhbnNmb3JtIGNoYW5nZSB0aGUgY29udGFpbmluZyBibG9ja1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX0Jsb2NrXG4gICAgaWYgKGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgndHJhbnNmb3JtJykgIT09ICdub25lJyB8fCBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3dpbGwtY2hhbmdlJykgPT09ICd0cmFuc2Zvcm0nKSBicmVhaztcbiAgICBjdXJyZW50UGFyZW50ID0gY3VycmVudFBhcmVudC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHZhciBwYXJlbnRUb3AgPSBjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIHx8IDA7XG4gIHZhciBwYXJlbnRMZWZ0ID0gY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgfHwgMDtcbiAgcmV0dXJuIHtcbiAgICBwYXJlbnRUb3A6IHBhcmVudFRvcCxcbiAgICBwYXJlbnRMZWZ0OiBwYXJlbnRMZWZ0XG4gIH07XG59O1xuXG4vKipcbiAqIFRvIGdldCB0aGUgdG9vbHRpcCBjb250ZW50XG4gKiBpdCBtYXkgY29tZXMgZnJvbSBkYXRhLXRpcCBvciB0aGlzLnByb3BzLmNoaWxkcmVuXG4gKiBpdCBzaG91bGQgc3VwcG9ydCBtdWx0aWxpbmVcbiAqXG4gKiBAcGFyYW1zXG4gKiAtIGB0aXBgIHtTdHJpbmd9IHZhbHVlIG9mIGRhdGEtdGlwXG4gKiAtIGBjaGlsZHJlbmAge1JlYWN0RWxlbWVudH0gdGhpcy5wcm9wcy5jaGlsZHJlblxuICogLSBgbXVsdGlsaW5lYCB7QW55fSBjb3VsZCBiZSBCb29sKHRydWUvZmFsc2UpIG9yIFN0cmluZygndHJ1ZScvJ2ZhbHNlJylcbiAqXG4gKiBAcmV0dXJuXG4gKiAtIFN0cmluZyBvciByZWFjdCBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gVGlwQ29udGVudCh0aXAsIGNoaWxkcmVuLCBnZXRDb250ZW50LCBtdWx0aWxpbmUpIHtcbiAgaWYgKGNoaWxkcmVuKSByZXR1cm4gY2hpbGRyZW47XG4gIGlmIChnZXRDb250ZW50ICE9PSB1bmRlZmluZWQgJiYgZ2V0Q29udGVudCAhPT0gbnVsbCkgcmV0dXJuIGdldENvbnRlbnQ7IC8vIGdldENvbnRlbnQgY2FuIGJlIDAsICcnLCBldGMuXG4gIGlmIChnZXRDb250ZW50ID09PSBudWxsKSByZXR1cm4gbnVsbDsgLy8gVGlwIG5vdCBleGlzdCBhbmQgY2hpbGRyZW4gaXMgbnVsbCBvciB1bmRlZmluZWRcblxuICB2YXIgcmVnZXhwID0gLzxiclxccypcXC8/Pi87XG4gIGlmICghbXVsdGlsaW5lIHx8IG11bHRpbGluZSA9PT0gJ2ZhbHNlJyB8fCAhcmVnZXhwLnRlc3QodGlwKSkge1xuICAgIC8vIE5vIHRyaW0oKSwgc28gdGhhdCB1c2VyIGNhbiBrZWVwIHRoZWlyIGlucHV0XG4gICAgcmV0dXJuIHRpcDtcbiAgfVxuXG4gIC8vIE11bHRpbGluZSB0b29sdGlwIGNvbnRlbnRcbiAgcmV0dXJuIHRpcC5zcGxpdChyZWdleHApLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAga2V5OiBpLFxuICAgICAgY2xhc3NOYW1lOiBcIm11bHRpLWxpbmVcIlxuICAgIH0sIGQpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IGFyaWEtIGFuZCByb2xlIGluIFJlYWN0VG9vbHRpcFxuICpcbiAqIEBwYXJhbXMgcHJvcHMge09iamVjdH1cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gcGFyc2VBcmlhKHByb3BzKSB7XG4gIHZhciBhcmlhT2JqID0ge307XG4gIE9iamVjdC5rZXlzKHByb3BzKS5maWx0ZXIoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAvLyBhcmlhLXh4eCBhbmQgcm9sZSBpcyBhY2NlcHRhYmxlXG4gICAgcmV0dXJuIC8oXmFyaWEtXFx3KyR8XnJvbGUkKS8udGVzdChwcm9wKTtcbiAgfSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIGFyaWFPYmpbcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgfSk7XG4gIHJldHVybiBhcmlhT2JqO1xufVxuXG4vKipcbiAqIENvbnZlcnQgbm9kZWxpc3QgdG8gYXJyYXlcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL2NvcmUvY3JlYXRlQXJyYXlGcm9tTWl4ZWQuanMjTDI0XG4gKiBOb2RlTGlzdHMgYXJlIGZ1bmN0aW9ucyBpbiBTYWZhcmlcbiAqL1xuXG5mdW5jdGlvbiBub2RlTGlzdFRvQXJyYXkobm9kZUxpc3QpIHtcbiAgdmFyIGxlbmd0aCA9IG5vZGVMaXN0Lmxlbmd0aDtcbiAgaWYgKG5vZGVMaXN0Lmhhc093blByb3BlcnR5KSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5vZGVMaXN0KTtcbiAgfVxuICByZXR1cm4gbmV3IEFycmF5KGxlbmd0aCkuZmlsbCgpLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gbm9kZUxpc3RbaW5kZXhdO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcbiAgcmV0dXJuICd0JyArIHY0KCk7XG59XG52YXIgYmFzZUNzcyA9IFwiLl9fcmVhY3RfY29tcG9uZW50X3Rvb2x0aXAge1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgZm9udC1zaXplOiAxM3B4O1xcbiAgbGVmdDogLTk5OWVtO1xcbiAgb3BhY2l0eTogMDtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzIGVhc2Utb3V0O1xcbiAgdG9wOiAtOTk5ZW07XFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICB6LWluZGV4OiA5OTk7XFxufVxcbi5fX3JlYWN0X2NvbXBvbmVudF90b29sdGlwLmFsbG93X2hvdmVyLCAuX19yZWFjdF9jb21wb25lbnRfdG9vbHRpcC5hbGxvd19jbGljayB7XFxuICBwb2ludGVyLWV2ZW50czogYXV0bztcXG59XFxuLl9fcmVhY3RfY29tcG9uZW50X3Rvb2x0aXA6OmJlZm9yZSwgLl9fcmVhY3RfY29tcG9uZW50X3Rvb2x0aXA6OmFmdGVyIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgd2lkdGg6IDA7XFxuICBoZWlnaHQ6IDA7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcbi5fX3JlYWN0X2NvbXBvbmVudF90b29sdGlwLnNob3cge1xcbiAgb3BhY2l0eTogMC45O1xcbiAgbWFyZ2luLXRvcDogMDtcXG4gIG1hcmdpbi1sZWZ0OiAwO1xcbiAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXG59XFxuLl9fcmVhY3RfY29tcG9uZW50X3Rvb2x0aXAucGxhY2UtdG9wOjpiZWZvcmUge1xcbiAgYm90dG9tOiAwO1xcbiAgbGVmdDogNTAlO1xcbiAgbWFyZ2luLWxlZnQ6IC0xMXB4O1xcbn1cXG4uX19yZWFjdF9jb21wb25lbnRfdG9vbHRpcC5wbGFjZS1ib3R0b206OmJlZm9yZSB7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiA1MCU7XFxuICBtYXJnaW4tbGVmdDogLTExcHg7XFxufVxcbi5fX3JlYWN0X2NvbXBvbmVudF90b29sdGlwLnBsYWNlLWxlZnQ6OmJlZm9yZSB7XFxuICByaWdodDogMDtcXG4gIHRvcDogNTAlO1xcbiAgbWFyZ2luLXRvcDogLTlweDtcXG59XFxuLl9fcmVhY3RfY29tcG9uZW50X3Rvb2x0aXAucGxhY2UtcmlnaHQ6OmJlZm9yZSB7XFxuICBsZWZ0OiAwO1xcbiAgdG9wOiA1MCU7XFxuICBtYXJnaW4tdG9wOiAtOXB4O1xcbn1cXG4uX19yZWFjdF9jb21wb25lbnRfdG9vbHRpcCAubXVsdGktbGluZSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHBhZGRpbmc6IDJweCAwO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cIjtcblxuLyoqXG4gKiBEZWZhdWx0IHBvcC11cCBzdHlsZSB2YWx1ZXMgKHRleHQgY29sb3IsIGJhY2tncm91bmQgY29sb3IpLlxuICovXG52YXIgZGVmYXVsdENvbG9ycyA9IHtcbiAgZGFyazoge1xuICAgIHRleHQ6ICcjZmZmJyxcbiAgICBiYWNrZ3JvdW5kOiAnIzIyMicsXG4gICAgYm9yZGVyOiAndHJhbnNwYXJlbnQnLFxuICAgIGFycm93OiAnIzIyMidcbiAgfSxcbiAgc3VjY2Vzczoge1xuICAgIHRleHQ6ICcjZmZmJyxcbiAgICBiYWNrZ3JvdW5kOiAnIzhEQzU3MicsXG4gICAgYm9yZGVyOiAndHJhbnNwYXJlbnQnLFxuICAgIGFycm93OiAnIzhEQzU3MidcbiAgfSxcbiAgd2FybmluZzoge1xuICAgIHRleHQ6ICcjZmZmJyxcbiAgICBiYWNrZ3JvdW5kOiAnI0YwQUQ0RScsXG4gICAgYm9yZGVyOiAndHJhbnNwYXJlbnQnLFxuICAgIGFycm93OiAnI0YwQUQ0RSdcbiAgfSxcbiAgZXJyb3I6IHtcbiAgICB0ZXh0OiAnI2ZmZicsXG4gICAgYmFja2dyb3VuZDogJyNCRTY0NjQnLFxuICAgIGJvcmRlcjogJ3RyYW5zcGFyZW50JyxcbiAgICBhcnJvdzogJyNCRTY0NjQnXG4gIH0sXG4gIGluZm86IHtcbiAgICB0ZXh0OiAnI2ZmZicsXG4gICAgYmFja2dyb3VuZDogJyMzMzdBQjcnLFxuICAgIGJvcmRlcjogJ3RyYW5zcGFyZW50JyxcbiAgICBhcnJvdzogJyMzMzdBQjcnXG4gIH0sXG4gIGxpZ2h0OiB7XG4gICAgdGV4dDogJyMyMjInLFxuICAgIGJhY2tncm91bmQ6ICcjZmZmJyxcbiAgICBib3JkZXI6ICd0cmFuc3BhcmVudCcsXG4gICAgYXJyb3c6ICcjZmZmJ1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFBvcHVwQ29sb3JzKHR5cGUpIHtcbiAgcmV0dXJuIGRlZmF1bHRDb2xvcnNbdHlwZV0gPyBfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdENvbG9yc1t0eXBlXSkgOiB1bmRlZmluZWQ7XG59XG52YXIgREVGQVVMVF9QQURESU5HID0gJzhweCAyMXB4JztcbnZhciBERUZBVUxUX1JBRElVUyA9IHtcbiAgdG9vbHRpcDogMyxcbiAgYXJyb3c6IDBcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBzcGVjaWZpYyB0b29sdGlwIHN0eWxlIGZvciB1c2Ugb24gcmVuZGVyLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVRvb2x0aXBTdHlsZSh1dWlkLCBjdXN0b21Db2xvcnMsIHR5cGUsIGhhc0JvcmRlciwgcGFkZGluZywgcmFkaXVzKSB7XG4gIHJldHVybiBnZW5lcmF0ZVN0eWxlKHV1aWQsIGdldFBvcHVwQ29sb3JzKGN1c3RvbUNvbG9ycywgdHlwZSwgaGFzQm9yZGVyKSwgcGFkZGluZywgcmFkaXVzKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgdGhlIHRvb2x0aXAgc3R5bGUgcnVsZXMgYmFzZWQgb24gdGhlIGVsZW1lbnQtc3BlY2lmaWVkIFwiZGF0YS10eXBlXCIgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlU3R5bGUodXVpZCwgY29sb3JzKSB7XG4gIHZhciBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBERUZBVUxUX1BBRERJTkc7XG4gIHZhciByYWRpdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IERFRkFVTFRfUkFESVVTO1xuICB2YXIgdGV4dENvbG9yID0gY29sb3JzLnRleHQ7XG4gIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcnMuYmFja2dyb3VuZDtcbiAgdmFyIGJvcmRlckNvbG9yID0gY29sb3JzLmJvcmRlcjtcbiAgdmFyIGFycm93Q29sb3IgPSBjb2xvcnMuYXJyb3c7XG4gIHZhciBhcnJvd1JhZGl1cyA9IHJhZGl1cy5hcnJvdztcbiAgdmFyIHRvb2x0aXBSYWRpdXMgPSByYWRpdXMudG9vbHRpcDtcbiAgcmV0dXJuIFwiXFxuICBcXHQuXCIuY29uY2F0KHV1aWQsIFwiIHtcXG5cXHQgICAgY29sb3I6IFwiKS5jb25jYXQodGV4dENvbG9yLCBcIjtcXG5cXHQgICAgYmFja2dyb3VuZDogXCIpLmNvbmNhdChiYWNrZ3JvdW5kQ29sb3IsIFwiO1xcblxcdCAgICBib3JkZXI6IDFweCBzb2xpZCBcIikuY29uY2F0KGJvcmRlckNvbG9yLCBcIjtcXG5cXHQgICAgYm9yZGVyLXJhZGl1czogXCIpLmNvbmNhdCh0b29sdGlwUmFkaXVzLCBcInB4O1xcblxcdCAgICBwYWRkaW5nOiBcIikuY29uY2F0KHBhZGRpbmcsIFwiO1xcbiAgXFx0fVxcblxcbiAgXFx0LlwiKS5jb25jYXQodXVpZCwgXCIucGxhY2UtdG9wIHtcXG4gICAgICAgIG1hcmdpbi10b3A6IC0xMHB4O1xcbiAgICB9XFxuICAgIC5cIikuY29uY2F0KHV1aWQsIFwiLnBsYWNlLXRvcDo6YmVmb3JlIHtcXG4gICAgICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogaW5oZXJpdDtcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIHotaW5kZXg6IDI7XFxuICAgICAgICB3aWR0aDogMjBweDtcXG4gICAgICAgIGhlaWdodDogMTJweDtcXG4gICAgfVxcbiAgICAuXCIpLmNvbmNhdCh1dWlkLCBcIi5wbGFjZS10b3A6OmFmdGVyIHtcXG4gICAgICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgd2lkdGg6IDEwcHg7XFxuICAgICAgICBoZWlnaHQ6IDEwcHg7XFxuICAgICAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogXCIpLmNvbmNhdChhcnJvd1JhZGl1cywgXCJweDtcXG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIFwiKS5jb25jYXQoYm9yZGVyQ29sb3IsIFwiO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogXCIpLmNvbmNhdChhcnJvd0NvbG9yLCBcIjtcXG4gICAgICAgIHotaW5kZXg6IC0yO1xcbiAgICAgICAgYm90dG9tOiAtNnB4O1xcbiAgICAgICAgbGVmdDogNTAlO1xcbiAgICAgICAgbWFyZ2luLWxlZnQ6IC02cHg7XFxuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxMzVkZWcpO1xcbiAgICB9XFxuXFxuICAgIC5cIikuY29uY2F0KHV1aWQsIFwiLnBsYWNlLWJvdHRvbSB7XFxuICAgICAgICBtYXJnaW4tdG9wOiAxMHB4O1xcbiAgICB9XFxuICAgIC5cIikuY29uY2F0KHV1aWQsIFwiLnBsYWNlLWJvdHRvbTo6YmVmb3JlIHtcXG4gICAgICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogaW5oZXJpdDtcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIHotaW5kZXg6IC0xO1xcbiAgICAgICAgd2lkdGg6IDE4cHg7XFxuICAgICAgICBoZWlnaHQ6IDEwcHg7XFxuICAgIH1cXG4gICAgLlwiKS5jb25jYXQodXVpZCwgXCIucGxhY2UtYm90dG9tOjphZnRlciB7XFxuICAgICAgICBjb250ZW50OiBcXFwiXFxcIjtcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIHdpZHRoOiAxMHB4O1xcbiAgICAgICAgaGVpZ2h0OiAxMHB4O1xcbiAgICAgICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IFwiKS5jb25jYXQoYXJyb3dSYWRpdXMsIFwicHg7XFxuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCBcIikuY29uY2F0KGJvcmRlckNvbG9yLCBcIjtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IFwiKS5jb25jYXQoYXJyb3dDb2xvciwgXCI7XFxuICAgICAgICB6LWluZGV4OiAtMjtcXG4gICAgICAgIHRvcDogLTZweDtcXG4gICAgICAgIGxlZnQ6IDUwJTtcXG4gICAgICAgIG1hcmdpbi1sZWZ0OiAtNnB4O1xcbiAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcbiAgICB9XFxuXFxuICAgIC5cIikuY29uY2F0KHV1aWQsIFwiLnBsYWNlLWxlZnQge1xcbiAgICAgICAgbWFyZ2luLWxlZnQ6IC0xMHB4O1xcbiAgICB9XFxuICAgIC5cIikuY29uY2F0KHV1aWQsIFwiLnBsYWNlLWxlZnQ6OmJlZm9yZSB7XFxuICAgICAgICBjb250ZW50OiBcXFwiXFxcIjtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICB6LWluZGV4OiAtMTtcXG4gICAgICAgIHdpZHRoOiAxMHB4O1xcbiAgICAgICAgaGVpZ2h0OiAxOHB4O1xcbiAgICB9XFxuICAgIC5cIikuY29uY2F0KHV1aWQsIFwiLnBsYWNlLWxlZnQ6OmFmdGVyIHtcXG4gICAgICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgd2lkdGg6IDEwcHg7XFxuICAgICAgICBoZWlnaHQ6IDEwcHg7XFxuICAgICAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogXCIpLmNvbmNhdChhcnJvd1JhZGl1cywgXCJweDtcXG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIFwiKS5jb25jYXQoYm9yZGVyQ29sb3IsIFwiO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogXCIpLmNvbmNhdChhcnJvd0NvbG9yLCBcIjtcXG4gICAgICAgIHotaW5kZXg6IC0yO1xcbiAgICAgICAgcmlnaHQ6IC02cHg7XFxuICAgICAgICB0b3A6IDUwJTtcXG4gICAgICAgIG1hcmdpbi10b3A6IC02cHg7XFxuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxuICAgIH1cXG5cXG4gICAgLlwiKS5jb25jYXQodXVpZCwgXCIucGxhY2UtcmlnaHQge1xcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDEwcHg7XFxuICAgIH1cXG4gICAgLlwiKS5jb25jYXQodXVpZCwgXCIucGxhY2UtcmlnaHQ6OmJlZm9yZSB7XFxuICAgICAgICBjb250ZW50OiBcXFwiXFxcIjtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICB6LWluZGV4OiAtMTtcXG4gICAgICAgIHdpZHRoOiAxMHB4O1xcbiAgICAgICAgaGVpZ2h0OiAxOHB4O1xcbiAgICB9XFxuICAgIC5cIikuY29uY2F0KHV1aWQsIFwiLnBsYWNlLXJpZ2h0OjphZnRlciB7XFxuICAgICAgICBjb250ZW50OiBcXFwiXFxcIjtcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIHdpZHRoOiAxMHB4O1xcbiAgICAgICAgaGVpZ2h0OiAxMHB4O1xcbiAgICAgICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IFwiKS5jb25jYXQoYXJyb3dSYWRpdXMsIFwicHg7XFxuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCBcIikuY29uY2F0KGJvcmRlckNvbG9yLCBcIjtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IFwiKS5jb25jYXQoYXJyb3dDb2xvciwgXCI7XFxuICAgICAgICB6LWluZGV4OiAtMjtcXG4gICAgICAgIGxlZnQ6IC02cHg7XFxuICAgICAgICB0b3A6IDUwJTtcXG4gICAgICAgIG1hcmdpbi10b3A6IC02cHg7XFxuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtMTM1ZGVnKTtcXG4gICAgfVxcbiAgXCIpO1xufVxuZnVuY3Rpb24gZ2V0UG9wdXBDb2xvcnMoY3VzdG9tQ29sb3JzLCB0eXBlLCBoYXNCb3JkZXIpIHtcbiAgdmFyIHRleHRDb2xvciA9IGN1c3RvbUNvbG9ycy50ZXh0O1xuICB2YXIgYmFja2dyb3VuZENvbG9yID0gY3VzdG9tQ29sb3JzLmJhY2tncm91bmQ7XG4gIHZhciBib3JkZXJDb2xvciA9IGN1c3RvbUNvbG9ycy5ib3JkZXI7XG4gIHZhciBhcnJvd0NvbG9yID0gY3VzdG9tQ29sb3JzLmFycm93ID8gY3VzdG9tQ29sb3JzLmFycm93IDogY3VzdG9tQ29sb3JzLmJhY2tncm91bmQ7XG4gIHZhciBjb2xvcnMgPSBnZXREZWZhdWx0UG9wdXBDb2xvcnModHlwZSk7XG4gIGlmICh0ZXh0Q29sb3IpIHtcbiAgICBjb2xvcnMudGV4dCA9IHRleHRDb2xvcjtcbiAgfVxuICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgY29sb3JzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gIH1cbiAgaWYgKGhhc0JvcmRlcikge1xuICAgIGlmIChib3JkZXJDb2xvcikge1xuICAgICAgY29sb3JzLmJvcmRlciA9IGJvcmRlckNvbG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2xvcnMuYm9yZGVyID0gdHlwZSA9PT0gJ2xpZ2h0JyA/ICdibGFjaycgOiAnd2hpdGUnO1xuICAgIH1cbiAgfVxuICBpZiAoYXJyb3dDb2xvcikge1xuICAgIGNvbG9ycy5hcnJvdyA9IGFycm93Q29sb3I7XG4gIH1cbiAgcmV0dXJuIGNvbG9ycztcbn1cbnZhciBfY2xhc3MsIF9jbGFzczI7XG5cbi8qIFBvbHlmaWxsICovXG52YXIgUmVhY3RUb29sdGlwID0gc3RhdGljTWV0aG9kcyhfY2xhc3MgPSB3aW5kb3dMaXN0ZW5lcihfY2xhc3MgPSBjdXN0b21FdmVudChfY2xhc3MgPSBpc0NhcHR1cmUoX2NsYXNzID0gZ2V0RWZmZWN0KF9jbGFzcyA9IGJvZHlNb2RlKF9jbGFzcyA9IHRyYWNrUmVtb3ZhbChfY2xhc3MgPSAoX2NsYXNzMiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUmVhY3RUb29sdGlwLCBfUmVhY3QkQ29tcG9uZW50KTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihSZWFjdFRvb2x0aXApO1xuICBmdW5jdGlvbiBSZWFjdFRvb2x0aXAocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlYWN0VG9vbHRpcCk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcyk7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICB1dWlkOiBwcm9wcy51dWlkIHx8IGdlbmVyYXRlVVVJRCgpLFxuICAgICAgcGxhY2U6IHByb3BzLnBsYWNlIHx8ICd0b3AnLFxuICAgICAgLy8gRGlyZWN0aW9uIG9mIHRvb2x0aXBcbiAgICAgIGRlc2lyZWRQbGFjZTogcHJvcHMucGxhY2UgfHwgJ3RvcCcsXG4gICAgICB0eXBlOiBwcm9wcy50eXBlIHx8ICdkYXJrJyxcbiAgICAgIC8vIENvbG9yIHRoZW1lIG9mIHRvb2x0aXBcbiAgICAgIGVmZmVjdDogcHJvcHMuZWZmZWN0IHx8ICdmbG9hdCcsXG4gICAgICAvLyBmbG9hdCBvciBmaXhlZFxuICAgICAgc2hvdzogZmFsc2UsXG4gICAgICBib3JkZXI6IGZhbHNlLFxuICAgICAgYm9yZGVyQ2xhc3M6ICdib3JkZXInLFxuICAgICAgY3VzdG9tQ29sb3JzOiB7fSxcbiAgICAgIGN1c3RvbVJhZGl1czoge30sXG4gICAgICBvZmZzZXQ6IHt9LFxuICAgICAgcGFkZGluZzogcHJvcHMucGFkZGluZyxcbiAgICAgIGV4dHJhQ2xhc3M6ICcnLFxuICAgICAgaHRtbDogZmFsc2UsXG4gICAgICBkZWxheUhpZGU6IDAsXG4gICAgICBkZWxheVNob3c6IDAsXG4gICAgICBldmVudDogcHJvcHMuZXZlbnQgfHwgbnVsbCxcbiAgICAgIGV2ZW50T2ZmOiBwcm9wcy5ldmVudE9mZiB8fCBudWxsLFxuICAgICAgY3VycmVudEV2ZW50OiBudWxsLFxuICAgICAgLy8gQ3VycmVudCBtb3VzZSBldmVudFxuICAgICAgY3VycmVudFRhcmdldDogbnVsbCxcbiAgICAgIC8vIEN1cnJlbnQgdGFyZ2V0IG9mIG1vdXNlIGV2ZW50XG4gICAgICBhcmlhUHJvcHM6IHBhcnNlQXJpYShwcm9wcyksXG4gICAgICAvLyBhcmlhLSBhbmQgcm9sZSBhdHRyaWJ1dGVzXG4gICAgICBpc0VtcHR5VGlwOiBmYWxzZSxcbiAgICAgIGRpc2FibGU6IGZhbHNlLFxuICAgICAgcG9zc2libGVDdXN0b21FdmVudHM6IHByb3BzLnBvc3NpYmxlQ3VzdG9tRXZlbnRzIHx8ICcnLFxuICAgICAgcG9zc2libGVDdXN0b21FdmVudHNPZmY6IHByb3BzLnBvc3NpYmxlQ3VzdG9tRXZlbnRzT2ZmIHx8ICcnLFxuICAgICAgb3JpZ2luVG9vbHRpcDogbnVsbCxcbiAgICAgIGlzTXVsdGlsaW5lOiBmYWxzZVxuICAgIH07XG4gICAgX3RoaXMuYmluZChbJ3Nob3dUb29sdGlwJywgJ3VwZGF0ZVRvb2x0aXAnLCAnaGlkZVRvb2x0aXAnLCAnaGlkZVRvb2x0aXBPblNjcm9sbCcsICdnZXRUb29sdGlwQ29udGVudCcsICdnbG9iYWxSZWJ1aWxkJywgJ2dsb2JhbFNob3cnLCAnZ2xvYmFsSGlkZScsICdvbldpbmRvd1Jlc2l6ZScsICdtb3VzZU9uVG9vbFRpcCddKTtcbiAgICBfdGhpcy5tb3VudCA9IHRydWU7XG4gICAgX3RoaXMuZGVsYXlTaG93TG9vcCA9IG51bGw7XG4gICAgX3RoaXMuZGVsYXlIaWRlTG9vcCA9IG51bGw7XG4gICAgX3RoaXMuZGVsYXlSZXNob3cgPSBudWxsO1xuICAgIF90aGlzLmludGVydmFsVXBkYXRlQ29udGVudCA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciB1bmlmeSB0aGUgYmluZCBhbmQgdW5iaW5kIGxpc3RlbmVyXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoUmVhY3RUb29sdGlwLCBbe1xuICAgIGtleTogXCJiaW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmQobWV0aG9kQXJyYXkpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgbWV0aG9kQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIF90aGlzMlttZXRob2RdID0gX3RoaXMyW21ldGhvZF0uYmluZChfdGhpczIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIF90aGlzJHByb3BzLmluc2VjdXJlO1xuICAgICAgdmFyIHJlc2l6ZUhpZGUgPSBfdGhpcyRwcm9wcy5yZXNpemVIaWRlLFxuICAgICAgICBkaXNhYmxlSW50ZXJuYWxTdHlsZSA9IF90aGlzJHByb3BzLmRpc2FibGVJbnRlcm5hbFN0eWxlO1xuICAgICAgdGhpcy5tb3VudCA9IHRydWU7XG4gICAgICB0aGlzLmJpbmRMaXN0ZW5lcigpOyAvLyBCaW5kIGxpc3RlbmVyIGZvciB0b29sdGlwXG4gICAgICB0aGlzLmJpbmRXaW5kb3dFdmVudHMocmVzaXplSGlkZSk7IC8vIEJpbmQgZ2xvYmFsIGV2ZW50IGZvciBzdGF0aWMgbWV0aG9kXG5cbiAgICAgIGlmICghZGlzYWJsZUludGVybmFsU3R5bGUpIHtcbiAgICAgICAgdGhpcy5pbmplY3RTdHlsZXMoKTsgLy8gSW5qZWN0IHN0eWxlcyBmb3IgZWFjaCBET00gcm9vdCBoYXZpbmcgdG9vbHRpcC5cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB0aGlzLm1vdW50ID0gZmFsc2U7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIHRoaXMudW5iaW5kTGlzdGVuZXIoKTtcbiAgICAgIHRoaXMucmVtb3ZlU2Nyb2xsTGlzdGVuZXIodGhpcy5zdGF0ZS5jdXJyZW50VGFyZ2V0KTtcbiAgICAgIHRoaXMudW5iaW5kV2luZG93RXZlbnRzKCk7XG4gICAgfVxuXG4gICAgLyogTG9vayBmb3IgdGhlIGNsb3Nlc3QgRE9NIHJvb3QgaGF2aW5nIHRvb2x0aXAgYW5kIGluamVjdCBzdHlsZXMuICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5qZWN0U3R5bGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluamVjdFN0eWxlcygpIHtcbiAgICAgIHZhciB0b29sdGlwUmVmID0gdGhpcy50b29sdGlwUmVmO1xuICAgICAgaWYgKCF0b29sdGlwUmVmKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJlbnROb2RlID0gdG9vbHRpcFJlZi5wYXJlbnROb2RlO1xuICAgICAgd2hpbGUgKHBhcmVudE5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgdmFyIGRvbVJvb3Q7XG4gICAgICBzd2l0Y2ggKHBhcmVudE5vZGUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgICBjYXNlICdEb2N1bWVudCc6XG4gICAgICAgIGNhc2UgJ0hUTUxEb2N1bWVudCc6XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgIGRvbVJvb3QgPSBwYXJlbnROb2RlLmhlYWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1NoYWRvd1Jvb3QnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRvbVJvb3QgPSBwYXJlbnROb2RlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmV2ZW50IHN0eWxlcyBkdXBsaWNhdGlvbi5cbiAgICAgIGlmICghZG9tUm9vdC5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLXJlYWN0LXRvb2x0aXBdJykpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBiYXNlQ3NzO1xuICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtcmVhY3QtdG9vbHRpcCcsICd0cnVlJyk7XG4gICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBpZiB0aGUgbW91c2UgaXMgb24gdGhlIHRvb2x0aXAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgLSBtb3VzZSBpcyBvbiB0aGUgdG9vbHRpcFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm1vdXNlT25Ub29sVGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNlT25Ub29sVGlwKCkge1xuICAgICAgdmFyIHNob3cgPSB0aGlzLnN0YXRlLnNob3c7XG4gICAgICBpZiAoc2hvdyAmJiB0aGlzLnRvb2x0aXBSZWYpIHtcbiAgICAgICAgLyogb2xkIElFIG9yIEZpcmVmb3ggd29yayBhcm91bmQgKi9cbiAgICAgICAgaWYgKCF0aGlzLnRvb2x0aXBSZWYubWF0Y2hlcykge1xuICAgICAgICAgIC8qIG9sZCBJRSB3b3JrIGFyb3VuZCAqL1xuICAgICAgICAgIGlmICh0aGlzLnRvb2x0aXBSZWYubXNNYXRjaGVzU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcFJlZi5tYXRjaGVzID0gdGhpcy50b29sdGlwUmVmLm1zTWF0Y2hlc1NlbGVjdG9yO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBvbGQgRmlyZWZveCB3b3JrIGFyb3VuZCAqL1xuICAgICAgICAgICAgdGhpcy50b29sdGlwUmVmLm1hdGNoZXMgPSB0aGlzLnRvb2x0aXBSZWYubW96TWF0Y2hlc1NlbGVjdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50b29sdGlwUmVmLm1hdGNoZXMoJzpob3ZlcicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBpY2sgb3V0IGNvcnJlc3BvbmRlZCB0YXJnZXQgZWxlbWVudHNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRUYXJnZXRBcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUYXJnZXRBcnJheShpZCkge1xuICAgICAgdmFyIHRhcmdldEFycmF5ID0gW107XG4gICAgICB2YXIgc2VsZWN0b3I7XG4gICAgICBpZiAoIWlkKSB7XG4gICAgICAgIHNlbGVjdG9yID0gJ1tkYXRhLXRpcF06bm90KFtkYXRhLWZvcl0pJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlc2NhcGVkID0gaWQucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJyk7XG4gICAgICAgIHNlbGVjdG9yID0gXCJbZGF0YS10aXBdW2RhdGEtZm9yPVxcXCJcIi5jb25jYXQoZXNjYXBlZCwgXCJcXFwiXVwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2NhbiBkb2N1bWVudCBmb3Igc2hhZG93IERPTSBlbGVtZW50c1xuICAgICAgbm9kZUxpc3RUb0FycmF5KGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykpLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB0YXJnZXRBcnJheSA9IHRhcmdldEFycmF5LmNvbmNhdChub2RlTGlzdFRvQXJyYXkoZWxlbWVudC5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0YXJnZXRBcnJheS5jb25jYXQobm9kZUxpc3RUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmluZCBsaXN0ZW5lciB0byB0aGUgdGFyZ2V0IGVsZW1lbnRzXG4gICAgICogVGhlc2UgbGlzdGVuZXJzIHVzZWQgdG8gdHJpZ2dlciBzaG93aW5nIG9yIGhpZGluZyB0aGUgdG9vbHRpcFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImJpbmRMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kTGlzdGVuZXIoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBpZCA9IF90aGlzJHByb3BzMi5pZCxcbiAgICAgICAgZ2xvYmFsRXZlbnRPZmYgPSBfdGhpcyRwcm9wczIuZ2xvYmFsRXZlbnRPZmYsXG4gICAgICAgIGlzQ2FwdHVyZSA9IF90aGlzJHByb3BzMi5pc0NhcHR1cmU7XG4gICAgICB2YXIgdGFyZ2V0QXJyYXkgPSB0aGlzLmdldFRhcmdldEFycmF5KGlkKTtcbiAgICAgIHRhcmdldEFycmF5LmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0LmdldEF0dHJpYnV0ZSgnY3VycmVudEl0ZW0nKSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoJ2N1cnJlbnRJdGVtJywgJ2ZhbHNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMzLnVuYmluZEJhc2ljTGlzdGVuZXIodGFyZ2V0KTtcbiAgICAgICAgaWYgKF90aGlzMy5pc0N1c3RvbUV2ZW50KHRhcmdldCkpIHtcbiAgICAgICAgICBfdGhpczMuY3VzdG9tVW5iaW5kTGlzdGVuZXIodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5pc0JvZHlNb2RlKCkpIHtcbiAgICAgICAgdGhpcy5iaW5kQm9keUxpc3RlbmVyKHRhcmdldEFycmF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldEFycmF5LmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgIHZhciBpc0NhcHR1cmVNb2RlID0gX3RoaXMzLmlzQ2FwdHVyZSh0YXJnZXQpO1xuICAgICAgICAgIHZhciBlZmZlY3QgPSBfdGhpczMuZ2V0RWZmZWN0KHRhcmdldCk7XG4gICAgICAgICAgaWYgKF90aGlzMy5pc0N1c3RvbUV2ZW50KHRhcmdldCkpIHtcbiAgICAgICAgICAgIF90aGlzMy5jdXN0b21CaW5kTGlzdGVuZXIodGFyZ2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBfdGhpczMuc2hvd1Rvb2x0aXAsIGlzQ2FwdHVyZU1vZGUpO1xuICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIF90aGlzMy5zaG93VG9vbHRpcCwgaXNDYXB0dXJlTW9kZSk7XG4gICAgICAgICAgaWYgKGVmZmVjdCA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF90aGlzMy51cGRhdGVUb29sdGlwLCBpc0NhcHR1cmVNb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBfdGhpczMuaGlkZVRvb2x0aXAsIGlzQ2FwdHVyZU1vZGUpO1xuICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgX3RoaXMzLmhpZGVUb29sdGlwLCBpc0NhcHR1cmVNb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdsb2JhbCBldmVudCB0byBoaWRlIHRvb2x0aXBcbiAgICAgIGlmIChnbG9iYWxFdmVudE9mZikge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihnbG9iYWxFdmVudE9mZiwgdGhpcy5oaWRlVG9vbHRpcCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGdsb2JhbEV2ZW50T2ZmLCB0aGlzLmhpZGVUb29sdGlwLCBpc0NhcHR1cmUpO1xuICAgICAgfVxuXG4gICAgICAvLyBUcmFjayByZW1vdmFsIG9mIHRhcmdldEFycmF5IGVsZW1lbnRzIGZyb20gRE9NXG4gICAgICB0aGlzLmJpbmRSZW1vdmFsVHJhY2tlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVuYmluZCBsaXN0ZW5lcnMgb24gdGFyZ2V0IGVsZW1lbnRzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidW5iaW5kTGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kTGlzdGVuZXIoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICBpZCA9IF90aGlzJHByb3BzMy5pZCxcbiAgICAgICAgZ2xvYmFsRXZlbnRPZmYgPSBfdGhpcyRwcm9wczMuZ2xvYmFsRXZlbnRPZmY7XG4gICAgICBpZiAodGhpcy5pc0JvZHlNb2RlKCkpIHtcbiAgICAgICAgdGhpcy51bmJpbmRCb2R5TGlzdGVuZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0YXJnZXRBcnJheSA9IHRoaXMuZ2V0VGFyZ2V0QXJyYXkoaWQpO1xuICAgICAgICB0YXJnZXRBcnJheS5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICBfdGhpczQudW5iaW5kQmFzaWNMaXN0ZW5lcih0YXJnZXQpO1xuICAgICAgICAgIGlmIChfdGhpczQuaXNDdXN0b21FdmVudCh0YXJnZXQpKSBfdGhpczQuY3VzdG9tVW5iaW5kTGlzdGVuZXIodGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoZ2xvYmFsRXZlbnRPZmYpIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGdsb2JhbEV2ZW50T2ZmLCB0aGlzLmhpZGVUb29sdGlwKTtcbiAgICAgIHRoaXMudW5iaW5kUmVtb3ZhbFRyYWNrZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2UgdGhpcyBiZWZvcmUgYmluZCBsaXN0ZW5lciBhbmQgdW5tb3VudCB0aGUgY29tcG9uZW50XG4gICAgICogaXQgaXMgbmVjZXNzYXJ5IHRvIGludm9rZSB0aGlzIGV2ZW4gd2hlbiBiaW5kaW5nIGN1c3RvbSBldmVudFxuICAgICAqIHNvIHRoYXQgdGhlIHRvb2x0aXAgY2FuIHN3aXRjaCBiZXR3ZWVuIGN1c3RvbSBhbmQgZGVmYXVsdCBsaXN0ZW5lclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVuYmluZEJhc2ljTGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kQmFzaWNMaXN0ZW5lcih0YXJnZXQpIHtcbiAgICAgIHZhciBpc0NhcHR1cmVNb2RlID0gdGhpcy5pc0NhcHR1cmUodGFyZ2V0KTtcbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5zaG93VG9vbHRpcCwgaXNDYXB0dXJlTW9kZSk7XG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy51cGRhdGVUb29sdGlwLCBpc0NhcHR1cmVNb2RlKTtcbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5oaWRlVG9vbHRpcCwgaXNDYXB0dXJlTW9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRvb2x0aXBDb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRvb2x0aXBDb250ZW50KCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IHRoaXMucHJvcHMsXG4gICAgICAgIGdldENvbnRlbnQgPSBfdGhpcyRwcm9wczQuZ2V0Q29udGVudCxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczQuY2hpbGRyZW47XG5cbiAgICAgIC8vIEdlbmVyYXRlIHRvb2x0aXAgY29udGVudFxuICAgICAgdmFyIGNvbnRlbnQ7XG4gICAgICBpZiAoZ2V0Q29udGVudCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShnZXRDb250ZW50KSkge1xuICAgICAgICAgIGNvbnRlbnQgPSBnZXRDb250ZW50WzBdICYmIGdldENvbnRlbnRbMF0odGhpcy5zdGF0ZS5vcmlnaW5Ub29sdGlwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZW50ID0gZ2V0Q29udGVudCh0aGlzLnN0YXRlLm9yaWdpblRvb2x0aXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gVGlwQ29udGVudCh0aGlzLnN0YXRlLm9yaWdpblRvb2x0aXAsIGNoaWxkcmVuLCBjb250ZW50LCB0aGlzLnN0YXRlLmlzTXVsdGlsaW5lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNFbXB0eVRpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0VtcHR5VGlwKHBsYWNlaG9sZGVyKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHBsYWNlaG9sZGVyID09PSAnc3RyaW5nJyAmJiBwbGFjZWhvbGRlciA9PT0gJycgfHwgcGxhY2Vob2xkZXIgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiBtb3VzZSBlbnRlciwgc2hvdyB0aGUgdG9vbHRpcFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNob3dUb29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dUb29sdGlwKGUsIGlzR2xvYmFsQ2FsbCkge1xuICAgICAgaWYgKCF0aGlzLnRvb2x0aXBSZWYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzR2xvYmFsQ2FsbCkge1xuICAgICAgICAvLyBEb24ndCB0cmlnZ2VyIG90aGVyIGVsZW1lbnRzIGJlbG9uZ3MgdG8gb3RoZXIgUmVhY3RUb29sdGlwXG4gICAgICAgIHZhciB0YXJnZXRBcnJheSA9IHRoaXMuZ2V0VGFyZ2V0QXJyYXkodGhpcy5wcm9wcy5pZCk7XG4gICAgICAgIHZhciBpc015RWxlbWVudCA9IHRhcmdldEFycmF5LnNvbWUoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUgPT09IGUuY3VycmVudFRhcmdldDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaXNNeUVsZW1lbnQpIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEdldCB0aGUgdG9vbHRpcCBjb250ZW50XG4gICAgICAvLyBjYWxjdWxhdGUgaW4gdGhpcyBwaHJhc2Ugc28gdGhhdCB0aXAgd2lkdGggaGVpZ2h0IGNhbiBiZSBkZXRlY3RlZFxuICAgICAgdmFyIF90aGlzJHByb3BzNSA9IHRoaXMucHJvcHMsXG4gICAgICAgIG11bHRpbGluZSA9IF90aGlzJHByb3BzNS5tdWx0aWxpbmUsXG4gICAgICAgIGdldENvbnRlbnQgPSBfdGhpcyRwcm9wczUuZ2V0Q29udGVudDtcbiAgICAgIHZhciBvcmlnaW5Ub29sdGlwID0gZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS10aXAnKTtcbiAgICAgIHZhciBpc011bHRpbGluZSA9IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbXVsdGlsaW5lJykgfHwgbXVsdGlsaW5lIHx8IGZhbHNlO1xuXG4gICAgICAvLyBJZiBpdCBpcyBmb2N1cyBldmVudCBvciBjYWxsZWQgYnkgUmVhY3RUb29sdGlwLnNob3csIHN3aXRjaCB0byBgc29saWRgIGVmZmVjdFxuICAgICAgdmFyIHN3aXRjaFRvU29saWQgPSBlIGluc3RhbmNlb2Ygd2luZG93LkZvY3VzRXZlbnQgfHwgaXNHbG9iYWxDYWxsO1xuXG4gICAgICAvLyBpZiBpdCBuZWVkcyB0byBza2lwIGFkZGluZyBoaWRlIGxpc3RlbmVyIHRvIHNjcm9sbFxuICAgICAgdmFyIHNjcm9sbEhpZGUgPSB0cnVlO1xuICAgICAgaWYgKGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2Nyb2xsLWhpZGUnKSkge1xuICAgICAgICBzY3JvbGxIaWRlID0gZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1zY3JvbGwtaGlkZScpID09PSAndHJ1ZSc7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucHJvcHMuc2Nyb2xsSGlkZSAhPSBudWxsKSB7XG4gICAgICAgIHNjcm9sbEhpZGUgPSB0aGlzLnByb3BzLnNjcm9sbEhpZGU7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZGluZyBhcmlhLWRlc2NyaWJlZGJ5IHRvIHRhcmdldCB0byBtYWtlIHRvb2x0aXBzIHJlYWQgYnkgc2NyZWVuIHJlYWRlcnNcbiAgICAgIGlmIChlICYmIGUuY3VycmVudFRhcmdldCAmJiBlLmN1cnJlbnRUYXJnZXQuc2V0QXR0cmlidXRlKSB7XG4gICAgICAgIGUuY3VycmVudFRhcmdldC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aGlzLnByb3BzLmlkIHx8IHRoaXMuc3RhdGUudXVpZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgY29ycmVjdCBwbGFjZSBpcyBzZXRcbiAgICAgIHZhciBkZXNpcmVkUGxhY2UgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXBsYWNlJykgfHwgdGhpcy5wcm9wcy5wbGFjZSB8fCAndG9wJztcbiAgICAgIHZhciBlZmZlY3QgPSBzd2l0Y2hUb1NvbGlkICYmICdzb2xpZCcgfHwgdGhpcy5nZXRFZmZlY3QoZS5jdXJyZW50VGFyZ2V0KTtcbiAgICAgIHZhciBvZmZzZXQgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLW9mZnNldCcpIHx8IHRoaXMucHJvcHMub2Zmc2V0IHx8IHt9O1xuICAgICAgdmFyIHJlc3VsdCA9IGdldFBvc2l0aW9uKGUsIGUuY3VycmVudFRhcmdldCwgdGhpcy50b29sdGlwUmVmLCBkZXNpcmVkUGxhY2Uuc3BsaXQoJywnKVswXSwgZGVzaXJlZFBsYWNlLCBlZmZlY3QsIG9mZnNldCk7XG4gICAgICBpZiAocmVzdWx0LnBvc2l0aW9uICYmIHRoaXMucHJvcHMub3ZlcnJpZGVQb3NpdGlvbikge1xuICAgICAgICByZXN1bHQucG9zaXRpb24gPSB0aGlzLnByb3BzLm92ZXJyaWRlUG9zaXRpb24ocmVzdWx0LnBvc2l0aW9uLCBlLCBlLmN1cnJlbnRUYXJnZXQsIHRoaXMudG9vbHRpcFJlZiwgZGVzaXJlZFBsYWNlLCBkZXNpcmVkUGxhY2UsIGVmZmVjdCwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIHZhciBwbGFjZSA9IHJlc3VsdC5pc05ld1N0YXRlID8gcmVzdWx0Lm5ld1N0YXRlLnBsYWNlIDogZGVzaXJlZFBsYWNlLnNwbGl0KCcsJylbMF07XG5cbiAgICAgIC8vIFRvIHByZXZlbnQgcHJldmlvdXNseSBjcmVhdGVkIHRpbWVycyBmcm9tIHRyaWdnZXJpbmdcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgdmFyIHRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcbiAgICAgIHZhciByZXNob3dEZWxheSA9IHRoaXMuc3RhdGUuc2hvdyA/IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGVsYXktdXBkYXRlJykgfHwgdGhpcy5wcm9wcy5kZWxheVVwZGF0ZSA6IDA7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgdXBkYXRlU3RhdGUgPSBmdW5jdGlvbiB1cGRhdGVTdGF0ZSgpIHtcbiAgICAgICAgc2VsZi5zZXRTdGF0ZSh7XG4gICAgICAgICAgb3JpZ2luVG9vbHRpcDogb3JpZ2luVG9vbHRpcCxcbiAgICAgICAgICBpc011bHRpbGluZTogaXNNdWx0aWxpbmUsXG4gICAgICAgICAgZGVzaXJlZFBsYWNlOiBkZXNpcmVkUGxhY2UsXG4gICAgICAgICAgcGxhY2U6IHBsYWNlLFxuICAgICAgICAgIHR5cGU6IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdHlwZScpIHx8IHNlbGYucHJvcHMudHlwZSB8fCAnZGFyaycsXG4gICAgICAgICAgY3VzdG9tQ29sb3JzOiB7XG4gICAgICAgICAgICB0ZXh0OiB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXRleHQtY29sb3InKSB8fCBzZWxmLnByb3BzLnRleHRDb2xvciB8fCBudWxsLFxuICAgICAgICAgICAgYmFja2dyb3VuZDogdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1iYWNrZ3JvdW5kLWNvbG9yJykgfHwgc2VsZi5wcm9wcy5iYWNrZ3JvdW5kQ29sb3IgfHwgbnVsbCxcbiAgICAgICAgICAgIGJvcmRlcjogdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1ib3JkZXItY29sb3InKSB8fCBzZWxmLnByb3BzLmJvcmRlckNvbG9yIHx8IG51bGwsXG4gICAgICAgICAgICBhcnJvdzogdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1hcnJvdy1jb2xvcicpIHx8IHNlbGYucHJvcHMuYXJyb3dDb2xvciB8fCBudWxsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjdXN0b21SYWRpdXM6IHtcbiAgICAgICAgICAgIHRvb2x0aXA6IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdG9vbHRpcC1yYWRpdXMnKSB8fCBzZWxmLnByb3BzLnRvb2x0aXBSYWRpdXMgfHwgJzMnLFxuICAgICAgICAgICAgYXJyb3c6IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYXJyb3ctcmFkaXVzJykgfHwgc2VsZi5wcm9wcy5hcnJvd1JhZGl1cyB8fCAnMCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVmZmVjdDogZWZmZWN0LFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgIHBhZGRpbmc6IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFkZGluZycpIHx8IHNlbGYucHJvcHMucGFkZGluZyxcbiAgICAgICAgICBodG1sOiAodGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1odG1sJykgPyB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWh0bWwnKSA9PT0gJ3RydWUnIDogc2VsZi5wcm9wcy5odG1sKSB8fCBmYWxzZSxcbiAgICAgICAgICBkZWxheVNob3c6IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGVsYXktc2hvdycpIHx8IHNlbGYucHJvcHMuZGVsYXlTaG93IHx8IDAsXG4gICAgICAgICAgZGVsYXlIaWRlOiB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWRlbGF5LWhpZGUnKSB8fCBzZWxmLnByb3BzLmRlbGF5SGlkZSB8fCAwLFxuICAgICAgICAgIGRlbGF5VXBkYXRlOiB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWRlbGF5LXVwZGF0ZScpIHx8IHNlbGYucHJvcHMuZGVsYXlVcGRhdGUgfHwgMCxcbiAgICAgICAgICBib3JkZXI6ICh0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWJvcmRlcicpID8gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1ib3JkZXInKSA9PT0gJ3RydWUnIDogc2VsZi5wcm9wcy5ib3JkZXIpIHx8IGZhbHNlLFxuICAgICAgICAgIGJvcmRlckNsYXNzOiB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWJvcmRlci1jbGFzcycpIHx8IHNlbGYucHJvcHMuYm9yZGVyQ2xhc3MgfHwgJ2JvcmRlcicsXG4gICAgICAgICAgZXh0cmFDbGFzczogdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1jbGFzcycpIHx8IHNlbGYucHJvcHNbXCJjbGFzc1wiXSB8fCBzZWxmLnByb3BzLmNsYXNzTmFtZSB8fCAnJyxcbiAgICAgICAgICBkaXNhYmxlOiAodGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS10aXAtZGlzYWJsZScpID8gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS10aXAtZGlzYWJsZScpID09PSAndHJ1ZScgOiBzZWxmLnByb3BzLmRpc2FibGUpIHx8IGZhbHNlLFxuICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHRhcmdldFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHNjcm9sbEhpZGUpIHtcbiAgICAgICAgICAgIHNlbGYuYWRkU2Nyb2xsTGlzdGVuZXIoc2VsZi5zdGF0ZS5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi51cGRhdGVUb29sdGlwKGUpO1xuICAgICAgICAgIGlmIChnZXRDb250ZW50ICYmIEFycmF5LmlzQXJyYXkoZ2V0Q29udGVudCkpIHtcbiAgICAgICAgICAgIHNlbGYuaW50ZXJ2YWxVcGRhdGVDb250ZW50ID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoc2VsZi5tb3VudCkge1xuICAgICAgICAgICAgICAgIHZhciBfZ2V0Q29udGVudCA9IHNlbGYucHJvcHMuZ2V0Q29udGVudDtcbiAgICAgICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBUaXBDb250ZW50KG9yaWdpblRvb2x0aXAsICcnLCBfZ2V0Q29udGVudFswXSgpLCBpc011bHRpbGluZSk7XG4gICAgICAgICAgICAgICAgdmFyIGlzRW1wdHlUaXAgPSBzZWxmLmlzRW1wdHlUaXAocGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgaXNFbXB0eVRpcDogaXNFbXB0eVRpcFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZ2V0Q29udGVudFsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGRlbGF5IGNhbGwgaW1tZWRpYXRlbHksIGRvbid0IGFsbG93IGV2ZW50cyB0byBnZXQgaW4gZmlyc3QuXG4gICAgICBpZiAocmVzaG93RGVsYXkpIHtcbiAgICAgICAgdGhpcy5kZWxheVJlc2hvdyA9IHNldFRpbWVvdXQodXBkYXRlU3RhdGUsIHJlc2hvd0RlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZVN0YXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiBtb3VzZSBob3ZlciwgdXBkYXRlIHRvb2wgdGlwXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlVG9vbHRpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVUb29sdGlwKGUpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgICAgdmFyIF90aGlzJHN0YXRlID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgZGVsYXlTaG93ID0gX3RoaXMkc3RhdGUuZGVsYXlTaG93LFxuICAgICAgICBkaXNhYmxlID0gX3RoaXMkc3RhdGUuZGlzYWJsZTtcbiAgICAgIHZhciBfdGhpcyRwcm9wczYgPSB0aGlzLnByb3BzLFxuICAgICAgICBhZnRlclNob3cgPSBfdGhpcyRwcm9wczYuYWZ0ZXJTaG93LFxuICAgICAgICBkaXNhYmxlUHJvcCA9IF90aGlzJHByb3BzNi5kaXNhYmxlO1xuICAgICAgdmFyIHBsYWNlaG9sZGVyID0gdGhpcy5nZXRUb29sdGlwQ29udGVudCgpO1xuICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0IHx8IGUudGFyZ2V0O1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgbW91c2UgaXMgYWN0dWFsbHkgb3ZlciB0aGUgdG9vbHRpcCwgaWYgc28gZG9uJ3QgaGlkZSB0aGUgdG9vbHRpcFxuICAgICAgaWYgKHRoaXMubW91c2VPblRvb2xUaXAoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSB0b29sdGlwIGlzIGVtcHR5LCBkaXNhYmxlIHRoZSB0b29sdGlwXG4gICAgICBpZiAodGhpcy5pc0VtcHR5VGlwKHBsYWNlaG9sZGVyKSB8fCBkaXNhYmxlIHx8IGRpc2FibGVQcm9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBkZWxheVRpbWUgPSAhdGhpcy5zdGF0ZS5zaG93ID8gcGFyc2VJbnQoZGVsYXlTaG93LCAxMCkgOiAwO1xuICAgICAgdmFyIHVwZGF0ZVN0YXRlID0gZnVuY3Rpb24gdXBkYXRlU3RhdGUoKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBsYWNlaG9sZGVyKSAmJiBwbGFjZWhvbGRlci5sZW5ndGggPiAwIHx8IHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgdmFyIGlzSW52aXNpYmxlID0gIV90aGlzNS5zdGF0ZS5zaG93O1xuICAgICAgICAgIF90aGlzNS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjdXJyZW50RXZlbnQ6IGUsXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBldmVudFRhcmdldCxcbiAgICAgICAgICAgIHNob3c6IHRydWVcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczUudXBkYXRlUG9zaXRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoaXNJbnZpc2libGUgJiYgYWZ0ZXJTaG93KSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXJTaG93KGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmRlbGF5U2hvd0xvb3ApIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlTaG93TG9vcCk7XG4gICAgICB9XG4gICAgICBpZiAoZGVsYXlUaW1lKSB7XG4gICAgICAgIHRoaXMuZGVsYXlTaG93TG9vcCA9IHNldFRpbWVvdXQodXBkYXRlU3RhdGUsIGRlbGF5VGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlbGF5U2hvd0xvb3AgPSBudWxsO1xuICAgICAgICB1cGRhdGVTdGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogSWYgd2UncmUgbW91c2luZyBvdmVyIHRoZSB0b29sdGlwIHJlbW92ZSBpdCB3aGVuIHdlIGxlYXZlLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImxpc3RlbkZvclRvb2x0aXBFeGl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RlbkZvclRvb2x0aXBFeGl0KCkge1xuICAgICAgdmFyIHNob3cgPSB0aGlzLnN0YXRlLnNob3c7XG4gICAgICBpZiAoc2hvdyAmJiB0aGlzLnRvb2x0aXBSZWYpIHtcbiAgICAgICAgdGhpcy50b29sdGlwUmVmLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLmhpZGVUb29sdGlwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlTGlzdGVuZXJGb3JUb29sdGlwRXhpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lckZvclRvb2x0aXBFeGl0KCkge1xuICAgICAgdmFyIHNob3cgPSB0aGlzLnN0YXRlLnNob3c7XG4gICAgICBpZiAoc2hvdyAmJiB0aGlzLnRvb2x0aXBSZWYpIHtcbiAgICAgICAgdGhpcy50b29sdGlwUmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLmhpZGVUb29sdGlwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIG1vdXNlIGxlYXZlLCBoaWRlIHRvb2x0aXBcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJoaWRlVG9vbHRpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlVG9vbHRpcChlLCBoYXNUYXJnZXQpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHtcbiAgICAgICAgaXNTY3JvbGw6IGZhbHNlXG4gICAgICB9O1xuICAgICAgdmFyIGRpc2FibGUgPSB0aGlzLnN0YXRlLmRpc2FibGU7XG4gICAgICB2YXIgaXNTY3JvbGwgPSBvcHRpb25zLmlzU2Nyb2xsO1xuICAgICAgdmFyIGRlbGF5SGlkZSA9IGlzU2Nyb2xsID8gMCA6IHRoaXMuc3RhdGUuZGVsYXlIaWRlO1xuICAgICAgdmFyIF90aGlzJHByb3BzNyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGFmdGVySGlkZSA9IF90aGlzJHByb3BzNy5hZnRlckhpZGUsXG4gICAgICAgIGRpc2FibGVQcm9wID0gX3RoaXMkcHJvcHM3LmRpc2FibGU7XG4gICAgICB2YXIgcGxhY2Vob2xkZXIgPSB0aGlzLmdldFRvb2x0aXBDb250ZW50KCk7XG4gICAgICBpZiAoIXRoaXMubW91bnQpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmlzRW1wdHlUaXAocGxhY2Vob2xkZXIpIHx8IGRpc2FibGUgfHwgZGlzYWJsZVByb3ApIHJldHVybjsgLy8gaWYgdGhlIHRvb2x0aXAgaXMgZW1wdHksIGRpc2FibGUgdGhlIHRvb2x0aXBcbiAgICAgIGlmIChoYXNUYXJnZXQpIHtcbiAgICAgICAgLy8gRG9uJ3QgdHJpZ2dlciBvdGhlciBlbGVtZW50cyBiZWxvbmdzIHRvIG90aGVyIFJlYWN0VG9vbHRpcFxuICAgICAgICB2YXIgdGFyZ2V0QXJyYXkgPSB0aGlzLmdldFRhcmdldEFycmF5KHRoaXMucHJvcHMuaWQpO1xuICAgICAgICB2YXIgaXNNeUVsZW1lbnQgPSB0YXJnZXRBcnJheS5zb21lKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlID09PSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWlzTXlFbGVtZW50IHx8ICF0aGlzLnN0YXRlLnNob3cpIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gY2xlYW4gdXAgYXJpYS1kZXNjcmliZWRieSB3aGVuIGhpZGluZyB0b29sdGlwXG4gICAgICBpZiAoZSAmJiBlLmN1cnJlbnRUYXJnZXQgJiYgZS5jdXJyZW50VGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZSkge1xuICAgICAgICBlLmN1cnJlbnRUYXJnZXQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5Jyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzZXRTdGF0ZSA9IGZ1bmN0aW9uIHJlc2V0U3RhdGUoKSB7XG4gICAgICAgIHZhciBpc1Zpc2libGUgPSBfdGhpczYuc3RhdGUuc2hvdztcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG1vdXNlIGlzIGFjdHVhbGx5IG92ZXIgdGhlIHRvb2x0aXAsIGlmIHNvIGRvbid0IGhpZGUgdGhlIHRvb2x0aXBcbiAgICAgICAgaWYgKF90aGlzNi5tb3VzZU9uVG9vbFRpcCgpKSB7XG4gICAgICAgICAgX3RoaXM2Lmxpc3RlbkZvclRvb2x0aXBFeGl0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzNi5yZW1vdmVMaXN0ZW5lckZvclRvb2x0aXBFeGl0KCk7XG4gICAgICAgIF90aGlzNi5zZXRTdGF0ZSh7XG4gICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNi5yZW1vdmVTY3JvbGxMaXN0ZW5lcihfdGhpczYuc3RhdGUuY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgaWYgKGlzVmlzaWJsZSAmJiBhZnRlckhpZGUpIHtcbiAgICAgICAgICAgIGFmdGVySGlkZShlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgaWYgKGRlbGF5SGlkZSkge1xuICAgICAgICB0aGlzLmRlbGF5SGlkZUxvb3AgPSBzZXRUaW1lb3V0KHJlc2V0U3RhdGUsIHBhcnNlSW50KGRlbGF5SGlkZSwgMTApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNjcm9sbCwgaGlkZSB0b29sdGlwXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZVRvb2x0aXBPblNjcm9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlVG9vbHRpcE9uU2Nyb2xsKGV2ZW50LCBoYXNUYXJnZXQpIHtcbiAgICAgIHRoaXMuaGlkZVRvb2x0aXAoZXZlbnQsIGhhc1RhcmdldCwge1xuICAgICAgICBpc1Njcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHNjcm9sbCBldmVudCBsaXN0ZW5lciB3aGVuIHRvb2x0aXAgc2hvd1xuICAgICAqIGF1dG9tYXRpY2FsbHkgaGlkZSB0aGUgdG9vbHRpcCB3aGVuIHNjcm9sbGluZ1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZFNjcm9sbExpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFNjcm9sbExpc3RlbmVyKGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIHZhciBpc0NhcHR1cmVNb2RlID0gdGhpcy5pc0NhcHR1cmUoY3VycmVudFRhcmdldCk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oaWRlVG9vbHRpcE9uU2Nyb2xsLCBpc0NhcHR1cmVNb2RlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlU2Nyb2xsTGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlU2Nyb2xsTGlzdGVuZXIoY3VycmVudFRhcmdldCkge1xuICAgICAgdmFyIGlzQ2FwdHVyZU1vZGUgPSB0aGlzLmlzQ2FwdHVyZShjdXJyZW50VGFyZ2V0KTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhpZGVUb29sdGlwT25TY3JvbGwsIGlzQ2FwdHVyZU1vZGUpO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0aW9uIHRoZSBwb3NpdGlvblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKGNhbGxiYWNrQWZ0ZXIpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuICAgICAgdmFyIF90aGlzJHN0YXRlMiA9IHRoaXMuc3RhdGUsXG4gICAgICAgIGN1cnJlbnRFdmVudCA9IF90aGlzJHN0YXRlMi5jdXJyZW50RXZlbnQsXG4gICAgICAgIGN1cnJlbnRUYXJnZXQgPSBfdGhpcyRzdGF0ZTIuY3VycmVudFRhcmdldCxcbiAgICAgICAgcGxhY2UgPSBfdGhpcyRzdGF0ZTIucGxhY2UsXG4gICAgICAgIGRlc2lyZWRQbGFjZSA9IF90aGlzJHN0YXRlMi5kZXNpcmVkUGxhY2UsXG4gICAgICAgIGVmZmVjdCA9IF90aGlzJHN0YXRlMi5lZmZlY3QsXG4gICAgICAgIG9mZnNldCA9IF90aGlzJHN0YXRlMi5vZmZzZXQ7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMudG9vbHRpcFJlZjtcbiAgICAgIHZhciByZXN1bHQgPSBnZXRQb3NpdGlvbihjdXJyZW50RXZlbnQsIGN1cnJlbnRUYXJnZXQsIG5vZGUsIHBsYWNlLCBkZXNpcmVkUGxhY2UsIGVmZmVjdCwgb2Zmc2V0KTtcbiAgICAgIGlmIChyZXN1bHQucG9zaXRpb24gJiYgdGhpcy5wcm9wcy5vdmVycmlkZVBvc2l0aW9uKSB7XG4gICAgICAgIHJlc3VsdC5wb3NpdGlvbiA9IHRoaXMucHJvcHMub3ZlcnJpZGVQb3NpdGlvbihyZXN1bHQucG9zaXRpb24sIGN1cnJlbnRFdmVudCwgY3VycmVudFRhcmdldCwgbm9kZSwgcGxhY2UsIGRlc2lyZWRQbGFjZSwgZWZmZWN0LCBvZmZzZXQpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5pc05ld1N0YXRlKSB7XG4gICAgICAgIC8vIFN3aXRjaCB0byByZXZlcnNlIHBsYWNlbWVudFxuICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZShyZXN1bHQubmV3U3RhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczcudXBkYXRlUG9zaXRpb24oY2FsbGJhY2tBZnRlcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrQWZ0ZXIgJiYgdHlwZW9mIGNhbGxiYWNrQWZ0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2tBZnRlcigpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdG9vbHRpcCBwb3NpdGlvblxuICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gcmVzdWx0LnBvc2l0aW9uLmxlZnQgKyAncHgnO1xuICAgICAgbm9kZS5zdHlsZS50b3AgPSByZXN1bHQucG9zaXRpb24udG9wICsgJ3B4JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDTGVhciBhbGwga2luZHMgb2YgdGltZW91dCBvZiBpbnRlcnZhbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsZWFyVGltZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJUaW1lcigpIHtcbiAgICAgIGlmICh0aGlzLmRlbGF5U2hvd0xvb3ApIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlTaG93TG9vcCk7XG4gICAgICAgIHRoaXMuZGVsYXlTaG93TG9vcCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kZWxheUhpZGVMb29wKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlbGF5SGlkZUxvb3ApO1xuICAgICAgICB0aGlzLmRlbGF5SGlkZUxvb3AgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGVsYXlSZXNob3cpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlSZXNob3cpO1xuICAgICAgICB0aGlzLmRlbGF5UmVzaG93ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmludGVydmFsVXBkYXRlQ29udGVudCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxVcGRhdGVDb250ZW50KTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbFVwZGF0ZUNvbnRlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNDdXN0b21Db2xvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzQ3VzdG9tQ29sb3JzKCkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG4gICAgICByZXR1cm4gQm9vbGVhbihPYmplY3Qua2V5cyh0aGlzLnN0YXRlLmN1c3RvbUNvbG9ycykuZmluZChmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yICE9PSAnYm9yZGVyJyAmJiBfdGhpczguc3RhdGUuY3VzdG9tQ29sb3JzW2NvbG9yXTtcbiAgICAgIH0pIHx8IHRoaXMuc3RhdGUuYm9yZGVyICYmIHRoaXMuc3RhdGUuY3VzdG9tQ29sb3JzWydib3JkZXInXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcbiAgICAgIHZhciBfdGhpcyRzdGF0ZTMgPSB0aGlzLnN0YXRlLFxuICAgICAgICBleHRyYUNsYXNzID0gX3RoaXMkc3RhdGUzLmV4dHJhQ2xhc3MsXG4gICAgICAgIGh0bWwgPSBfdGhpcyRzdGF0ZTMuaHRtbCxcbiAgICAgICAgYXJpYVByb3BzID0gX3RoaXMkc3RhdGUzLmFyaWFQcm9wcyxcbiAgICAgICAgZGlzYWJsZSA9IF90aGlzJHN0YXRlMy5kaXNhYmxlLFxuICAgICAgICB1dWlkID0gX3RoaXMkc3RhdGUzLnV1aWQ7XG4gICAgICB2YXIgY29udGVudCA9IHRoaXMuZ2V0VG9vbHRpcENvbnRlbnQoKTtcbiAgICAgIHZhciBpc0VtcHR5VGlwID0gdGhpcy5pc0VtcHR5VGlwKGNvbnRlbnQpO1xuICAgICAgdmFyIHN0eWxlID0gdGhpcy5wcm9wcy5kaXNhYmxlSW50ZXJuYWxTdHlsZSA/ICcnIDogZ2VuZXJhdGVUb29sdGlwU3R5bGUodGhpcy5zdGF0ZS51dWlkLCB0aGlzLnN0YXRlLmN1c3RvbUNvbG9ycywgdGhpcy5zdGF0ZS50eXBlLCB0aGlzLnN0YXRlLmJvcmRlciwgdGhpcy5zdGF0ZS5wYWRkaW5nLCB0aGlzLnN0YXRlLmN1c3RvbVJhZGl1cyk7XG4gICAgICB2YXIgdG9vbHRpcENsYXNzID0gJ19fcmVhY3RfY29tcG9uZW50X3Rvb2x0aXAnICsgXCIgXCIuY29uY2F0KHRoaXMuc3RhdGUudXVpZCkgKyAodGhpcy5zdGF0ZS5zaG93ICYmICFkaXNhYmxlICYmICFpc0VtcHR5VGlwID8gJyBzaG93JyA6ICcnKSArICh0aGlzLnN0YXRlLmJvcmRlciA/ICcgJyArIHRoaXMuc3RhdGUuYm9yZGVyQ2xhc3MgOiAnJykgKyBcIiBwbGFjZS1cIi5jb25jYXQodGhpcy5zdGF0ZS5wbGFjZSkgK1xuICAgICAgLy8gdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0XG4gICAgICBcIiB0eXBlLVwiLmNvbmNhdCh0aGlzLmhhc0N1c3RvbUNvbG9ycygpID8gJ2N1c3RvbScgOiB0aGlzLnN0YXRlLnR5cGUpICsgKFxuICAgICAgLy8gZGFyaywgc3VjY2Vzcywgd2FybmluZywgZXJyb3IsIGluZm8sIGxpZ2h0LCBjdXN0b21cbiAgICAgIHRoaXMucHJvcHMuZGVsYXlVcGRhdGUgPyAnIGFsbG93X2hvdmVyJyA6ICcnKSArICh0aGlzLnByb3BzLmNsaWNrYWJsZSA/ICcgYWxsb3dfY2xpY2snIDogJycpO1xuICAgICAgdmFyIFdyYXBwZXIgPSB0aGlzLnByb3BzLndyYXBwZXI7XG4gICAgICBpZiAoUmVhY3RUb29sdGlwLnN1cHBvcnRlZFdyYXBwZXJzLmluZGV4T2YoV3JhcHBlcikgPCAwKSB7XG4gICAgICAgIFdyYXBwZXIgPSBSZWFjdFRvb2x0aXAuZGVmYXVsdFByb3BzLndyYXBwZXI7XG4gICAgICB9XG4gICAgICB2YXIgd3JhcHBlckNsYXNzTmFtZSA9IFt0b29sdGlwQ2xhc3MsIGV4dHJhQ2xhc3NdLmZpbHRlcihCb29sZWFuKS5qb2luKCcgJyk7XG4gICAgICBpZiAoaHRtbCkge1xuICAgICAgICB2YXIgaHRtbENvbnRlbnQgPSBcIlwiLmNvbmNhdChjb250ZW50KS5jb25jYXQoc3R5bGUgPyBcIlxcbjxzdHlsZSBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+XCIuY29uY2F0KHN0eWxlLCBcIjwvc3R5bGU+XCIpIDogJycpO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlciwgX2V4dGVuZHMoe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQod3JhcHBlckNsYXNzTmFtZSksXG4gICAgICAgICAgaWQ6IHRoaXMucHJvcHMuaWQgfHwgdXVpZCxcbiAgICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihfcmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM5LnRvb2x0aXBSZWYgPSBfcmVmO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgYXJpYVByb3BzLCB7XG4gICAgICAgICAgXCJkYXRhLWlkXCI6IFwidG9vbHRpcFwiLFxuICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgICBfX2h0bWw6IGh0bWxDb250ZW50XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlciwgX2V4dGVuZHMoe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQod3JhcHBlckNsYXNzTmFtZSksXG4gICAgICAgICAgaWQ6IHRoaXMucHJvcHMuaWQgfHwgdXVpZFxuICAgICAgICB9LCBhcmlhUHJvcHMsIHtcbiAgICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihfcmVmMikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzOS50b29sdGlwUmVmID0gX3JlZjI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRhdGEtaWRcIjogXCJ0b29sdGlwXCJcbiAgICAgICAgfSksIHN0eWxlICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIiwge1xuICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgICBfX2h0bWw6IHN0eWxlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiXG4gICAgICAgIH0pLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwcm9wVHlwZXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHV1aWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBwbGFjZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgdHlwZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgZWZmZWN0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBvZmZzZXQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIHBhZGRpbmc6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIG11bHRpbGluZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGJvcmRlcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGJvcmRlckNsYXNzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICB0ZXh0Q29sb3I6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgYm9yZGVyQ29sb3I6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGFycm93Q29sb3I6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGFycm93UmFkaXVzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICB0b29sdGlwUmFkaXVzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBpbnNlY3VyZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIFwiY2xhc3NcIjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgaHRtbDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGRlbGF5SGlkZTogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgZGVsYXlVcGRhdGU6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGRlbGF5U2hvdzogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgZXZlbnQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGV2ZW50T2ZmOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBpc0NhcHR1cmU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBnbG9iYWxFdmVudE9mZjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgZ2V0Q29udGVudDogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgYWZ0ZXJTaG93OiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgYWZ0ZXJIaWRlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb3ZlcnJpZGVQb3NpdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGRpc2FibGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBzY3JvbGxIaWRlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgcmVzaXplSGlkZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHdyYXBwZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGJvZHlNb2RlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgcG9zc2libGVDdXN0b21FdmVudHM6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHBvc3NpYmxlQ3VzdG9tRXZlbnRzT2ZmOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjbGlja2FibGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBkaXNhYmxlSW50ZXJuYWxTdHlsZTogUHJvcFR5cGVzLmJvb2xcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgIHZhciBhcmlhUHJvcHMgPSBwcmV2U3RhdGUuYXJpYVByb3BzO1xuICAgICAgdmFyIG5ld0FyaWFQcm9wcyA9IHBhcnNlQXJpYShuZXh0UHJvcHMpO1xuICAgICAgdmFyIGlzQ2hhbmdlZCA9IE9iamVjdC5rZXlzKG5ld0FyaWFQcm9wcykuc29tZShmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIG5ld0FyaWFQcm9wc1twcm9wc10gIT09IGFyaWFQcm9wc1twcm9wc107XG4gICAgICB9KTtcbiAgICAgIGlmICghaXNDaGFuZ2VkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwcmV2U3RhdGUpLCB7fSwge1xuICAgICAgICBhcmlhUHJvcHM6IG5ld0FyaWFQcm9wc1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSZWFjdFRvb2x0aXA7XG59KFJlYWN0LkNvbXBvbmVudCksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MyLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIGluc2VjdXJlOiB0cnVlLFxuICByZXNpemVIaWRlOiB0cnVlLFxuICB3cmFwcGVyOiAnZGl2JyxcbiAgY2xpY2thYmxlOiBmYWxzZVxufSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MyLCBcInN1cHBvcnRlZFdyYXBwZXJzXCIsIFsnZGl2JywgJ3NwYW4nXSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MyLCBcImRpc3BsYXlOYW1lXCIsICdSZWFjdFRvb2x0aXAnKSwgX2NsYXNzMikpIHx8IF9jbGFzcykgfHwgX2NsYXNzKSB8fCBfY2xhc3MpIHx8IF9jbGFzcykgfHwgX2NsYXNzKSB8fCBfY2xhc3MpIHx8IF9jbGFzcztcbmV4cG9ydCB7IFJlYWN0VG9vbHRpcCBhcyBkZWZhdWx0IH07IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIGRpc0luZGljYXRvclZhbHVlID0gXCJJbmRpY2F0b3ItbW9kdWxlLS1kaXNJbmRpY2F0b3JWYWx1ZS0tRFgwSWdcIjtcbmV4cG9ydCB2YXIgaW5kaWNhdG9yQm94TWFpbiA9IFwiSW5kaWNhdG9yLW1vZHVsZS0taW5kaWNhdG9yQm94TWFpbi0tNlQ1WHRcIjtcbmV4cG9ydCB2YXIgaW5kaWNhdG9yRGVzYyA9IFwiSW5kaWNhdG9yLW1vZHVsZS0taW5kaWNhdG9yRGVzYy0tLUVDVFFcIjtcbmV4cG9ydCB2YXIgaW5kaWNhdG9ySW5mbyA9IFwiSW5kaWNhdG9yLW1vZHVsZS0taW5kaWNhdG9ySW5mby0tcDZsQ3VcIjtcbmV4cG9ydCB2YXIgaW5kaWNhdG9yTmFtZSA9IFwiSW5kaWNhdG9yLW1vZHVsZS0taW5kaWNhdG9yTmFtZS0tbHIzSE1cIjtcbmV4cG9ydCB2YXIgaW5kaWNhdG9yUm93ID0gXCJJbmRpY2F0b3ItbW9kdWxlLS1pbmRpY2F0b3JSb3ctLWRFYU5nXCI7XG5leHBvcnQgdmFyIGluZGljYXRvclZhbHVlID0gXCJJbmRpY2F0b3ItbW9kdWxlLS1pbmRpY2F0b3JWYWx1ZS0tUGNVdTNcIjtcbmV4cG9ydCB2YXIgaW5kaWNhdG9yVmFsdWVDb2wgPSBcIkluZGljYXRvci1tb2R1bGUtLWluZGljYXRvclZhbHVlQ29sLS1jaWMxQ1wiO1xuZXhwb3J0IHZhciBpbmRpY2F0b3JWYWx1ZVJvdyA9IFwiSW5kaWNhdG9yLW1vZHVsZS0taW5kaWNhdG9yVmFsdWVSb3ctLUljaEU4XCI7XG5leHBvcnQgdmFyIGluZGljYXRvclZhbHVlU3ViVGV4dCA9IFwiSW5kaWNhdG9yLW1vZHVsZS0taW5kaWNhdG9yVmFsdWVTdWJUZXh0LS13OTJ3dlwiO1xuZXhwb3J0IHZhciBpbmZvID0gXCJJbmRpY2F0b3ItbW9kdWxlLS1pbmZvLS01d2R2NVwiO1xuZXhwb3J0IHZhciBpbmZvVGlsZGUgPSBcIkluZGljYXRvci1tb2R1bGUtLWluZm9UaWxkZS0tSlNKV0VcIjsiLCJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlHaGxhV2RvZEQwaU1qUWlJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lnZDJsa2RHZzlJakkwSWo0OGNHRjBhQ0JrUFNKTk1DQXdhREkwZGpJMFNEQjZJaUJtYVd4c1BTSnViMjVsSWk4K1BIQmhkR2dnWkQwaVRURXlJREpETmk0ME9DQXlJRElnTmk0ME9DQXlJREV5Y3pRdU5EZ2dNVEFnTVRBZ01UQWdNVEF0TkM0ME9DQXhNQzB4TUZNeE55NDFNaUF5SURFeUlESjZiVEVnTVRWb0xUSjJMVFpvTW5ZMmVtMHdMVGhvTFRKV04yZ3lkako2SWk4K1BDOXpkbWMrXCIiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHt1c2VJbnRsfSBmcm9tICdnYXRzYnktcGx1Z2luLWludGwnO1xuaW1wb3J0IFJlYWN0VG9vbHRpcCBmcm9tICdyZWFjdC10b29sdGlwJztcblxuaW1wb3J0IHtpbmRpY2F0b3JJbmZvLCBpbmRpY2F0b3JUeXBlfSBmcm9tICcuLi9BcmVhRGV0YWlsL0FyZWFEZXRhaWwnO1xuXG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi9JbmRpY2F0b3IubW9kdWxlLnNjc3MnO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4uLy4uL2RhdGEvY29uc3RhbnRzJztcbmltcG9ydCAqIGFzIEVYUExPUkVfQ09QWSBmcm9tICcuLi8uLi9kYXRhL2NvcHkvZXhwbG9yZSc7XG5cbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBpbmZvSWNvbiBmcm9tICcvbm9kZV9tb2R1bGVzL3Vzd2RzL2Rpc3QvaW1nL3VzYS1pY29ucy9pbmZvLnN2Zyc7XG5cbmludGVyZmFjZSBJSW5kaWNhdG9yIHtcbiAgaW5kaWNhdG9yOiBpbmRpY2F0b3JJbmZvLFxuICBpc0ltcHV0ZT86IGJvb2xlYW4sXG4gIHBvcHVsYXRpb24/OiBudW1iZXIgfCBzdHJpbmcsXG59XG5pbnRlcmZhY2UgSUluZGljYXRvclZhbHVlU3ViVGV4dCB7XG4gIHR5cGU6IGluZGljYXRvclR5cGUsXG4gIHZhbHVlOiBudW1iZXIgfCBudWxsIHwgYm9vbGVhbixcbiAgaXNBYm92ZVRocmVzaDogYm9vbGVhbixcbiAgdGhyZXNob2xkOiBudW1iZXIsXG59XG5cbmludGVyZmFjZSBJSW5kaWNhdG9yVmFsdWUge1xuICB0eXBlOiBpbmRpY2F0b3JUeXBlLFxuICBkaXNwbGF5U3RhdDogbnVtYmVyIHwgbnVsbCxcbn1cblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCB3aWxsIHJlbmRlciBhbiBpbmZvIGljb24gaW4gdGhlIGluZGljYXRvciB2YWx1ZVxuICpcbiAqIEByZXR1cm4ge0pTWC5FbGVtZW50fVxuICovXG5leHBvcnQgY29uc3QgSW5kaWNhdG9ySW5mb0ljb24gPSAoe2lzSW1wdXRlLCBwb3B1bGF0aW9ufTogT21pdDxJSW5kaWNhdG9yLCAnaW5kaWNhdG9yJz4pID0+IHtcbiAgY29uc3QgaW50bCA9IHVzZUludGwoKTtcbiAgbGV0IHNob3dUaWxkZSA9IGZhbHNlO1xuXG4gIGNvbnN0IGdldFRvb2xUaXBDb3B5ID0gKCkgPT4ge1xuICAgIGlmIChwb3B1bGF0aW9uID09PSBjb25zdGFudHMuTUlTU0lOR19EQVRBX1NUUklORykge1xuICAgICAgcmV0dXJuIGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuTE9XX0lOQ09NRV9UT09MVElQLklNUF9ZRVNfUE9QX05VTEwpO1xuICAgIH0gZWxzZSBpZiAocG9wdWxhdGlvbiAhPT0gY29uc3RhbnRzLk1JU1NJTkdfREFUQV9TVFJJTkcgJiYgaXNJbXB1dGUpIHtcbiAgICAgIHNob3dUaWxkZSA9IHRydWU7XG4gICAgICByZXR1cm4gaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5MT1dfSU5DT01FX1RPT0xUSVAuSU1QX1lFU19QT1BfTk9UX05VTEwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbGlicmFyeSByZWFjdC10b29sdGlwIGNyZWF0ZXMgcmFuZG9tIERPTSBJRCB3aGljaCB3aWxsIG5vdCBhbGxvdyBmb3Igc25hcHNob3QgdGVzdGluZyBhc1xuICAgKiB0aGUgSURzIGNoYW5nZSBvbiBlYWNoIGJ1aWxkLiBEdWUgdG8gdGltZSBjb25zdHJhaW50cywgd2Ugc2ltcGx5IHJlbW92ZWQgdGhlIEFyZWFEZXRhaWxzIHRlc3QuXG4gICAqIFRoZSBBcmVhRGV0YWlscyBjb21wb25lbnQgaXMgbWFkZSB1cCBvZiBzdWIgY29tcG9uZW50IGFuZCBlYWNoIHN1YiBjb21wb25lbnQgaGFzIHRlc3RzIHNvIHRoaXNcbiAgICogaXMgbG93IHJpc2suXG4gICAqXG4gICAqIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc29sdXRpb24uIFNvbWUgbG9uZ2VyIHRlcm1zIHNvbHV0aW9ucyBtYXkgYmVcbiAgICogMS4gUmVtb3ZlIHRoaXMgbGlicmFyeSBhbmQgZ2V0IHRoZSBVU1dEUyB0b29sIHRpcCB0byB3b3JrXG4gICAqIDIuIFJlLWZhY3RvciB0aGUgYXJlYURldGFpbC50ZXN0cy50c3ggc25hcHNob3QgdGVzdHMgdG8gZG8gbW9yZSBET00gYXNzZXJ0aW9ucyByYXRoZXIgdGhhbiBzbmFwc2hvdHNcbiAgICogMy4gU29tZSBjb21iaW5hdGlvbiBvZiB0aGUgdHdvLlxuICAgKi9cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPFJlYWN0VG9vbHRpcFxuICAgICAgICBpZD1cImxvd0luY29tZUljb25cIlxuICAgICAgICBtdWx0aWxpbmU9e3RydWV9XG4gICAgICAvPlxuICAgICAgPGltZ1xuICAgICAgICBkYXRhLWZvcj1cImxvd0luY29tZUljb25cIlxuICAgICAgICBkYXRhLXRpcD17Z2V0VG9vbFRpcENvcHkoKX1cbiAgICAgICAgZGF0YS1pc2NhcHR1cmU9XCJ0cnVlXCJcbiAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuaW5mb31cbiAgICAgICAgc3JjPXtpbmZvSWNvbn1cbiAgICAgICAgYWx0PXtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfVkFMVUVTLklNR19BTFRfVEVYVC5JTkZPKX1cbiAgICAgIC8+XG4gICAgICB7c2hvd1RpbGRlICYmIDxzcGFuIGNsYXNzTmFtZT17c3R5bGVzLmluZm9UaWxkZX0+eyBgIH4gYCB9PC9zcGFuPn1cbiAgICA8Lz5cbiAgKTtcbn07XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgd2lsbCBkZXRlcm1pbmUgdGhlIHN1Yi10ZXh0IG9mIHRoZSBpbmRpY2F0b3IncyB2YWx1ZSwgc29tZSBleGFtcGxlcyBjb3VsZCBiZVxuICogICBcImFib3ZlIDkwdGggcGVyY2VudGlsZVwiXG4gKiAgIFwiYmVsb3cgMjAgcGVyY2VudFwiXG4gKiAgIFwiZGF0YSBpcyBub3QgYXZhaWxhYmxlXCJcbiAqXG4gKiBAcGFyYW0ge0lJbmRpY2F0b3JWYWx1ZVN1YlRleHR9IHt9XG4gKiBAcmV0dXJuIHtKU1guRWxlbWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IEluZGljYXRvclZhbHVlU3ViVGV4dCA9ICh7dHlwZSwgdmFsdWUsIGlzQWJvdmVUaHJlc2gsIHRocmVzaG9sZH06SUluZGljYXRvclZhbHVlU3ViVGV4dCkgPT4ge1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdj5cbiAgICAgICAge0VYUExPUkVfQ09QWS5TSURFX1BBTkVMX1ZBTFVFUy5VTkFWQUlMQkxFX01TR31cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3BlcmNlbnQnIHx8IHR5cGUgPT09ICdwZXJjZW50aWxlJykge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2PlxuICAgICAgICB7XG4gICAgICAgICAgaXNBYm92ZVRocmVzaCA/XG4gICAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfVkFMVUVTLkFCT1ZFIDpcbiAgICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9WQUxVRVMuQkVMT1dcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgdGhyZXNob2xkID9cbiAgICAgICAgICA8SW5kaWNhdG9yVmFsdWUgdHlwZT17dHlwZX0gZGlzcGxheVN0YXQ9e3RocmVzaG9sZH0vPiA6XG4gICAgICAgICAgPEluZGljYXRvclZhbHVlIHR5cGU9e3R5cGV9IGRpc3BsYXlTdGF0PXs5MH0vPlxuICAgICAgICB9XG4gICAgICAgIHtgIGB9XG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlID09PSAncGVyY2VudCcgP1xuICAgICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX1ZBTFVFUy5QRVJDRU5UIDpcbiAgICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9WQUxVRVMuUEVSQ0VOVElMRVxuICAgICAgICB9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoPD48Lz4pO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSByZWFjdC1pMThuIGxpYnJhcnkgYWxsb3cgdG8gYWRkIG9yZGluYWwgc3VmZml4IChzdCwgbmQsIHJkLCB0aCkgdG8gaW5kaWNhdG9yIHZhbHVlcy5cbiAqIFRoZSBudW1iZXIgYW5kIHRoZSBzdWZmaXggaXMgYSBzaW5nbGUgZW50aXR5LiBXZSBhcmUgbG9va2luZyB0byBhZGQgc3R5bGluZyB0b1xuICoganVzdCB0aGUgc3VmZml4IHBvcnRpb24gaWYgdGhlIHZhbHVlIGlzIGEgcGVyY2VudGlsZS4gVGhpcyBmdW5jdGlvbiB3aWxsIGFkZFxuICogYSBzdXBlcnNjcmlwdCBzdHlsaW5nIHRvIGp1c3QgdGhlIHN1ZmZpeCBwb3J0aW9uIG9mIHBlcmNlbnRpbGUgdmFsdWVzLlxuICpcbiAqIFRoZSBpMThuIHZhcmlhYmxlIG5hbWVkIGkxOG5PcmRpbmFsU3VmZml4LCBpbiB0aGUgSW5kaWNhdG9yVmFsdWUgZnVuY3Rpb24gZGVmaW5lcyB0aGVcbiAqIHZhcmlvdXMgcHJlZml4ZXMuIFRoZSBTcGFuaXNoIHZlcnNpb24gb2YgdGhlIGkxOG4gdmFyaWFibGUgd29ya3MgaW4gYSBzaW1pbGFyIG1hbm5lcixcbiAqIGhvd2V2ZXIgaGFzIGEgZGlmZmVyZW5jZS4gVGhlIHN1cGVyc2NyaXB0aW5nIGlzIGRpZmZlcmVudCBmb3IgU3BhbmlzaC5cbiAqIEluIFNwYW5pc2gsIHRoZSBzdWZmaXggaXMgYSBcIi5hXCIgYW5kIFwiLm9cIiwgd2hlcmUgb25seSB0aGUgXCJhXCIgYW5kIFwib1wiIGFyZSBzdXBlcnNjcmlwdGVkLlxuICogVGhpcyBmdW5jdGlvbiBoYW5kbGVzIHRoaXMgY2FzZS5cbiAqXG4gKiBWZXJiYXRpbSBmcm9tIHRyYW5zbGF0aW9uIHRlYW06XG4gKiBXZSBzdWdnZXN0IGNoYW5naW5nIHRoaXMgdG8gdGhlIFNwYW5pc2ggb3JkaW5hbCBudW1iZXIgYWJicmV2aWF0aW9uLCB3aGljaCBpcyAubyBmb3IgbWFzY3VsaW5lXG4gKiBhbmQgLmEgZm9yIGZlbWluaW5lIGdlbmRlcmVkIHdvcmRzLiAqKipTaW5jZSB0aGlzIHJhbmtpbmcgYXBwbGllcyB0byB0aGUgY29tbXVuaXRpZXMgb2YgZm9jdXMsXG4gKiB3aGljaCB1c2UgYSBmZW1pbmluZSBnZW5kZXIgaW4gU3BhbmlzaCwgd2UgcmVjb21tZW5kIHRoYXQgdGhlIHRoIG9yZGluYWwgYWJicmV2aWF0aW9uIGluIEVuZ2xpc2hcbiAqIGJlIHN1YnN0aXR1dGVkIHdpdGggdGhlIGZlbWluaW5lIG9yZGluYWwgYWJicmV2aWF0aW9uIGluIFNwYW5pc2g6IC5hICB0aHJvdWdob3V0IHRoZSB0ZXh0LlxuICogRS5nLiwgMTl0aCB3b3VsZCBiZSAxOS5hIGluIFNwYW5pc2ggYW5kIDY1dGggd291bGQgYmUgNjUuYVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbmRpY2F0b3JWYWx1ZVdpdGhTdWZmaXhcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHN1cGVyc2NyaXB0T3JkaW5hbCA9IChpbmRpY2F0b3JWYWx1ZVdpdGhTdWZmaXg6c3RyaW5nKSA9PiB7XG4gIC8vIFNwYW5pc2ggY2FzZTpcbiAgaWYgKGluZGljYXRvclZhbHVlV2l0aFN1ZmZpeC5pbmRleE9mKCcuJykgIT09IC0xKSB7XG4gICAgY29uc3Qgb3JkaW5hbFN1ZmZpeCA9IGluZGljYXRvclZhbHVlV2l0aFN1ZmZpeC5jaGFyQXQoaW5kaWNhdG9yVmFsdWVXaXRoU3VmZml4Lmxlbmd0aCAtIDEpO1xuICAgIGNvbnN0IGluZGljYXRvclZhbHVlID0gaW5kaWNhdG9yVmFsdWVXaXRoU3VmZml4LnNsaWNlKDAsIC0xKTtcblxuICAgIHJldHVybiA8PntpbmRpY2F0b3JWYWx1ZX08c3VwIHN0eWxlPXt7dG9wOiAnLTAuMmVtJ319PntvcmRpbmFsU3VmZml4fTwvc3VwPjwvPjtcbiAgfVxuXG4gIC8vIEVuZ2xpc2ggY2FzZTpcbiAgY29uc3QgdmFsdWVSZWdFeCA9IC9bMC05XXsxLDJ9LztcbiAgY29uc3Qgc3VmZml4UmVnRXggPSAvW2Etel17Mn0vOyAvLyBpZSwgKHN0LCBuZCwgcmQsIHRoKVxuICBjb25zdCBpbmRpY2F0b3JWYWx1ZSA9IHZhbHVlUmVnRXguZXhlYyhpbmRpY2F0b3JWYWx1ZVdpdGhTdWZmaXgpO1xuICBjb25zdCBvcmRpbmFsU3VmZml4ID0gc3VmZml4UmVnRXguZXhlYyhpbmRpY2F0b3JWYWx1ZVdpdGhTdWZmaXgpO1xuXG4gIHJldHVybiA8PntpbmRpY2F0b3JWYWx1ZX08c3VwIHN0eWxlPXt7dG9wOiAnLTAuMmVtJ319PntvcmRpbmFsU3VmZml4fTwvc3VwPjwvPjtcbn07XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgd2lsbCByZXR1cm4gdGhlIGluZGljYXRvcnMncyB2YWx1ZS4gVGhlIHZhbHVlIGRlcGVuZHMgb24gdGhlXG4gKiBpbmRpY2F0b3IgdHlwZS4gRWFjaCB0eXBlIHJlbmRlcnMgYSBkaWZmZXJlbnQgVUkuXG4gKlxuICogQHJldHVybiB7SlNYLkVsZW1lbnQgfCBudWxsfVxuICovXG5leHBvcnQgY29uc3QgSW5kaWNhdG9yVmFsdWUgPSAoe3R5cGUsIGRpc3BsYXlTdGF0fTpJSW5kaWNhdG9yVmFsdWUpID0+IHtcbiAgY29uc3QgaW50bCA9IHVzZUludGwoKTtcblxuICBpZiAoZGlzcGxheVN0YXQgPT09IG51bGwpIHJldHVybiA8Pntjb25zdGFudHMuTUlTU0lOR19EQVRBX1NUUklOR308Lz47XG5cbiAgaWYgKHR5cGUgPT09ICdwZXJjZW50JyB8fCB0eXBlID09PSAncGVyY2VudGlsZScpIHtcbiAgICAvLyBJbiB0aGlzIGNhc2Ugd2Ugd2lsbCBzaG93IG5vIHZhbHVlIGFuZCBhbiBpY29uIG9ubHlcblxuICAgIGlmICh0eXBlID09PSAncGVyY2VudCcpIHtcbiAgICAgIC8vIElmIHRoZSB0eXBlIGlzIHBlcmNlbnQsIHJldHVybiB0aGUgaW50bCBwZXJjZW50IGZvcm1hdFxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPHNwYW4+XG4gICAgICAgICAge2ludGwuZm9ybWF0TnVtYmVyKFxuICAgICAgICAgICAgICBkaXNwbGF5U3RhdCxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0eWxlOiAndW5pdCcsXG4gICAgICAgICAgICAgICAgdW5pdDogJ3BlcmNlbnQnLFxuICAgICAgICAgICAgICAgIHVuaXREaXNwbGF5OiAnc2hvcnQnLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICl9XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgdHlwZSBpcyBwZXJjZW50aWxlLCBjcmVhdGUgdGhlIGludGwgb3JkaW5hbCBhbmQgcmV0dXJuIGl0IGFzIGEgc3VwZXJzY3JpcHRcbiAgICAgIGNvbnN0IGkxOG5PcmRpbmFsU3VmZml4OiBzdHJpbmcgPSBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQ6ICdleHBsb3JlLm1hcC5wYWdlLnNpZGUucGFuZWwuaW5kaWNhdG9yLnBlcmNlbnRpbGUudmFsdWUub3JkaW5hbC5zdWZmaXgnLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgTmF2aWdhdGUgdG8gdGhlIGV4cGxvcmUgdGhlIHRvb2wgcGFnZS4gQ2xpY2sgb24gdGhlIG1hcC4gVGhlIHNpZGUgcGFuZWwgd2lsbCBzaG93IGNhdGVnb3JpZXMuIE9wZW4gYSBjYXRlZ29yeS4gVGhpcyB3aWxsIGRlZmluZSB0aGUgaW5kaWNhdG9yIHZhbHVlJ3Mgb3JkaW5hbCBzdWZmaXguIEZvciBleGFtcGxlIHRoZSBzdCBpbiA5MXN0LCB0aGUgcmQgaW4gMjNyZCwgYW5kIHRoZSB0aCBpbiAyNnRoLCBldGMuYCxcbiAgICAgICAgICAgIGRlZmF1bHRNZXNzYWdlOiBgXG4gICAgICAgIHtpbmRpY2F0b3JWYWx1ZSwgc2VsZWN0b3JkaW5hbCwgXG4gICAgICAgICAgb25lIHsjc3R9IFxuICAgICAgICAgIHR3byB7I25kfVxuICAgICAgICAgIGZldyB7I3JkfSBcbiAgICAgICAgICBvdGhlciB7I3RofVxuICAgICAgICB9XG4gICAgICAgIGAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbmRpY2F0b3JWYWx1ZTogZGlzcGxheVN0YXQsXG4gICAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICByZXR1cm4gc3VwZXJzY3JpcHRPcmRpbmFsKGkxOG5PcmRpbmFsU3VmZml4KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gd2hlbiB0aGUgdHlwZSA9PT0gYm9vbGVhbiB0aGUgZGlzcGxheSBzdGF0IHdpbGwgYmUgZWl0aGVyIDEwMCAodHJ1ZSkgb3IgMCAoZmFsc2UpXG4gICAgcmV0dXJuIGRpc3BsYXlTdGF0ID09PSAwID9cbiAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX1NQQUNFUlMuTk8gOlxuICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfU1BBQ0VSUy5ZRVM7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgd2lsbCByZXR1cm4gdGhlIGxpc3QgZWxlbWVudCB3aGljaCB3aWxsIGJlIHRoZSBpbmRpY2F0b3Igcm93IGluIHRoZSBzaWRlIHBhbmVsXG4gKlxuICogQHBhcmFtIHtJSW5kaWNhdG9yfSBpbmRpY2F0b3JcbiAqIEByZXR1cm4ge0pTWC5FbGVtZW50fVxuICovXG5jb25zdCBJbmRpY2F0b3IgPSAoe2luZGljYXRvciwgaXNJbXB1dGUsIHBvcHVsYXRpb259OklJbmRpY2F0b3IpID0+IHtcbiAgLyoqXG4gICAqIFRoZSBpbmRpY2F0b3IgdmFsdWUgY291bGQgYmUgYSBudW1iZXIgfCBib29sZWFuIHwgbnVsbC4gSW4gYWxsIGNhc2VzIHdlIGNvZXJjZSB0byBudW1iZXJcbiAgICogYmVmb3JlIGZsb29yaW5nLlxuICAgKlxuICAgKiBJbiB0aGUgY2FzZSB3aGVyZSBpbmRpY2F0b3IudmFsdWUgaXMgYSBib29sZWFuLCB0aGUgZGlzcGxheVN0YXQgd2lsbCBiZSBlaXRoZXIgMTAwIG9yIDAsIGRlcGVuZGluZ1xuICAgKiBvbiBpZiBpbmRpY2F0b3IudmFsdWUgaXMgdHJ1ZSBvciBmYWxzZSByZXNwZWN0aXZlbHkuXG4gICAqXG4gICAqIFRvZG86IFRoZSB3YXkgdGhlIGRpc3BsYXlTdGF0IGhhbmRsZXMgdGhlIGJvb2xlYW4gaW5kaWNhdG9ycyBzaG91bGQgYmUgcmVmYWN0b3JlZFxuICAgKi9cbiAgY29uc3QgZGlzcGxheVN0YXQgPSBpbmRpY2F0b3IudmFsdWUgIT09IG51bGwgPyBNYXRoLmZsb29yKE51bWJlcihpbmRpY2F0b3IudmFsdWUpICogMTAwKSA6IG51bGw7XG5cbiAgLy8gSWYgdGhlIHRocmVzaG9sZCBleGlzdHMsIHNldCBpdCwgb3RoZXJ3aXNlIHNldCBpdCB0byB0aGUgZGVmYXVsdCB2YWx1ZVxuICBjb25zdCB0aHJlc2hvbGQgPSBpbmRpY2F0b3IudGhyZXNob2xkID8gaW5kaWNhdG9yLnRocmVzaG9sZCA6IGNvbnN0YW50cy5ERUZBVUxUX1RIUkVTSE9MRF9QRVJDRU5USUxFO1xuXG4gIC8vIEEgYm9vbGVhbiB0byByZXByZXNlbnQgaWYgdGhlIGluZGljYXRvciBpcyBhYm92ZSBvciBiZWxvdyB0aGUgdGhyZXNob2xkXG4gIGNvbnN0IGlzQWJvdmVUaHJlc2ggPSBkaXNwbGF5U3RhdCAhPT0gbnVsbCAmJiBkaXNwbGF5U3RhdCA+PSB0aHJlc2hvbGQgPyB0cnVlIDogZmFsc2U7XG5cbiAgLy8gU2hvdyBhbiBpbmZvIGljb24gb24gdGhlIGxvdyBpY29tZSBpbmRpY2F0b3IgaWY6XG4gIGNvbnN0IHNob3dMb3dJbmNvbWVJbmZvSWNvbiA9IChcbiAgICAoaW5kaWNhdG9yLmxhYmVsID09PSAnTG93IGluY29tZScgJiYgKGlzSW1wdXRlKSkgfHxcbiAgICAoaW5kaWNhdG9yLmxhYmVsID09PSAnTG93IGluY29tZScgJiYgcG9wdWxhdGlvbiA9PT0gY29uc3RhbnRzLk1JU1NJTkdfREFUQV9TVFJJTkcgJiYgIWlzSW1wdXRlKVxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPGxpXG4gICAgICBjbGFzc05hbWU9e3N0eWxlcy5pbmRpY2F0b3JCb3hNYWlufVxuICAgICAgZGF0YS1jeT17J2luZGljYXRvckJveCd9XG4gICAgICBkYXRhLXRlc3RpZD0naW5kaWNhdG9yLWJveCc+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmluZGljYXRvclJvd30+XG5cbiAgICAgICAgey8qIEluZGljYXRvciBuYW1lIGFuZCBkZXNjcmlwdGlvbiovfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmluZGljYXRvck5hbWV9PlxuICAgICAgICAgIHtpbmRpY2F0b3IubGFiZWx9XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5pbmRpY2F0b3JEZXNjfT5cbiAgICAgICAgICAgIHtpbmRpY2F0b3IuZGVzY3JpcHRpb259XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIHsvKiBJbmRpY2F0b3IgdmFsdWUsIGljb24gYW5kIHN1YnRleHQgKi99XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaW5kaWNhdG9yVmFsdWVDb2x9PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaW5kaWNhdG9yVmFsdWVSb3d9PlxuXG4gICAgICAgICAgICB7LyogSW5kaWNhdG9yIGluZm8gaWNvbiAqL31cbiAgICAgICAgICAgIHsgc2hvd0xvd0luY29tZUluZm9JY29uICYmXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaW5kaWNhdG9ySW5mb30+XG4gICAgICAgICAgICAgICAgPEluZGljYXRvckluZm9JY29uXG4gICAgICAgICAgICAgICAgICBpc0ltcHV0ZT17aXNJbXB1dGV9XG4gICAgICAgICAgICAgICAgICBwb3B1bGF0aW9uPXtwb3B1bGF0aW9ufVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB7LyogSW5kaWNhdG9yIHZhbHVlICovfVxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2luZGljYXRvci5pc0Rpc2FkdmFndGFnZWQgP1xuICAgICAgICAgICAgICBzdHlsZXMuZGlzSW5kaWNhdG9yVmFsdWUgOiBzdHlsZXMuaW5kaWNhdG9yVmFsdWV9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxJbmRpY2F0b3JWYWx1ZVxuICAgICAgICAgICAgICAgIHR5cGU9e2luZGljYXRvci50eXBlfVxuICAgICAgICAgICAgICAgIGRpc3BsYXlTdGF0PXtkaXNwbGF5U3RhdH1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICB7LyogSW5kaWNhdG9yIHN1Yi10ZXh0ICovfVxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaW5kaWNhdG9yVmFsdWVTdWJUZXh0fT5cbiAgICAgICAgICAgIDxJbmRpY2F0b3JWYWx1ZVN1YlRleHRcbiAgICAgICAgICAgICAgdmFsdWU9e2Rpc3BsYXlTdGF0fVxuICAgICAgICAgICAgICBpc0Fib3ZlVGhyZXNoPXtpc0Fib3ZlVGhyZXNofVxuICAgICAgICAgICAgICB0aHJlc2hvbGQ9e3RocmVzaG9sZH1cbiAgICAgICAgICAgICAgdHlwZT17aW5kaWNhdG9yLnR5cGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9saT5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEluZGljYXRvcjtcbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHZhciBkb251dENvcHlDb250YWluZXIgPSBcIkRvbnV0Q29weS1tb2R1bGUtLWRvbnV0Q29weUNvbnRhaW5lci0tclpjMm5cIjtcbmV4cG9ydCB2YXIgZG9udXRSb3cgPSBcIkRvbnV0Q29weS1tb2R1bGUtLWRvbnV0Um93LS11TUdPK1wiO1xuZXhwb3J0IHZhciBkb251dFJvd0xhYmVsID0gXCJEb251dENvcHktbW9kdWxlLS1kb251dFJvd0xhYmVsLS1IMlppeFwiO1xuZXhwb3J0IHZhciBpbnZlcnQgPSBcIkRvbnV0Q29weS1tb2R1bGUtLWludmVydC0tSXRtQ2dcIjtcbmV4cG9ydCB2YXIgbm9JbnZlcnQgPSBcIkRvbnV0Q29weS1tb2R1bGUtLW5vSW52ZXJ0LS1XZkVETlwiO1xuZXhwb3J0IHZhciBzdWJUZXh0Q29udGFpbmVyID0gXCJEb251dENvcHktbW9kdWxlLS1zdWJUZXh0Q29udGFpbmVyLS1yT0VobVwiO1xuZXhwb3J0IHZhciB2YWx1ZVN1YlRleHRDb250YWluZXIgPSBcIkRvbnV0Q29weS1tb2R1bGUtLXZhbHVlU3ViVGV4dENvbnRhaW5lci0tLW50SzBcIjsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHt1c2VJbnRsfSBmcm9tICdnYXRzYnktcGx1Z2luLWludGwnO1xuXG5pbXBvcnQge0luZGljYXRvclZhbHVlLCBJbmRpY2F0b3JWYWx1ZVN1YlRleHR9IGZyb20gJy4uL0luZGljYXRvci9JbmRpY2F0b3InO1xuXG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi9Eb251dENvcHkubW9kdWxlLnNjc3MnO1xuXG5pbXBvcnQgKiBhcyBFWFBMT1JFX0NPUFkgZnJvbSAnLi4vLi4vZGF0YS9jb3B5L2V4cGxvcmUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElEb251dENvcHlQcm9wcyB7XG4gIGlzQWRqYWNlbnQ6IGJvb2xlYW5cbiAgcG92ZXJ0eUJlbG93MjAwUGVyY2VudGlsZTogbnVtYmVyIHwgbnVsbFxufVxuXG5jb25zdCBEb251dENvcHkgPSAoe2lzQWRqYWNlbnQsIHBvdmVydHlCZWxvdzIwMFBlcmNlbnRpbGV9OiBJRG9udXRDb3B5UHJvcHMpID0+IHtcbiAgY29uc3QgaW50bCA9IHVzZUludGwoKTtcbiAgY29uc3QgcG92QmVsMjAwUGVyY2VudGlsZSA9IHBvdmVydHlCZWxvdzIwMFBlcmNlbnRpbGUgP1xuICAgIHBhcnNlRmxvYXQoKHBvdmVydHlCZWxvdzIwMFBlcmNlbnRpbGUqMTAwKS50b0ZpeGVkKCkpIDogbnVsbDtcbiAgY29uc3QgdGhyZXNob2xkID0gNTA7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmRvbnV0Q29weUNvbnRhaW5lcn0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmRvbnV0Um93fT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5kb251dFJvd0xhYmVsfT57aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5ET05VVF9DT1BZLkNPTVBfU1VSUil9PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtpc0FkamFjZW50ID8gc3R5bGVzLmludmVydCA6ICcnfT5cbiAgICAgICAgICB7aXNBZGphY2VudCA/IEVYUExPUkVfQ09QWS5DT01NVU5JVFkuT0ZfRk9DVVMgOiBFWFBMT1JFX0NPUFkuQ09NTVVOSVRZLk5PVF9PRl9GT0NVU31cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZG9udXRSb3d9PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmRvbnV0Um93TGFiZWx9PntpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLkRPTlVUX0NPUFkuQURKX0xPV19JTkMpfTwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnZhbHVlU3ViVGV4dENvbnRhaW5lcn0+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e1xuICAgICAgICAgICAgaXNBZGphY2VudCAmJiBwb3ZCZWwyMDBQZXJjZW50aWxlICYmXG4gICAgICAgICAgICBwb3ZCZWwyMDBQZXJjZW50aWxlID49IHRocmVzaG9sZCA/IHN0eWxlcy5pbnZlcnQgOiBzdHlsZXMubm9JbnZlcnR9PlxuICAgICAgICAgICAgPEluZGljYXRvclZhbHVlXG4gICAgICAgICAgICAgIHR5cGU9eydwZXJjZW50aWxlJ31cbiAgICAgICAgICAgICAgZGlzcGxheVN0YXQ9e3BvdkJlbDIwMFBlcmNlbnRpbGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuc3ViVGV4dENvbnRhaW5lcn0+XG4gICAgICAgICAgICA8SW5kaWNhdG9yVmFsdWVTdWJUZXh0XG4gICAgICAgICAgICAgIHZhbHVlPXtwb3ZCZWwyMDBQZXJjZW50aWxlfVxuICAgICAgICAgICAgICBpc0Fib3ZlVGhyZXNoPXtwb3ZCZWwyMDBQZXJjZW50aWxlICYmIHBvdkJlbDIwMFBlcmNlbnRpbGUgPj0gdGhyZXNob2xkID8gdHJ1ZSA6IGZhbHNlfVxuICAgICAgICAgICAgICB0aHJlc2hvbGQ9e3RocmVzaG9sZH1cbiAgICAgICAgICAgICAgdHlwZT17J3BlcmNlbnRpbGUnfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERvbnV0Q29weTtcbiIsImltcG9ydCBEb251dENvcHkgZnJvbSAnLi9Eb251dENvcHknO1xuZXhwb3J0IGRlZmF1bHQgRG9udXRDb3B5O1xuIiwiaW1wb3J0IEluZGljYXRvciBmcm9tICcuL0luZGljYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IEluZGljYXRvcjtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCAqIGFzIEVYUExPUkVfQ09QWSBmcm9tICcuLi8uLi9kYXRhL2NvcHkvZXhwbG9yZSc7XG5cbmludGVyZmFjZSBJUHJpb3JpdGl6YXRpb25Db3B5IHtcbiAgdG90YWxDYXRlZ29yaWVzUHJpb3JpdGl6ZWQ6IG51bWJlclxuICB0b3RhbEJ1cmRlbnNQcmlvcml0aXplZDogbnVtYmVyXG4gIGlzQWRqYWNlbmN5VGhyZXNoTWV0OiBib29sZWFuLFxuICBpc0FkamFjZW5jeUxvd0luY29tZTogYm9vbGVhbixcbiAgaXNJc2xhbmRMb3dJbmNvbWU6IGJvb2xlYW4sXG4gIGlzR3JhbmRmYXRoZXJlZDogYm9vbGVhbixcbiAgdHJpYmFsQ291bnRBSzogbnVtYmVyIHwgbnVsbCxcbiAgdHJpYmFsQ291bnRVUzogbnVsbCwgLy8gd2hlbiB0aGlzIHNpZ25hbCBpcyBzdXBwb3J0ZWQgYWRkIG51bWJlciB0eXBlXG4gIHBlcmNlbnRUcmFjdFRyaWJhbDogbnVtYmVyIHwgbnVsbFxufTtcblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCByZXR1cm5zIHRoZSBwcmlvcml0emF0aW9uIGNvcHkuXG4gKlxuICogVGhlIHRydXRoIHRhYmxlIHRoYXQgdHJhY2tzIGFsbCB0aGUgc3RhdGVzIGZvciB0aGlzIGxvZ2ljIGlzIGNhcHR1cmVkIGluIHRoZSBzaGFyZWQgZG9jXG4gKiBjYWxsZWQgXCJJbmRpY2F0b3JzIGZvciBVSSBhbmQgQkUgU2lnbmFsc1wiLiBUaGUgU2hlZXQgaXMgY2FsbGVkIFwiRGlzYWR2IENvcHkgdjQgcDFcIi4gVGhpc1xuICogc3ByZWFkc2hlZXQgaXMgYSBnaWFudCB0cnV0aCB0YWJsZSB3aXRoIGFsbCBwb3NzaWJsZSBCRSBzaWduYWwgY29tYmluYXRpb25zIGFuZCB3aGF0IHRoZVxuICogYXBwcm9wcHJpYXRlIGNvcHkgc2hvdWxkIGJlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbENhdGVnb3JpZXNQcmlvcml0aXplZFxuICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsQnVyZGVuc1ByaW9yaXRpemVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzQWRqYWNlbmN5VGhyZXNoTWV0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzQWRqYWNlbmN5TG93SW5jb21lXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzSXNsYW5kTG93SW5jb21lXG4gKiBAcGFyYW0ge251bWJlciB8IG51bGx9IHRyaWJhbENvdW50QUtcbiAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbH0gdHJpYmFsQ291bnRVU1xuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBwZXJjZW50VHJhY3RUcmliYWxcbiAqIEByZXR1cm4ge0pTWH1cbiAqL1xuY29uc3QgUHJpb3JpdGl6YXRpb25Db3B5ID1cbiAgICh7dG90YWxDYXRlZ29yaWVzUHJpb3JpdGl6ZWQsXG4gICAgIHRvdGFsQnVyZGVuc1ByaW9yaXRpemVkLFxuICAgICBpc0FkamFjZW5jeVRocmVzaE1ldCxcbiAgICAgaXNBZGphY2VuY3lMb3dJbmNvbWUsXG4gICAgIGlzR3JhbmRmYXRoZXJlZCxcbiAgICAgaXNJc2xhbmRMb3dJbmNvbWUsXG4gICAgIHRyaWJhbENvdW50QUssXG4gICAgIHRyaWJhbENvdW50VVMsXG4gICAgIHBlcmNlbnRUcmFjdFRyaWJhbCxcbiAgIH06SVByaW9yaXRpemF0aW9uQ29weSkgPT4ge1xuICAgICBsZXQgcHJpb0NvcHlSZW5kZXJlZCA9IG51bGw7XG5cbiAgICAgaWYgKGlzR3JhbmRmYXRoZXJlZCkge1xuICAgICAgIHByaW9Db3B5UmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuUFJJT1JJVElaQVRJT05fQ09QWS5QUklPX0dSQU5ERkFUSEVSRURfTEk7XG4gICAgIC8vIGlmIDFcbiAgICAgfSBlbHNlIGlmICh0b3RhbENhdGVnb3JpZXNQcmlvcml0aXplZCA9PT0gMCkge1xuICAgICAgIC8vIGlmIDEtMVxuICAgICAgIGlmIChpc0FkamFjZW5jeVRocmVzaE1ldCAmJiBpc0FkamFjZW5jeUxvd0luY29tZSkge1xuICAgICAgICAgcHJpb0NvcHlSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5QUklPUklUSVpBVElPTl9DT1BZLlBSSU9fU1VSUl9MSTtcbiAgICAgICAgIC8vIGlmIDEtMlxuICAgICAgIH0gZWxzZSBpZiAoaXNJc2xhbmRMb3dJbmNvbWUpIHtcbiAgICAgICAgIHByaW9Db3B5UmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuUFJJT1JJVElaQVRJT05fQ09QWS5QUklPX0lTTEFORF9MSTtcbiAgICAgICAgIC8vIGlmIDEtM1xuICAgICAgIH0gZWxzZSBpZiAoaXNBZGphY2VuY3lUaHJlc2hNZXQgJiYgIWlzQWRqYWNlbmN5TG93SW5jb21lKSB7XG4gICAgICAgICAvLyBpZiAxLTItMVxuICAgICAgICAgaWYgKCB0cmliYWxDb3VudEFLID09PSBudWxsICYmIHRyaWJhbENvdW50VVMgPT09IG51bGwpIHtcbiAgICAgICAgICAgLy8gaWYgMS0yLTEtMVxuICAgICAgICAgICBpZiAocGVyY2VudFRyYWN0VHJpYmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgcHJpb0NvcHlSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5QUklPUklUSVpBVElPTl9DT1BZLk5PVF9QUklPX1NVUlJfTEk7XG4gICAgICAgICAgICAgLy8gaWYgMS0yLTEtMlxuICAgICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnRUcmFjdFRyaWJhbCA9PT0gMCkge1xuICAgICAgICAgICAgIHByaW9Db3B5UmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuUFJJT1JJVElaQVRJT05fQ09QWS5QQVJfUFJJT19TVVJSX05PX0xJO1xuICAgICAgICAgICAgIC8vIGlmIDEtMi0xLTNcbiAgICAgICAgICAgfSBlbHNlIGlmIChwZXJjZW50VHJhY3RUcmliYWwgPj0gMSkge1xuICAgICAgICAgICAgIHByaW9Db3B5UmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuUFJJT1JJVElaQVRJT05fQ09QWS5QQVJfUFJJT19TVVJSX05PX0xJO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIC8vIGlmIDEtMi0yXG4gICAgICAgICB9IGVsc2UgaWYgKHRyaWJhbENvdW50QUsgIT09IG51bGwgJiYgdHJpYmFsQ291bnRBSyA+PSAxKSB7XG4gICAgICAgICAgIHByaW9Db3B5UmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuUFJJT1JJVElaQVRJT05fQ09QWS5QQVJfUFJJT19TVVJSX05PX0xJO1xuICAgICAgICAgfVxuICAgICAgICAgLy8gaWYgMS0zXG4gICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICEoaXNBZGphY2VuY3lUaHJlc2hNZXQgJiYgaXNBZGphY2VuY3lMb3dJbmNvbWUpICYmXG4gICAgICAgICAgdHJpYmFsQ291bnRBSyA9PT0gbnVsbCAmJlxuICAgICAgICAgIHRyaWJhbENvdW50VVMgPT09IG51bGwgJiZcbiAgICAgICAgICBwZXJjZW50VHJhY3RUcmliYWwgPT09IG51bGxcbiAgICAgICApIHtcbiAgICAgICAgIC8vIGlmIDEtMy0xXG4gICAgICAgICBpZiAodG90YWxCdXJkZW5zUHJpb3JpdGl6ZWQgPT09IDApIHtcbiAgICAgICAgICAgcHJpb0NvcHlSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5QUklPUklUSVpBVElPTl9DT1BZLk5PVF9QUklPO1xuICAgICAgICAgICAvLyBpZiAxLTMtMlxuICAgICAgICAgfSBlbHNlIGlmICh0b3RhbEJ1cmRlbnNQcmlvcml0aXplZCA9PT0gMSkge1xuICAgICAgICAgICBwcmlvQ29weVJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLlBSSU9SSVRJWkFUSU9OX0NPUFkuTk9UX1BSSU9fMUJVUjtcbiAgICAgICAgICAgLy8gaWYgMS0zLTNcbiAgICAgICAgIH0gZWxzZSBpZiAodG90YWxCdXJkZW5zUHJpb3JpdGl6ZWQgPiAxKSB7XG4gICAgICAgICAgIHByaW9Db3B5UmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuUFJJT1JJVElaQVRJT05fQ09QWS5OT1RfUFJJT19OQlVSO1xuICAgICAgICAgfVxuICAgICAgICAgLy8gaWYgMS00XG4gICAgICAgfSBlbHNlIGlmICghKGlzQWRqYWNlbmN5VGhyZXNoTWV0ICYmIGlzQWRqYWNlbmN5TG93SW5jb21lKSkge1xuICAgICAgICAgLy8gaWYgMS00LTFcbiAgICAgICAgIGlmIChcbiAgICAgICAgICAgKHRyaWJhbENvdW50QUsgIT09IG51bGwgJiYgdHJpYmFsQ291bnRBSyA+PSAxKSAmJlxuICAgICAgICAodHJpYmFsQ291bnRVUyAhPT0gbnVsbCAmJiB0cmliYWxDb3VudFVTID49IDEpXG4gICAgICAgICApIHtcbiAgICAgICAgICAgcHJpb0NvcHlSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5nZXRQcmlvQUtVU0NvcHkodHJpYmFsQ291bnRBSywgdHJpYmFsQ291bnRVUyk7XG4gICAgICAgICAgIC8vIGlmIDEtNC0yXG4gICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAodHJpYmFsQ291bnRBSyAhPT0gbnVsbCAmJiB0cmliYWxDb3VudEFLID49IDEpICYmXG4gICAgICAgIHRyaWJhbENvdW50VVMgPT09IG51bGxcbiAgICAgICAgICkge1xuICAgICAgICAgICBwcmlvQ29weVJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9BTlZDb3B5KHRyaWJhbENvdW50QUspO1xuICAgICAgICAgICAvLyBpZiAxLTQtM1xuICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgKHRyaWJhbENvdW50VVMgIT09IG51bGwgJiYgdHJpYmFsQ291bnRVUyA+PSAxKSAmJlxuICAgICAgICB0cmliYWxDb3VudEFLID09PSBudWxsXG4gICAgICAgICApIHtcbiAgICAgICAgICAgaWYgKHBlcmNlbnRUcmFjdFRyaWJhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgIHByaW9Db3B5UmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuZ2V0UHJpb0ZSVFBvaW50c0NvcHkoYCR7dHJpYmFsQ291bnRVU31gKTtcbiAgICAgICAgICAgfSBlbHNlIGlmIChwZXJjZW50VHJhY3RUcmliYWwgPT09IDApIHtcbiAgICAgICAgICAgICBwcmlvQ29weVJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9GUlRDb3B5KGBsZXNzIHRoYW4gMSVgKTtcbiAgICAgICAgICAgfSBlbHNlIGlmIChwZXJjZW50VHJhY3RUcmliYWwgPj0gMSkge1xuICAgICAgICAgICAgIHByaW9Db3B5UmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuZ2V0UHJpb0ZSVENvcHkoYCR7cGVyY2VudFRyYWN0VHJpYmFsfSVgKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgLy8gMS00LTRcbiAgICAgICAgIH0gZWxzZSBpZiAodHJpYmFsQ291bnRVUyA9PT0gbnVsbCAmJiB0cmliYWxDb3VudEFLID09PSBudWxsKSB7XG4gICAgICAgICAgIGlmIChwZXJjZW50VHJhY3RUcmliYWwgPT09IDApIHtcbiAgICAgICAgICAgICBwcmlvQ29weVJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9GUlRDb3B5KGBsZXNzIHRoYW4gMSVgKTtcbiAgICAgICAgICAgfSBlbHNlIGlmIChwZXJjZW50VHJhY3RUcmliYWwgIT09IG51bGwgJiYgcGVyY2VudFRyYWN0VHJpYmFsID49IDEgKSB7XG4gICAgICAgICAgICAgcHJpb0NvcHlSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5nZXRQcmlvRlJUQ29weShgJHtwZXJjZW50VHJhY3RUcmliYWx9JWApO1xuICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICAgIC8vIGlmIDJcbiAgICAgfSBlbHNlIGlmICh0b3RhbENhdGVnb3JpZXNQcmlvcml0aXplZCA+IDApIHtcbiAgICAgICBpZiAodG90YWxCdXJkZW5zUHJpb3JpdGl6ZWQgPT09IDApIHtcbiAgICAgICB9IGVsc2UgaWYgKHRvdGFsQnVyZGVuc1ByaW9yaXRpemVkID09PSAxKSB7XG4gICAgICAgICBwcmlvQ29weVJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9OQnVyZGVuQ29weShgMWApO1xuICAgICAgIH0gZWxzZSBpZiAodG90YWxCdXJkZW5zUHJpb3JpdGl6ZWQgPiAxKSB7XG4gICAgICAgICBwcmlvQ29weVJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9OQnVyZGVuQ29weShgbW9yZSB0aGFuIDFgKTtcbiAgICAgICB9XG4gICAgIH07XG5cbiAgICAgcmV0dXJuIHByaW9Db3B5UmVuZGVyZWQgJiYgPHA+e3ByaW9Db3B5UmVuZGVyZWR9PC9wPjtcbiAgIH07XG5cbmV4cG9ydCBkZWZhdWx0IFByaW9yaXRpemF0aW9uQ29weTtcbiIsImltcG9ydCBQcmlvcml0aXphdGlvbkNvcHkgZnJvbSAnLi9Qcmlvcml0aXphdGlvbkNvcHknO1xuZXhwb3J0IGRlZmF1bHQgUHJpb3JpdGl6YXRpb25Db3B5O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0ICogYXMgRVhQTE9SRV9DT1BZIGZyb20gJy4uLy4uL2RhdGEvY29weS9leHBsb3JlJztcblxuaW50ZXJmYWNlIElQcmlvcml0aXphdGlvbkNvcHkyIHtcbiAgdG90YWxDYXRlZ29yaWVzUHJpb3JpdGl6ZWQ6IG51bWJlclxuICB0b3RhbEJ1cmRlbnNQcmlvcml0aXplZD86IG51bWJlclxuICBpc0FkamFjZW5jeVRocmVzaE1ldDogYm9vbGVhbixcbiAgaXNBZGphY2VuY3lMb3dJbmNvbWU6IGJvb2xlYW4sXG4gIHRyaWJhbENvdW50QUs6IG51bWJlciB8IG51bGwsXG4gIHRyaWJhbENvdW50VVM6IG51bGwsIC8vIHdoZW4gdGhpcyBzaWduYWwgaXMgc3VwcG9ydGVkIGFkZCBudW1iZXIgdHlwZVxuICBwZXJjZW50VHJhY3RUcmliYWw6IG51bWJlciB8IG51bGxcbn07XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgcmV0dXJucyB0aGUgcHJpb3JpdHphdGlvbiBjb3B5LlxuICpcbiAqIFRoZSB0cnV0aCB0YWJsZSBmb3IgdGhpcyBsb2dpYyBpcyBjYXB0dXJlZCBpbiB0aGUgc2hhcmVkIGRvYyBjYWxsZWQgXCJJbmRpY2F0b3JzIGZvclxuICogVUkgYW5kIEJFIFNpZ25hbHNcIi4gVGhlIFNoZWV0IG5hbWUgaXMgXCJEaXNhZHYgQ29weSBwMiB2NVwiLiBUaGlzIHNoZWV0IGlzIGEgY29weSBvZiB0aGVcbiAqIHRoZSBmdWxsIHRhYmxlIGluIFNoZWV0IFwiRGlzYWR2IENvcHkgdjQgcDFcIiwgd2hpY2ggaXMgdGhlIGZ1bGwgdHJ1dGggdGFibGUgaW4gbG9naWNhbCBvcmRlci5cbiAqIFRoZSBwMiB2NCBzaGVldCBjb3BpZXMgdGhlIGZ1bGwgdHJ1dGggdGFibGUgYW5kIHNvcnRzIGJ5IHRoZSBjb2x1bW4gJ3NlY29uZCBwYXJhZ3JhcGgnIHRvXG4gKiBmaW5kIHRoZSBhcHByb3ByaWF0ZSBsb2dpY2FsIGdyb3VwaW5nIGZvciB0aGUgc2Vjb25kIHBhcmFncmFwaC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdG90YWxDYXRlZ29yaWVzUHJpb3JpdGl6ZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbEJ1cmRlbnNQcmlvcml0aXplZFxuICogQHBhcmFtIHtib29sZWFufSBpc0FkamFjZW5jeVRocmVzaE1ldFxuICogQHBhcmFtIHtib29sZWFufSBpc0FkamFjZW5jeUxvd0luY29tZVxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSB0cmliYWxDb3VudEFLXG4gKiBAcGFyYW0ge251bWJlciB8IG51bGx9IHRyaWJhbENvdW50VVNcbiAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbH0gcGVyY2VudFRyYWN0VHJpYmFsXG4gKiBAcmV0dXJuIHtKU1h9XG4gKi9cbmNvbnN0IFByaW9yaXRpemF0aW9uQ29weTIgPVxuICAgKHt0b3RhbENhdGVnb3JpZXNQcmlvcml0aXplZCxcbiAgICAgaXNBZGphY2VuY3lUaHJlc2hNZXQsXG4gICAgIGlzQWRqYWNlbmN5TG93SW5jb21lLFxuICAgICB0cmliYWxDb3VudEFLLFxuICAgICB0cmliYWxDb3VudFVTLFxuICAgICBwZXJjZW50VHJhY3RUcmliYWwsXG4gICB9OklQcmlvcml0aXphdGlvbkNvcHkyKSA9PiB7XG4gICAgIGxldCBwcmlvQ29weTJSZW5kZXJlZCA9IG51bGw7XG5cbiAgICAgLy8gaWYgMVxuICAgICBpZiAoXG4gICAgICAgKHRvdGFsQ2F0ZWdvcmllc1ByaW9yaXRpemVkID09PSAwICYmIChpc0FkamFjZW5jeVRocmVzaE1ldCAmJiBpc0FkamFjZW5jeUxvd0luY29tZSkpIHx8XG4gICAgICAodG90YWxDYXRlZ29yaWVzUHJpb3JpdGl6ZWQgPj0gMSlcbiAgICAgKSB7XG4gICAgICAgLy8gaWYgMS0xXG4gICAgICAgaWYgKFxuICAgICAgICAgdHJpYmFsQ291bnRBSyA9PT0gbnVsbCAmJlxuICAgICAgICAodHJpYmFsQ291bnRVUyAhPT0gbnVsbCAmJiB0cmliYWxDb3VudFVTID49IDEpICYmXG4gICAgICAgIChwZXJjZW50VHJhY3RUcmliYWwgIT09IG51bGwgJiYgcGVyY2VudFRyYWN0VHJpYmFsID49IDEpXG4gICAgICAgKSB7XG4gICAgICAgICBwcmlvQ29weTJSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5nZXRQcmlvUGVyY0FuZE51bVBvaW50c0Fsc29Db3B5KGAke3BlcmNlbnRUcmFjdFRyaWJhbH0lYCwgdHJpYmFsQ291bnRVUyk7XG4gICAgICAgLy8gaWYgMS0yXG4gICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgIHRyaWJhbENvdW50QUsgPT09IG51bGwgJiZcbiAgICAgICAgdHJpYmFsQ291bnRVUyA9PT0gbnVsbCAmJlxuICAgICAgICAocGVyY2VudFRyYWN0VHJpYmFsICE9PSBudWxsICYmIHBlcmNlbnRUcmFjdFRyaWJhbCA+PSAxKVxuICAgICAgICkge1xuICAgICAgICAgcHJpb0NvcHkyUmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuZ2V0UHJpb0ZSVENvcHkoYCR7cGVyY2VudFRyYWN0VHJpYmFsfSVgLCB0cnVlKTtcbiAgICAgICAvLyBpZiAxLTNcbiAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgdHJpYmFsQ291bnRBSyA9PT0gbnVsbCAmJlxuICAgICAgICAodHJpYmFsQ291bnRVUyAhPT0gbnVsbCAmJiB0cmliYWxDb3VudFVTID49IDEpICYmXG4gICAgICAgIChwZXJjZW50VHJhY3RUcmliYWwgIT09IG51bGwgJiYgcGVyY2VudFRyYWN0VHJpYmFsID09IDApXG4gICAgICAgKSB7XG4gICAgICAgICBwcmlvQ29weTJSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5nZXRQcmlvUGVyY0FuZE51bVBvaW50c0Fsc29Db3B5KGBsZXNzIHRoYW4gMSVgLCB0cmliYWxDb3VudFVTKTtcbiAgICAgICAvLyBpZiAxLTRcbiAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgdHJpYmFsQ291bnRBSyA9PT0gbnVsbCAmJlxuICAgICAgICB0cmliYWxDb3VudFVTID09PSBudWxsICYmXG4gICAgICAgIChwZXJjZW50VHJhY3RUcmliYWwgIT09IG51bGwgJiYgcGVyY2VudFRyYWN0VHJpYmFsID09IDApXG4gICAgICAgKSB7XG4gICAgICAgICBwcmlvQ29weTJSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5nZXRQcmlvRlJUQ29weShgbGVzcyB0aGFuIDElYCwgdHJ1ZSk7XG4gICAgICAgLy8gaWYgMS01XG4gICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICh0cmliYWxDb3VudEFLICE9PSBudWxsICYmIHRyaWJhbENvdW50QUsgPj0gMSkgJiZcbiAgICAgICAgdHJpYmFsQ291bnRVUyA9PT0gbnVsbCAmJlxuICAgICAgICBwZXJjZW50VHJhY3RUcmliYWwgPT09IG51bGxcbiAgICAgICApIHtcbiAgICAgICAgIHByaW9Db3B5MlJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9BTlZDb3B5KHRyaWJhbENvdW50QUssIHRydWUpO1xuICAgICAgIC8vIGlmIDEtNlxuICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAodHJpYmFsQ291bnRBSyAhPT0gbnVsbCAmJiB0cmliYWxDb3VudEFLID49IDEpICYmXG4gICAgICAgICh0cmliYWxDb3VudFVTICE9PSBudWxsICYmIHRyaWJhbENvdW50VVMgPj0gMSlcbiAgICAgICApIHtcbiAgICAgICAgIHByaW9Db3B5MlJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9BS1VTQ29weSh0cmliYWxDb3VudEFLLCB0cmliYWxDb3VudFVTLCB0cnVlKTtcbiAgICAgICAgIC8vIGlmIDEtN1xuICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAhaXNBZGphY2VuY3lUaHJlc2hNZXQgJiYgaXNBZGphY2VuY3lMb3dJbmNvbWUgJiZcbiAgICAgICAodHJpYmFsQ291bnRBSyAhPT0gbnVsbCAmJiB0cmliYWxDb3VudEFLID49IDEpICYmXG4gICAgICAgKHBlcmNlbnRUcmFjdFRyaWJhbCAhPT0gbnVsbCAmJiBwZXJjZW50VHJhY3RUcmliYWwgPj0gMSlcbiAgICAgICApIHtcbiAgICAgICAgIHByaW9Db3B5MlJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9GUlRDb3B5KGAke3BlcmNlbnRUcmFjdFRyaWJhbH0lYCwgdHJ1ZSk7XG4gICAgICAgICAvLyBpZiAxLThcbiAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgKHRvdGFsQ2F0ZWdvcmllc1ByaW9yaXRpemVkID49IDEpICYmXG4gICAgICAgICB0cmliYWxDb3VudEFLID09IG51bGwgJiZcbiAgICAgICAgICh0cmliYWxDb3VudFVTICE9PSBudWxsICYmIHRyaWJhbENvdW50VVMgPj0gMSkgJiZcbiAgICAgICAgIHBlcmNlbnRUcmFjdFRyaWJhbCA9PSBudWxsXG4gICAgICAgKSB7XG4gICAgICAgICBwcmlvQ29weTJSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5nZXRQcmlvRlJUUG9pbnRzQ29weSh0cmliYWxDb3VudFVTLCB0cnVlKTtcbiAgICAgICAgIC8vIGlmIDEtOVxuICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICB0b3RhbENhdGVnb3JpZXNQcmlvcml0aXplZCA+PSAxICYmXG4gICAgICAgKHRyaWJhbENvdW50QUsgIT09IG51bGwgJiYgdHJpYmFsQ291bnRBSyA+PSAxKSAmJlxuICAgICAgIChwZXJjZW50VHJhY3RUcmliYWwgIT09IG51bGwgJiYgcGVyY2VudFRyYWN0VHJpYmFsID09IDApXG4gICAgICAgKSB7XG4gICAgICAgICBwcmlvQ29weTJSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5nZXRQcmlvRlJUQ29weShgbGVzcyB0aGFuIDElYCwgdHJ1ZSk7XG4gICAgICAgICAvLyBpZiAxLTEwXG4gICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgIHRvdGFsQ2F0ZWdvcmllc1ByaW9yaXRpemVkID49IDEgJiZcbiAgICAgICAodHJpYmFsQ291bnRBSyAhPT0gbnVsbCAmJiB0cmliYWxDb3VudEFLID49IDEpICYmXG4gICAgICAgKHBlcmNlbnRUcmFjdFRyaWJhbCAhPT0gbnVsbCAmJiBwZXJjZW50VHJhY3RUcmliYWwgPj0gMSlcbiAgICAgICApIHtcbiAgICAgICAgIHByaW9Db3B5MlJlbmRlcmVkID0gRVhQTE9SRV9DT1BZLmdldFByaW9GUlRDb3B5KGAke3BlcmNlbnRUcmFjdFRyaWJhbH0lYCwgdHJ1ZSk7XG4gICAgICAgfVxuICAgICAgIC8vIGlmIDJcbiAgICAgfSBlbHNlIGlmIChcbiAgICAgICB0b3RhbENhdGVnb3JpZXNQcmlvcml0aXplZCA9PT0gMCAmJlxuICAgICAgaXNBZGphY2VuY3lUaHJlc2hNZXQgJiYgIWlzQWRqYWNlbmN5TG93SW5jb21lICYmXG4gICAgICB0cmliYWxDb3VudEFLID09PSBudWxsICYmIHRyaWJhbENvdW50VVMgPT09IG51bGxcbiAgICAgKSB7XG4gICAgICAgLy8gaWYgMi0xXG4gICAgICAgaWYgKHBlcmNlbnRUcmFjdFRyaWJhbCAhPT0gbnVsbCAmJiBwZXJjZW50VHJhY3RUcmliYWwgPT0gMCkge1xuICAgICAgICAgcHJpb0NvcHkyUmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuZ2V0UHJpb0ZSVENvcHkoYGxlc3MgdGhhbiAxJWAsIGZhbHNlKTtcbiAgICAgICAgIC8vIGlmIDItMlxuICAgICAgIH0gZWxzZSBpZiAocGVyY2VudFRyYWN0VHJpYmFsICE9PSBudWxsICYmIHBlcmNlbnRUcmFjdFRyaWJhbCA+PSAxKSB7XG4gICAgICAgICBwcmlvQ29weTJSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5nZXRQcmlvRlJUQ29weShgJHtwZXJjZW50VHJhY3RUcmliYWx9JWAsIGZhbHNlKTtcbiAgICAgICB9XG4gICAgICAgLy8gaWYgMy0xXG4gICAgIH0gZWxzZSBpZiAoXG4gICAgICAgdG90YWxDYXRlZ29yaWVzUHJpb3JpdGl6ZWQgPT09IDAgJiZcbiAgICAgIChpc0FkamFjZW5jeVRocmVzaE1ldCAmJiAhaXNBZGphY2VuY3lMb3dJbmNvbWUpICYmXG4gICAgICB0cmliYWxDb3VudEFLID09PSBudWxsICYmXG4gICAgICAodHJpYmFsQ291bnRVUyAhPT0gbnVsbCAmJiB0cmliYWxDb3VudFVTID49IDEpICYmXG4gICAgICAocGVyY2VudFRyYWN0VHJpYmFsICE9PSBudWxsICYmIHBlcmNlbnRUcmFjdFRyaWJhbCA9PSAwKVxuICAgICApIHtcbiAgICAgICBwcmlvQ29weTJSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5nZXRQcmlvRlJUUG9pbnRzQ29weSh0cmliYWxDb3VudFVTLCBmYWxzZSk7XG4gICAgICAgLy8gaWYgMy0yXG4gICAgIH0gZWxzZSBpZiAoXG4gICAgICAgdG90YWxDYXRlZ29yaWVzUHJpb3JpdGl6ZWQgPT09IDAgJiZcbiAgICAgIChpc0FkamFjZW5jeVRocmVzaE1ldCAmJiAhaXNBZGphY2VuY3lMb3dJbmNvbWUpICYmXG4gICAgICB0cmliYWxDb3VudEFLID09PSBudWxsICYmXG4gICAgICAodHJpYmFsQ291bnRVUyAhPT0gbnVsbCAmJiB0cmliYWxDb3VudFVTID49IDEpICYmXG4gICAgICAocGVyY2VudFRyYWN0VHJpYmFsICE9PSBudWxsICYmIHBlcmNlbnRUcmFjdFRyaWJhbCA+PSAxKVxuICAgICApIHtcbiAgICAgICBwcmlvQ29weTJSZW5kZXJlZCA9IEVYUExPUkVfQ09QWS5nZXRQcmlvRlJUUG9pbnRzQ29weSh0cmliYWxDb3VudFVTLCBmYWxzZSk7XG4gICAgICAgLy8gaWYgMy0zXG4gICAgIH0gZWxzZSBpZiAoXG4gICAgICAgKHRvdGFsQ2F0ZWdvcmllc1ByaW9yaXRpemVkID09PSAwICYmICEoaXNBZGphY2VuY3lUaHJlc2hNZXQgJiYgaXNBZGphY2VuY3lMb3dJbmNvbWUpKSAmJlxuICAgICAgdHJpYmFsQ291bnRBSyA9PT0gbnVsbCAmJlxuICAgICAgKHRyaWJhbENvdW50VVMgIT09IG51bGwgJiYgdHJpYmFsQ291bnRVUyA+PSAxKSAmJlxuICAgICAgKHBlcmNlbnRUcmFjdFRyaWJhbCAhPT0gbnVsbCAmJiBwZXJjZW50VHJhY3RUcmliYWwgPj0gMClcbiAgICAgKSB7XG4gICAgICAgcHJpb0NvcHkyUmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuZ2V0UHJpb0ZSVFBvaW50c0NvcHkodHJpYmFsQ291bnRVUywgdHJ1ZSk7XG4gICAgICAgLy8gaWYgNFxuICAgICB9IGVsc2UgaWYgKFxuICAgICAgIHRvdGFsQ2F0ZWdvcmllc1ByaW9yaXRpemVkID09PSAwICYmXG4gICAgICBpc0FkamFjZW5jeVRocmVzaE1ldCAmJiAhaXNBZGphY2VuY3lMb3dJbmNvbWUgJiZcbiAgICAgICh0cmliYWxDb3VudEFLICE9PSBudWxsICYmIHRyaWJhbENvdW50QUsgPj0gMSlcbiAgICAgKSB7XG4gICAgICAgcHJpb0NvcHkyUmVuZGVyZWQgPSBFWFBMT1JFX0NPUFkuZ2V0UHJpb0FOVkNvcHkodHJpYmFsQ291bnRBSywgZmFsc2UpO1xuICAgICB9XG5cbiAgICAgcmV0dXJuIHByaW9Db3B5MlJlbmRlcmVkICYmIDxwPntwcmlvQ29weTJSZW5kZXJlZH08L3A+O1xuICAgfTtcblxuZXhwb3J0IGRlZmF1bHQgUHJpb3JpdGl6YXRpb25Db3B5MjtcbiIsImltcG9ydCBQcmlvcml0aXphdGlvbkNvcHkyIGZyb20gJy4vUHJpb3JpdGl6YXRpb25Db3B5Mic7XG5leHBvcnQgZGVmYXVsdCBQcmlvcml0aXphdGlvbkNvcHkyO1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIGRlbW9ncmFwaGljSGVhZGluZyA9IFwiVHJhY3REZW1vZ3JhcGhpY3MtbW9kdWxlLS1kZW1vZ3JhcGhpY0hlYWRpbmctLUlDWWwrXCI7XG5leHBvcnQgdmFyIGRlbW9ncmFwaGljSXRlbSA9IFwiVHJhY3REZW1vZ3JhcGhpY3MtbW9kdWxlLS1kZW1vZ3JhcGhpY0l0ZW0tLTE2bVlxXCI7XG5leHBvcnQgdmFyIGRlbW9ncmFwaGljc0NvbnRhaW5lciA9IFwiVHJhY3REZW1vZ3JhcGhpY3MtbW9kdWxlLS1kZW1vZ3JhcGhpY3NDb250YWluZXItLUY4aExKXCI7XG5leHBvcnQgdmFyIGRlbW9ncmFwaGljc1RpdGxlID0gXCJUcmFjdERlbW9ncmFwaGljcy1tb2R1bGUtLWRlbW9ncmFwaGljc1RpdGxlLS1GSnRVQVwiO1xuZXhwb3J0IHZhciBzaG93SGlkZUljb24gPSBcIlRyYWN0RGVtb2dyYXBoaWNzLW1vZHVsZS0tc2hvd0hpZGVJY29uLS1Zak1vYlwiO1xuZXhwb3J0IHZhciBzaG93SGlkZVRleHQgPSBcIlRyYWN0RGVtb2dyYXBoaWNzLW1vZHVsZS0tc2hvd0hpZGVUZXh0LS1WUkh2TFwiOyIsImltcG9ydCBSZWFjdCwge3VzZVN0YXRlfSBmcm9tICdyZWFjdCc7XG5cbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBleHBhbmRJY29uIGZyb20gJy9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL2V4cGFuZF9tb3JlLnN2Zyc7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgY29sbGFwc2VJY29uIGZyb20gJy9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL2V4cGFuZF9sZXNzLnN2Zyc7XG5cbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuL1RyYWN0RGVtb2dyYXBoaWNzLm1vZHVsZS5zY3NzJztcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi8uLi9kYXRhL2NvbnN0YW50cyc7XG5pbXBvcnQgKiBhcyBFWFBMT1JFX0NPUFkgZnJvbSAnLi4vLi4vZGF0YS9jb3B5L2V4cGxvcmUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElUcmFjdERlbW9ncmFwaGljc1Byb3BzIHtcbiAgcHJvcGVydGllczogY29uc3RhbnRzLko0MFByb3BlcnRpZXNcbn1cblxuaW50ZXJmYWNlIElEZW1vZ3JhcGhpY3NEYXRhIHtcbiAgcmFjZTogW1JlYWN0LlJlYWN0RWxlbWVudCwgbnVtYmVyXVtdLFxuICBhZ2U6IFtSZWFjdC5SZWFjdEVsZW1lbnQsIG51bWJlcl1bXSxcbn1cblxuaW50ZXJmYWNlIElKNDBBY2NvcmRpb25JdGVtIHtcbiAgaWQ6IHN0cmluZyxcbiAgdGl0bGU6IFJlYWN0LlJlYWN0RWxlbWVudCxcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0RWxlbWVudFxufVxuXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGNyZWF0ZSB0aGUgY3VzdG9tIEFjY29yZGlvbiBpdGVtLiBUaGlzIHdpbGwgYmUgdXNlZFxuICogZm9yIHRoZSByYWNlIGFuZCBhZ2UgZGVtb2dyYXBoaWMgVUkgZWxlbWVudHNcbiAqXG4gKiBAcGFyYW0ge0lKNDBBY2NvcmRpb25JdGVtfSBwcm9wc1xuICogQHJldHVybiB7SlNYLkVsZW1lbnR9XG4gKi9cbmNvbnN0IEo0MEFjY29yZGlvbkl0ZW0gPSAoe2lkLCB0aXRsZSwgY2hpbGRyZW59OklKNDBBY2NvcmRpb25JdGVtKSA9PiB7XG4gIGNvbnN0IFtpc0V4cGFuZGVkLCBzZXRJc0V4cGFuZGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGg2IGNsYXNzTmFtZT17c3R5bGVzLmRlbW9ncmFwaGljSGVhZGluZ30+XG4gICAgICAgIHt0aXRsZX1cbiAgICAgICAgPHNwYW4+XG4gICAgICAgICAgeycoJ31cbiAgICAgICAgICA8YVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuc2hvd0hpZGVUZXh0ID8gYHVzYS1saW5rICR7c3R5bGVzLnNob3dIaWRlVGV4dH1gIDogYHVzYS1saW5rYH1cbiAgICAgICAgICAgIGlkPXtgJHtpZH0taGVhZGVyYH1cbiAgICAgICAgICAgIGFyaWEtY29udHJvbHM9e2Ake2lkfS1wYW5lbGB9XG4gICAgICAgICAgICBhcmlhLWV4cGFuZGVkPXtpc0V4cGFuZGVkfVxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0SXNFeHBhbmRlZCghaXNFeHBhbmRlZCl9XG4gICAgICAgICAgICB0YWJJbmRleD17MH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7aXNFeHBhbmRlZCA/XG4gICAgICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9ERU1PR1JBUEhJQ1MuSElERV9ERU1PR1JBUEhJQ1MgOlxuICAgICAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfREVNT0dSQVBISUNTLlNIT1dfREVNT0dSQVBISUNTfVxuICAgICAgICAgIDwvYT5cbiAgICAgICAgICB7IGlzRXhwYW5kZWQgP1xuICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnNob3dIaWRlSWNvbn1cbiAgICAgICAgICAgIHNyYz17Y29sbGFwc2VJY29ufVxuICAgICAgICAgICAgYWx0PXsnY29sbGFwc2UgaWNvbid9XG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRJc0V4cGFuZGVkKCFpc0V4cGFuZGVkKX1cbiAgICAgICAgICAvPiA6XG4gICAgICAgICAgPGltZ1xuICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuc2hvd0hpZGVJY29ufVxuICAgICAgICAgICAgc3JjPXtleHBhbmRJY29ufVxuICAgICAgICAgICAgYWx0PXsnZXhwYW5kIGljb24nfVxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0SXNFeHBhbmRlZCghaXNFeHBhbmRlZCl9XG4gICAgICAgICAgLz5cbiAgICAgICAgICB9XG4gICAgICAgICAgeycpJ31cbiAgICAgICAgPC9zcGFuPlxuXG4gICAgICA8L2g2PlxuXG4gICAgICA8c2VjdGlvblxuICAgICAgICBpZD17YCR7aWR9LXBhbmVsYH1cbiAgICAgICAgYXJpYS1sYWJlbGxlZGJ5PXtgJHtpZH0taGVhZGVyYH1cbiAgICAgICAgaGlkZGVuPXshaXNFeHBhbmRlZH1cbiAgICAgID57Y2hpbGRyZW59PC9zZWN0aW9uPlxuICAgIDwvPlxuICApO1xufTtcblxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBjcmVhdGUgZWFjaCBsaW5lIGl0ZW0gb24gdGhlIGxpc3Qgb2YgZGVtb2dyYXBoaWNzXG4gKlxuICogQHBhcmFtIHtbXX0gZGVtb2dyYXBoaWNEYXRhXG4gKiBAcmV0dXJuIHtKU1guRWxlbWVudH1cbiAqL1xuY29uc3QgZGVtb2dyYXBoaWNJdGVtR2VuID0gKGRlbW9ncmFwaGljRGF0YTogW10pID0+IHtcbiAgcmV0dXJuIGRlbW9ncmFwaGljRGF0YS5tYXAoKGVsLCBpbmRleCkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGtleT17aW5kZXh9IGNsYXNzTmFtZT17c3R5bGVzLmRlbW9ncmFwaGljSXRlbX0+XG4gICAgICAgIDxzcGFuPnsgZWxbMF0gfTwvc3Bhbj5cbiAgICAgICAge3R5cGVvZiBlbFsxXSA9PT0gJ251bWJlcicgP1xuICAgICAgICA8c3Bhbj57YCR7ZWxbMV19JWB9PC9zcGFuPiA6XG4gICAgICAgIDxzcGFuPntgJHtlbFsxXX1gfTwvc3Bhbj4gfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgbnVtZXJpYyB2YWx1ZSBvZiBlYWNoIGRlbW9ncmFwaGljLiBUYWtpbmcgaW50b1xuICogYWNjb3VudCBjYXNlcyB3aGVuIHRoZSBkYXRhIGlzIHVuZGVmaW5lZCBvciBpcyBudWxsXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuY29uc3QgZGlzcGxheVN0YXQgPSAoc3RhdDogbnVtYmVyKSA9PiB7XG4gIGlmIChzdGF0ID09PSB1bmRlZmluZWQgfHwgc3RhdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnLS0nO1xuICB9IGVsc2UgaWYgKHN0YXQgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBOdW1iZXIoTWF0aC5mbG9vcihzdGF0ICogMTAwKSk7XG59O1xuXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGNyZWF0ZSB0aGUgZGF0YSBzdHJ1Y3R1cmUgZm9yIHRoZSBkZW1vZ3JhcGhpY3MgZGF0YVxuICpcbiAqIEBwYXJhbSB7Y29uc3RhbnRzLko0MFByb3BlcnRpZXN9IHByb3BlcnRpZXNcbiAqIEByZXR1cm4ge0lEZW1vZ3JhcGhpY3NEYXRhfVxuICovXG5jb25zdCBnZXREZW1vZ3JhcGhpY3NEYXRhID0gKHByb3BlcnRpZXM6Y29uc3RhbnRzLko0MFByb3BlcnRpZXMpOklEZW1vZ3JhcGhpY3NEYXRhID0+IChcbiAge1xuICAgIHJhY2U6IFtcbiAgICAgIFtcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfREVNT0dSQVBISUNTLkRFTU9fTk9OX0hJU1BBTklDX1dISVRFLFxuICAgICAgICBkaXNwbGF5U3RhdChwcm9wZXJ0aWVzW2NvbnN0YW50cy5ERU1PX05PTl9ISVNQQU5JQ19XSElURV0pLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfREVNT0dSQVBISUNTLkRFTU9fQkxBQ0ssXG4gICAgICAgIGRpc3BsYXlTdGF0KHByb3BlcnRpZXNbY29uc3RhbnRzLkRFTU9fQkxBQ0tdKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0RFTU9HUkFQSElDUy5ERU1PX0FNRVJJQ0FOX0lORElBTixcbiAgICAgICAgZGlzcGxheVN0YXQocHJvcGVydGllc1tjb25zdGFudHMuREVNT19BTUVSSUNBTl9JTkRJQU5dKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0RFTU9HUkFQSElDUy5ERU1PX0FTSUFOLFxuICAgICAgICBkaXNwbGF5U3RhdChwcm9wZXJ0aWVzW2NvbnN0YW50cy5ERU1PX0FTSUFOXSksXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9ERU1PR1JBUEhJQ1MuREVNT19IQVdBSUlBTixcbiAgICAgICAgZGlzcGxheVN0YXQocHJvcGVydGllc1tjb25zdGFudHMuREVNT19IQVdBSUlBTl0pLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfREVNT0dSQVBISUNTLkRFTU9fT1RIRVJfUkFDRSxcbiAgICAgICAgZGlzcGxheVN0YXQocHJvcGVydGllc1tjb25zdGFudHMuREVNT19PVEhFUl9SQUNFXSksXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9ERU1PR1JBUEhJQ1MuREVNT19UV09fT1JfTU9SRV9SQUNFUyxcbiAgICAgICAgZGlzcGxheVN0YXQocHJvcGVydGllc1tjb25zdGFudHMuREVNT19UV09fT1JfTU9SRV9SQUNFU10pLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfREVNT0dSQVBISUNTLkRFTU9fSElTUEFOSUMsXG4gICAgICAgIGRpc3BsYXlTdGF0KHByb3BlcnRpZXNbY29uc3RhbnRzLkRFTU9fSElTUEFOSUNdKSxcbiAgICAgIF0sXG4gICAgXSxcbiAgICBhZ2U6IFtcbiAgICAgIFtcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfREVNT0dSQVBISUNTLkRFTU9fQUdFX1VOREVSXzEwLFxuICAgICAgICBkaXNwbGF5U3RhdChwcm9wZXJ0aWVzW2NvbnN0YW50cy5ERU1PX0FHRV9VTkRFUl8xMF0pLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfREVNT0dSQVBISUNTLkRFTU9fQUdFX01JRCxcbiAgICAgICAgZGlzcGxheVN0YXQocHJvcGVydGllc1tjb25zdGFudHMuREVNT19BR0VfTUlEXSksXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9ERU1PR1JBUEhJQ1MuREVNT19BR0VfT1ZFUl82NSxcbiAgICAgICAgZGlzcGxheVN0YXQocHJvcGVydGllc1tjb25zdGFudHMuREVNT19BR0VfT1ZFUl82NF0pLFxuICAgICAgXSxcbiAgICBdLFxuICB9KTtcblxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIG1haW4gY29tcG9uZW50IGZvciB0aGlzIGZpbGUuIEl0IGFjY2VwdHMgdGhlIHNlbGVjdGVkIGZlYXR1cmVcbiAqIGFzIGEgcHJvcCBhbmQgcmV0dXJuIHRoZSBkZW1vZ3JhcGhpY3MgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7SVRyYWN0RGVtb2dyYXBoaWNzUHJvcHN9IHByb3BzXG4gKiBAcmV0dXJuIHtKU1guRWxlbWVudH1cbiAqL1xuY29uc3QgVHJhY3REZW1vZ3JhcGhpY3MgPSAoe3Byb3BlcnRpZXN9OiBJVHJhY3REZW1vZ3JhcGhpY3NQcm9wcykgPT4ge1xuICBjb25zdCB7cmFjZSwgYWdlfSA9IGdldERlbW9ncmFwaGljc0RhdGEocHJvcGVydGllcyk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmRlbW9ncmFwaGljc0NvbnRhaW5lcn0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmRlbW9ncmFwaGljc1RpdGxlfT5cbiAgICAgICAge0VYUExPUkVfQ09QWS5TSURFX1BBTkVMX0RFTU9HUkFQSElDUy5USVRMRX1cbiAgICAgIDwvZGl2PlxuICAgICAgPD5cbiAgICAgICAgPEo0MEFjY29yZGlvbkl0ZW0gaWQ9eydyYWNlJ30gdGl0bGU9e0VYUExPUkVfQ09QWS5TSURFX1BBTkVMX0RFTU9HUkFQSElDUy5SQUNFX1RJVExFfT5cbiAgICAgICAgICB7ZGVtb2dyYXBoaWNJdGVtR2VuKHJhY2UpfVxuICAgICAgICA8L0o0MEFjY29yZGlvbkl0ZW0+XG4gICAgICAgIDxKNDBBY2NvcmRpb25JdGVtIGlkPXsnYWdlJ30gdGl0bGU9e0VYUExPUkVfQ09QWS5TSURFX1BBTkVMX0RFTU9HUkFQSElDUy5BR0VfVElUTEV9PlxuICAgICAgICAgIHtkZW1vZ3JhcGhpY0l0ZW1HZW4oYWdlKX1cbiAgICAgICAgPC9KNDBBY2NvcmRpb25JdGVtPlxuICAgICAgPC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBUcmFjdERlbW9ncmFwaGljcztcbiIsImltcG9ydCBUcmFjdERlbW9ncmFwaGljcyBmcm9tICcuL1RyYWN0RGVtb2dyYXBoaWNzJztcbmV4cG9ydCBkZWZhdWx0IFRyYWN0RGVtb2dyYXBoaWNzO1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIHRyYWN0SW5mb0NvbnRhaW5lciA9IFwiVHJhY3RJbmZvLW1vZHVsZS0tdHJhY3RJbmZvQ29udGFpbmVyLS11UGhFV1wiO1xuZXhwb3J0IHZhciB0cmFjdEluZm9MYWJlbCA9IFwiVHJhY3RJbmZvLW1vZHVsZS0tdHJhY3RJbmZvTGFiZWwtLW1ZMTJxXCI7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7dXNlSW50bH0gZnJvbSAnZ2F0c2J5LXBsdWdpbi1pbnRsJztcblxuaW1wb3J0ICogYXMgc3R5bGVzIGZyb20gJy4vVHJhY3RJbmZvLm1vZHVsZS5zY3NzJztcbmltcG9ydCAqIGFzIEVYUExPUkVfQ09QWSBmcm9tICcuLi8uLi9kYXRhL2NvcHkvZXhwbG9yZSc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vLi4vZGF0YS9jb25zdGFudHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElUcmFjdEluZm9Qcm9wcyB7XG4gIGJsb2NrR3JvdXA6IHN0cmluZyxcbiAgY291bnR5TmFtZTogc3RyaW5nLFxuICBzdGF0ZU5hbWU6IHN0cmluZyxcbiAgcG9wdWxhdGlvbjogbnVtYmVyLFxuICBzaWRlUGFuZWxTdGF0ZTogc3RyaW5nLFxufVxuXG5jb25zdCBUcmFjdEluZm8gPSAoe2Jsb2NrR3JvdXAsIGNvdW50eU5hbWUsIHN0YXRlTmFtZSwgcG9wdWxhdGlvbiwgc2lkZVBhbmVsU3RhdGV9OiBJVHJhY3RJbmZvUHJvcHMpID0+IHtcbiAgY29uc3QgaW50bCA9IHVzZUludGwoKTtcblxuICByZXR1cm4gKFxuICAgIDx1bCBjbGFzc05hbWU9e3N0eWxlcy50cmFjdEluZm9Db250YWluZXJ9PlxuICAgICAgPGxpPlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy50cmFjdEluZm9MYWJlbH0+XG4gICAgICAgICAge2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9DQkdfSU5GTy5DRU5TVVNfSU5GT19USVRMRSl9XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvbGk+XG4gICAgICA8bGk+XG4gICAgICAgIDxzcGFuPlxuICAgICAgICAgIHtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfQ0JHX0lORk8uQ0VOU1VTX0JMT0NLX0dST1VQKX1cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICA8c3Bhbj57YCAke2Jsb2NrR3JvdXB9YH08L3NwYW4+XG4gICAgICA8L2xpPlxuICAgICAgPGxpPlxuICAgICAgICA8c3Bhbj5cbiAgICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0NCR19JTkZPLkNPVU5UWSl9XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPHNwYW4+e2AgJHtjb3VudHlOYW1lfWB9PC9zcGFuPlxuICAgICAgPC9saT5cbiAgICAgIDxsaT5cbiAgICAgICAgPHNwYW4+XG4gICAgICAgICAge3NpZGVQYW5lbFN0YXRlICE9PSBjb25zdGFudHMuU0lERV9QQU5FTF9TVEFURV9WQUxVRVMuTkFUSU9OID9cbiAgICAgICAgICAgICAgaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0NCR19JTkZPLlRFUlJJVE9SWSkgOlxuICAgICAgICAgICAgICBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfQ0JHX0lORk8uU1RBVEUpXG4gICAgICAgICAgfVxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIDxzcGFuPntgICR7c3RhdGVOYW1lfWB9PC9zcGFuPlxuICAgICAgPC9saT5cbiAgICAgIDxsaT5cbiAgICAgICAgPHNwYW4+XG4gICAgICAgICAge2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9DQkdfSU5GTy5QT1BVTEFUSU9OKX1cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICA8c3Bhbj57YCAke3BvcHVsYXRpb24udG9Mb2NhbGVTdHJpbmcoKX1gfTwvc3Bhbj5cbiAgICAgIDwvbGk+XG4gICAgPC91bD5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRyYWN0SW5mbztcbiIsImltcG9ydCBUcmFjdEluZm8gZnJvbSAnLi9UcmFjdEluZm8nO1xuZXhwb3J0IGRlZmF1bHQgVHJhY3RJbmZvO1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIGludmVydCA9IFwiVHJhY3RQcmlvcml0aXphdGlvbi1tb2R1bGUtLWludmVydC0tb3V3RmNcIjsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi9UcmFjdFByaW9yaXRpemF0aW9uLm1vZHVsZS5zY3NzJztcblxuaW1wb3J0ICogYXMgRVhQTE9SRV9DT1BZIGZyb20gJy4uLy4uL2RhdGEvY29weS9leHBsb3JlJztcblxuaW50ZXJmYWNlIElUcmFjdFByaW9yaXRpemF0aW9uIHtcbiAgc2NvcmVOQ29tbXVuaXRpZXM6IGJvb2xlYW4sXG4gIHRyaWJhbENvdW50QUs6IG51bWJlciB8IG51bGwsXG4gIHRyaWJhbENvdW50VVM6IG51bWJlciB8IG51bGwsXG4gIHBlcmNlbnRUcmFjdFRyaWJhbDogbnVtYmVyIHwgbnVsbCxcbn1cblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCB3aWxsIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgZGVzaWduYXRpb24gZm9yIHRoZSB0cmFjdCdzIHByaW9yaXRpemF0aW9uXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBzY29yZU5Db21tdW5pdGllc1xuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSB0cmliYWxDb3VudEFLXG4gKiBAcGFyYW0ge251bWJlciB8IG51bGx9IHRyaWJhbENvdW50VVNcbiAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbH0gcGVyY2VudFRyYWN0VHJpYmFsXG4gKiBAcmV0dXJuIHtKU1h9XG4gKi9cbmNvbnN0IFRyYWN0UHJpb3JpdGl6YXRpb24gPSAoXG4gICAge3Njb3JlTkNvbW11bml0aWVzLFxuICAgICAgdHJpYmFsQ291bnRBSyxcbiAgICAgIHRyaWJhbENvdW50VVMsXG4gICAgICBwZXJjZW50VHJhY3RUcmliYWx9OklUcmFjdFByaW9yaXRpemF0aW9uKSA9PiB7XG4gIGlmIChzY29yZU5Db21tdW5pdGllcyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiA8aDMgY2xhc3NOYW1lPXtzdHlsZXMuaW52ZXJ0fT57RVhQTE9SRV9DT1BZLkNPTU1VTklUWS5PRl9GT0NVU308L2gzPjtcbiAgfSBlbHNlIHtcbiAgICBpZiAocGVyY2VudFRyYWN0VHJpYmFsID09PSBudWxsICYmIHRyaWJhbENvdW50QUsgPT09IG51bGwgJiYgdHJpYmFsQ291bnRVUyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDxoMz57RVhQTE9SRV9DT1BZLkNPTU1VTklUWS5OT1RfT0ZfRk9DVVN9PC9oMz47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiA8aDMgY2xhc3NOYW1lPXtzdHlsZXMuaW52ZXJ0fT57RVhQTE9SRV9DT1BZLkNPTU1VTklUWS5QQVJUSUFMfTwvaDM+O1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgVHJhY3RQcmlvcml0aXphdGlvbjtcbiIsImltcG9ydCBUcmFjdFByaW9yaXRpemF0aW9uIGZyb20gJy4vVHJhY3RQcmlvcml0aXphdGlvbic7XG5leHBvcnQgZGVmYXVsdCBUcmFjdFByaW9yaXRpemF0aW9uO1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIGFyZWFEZXRhaWxDb250YWluZXIgPSBcImFyZWFEZXRhaWwtbW9kdWxlLS1hcmVhRGV0YWlsQ29udGFpbmVyLS1pOFM0Y1wiO1xuZXhwb3J0IHZhciBidXR0b25Db250YWluZXIgPSBcImFyZWFEZXRhaWwtbW9kdWxlLS1idXR0b25Db250YWluZXItLTFtN2pnXCI7XG5leHBvcnQgdmFyIGJ1dHRvblRleHQgPSBcImFyZWFEZXRhaWwtbW9kdWxlLS1idXR0b25UZXh0LS1nS3VYM1wiO1xuZXhwb3J0IHZhciBjYXRlZ29yaXphdGlvbiA9IFwiYXJlYURldGFpbC1tb2R1bGUtLWNhdGVnb3JpemF0aW9uLS1Jd3lPR1wiO1xuZXhwb3J0IHZhciBjYXRlZ29yeUhlYWRlciA9IFwiYXJlYURldGFpbC1tb2R1bGUtLWNhdGVnb3J5SGVhZGVyLS03NEx1b1wiO1xuZXhwb3J0IHZhciBjYXRlZ29yeVNwYWNlciA9IFwiYXJlYURldGFpbC1tb2R1bGUtLWNhdGVnb3J5U3BhY2VyLS10dDBkNVwiO1xuZXhwb3J0IHZhciBjZW5zdXNMYWJlbCA9IFwiYXJlYURldGFpbC1tb2R1bGUtLWNlbnN1c0xhYmVsLS1KdnBGVlwiO1xuZXhwb3J0IHZhciBjZW5zdXNSb3cgPSBcImFyZWFEZXRhaWwtbW9kdWxlLS1jZW5zdXNSb3ctLUM5UVB1XCI7XG5leHBvcnQgdmFyIGNlbnN1c1RleHQgPSBcImFyZWFEZXRhaWwtbW9kdWxlLS1jZW5zdXNUZXh0LS1ETjd2dlwiO1xuZXhwb3J0IHZhciBjb21tdW5pdHlPZkZvY3VzID0gXCJhcmVhRGV0YWlsLW1vZHVsZS0tY29tbXVuaXR5T2ZGb2N1cy0tRTJZNHpcIjtcbmV4cG9ydCB2YXIgaXNJbkZvY3VzID0gXCJhcmVhRGV0YWlsLW1vZHVsZS0taXNJbkZvY3VzLS1jTVU5U1wiO1xuZXhwb3J0IHZhciBwcmlvQ29weSA9IFwiYXJlYURldGFpbC1tb2R1bGUtLXByaW9Db3B5LS04b3pHNVwiO1xuZXhwb3J0IHZhciBzZW5kRmVlZGJhY2tCdG4gPSBcImFyZWFEZXRhaWwtbW9kdWxlLS1zZW5kRmVlZGJhY2tCdG4tLXl6VTdQXCI7XG5leHBvcnQgdmFyIHNlbmRGZWVkYmFja0xpbmsgPSBcImFyZWFEZXRhaWwtbW9kdWxlLS1zZW5kRmVlZGJhY2tMaW5rLS13M05valwiO1xuZXhwb3J0IHZhciBzaG93Q2F0ZWdvcmllc0V4Y2VlZCA9IFwiYXJlYURldGFpbC1tb2R1bGUtLXNob3dDYXRlZ29yaWVzRXhjZWVkLS1idW1JMVwiO1xuZXhwb3J0IHZhciB0ZXN0U2lnbmFscyA9IFwiYXJlYURldGFpbC1tb2R1bGUtLXRlc3RTaWduYWxzLS15WWhxUlwiO1xuZXhwb3J0IHZhciB2ZXJzaW9uSW5mbyA9IFwiYXJlYURldGFpbC1tb2R1bGUtLXZlcnNpb25JbmZvLS1ITkgwT1wiOyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHZhciBpbnZlcnQgPSBcIklzbGFuZENvcHktbW9kdWxlLS1pbnZlcnQtLVdhYkRUXCI7XG5leHBvcnQgdmFyIGlzbGFuZENvcHlDb250YWluZXIgPSBcIklzbGFuZENvcHktbW9kdWxlLS1pc2xhbmRDb3B5Q29udGFpbmVyLS1yQ0JXb1wiO1xuZXhwb3J0IHZhciBpc2xhbmRSb3cgPSBcIklzbGFuZENvcHktbW9kdWxlLS1pc2xhbmRSb3ctLVU2Zm5SXCI7XG5leHBvcnQgdmFyIGlzbGFuZFJvd0xhYmVsID0gXCJJc2xhbmRDb3B5LW1vZHVsZS0taXNsYW5kUm93TGFiZWwtLTBXc2tnXCI7XG5leHBvcnQgdmFyIG5vSW52ZXJ0ID0gXCJJc2xhbmRDb3B5LW1vZHVsZS0tbm9JbnZlcnQtLTIzV2FTXCI7XG5leHBvcnQgdmFyIHN1YlRleHRDb250YWluZXIgPSBcIklzbGFuZENvcHktbW9kdWxlLS1zdWJUZXh0Q29udGFpbmVyLS1XQVE1SVwiO1xuZXhwb3J0IHZhciB2YWx1ZUNvbnRhaW5lciA9IFwiSXNsYW5kQ29weS1tb2R1bGUtLXZhbHVlQ29udGFpbmVyLS1YeXZmVFwiO1xuZXhwb3J0IHZhciB2YWx1ZVN1YlRleHRDb250YWluZXIgPSBcIklzbGFuZENvcHktbW9kdWxlLS12YWx1ZVN1YlRleHRDb250YWluZXItLVkrRFEyXCI7IiwiaW1wb3J0IHt1c2VJbnRsfSBmcm9tICdnYXRzYnktcGx1Z2luLWludGwnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHtJbmRpY2F0b3JWYWx1ZSwgSW5kaWNhdG9yVmFsdWVTdWJUZXh0fSBmcm9tICcuLi9JbmRpY2F0b3IvSW5kaWNhdG9yJztcblxuaW1wb3J0ICogYXMgc3R5bGVzIGZyb20gJy4vSXNsYW5kQ29weS5tb2R1bGUuc2Nzcyc7XG5cbmltcG9ydCAqIGFzIEVYUExPUkVfQ09QWSBmcm9tICcuLi8uLi9kYXRhL2NvcHkvZXhwbG9yZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUlzbGFuZENvcHlQcm9wcyB7XG4gIHBvdmVydHlQZXJjZW50aWxlOiBudW1iZXIgfCBudWxsXG59XG5cbmNvbnN0IElzbGFuZENvcHkgPSAoe3BvdmVydHlQZXJjZW50aWxlfTogSUlzbGFuZENvcHlQcm9wcykgPT4ge1xuICBjb25zdCBpbnRsID0gdXNlSW50bCgpO1xuICBjb25zdCBwZXJjZW50aWxlV2hvbGUgPSBwb3ZlcnR5UGVyY2VudGlsZSA/XG4gICAgcGFyc2VGbG9hdCgocG92ZXJ0eVBlcmNlbnRpbGUqMTAwKS50b0ZpeGVkKCkpIDogbnVsbDtcbiAgY29uc3QgdGhyZXNob2xkID0gNjU7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmlzbGFuZENvcHlDb250YWluZXJ9PlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5pc2xhbmRSb3d9PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmlzbGFuZFJvd0xhYmVsfT5cbiAgICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5JU0xBTkRfQ09QWS5MT1dfSU5DKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudmFsdWVTdWJUZXh0Q29udGFpbmVyfT5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7c3R5bGVzLnZhbHVlQ29udGFpbmVyfVxuICAgICAgICAgICAgJHsgcGVyY2VudGlsZVdob2xlICYmIHBlcmNlbnRpbGVXaG9sZSA+PSB0aHJlc2hvbGQgP1xuICAgICAgICAgICAgICBzdHlsZXMuaW52ZXJ0IDpcbiAgICAgICAgICAgICAgc3R5bGVzLm5vSW52ZXJ0IH1cbiAgICAgICAgICBgfT5cbiAgICAgICAgICAgIDxJbmRpY2F0b3JWYWx1ZVxuICAgICAgICAgICAgICB0eXBlPXsncGVyY2VudGlsZSd9XG4gICAgICAgICAgICAgIGRpc3BsYXlTdGF0PXtwZXJjZW50aWxlV2hvbGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuc3ViVGV4dENvbnRhaW5lcn0+XG4gICAgICAgICAgICA8SW5kaWNhdG9yVmFsdWVTdWJUZXh0XG4gICAgICAgICAgICAgIHZhbHVlPXtwZXJjZW50aWxlV2hvbGV9XG4gICAgICAgICAgICAgIGlzQWJvdmVUaHJlc2g9e3BlcmNlbnRpbGVXaG9sZSAmJiBwZXJjZW50aWxlV2hvbGUgPj0gdGhyZXNob2xkID8gdHJ1ZSA6IGZhbHNlfVxuICAgICAgICAgICAgICB0aHJlc2hvbGQ9e3RocmVzaG9sZH1cbiAgICAgICAgICAgICAgdHlwZT17J3BlcmNlbnRpbGUnfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IElzbGFuZENvcHk7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBxdW90ZXMgKi9cbi8vIEV4dGVybmFsIExpYnM6XG5pbXBvcnQge0FjY29yZGlvbiwgQnV0dG9uLCBJY29ufSBmcm9tIFwiQHRydXNzd29ya3MvcmVhY3QtdXN3ZHNcIjtcbmltcG9ydCB7TWVzc2FnZURlc2NyaXB0b3IsIHVzZUludGx9IGZyb20gXCJnYXRzYnktcGx1Z2luLWludGxcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuLy8gQ29tcG9uZW50czpcbmltcG9ydCBDYXRlZ29yeSBmcm9tIFwiLi4vQ2F0ZWdvcnlcIjtcbmltcG9ydCBEb251dENvcHkgZnJvbSBcIi4uL0RvbnV0Q29weVwiO1xuaW1wb3J0IEluZGljYXRvciBmcm9tIFwiLi4vSW5kaWNhdG9yXCI7XG5pbXBvcnQgUHJpb3JpdGl6YXRpb25Db3B5IGZyb20gXCIuLi9Qcmlvcml0aXphdGlvbkNvcHlcIjtcbmltcG9ydCBQcmlvcml0aXphdGlvbkNvcHkyIGZyb20gXCIuLi9Qcmlvcml0aXphdGlvbkNvcHkyXCI7XG5pbXBvcnQgVHJhY3REZW1vZ3JhcGhpY3MgZnJvbSBcIi4uL1RyYWN0RGVtb2dyYXBoaWNzXCI7XG5pbXBvcnQgVHJhY3RJbmZvIGZyb20gXCIuLi9UcmFjdEluZm9cIjtcbmltcG9ydCBUcmFjdFByaW9yaXRpemF0aW9uIGZyb20gXCIuLi9UcmFjdFByaW9yaXRpemF0aW9uXCI7XG5cbi8vIFN0eWxlcyBhbmQgY29uc3RhbnRzXG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSBcIi4uLy4uL2RhdGEvY29uc3RhbnRzXCI7XG5pbXBvcnQgKiBhcyBFWFBMT1JFX0NPUFkgZnJvbSBcIi4uLy4uL2RhdGEvY29weS9leHBsb3JlXCI7XG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSBcIi4vYXJlYURldGFpbC5tb2R1bGUuc2Nzc1wiO1xuXG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgSXNsYW5kQ29weSBmcm9tIFwiLi4vSXNsYW5kQ29weS9Jc2xhbmRDb3B5XCI7XG5cbmludGVyZmFjZSBJQXJlYURldGFpbFByb3BzIHtcbiAgcHJvcGVydGllczogY29uc3RhbnRzLko0MFByb3BlcnRpZXM7XG4gIGhhc2g6IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIFRoZXJlIGFyZSBhIDQgZGlmZmVyZW50IGluZGljYXRvciB0eXBlcy4gRWFjaCBpbmRpY2F0b3IgdHlwZSB3aWxsIHJlbmRlciBpbiB0aGUgVUkgZGlmZmVyZW50bHkuXG4gKlxuICogcGVyY2VudGlsZSAtIGlzIHRoZSBtYWpvcml0eSBvZiBpbmRpY2F0b3JzXG4gKiBwZXJjZW50cyAtIGEgZmV3IGluZGljYXRvcnMgZmFsbCBpbnRvIHRoaXMgdHlwZVxuICogYm9vbGVhbiAtIDMgaW5kaWNhdG9ycyBhcmUgb2YgYm9vbGVhbiB0eXBlXG4gKiAgICAtIGhpc3RvcmljIHJlZGxpbmluZ1xuICogICAgLSBhYmFuZG9uZWQgbGFuZCBtaW5lc1xuICogICAgLSBGVURTXG4gKlxuICovXG5leHBvcnQgdHlwZSBpbmRpY2F0b3JUeXBlID0gXCJwZXJjZW50aWxlXCIgfCBcInBlcmNlbnRcIiB8IFwiYm9vbGVhblwiO1xuXG4vKipcbiAqIFRoaXMgaW50ZXJmYWNlIGlzIHVzZWQgYXMgZGVmaW5lIHRoZSB2YXJpb3VzIGZpZWxkcyBmb3IgZWFjaCBpbmRpY2F0b3IgaW4gdGhlIHNpZGUgcGFuZWxcbiAqICBsYWJlbDogdGhlIGluZGljYXRvciBsYWJlbCBvciB0aXRsZVxuICogIGRlc2NyaXB0aW9uOiB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGluZGljYXRvciB1c2VkIGluIHRoZSBzaWRlIHBhbmVsXG4gKiAgdHlwZTogc2VlIGluZGljYXRvclR5cGUgYWJvdmVcbiAqICB2YWx1ZTogdGhlIG51bWJlciBmcm9tIHRoZSBnZW9KU09OIHRpbGUuIElmIHRpbGUgZG9lc24ndCBleGlzdCBpdCBnZXQgYSBudWxsIHZhbHVlLiBDb3VsZCBiZSBib29sZWFuIGFsc29cbiAqICBpc0Rpc2FkdmFndGFnZWQ6IHRoZSBmbGFnIGZyb20gdGhlIGdlb0pTT04gdGlsZVxuICogIHRocmVzaG9sZDogYSBjdXN0b20gdmFsdWUgb2YgdGhyZXNob2xkIGZvciBjZXJ0YWluIGluZGljYXRvcnNcbiAqICAqL1xuZXhwb3J0IGludGVyZmFjZSBpbmRpY2F0b3JJbmZvIHtcbiAgbGFiZWw6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgdHlwZTogaW5kaWNhdG9yVHlwZTtcbiAgdmFsdWU6IG51bWJlciB8IGJvb2xlYW4gfCBudWxsO1xuICBpc0Rpc2FkdmFndGFnZWQ6IGJvb2xlYW47XG4gIHRocmVzaG9sZD86IG51bWJlcjtcbn1cblxuLyoqXG4gKiBUaGlzIGludGVyZmFjZSBpcyB1c2VkIGFzIGRlZmluZSB0aGUgdmFyaW91cyBmaWVsZHMgZm9yIGNhdGVnb3J5IGluIHRoZSBzaWRlIHBhbmVsXG4gKiBpZDogZGlzdGljdCBpZFxuICogdGl0bGVUZXh0OiBkaXNwbGF5IHRleHQgZm9yIHRoZSBjYXRlZ29yeSB0aXRsZVxuICogaW5kaWNhdG9yczogYW4gYXJyYXkgb2YgaW5kaWNhdG9yc1xuICogc29jaW9FY0luZGljYXRvcnM6IGFuIGFycmF5IG9mIHNvY2lvZWNvbm9taWMgaW5kaWNhdG9yc1xuICogaXNEaXNhZHZhZ3RhZ2VkOiBib29sZWFuIHRvIGluZGljYXRlIGlmIHRoZSBjYXRlZ29yeSBpcyBkaXNhZHZhbnRhZ2VkXG4gKiBpc0V4Y2VlZDFNb3JlQnVyZGVuOiBib29sZWFuIHRvIGluZGljYXRlIGlmIHRoZSBjYXRlZ29yeSBleGNlZWRzIG1vcmUgdGhhbiBvbmUgYnVyZGVuXG4gKiBpc0V4Y2VlZEJvdGhTb2Npb0J1cmRlbnM6IGJvb2xlYW4gdG8gaW5kaWNhdGUgaWYgdGhlIGNhdGVnb3J5IGV4Y2VlZHMgYm90aCBzb2Npby1lY28gYnVyZGVuc1xuICogICovXG5leHBvcnQgaW50ZXJmYWNlIElDYXRlZ29yeSB7XG4gIGlkOiBzdHJpbmc7XG4gIHRpdGxlVGV4dDogc3RyaW5nO1xuICBpbmRpY2F0b3JzOiBpbmRpY2F0b3JJbmZvW107XG4gIHNvY2lvRWNJbmRpY2F0b3JzOiBpbmRpY2F0b3JJbmZvW107XG4gIGlzRGlzYWR2YWd0YWdlZDogYm9vbGVhbiB8IG51bGw7XG4gIGlzRXhjZWVkMU1vcmVCdXJkZW46IGJvb2xlYW4gfCBudWxsO1xuICBpc0V4Y2VlZEJvdGhTb2Npb0J1cmRlbnM6IGJvb2xlYW4gfCBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyIHdpbGwgcmVtb3ZlIGluZGljYXRvcnMgZnJvbSBhcHBlYXJpbmcgaW4gdGhlIHNpZGUgcGFuZWwgYnkgcmV0dXJuaW5nXG4gKiB0aGUgZmlsdGVyIGZ1bmN0aW9uIChjdXJyeWluZykuIFRoZXJlIGlzIDEgdXNlIGNhc2UuIEl0IGNhbiBhY2NlcHQgYW55IGluZGljYXRvciBuYW1lXG4gKiBhcyBhbiBpbnB1dC5cbiAqXG4gKiAxLiBGb3IgSGlzdG9yaWMgdW5kZXJpbnZlc3RtZW50IGlmIHRoZSB2YWx1ZSBpcyBudWxsXG4gKlxuICogUmVjb21tZW5kYXRpb24gaXMgdG8gdXNlIGEgc2VwYXJhdGUgZmlsdGVyIGZvciBlYWNoIGluZGljYXRvciB0aGF0IG5lZWRzIGZpbHRlcmluZy5cbiAqXG4gKiBAcGFyYW0ge01lc3NhZ2VEZXNjcmlwdG9yfSBsYWJlbCAtIGFsbG93cyB0byByZS11c2UgdGhpcyBmaWx0ZXIgZm9yIGFueSBudW1iZXIgb2YgaW5kaWNhdG9yc1xuICogQHJldHVybiB7aW5kaWNhdG9ySW5mb31cbiAqL1xuZXhwb3J0IGNvbnN0IGluZGljYXRvckZpbHRlciA9IChsYWJlbDogTWVzc2FnZURlc2NyaXB0b3IpID0+IHtcbiAgY29uc3QgaW50bCA9IHVzZUludGwoKTtcblxuICByZXR1cm4gKGluZGljYXRvcjogaW5kaWNhdG9ySW5mbykgPT5cbiAgICBpbmRpY2F0b3IubGFiZWwgIT09IGludGwuZm9ybWF0TWVzc2FnZShsYWJlbCkgfHxcbiAgICAoaW5kaWNhdG9yLmxhYmVsID09IGludGwuZm9ybWF0TWVzc2FnZShsYWJlbCkgJiYgaW5kaWNhdG9yLnZhbHVlICE9IG51bGwpO1xufTtcblxuLyoqXG4gKiBGdW5jdGlvbiB0byBjYWxjdWxhdGUgdGhlIHRyaWJhbCBhcmVhIHBlcmNlbnRhZ2UgdmFsdWUgdG8gZGlzcGxheSB3aGVuIGEgdHJhY3QgaXMgc2VsZWN0ZWRcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdHJpYmFsUGVyY2VudFJhd1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgZ2V0VHJpYmFsUGVyY2VudFZhbHVlID0gKHRyaWJhbFBlcmNlbnRSYXc6IG51bWJlcikgPT4ge1xuICBpZiAodHJpYmFsUGVyY2VudFJhdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGAgbm9uZWA7XG4gIH1cblxuICBpZiAodHJpYmFsUGVyY2VudFJhdyA9PT0gMCkge1xuICAgIC8vIHRlc3QgdHJhY3QgPSAjOS4wMy80Mi45MjQyLy05OC44MDE1XG4gICAgcmV0dXJuIGAgbGVzcyB0aGFuIDElYDtcbiAgfVxuXG4gIGlmICh0cmliYWxQZXJjZW50UmF3ICYmIHRyaWJhbFBlcmNlbnRSYXcgPiAwKSB7XG4gICAgcmV0dXJuIGAgJHtwYXJzZUZsb2F0KCh0cmliYWxQZXJjZW50UmF3ICogMTAwKS50b0ZpeGVkKCkpfSAlYDtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWluIGNvbXBvbmVudC4gSXQgd2lsbCByZW5kZXIgdGhlIGVudGlyZSBzaWRlIHBhbmVsIGFuZCBzaG93IHRoZSBkZXRhaWxzXG4gKiBvZiB0aGUgYXJlYS9mZWF0dXJlIHRoYXQgaXMgc2VsZWN0ZWQuXG4gKlxuICogQHBhcmFtIHtJQXJlYURldGFpbFByb3BzfSB7fVxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuY29uc3QgQXJlYURldGFpbCA9ICh7cHJvcGVydGllc306IElBcmVhRGV0YWlsUHJvcHMpID0+IHtcbiAgY29uc3QgaW50bCA9IHVzZUludGwoKTtcblxuICAvKipcbiAgICogU2V0IHRoZSBpbmRpY2F0b3JzIGZvciBhIGdpdmVuIGNhdGVnb3J5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgdGhlIGNhdGVnb3J5IElEXG4gICAqIEBwYXJhbSB7aW5kaWNhdG9ySW5mb1tdfSBpbmRpY2F0b3JzIHRoZSBpbmRpY2F0b3JzIHRvIHNldCBmb3IgdGhlIGNhdGVnb3J5LlxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBjYXRlZ29yeSBJRCBkb2VzIG5vdCBleGlzdFxuICAgKi9cbiAgY29uc3Qgc2V0Q2F0ZWdvcnlJbmRpY2F0b3JzID0gKGlkOiBzdHJpbmcsIGluZGljYXRvcnM6IGluZGljYXRvckluZm9bXSkgPT4ge1xuICAgIGNvbnN0IGNhdCA9IGNhdGVnb3JpZXMuZmluZCgoY2F0ZWdvcnkpID0+IGNhdGVnb3J5LmlkID09PSBpZCk7XG4gICAgaWYgKGNhdCkgY2F0LmluZGljYXRvcnMgPSBpbmRpY2F0b3JzO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHNpZGUgcGFuZWwgY2F0ZWdvcnkgSUQgJyArIGlkKTtcbiAgfTtcblxuICAvLyBjb25zb2xlLmxvZyB0aGUgcHJvcGVydGllcyBvZiB0aGUgY2Vuc3VzIHRoYXQgaXMgc2VsZWN0ZWQ6XG4gIGNvbnNvbGUubG9nKFxuICAgICAgXCJCRSBzaWduYWxzIGZvciB0cmFjdCAobGFzdCBvbmUgaXMgdGhlIHRyYWN0IGN1cnJlbnRseSBzZWxlY3RlZCk6IFwiLFxuICAgICAgcHJvcGVydGllcyxcbiAgKTtcblxuICAvLyBjb25zb2xlLmxvZyBhcm91bmQgdGhlIGRvbnV0LCBhZGphY2VuY3kgYW5kIHRyaWJhbCBpbmZvOlxuICBjb25zb2xlLmxvZyhcbiAgICAgIFwiSW5jb21lIGltcHV0ZWQ/IFwiLFxuICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklNUFVURV9GTEFHXSA9PT0gXCIwXCIgPyBcIiBOT1wiIDogXCIgWUVTXCIsXG4gICk7XG4gIGNvbnNvbGUubG9nKFxuICAgICAgXCJBZGphY2VuY3kgaW5kaWNhdG9yPyBcIixcbiAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5BREpBQ0VOQ1lfRVhDRUVEU19USFJFU0hdID8gXCIgWUVTXCIgOiBcIiBOT1wiLFxuICApO1xuICBjb25zb2xlLmxvZyhcbiAgICAgIFwiJSBvZiB0cmFjdCB0cmliYWw6IFwiLFxuICAgICAgZ2V0VHJpYmFsUGVyY2VudFZhbHVlKHByb3BlcnRpZXNbY29uc3RhbnRzLlRSSUJBTF9BUkVBU19QRVJDRU5UQUdFXSksXG4gICk7XG4gIGNvbnNvbGUubG9nKFxuICAgICAgXCJUcmliYWwgY291bnQgaW4gQUs6IFwiLFxuICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlRSSUJBTF9BUkVBU19DT1VOVF9BS10gPj0gMSA/XG4gICAgICBgICR7cHJvcGVydGllc1tjb25zdGFudHMuVFJJQkFMX0FSRUFTX0NPVU5UX0FLXX1gIDpcbiAgICAgIGAgbnVsbGAsXG4gICk7XG4gIGNvbnNvbGUubG9nKFxuICAgICAgXCJUcmliYWwgY291bnQgaW4gQ09OVVM6IFwiLFxuICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlRSSUJBTF9BUkVBU19DT1VOVF9DT05VU10gPj0gMSA/XG4gICAgICBgICR7cHJvcGVydGllc1tjb25zdGFudHMuVFJJQkFMX0FSRUFTX0NPVU5UX0NPTlVTXX1gIDpcbiAgICAgIGAgbnVsbGAsXG4gICk7XG5cbiAgLy8gRml4IGNvbnN0YW50cy5NSVNTSU5HX0RBVEFfU1RSSU5HIGltcG9ydFxuICBjb25zdCBibG9ja0dyb3VwID0gcHJvcGVydGllc1tjb25zdGFudHMuR0VPSURfUFJPUEVSVFldID9cbiAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5HRU9JRF9QUk9QRVJUWV0gOlxuICAgIGNvbnN0YW50cy5NSVNTSU5HX0RBVEFfU1RSSU5HO1xuICBjb25zdCBwb3B1bGF0aW9uID0gcHJvcGVydGllc1tjb25zdGFudHMuVE9UQUxfUE9QVUxBVElPTl0gP1xuICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlRPVEFMX1BPUFVMQVRJT05dIDpcbiAgICBjb25zdGFudHMuTUlTU0lOR19EQVRBX1NUUklORztcbiAgY29uc3QgY291bnR5TmFtZSA9IHByb3BlcnRpZXNbY29uc3RhbnRzLkNPVU5UWV9OQU1FXSA/XG4gICAgcHJvcGVydGllc1tjb25zdGFudHMuQ09VTlRZX05BTUVdIDpcbiAgICBjb25zdGFudHMuTUlTU0lOR19EQVRBX1NUUklORztcbiAgY29uc3Qgc3RhdGVOYW1lID0gcHJvcGVydGllc1tjb25zdGFudHMuU1RBVEVfTkFNRV0gP1xuICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlNUQVRFX05BTUVdIDpcbiAgICBjb25zdGFudHMuTUlTU0lOR19EQVRBX1NUUklORztcblxuICBjb25zdCBzaWRlUGFuZWxTdGF0ZSA9IHByb3BlcnRpZXNbY29uc3RhbnRzLlNJREVfUEFORUxfU1RBVEVdO1xuICBjb25zdCBwZXJjZW50VHJhY3RUcmliYWwgPVxuICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlRSSUJBTF9BUkVBU19QRVJDRU5UQUdFXSA+PSAwID9cbiAgICAgIHBhcnNlRmxvYXQoXG4gICAgICAgICAgKHByb3BlcnRpZXNbY29uc3RhbnRzLlRSSUJBTF9BUkVBU19QRVJDRU5UQUdFXSAqIDEwMCkudG9GaXhlZCgpLFxuICAgICAgKSA6XG4gICAgICBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgd29ya2ZvcmNlIGRldmVsb3BtZW50IGNhdGVnb3J5IGhhcyBzb21lIGluZGljYXRvcnMgd2hvJ3Mgc291cmNlIHdpbGwgdmFyeSBkZXBlbmRpbmcgb24gd2hpY2hcbiAgICogdGVycml0b3J5IGlzIHNlbGVjdGVkLiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB1cyB0byBjaGFuZ2UgdGhlIHNvdXJjZSBvZiB3b3JrZm9yY2UgZGV2ZWxvcG1lbnQgaW5kaWNhdG9yc1xuICAgKiBkZXBlbmRpbmcgb24gd2hpY2ggdGVycml0b3J5IHdhcyBzZWxlY3RlZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5kaWNhdG9yTmFtZVxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgY29uc3QgZ2V0V29ya0ZvcmNlSW5kaWNhdG9yVmFsdWUgPSAoaW5kaWNhdG9yTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHNpZGVQYW5lbFN0YXRlID09PSBjb25zdGFudHMuU0lERV9QQU5FTF9TVEFURV9WQUxVRVMuSVNMQU5EX0FSRUFTKSB7XG4gICAgICBpZiAoaW5kaWNhdG9yTmFtZSA9PT0gXCJsb3dNZWRJbmNcIikge1xuICAgICAgICByZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgIGNvbnN0YW50cy5JU0xBTkRfQVJFQVNfTE9XX01FRElBTl9JTkNPTUVfTE9XX0hTX0VEVV9QRVJDRU5USUxFX0ZJRUxELFxuICAgICAgICApID9cbiAgICAgICAgICBwcm9wZXJ0aWVzW1xuICAgICAgICAgICAgICBjb25zdGFudHNcbiAgICAgICAgICAgICAgICAgIC5JU0xBTkRfQVJFQVNfTE9XX01FRElBTl9JTkNPTUVfTE9XX0hTX0VEVV9QRVJDRU5USUxFX0ZJRUxEXG4gICAgICAgICAgXSA6XG4gICAgICAgICAgbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRpY2F0b3JOYW1lID09PSBcInVuZW1wbG95XCIpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXG4gICAgICAgICAgICBjb25zdGFudHMuSVNMQU5EX0FSRUFTX1VORU1QTE9ZTUVOVF9MT1dfSFNfRURVX1BFUkNFTlRJTEVfRklFTEQsXG4gICAgICAgICkgP1xuICAgICAgICAgIHByb3BlcnRpZXNbXG4gICAgICAgICAgICAgIGNvbnN0YW50cy5JU0xBTkRfQVJFQVNfVU5FTVBMT1lNRU5UX0xPV19IU19FRFVfUEVSQ0VOVElMRV9GSUVMRFxuICAgICAgICAgIF0gOlxuICAgICAgICAgIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoaW5kaWNhdG9yTmFtZSA9PT0gXCJwb3ZlcnR5XCIpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXG4gICAgICAgICAgICBjb25zdGFudHMuSVNMQU5EX0FSRUFTX1BPVkVSVFlfTE9XX0hTX0VEVV9QRVJDRU5USUxFX0ZJRUxELFxuICAgICAgICApID9cbiAgICAgICAgICBwcm9wZXJ0aWVzW1xuICAgICAgICAgICAgICBjb25zdGFudHMuSVNMQU5EX0FSRUFTX1BPVkVSVFlfTE9XX0hTX0VEVV9QRVJDRU5USUxFX0ZJRUxEXG4gICAgICAgICAgXSA6XG4gICAgICAgICAgbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRpY2F0b3JOYW1lID09PSBcImhpZ2hTY2hvb2xcIikge1xuICAgICAgICByZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgIGNvbnN0YW50cy5JU0xBTkRfQVJFQVNfSFNfRURVX1BFUkNFTlRBR0VfRklFTEQsXG4gICAgICAgICkgP1xuICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTTEFORF9BUkVBU19IU19FRFVfUEVSQ0VOVEFHRV9GSUVMRF0gOlxuICAgICAgICAgIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluZGljYXRvck5hbWUgPT09IFwibG93TWVkSW5jXCIpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5MT1dfTUVESUFOX0lOQ09NRV9QRVJDRU5USUxFKSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkxPV19NRURJQU5fSU5DT01FX1BFUkNFTlRJTEVdIDpcbiAgICAgICAgbnVsbDtcbiAgICB9XG4gICAgaWYgKGluZGljYXRvck5hbWUgPT09IFwidW5lbXBsb3lcIikge1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXG4gICAgICAgICAgY29uc3RhbnRzLlVORU1QTE9ZTUVOVF9QUk9QRVJUWV9QRVJDRU5USUxFLFxuICAgICAgKSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlVORU1QTE9ZTUVOVF9QUk9QRVJUWV9QRVJDRU5USUxFXSA6XG4gICAgICAgIG51bGw7XG4gICAgfVxuICAgIGlmIChpbmRpY2F0b3JOYW1lID09PSBcInBvdmVydHlcIikge1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnRzLlBPVkVSVFlfQkVMT1dfMTAwX1BFUkNFTlRJTEUpID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuUE9WRVJUWV9CRUxPV18xMDBfUEVSQ0VOVElMRV0gOlxuICAgICAgICBudWxsO1xuICAgIH1cbiAgICBpZiAoaW5kaWNhdG9yTmFtZSA9PT0gXCJoaWdoU2Nob29sXCIpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgIGNvbnN0YW50cy5ISUdIX1NDSE9PTF9QUk9QRVJUWV9QRVJDRU5USUxFLFxuICAgICAgKSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkhJR0hfU0NIT09MX1BST1BFUlRZX1BFUkNFTlRJTEVdIDpcbiAgICAgICAgbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSB3b3JrZm9yY2UgZGV2ZWxvcG1lbnQgY2F0ZWdvcnkgaGFzIHNvbWUgaW5kaWNhdG9ycyB3aG8ncyBkaXNhZHZhbnRhZ2VkIGJvb2xlYW5cbiAgICogd2lsbCB2YXJ5IGRlcGVuZGluZyBvbiB3aGljaCB0ZXJyaXRvcnkgaXMgc2VsZWN0ZWQuIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHVzIHRvIGNoYW5nZVxuICAgKiB0aGUgYm9vbGVhbiBvZiB3b3JrZm9yY2UgZGV2ZWxvcG1lbnQgaW5kaWNhdG9ycyBkZXBlbmRpbmcgb24gd2hpY2ggdGVycml0b3J5IHdhcyBzZWxlY3RlZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5kaWNhdG9yTmFtZVxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgY29uc3QgZ2V0V29ya0ZvcmNlSW5kaWNhdG9ySXNEaXNhZHYgPSAoaW5kaWNhdG9yTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHNpZGVQYW5lbFN0YXRlID09PSBjb25zdGFudHMuU0lERV9QQU5FTF9TVEFURV9WQUxVRVMuSVNMQU5EX0FSRUFTKSB7XG4gICAgICBpZiAoaW5kaWNhdG9yTmFtZSA9PT0gXCJsb3dNZWRJbmNcIikge1xuICAgICAgICByZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgIGNvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfSVNMQU5EX0FSRUFfTE9XX01FRElBTl9JTkNPTUUsXG4gICAgICAgICkgP1xuICAgICAgICAgIHByb3BlcnRpZXNbXG4gICAgICAgICAgICAgIGNvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfSVNMQU5EX0FSRUFfTE9XX01FRElBTl9JTkNPTUVcbiAgICAgICAgICBdIDpcbiAgICAgICAgICBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGluZGljYXRvck5hbWUgPT09IFwidW5lbXBsb3lcIikge1xuICAgICAgICByZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgIGNvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfSVNMQU5EX0FSRUFfVU5FTVBMT1lNRU5ULFxuICAgICAgICApID9cbiAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfSVNMQU5EX0FSRUFfVU5FTVBMT1lNRU5UXSA6XG4gICAgICAgICAgbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRpY2F0b3JOYW1lID09PSBcInBvdmVydHlcIikge1xuICAgICAgICByZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgIGNvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfSVNMQU5EX0FSRUFfQkVMT1dfMTAwX1BPVkVSVFksXG4gICAgICAgICkgP1xuICAgICAgICAgIHByb3BlcnRpZXNbXG4gICAgICAgICAgICAgIGNvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfSVNMQU5EX0FSRUFfQkVMT1dfMTAwX1BPVkVSVFlcbiAgICAgICAgICBdIDpcbiAgICAgICAgICBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGluZGljYXRvck5hbWUgPT09IFwiaGlnaFNjaG9vbFwiKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5JU0xBTkRfQVJFQV9MT1dfSFNfRURVKSA/XG4gICAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNMQU5EX0FSRUFfTE9XX0hTX0VEVV0gOlxuICAgICAgICAgIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluZGljYXRvck5hbWUgPT09IFwibG93TWVkSW5jXCIpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgIGNvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfTE9XX01FRElBTl9JTkNPTUUsXG4gICAgICApID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0xPV19NRURJQU5fSU5DT01FXSA6XG4gICAgICAgIG51bGw7XG4gICAgfVxuICAgIGlmIChpbmRpY2F0b3JOYW1lID09PSBcInVuZW1wbG95XCIpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgIGNvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfVU5FTVBMT1lNRU5ULFxuICAgICAgKSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9VTkVNUExPWU1FTlRdIDpcbiAgICAgICAgbnVsbDtcbiAgICB9XG4gICAgaWYgKGluZGljYXRvck5hbWUgPT09IFwicG92ZXJ0eVwiKSB7XG4gICAgICByZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICBjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0JFTE9XXzEwMF9QT1ZFUlRZLFxuICAgICAgKSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9CRUxPV18xMDBfUE9WRVJUWV0gOlxuICAgICAgICBudWxsO1xuICAgIH1cbiAgICBpZiAoaW5kaWNhdG9yTmFtZSA9PT0gXCJoaWdoU2Nob29sXCIpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgIGNvbnN0YW50cy5JU19MT1dfSFNfRURVQ0FUSU9OX0xPV19ISUdIRVJfRURfUFJJT1JJVElaRUQsXG4gICAgICApID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfTE9XX0hTX0VEVUNBVElPTl9MT1dfSElHSEVSX0VEX1BSSU9SSVRJWkVEXSA6XG4gICAgICAgIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZWZpbmUgZWFjaCBpbmRpY2F0b3IgaW4gdGhlIHNpZGUgcGFuZWwgd2l0aCBjb25zdGFudHMgZnJvbSBjb3B5IGZpbGUgKGZvciBpbnRsKVxuICAgKlxuICAgKiBJbmRpY2F0b3JzIGFyZSBncm91cGVkIGJ5IGNhdGVnb3J5XG4gICAqL1xuXG4gIC8vIENsaW1hdGUgY2F0ZWdvcnlcbiAgY29uc3QgZXhwQWdMb3NzOiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5FWFBfQUdfTE9TUyksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLkVYUF9BR19MT1NTLFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50aWxlXCIsXG4gICAgdmFsdWU6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnRzLkVYUF9BR1JJQ1VMVFVSRV9MT1NTX1BFUkNFTlRJTEUpID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkVYUF9BR1JJQ1VMVFVSRV9MT1NTX1BFUkNFTlRJTEVdIDpcbiAgICAgIG51bGwsXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfRVhQX0FHUl9MT1NTXSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfRVhQX0FHUl9MT1NTXSA6XG4gICAgICBudWxsLFxuICB9O1xuICBjb25zdCBleHBCbGRMb3NzOiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5FWFBfQkxEX0xPU1MpLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5FWFBfQkxEX0xPU1MsXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuRVhQX0JVSUxESU5HX0xPU1NfUEVSQ0VOVElMRSkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuRVhQX0JVSUxESU5HX0xPU1NfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9FWFBfQkxEX0xPU1NdID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9FWFBfQkxEX0xPU1NdIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IGV4cFBvcExvc3M6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLkVYUF9QT1BfTE9TUyksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLkVYUF9QT1BfTE9TUyxcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5FWFBfUE9QVUxBVElPTl9MT1NTX1BFUkNFTlRJTEUpID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkVYUF9QT1BVTEFUSU9OX0xPU1NfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9FWFBfUE9QX0xPU1NdID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9FWFBfUE9QX0xPU1NdIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IGZsb29kaW5nOiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5GTE9PRElORyksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLkZMT09ESU5HLFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50aWxlXCIsXG4gICAgdmFsdWU6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnRzLkZMT09ESU5HX1BFUkNFTlRJTEUpID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkZMT09ESU5HX1BFUkNFTlRJTEVdIDpcbiAgICAgIG51bGwsXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GTE9PRElOR10gP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRkxPT0RJTkddIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IHdpbGRmaXJlOiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5XSUxERklSRSksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLldJTERGSVJFLFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50aWxlXCIsXG4gICAgdmFsdWU6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnRzLldJTERGSVJFX1BFUkNFTlRJTEUpID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLldJTERGSVJFX1BFUkNFTlRJTEVdIDpcbiAgICAgIG51bGwsXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9XSUxERklSRV0gP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfV0lMREZJUkVdIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IGxvd0luYzogaW5kaWNhdG9ySW5mbyA9IHtcbiAgICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuTE9XX0lOQ09NRSksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLkxPV19JTkNPTUUsXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuUE9WRVJUWV9CRUxPV18yMDBfUEVSQ0VOVElMRSkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuUE9WRVJUWV9CRUxPV18yMDBfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0ZFREVSQUxfUE9WRVJUWV9MRVZFTF8yMDBdID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0ZFREVSQUxfUE9WRVJUWV9MRVZFTF8yMDBdIDpcbiAgICAgIG51bGwsXG4gICAgdGhyZXNob2xkOiA2NSxcbiAgfTtcbiAgLy8gY29uc3QgaGlnaGVyRWQ6IGluZGljYXRvckluZm8gPSB7XG4gIC8vICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLkhJR0hfRUQpLFxuICAvLyAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLkhJR0hfRUQpLFxuICAvLyAgIHR5cGU6ICdwZXJjZW50JyxcbiAgLy8gICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuTk9OX0hJR0hFUl9FRF9QRVJDRU5USUxFKSA/XG4gIC8vICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5OT05fSElHSEVSX0VEX1BFUkNFTlRJTEVdIDogbnVsbCxcbiAgLy8gICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0hJR0hFUl9FRF9QRVJDRU5USUxFXSA/XG4gIC8vICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19ISUdIRVJfRURfUEVSQ0VOVElMRV0gOiBudWxsLFxuICAvLyAgIHRocmVzaG9sZDogODAsXG4gIC8vIH07XG5cbiAgLy8gRW5lcmd5IGNhdGVnb3J5XG4gIGNvbnN0IGVuZXJneUNvc3Q6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLkVORVJHWV9DT1NUKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uRU5FUkdZX0NPU1QsXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuRU5FUkdZX1BFUkNFTlRJTEUpID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkVORVJHWV9QRVJDRU5USUxFXSA6XG4gICAgICBudWxsLFxuICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0VORVJHWV9CVVJERU5dID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9FTkVSR1lfQlVSREVOXSA6XG4gICAgICBudWxsLFxuICB9O1xuICBjb25zdCBwbTI1OiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5QTV8yXzUpLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5QTV8yXzUsXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuUE0yNV9QRVJDRU5USUxFKSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5QTTI1X1BFUkNFTlRJTEVdIDpcbiAgICAgIG51bGwsXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfUE0yNV0gP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX1BNMjVdIDpcbiAgICAgIG51bGwsXG4gIH07XG5cbiAgLy8gSGVhbHRoIGNhdGVnb3J5XG4gIGNvbnN0IGFzdGhtYTogaW5kaWNhdG9ySW5mbyA9IHtcbiAgICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuQVNUSE1BKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uQVNUSE1BLFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50aWxlXCIsXG4gICAgdmFsdWU6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnRzLkFTVEhNQV9QRVJDRU5USUxFKSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5BU1RITUFfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9BU1RITUFdID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9BU1RITUFdIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IGRpYWJldGVzOiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5ESUFCRVRFUyksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLkRJQUJFVEVTLFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50aWxlXCIsXG4gICAgdmFsdWU6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnRzLkRJQUJFVEVTX1BFUkNFTlRJTEUpID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkRJQUJFVEVTX1BFUkNFTlRJTEVdIDpcbiAgICAgIG51bGwsXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfRElBQkVURVNdID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9ESUFCRVRFU10gOlxuICAgICAgbnVsbCxcbiAgfTtcbiAgY29uc3QgaGVhcnREaXNlYXNlOiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5IRUFSVF9ESVNFQVNFKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uSEVBUlRfRElTRUFTRSxcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5IRUFSVF9QRVJDRU5USUxFKSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5IRUFSVF9QRVJDRU5USUxFXSA6XG4gICAgICBudWxsLFxuICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX0hFQVJUX0RJU0VBU0VdID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9IRUFSVF9ESVNFQVNFXSA6XG4gICAgICBudWxsLFxuICB9O1xuICBjb25zdCBsaWZlRXhwZWN0OiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5MSUZFX0VYUEVDVCksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLkxPV19MSUZFX0VYUEVDVCxcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5MSUZFX1BFUkNFTlRJTEUpID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkxJRkVfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9MT1dfTElGRV9FWFBdID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9MT1dfTElGRV9FWFBdIDpcbiAgICAgIG51bGwsXG4gIH07XG5cbiAgLy8gSG91c2luZyBjYXRlZ29yeVxuICBjb25zdCBoaXN0b3JpY1VuZGVyaW52ZXN0OiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuSElTVF9VTkRFUklOVkVTVCxcbiAgICApLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5ISVNUX1VOREVSSU5WRVNULFxuICAgICksXG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgdmFsdWU6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXG4gICAgICAgIGNvbnN0YW50cy5ISVNUT1JJQ19VTkRFUklOVkVTVE1FTlRfRVhDRUVEX1RIUkVTSCxcbiAgICApID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkhJU1RPUklDX1VOREVSSU5WRVNUTUVOVF9FWENFRURfVEhSRVNIXSA9PT1cbiAgICAgICAgY29uc3RhbnRzLkhJU1RPUklDX1VOREVSSU5WRVNUTUVOVF9SQVdfWUVTID9cbiAgICAgICAgdHJ1ZSA6XG4gICAgICAgIGZhbHNlIDpcbiAgICAgIG51bGwsXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOlxuICAgICAgcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICBjb25zdGFudHMuSElTVE9SSUNfVU5ERVJJTlZFU1RNRU5UX0VYQ0VFRF9USFJFU0gsXG4gICAgICApICYmXG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5ISVNUT1JJQ19VTkRFUklOVkVTVE1FTlRfRVhDRUVEX1RIUkVTSF0gPT09XG4gICAgICAgIGNvbnN0YW50cy5ISVNUT1JJQ19VTkRFUklOVkVTVE1FTlRfUkFXX1lFUyA/XG4gICAgICAgIHRydWUgOlxuICAgICAgICBmYWxzZSxcbiAgfTtcbiAgY29uc3QgaG91c2VDb3N0OiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5IT1VTRV9DT1NUKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uSE9VU0VfQ09TVCxcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFxuICAgICAgICBjb25zdGFudHMuSE9VU0lOR19CVVJERU5fUFJPUEVSVFlfUEVSQ0VOVElMRSxcbiAgICApID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkhPVVNJTkdfQlVSREVOX1BST1BFUlRZX1BFUkNFTlRJTEVdIDpcbiAgICAgIG51bGwsXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfSE9VU0VfQlVSREVOXSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfSE9VU0VfQlVSREVOXSA6XG4gICAgICBudWxsLFxuICB9O1xuICBjb25zdCBsYWNrR3JlZW5TcGFjZTogaW5kaWNhdG9ySW5mbyA9IHtcbiAgICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLkxBQ0tfR1JFRU5fU1BBQ0UsXG4gICAgKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uTEFDS19HUkVFTl9TUEFDRSxcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5JTVBFUlZJT1VTX1BFUkNFTlRJTEUpID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklNUEVSVklPVVNfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0lNUEVSVklPVVNdID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0lNUEVSVklPVVNdIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IGxhY2tQbHVtYmluZzogaW5kaWNhdG9ySW5mbyA9IHtcbiAgICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuTEFDS19QTFVNQklORyksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLkxBQ0tfUExVTUJJTkcsXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuS0lUQ0hFTl9QTFVNQl9QRVJDRU5USUxFKSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5LSVRDSEVOX1BMVU1CX1BFUkNFTlRJTEVdIDpcbiAgICAgIG51bGwsXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9LSVRDSEVOX1BMVU1CXSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9LSVRDSEVOX1BMVU1CXSA6XG4gICAgICBudWxsLFxuICB9O1xuICBjb25zdCBsZWFkUGFpbnQ6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLkxFQURfUEFJTlQpLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5MRUFEX1BBSU5ULFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50aWxlXCIsXG4gICAgdmFsdWU6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnRzLkxFQURfUEFJTlRfUEVSQ0VOVElMRSkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuTEVBRF9QQUlOVF9QRVJDRU5USUxFXSA6XG4gICAgICBudWxsLFxuICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tcbiAgICAgICAgY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9MRUFEX1BBSU5UX0FORF9NRURJQU5fSE9NRV9WQUxcbiAgICBdID9cbiAgICAgIHByb3BlcnRpZXNbXG4gICAgICAgICAgY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9MRUFEX1BBSU5UX0FORF9NRURJQU5fSE9NRV9WQUxcbiAgICAgIF0gOlxuICAgICAgbnVsbCxcbiAgfTtcblxuICAvLyBQb2xsdXRpb24gY2F0ZWdlb3J5XG4gIGNvbnN0IGFiYW5kb25NaW5lczogaW5kaWNhdG9ySW5mbyA9IHtcbiAgICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuQUJBTkRPTl9NSU5FUyksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLkFCQU5ET05fTUlORVMsXG4gICAgKSxcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgY29uc3RhbnRzLkFCQU5ET05fTEFORF9NSU5FU19FWENFRURTX1RIUkVTSCxcbiAgICApID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkFCQU5ET05fTEFORF9NSU5FU19FWENFRURTX1RIUkVTSF0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXG4gICAgICAgIGNvbnN0YW50cy5BQkFORE9OX0xBTkRfTUlORVNfRVhDRUVEU19USFJFU0gsXG4gICAgKSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5BQkFORE9OX0xBTkRfTUlORVNfRVhDRUVEU19USFJFU0hdIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IGZvcm1lckRlZlNpdGVzOiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuRk9STUVSX0RFRl9TSVRFUyxcbiAgICApLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5GT1JNRVJfREVGX1NJVEVTLFxuICAgICksXG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgLy8gZG91YmxlIGVxdWFsaXR5IGlzIHVzZWQgaW4gdGhpcyBpbnN0YW5jZSBhcyBpdCBzZWVtcyB0aGF0IEZVRFNfUkFXIGNvdWxkIGJlIFwiMVwiIG9yIDEgZnJvbSB0aGUgQkVcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuRk9STUVSX0RFRl9TSVRFU19SQVdfVkFMVUUpID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkZPUk1FUl9ERUZfU0lURVNfUkFXX1ZBTFVFXSA9PVxuICAgICAgICBjb25zdGFudHMuRlVEU19SQVdfWUVTID9cbiAgICAgICAgdHJ1ZSA6XG4gICAgICAgIGZhbHNlIDpcbiAgICAgIG51bGwsXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFxuICAgICAgICBjb25zdGFudHMuRk9STUVSX0RFRl9TSVRFU19FWENFRURTX1RIUkVTSCxcbiAgICApID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkZPUk1FUl9ERUZfU0lURVNfRVhDRUVEU19USFJFU0hdIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IHByb3hIYXo6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLlBST1hfSEFaKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uUFJPWF9IQVosXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuUFJPWElNSVRZX1RTREZfU0lURVNfUEVSQ0VOVElMRSkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuUFJPWElNSVRZX1RTREZfU0lURVNfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9IQVpBUkRfV0FTVEVdID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9IQVpBUkRfV0FTVEVdIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IHByb3hSTVA6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLlBST1hfUk1QKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uUFJPWF9STVAsXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuUFJPWElNSVRZX1JNUF9TSVRFU19QRVJDRU5USUxFKSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5QUk9YSU1JVFlfUk1QX1NJVEVTX1BFUkNFTlRJTEVdIDpcbiAgICAgIG51bGwsXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfUk1QXSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfUk1QXSA6XG4gICAgICBudWxsLFxuICB9O1xuICBjb25zdCBwcm94TlBMOiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5QUk9YX05QTCksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLlBST1hfTlBMLFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50aWxlXCIsXG4gICAgdmFsdWU6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnRzLlBST1hJTUlUWV9OUExfU0lURVNfUEVSQ0VOVElMRSkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuUFJPWElNSVRZX05QTF9TSVRFU19QRVJDRU5USUxFXSA6XG4gICAgICBudWxsLFxuICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX1NVUEVSRlVORF0gP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX1NVUEVSRlVORF0gOlxuICAgICAgbnVsbCxcbiAgfTtcblxuICAvLyBUcmFuc3BvdGF0aW9uIGNhdGVnb3J5XG4gIGNvbnN0IGRpZXNlbFBhcnRNYXR0ZXI6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5ESUVTRUxfUEFSVElDVUxBVEVfTUFUVEVSLFxuICAgICksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLkRJRVNFTF9QQVJUSUNVTEFURV9NQVRURVIsXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudHMuRElFU0VMX01BVFRFUl9QRVJDRU5USUxFKSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5ESUVTRUxfTUFUVEVSX1BFUkNFTlRJTEVdIDpcbiAgICAgIG51bGwsXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfRElFU0VMX1BNXSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfRElFU0VMX1BNXSA6XG4gICAgICBudWxsLFxuICB9O1xuICBjb25zdCBiYXJyaWVyVHJhbnNwb3J0OiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5CQVJSSUVSX1RSQU5TKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uQkFSUklFUl9UUkFOUyxcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5UUkFWRUxfRElTQURWX1BFUkNFTlRJTEUpID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlRSQVZFTF9ESVNBRFZfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX1RSQVZFTF9ESVNBRFZdID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX1RSQVZFTF9ESVNBRFZdIDpcbiAgICAgIG51bGwsXG4gIH07XG4gIGNvbnN0IHRyYWZmaWNWb2x1bWU6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5UUkFGRklDX1ZPTFVNRSxcbiAgICApLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5UUkFGRklDX1ZPTFVNRSxcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5UUkFGRklDX1BFUkNFTlRJTEUpID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlRSQUZGSUNfUEVSQ0VOVElMRV0gOlxuICAgICAgbnVsbCxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9UUkFGRklDX1BST1hdID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9UUkFGRklDX1BST1hdIDpcbiAgICAgIG51bGwsXG4gIH07XG5cbiAgLy8gV2F0ZXIgY2F0ZWdvcnlcbiAgY29uc3QgbGVha3lUYW5rczogaW5kaWNhdG9ySW5mbyA9IHtcbiAgICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuTEVBS1lfVEFOS1MpLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5MRUFLWV9UQU5LUyxcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGNvbnN0YW50cy5MRUFLWV9VTkRFUl9QRVJDRU5USUxFKSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5MRUFLWV9VTkRFUl9QRVJDRU5USUxFXSA6XG4gICAgICBudWxsLFxuICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfTEVBS1lfVU5ERVJdID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0xFQUtZX1VOREVSXSA6XG4gICAgICBudWxsLFxuICB9O1xuICBjb25zdCB3YXN0ZVdhdGVyOiBpbmRpY2F0b3JJbmZvID0ge1xuICAgIGxhYmVsOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SUy5XQVNURV9XQVRFUiksXG4gICAgZGVzY3JpcHRpb246IGludGwuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5ESUNBVE9SX0RFU0NSSVBUSU9OLldBU1RFX1dBVEVSLFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50aWxlXCIsXG4gICAgdmFsdWU6IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnRzLldBU1RFV0FURVJfUEVSQ0VOVElMRSkgP1xuICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuV0FTVEVXQVRFUl9QRVJDRU5USUxFXSA6XG4gICAgICBudWxsLFxuICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEU19USFJFU0hfRk9SX1dBU1RFV0FURVJdID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9XQVNURVdBVEVSXSA6XG4gICAgICBudWxsLFxuICB9O1xuXG4gIC8vIFdvcmtmb3JjZSBkZXYgY2F0ZWdvcnlcbiAgY29uc3QgbGluZ0lzbzogaW5kaWNhdG9ySW5mbyA9IHtcbiAgICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuTElOR19JU08pLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5MSU5HX0lTTyxcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudGlsZVwiLFxuICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFxuICAgICAgICBjb25zdGFudHMuTElOR1VJU1RJQ19JU09MQVRJT05fUFJPUEVSVFlfUEVSQ0VOVElMRSxcbiAgICApID9cbiAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkxJTkdVSVNUSUNfSVNPTEFUSU9OX1BST1BFUlRZX1BFUkNFTlRJTEVdIDpcbiAgICAgIG51bGwsXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfTElOR1VJU0lUSUNfSVNPXSA/XG4gICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURTX1RIUkVTSF9GT1JfTElOR1VJU0lUSUNfSVNPXSA6XG4gICAgICBudWxsLFxuICB9O1xuICBjb25zdCBsb3dNZWRJbmM6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLkxPV19NRURfSU5DKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uTE9XX01FRF9JTkNPTUUsXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogZ2V0V29ya0ZvcmNlSW5kaWNhdG9yVmFsdWUoXCJsb3dNZWRJbmNcIiksXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBnZXRXb3JrRm9yY2VJbmRpY2F0b3JJc0Rpc2FkdihcImxvd01lZEluY1wiKSxcbiAgfTtcbiAgY29uc3QgdW5lbXBsb3k6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLlVORU1QTE9ZKSxcbiAgICBkZXNjcmlwdGlvbjogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JfREVTQ1JJUFRJT04uVU5FTVBMT1ksXG4gICAgKSxcbiAgICB0eXBlOiBcInBlcmNlbnRpbGVcIixcbiAgICB2YWx1ZTogZ2V0V29ya0ZvcmNlSW5kaWNhdG9yVmFsdWUoXCJ1bmVtcGxveVwiKSxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IGdldFdvcmtGb3JjZUluZGljYXRvcklzRGlzYWR2KFwidW5lbXBsb3lcIiksXG4gIH07XG4gIGNvbnN0IHBvdmVydHk6IGluZGljYXRvckluZm8gPSB7XG4gICAgbGFiZWw6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTkRJQ0FUT1JTLlBPVkVSVFkpLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5QT1ZFUlRZLFxuICAgICksXG4gICAgdHlwZTogXCJwZXJjZW50aWxlXCIsXG4gICAgdmFsdWU6IGdldFdvcmtGb3JjZUluZGljYXRvclZhbHVlKFwicG92ZXJ0eVwiKSxcbiAgICBpc0Rpc2FkdmFndGFnZWQ6IGdldFdvcmtGb3JjZUluZGljYXRvcklzRGlzYWR2KFwicG92ZXJ0eVwiKSxcbiAgfTtcbiAgY29uc3QgaGlnaFNjaG9vbDogaW5kaWNhdG9ySW5mbyA9IHtcbiAgICBsYWJlbDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUlMuSElHSF9TQ0wpLFxuICAgIGRlc2NyaXB0aW9uOiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTi5ISUdIX1NLTCxcbiAgICApLFxuICAgIHR5cGU6IFwicGVyY2VudFwiLFxuICAgIHZhbHVlOiBnZXRXb3JrRm9yY2VJbmRpY2F0b3JWYWx1ZShcImhpZ2hTY2hvb2xcIiksXG4gICAgaXNEaXNhZHZhZ3RhZ2VkOiBnZXRXb3JrRm9yY2VJbmRpY2F0b3JJc0Rpc2FkdihcImhpZ2hTY2hvb2xcIiksXG4gICAgdGhyZXNob2xkOiAxMCxcbiAgfTtcblxuICAvKipcbiAgICogQWdncmVnYXRlIGluZGljYXRvcnMgYmFzZWQgb24gY2F0ZWdvcmllc1xuICAgKlxuICAgKiBUaGUgaW5kaWNhdG9ycyBwcm9wZXJ0eSBtdXN0IGJlIGFuIGFycmF5IHdpdGggbGFzdCB0d28gZWxlbWVudHMgYmVpbmcgdGhlXG4gICAqIHNvY2lvZWNvbm9taWMgYnVyZGVucy5cbiAgICovXG4gIGxldCBjYXRlZ29yaWVzOiBJQ2F0ZWdvcnlbXSA9IFtcbiAgICB7XG4gICAgICBpZDogXCJjbGltYXRlLWNoYW5nZVwiLFxuICAgICAgdGl0bGVUZXh0OiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfQ0FURUdPUlkuQ0xJTUFURSksXG4gICAgICBpbmRpY2F0b3JzOiBbZXhwQWdMb3NzLCBleHBCbGRMb3NzLCBleHBQb3BMb3NzLCBmbG9vZGluZywgd2lsZGZpcmVdLFxuICAgICAgc29jaW9FY0luZGljYXRvcnM6IFtsb3dJbmNdLFxuICAgICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19DTElNQVRFX0ZBQ1RPUl9ESVNBRFZBTlRBR0VEXSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0NMSU1BVEVfRkFDVE9SX0RJU0FEVkFOVEFHRURdIDpcbiAgICAgICAgbnVsbCxcbiAgICAgIGlzRXhjZWVkMU1vcmVCdXJkZW46IHByb3BlcnRpZXNbXG4gICAgICAgICAgY29uc3RhbnRzLklTX0NMSU1BVEVfRVhDRUVEX09ORV9PUl9NT1JFX0lORElDQVRPUlNcbiAgICAgIF0gP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19DTElNQVRFX0VYQ0VFRF9PTkVfT1JfTU9SRV9JTkRJQ0FUT1JTXSA6XG4gICAgICAgIG51bGwsXG4gICAgICBpc0V4Y2VlZEJvdGhTb2Npb0J1cmRlbnM6IHByb3BlcnRpZXNbXG4gICAgICAgICAgY29uc3RhbnRzLklTX0VYQ0VFRF9CT1RIX1NPQ0lPX0lORElDQVRPUlNcbiAgICAgIF0gP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURfQk9USF9TT0NJT19JTkRJQ0FUT1JTXSA6XG4gICAgICAgIG51bGwsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogXCJjbGVhbi1lbmVyZ3lcIixcbiAgICAgIHRpdGxlVGV4dDogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0NBVEVHT1JZLkNMRUFOX0VORVJHWSxcbiAgICAgICksXG4gICAgICBpbmRpY2F0b3JzOiBbZW5lcmd5Q29zdCwgcG0yNV0sXG4gICAgICBzb2Npb0VjSW5kaWNhdG9yczogW2xvd0luY10sXG4gICAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VORVJHWV9GQUNUT1JfRElTQURWQU5UQUdFRF0gP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FTkVSR1lfRkFDVE9SX0RJU0FEVkFOVEFHRURdIDpcbiAgICAgICAgbnVsbCxcbiAgICAgIGlzRXhjZWVkMU1vcmVCdXJkZW46IHByb3BlcnRpZXNbXG4gICAgICAgICAgY29uc3RhbnRzLklTX0VORVJHWV9FWENFRURfT05FX09SX01PUkVfSU5ESUNBVE9SU1xuICAgICAgXSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VORVJHWV9FWENFRURfT05FX09SX01PUkVfSU5ESUNBVE9SU10gOlxuICAgICAgICBudWxsLFxuICAgICAgaXNFeGNlZWRCb3RoU29jaW9CdXJkZW5zOiBwcm9wZXJ0aWVzW1xuICAgICAgICAgIGNvbnN0YW50cy5JU19FWENFRURfQk9USF9TT0NJT19JTkRJQ0FUT1JTXG4gICAgICBdID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEX0JPVEhfU09DSU9fSU5ESUNBVE9SU10gOlxuICAgICAgICBudWxsLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IFwiaGVhbHRoLWJ1cmRlbnNcIixcbiAgICAgIHRpdGxlVGV4dDogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0NBVEVHT1JZLkhFQUxUSF9CVVJERU4sXG4gICAgICApLFxuICAgICAgaW5kaWNhdG9yczogW2FzdGhtYSwgZGlhYmV0ZXMsIGhlYXJ0RGlzZWFzZSwgbGlmZUV4cGVjdF0sXG4gICAgICBzb2Npb0VjSW5kaWNhdG9yczogW2xvd0luY10sXG4gICAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0hFQUxUSF9GQUNUT1JfRElTQURWQU5UQUdFRF0gP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19IRUFMVEhfRkFDVE9SX0RJU0FEVkFOVEFHRURdIDpcbiAgICAgICAgbnVsbCxcbiAgICAgIGlzRXhjZWVkMU1vcmVCdXJkZW46IHByb3BlcnRpZXNbXG4gICAgICAgICAgY29uc3RhbnRzLklTX0hFQUxUSF9FWENFRURfT05FX09SX01PUkVfSU5ESUNBVE9SU1xuICAgICAgXSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0hFQUxUSF9FWENFRURfT05FX09SX01PUkVfSU5ESUNBVE9SU10gOlxuICAgICAgICBudWxsLFxuICAgICAgaXNFeGNlZWRCb3RoU29jaW9CdXJkZW5zOiBwcm9wZXJ0aWVzW1xuICAgICAgICAgIGNvbnN0YW50cy5JU19FWENFRURfQk9USF9TT0NJT19JTkRJQ0FUT1JTXG4gICAgICBdID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEX0JPVEhfU09DSU9fSU5ESUNBVE9SU10gOlxuICAgICAgICBudWxsLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IFwic3VzdGFpbi1ob3VzZVwiLFxuICAgICAgdGl0bGVUZXh0OiBpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfQ0FURUdPUlkuU1VTVEFJTl9IT1VTRSxcbiAgICAgICksXG4gICAgICBpbmRpY2F0b3JzOiBbXG4gICAgICAgIGhpc3RvcmljVW5kZXJpbnZlc3QsXG4gICAgICAgIGhvdXNlQ29zdCxcbiAgICAgICAgbGFja0dyZWVuU3BhY2UsXG4gICAgICAgIGxhY2tQbHVtYmluZyxcbiAgICAgICAgbGVhZFBhaW50LFxuICAgICAgXSxcbiAgICAgIHNvY2lvRWNJbmRpY2F0b3JzOiBbbG93SW5jXSxcbiAgICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfSE9VU0lOR19GQUNUT1JfRElTQURWQU5UQUdFRF0gP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19IT1VTSU5HX0ZBQ1RPUl9ESVNBRFZBTlRBR0VEXSA6XG4gICAgICAgIG51bGwsXG4gICAgICBpc0V4Y2VlZDFNb3JlQnVyZGVuOiBwcm9wZXJ0aWVzW1xuICAgICAgICAgIGNvbnN0YW50cy5JU19IT1VTSU5HX0VYQ0VFRF9PTkVfT1JfTU9SRV9JTkRJQ0FUT1JTXG4gICAgICBdID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfSE9VU0lOR19FWENFRURfT05FX09SX01PUkVfSU5ESUNBVE9SU10gOlxuICAgICAgICBudWxsLFxuICAgICAgaXNFeGNlZWRCb3RoU29jaW9CdXJkZW5zOiBwcm9wZXJ0aWVzW1xuICAgICAgICAgIGNvbnN0YW50cy5JU19FWENFRURfQk9USF9TT0NJT19JTkRJQ0FUT1JTXG4gICAgICBdID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEX0JPVEhfU09DSU9fSU5ESUNBVE9SU10gOlxuICAgICAgICBudWxsLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IFwibGVnLXBvbGx1dGVcIixcbiAgICAgIHRpdGxlVGV4dDogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0NBVEVHT1JZLkxFR19QT0xMVVRFLFxuICAgICAgKSxcbiAgICAgIGluZGljYXRvcnM6IFthYmFuZG9uTWluZXMsIGZvcm1lckRlZlNpdGVzLCBwcm94SGF6LCBwcm94Uk1QLCBwcm94TlBMXSxcbiAgICAgIHNvY2lvRWNJbmRpY2F0b3JzOiBbbG93SW5jXSxcbiAgICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfUE9MTFVUSU9OX0ZBQ1RPUl9ESVNBRFZBTlRBR0VEXSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX1BPTExVVElPTl9GQUNUT1JfRElTQURWQU5UQUdFRF0gOlxuICAgICAgICBudWxsLFxuICAgICAgaXNFeGNlZWQxTW9yZUJ1cmRlbjogcHJvcGVydGllc1tcbiAgICAgICAgICBjb25zdGFudHMuSVNfUE9MTFVUSU9OX0VYQ0VFRF9PTkVfT1JfTU9SRV9JTkRJQ0FUT1JTXG4gICAgICBdID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfUE9MTFVUSU9OX0VYQ0VFRF9PTkVfT1JfTU9SRV9JTkRJQ0FUT1JTXSA6XG4gICAgICAgIG51bGwsXG4gICAgICBpc0V4Y2VlZEJvdGhTb2Npb0J1cmRlbnM6IHByb3BlcnRpZXNbXG4gICAgICAgICAgY29uc3RhbnRzLklTX0VYQ0VFRF9CT1RIX1NPQ0lPX0lORElDQVRPUlNcbiAgICAgIF0gP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19FWENFRURfQk9USF9TT0NJT19JTkRJQ0FUT1JTXSA6XG4gICAgICAgIG51bGwsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogXCJjbGVhbi10cmFuc3BvcnRcIixcbiAgICAgIHRpdGxlVGV4dDogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0NBVEVHT1JZLkNMRUFOX1RSQU5TUE9SVCxcbiAgICAgICksXG4gICAgICBpbmRpY2F0b3JzOiBbZGllc2VsUGFydE1hdHRlciwgYmFycmllclRyYW5zcG9ydCwgdHJhZmZpY1ZvbHVtZV0sXG4gICAgICBzb2Npb0VjSW5kaWNhdG9yczogW2xvd0luY10sXG4gICAgICBpc0Rpc2FkdmFndGFnZWQ6IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX1RSQU5TUE9SVF9GQUNUT1JfRElTQURWQU5UQUdFRF0gP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19UUkFOU1BPUlRfRkFDVE9SX0RJU0FEVkFOVEFHRURdIDpcbiAgICAgICAgbnVsbCxcbiAgICAgIGlzRXhjZWVkMU1vcmVCdXJkZW46IHByb3BlcnRpZXNbXG4gICAgICAgICAgY29uc3RhbnRzLklTX1RSQU5TUE9SVF9FWENFRURfT05FX09SX01PUkVfSU5ESUNBVE9SU1xuICAgICAgXSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX1RSQU5TUE9SVF9FWENFRURfT05FX09SX01PUkVfSU5ESUNBVE9SU10gOlxuICAgICAgICBudWxsLFxuICAgICAgaXNFeGNlZWRCb3RoU29jaW9CdXJkZW5zOiBwcm9wZXJ0aWVzW1xuICAgICAgICAgIGNvbnN0YW50cy5JU19FWENFRURfQk9USF9TT0NJT19JTkRJQ0FUT1JTXG4gICAgICBdID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfRVhDRUVEX0JPVEhfU09DSU9fSU5ESUNBVE9SU10gOlxuICAgICAgICBudWxsLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IFwiY2xlYW4td2F0ZXJcIixcbiAgICAgIHRpdGxlVGV4dDogaW50bC5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAgIEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0NBVEVHT1JZLkNMRUFOX1dBVEVSLFxuICAgICAgKSxcbiAgICAgIGluZGljYXRvcnM6IFtsZWFreVRhbmtzLCB3YXN0ZVdhdGVyXSxcbiAgICAgIHNvY2lvRWNJbmRpY2F0b3JzOiBbbG93SW5jXSxcbiAgICAgIGlzRGlzYWR2YWd0YWdlZDogcHJvcGVydGllc1tjb25zdGFudHMuSVNfV0FURVJfRkFDVE9SX0RJU0FEVkFOVEFHRURdID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfV0FURVJfRkFDVE9SX0RJU0FEVkFOVEFHRURdIDpcbiAgICAgICAgbnVsbCxcbiAgICAgIGlzRXhjZWVkMU1vcmVCdXJkZW46IHByb3BlcnRpZXNbXG4gICAgICAgICAgY29uc3RhbnRzLklTX1dBVEVSX0VYQ0VFRF9PTkVfT1JfTU9SRV9JTkRJQ0FUT1JTXG4gICAgICBdID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfV0FURVJfRVhDRUVEX09ORV9PUl9NT1JFX0lORElDQVRPUlNdIDpcbiAgICAgICAgbnVsbCxcbiAgICAgIGlzRXhjZWVkQm90aFNvY2lvQnVyZGVuczogcHJvcGVydGllc1tcbiAgICAgICAgICBjb25zdGFudHMuSVNfRVhDRUVEX0JPVEhfU09DSU9fSU5ESUNBVE9SU1xuICAgICAgXSA/XG4gICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0VYQ0VFRF9CT1RIX1NPQ0lPX0lORElDQVRPUlNdIDpcbiAgICAgICAgbnVsbCxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBcIndvcmstZGV2XCIsXG4gICAgICB0aXRsZVRleHQ6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9DQVRFR09SWS5XT1JLX0RFViksXG4gICAgICBpbmRpY2F0b3JzOiBbbGluZ0lzbywgbG93TWVkSW5jLCBwb3ZlcnR5LCB1bmVtcGxveV0sXG4gICAgICBzb2Npb0VjSW5kaWNhdG9yczogW2hpZ2hTY2hvb2xdLFxuICAgICAgaXNEaXNhZHZhZ3RhZ2VkOiBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19XT1JLRk9SQ0VfRkFDVE9SX0RJU0FEVkFOVEFHRURdID9cbiAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuSVNfV09SS0ZPUkNFX0ZBQ1RPUl9ESVNBRFZBTlRBR0VEXSA6XG4gICAgICAgIG51bGwsXG4gICAgICBpc0V4Y2VlZDFNb3JlQnVyZGVuOiBwcm9wZXJ0aWVzW1xuICAgICAgICAgIGNvbnN0YW50cy5JU19XT1JLRk9SQ0VfRVhDRUVEX09ORV9PUl9NT1JFX0lORElDQVRPUlNcbiAgICAgIF0gP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19XT1JLRk9SQ0VfRVhDRUVEX09ORV9PUl9NT1JFX0lORElDQVRPUlNdIDpcbiAgICAgICAgbnVsbCxcbiAgICAgIGlzRXhjZWVkQm90aFNvY2lvQnVyZGVuczogcHJvcGVydGllc1tcbiAgICAgICAgICBjb25zdGFudHMuSVNfV09SS0ZPUkNFX0VYQ0VFRF9CT1RIX1NPQ0lPX0lORElDQVRPUlNcbiAgICAgIF0gP1xuICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JU19XT1JLRk9SQ0VfRVhDRUVEX0JPVEhfU09DSU9fSU5ESUNBVE9SU10gOlxuICAgICAgICBudWxsLFxuICAgIH0sXG4gIF07XG5cbiAgLyoqXG4gICAqIE1vZGlmeSB0aGUgY2F0ZWdvcnkgYXJyYXkgZGVwZW5kaW5nIG9uIHRoZSBzaWRlUGFuZWxTdGF0ZSBmaWVsZC4gVGhpcyBmaWVsZCBjb21lcyBmcm9tIHRoZSBiYWNrZW5kXG4gICAqIGFuZCBpcyBjYWxsZWQgVUlfRVhQLlxuICAgKlxuICAgKiBUaGlzIHNpZGVQYW5lbFN0YXRlIGhhcyAzIHZhbHVlczsgbmFtZWx5LCBOYXRpb24sIFB1ZXJ0byBSaWNvIGFuZCBJc2xhbmQgQXJlYXMuXG4gICAqL1xuICBpZiAoc2lkZVBhbmVsU3RhdGUgPT09IGNvbnN0YW50cy5TSURFX1BBTkVMX1NUQVRFX1ZBTFVFUy5QVUVSVE9fUklDTykge1xuICAgIC8vIFJlLWRlZmluZSB3aGljaCBidXJkZW5zIHNob3cgdXAgZm9yIGVhY2ggY2F0ZWdvcnk6XG5cbiAgICBzZXRDYXRlZ29yeUluZGljYXRvcnMoJ2NsaW1hdGUtY2hhbmdlJywgW2Zsb29kaW5nXSk7XG4gICAgc2V0Q2F0ZWdvcnlJbmRpY2F0b3JzKCdjbGVhbi1lbmVyZ3knLCBbZW5lcmd5Q29zdF0pO1xuICAgIHNldENhdGVnb3J5SW5kaWNhdG9ycygnc3VzdGFpbi1ob3VzZScsIFtoaXN0b3JpY1VuZGVyaW52ZXN0LCBob3VzZUNvc3QsIGxhY2tQbHVtYmluZywgbGVhZFBhaW50XSk7XG4gICAgc2V0Q2F0ZWdvcnlJbmRpY2F0b3JzKCdsZWctcG9sbHV0ZScsIFtwcm94SGF6LCBwcm94Uk1QLCBwcm94TlBMXSk7XG4gICAgc2V0Q2F0ZWdvcnlJbmRpY2F0b3JzKCdjbGVhbi10cmFuc3BvcnQnLCBbZGllc2VsUGFydE1hdHRlciwgdHJhZmZpY1ZvbHVtZV0pO1xuICAgIHNldENhdGVnb3J5SW5kaWNhdG9ycygnd29yay1kZXYnLCBbbG93TWVkSW5jLCBwb3ZlcnR5LCB1bmVtcGxveV0pO1xuICB9XG5cbiAgaWYgKHNpZGVQYW5lbFN0YXRlID09PSBjb25zdGFudHMuU0lERV9QQU5FTF9TVEFURV9WQUxVRVMuSVNMQU5EX0FSRUFTKSB7XG4gICAgLy8gRm9yIElzbGFuZCBBcmVhcyAtIG9ubHkgc2hvdyB3b3JrZm9yY2UgZGV2IGNhdGVnb3J5XG4gICAgY2F0ZWdvcmllcyA9IGNhdGVnb3JpZXMuZmlsdGVyKChjYXRlZ29yeSkgPT4gY2F0ZWdvcnkuaWQgPT09IFwid29yay1kZXZcIik7XG4gICAgLy8gRm9yIElzbGFuZCBBcmVhcyAtIHJlbW92ZSB0aGUgbGluZ3Vpc3RpYyBJc29sYXRpb25cbiAgICBjYXRlZ29yaWVzWzBdLmluZGljYXRvcnMgPSBbbG93TWVkSW5jLCB1bmVtcGxveSwgcG92ZXJ0eV07XG4gIH1cblxuICBjb25zdCBpc1RlcnJpdG9yeSA9IGNvbnN0YW50cy5USUxFU19JU0xBTkRfQVJFQV9GSVBTX0NPREVTLnNvbWUoKGNvZGUpID0+IHtcbiAgICByZXR1cm4gcHJvcGVydGllc1tjb25zdGFudHMuR0VPSURfUFJPUEVSVFldLnN0YXJ0c1dpdGgoY29kZSk7XG4gIH0pO1xuXG4gIGNvbnN0IGlzR3JhbmRmYXRoZXJlZCA9IHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0dSQU5ERkFUSEVSRURdO1xuICAvLyBTaG93IERvbnV0IGluZm9ybWF0aW9uICFpc0dyYW5kZmF0aGVyZWRcbiAgY29uc3Qgc2hvd0RvbnV0Q29weSA9ICFpc0dyYW5kZmF0aGVyZWQgJiZcbiAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5BREpBQ0VOQ1lfRVhDRUVEU19USFJFU0hdICYmXG4gICAgcHJvcGVydGllc1tjb25zdGFudHMuVE9UQUxfTlVNQkVSX09GX0RJU0FEVkFOVEFHRV9JTkRJQ0FUT1JTXSA9PT0gMDtcbiAgY29uc3Qgc2hvd0lzbGFuZENvcHkgPSBpc1RlcnJpdG9yeSAmJiAhc2hvd0RvbnV0Q29weTtcblxuICAvLyBGb3IgdGVycml0b3JpZXMgd2UgdXNlIHRoZSBwb3ZlcnR5IHBlcmNlbnRpbGUgZnJvbSB0aGUgY2Vuc3VzIGRlY2VubmlhbCBkYXRhXG4gIGNvbnN0IHBvdmVyeVBlcmNlbnRpbGUgPSBpc1RlcnJpdG9yeSA/XG4gICAgcHJvcGVydGllc1tjb25zdGFudHMuQ0VOU1VTX0RFQ0VOTklBTF9QT1ZFUlRZX0xFU1NfVEhBTl8yMDBfRlBMX1BFUkNFTlRJTEVdIDpcbiAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5QT1ZFUlRZX0JFTE9XXzIwMF9QRVJDRU5USUxFXSA+IDAgP1xuICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlBPVkVSVFlfQkVMT1dfMjAwX1BFUkNFTlRJTEVdIDpcbiAgICBudWxsO1xuICAvKipcbiAgICogQ3JlYXRlIHRoZSBBY2NvcmlkaW9uSXRlbXMgYnkgbWFwcGluZyBvdmVyIHRoZSBjYXRlZ29yaWVzIGFycmF5LiBJbiB0aGlzIGFycmF5IHdlIGRlZmluZSB0aGVcbiAgICogdmFyaW91cyBpbmRpY2F0b3JzIGZvciBhIHNwZWNpZmljIGNhdGVnb3J5LiBUaGlzIGlzIGFuIGFycmF5IHdoaWNoIHRoZW4gbWFwcyBvdmVyIHRoZVxuICAgKiA8SW5kaWNhdG9yIC8+IGNvbXBvbmVudCB0byByZW5kZXIgdGhlIGFjdHVhbCBJbmRpY2F0b3JcbiAgICovXG4gIGNvbnN0IGNhdGVnb3J5SXRlbXMgPSBjYXRlZ29yaWVzLm1hcCgoY2F0ZWdvcnkpID0+ICh7XG4gICAgaWQ6IGNhdGVnb3J5LmlkLFxuXG4gICAgLypcbiAgICBBcyBvZiB0cnVzc3dvcmtzIDMuMC4wLCB0aGVyZSB3ZXJlIHNvbWUgYnJlYWtpbmcgY2hhbmdlcy4gVGhpcyBuZXcgcHJvcCBvZiBoZWFkaW5nTGV2ZWxcbiAgICBpcyByZXF1aXJlZCwgaG93ZXZlciwgdGhlIHRpdGxlIHByb3AgaXMgYWxyZWFkeSBkZWZpbmluZyB0aGUgY2F0ZWdvcnkgc3R5bGluZywgc28gdGhpc1xuICAgIGlzIHBsYWNlZCBoZXJlIHRvIHNhdGlzZnkgdGhlIHJlcXVpcmVtZW50IG9mIHRoZSBBY2NvcmRpb25JdGVtcyBBUEksIGhvd2V2ZXIgaXQncyBub3RcbiAgICBiZWluZyB1c2VkLlxuXG4gICAgQ2FzdGluZyAnaDQnIGFzIGNvbnN0IGJlY2F1c2UgaXQgbmVlZHMgdG8gYmUgYSBoZWFkaW5nIHR5cGUgYXMgc3BlY2lmaWVkIEhlYWRpbmdMZXZlbC5cbiAgICAqL1xuICAgIGhlYWRpbmdMZXZlbDogXCJoNFwiIGFzIGNvbnN0LFxuXG4gICAgdGl0bGU6IChcbiAgICAgIDxDYXRlZ29yeVxuICAgICAgICBuYW1lPXtjYXRlZ29yeS50aXRsZVRleHR9XG4gICAgICAgIGlzRGlzYWR2YW50YWdlZD17Y2F0ZWdvcnkuaXNEaXNhZHZhZ3RhZ2VkfVxuICAgICAgLz5cbiAgICApLFxuICAgIGNvbnRlbnQ6IChcbiAgICAgIDw+XG4gICAgICAgIHsvKiBJbmRpY2F0b3JzIC0gZmlsdGVycyB0aGVuIG1hcCAqL31cbiAgICAgICAge2NhdGVnb3J5LmluZGljYXRvcnNcbiAgICAgICAgICAgIC5tYXAoKGluZGljYXRvcjogYW55LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiA8SW5kaWNhdG9yIGtleT17YGluZCR7aW5kZXh9YH0gaW5kaWNhdG9yPXtpbmRpY2F0b3J9IC8+O1xuICAgICAgICAgICAgfSl9XG5cbiAgICAgICAgey8qIEFORCAqL31cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jYXRlZ29yeVNwYWNlcn0+XG4gICAgICAgICAge0VYUExPUkVfQ09QWS5TSURFX1BBTkVMX1NQQUNFUlMuQU5EfVxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICB7Lyogc29jaW9lY29ub21pYyBpbmRpY2F0b3JzICovfVxuICAgICAgICB7Y2F0ZWdvcnkuc29jaW9FY0luZGljYXRvcnMubWFwKChpbmRpY2F0b3I6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8SW5kaWNhdG9yXG4gICAgICAgICAgICAgIGtleT17YGluZCR7aW5kZXh9YH1cbiAgICAgICAgICAgICAgaW5kaWNhdG9yPXtpbmRpY2F0b3J9XG4gICAgICAgICAgICAgIGlzSW1wdXRlPXtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5JTVBVVEVfRkxBR10gPT09IFwiMFwiID8gZmFsc2UgOiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcG9wdWxhdGlvbj17cG9wdWxhdGlvbn1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKTtcbiAgICAgICAgfSl9XG4gICAgICA8Lz5cbiAgICApLFxuICAgIGV4cGFuZGVkOiBmYWxzZSxcbiAgfSkpO1xuXG4gIHJldHVybiAoXG4gICAgPGFzaWRlIGNsYXNzTmFtZT17c3R5bGVzLmFyZWFEZXRhaWxDb250YWluZXJ9IGRhdGEtY3k9e1wiYXNpZGVcIn0+XG4gICAgICB7LyogVHJhY3QgSW5mbyAqL31cbiAgICAgIDxUcmFjdEluZm9cbiAgICAgICAgYmxvY2tHcm91cD17YmxvY2tHcm91cH1cbiAgICAgICAgY291bnR5TmFtZT17Y291bnR5TmFtZX1cbiAgICAgICAgc3RhdGVOYW1lPXtzdGF0ZU5hbWV9XG4gICAgICAgIHBvcHVsYXRpb249e3BvcHVsYXRpb259XG4gICAgICAgIHNpZGVQYW5lbFN0YXRlPXtwcm9wZXJ0aWVzW2NvbnN0YW50cy5TSURFX1BBTkVMX1NUQVRFXX1cbiAgICAgIC8+XG5cbiAgICAgIHsvKiBEZW1vZ3JhcGhpY3MgKi99XG4gICAgICA8VHJhY3REZW1vZ3JhcGhpY3MgcHJvcGVydGllcz17cHJvcGVydGllc30gLz5cblxuICAgICAgey8qIERpc2FkdmFudGFnZWQ/ICovfVxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jYXRlZ29yaXphdGlvbn0+XG4gICAgICAgIHsvKiBRdWVzdGlvbnMgYXNraW5nIGlmIGRpc2FkdmFudGFnZWQ/ICovfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmlzSW5Gb2N1c30+XG4gICAgICAgICAge0VYUExPUkVfQ09QWS5DT01NVU5JVFkuSVNfRk9DVVN9XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIHsvKiBZRVMsIE5PIG9yIFBBUlRJQUxMWSBkaXNhZHZhbnRhZ2VkICAqL31cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jb21tdW5pdHlPZkZvY3VzfT5cbiAgICAgICAgICA8VHJhY3RQcmlvcml0aXphdGlvblxuICAgICAgICAgICAgc2NvcmVOQ29tbXVuaXRpZXM9e1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5TQ09SRV9OX0NPTU1VTklUSUVTXSA9PT0gdHJ1ZSA/XG4gICAgICAgICAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuU0NPUkVfTl9DT01NVU5JVElFU10gOlxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmliYWxDb3VudEFLPXtcbiAgICAgICAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuVFJJQkFMX0FSRUFTX0NPVU5UX0FLXSA+PSAxID9cbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5UUklCQUxfQVJFQVNfQ09VTlRfQUtdIDpcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmliYWxDb3VudFVTPXtcbiAgICAgICAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuVFJJQkFMX0FSRUFTX0NPVU5UX0NPTlVTXSA+PSAxID9cbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5UUklCQUxfQVJFQVNfQ09VTlRfQ09OVVNdIDpcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZXJjZW50VHJhY3RUcmliYWw9e3BlcmNlbnRUcmFjdFRyaWJhbH1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnByaW9Db3B5fT5cbiAgICAgICAgICA8UHJpb3JpdGl6YXRpb25Db3B5XG4gICAgICAgICAgICB0b3RhbENhdGVnb3JpZXNQcmlvcml0aXplZD17XG4gICAgICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkNPVU5UX09GX0NBVEVHT1JJRVNfRElTQURWXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG90YWxCdXJkZW5zUHJpb3JpdGl6ZWQ9e1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5UT1RBTF9OVU1CRVJfT0ZfRElTQURWQU5UQUdFX0lORElDQVRPUlNdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0FkamFjZW5jeVRocmVzaE1ldD17XG4gICAgICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLkFESkFDRU5DWV9FWENFRURTX1RIUkVTSF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzQWRqYWNlbmN5TG93SW5jb21lPXtcbiAgICAgICAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuQURKQUNFTkNZX0xPV19JTkNPTUVfRVhDRUVEU19USFJFU0hdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0lzbGFuZExvd0luY29tZT17XG4gICAgICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0ZFREVSQUxfUE9WRVJUWV9MRVZFTF8yMDBdICYmXG4gICAgICAgICAgICAgIGNvbnN0YW50cy5USUxFU19JU0xBTkRfQVJFQV9GSVBTX0NPREVTLnNvbWUoKGNvZGUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydGllc1tjb25zdGFudHMuR0VPSURfUFJPUEVSVFldLnN0YXJ0c1dpdGgoY29kZSk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmliYWxDb3VudEFLPXtcbiAgICAgICAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuVFJJQkFMX0FSRUFTX0NPVU5UX0FLXSA+PSAxID9cbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5UUklCQUxfQVJFQVNfQ09VTlRfQUtdIDpcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmliYWxDb3VudFVTPXtcbiAgICAgICAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuVFJJQkFMX0FSRUFTX0NPVU5UX0NPTlVTXSA+PSAxID9cbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5UUklCQUxfQVJFQVNfQ09VTlRfQ09OVVNdIDpcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZXJjZW50VHJhY3RUcmliYWw9e3BlcmNlbnRUcmFjdFRyaWJhbH1cbiAgICAgICAgICAgIGlzR3JhbmRmYXRoZXJlZD17XG4gICAgICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLklTX0dSQU5ERkFUSEVSRURdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8UHJpb3JpdGl6YXRpb25Db3B5MlxuICAgICAgICAgICAgdG90YWxDYXRlZ29yaWVzUHJpb3JpdGl6ZWQ9e1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5DT1VOVF9PRl9DQVRFR09SSUVTX0RJU0FEVl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzQWRqYWNlbmN5VGhyZXNoTWV0PXtcbiAgICAgICAgICAgICAgcHJvcGVydGllc1tjb25zdGFudHMuQURKQUNFTkNZX0VYQ0VFRFNfVEhSRVNIXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNBZGphY2VuY3lMb3dJbmNvbWU9e1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5BREpBQ0VOQ1lfTE9XX0lOQ09NRV9FWENFRURTX1RIUkVTSF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWJhbENvdW50QUs9e1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5UUklCQUxfQVJFQVNfQ09VTlRfQUtdID49IDEgP1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlRSSUJBTF9BUkVBU19DT1VOVF9BS10gOlxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWJhbENvdW50VVM9e1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2NvbnN0YW50cy5UUklCQUxfQVJFQVNfQ09VTlRfQ09OVVNdID49IDEgP1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXNbY29uc3RhbnRzLlRSSUJBTF9BUkVBU19DT1VOVF9DT05VU10gOlxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlcmNlbnRUcmFjdFRyaWJhbD17cGVyY2VudFRyYWN0VHJpYmFsfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIHtzaG93SXNsYW5kQ29weSAmJlxuICAgICAgICA8SXNsYW5kQ29weSBwb3ZlcnR5UGVyY2VudGlsZT17cG92ZXJ5UGVyY2VudGlsZX0gLz59XG4gICAgICB7c2hvd0RvbnV0Q29weSAmJlxuICAgICAgICA8RG9udXRDb3B5XG4gICAgICAgICAgaXNBZGphY2VudD17cHJvcGVydGllc1tjb25zdGFudHMuQURKQUNFTkNZX0VYQ0VFRFNfVEhSRVNIXX1cbiAgICAgICAgICBwb3ZlcnR5QmVsb3cyMDBQZXJjZW50aWxlPXtwb3ZlcnlQZXJjZW50aWxlfVxuICAgICAgICAvPlxuICAgICAgfVxuXG4gICAgICB7LyogU2VuZCBGZWVkYmFjayBidXR0b24gKi99XG4gICAgICA8YVxuICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5zZW5kRmVlZGJhY2tMaW5rfVxuICAgICAgICBocmVmPXtcbiAgICAgICAgICBpbnRsLmxvY2FsZSA9PT0gYGVzYCA/XG4gICAgICAgICAgICBgJHtjb25zdGFudHMuQ0VOU1VTX1RSQUNUX1NVUlZFWV9MSU5LUy5FU30/dHJhY3RpZD0ke2Jsb2NrR3JvdXB9YCA6XG4gICAgICAgICAgICBgJHtjb25zdGFudHMuQ0VOU1VTX1RSQUNUX1NVUlZFWV9MSU5LUy5FTn0/dHJhY3RpZD0ke2Jsb2NrR3JvdXB9YFxuICAgICAgICB9XG4gICAgICAgIHRhcmdldD17XCJfYmxhbmtcIn1cbiAgICAgICAgcmVsPVwibm9yZWZlcnJlclwiXG4gICAgICA+XG4gICAgICAgIDxCdXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzTmFtZT17c3R5bGVzLnNlbmRGZWVkYmFja0J0bn0+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5idXR0b25Db250YWluZXJ9PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5idXR0b25UZXh0fT5cbiAgICAgICAgICAgICAge0VYUExPUkVfQ09QWS5DT01NVU5JVFkuU0VORF9GRUVEQkFDSy5USVRMRX1cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8SWNvbi5MYXVuY2ggYXJpYS1sYWJlbD17aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5DT01NVU5JVFkuU0VORF9GRUVEQkFDSy5JTUdfSUNPTi5BTFRfVEFHKX0gLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9CdXR0b24+XG4gICAgICA8L2E+XG5cbiAgICAgIHsvKiBBbGwgY2F0ZWdvcnkgYWNjb3JkaW9ucyBpbiB0aGlzIGNvbXBvbmVudCAqL31cbiAgICAgIHs8QWNjb3JkaW9uIG11bHRpc2VsZWN0YWJsZT17dHJ1ZX0gaXRlbXM9e2NhdGVnb3J5SXRlbXN9IGNsYXNzTmFtZT1cIi1BcmVhRGV0YWlsXCIgLz59XG5cbiAgICAgIHsvKiBNZXRob2RvbG9neSB2ZXJzaW9uICovfVxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy52ZXJzaW9uSW5mb30+XG4gICAgICAgIHtFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9WRVJTSU9OLlRJVExFfVxuICAgICAgPC9kaXY+XG4gICAgPC9hc2lkZT5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFyZWFEZXRhaWw7XG4iLCJpbXBvcnQgQXJlYURldGFpbCBmcm9tICcuL0FyZWFEZXRhaWwnO1xuXG5leHBvcnQgZGVmYXVsdCBBcmVhRGV0YWlsO1xuXG4iLCJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlHaGxhV2RvZEQwaU1qUWlJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lnZDJsa2RHZzlJakkwSWo0OGNHRjBhQ0JrUFNKTk1DQXdhREkwZGpJMFNEQjZJaUJtYVd4c1BTSnViMjVsSWk4K1BIQmhkR2dnWkQwaVRURTVJREV6YUMwMmRqWm9MVEoyTFRaSU5YWXRNbWcyVmpWb01uWTJhRFoyTW5vaUx6NDhMM04yWno0PVwiIiwiZXhwb3J0IGRlZmF1bHQgXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJR2hsYVdkb2REMGlNalFpSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJZ2QybGtkR2c5SWpJMElqNDhjR0YwYUNCa1BTSk5NQ0F3YURJMGRqSTBTREI2SWlCbWFXeHNQU0p1YjI1bElpOCtQSEJoZEdnZ1pEMGlUVEUxTGpVZ01UUm9MUzQzT1d3dExqSTRMUzR5TjBNeE5TNDBNU0F4TWk0MU9TQXhOaUF4TVM0eE1TQXhOaUE1TGpVZ01UWWdOUzQ1TVNBeE15NHdPU0F6SURrdU5TQXpVek1nTlM0NU1TQXpJRGt1TlNBMUxqa3hJREUySURrdU5TQXhObU14TGpZeElEQWdNeTR3T1MwdU5Ua2dOQzR5TXkweExqVTNiQzR5Tnk0eU9IWXVOemxzTlNBMExqazVUREl3TGpRNUlERTViQzAwTGprNUxUVjZiUzAySURCRE55NHdNU0F4TkNBMUlERXhMams1SURVZ09TNDFVemN1TURFZ05TQTVMalVnTlNBeE5DQTNMakF4SURFMElEa3VOU0F4TVM0NU9TQXhOQ0E1TGpVZ01UUjZJaTgrUEM5emRtYytcIiIsImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUdobGFXZG9kRDBpTWpRaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSWdkMmxrZEdnOUlqSTBJajQ4Y0dGMGFDQmtQU0pOTUNBd2FESTBkakkwU0RCNklpQm1hV3hzUFNKdWIyNWxJaTgrUEhCaGRHZ2daRDBpVFRFeUlEaGpMVEl1TWpFZ01DMDBJREV1TnprdE5DQTBjekV1TnprZ05DQTBJRFFnTkMweExqYzVJRFF0TkMweExqYzVMVFF0TkMwMGVtMDRMamswSUROakxTNDBOaTAwTGpFM0xUTXVOemN0Tnk0ME9DMDNMamswTFRjdU9UUldNV2d0TW5ZeUxqQTJRell1T0RNZ015NDFNaUF6TGpVeUlEWXVPRE1nTXk0d05pQXhNVWd4ZGpKb01pNHdObU11TkRZZ05DNHhOeUF6TGpjM0lEY3VORGdnTnk0NU5DQTNMamswVmpJemFESjJMVEl1TURaak5DNHhOeTB1TkRZZ055NDBPQzB6TGpjM0lEY3VPVFF0Tnk0NU5FZ3lNM1l0TW1ndE1pNHdObnBOTVRJZ01UbGpMVE11T0RjZ01DMDNMVE11TVRNdE55MDNjek11TVRNdE55QTNMVGNnTnlBekxqRXpJRGNnTnkwekxqRXpJRGN0TnlBM2VpSXZQand2YzNablBnPT1cIiIsImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUdobGFXZG9kRDBpTWpRaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSWdkMmxrZEdnOUlqSTBJajQ4Y0dGMGFDQmtQU0pOTUNBd2FESTBkakkwU0RCNklpQm1hV3hzUFNKdWIyNWxJaTgrUEhCaGRHZ2daRDBpVFRFMklERXhZekV1TmpZZ01DQXlMams1TFRFdU16UWdNaTQ1T1MwelV6RTNMalkySURVZ01UWWdOV010TVM0Mk5pQXdMVE1nTVM0ek5DMHpJRE56TVM0ek5DQXpJRE1nTTNwdExUZ2dNR014TGpZMklEQWdNaTQ1T1MweExqTTBJREl1T1RrdE0xTTVMalkySURVZ09DQTFRell1TXpRZ05TQTFJRFl1TXpRZ05TQTRjekV1TXpRZ015QXpJRE42YlRBZ01tTXRNaTR6TXlBd0xUY2dNUzR4TnkwM0lETXVOVll4T1dneE5IWXRNaTQxWXpBdE1pNHpNeTAwTGpZM0xUTXVOUzAzTFRNdU5YcHRPQ0F3WXkwdU1qa2dNQzB1TmpJdU1ESXRMamszTGpBMUlERXVNVFl1T0RRZ01TNDVOeUF4TGprM0lERXVPVGNnTXk0ME5WWXhPV2cyZGkweUxqVmpNQzB5TGpNekxUUXVOamN0TXk0MUxUY3RNeTQxZWlJdlBqd3ZjM1puUGc9PVwiIiwiZXhwb3J0IGRlZmF1bHQgXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJR2hsYVdkb2REMGlNalFpSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJZ2QybGtkR2c5SWpJMElqNDhjR0YwYUNCa1BTSk5NQ0F3YURJMGRqSTBTREI2SWlCbWFXeHNQU0p1YjI1bElpOCtQSEJoZEdnZ1pEMGlUVGtnTVRab05uWXRObWcwYkMwM0xUY3ROeUEzYURSNmJTMDBJREpvTVRSMk1rZzFlaUl2UGp3dmMzWm5QZz09XCIiLCJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlHaGxhV2RvZEQwaU1qUWlJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lnZDJsa2RHZzlJakkwSWo0OGNHRjBhQ0JrUFNKTk1DQXdhREkwZGpJMFNEQjZJaUJtYVd4c1BTSnViMjVsSWk4K1BIQmhkR2dnWkQwaVRUa2dNVFl1TVRkTU5DNDRNeUF4TW13dE1TNDBNaUF4TGpReFREa2dNVGtnTWpFZ04yd3RNUzQwTVMweExqUXhlaUl2UGp3dmMzWm5QZz09XCIiLCJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIWnBaWGRDYjNnOUlqQWdNQ0F4TXprdU9EY2dNVFF5TGpjMElqNDhaR1ZtY3o0OGMzUjViR1UrTG1Oc2N5MHhlMlpwYkd3NkkyWm1aanQ5TG1Oc2N5MHllMlpwYkd3Nkl6SXpNV1l5TUR0OUxtTnNjeTB6ZTJacGJHdzZJMkpqWW1WallUdDlMbU5zY3kwMGUyWnBiR3c2SXpCak16VTFOanQ5UEM5emRIbHNaVDQ4TDJSbFpuTStQR2NnYVdROUlreGhlV1Z5WHpJaUlHUmhkR0V0Ym1GdFpUMGlUR0Y1WlhJZ01pSStQR2NnYVdROUlreGhlV1Z5WHpFdE1pSWdaR0YwWVMxdVlXMWxQU0pNWVhsbGNpQXhJajQ4Y0dGMGFDQmpiR0Z6Y3owaVkyeHpMVEVpSUdROUlrMHhNRGt1TURrc09EZ3VNalZvTFRJdU1qaHNMVE15TGpJeExqZzBZeTB5TGpFMExqQTJMVE1zTGpnMUxUTXNNaTQ1ZGpRM0xqUTJZekFzTWl3eExESXVPVFFzTXl3eUxqa3pjVE14TGpJdExqRXNOakl1TXpndExqSTJZekl1TURZc01Dd3lMamc1TFM0NE5pd3lMamc1TFRJdU9UUldOelV1T0RWak1DMHlMakV6TFM0NE9DMHpMVE10TTBneE1USXVNRGxqTFRJdU1UZ3NNQzB6TEM0NE5DMHpMRE5hVFRRM0xqRTJMREk0TGpnM1ZqTXVNVFZqTUMweUxqTXlMUzQzTnkwekxqRXpMVE10TXk0eE0wZ3pRekVzTUN3dU1EVXVPRFl1TURZc01pNDNPVkV1TVRjc016UXNMak14TERZMUxqSTVZekFzTWk0eE1TNDNPU3d5TGpneExETXNNaTQ0TmtnMk55NHdPV015TGpVMUxEQXNNeTR5T1MwdU5qRXNNeTR6TFRJdU9ESldNekV1Tmpkak1DMHlMUzQ0TXkweUxqYzRMVEl1T0RVdE1pNDNPRWcwTnk0eE5scHROUzR4TkMweU5HZzRNaTQxTVhZMk0yZzBMamMxVmpNdU16RmpNQzB5TGpVNExTNDNNeTB6TGpJNUxUTXVNell0TXk0eU9VZzFNaTR6V20wdE5EY3VNVFlzTVRNemRpMDJOa2d1TXpWMk5qY3VNMk13TERJdU9EY3VOekVzTXk0MU55d3pMallzTXk0MU4wZzJOaTQyTVZZeE16aGFJaTgrUEhCaGRHZ2dZMnhoYzNNOUltTnNjeTB5SWlCa1BTSk5Nemt1TkRRc05TNHdObll0TlVneE16WXVNbU15TGpZekxEQXNNeTR6Tmk0M05Dd3pMak0yTERNdU5ERldPRE11TnpKb0xUUXVOelZXTlM0d05sb2lMejQ4Y0dGMGFDQmpiR0Z6Y3owaVkyeHpMVElpSUdROUlrMDFMakUwTERFek55NDVTRGMyTGpJMWRqUXVOemxJTkdNdE1pNDRPU3d3TFRNdU5pMHVOeTB6TGpZdE15NDFOMVkyTlM0ME1rZzFMakUwV2lJdlBqeHdZWFJvSUdOc1lYTnpQU0pqYkhNdE15SWdaRDBpVFRjMkxqVTBMRGt6TGpnNVl5NDJNeXd3TERFdU1UVXRMakE1TERFdU5qY3RMakZzTXpFdU9URXRMamN4WXpJdU5EUXNNQ3d5TGpJeUxTNDNOeXd5TGpNekxUTXVNamd1TVRRdE15NDBPUzR5TFRjc0xqTXRNVEF1TkRjc01DMHVOVE1zTVM0eExURXNNUzR4TlMweExqWXphREl4ZGpZd1NEYzJMalUwV2lJdlBqeHdZWFJvSUdOc1lYTnpQU0pqYkhNdE15SWdaRDBpVFRZMUxqVXhMRE16TGpZM1ZqWXpMalF4U0RZdU5qWmpMVEV1TkRjc01DMHhMamM0TFM0MUxURXVOemd0TVM0NE5GWTFMalE0UVRJdU1USXNNaTR4TWl3d0xEQXNNU3cxTERRdU9EbElOREl1TkRGV016QXVORFZqTUN3eUxqTTRMamM1TERNdU1UZ3NNeTR4TkN3ekxqRTRhREl3V2lJdlBqeHdZWFJvSUdOc1lYTnpQU0pqYkhNdE5DSWdaRDBpVFRFd09DNDVNU3c0T0M0ek1sWTNOUzQ0TTJNd0xUSXVNVFV1T0RZdE15d3pMVE5vTWpRdU5UaGpNaTR4TkN3d0xETXNMamc0TERNc00zWTJNeTQyTW1Nd0xESXVNRGt0TGpneUxETXRNaTQ0T0N3emNTMHpNU3d1TVRVdE5qSXVNRGt1TWpWakxUSXNNQzB6TFM0NU1TMHpMVEl1T1RSV09USXVNRGxqTUMweUxqQTNMamd5TFRJdU9EVXNNeTB5TGpreFF6ZzFMakkzTERnNExqZzNMREV3Tnk0NExEZzRMak15TERFd09DNDVNU3c0T0M0ek1scHRMVE15TGpRc05TNDFPWFkwTXk0NGFEVTRMakUwZGkwMk1FZ3hNVE11TnpGak1Dd3VOVGd0TGpFekxERXVNVEV0TGpFMUxERXVOak10TGpFc015NDBPUzB1TVRZc055MHVNeXd4TUM0ME5pMHVNU3d5TGpVeUxTNDRPQ3d6TGpJekxUTXVNekVzTXk0eU9Xd3RNekV1TnpZdU55MHhMalk0TGpFeVdpSXZQanh3WVhSb0lHTnNZWE56UFNKamJITXROQ0lnWkQwaVRUUTNMakUyTERJNExqZzNTRFkzTGpWak1pd3dMREl1T0RRdU56Z3NNaTQ0TlN3eUxqYzRWalkxTGpNeFl6QXNNaTR5TVMwdU56VXNNaTQ0TWkwekxqTXNNaTQ0TWtnekxqSTFZeTB5TGpFMkxEQXRNaTQ1TkMwdU56VXRNeTB5TGpnMlVTNHhMRE0wTERBc01pNDNOME13TEM0NE5DNDVNU3d3TERJdU9Td3dTRFEwTGpGak1pNHlOU3d3TERNc0xqZ3hMRE1zTXk0eE0xWXlOaTQ0TlZwdE1UZ3VNelVzTkM0NGFDMHlNR010TWk0ek5Td3dMVE11TVRRdExqZ3RNeTR4TkMwekxqRTRWalF1T1ROSU5DNDVNV013TEM0eU9DMHVNRGN1TkRRdExqQTNMalU1VmpZeExqWXhZekFzTVM0ek5DNHpNU3d4TGpnMExERXVOemdzTVM0NE5IRXlPQzQyTVMwdU1EZ3NOVGN1TWpJc01HZ3hMall6V2lJdlBqd3ZaejQ4TDJjK1BDOXpkbWMrXCIiLCJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIWnBaWGRDYjNnOUlqQWdNQ0F4T0RjdU9EY2dNVEk1TGpnaVBqeGtaV1p6UGp4emRIbHNaVDR1WTJ4ekxURjdabWxzYkRvalptWm1PMzA4TDNOMGVXeGxQand2WkdWbWN6NDhaeUJwWkQwaVRHRjVaWEpmTWlJZ1pHRjBZUzF1WVcxbFBTSk1ZWGxsY2lBeUlqNDhaeUJwWkQwaVRHRjVaWEpmTVMweUlpQmtZWFJoTFc1aGJXVTlJa3hoZVdWeUlERWlQanhuSUdsa1BTSllUVkJ3TWtvdWRHbG1JajQ4Y0dGMGFDQmtQU0pOTWpBdU9EWXNNVEkxTGpOaE5DNHhNU3cwTGpFeExEQXNNQ3d3TERNdU56VXRNUzQ0TVN3eE16SXVOaXd4TXpJdU5pd3dMREFzTUN3eU5DMDBPUzQyTkVNMU1TNHhPQ3cyTXk0MU5TdzFNeXcxTXk0d055dzFOUzR5TlN3ME1pNDNZekl0T1M0eU1pdzBMall0TVRndU1qZ3NNVEF1TmpRdE1qVXVOemxETnpRdU1Ua3NOaTQyTERnMExqWTVMUzR4TkN3NU9DNHpMREJqTVRZdU16WXVNVGdzTWpndU1UWXNPQzR6T1N3ek5TNDRNaXd5TWk0MU9DdzBMakV6TERjdU5qUXNOUzQwTXl3eE5pNHhOaXcyTGpRNExESTBMalkyTERJc01UVXVPU3d6TGpZMkxETXhMamcwTERrdU5ERXNORGRCTVRJMkxqRTJMREV5Tmk0eE5pd3dMREFzTUN3eE5qWXNNVEl6TGpRMllUUXNOQ3d3TERBc01Dd3pMamN4TERFdU9EWk5NelV1TWpNc01USTFMakZvTVRJd0xqVmpMUzR6TWkwdU5UZ3RMalE0TFM0NU5DMHVOeTB4TGpJMllURXlOQzQyTml3eE1qUXVOallzTUN3d0xERXRNVGt1T1MwME9TNDFNMk10TVM0M09TMHhNQzQwTnkweUxqa3hMVEl4TFRRdU5URXRNekV1TlRVdE1TNHdOUzAyTGprekxUSXVOemd0TVRNdU5qWXROaTQzTkMweE9TNDJNa014TVRZdU9UTXNNVEl1Tnl3eE1ETXVOemtzTnl3NU1pNHpMRGt1T1RSakxURXhMakkxTERJdU9TMHhPUzR4TWl3eE1DMHlNeTQzTERJd0xqWTVRelkwTGpZc05EQXNOak11TVRrc05UQXVNU3cyTVM0ek1TdzJNQ3cxT0N3M055NDJOeXcxTXl3NU5DNDNOQ3cwTkM0eE55d3hNVEF1TkRnc05ERXVNemNzTVRFMUxqTTVMRE00TGpJekxERXlNQzR4TERNMUxqSXpMREV5TlM0eFdpSXZQanh3WVhSb0lHTnNZWE56UFNKamJITXRNU0lnWkQwaVRUTTFMakl6TERFeU5TNHhZek11TURjdE5TdzJMakU0TFRrdU56RXNPQzQ1TkMweE5DNDJNa00xTXl3NU5DNDNOQ3cxTnk0NU5DdzNOeTQyTnl3Mk1TNHlNeXcyTUdNeExqZzRMVGt1T1RRc015NHlOUzB5TUN3M0xqSTVMVEk1TGpReFF6Y3pMakVzTWpBc09ERXNNVEl1T0RRc09USXVNaklzT1M0NU5HTXhNUzQwT1MwekxESTBMall6TERJdU56WXNNekV1TlRnc01UTXVNaXcwTERZc05TNDJPU3d4TWk0Mk9TdzJMamMwTERFNUxqWXlMREV1Tml3eE1DNDFMREl1TnpJc01qRXVNRGdzTkM0MU1Td3pNUzQxTlVFeE1qUXVOallzTVRJMExqWTJMREFzTUN3d0xERTFOU3d4TWpNdU9EUmpMakl5TGpNeUxqTTRMalk0TGpjc01TNHlObG9pTHo0OEwyYytQSEpsWTNRZ2VUMGlNVEl3TGpnaUlIZHBaSFJvUFNJeE9EY3VPRGNpSUdobGFXZG9kRDBpT1NJdlBqd3ZaejQ4TDJjK1BDOXpkbWMrXCIiLCJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIWnBaWGRDYjNnOUlqQWdNQ0F4TlRjdU1ETWdNVFUyTGpreUlqNDhaeUJwWkQwaVRHRjVaWEpmTWlJZ1pHRjBZUzF1WVcxbFBTSk1ZWGxsY2lBeUlqNDhaeUJwWkQwaVRHRjVaWEpmTVMweUlpQmtZWFJoTFc1aGJXVTlJa3hoZVdWeUlERWlQanh3WVhSb0lHUTlJazA1TkM0ME1Td3hNall1T0RWb0xTNDVOR3d0TXk0ME5Dd3dWamM1WXpBdE5TNDVOQzB6TGpNMkxURXdMak14TFRrdE1URXVOamxoTVRndU5Dd3hPQzQwTERBc01Dd3dMVFF0TGpNMVNETTFMamc1VERNd0xqSXNOamRzTFM0d09DMHpMalJETWprdU5ESXNNelF1TlRJc05USXVNallzTWl3NU1DNHpOaTR3T1dFMk15NHpPU3cyTXk0ek9Td3dMREFzTVN3Mk5pNDFPU3cyTUN3Mk5DdzJOQ3d3TERBc01Td3dMRGN1TURZc05qTXVNallzTmpNdU1qWXNNQ3d3TERFdE5qSXVOVEVzTlRrdU56SmFUVGMzTGpVM0xEWXdZVEkwTGpZNUxESTBMalk1TERBc01Dd3hMRFVzTGpVeGJDNHhNU3d3UXpreExqVXhMRFl5TGpZMExEazNMRFk1TGpjekxEazNMRGM1ZGpRd0xqYzRZVFUyTGpNeUxEVTJMak15TERBc01Dd3dMRFV5TGprdE5UTXVNRGNzTlRjdU16Z3NOVGN1TXpnc01Dd3dMREFzTUMwMkxqSTVRVFUyTGpNNExEVTJMak00TERBc01Dd3dMRGt3TGpjeUxEY3VNRGhETlRndU15dzRMamN4TERNNExqTXhMRE0xTGpFMUxETTNMakUyTERZd1NEYzNMalUzV2lJdlBqeHdZWFJvSUdROUlrMDJPQ3d4TlRZdU9USm9NRUUyT0M0eU9TdzJPQzR5T1N3d0xEQXNNU3d4TGpVeUxERXdNaTQxTERnekxqSTBMRGd6TGpJMExEQXNNQ3d4TEM0ek5DdzVNaTQ1UXk0eU5TdzVNUzQ0TGpFMkxEa3dMalk1TGpBMkxEZzVMalpoT0M0MU1pdzRMalV5TERBc01Dd3hMREl1TVRNdE5pNDNPRUU1TGpJNUxEa3VNamtzTUN3d0xERXNPUzQwTVN3NE1HTXlMamMwTGpBMkxEVXVOVFFzTUN3NExqSTBMREJzTkM0eUxEQklOamN1TmpOak5DNHdPU3d3TERZdU9USXNNUzQxTlN3NExqTTVMRFF1TmpKQk1UQXVORGtzTVRBdU5Ea3NNQ3d3TERFc056Y3NPRGwyTVRBdU4yTXdMREl1TVRZc01DdzBMalUxTERBc09DNDRPSFl6T1M0ek4yRTRMalEwTERndU5EUXNNQ3d3TERFdE9TdzVXbTB0TlRndU56Z3ROekJoTWk0ME9Dd3lMalE0TERBc01Dd3dMVEV1T0RRdU5qRkJNUzQyTXl3eExqWXpMREFzTUN3d0xEY3NPRGd1T0RoakxqRXhMREV1TVRjdU1qRXNNaTR6TVM0ekxETXVORFZoTnpRdU5ESXNOelF1TkRJc01Dd3dMREFzTVM0d05pdzRMamMyUVRZeExqWXNOakV1Tml3d0xEQXNNQ3cyT0N3eE5Ea3VPVEpoTWk0MExESXVOQ3d3TERBc01Dd3hMall6TFM0MExESXVORE1zTWk0ME15d3dMREFzTUN3dU5DMHhMalpXTVRBNExqVTFZekF0TkM0ek15d3dMVFl1TnpNc01DMDRMamc1VmpnNVlUTXVNekVzTXk0ek1Td3dMREFzTUMwdU16SXRNUzQwTW1NdExqRXhMUzR5TXkwdU1qa3RMall4TFRJdU1EWXRMall4U0RFM0xqZGpMVEl1TnpVc01DMDFMallzTUMwNExqUXpMREJhSWk4K1BDOW5Qand2Wno0OEwzTjJaejQ9XCIiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB2YXIgc2lkZVBhbmVsSW5mb0NvbnRhaW5lciA9IFwiU2lkZVBhbmVsSW5mby1tb2R1bGUtLXNpZGVQYW5lbEluZm9Db250YWluZXItLXowV082XCI7XG5leHBvcnQgdmFyIHNpZGVQYW5lbEluZm9IZWFkaW5nID0gXCJTaWRlUGFuZWxJbmZvLW1vZHVsZS0tc2lkZVBhbmVsSW5mb0hlYWRpbmctLUlxeUQwXCI7XG5leHBvcnQgdmFyIHNpZGVQYW5lbEluZm9JY29uID0gXCJTaWRlUGFuZWxJbmZvLW1vZHVsZS0tc2lkZVBhbmVsSW5mb0ljb24tLUZ2UnJMXCI7XG5leHBvcnQgdmFyIHNpZGVQYW5lbEluZm9UaXRsZSA9IFwiU2lkZVBhbmVsSW5mby1tb2R1bGUtLXNpZGVQYW5lbEluZm9UaXRsZS0tUm96ZFpcIjsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHt1c2VJbnRsfSBmcm9tICdnYXRzYnktcGx1Z2luLWludGwnO1xuaW1wb3J0IHt1c2VXaW5kb3dTaXplfSBmcm9tICdyZWFjdC11c2UnO1xuXG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgcGx1c0ljb24gZnJvbSAnL25vZGVfbW9kdWxlcy91c3dkcy9kaXN0L2ltZy91c2EtaWNvbnMvYWRkLnN2Zyc7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgc2VhcmNoSWNvbiBmcm9tICcvbm9kZV9tb2R1bGVzL3Vzd2RzL2Rpc3QvaW1nL3VzYS1pY29ucy9zZWFyY2guc3ZnJztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBsb2NhdGVJY29uIGZyb20gJy9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL215X2xvY2F0aW9uLnN2Zyc7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgcGVvcGxlSWNvbiBmcm9tICcvbm9kZV9tb2R1bGVzL3Vzd2RzL2Rpc3QvaW1nL3VzYS1pY29ucy9wZW9wbGUuc3ZnJztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBmaWxlVXBJY29uIGZyb20gJy9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL2ZpbGVfdXBsb2FkLnN2Zyc7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgY2hlY2tJY29uIGZyb20gJy9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL2NoZWNrLnN2Zyc7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgcHV6emxlSWNvbiBmcm9tICcuLi8uLi9pbWFnZXMvc2lkZVBhbmVsSWNvbnMvcHV6emxlLnN2Zyc7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgYmVsbEN1cnZlSWNvbiBmcm9tICcuLi8uLi9pbWFnZXMvc2lkZVBhbmVsSWNvbnMvYmVsbC1jdXJ2ZS5zdmcnO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IGNlbnN1c0RvdEljb24gZnJvbSAnLi4vLi4vaW1hZ2VzL3NpZGVQYW5lbEljb25zL2NlbnN1cy10cmFjdC5zdmcnO1xuLy8gQHRzLWlnbm9yZVxuLy8gaW1wb3J0IHRyaWJhbERvdEljb24gZnJvbSAnLi4vLi4vaW1hZ2VzL3NpZGVQYW5lbEljb25zL3RyaWJhbC10cmFjdC5zdmcnO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHBpZUNoYXJ0SWNvbiBmcm9tICcuLi8uLi9pbWFnZXMvc2lkZVBhbmVsSWNvbnMvcGllLWNoYXJ0LnN2Zyc7XG4vLyBAdHMtaWdub3JlXG4vLyBpbXBvcnQgaGFuZFBvaW50SWNvbiBmcm9tICcuLi8uLi9pbWFnZXMvc2lkZVBhbmVsSWNvbnMvbW91c2UtaGFuZC1wb2ludC5zdmcnO1xuXG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi9TaWRlUGFuZWxJbmZvLm1vZHVsZS5zY3NzJztcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi8uLi9kYXRhL2NvbnN0YW50cyc7XG5pbXBvcnQgKiBhcyBFWFBMT1JFX0NPUFkgZnJvbSAnLi4vLi4vZGF0YS9jb3B5L2V4cGxvcmUnO1xuXG5jb25zdCBTaWRlUGFuZWxJbmZvID0gKCkgPT4ge1xuICBjb25zdCBpbnRsID0gdXNlSW50bCgpO1xuICBjb25zdCB7d2lkdGg6IHdpbmRvd1dpZHRofSA9IHVzZVdpbmRvd1NpemUoKTtcblxuICByZXR1cm4gKFxuICAgIDxhc2lkZSBjbGFzc05hbWU9e3N0eWxlcy5zaWRlUGFuZWxJbmZvQ29udGFpbmVyfT5cblxuICAgICAgey8qIEhlYWRpbmcgMSAqL31cbiAgICAgIDxoZWFkZXIgdGFiSW5kZXg9ezB9IGNsYXNzTmFtZT17c3R5bGVzLnNpZGVQYW5lbEluZm9UaXRsZX0+XG4gICAgICAgIHtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5JVElBTF9TVEFURS5IRUFESU5HMSl9XG4gICAgICA8L2hlYWRlcj5cblxuICAgICAgey8qIFBhcmFncmFwaCAxICovfVxuICAgICAgPHAgdGFiSW5kZXg9ezB9PlxuICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRJQUxfU1RBVEUuUEFSQTFfUEFSVDEpfVxuICAgICAgICB7XG4gICAgICAgICAgd2luZG93V2lkdGggPiBjb25zdGFudHMuVVNXRFNfQlJFQUtQT0lOVFMuTU9CSUxFX0xHICYmXG4gICAgICAgICAgPGltZyB0YWJJbmRleD17MH0gY2xhc3NOYW1lPXtzdHlsZXMuc2lkZVBhbmVsSW5mb0ljb259IHNyYz17cGx1c0ljb259XG4gICAgICAgICAgICBhbHQ9e2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUX1NUQVRFX0lDT05fQUxUX1RFWFQuUExVUyl9XG4gICAgICAgICAgLz5cbiAgICAgICAgfVxuICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRJQUxfU1RBVEUuUEFSQTFfUEFSVDIpfVxuICAgICAgICB7XG4gICAgICAgICAgd2luZG93V2lkdGggPiBjb25zdGFudHMuVVNXRFNfQlJFQUtQT0lOVFMuTU9CSUxFX0xHICYmXG4gICAgICAgICAgPGltZyB0YWJJbmRleD17MH0gY2xhc3NOYW1lPXtzdHlsZXMuc2lkZVBhbmVsSW5mb0ljb259IHNyYz17c2VhcmNoSWNvbn1cbiAgICAgICAgICAgIGFsdD17aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRfU1RBVEVfSUNPTl9BTFRfVEVYVC5TRUFSQ0gpfVxuICAgICAgICAgIC8+XG4gICAgICAgIH1cbiAgICAgICAge2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUSUFMX1NUQVRFLlBBUkExX1BBUlQzKX1cbiAgICAgICAge1xuICAgICAgICAgIHdpbmRvd1dpZHRoID4gY29uc3RhbnRzLlVTV0RTX0JSRUFLUE9JTlRTLk1PQklMRV9MRyAmJlxuICAgICAgICAgIDxpbWcgdGFiSW5kZXg9ezB9IGNsYXNzTmFtZT17c3R5bGVzLnNpZGVQYW5lbEluZm9JY29ufSBzcmM9e2xvY2F0ZUljb259XG4gICAgICAgICAgICBhbHQ9e2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUX1NUQVRFX0lDT05fQUxUX1RFWFQuTE9DQVRFKX1cbiAgICAgICAgICAvPlxuICAgICAgICB9XG4gICAgICAgIHtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5JVElBTF9TVEFURS5QQVJBMV9QQVJUNCl9XG4gICAgICAgIHsvKiB7XG4gICAgICAgICAgd2luZG93V2lkdGggPiBjb25zdGFudHMuVVNXRFNfQlJFQUtQT0lOVFMuTU9CSUxFX0xHICYmXG4gICAgICAgICAgPGltZyB0YWJJbmRleD17MH0gY2xhc3NOYW1lPXtzdHlsZXMuc2lkZVBhbmVsSW5mb0ljb259IHNyYz17aGFuZFBvaW50SWNvbn1cbiAgICAgICAgICAgIGFsdD17aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRfU1RBVEVfSUNPTl9BTFRfVEVYVC5NT1VTRSl9XG4gICAgICAgICAgLz5cbiAgICAgICAgfSAqL31cbiAgICAgICAge2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUSUFMX1NUQVRFLlBBUkExX1BBUlQ1KX1cbiAgICAgIDwvcD5cblxuICAgICAgey8qIEhlYWRpbmcgMiAqL31cbiAgICAgIDxwIHRhYkluZGV4PXswfSBjbGFzc05hbWU9e3N0eWxlcy5zaWRlUGFuZWxJbmZvSGVhZGluZ30+XG4gICAgICAgIHtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5JVElBTF9TVEFURS5IRUFESU5HMil9XG4gICAgICA8L3A+XG5cbiAgICAgIHsvKiBQYXJhZ3JhcGggMiAqL31cbiAgICAgIDxwIHRhYkluZGV4PXswfT5cbiAgICAgICAge2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUSUFMX1NUQVRFLlBBUkEyX1BBUlQxKX1cbiAgICAgICAge1xuICAgICAgICAgIHdpbmRvd1dpZHRoID4gY29uc3RhbnRzLlVTV0RTX0JSRUFLUE9JTlRTLk1PQklMRV9MRyAmJlxuICAgICAgICAgIDxpbWcgdGFiSW5kZXg9ezB9IGNsYXNzTmFtZT17c3R5bGVzLnNpZGVQYW5lbEluZm9JY29ufSBzcmM9e3B1enpsZUljb259XG4gICAgICAgICAgICBhbHQ9e2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUX1NUQVRFX0lDT05fQUxUX1RFWFQuVFJBQ1QpfVxuICAgICAgICAgIC8+XG4gICAgICAgIH1cbiAgICAgICAge2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUSUFMX1NUQVRFLlBBUkEyX1BBUlQyKX1cbiAgICAgICAge1xuICAgICAgICAgIHdpbmRvd1dpZHRoID4gY29uc3RhbnRzLlVTV0RTX0JSRUFLUE9JTlRTLk1PQklMRV9MRyAmJlxuICAgICAgICAgIDxpbWcgdGFiSW5kZXg9ezB9IGNsYXNzTmFtZT17c3R5bGVzLnNpZGVQYW5lbEluZm9JY29ufSBzcmM9e3Blb3BsZUljb259XG4gICAgICAgICAgICBhbHQ9e2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUX1NUQVRFX0lDT05fQUxUX1RFWFQuUEVPUExFKX1cbiAgICAgICAgICAvPlxuICAgICAgICB9XG4gICAgICAgIHtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5JVElBTF9TVEFURS5QQVJBMl9QQVJUMyl9XG4gICAgICA8L3A+XG5cbiAgICAgIHsvKiBQYXJhZ3JhcGggMyAqL31cbiAgICAgIHtcbiAgICAgICAgd2luZG93V2lkdGggPiBjb25zdGFudHMuVVNXRFNfQlJFQUtQT0lOVFMuTU9CSUxFX0xHICYmXG4gICAgICAgIDxwIHRhYkluZGV4PXswfT5cbiAgICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRJQUxfU1RBVEUuUEFSQTNfUEFSVDEpfVxuICAgICAgICAgIDxpbWcgdGFiSW5kZXg9ezB9IGNsYXNzTmFtZT17c3R5bGVzLnNpZGVQYW5lbEluZm9JY29ufSBzcmM9e2NlbnN1c0RvdEljb259XG4gICAgICAgICAgICBhbHQ9e2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUX1NUQVRFX0lDT05fQUxUX1RFWFQuREFDX0NJUkNMRSl9XG4gICAgICAgICAgLz5cbiAgICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRJQUxfU1RBVEUuUEFSQTNfUEFSVDIpfVxuICAgICAgICA8L3A+XG4gICAgICB9XG5cbiAgICAgIHsvKiBQYXJhZ3JhcGggNCAqL31cbiAgICAgIHtcbiAgICAgICAgd2luZG93V2lkdGggPiBjb25zdGFudHMuVVNXRFNfQlJFQUtQT0lOVFMuTU9CSUxFX0xHICYmXG4gICAgICAgIDxwIHRhYkluZGV4PXswfT5cbiAgICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRJQUxfU1RBVEUuUEFSQTRfUEFSVDEpfVxuICAgICAgICAgIDxpbWcgdGFiSW5kZXg9ezB9IGNsYXNzTmFtZT17c3R5bGVzLnNpZGVQYW5lbEluZm9JY29ufSBzcmM9e2JlbGxDdXJ2ZUljb259XG4gICAgICAgICAgICBhbHQ9e2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUX1NUQVRFX0lDT05fQUxUX1RFWFQuQkVMTF9DVVJWRSl9XG4gICAgICAgICAgLz5cbiAgICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRJQUxfU1RBVEUuUEFSQTRfUEFSVDIpfVxuICAgICAgICA8L3A+XG4gICAgICB9XG5cbiAgICAgIHsvKiBQYXJhZ3JhcGggNSAqL31cbiAgICAgIHtcbiAgICAgICAgd2luZG93V2lkdGggPiBjb25zdGFudHMuVVNXRFNfQlJFQUtQT0lOVFMuTU9CSUxFX0xHICYmXG4gICAgICAgPHAgdGFiSW5kZXg9ezB9PlxuICAgICAgICAge2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUSUFMX1NUQVRFLlBBUkE1X1BBUlQxKX1cbiAgICAgICAgIDxpbWcgdGFiSW5kZXg9ezB9IGNsYXNzTmFtZT17c3R5bGVzLnNpZGVQYW5lbEluZm9JY29ufSBzcmM9e2ZpbGVVcEljb259XG4gICAgICAgICAgIGFsdD17aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRfU1RBVEVfSUNPTl9BTFRfVEVYVC5GSUxFX1VQKX1cbiAgICAgICAgIC8+XG4gICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRJQUxfU1RBVEUuUEFSQTVfUEFSVDIpfVxuICAgICAgICAgPGltZyB0YWJJbmRleD17MH0gY2xhc3NOYW1lPXtzdHlsZXMuc2lkZVBhbmVsSW5mb0ljb259IHNyYz17cGllQ2hhcnRJY29ufVxuICAgICAgICAgICBhbHQ9e2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUX1NUQVRFX0lDT05fQUxUX1RFWFQuUElFX0NIQVJUKX1cbiAgICAgICAgIC8+XG4gICAgICAgICB7aW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5TSURFX1BBTkVMX0lOSVRJQUxfU1RBVEUuUEFSQTVfUEFSVDMpfVxuICAgICAgICAgPGltZyB0YWJJbmRleD17MH0gY2xhc3NOYW1lPXtzdHlsZXMuc2lkZVBhbmVsSW5mb0ljb259IHNyYz17Y2hlY2tJY29ufVxuICAgICAgICAgICBhbHQ9e2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUX1NUQVRFX0lDT05fQUxUX1RFWFQuQ0hFQ0spfVxuICAgICAgICAgLz5cbiAgICAgICAgIHtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5JVElBTF9TVEFURS5QQVJBNV9QQVJUNCl9XG4gICAgICAgPC9wPlxuICAgICAgfVxuXG4gICAgICB7LyogUGFyYWdyYXBoIDYgKi99XG4gICAgICB7XG4gICAgICAgIHdpbmRvd1dpZHRoID4gY29uc3RhbnRzLlVTV0RTX0JSRUFLUE9JTlRTLk1PQklMRV9MRyAmJlxuICAgICAgICA8cCB0YWJJbmRleD17MH0+XG4gICAgICAgICAge2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUSUFMX1NUQVRFLlBBUkE2X1BBUlQxKX1cbiAgICAgICAgICA8aW1nIHRhYkluZGV4PXswfSBjbGFzc05hbWU9e3N0eWxlcy5zaWRlUGFuZWxJbmZvSWNvbn0gc3JjPXtjZW5zdXNEb3RJY29ufVxuICAgICAgICAgICAgYWx0PXtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlNJREVfUEFORUxfSU5JVF9TVEFURV9JQ09OX0FMVF9URVhULkRBQ19DSVJDTEUpfVxuICAgICAgICAgIC8+XG4gICAgICAgICAge2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuU0lERV9QQU5FTF9JTklUSUFMX1NUQVRFLlBBUkE2X1BBUlQyKX1cbiAgICAgICAgPC9wPlxuICAgICAgfVxuICAgIDwvYXNpZGU+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTaWRlUGFuZWxJbmZvO1xuIiwiaW1wb3J0IFNpZGVQYW5lbEluZm8gZnJvbSAnLi9TaWRlUGFuZWxJbmZvJztcblxuZXhwb3J0IGRlZmF1bHQgU2lkZVBhbmVsSW5mbztcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgQXJlYURldGFpbCBmcm9tICcuL0FyZWFEZXRhaWwnO1xuaW1wb3J0IFNpZGVQYW5lbEluZm8gZnJvbSAnLi9TaWRlUGFuZWxJbmZvJztcblxuaW50ZXJmYWNlIElNYXBJbmZvUGFuZWxQcm9wcyB7XG4gICAgY2xhc3NOYW1lOiBzdHJpbmcsXG4gICAgZmVhdHVyZVByb3BlcnRpZXM6IHsgW2tleTpzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfSB8IHVuZGVmaW5lZCxcbiAgICBoYXNoOiBzdHJpbmdbXSxcbiAgfVxuXG5jb25zdCBNYXBJbmZvUGFuZWwgPSAoe1xuICBjbGFzc05hbWUsXG4gIGZlYXR1cmVQcm9wZXJ0aWVzLFxuICBoYXNoLFxufTpJTWFwSW5mb1BhbmVsUHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSA+XG4gICAgICB7LypcbiAgICAgIFRoZSB0ZXJ0aWFyeSBjb25kaXRpb25hbCBzdGF0ZW1lbnQgYmVsb3cgd2lsbCBjb250cm9sIHRoZSBzaWRlIHBhbmVsIHN0YXRlLiBDdXJyZW50bHlcbiAgICAgIHRoZXJlIGFyZSB0d28gc3RhdGVzLCBuYW1lbHkgc2hvd2luZyB0aGUgQXJlYURldGFpbCBvciBTaWRlUGFuZWxJbmZvLiBXaGVuIGEgZmVhdHVyZVxuICAgICAgaXMgc2VsZWN0ZWQsIHNob3cgdGhlIEFyZWFEZXRhaWwuIFdoZW4gbm90IHNlbGVjdGVkIHNob3cgU2lkZVBhbmVsSW5mb1xuICAgICAgICovfVxuICAgICAgeyhmZWF0dXJlUHJvcGVydGllcykgP1xuICAgICAgICAgIDxBcmVhRGV0YWlsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzPXtmZWF0dXJlUHJvcGVydGllc31cbiAgICAgICAgICAgIGhhc2g9e2hhc2h9XG4gICAgICAgICAgLz4gOlxuICAgICAgICAgIDxTaWRlUGFuZWxJbmZvIC8+XG4gICAgICB9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBNYXBJbmZvUGFuZWw7XG4iLCIvKipcbiAqIEluZGV4ZXMgZm9yIGFsbCBzdWJzdHJpbmcgc2VhcmNoZXMgKGUuZy4gdGhlIHRlcm0gXCJjYXRcIiBpcyBpbmRleGVkIGFzIFwiY1wiLCBcImNhXCIsIFwiY2F0XCIsIFwiYVwiLCBcImF0XCIsIGFuZCBcInRcIikuXG4gKi9cbnZhciBBbGxTdWJzdHJpbmdzSW5kZXhTdHJhdGVneSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFsbFN1YnN0cmluZ3NJbmRleFN0cmF0ZWd5KCkge31cbiAgdmFyIF9wcm90byA9IEFsbFN1YnN0cmluZ3NJbmRleFN0cmF0ZWd5LnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NzXG4gICAqL1xuICBfcHJvdG8uZXhwYW5kVG9rZW4gPSBmdW5jdGlvbiBleHBhbmRUb2tlbih0b2tlbikge1xuICAgIHZhciBleHBhbmRlZFRva2VucyA9IFtdO1xuICAgIHZhciBzdHJpbmc7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRva2VuLmxlbmd0aDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBzdHJpbmcgPSAnJztcbiAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgbGVuZ3RoOyArK2opIHtcbiAgICAgICAgc3RyaW5nICs9IHRva2VuLmNoYXJBdChqKTtcbiAgICAgICAgZXhwYW5kZWRUb2tlbnMucHVzaChzdHJpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwYW5kZWRUb2tlbnM7XG4gIH07XG4gIHJldHVybiBBbGxTdWJzdHJpbmdzSW5kZXhTdHJhdGVneTtcbn0oKTtcblxuLyoqXG4gKiBJbmRleGVzIGZvciBleGFjdCB3b3JkIG1hdGNoZXMuXG4gKi9cbnZhciBFeGFjdFdvcmRJbmRleFN0cmF0ZWd5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXhhY3RXb3JkSW5kZXhTdHJhdGVneSgpIHt9XG4gIHZhciBfcHJvdG8gPSBFeGFjdFdvcmRJbmRleFN0cmF0ZWd5LnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NzXG4gICAqL1xuICBfcHJvdG8uZXhwYW5kVG9rZW4gPSBmdW5jdGlvbiBleHBhbmRUb2tlbih0b2tlbikge1xuICAgIHJldHVybiB0b2tlbiA/IFt0b2tlbl0gOiBbXTtcbiAgfTtcbiAgcmV0dXJuIEV4YWN0V29yZEluZGV4U3RyYXRlZ3k7XG59KCk7XG5cbi8qKlxuICogSW5kZXhlcyBmb3IgcHJlZml4IHNlYXJjaGVzIChlLmcuIHRoZSB0ZXJtIFwiY2F0XCIgaXMgaW5kZXhlZCBhcyBcImNcIiwgXCJjYVwiLCBhbmQgXCJjYXRcIiBhbGxvd2luZyBwcmVmaXggc2VhcmNoIGxvb2t1cHMpLlxuICovXG52YXIgUHJlZml4SW5kZXhTdHJhdGVneSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByZWZpeEluZGV4U3RyYXRlZ3koKSB7fVxuICB2YXIgX3Byb3RvID0gUHJlZml4SW5kZXhTdHJhdGVneS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jc1xuICAgKi9cbiAgX3Byb3RvLmV4cGFuZFRva2VuID0gZnVuY3Rpb24gZXhwYW5kVG9rZW4odG9rZW4pIHtcbiAgICB2YXIgZXhwYW5kZWRUb2tlbnMgPSBbXTtcbiAgICB2YXIgc3RyaW5nID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRva2VuLmxlbmd0aDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBzdHJpbmcgKz0gdG9rZW4uY2hhckF0KGkpO1xuICAgICAgZXhwYW5kZWRUb2tlbnMucHVzaChzdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwYW5kZWRUb2tlbnM7XG4gIH07XG4gIHJldHVybiBQcmVmaXhJbmRleFN0cmF0ZWd5O1xufSgpO1xuXG4vKipcbiAqIEVuZm9yY2VzIGNhc2Utc2Vuc2l0aXZlIHRleHQgbWF0Y2hlcy5cbiAqL1xudmFyIENhc2VTZW5zaXRpdmVTYW5pdGl6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDYXNlU2Vuc2l0aXZlU2FuaXRpemVyKCkge31cbiAgdmFyIF9wcm90byA9IENhc2VTZW5zaXRpdmVTYW5pdGl6ZXIucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY3NcbiAgICovXG4gIF9wcm90by5zYW5pdGl6ZSA9IGZ1bmN0aW9uIHNhbml0aXplKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dCA/IHRleHQudHJpbSgpIDogJyc7XG4gIH07XG4gIHJldHVybiBDYXNlU2Vuc2l0aXZlU2FuaXRpemVyO1xufSgpO1xuXG4vKipcbiAqIFNhbml0aXplcyB0ZXh0IGJ5IGNvbnZlcnRpbmcgdG8gYSBsb2NhbGUtZnJpZW5kbHkgbG93ZXItY2FzZSB2ZXJzaW9uIGFuZCB0cmltaW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuXG4gKi9cbnZhciBMb3dlckNhc2VTYW5pdGl6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMb3dlckNhc2VTYW5pdGl6ZXIoKSB7fVxuICB2YXIgX3Byb3RvID0gTG93ZXJDYXNlU2FuaXRpemVyLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NzXG4gICAqL1xuICBfcHJvdG8uc2FuaXRpemUgPSBmdW5jdGlvbiBzYW5pdGl6ZSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQgPyB0ZXh0LnRvTG9jYWxlTG93ZXJDYXNlKCkudHJpbSgpIDogJyc7XG4gIH07XG4gIHJldHVybiBMb3dlckNhc2VTYW5pdGl6ZXI7XG59KCk7XG5cbi8qKlxuICogRmluZCBhbmQgcmV0dXJuIGEgbmVzdGVkIG9iamVjdCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IHRvIGNyYXdsXG4gKiBAcGFyYW0gcGF0aCBQcm9wZXJ0eSBwYXRoXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBnZXROZXN0ZWRGaWVsZFZhbHVlKG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gcGF0aCB8fCBbXTtcbiAgb2JqZWN0ID0gb2JqZWN0IHx8IHt9O1xuICB2YXIgdmFsdWUgPSBvYmplY3Q7IC8vIHdhbGsgZG93biB0aGUgcHJvcGVydHkgcGF0aFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHZhbHVlID0gdmFsdWVbcGF0aFtpXV07XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogU2VhcmNoIGluZGV4IGNhcGFibGUgb2YgcmV0dXJuaW5nIHJlc3VsdHMgbWF0Y2hpbmcgYSBzZXQgb2YgdG9rZW5zIGFuZCByYW5rZWQgYWNjb3JkaW5nIHRvIFRGLUlERi5cbiAqL1xudmFyIFRmSWRmU2VhcmNoSW5kZXggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUZklkZlNlYXJjaEluZGV4KHVpZEZpZWxkTmFtZSkge1xuICAgIHRoaXMuX3VpZEZpZWxkTmFtZSA9IHVpZEZpZWxkTmFtZTtcbiAgICB0aGlzLl90b2tlblRvSWRmQ2FjaGUgPSB7fTtcbiAgICB0aGlzLl90b2tlbk1hcCA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY3NcbiAgICovXG5cbiAgdmFyIF9wcm90byA9IFRmSWRmU2VhcmNoSW5kZXgucHJvdG90eXBlO1xuICBfcHJvdG8uaW5kZXhEb2N1bWVudCA9IGZ1bmN0aW9uIGluZGV4RG9jdW1lbnQodG9rZW4sIHVpZCwgZG9jKSB7XG4gICAgdGhpcy5fdG9rZW5Ub0lkZkNhY2hlID0ge307IC8vIE5ldyBpbmRleCBpbnZhbGlkYXRlcyBwcmV2aW91cyBJREYgY2FjaGVzXG5cbiAgICB2YXIgdG9rZW5NYXAgPSB0aGlzLl90b2tlbk1hcDtcbiAgICB2YXIgdG9rZW5EYXR1bTtcbiAgICBpZiAodHlwZW9mIHRva2VuTWFwW3Rva2VuXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRva2VuTWFwW3Rva2VuXSA9IHRva2VuRGF0dW0gPSB7XG4gICAgICAgICRudW1Eb2N1bWVudE9jY3VycmVuY2VzOiAwLFxuICAgICAgICAkdG90YWxOdW1PY2N1cnJlbmNlczogMSxcbiAgICAgICAgJHVpZE1hcDoge31cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuRGF0dW0gPSB0b2tlbk1hcFt0b2tlbl07XG4gICAgICB0b2tlbkRhdHVtLiR0b3RhbE51bU9jY3VycmVuY2VzKys7XG4gICAgfVxuICAgIHZhciB1aWRNYXAgPSB0b2tlbkRhdHVtLiR1aWRNYXA7XG4gICAgaWYgKHR5cGVvZiB1aWRNYXBbdWlkXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRva2VuRGF0dW0uJG51bURvY3VtZW50T2NjdXJyZW5jZXMrKztcbiAgICAgIHVpZE1hcFt1aWRdID0ge1xuICAgICAgICAkZG9jdW1lbnQ6IGRvYyxcbiAgICAgICAgJG51bVRva2VuT2NjdXJyZW5jZXM6IDFcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHVpZE1hcFt1aWRdLiRudW1Ub2tlbk9jY3VycmVuY2VzKys7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY3NcbiAgICovO1xuICBfcHJvdG8uc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoKHRva2VucywgY29ycHVzKSB7XG4gICAgdmFyIHVpZFRvRG9jdW1lbnRNYXAgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICB2YXIgdG9rZW5NZXRhZGF0YSA9IHRoaXMuX3Rva2VuTWFwW3Rva2VuXTsgLy8gU2hvcnQgY2lyY3VpdCBpZiBubyBtYXRjaGVzIHdlcmUgZm91bmQgZm9yIGFueSBnaXZlbiB0b2tlbi5cblxuICAgICAgaWYgKCF0b2tlbk1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModG9rZW5NZXRhZGF0YS4kdWlkTWFwKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIG51bUtleXMgPSBrZXlzLmxlbmd0aDsgaiA8IG51bUtleXM7IGorKykge1xuICAgICAgICAgIHZhciB1aWQgPSBrZXlzW2pdO1xuICAgICAgICAgIHVpZFRvRG9jdW1lbnRNYXBbdWlkXSA9IHRva2VuTWV0YWRhdGEuJHVpZE1hcFt1aWRdLiRkb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh1aWRUb0RvY3VtZW50TWFwKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIG51bUtleXMgPSBrZXlzLmxlbmd0aDsgaiA8IG51bUtleXM7IGorKykge1xuICAgICAgICAgIHZhciB1aWQgPSBrZXlzW2pdO1xuICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW5NZXRhZGF0YS4kdWlkTWFwW3VpZF0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBkZWxldGUgdWlkVG9Eb2N1bWVudE1hcFt1aWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZG9jdW1lbnRzID0gW107XG4gICAgZm9yICh2YXIgdWlkIGluIHVpZFRvRG9jdW1lbnRNYXApIHtcbiAgICAgIGRvY3VtZW50cy5wdXNoKHVpZFRvRG9jdW1lbnRNYXBbdWlkXSk7XG4gICAgfVxuICAgIHZhciBjYWxjdWxhdGVUZklkZiA9IHRoaXMuX2NyZWF0ZUNhbGN1bGF0ZVRmSWRmKCk7IC8vIFJldHVybiBkb2N1bWVudHMgc29ydGVkIGJ5IFRGLUlERlxuXG4gICAgcmV0dXJuIGRvY3VtZW50cy5zb3J0KGZ1bmN0aW9uIChkb2N1bWVudEEsIGRvY3VtZW50Qikge1xuICAgICAgcmV0dXJuIGNhbGN1bGF0ZVRmSWRmKHRva2VucywgZG9jdW1lbnRCLCBjb3JwdXMpIC0gY2FsY3VsYXRlVGZJZGYodG9rZW5zLCBkb2N1bWVudEEsIGNvcnB1cyk7XG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5fY3JlYXRlQ2FsY3VsYXRlSWRmID0gZnVuY3Rpb24gX2NyZWF0ZUNhbGN1bGF0ZUlkZigpIHtcbiAgICB2YXIgdG9rZW5NYXAgPSB0aGlzLl90b2tlbk1hcDtcbiAgICB2YXIgdG9rZW5Ub0lkZkNhY2hlID0gdGhpcy5fdG9rZW5Ub0lkZkNhY2hlO1xuICAgIHJldHVybiBmdW5jdGlvbiBjYWxjdWxhdGVJZGYodG9rZW4sIGRvY3VtZW50cykge1xuICAgICAgaWYgKCF0b2tlblRvSWRmQ2FjaGVbdG9rZW5dKSB7XG4gICAgICAgIHZhciBudW1Eb2N1bWVudHNXaXRoVG9rZW4gPSB0eXBlb2YgdG9rZW5NYXBbdG9rZW5dICE9PSAndW5kZWZpbmVkJyA/IHRva2VuTWFwW3Rva2VuXS4kbnVtRG9jdW1lbnRPY2N1cnJlbmNlcyA6IDA7XG4gICAgICAgIHRva2VuVG9JZGZDYWNoZVt0b2tlbl0gPSAxICsgTWF0aC5sb2coZG9jdW1lbnRzLmxlbmd0aCAvICgxICsgbnVtRG9jdW1lbnRzV2l0aFRva2VuKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9rZW5Ub0lkZkNhY2hlW3Rva2VuXTtcbiAgICB9O1xuICB9O1xuICBfcHJvdG8uX2NyZWF0ZUNhbGN1bGF0ZVRmSWRmID0gZnVuY3Rpb24gX2NyZWF0ZUNhbGN1bGF0ZVRmSWRmKCkge1xuICAgIHZhciB0b2tlbk1hcCA9IHRoaXMuX3Rva2VuTWFwO1xuICAgIHZhciB1aWRGaWVsZE5hbWUgPSB0aGlzLl91aWRGaWVsZE5hbWU7XG4gICAgdmFyIGNhbGN1bGF0ZUlkZiA9IHRoaXMuX2NyZWF0ZUNhbGN1bGF0ZUlkZigpO1xuICAgIHJldHVybiBmdW5jdGlvbiBjYWxjdWxhdGVUZklkZih0b2tlbnMsIGRvY3VtZW50LCBkb2N1bWVudHMpIHtcbiAgICAgIHZhciBzY29yZSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgdmFyIGludmVyc2VEb2N1bWVudEZyZXF1ZW5jeSA9IGNhbGN1bGF0ZUlkZih0b2tlbiwgZG9jdW1lbnRzKTtcbiAgICAgICAgaWYgKGludmVyc2VEb2N1bWVudEZyZXF1ZW5jeSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICBpbnZlcnNlRG9jdW1lbnRGcmVxdWVuY3kgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1aWQ7XG4gICAgICAgIGlmICh1aWRGaWVsZE5hbWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIHVpZCA9IGRvY3VtZW50ICYmIGdldE5lc3RlZEZpZWxkVmFsdWUoZG9jdW1lbnQsIHVpZEZpZWxkTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdWlkID0gZG9jdW1lbnQgJiYgZG9jdW1lbnRbdWlkRmllbGROYW1lXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGVybUZyZXF1ZW5jeSA9IHR5cGVvZiB0b2tlbk1hcFt0b2tlbl0gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0b2tlbk1hcFt0b2tlbl0uJHVpZE1hcFt1aWRdICE9PSAndW5kZWZpbmVkJyA/IHRva2VuTWFwW3Rva2VuXS4kdWlkTWFwW3VpZF0uJG51bVRva2VuT2NjdXJyZW5jZXMgOiAwO1xuICAgICAgICBzY29yZSArPSB0ZXJtRnJlcXVlbmN5ICogaW52ZXJzZURvY3VtZW50RnJlcXVlbmN5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjb3JlO1xuICAgIH07XG4gIH07XG4gIHJldHVybiBUZklkZlNlYXJjaEluZGV4O1xufSgpO1xuXG4vKipcbiAqIFNlYXJjaCBpbmRleCBjYXBhYmxlIG9mIHJldHVybmluZyByZXN1bHRzIG1hdGNoaW5nIGEgc2V0IG9mIHRva2VucyBidXQgd2l0aG91dCBhbnkgbWVhbmluZ2Z1bCByYW5rIG9yIG9yZGVyLlxuICovXG52YXIgVW5vcmRlcmVkU2VhcmNoSW5kZXggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBVbm9yZGVyZWRTZWFyY2hJbmRleCgpIHtcbiAgICB0aGlzLl90b2tlblRvVWlkVG9Eb2N1bWVudE1hcCA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY3NcbiAgICovXG5cbiAgdmFyIF9wcm90byA9IFVub3JkZXJlZFNlYXJjaEluZGV4LnByb3RvdHlwZTtcbiAgX3Byb3RvLmluZGV4RG9jdW1lbnQgPSBmdW5jdGlvbiBpbmRleERvY3VtZW50KHRva2VuLCB1aWQsIGRvYykge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fdG9rZW5Ub1VpZFRvRG9jdW1lbnRNYXBbdG9rZW5dICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy5fdG9rZW5Ub1VpZFRvRG9jdW1lbnRNYXBbdG9rZW5dID0ge307XG4gICAgfVxuICAgIHRoaXMuX3Rva2VuVG9VaWRUb0RvY3VtZW50TWFwW3Rva2VuXVt1aWRdID0gZG9jO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY3NcbiAgICovO1xuICBfcHJvdG8uc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoKHRva2VucywgY29ycHVzKSB7XG4gICAgdmFyIGludGVyc2VjdGluZ0RvY3VtZW50TWFwID0ge307XG4gICAgdmFyIHRva2VuVG9VaWRUb0RvY3VtZW50TWFwID0gdGhpcy5fdG9rZW5Ub1VpZFRvRG9jdW1lbnRNYXA7XG4gICAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgdmFyIGRvY3VtZW50TWFwID0gdG9rZW5Ub1VpZFRvRG9jdW1lbnRNYXBbdG9rZW5dOyAvLyBTaG9ydCBjaXJjdWl0IGlmIG5vIG1hdGNoZXMgd2VyZSBmb3VuZCBmb3IgYW55IGdpdmVuIHRva2VuLlxuXG4gICAgICBpZiAoIWRvY3VtZW50TWFwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZG9jdW1lbnRNYXApO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgbnVtS2V5cyA9IGtleXMubGVuZ3RoOyBqIDwgbnVtS2V5czsgaisrKSB7XG4gICAgICAgICAgdmFyIHVpZCA9IGtleXNbal07XG4gICAgICAgICAgaW50ZXJzZWN0aW5nRG9jdW1lbnRNYXBbdWlkXSA9IGRvY3VtZW50TWFwW3VpZF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoaW50ZXJzZWN0aW5nRG9jdW1lbnRNYXApO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgbnVtS2V5cyA9IGtleXMubGVuZ3RoOyBqIDwgbnVtS2V5czsgaisrKSB7XG4gICAgICAgICAgdmFyIHVpZCA9IGtleXNbal07XG4gICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudE1hcFt1aWRdICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZGVsZXRlIGludGVyc2VjdGluZ0RvY3VtZW50TWFwW3VpZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoaW50ZXJzZWN0aW5nRG9jdW1lbnRNYXApO1xuICAgIHZhciBkb2N1bWVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbnVtS2V5cyA9IGtleXMubGVuZ3RoOyBpIDwgbnVtS2V5czsgaSsrKSB7XG4gICAgICB2YXIgdWlkID0ga2V5c1tpXTtcbiAgICAgIGRvY3VtZW50cy5wdXNoKGludGVyc2VjdGluZ0RvY3VtZW50TWFwW3VpZF0pO1xuICAgIH1cbiAgICByZXR1cm4gZG9jdW1lbnRzO1xuICB9O1xuICByZXR1cm4gVW5vcmRlcmVkU2VhcmNoSW5kZXg7XG59KCk7XG52YXIgUkVHRVggPSAvW15hLXrQsC3Rj9GRMC05XFwtJ10rL2k7XG4vKipcbiAqIFNpbXBsZSB0b2tlbml6ZXIgdGhhdCBzcGxpdHMgc3RyaW5ncyBvbiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgYWxsIG5vbi1lbXB0eSBzdWJzdHJpbmdzLlxuICovXG5cbnZhciBTaW1wbGVUb2tlbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaW1wbGVUb2tlbml6ZXIoKSB7fVxuICB2YXIgX3Byb3RvID0gU2ltcGxlVG9rZW5pemVyLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NzXG4gICAqL1xuICBfcHJvdG8udG9rZW5pemUgPSBmdW5jdGlvbiB0b2tlbml6ZSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQuc3BsaXQoUkVHRVgpLmZpbHRlcihmdW5jdGlvbiAodGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSAvLyBGaWx0ZXIgZW1wdHkgdG9rZW5zXG4gICAgKTtcbiAgfTtcbiAgcmV0dXJuIFNpbXBsZVRva2VuaXplcjtcbn0oKTtcblxuLyoqXG4gKiBTdGVtbWluZyBpcyB0aGUgcHJvY2VzcyBvZiByZWR1Y2luZyBzZWFyY2ggdG9rZW5zIHRvIHRoZWlyIHJvb3QgKG9yIHN0ZW0pIHNvIHRoYXQgc2VhcmNoZXMgZm9yIGRpZmZlcmVudCBmb3JtcyBvZiBhXG4gKiB3b3JkIHdpbGwgbWF0Y2guIEZvciBleGFtcGxlIFwic2VhcmNoXCIsIFwic2VhcmNoaW5nXCIgYW5kIFwic2VhcmNoZWRcIiBhcmUgYWxsIHJlZHVjZWQgdG8gdGhlIHN0ZW0gXCJzZWFyY2hcIi5cbiAqXG4gKiA8cD5UaGlzIHN0ZW1taW5nIHRva2VuaXplciBjb252ZXJ0cyB0b2tlbnMgKHdvcmRzKSB0byB0aGVpciBzdGVtIGZvcm1zIGJlZm9yZSByZXR1cm5pbmcgdGhlbS4gSXQgcmVxdWlyZXMgYW5cbiAqIGV4dGVybmFsIHN0ZW1taW5nIGZ1bmN0aW9uIHRvIGJlIHByb3ZpZGVkOyBmb3IgdGhpcyBwdXJwb3NlIEkgcmVjb21tZW5kIHRoZSBOUE0gJ3BvcnRlci1zdGVtbWVyJyBsaWJyYXJ5LlxuICpcbiAqIDxwPkZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSBodHRwIDogLy90YXJ0YXJ1cy5vcmcvfm1hcnRpbi9Qb3J0ZXJTdGVtbWVyL1xuICovXG52YXIgU3RlbW1pbmdUb2tlbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBzdGVtbWluZ0Z1bmN0aW9uIEZ1bmN0aW9uIGNhcGFibGUgb2YgYWNjZXB0aW5nIGEgd29yZCBhbmQgcmV0dXJuaW5nIGl0cyBzdGVtLlxuICAgKiBAcGFyYW0gZGVjb3JhdGVkSW5kZXhTdHJhdGVneSBJbmRleCBzdHJhdGVneSB0byBiZSBydW4gYWZ0ZXIgYWxsIHN0b3Agd29yZHMgaGF2ZSBiZWVuIHJlbW92ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBTdGVtbWluZ1Rva2VuaXplcihzdGVtbWluZ0Z1bmN0aW9uLCBkZWNvcmF0ZWRUb2tlbml6ZXIpIHtcbiAgICB0aGlzLl9zdGVtbWluZ0Z1bmN0aW9uID0gc3RlbW1pbmdGdW5jdGlvbjtcbiAgICB0aGlzLl90b2tlbml6ZXIgPSBkZWNvcmF0ZWRUb2tlbml6ZXI7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jc1xuICAgKi9cblxuICB2YXIgX3Byb3RvID0gU3RlbW1pbmdUb2tlbml6ZXIucHJvdG90eXBlO1xuICBfcHJvdG8udG9rZW5pemUgPSBmdW5jdGlvbiB0b2tlbml6ZSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3Rva2VuaXplci50b2tlbml6ZSh0ZXh0KS5tYXAodGhpcy5fc3RlbW1pbmdGdW5jdGlvbik7XG4gIH07XG4gIHJldHVybiBTdGVtbWluZ1Rva2VuaXplcjtcbn0oKTtcblxuLyoqXG4gKiBTdG9wIHdvcmRzIGxpc3QgY29waWVkIGZyb20gTHVuciBKUy5cbiAqL1xudmFyIFN0b3BXb3Jkc01hcCA9IHtcbiAgYTogdHJ1ZSxcbiAgYWJsZTogdHJ1ZSxcbiAgYWJvdXQ6IHRydWUsXG4gIGFjcm9zczogdHJ1ZSxcbiAgYWZ0ZXI6IHRydWUsXG4gIGFsbDogdHJ1ZSxcbiAgYWxtb3N0OiB0cnVlLFxuICBhbHNvOiB0cnVlLFxuICBhbTogdHJ1ZSxcbiAgYW1vbmc6IHRydWUsXG4gIGFuOiB0cnVlLFxuICBhbmQ6IHRydWUsXG4gIGFueTogdHJ1ZSxcbiAgYXJlOiB0cnVlLFxuICBhczogdHJ1ZSxcbiAgYXQ6IHRydWUsXG4gIGJlOiB0cnVlLFxuICBiZWNhdXNlOiB0cnVlLFxuICBiZWVuOiB0cnVlLFxuICBidXQ6IHRydWUsXG4gIGJ5OiB0cnVlLFxuICBjYW46IHRydWUsXG4gIGNhbm5vdDogdHJ1ZSxcbiAgY291bGQ6IHRydWUsXG4gIGRlYXI6IHRydWUsXG4gIGRpZDogdHJ1ZSxcbiAgJ2RvJzogdHJ1ZSxcbiAgZG9lczogdHJ1ZSxcbiAgZWl0aGVyOiB0cnVlLFxuICAnZWxzZSc6IHRydWUsXG4gIGV2ZXI6IHRydWUsXG4gIGV2ZXJ5OiB0cnVlLFxuICAnZm9yJzogdHJ1ZSxcbiAgZnJvbTogdHJ1ZSxcbiAgJ2dldCc6IHRydWUsXG4gIGdvdDogdHJ1ZSxcbiAgaGFkOiB0cnVlLFxuICBoYXM6IHRydWUsXG4gIGhhdmU6IHRydWUsXG4gIGhlOiB0cnVlLFxuICBoZXI6IHRydWUsXG4gIGhlcnM6IHRydWUsXG4gIGhpbTogdHJ1ZSxcbiAgaGlzOiB0cnVlLFxuICBob3c6IHRydWUsXG4gIGhvd2V2ZXI6IHRydWUsXG4gIGk6IHRydWUsXG4gICdpZic6IHRydWUsXG4gICdpbic6IHRydWUsXG4gIGludG86IHRydWUsXG4gIGlzOiB0cnVlLFxuICBpdDogdHJ1ZSxcbiAgaXRzOiB0cnVlLFxuICBqdXN0OiB0cnVlLFxuICBsZWFzdDogdHJ1ZSxcbiAgXCJsZXRcIjogdHJ1ZSxcbiAgbGlrZTogdHJ1ZSxcbiAgbGlrZWx5OiB0cnVlLFxuICBtYXk6IHRydWUsXG4gIG1lOiB0cnVlLFxuICBtaWdodDogdHJ1ZSxcbiAgbW9zdDogdHJ1ZSxcbiAgbXVzdDogdHJ1ZSxcbiAgbXk6IHRydWUsXG4gIG5laXRoZXI6IHRydWUsXG4gIG5vOiB0cnVlLFxuICBub3I6IHRydWUsXG4gIG5vdDogdHJ1ZSxcbiAgb2Y6IHRydWUsXG4gIG9mZjogdHJ1ZSxcbiAgb2Z0ZW46IHRydWUsXG4gIG9uOiB0cnVlLFxuICBvbmx5OiB0cnVlLFxuICBvcjogdHJ1ZSxcbiAgb3RoZXI6IHRydWUsXG4gIG91cjogdHJ1ZSxcbiAgb3duOiB0cnVlLFxuICByYXRoZXI6IHRydWUsXG4gIHNhaWQ6IHRydWUsXG4gIHNheTogdHJ1ZSxcbiAgc2F5czogdHJ1ZSxcbiAgc2hlOiB0cnVlLFxuICBzaG91bGQ6IHRydWUsXG4gIHNpbmNlOiB0cnVlLFxuICBzbzogdHJ1ZSxcbiAgc29tZTogdHJ1ZSxcbiAgdGhhbjogdHJ1ZSxcbiAgdGhhdDogdHJ1ZSxcbiAgdGhlOiB0cnVlLFxuICB0aGVpcjogdHJ1ZSxcbiAgdGhlbTogdHJ1ZSxcbiAgdGhlbjogdHJ1ZSxcbiAgdGhlcmU6IHRydWUsXG4gIHRoZXNlOiB0cnVlLFxuICB0aGV5OiB0cnVlLFxuICAndGhpcyc6IHRydWUsXG4gIHRpczogdHJ1ZSxcbiAgdG86IHRydWUsXG4gIHRvbzogdHJ1ZSxcbiAgdHdhczogdHJ1ZSxcbiAgdXM6IHRydWUsXG4gIHdhbnRzOiB0cnVlLFxuICB3YXM6IHRydWUsXG4gIHdlOiB0cnVlLFxuICB3ZXJlOiB0cnVlLFxuICB3aGF0OiB0cnVlLFxuICB3aGVuOiB0cnVlLFxuICB3aGVyZTogdHJ1ZSxcbiAgd2hpY2g6IHRydWUsXG4gICd3aGlsZSc6IHRydWUsXG4gIHdobzogdHJ1ZSxcbiAgd2hvbTogdHJ1ZSxcbiAgd2h5OiB0cnVlLFxuICB3aWxsOiB0cnVlLFxuICAnd2l0aCc6IHRydWUsXG4gIHdvdWxkOiB0cnVlLFxuICB5ZXQ6IHRydWUsXG4gIHlvdTogdHJ1ZSxcbiAgeW91cjogdHJ1ZVxufTsgLy8gUHJldmVudCBmYWxzZSBwb3NpdGl2ZXMgZm9yIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG5cblN0b3BXb3Jkc01hcC5jb25zdHJ1Y3RvciA9IGZhbHNlO1xuU3RvcFdvcmRzTWFwLmhhc093blByb3BlcnR5ID0gZmFsc2U7XG5TdG9wV29yZHNNYXAuaXNQcm90b3R5cGVPZiA9IGZhbHNlO1xuU3RvcFdvcmRzTWFwLnByb3BlcnR5SXNFbnVtZXJhYmxlID0gZmFsc2U7XG5TdG9wV29yZHNNYXAudG9Mb2NhbGVTdHJpbmcgPSBmYWxzZTtcblN0b3BXb3Jkc01hcC50b1N0cmluZyA9IGZhbHNlO1xuU3RvcFdvcmRzTWFwLnZhbHVlT2YgPSBmYWxzZTtcblxuLyoqXG4gKiBTdG9wIHdvcmRzIGFyZSB2ZXJ5IGNvbW1vbiAoZS5nLiBcImFcIiwgXCJhbmRcIiwgXCJ0aGVcIikgYW5kIGFyZSBvZnRlbiBub3Qgc2VtYW50aWNhbGx5IG1lYW5pbmdmdWwgaW4gdGhlIGNvbnRleHQgb2YgYVxuICogc2VhcmNoLiBUaGlzIHRva2VuaXplciByZW1vdmVzIHN0b3Agd29yZHMgZnJvbSBhIHNldCBvZiB0b2tlbnMgYmVmb3JlIHBhc3NpbmcgdGhlIHJlbWFpbmluZyB0b2tlbnMgYWxvbmcgZm9yXG4gKiBpbmRleGluZyBvciBzZWFyY2hpbmcgcHVycG9zZXMuXG4gKi9cblxudmFyIFN0b3BXb3Jkc1Rva2VuaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIGRlY29yYXRlZEluZGV4U3RyYXRlZ3kgSW5kZXggc3RyYXRlZ3kgdG8gYmUgcnVuIGFmdGVyIGFsbCBzdG9wIHdvcmRzIGhhdmUgYmVlbiByZW1vdmVkLlxuICAgKi9cbiAgZnVuY3Rpb24gU3RvcFdvcmRzVG9rZW5pemVyKGRlY29yYXRlZFRva2VuaXplcikge1xuICAgIHRoaXMuX3Rva2VuaXplciA9IGRlY29yYXRlZFRva2VuaXplcjtcbiAgfVxuICAvKipcbiAgICogQGluaGVyaXREb2NzXG4gICAqL1xuXG4gIHZhciBfcHJvdG8gPSBTdG9wV29yZHNUb2tlbml6ZXIucHJvdG90eXBlO1xuICBfcHJvdG8udG9rZW5pemUgPSBmdW5jdGlvbiB0b2tlbml6ZSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3Rva2VuaXplci50b2tlbml6ZSh0ZXh0KS5maWx0ZXIoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICByZXR1cm4gIVN0b3BXb3Jkc01hcFt0b2tlbl07XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBTdG9wV29yZHNUb2tlbml6ZXI7XG59KCk7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG4vKipcbiAqIFNpbXBsZSBjbGllbnQtc2lkZSBzZWFyY2hpbmcgd2l0aGluIGEgc2V0IG9mIGRvY3VtZW50cy5cbiAqXG4gKiA8cD5Eb2N1bWVudHMgY2FuIGJlIHNlYXJjaGVkIGJ5IGFueSBudW1iZXIgb2YgZmllbGRzLiBJbmRleGluZyBhbmQgc2VhcmNoIHN0cmF0ZWdpZXMgYXJlIGhpZ2hseSBjdXN0b21pemFibGUuXG4gKi9cbnZhciBTZWFyY2ggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQXJyYXkgY29udGFpbmluZyBlaXRoZXIgYSBwcm9wZXJ0eSBuYW1lIG9yIGEgcGF0aCAobGlzdCBvZiBwcm9wZXJ0eSBuYW1lcykgdG8gYSBuZXN0ZWQgdmFsdWVcbiAgICovXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0gdWlkRmllbGROYW1lIEZpZWxkIGNvbnRhaW5pbmcgdmFsdWVzIHRoYXQgdW5pcXVlbHkgaWRlbnRpZnkgc2VhcmNoIGRvY3VtZW50czsgdGhpcyBmaWVsZCdzIHZhbHVlcyBhcmUgdXNlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHRvIGVuc3VyZSB0aGF0IGEgc2VhcmNoIHJlc3VsdCBzZXQgZG9lcyBub3QgY29udGFpbiBkdXBsaWNhdGUgb2JqZWN0cy5cbiAgICovXG4gIGZ1bmN0aW9uIFNlYXJjaCh1aWRGaWVsZE5hbWUpIHtcbiAgICBpZiAoIXVpZEZpZWxkTmFtZSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ2pzLXNlYXJjaCByZXF1aXJlcyBhIHVpZCBmaWVsZCBuYW1lIGNvbnN0cnVjdG9yIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICB0aGlzLl91aWRGaWVsZE5hbWUgPSB1aWRGaWVsZE5hbWU7IC8vIFNldCBkZWZhdWx0L3JlY29tbWVuZGVkIHN0cmF0ZWdpZXNcblxuICAgIHRoaXMuX2luZGV4U3RyYXRlZ3kgPSBuZXcgUHJlZml4SW5kZXhTdHJhdGVneSgpO1xuICAgIHRoaXMuX3NlYXJjaEluZGV4ID0gbmV3IFRmSWRmU2VhcmNoSW5kZXgodWlkRmllbGROYW1lKTtcbiAgICB0aGlzLl9zYW5pdGl6ZXIgPSBuZXcgTG93ZXJDYXNlU2FuaXRpemVyKCk7XG4gICAgdGhpcy5fdG9rZW5pemVyID0gbmV3IFNpbXBsZVRva2VuaXplcigpO1xuICAgIHRoaXMuX2RvY3VtZW50cyA9IFtdO1xuICAgIHRoaXMuX3NlYXJjaGFibGVGaWVsZHMgPSBbXTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgaW5kZXggc3RyYXRlZ3kuXG4gICAqIEBwYXJhbSB2YWx1ZSBDdXN0b20gaW5kZXggc3RyYXRlZ3lcbiAgICogQHRocm93cyBFcnJvciBpZiBkb2N1bWVudHMgaGF2ZSBhbHJlYWR5IGJlZW4gaW5kZXhlZCBieSB0aGlzIHNlYXJjaCBpbnN0YW5jZVxuICAgKi9cblxuICB2YXIgX3Byb3RvID0gU2VhcmNoLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQWRkIGEgc2VhcmNoYWJsZSBkb2N1bWVudCB0byB0aGUgaW5kZXguIERvY3VtZW50IHdpbGwgYXV0b21hdGljYWxseSBiZSBpbmRleGVkIGZvciBzZWFyY2guXG4gICAqIEBwYXJhbSBkb2N1bWVudFxuICAgKi9cbiAgX3Byb3RvLmFkZERvY3VtZW50ID0gZnVuY3Rpb24gYWRkRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICB0aGlzLmFkZERvY3VtZW50cyhbZG9jdW1lbnRdKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBzZWFyY2hhYmxlIGRvY3VtZW50cyB0byB0aGUgaW5kZXguIERvY3VtZW50cyB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgaW5kZXhlZCBmb3Igc2VhcmNoLlxuICAgKiBAcGFyYW0gZG9jdW1lbnRcbiAgICovO1xuICBfcHJvdG8uYWRkRG9jdW1lbnRzID0gZnVuY3Rpb24gYWRkRG9jdW1lbnRzKGRvY3VtZW50cykge1xuICAgIHRoaXMuX2RvY3VtZW50cyA9IHRoaXMuX2RvY3VtZW50cy5jb25jYXQoZG9jdW1lbnRzKTtcbiAgICB0aGlzLmluZGV4RG9jdW1lbnRzXyhkb2N1bWVudHMsIHRoaXMuX3NlYXJjaGFibGVGaWVsZHMpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgc2VhcmNoYWJsZSBmaWVsZCB0byB0aGUgaW5kZXguIEV4aXN0aW5nIGRvY3VtZW50cyB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgaW5kZXhlZCB1c2luZyB0aGlzIG5ldyBmaWVsZC5cbiAgICpcbiAgICogQHBhcmFtIGZpZWxkIFNlYXJjaGFibGUgZmllbGQgb3IgZmllbGQgcGF0aC4gUGFzcyBhIHN0cmluZyB0byBpbmRleCBhIHRvcC1sZXZlbCBmaWVsZCBhbmQgYW4gYXJyYXkgb2Ygc3RyaW5ncyBmb3IgbmVzdGVkIGZpZWxkcy5cbiAgICovO1xuICBfcHJvdG8uYWRkSW5kZXggPSBmdW5jdGlvbiBhZGRJbmRleChmaWVsZCkge1xuICAgIHRoaXMuX3NlYXJjaGFibGVGaWVsZHMucHVzaChmaWVsZCk7XG4gICAgdGhpcy5pbmRleERvY3VtZW50c18odGhpcy5fZG9jdW1lbnRzLCBbZmllbGRdKTtcbiAgfVxuICAvKipcbiAgICogU2VhcmNoIGFsbCBkb2N1bWVudHMgZm9yIG9uZXMgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCBxdWVyeSB0ZXh0LlxuICAgKiBAcGFyYW0gcXVlcnlcbiAgICogQHJldHVybnMge0FycmF5PE9iamVjdD59XG4gICAqLztcbiAgX3Byb3RvLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChxdWVyeSkge1xuICAgIHZhciB0b2tlbnMgPSB0aGlzLl90b2tlbml6ZXIudG9rZW5pemUodGhpcy5fc2FuaXRpemVyLnNhbml0aXplKHF1ZXJ5KSk7XG4gICAgcmV0dXJuIHRoaXMuX3NlYXJjaEluZGV4LnNlYXJjaCh0b2tlbnMsIHRoaXMuX2RvY3VtZW50cyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBkb2N1bWVudHNcbiAgICogQHBhcmFtIF9zZWFyY2hhYmxlRmllbGRzIEFycmF5IGNvbnRhaW5pbmcgcHJvcGVydHkgbmFtZXMgYW5kIHBhdGhzIChsaXN0cyBvZiBwcm9wZXJ0eSBuYW1lcykgdG8gbmVzdGVkIHZhbHVlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi87XG4gIF9wcm90by5pbmRleERvY3VtZW50c18gPSBmdW5jdGlvbiBpbmRleERvY3VtZW50c18oZG9jdW1lbnRzLCBfc2VhcmNoYWJsZUZpZWxkcykge1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB2YXIgaW5kZXhTdHJhdGVneSA9IHRoaXMuX2luZGV4U3RyYXRlZ3k7XG4gICAgdmFyIHNhbml0aXplciA9IHRoaXMuX3Nhbml0aXplcjtcbiAgICB2YXIgc2VhcmNoSW5kZXggPSB0aGlzLl9zZWFyY2hJbmRleDtcbiAgICB2YXIgdG9rZW5pemVyID0gdGhpcy5fdG9rZW5pemVyO1xuICAgIHZhciB1aWRGaWVsZE5hbWUgPSB0aGlzLl91aWRGaWVsZE5hbWU7XG4gICAgZm9yICh2YXIgZGkgPSAwLCBudW1Eb2N1bWVudHMgPSBkb2N1bWVudHMubGVuZ3RoOyBkaSA8IG51bURvY3VtZW50czsgZGkrKykge1xuICAgICAgdmFyIGRvYyA9IGRvY3VtZW50c1tkaV07XG4gICAgICB2YXIgdWlkO1xuICAgICAgaWYgKHVpZEZpZWxkTmFtZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHVpZCA9IGdldE5lc3RlZEZpZWxkVmFsdWUoZG9jLCB1aWRGaWVsZE5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdWlkID0gZG9jW3VpZEZpZWxkTmFtZV07XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBzZmkgPSAwLCBudW1TZWFyY2hhYmxlRmllbGRzID0gX3NlYXJjaGFibGVGaWVsZHMubGVuZ3RoOyBzZmkgPCBudW1TZWFyY2hhYmxlRmllbGRzOyBzZmkrKykge1xuICAgICAgICB2YXIgZmllbGRWYWx1ZTtcbiAgICAgICAgdmFyIHNlYXJjaGFibGVGaWVsZCA9IF9zZWFyY2hhYmxlRmllbGRzW3NmaV07XG4gICAgICAgIGlmIChzZWFyY2hhYmxlRmllbGQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIGZpZWxkVmFsdWUgPSBnZXROZXN0ZWRGaWVsZFZhbHVlKGRvYywgc2VhcmNoYWJsZUZpZWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWVsZFZhbHVlID0gZG9jW3NlYXJjaGFibGVGaWVsZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgZmllbGRWYWx1ZSAhPT0gJ3N0cmluZycgJiYgZmllbGRWYWx1ZS50b1N0cmluZykge1xuICAgICAgICAgIGZpZWxkVmFsdWUgPSBmaWVsZFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBmaWVsZFRva2VucyA9IHRva2VuaXplci50b2tlbml6ZShzYW5pdGl6ZXIuc2FuaXRpemUoZmllbGRWYWx1ZSkpO1xuICAgICAgICAgIGZvciAodmFyIGZ0aSA9IDAsIG51bUZpZWxkVmFsdWVzID0gZmllbGRUb2tlbnMubGVuZ3RoOyBmdGkgPCBudW1GaWVsZFZhbHVlczsgZnRpKyspIHtcbiAgICAgICAgICAgIHZhciBmaWVsZFRva2VuID0gZmllbGRUb2tlbnNbZnRpXTtcbiAgICAgICAgICAgIHZhciBleHBhbmRlZFRva2VucyA9IGluZGV4U3RyYXRlZ3kuZXhwYW5kVG9rZW4oZmllbGRUb2tlbik7XG4gICAgICAgICAgICBmb3IgKHZhciBldGkgPSAwLCBudW1tRXhwYW5kZWRUb2tlbnMgPSBleHBhbmRlZFRva2Vucy5sZW5ndGg7IGV0aSA8IG51bW1FeHBhbmRlZFRva2VuczsgZXRpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGV4cGFuZGVkVG9rZW4gPSBleHBhbmRlZFRva2Vuc1tldGldO1xuICAgICAgICAgICAgICBzZWFyY2hJbmRleC5pbmRleERvY3VtZW50KGV4cGFuZGVkVG9rZW4sIHVpZCwgZG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9jcmVhdGVDbGFzcyhTZWFyY2gsIFt7XG4gICAga2V5OiBcImluZGV4U3RyYXRlZ3lcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdJSW5kZXhTdHJhdGVneSBjYW5ub3QgYmUgc2V0IGFmdGVyIGluaXRpYWxpemF0aW9uJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbmRleFN0cmF0ZWd5ID0gdmFsdWU7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbmRleFN0cmF0ZWd5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCB0ZXh0IHNhbml0aXppbmcgc3RyYXRlZ3kuXG4gICAgICogQHBhcmFtIHZhbHVlIEN1c3RvbSB0ZXh0IHNhbml0aXppbmcgc3RyYXRlZ3lcbiAgICAgKiBAdGhyb3dzIEVycm9yIGlmIGRvY3VtZW50cyBoYXZlIGFscmVhZHkgYmVlbiBpbmRleGVkIGJ5IHRoaXMgc2VhcmNoIGluc3RhbmNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2FuaXRpemVyXCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICB0aHJvdyBFcnJvcignSVNhbml0aXplciBjYW5ub3QgYmUgc2V0IGFmdGVyIGluaXRpYWxpemF0aW9uJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zYW5pdGl6ZXIgPSB2YWx1ZTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Nhbml0aXplcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgc2VhcmNoIGluZGV4IHN0cmF0ZWd5LlxuICAgICAqIEBwYXJhbSB2YWx1ZSBDdXN0b20gc2VhcmNoIGluZGV4IHN0cmF0ZWd5XG4gICAgICogQHRocm93cyBFcnJvciBpZiBkb2N1bWVudHMgaGF2ZSBhbHJlYWR5IGJlZW4gaW5kZXhlZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNlYXJjaEluZGV4XCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICB0aHJvdyBFcnJvcignSVNlYXJjaEluZGV4IGNhbm5vdCBiZSBzZXQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NlYXJjaEluZGV4ID0gdmFsdWU7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWFyY2hJbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgdGV4dCB0b2tlbml6aW5nIHN0cmF0ZWd5LlxuICAgICAqIEBwYXJhbSB2YWx1ZSBDdXN0b20gdGV4dCB0b2tlbml6aW5nIHN0cmF0ZWd5XG4gICAgICogQHRocm93cyBFcnJvciBpZiBkb2N1bWVudHMgaGF2ZSBhbHJlYWR5IGJlZW4gaW5kZXhlZCBieSB0aGlzIHNlYXJjaCBpbnN0YW5jZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRva2VuaXplclwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0lUb2tlbml6ZXIgY2Fubm90IGJlIHNldCBhZnRlciBpbml0aWFsaXphdGlvbicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdG9rZW5pemVyID0gdmFsdWU7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b2tlbml6ZXI7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTZWFyY2g7XG59KCk7XG5cbi8qKlxuICogVGhpcyB1dGlsaXR5IGhpZ2hsaWdodHMgdGhlIG9jY3VycmVuY2VzIG9mIHRva2VucyB3aXRoaW4gYSBzdHJpbmcgb2YgdGV4dC4gSXQgY2FuIGJlIHVzZWQgdG8gZ2l2ZSB2aXN1YWwgaW5kaWNhdG9yc1xuICogb2YgbWF0Y2ggY3JpdGVyaWEgd2l0aGluIHNlYXJjaGFibGUgZmllbGRzLlxuICpcbiAqIDxwPkZvciBwZXJmb3JtYW5jZSBwdXJwb3NlcyB0aGlzIGhpZ2hsaWdodGVyIG9ubHkgd29ya3Mgd2l0aCBmdWxsLXdvcmQgb3IgcHJlZml4IHRva2VuIGluZGV4ZXMuXG4gKi9cbnZhciBUb2tlbkhpZ2hsaWdodGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0X2luZGV4U3RyYXRlZ3kgSW5kZXggc3RyYXRlZ3kgdXNlZCBieSBTZWFyY2hcbiAgICogQHBhcmFtIG9wdF9zYW5pdGl6ZXIgU2FuaXRpemVyIHVzZWQgYnkgU2VhcmNoXG4gICAqIEBwYXJhbSBvcHRfd3JhcHBlclRhZ05hbWUgT3B0aW9uYWwgd3JhcHBlciB0YWcgbmFtZTsgZGVmYXVsdHMgdG8gJ21hcmsnIChlLmcuIDxtYXJrPilcbiAgICovXG4gIGZ1bmN0aW9uIFRva2VuSGlnaGxpZ2h0ZXIob3B0X2luZGV4U3RyYXRlZ3ksIG9wdF9zYW5pdGl6ZXIsIG9wdF93cmFwcGVyVGFnTmFtZSkge1xuICAgIHRoaXMuX2luZGV4U3RyYXRlZ3kgPSBvcHRfaW5kZXhTdHJhdGVneSB8fCBuZXcgUHJlZml4SW5kZXhTdHJhdGVneSgpO1xuICAgIHRoaXMuX3Nhbml0aXplciA9IG9wdF9zYW5pdGl6ZXIgfHwgbmV3IExvd2VyQ2FzZVNhbml0aXplcigpO1xuICAgIHRoaXMuX3dyYXBwZXJUYWdOYW1lID0gb3B0X3dyYXBwZXJUYWdOYW1lIHx8ICdtYXJrJztcbiAgfVxuICAvKipcbiAgICogSGlnaGxpZ2h0cyB0b2tlbiBvY2N1cnJlbmNlcyB3aXRoaW4gYSBzdHJpbmcgYnkgd3JhcHBpbmcgdGhlbSB3aXRoIGEgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB0ZXh0IGUuZy4gXCJqb2huIHdheW5lXCJcbiAgICogQHBhcmFtIHRva2VucyBlLmcuIFtcIndhXCJdXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IGUuZy4gXCJqb2huIDxtYXJrPndhPC9tYXJrPnluZVwiXG4gICAqL1xuXG4gIHZhciBfcHJvdG8gPSBUb2tlbkhpZ2hsaWdodGVyLnByb3RvdHlwZTtcbiAgX3Byb3RvLmhpZ2hsaWdodCA9IGZ1bmN0aW9uIGhpZ2hsaWdodCh0ZXh0LCB0b2tlbnMpIHtcbiAgICB2YXIgdGFnc0xlbmd0aCA9IHRoaXMuX3dyYXBUZXh0KCcnKS5sZW5ndGg7XG4gICAgdmFyIHRva2VuRGljdGlvbmFyeSA9IE9iamVjdC5jcmVhdGUobnVsbCk7IC8vIENyZWF0ZSBhIHRva2VuIG1hcCBmb3IgZWFzaWVyIGxvb2t1cCBiZWxvdy5cblxuICAgIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRoaXMuX3Nhbml0aXplci5zYW5pdGl6ZSh0b2tlbnNbaV0pO1xuICAgICAgdmFyIGV4cGFuZGVkVG9rZW5zID0gdGhpcy5faW5kZXhTdHJhdGVneS5leHBhbmRUb2tlbih0b2tlbik7XG4gICAgICBmb3IgKHZhciBqID0gMCwgbnVtRXhwYW5kZWRUb2tlbnMgPSBleHBhbmRlZFRva2Vucy5sZW5ndGg7IGogPCBudW1FeHBhbmRlZFRva2VuczsgaisrKSB7XG4gICAgICAgIHZhciBleHBhbmRlZFRva2VuID0gZXhwYW5kZWRUb2tlbnNbal07XG4gICAgICAgIGlmICghdG9rZW5EaWN0aW9uYXJ5W2V4cGFuZGVkVG9rZW5dKSB7XG4gICAgICAgICAgdG9rZW5EaWN0aW9uYXJ5W2V4cGFuZGVkVG9rZW5dID0gW3Rva2VuXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbkRpY3Rpb25hcnlbZXhwYW5kZWRUb2tlbl0ucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFRyYWNrIGFjdHVhbEN1cnJlbnRXb3JkIGFuZCBzYW5pdGl6ZWRDdXJyZW50V29yZCBzZXBhcmF0ZWx5IGluIGNhc2Ugd2UgZW5jb3VudGVyIG5lc3RlZCB0YWdzLlxuXG4gICAgdmFyIGFjdHVhbEN1cnJlbnRXb3JkID0gJyc7XG4gICAgdmFyIHNhbml0aXplZEN1cnJlbnRXb3JkID0gJyc7XG4gICAgdmFyIGN1cnJlbnRXb3JkU3RhcnRJbmRleCA9IDA7IC8vIE5vdGUgdGhpcyBhc3N1bWVzIGVpdGhlciBwcmVmaXggb3IgZnVsbCB3b3JkIG1hdGNoaW5nLlxuXG4gICAgZm9yICh2YXIgaSA9IDAsIHRleHRMZW5ndGggPSB0ZXh0Lmxlbmd0aDsgaSA8IHRleHRMZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoYXJhY3RlciA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgaWYgKGNoYXJhY3RlciA9PT0gJyAnKSB7XG4gICAgICAgIGFjdHVhbEN1cnJlbnRXb3JkID0gJyc7XG4gICAgICAgIHNhbml0aXplZEN1cnJlbnRXb3JkID0gJyc7XG4gICAgICAgIGN1cnJlbnRXb3JkU3RhcnRJbmRleCA9IGkgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0dWFsQ3VycmVudFdvcmQgKz0gY2hhcmFjdGVyO1xuICAgICAgICBzYW5pdGl6ZWRDdXJyZW50V29yZCArPSB0aGlzLl9zYW5pdGl6ZXIuc2FuaXRpemUoY2hhcmFjdGVyKTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbkRpY3Rpb25hcnlbc2FuaXRpemVkQ3VycmVudFdvcmRdICYmIHRva2VuRGljdGlvbmFyeVtzYW5pdGl6ZWRDdXJyZW50V29yZF0uaW5kZXhPZihzYW5pdGl6ZWRDdXJyZW50V29yZCkgPj0gMCkge1xuICAgICAgICBhY3R1YWxDdXJyZW50V29yZCA9IHRoaXMuX3dyYXBUZXh0KGFjdHVhbEN1cnJlbnRXb3JkKTtcbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIGN1cnJlbnRXb3JkU3RhcnRJbmRleCkgKyBhY3R1YWxDdXJyZW50V29yZCArIHRleHQuc3Vic3RyaW5nKGkgKyAxKTtcbiAgICAgICAgaSArPSB0YWdzTGVuZ3RoO1xuICAgICAgICB0ZXh0TGVuZ3RoICs9IHRhZ3NMZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gdGV4dCB0byB3cmFwXG4gICAqIEByZXR1cm5zIFRleHQgd3JhcHBlZCBieSB3cmFwcGVyIHRhZyAoZS5nLiBcImZvb1wiIGJlY29tZXMgXCI8bWFyaz5mb288L21hcms+XCIpXG4gICAqIEBwcml2YXRlXG4gICAqLztcbiAgX3Byb3RvLl93cmFwVGV4dCA9IGZ1bmN0aW9uIF93cmFwVGV4dCh0ZXh0KSB7XG4gICAgdmFyIHRhZ05hbWUgPSB0aGlzLl93cmFwcGVyVGFnTmFtZTtcbiAgICByZXR1cm4gXCI8XCIgKyB0YWdOYW1lICsgXCI+XCIgKyB0ZXh0ICsgXCI8L1wiICsgdGFnTmFtZSArIFwiPlwiO1xuICB9O1xuICByZXR1cm4gVG9rZW5IaWdobGlnaHRlcjtcbn0oKTtcbmV4cG9ydCB7IEFsbFN1YnN0cmluZ3NJbmRleFN0cmF0ZWd5LCBDYXNlU2Vuc2l0aXZlU2FuaXRpemVyLCBFeGFjdFdvcmRJbmRleFN0cmF0ZWd5LCBMb3dlckNhc2VTYW5pdGl6ZXIsIFByZWZpeEluZGV4U3RyYXRlZ3ksIFNlYXJjaCwgU2ltcGxlVG9rZW5pemVyLCBTdGVtbWluZ1Rva2VuaXplciwgU3RvcFdvcmRzTWFwLCBTdG9wV29yZHNUb2tlbml6ZXIsIFRmSWRmU2VhcmNoSW5kZXgsIFRva2VuSGlnaGxpZ2h0ZXIsIFVub3JkZXJlZFNlYXJjaEluZGV4IH07IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIGhpZGVNZXNzYWdlID0gXCJNYXBTZWFyY2hNZXNzYWdlLW1vZHVsZS0taGlkZU1lc3NhZ2UtLTlMT1V1XCI7XG5leHBvcnQgdmFyIHNob3dNZXNzYWdlID0gXCJNYXBTZWFyY2hNZXNzYWdlLW1vZHVsZS0tc2hvd01lc3NhZ2UtLWVhdE11XCI7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7dXNlSW50bH0gZnJvbSAnZ2F0c2J5LXBsdWdpbi1pbnRsJztcblxuaW1wb3J0ICogYXMgRVhQTE9SRV9DT1BZIGZyb20gJy4uLy4uL2RhdGEvY29weS9leHBsb3JlJztcbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuL01hcFNlYXJjaE1lc3NhZ2UubW9kdWxlLnNjc3MnO1xuXG5pbnRlcmZhY2UgSVNlYXJjaE1lc3NhZ2Uge1xuICAgIGlzU2VhcmNoUmVzdWx0c051bGw6IGJvb2xlYW47XG59O1xuXG5jb25zdCBNYXBTZWFyY2hNZXNzYWdlID0gKHtpc1NlYXJjaFJlc3VsdHNOdWxsfTpJU2VhcmNoTWVzc2FnZSkgPT4ge1xuICBjb25zdCBpbnRsID0gdXNlSW50bCgpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2lzU2VhcmNoUmVzdWx0c051bGwgPyBzdHlsZXMuc2hvd01lc3NhZ2UgOiBzdHlsZXMuaGlkZU1lc3NhZ2V9PlxuICAgICAge2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuTUFQLlNFQVJDSF9SRVNVTFRTX0VNUFRZX01FU1NBR0UpfVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwU2VhcmNoTWVzc2FnZTtcbiIsImltcG9ydCBNYXBTZWFyY2hNZXNzYWdlIGZyb20gJy4vTWFwU2VhcmNoTWVzc2FnZSc7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcFNlYXJjaE1lc3NhZ2U7XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5pbXBvcnQgUmVhY3QsIHt1c2VFZmZlY3QsIHVzZVN0YXRlfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQge0xuZ0xhdEJvdW5kc0xpa2V9IGZyb20gJ21hcGxpYnJlLWdsJztcbmltcG9ydCB7dXNlSW50bH0gZnJvbSAnZ2F0c2J5LXBsdWdpbi1pbnRsJztcbmltcG9ydCB7U2VhcmNofSBmcm9tICdAdHJ1c3N3b3Jrcy9yZWFjdC11c3dkcyc7XG5pbXBvcnQge3VzZVdpbmRvd1NpemV9IGZyb20gJ3JlYWN0LXVzZSc7XG5pbXBvcnQgKiBhcyBKc1NlYXJjaCBmcm9tICdqcy1zZWFyY2gnO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4uLy4uL2RhdGEvY29uc3RhbnRzJztcblxuaW1wb3J0IE1hcFNlYXJjaE1lc3NhZ2UgZnJvbSAnLi4vTWFwU2VhcmNoTWVzc2FnZSc7XG5cbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuL01hcFNlYXJjaC5tb2R1bGUuc2Nzcyc7XG5pbXBvcnQgKiBhcyBFWFBMT1JFX0NPUFkgZnJvbSAnLi4vLi4vZGF0YS9jb3B5L2V4cGxvcmUnO1xuXG5pbnRlcmZhY2UgSU1hcFNlYXJjaCB7XG4gIGdvVG9QbGFjZShib3VuZHM6IExuZ0xhdEJvdW5kc0xpa2UsIGlzVGVycml0b3J5OiBib29sZWFuLCBzZWxlY3RUcmFjdElkOiBzdHJpbmcgfCB1bmRlZmluZWQpOnZvaWQ7XG59XG5cbmludGVyZmFjZSBJU2VhcmNoVHJhY3RSZWNvcmQge1xuICBHRU9JRDEwOiBzdHJpbmc7XG4gIElOVFBUTEFUMTA6IHN0cmluZztcbiAgSU5UUFRMT04xMDogc3RyaW5nO1xufVxuXG5jb25zdCBNYXBTZWFyY2ggPSAoe2dvVG9QbGFjZX06SU1hcFNlYXJjaCkgPT4ge1xuICAvLyBTdGF0ZSB0byBob2xkIGlmIHRoZSBzZWFyY2ggcmVzdWx0cyBhcmUgZW1wdHkgb3Igbm90OlxuICBjb25zdCBbaXNTZWFyY2hSZXN1bHRzTnVsbCwgc2V0SXNTZWFyY2hSZXN1bHRzTnVsbF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGludGwgPSB1c2VJbnRsKCk7XG5cbiAgLyoqXG4gICAqIEF0IGNvbXBpbGUtdGltZSwgdGhlIHdpZHRoL2hlaWdodCByZXR1cm5lZCBieSB1c2VXaW5kb3dTaXplIHdpbGwgYmUgWC4gV2hlbiB0aGUgY2xpZW50IHJlcXVlc3RzIHRoZVxuICAgKiBhcHAgb24gcnVuLXRpbWUgZnJvbSBDRE4sIGFuZCB0aGUgYXBwIGh5ZHJhdGVzLCByZWNvbmNpbGF0aW9uIG5vIGxvbmdlciBvY2N1cnMgYW5kIHRoZSBjbGllbnQgaXMgZm9yY2VkXG4gICAqIHRvIHVzZSBYLlxuICAgKlxuICAgKiBUbyBhdm9pZCB0aGlzLCB3ZSBzZXQgdGhlIHBsYWNlaG9sZGVyIHRleHQgYXMgYSBzdGF0ZSB2YXJpYWJsZS4gV2UgYWxzbyBjcmVhdGUgYSB1c2VFZmZlY3QgdGhhdCB1cGRhdGVzXG4gICAqIHRoYXQgc3RhdGUgd2hlbmVudmVyIHRoZSB3aWR0aCBjaGFuZ2VzLlxuICAgKlxuICAgKi9cbiAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdXNlV2luZG93U2l6ZSgpO1xuICBjb25zdCBbcGxhY2Vob2xkZXJUZXh0LCBzZXRQbGFjZWhvbGRlclRleHRdPSB1c2VTdGF0ZShFWFBMT1JFX0NPUFkuTUFQLlNFQVJDSF9QTEFDRUhPTERFUik7XG4gIGNvbnN0IFt0cmFjdFNlYXJjaCwgc2V0VHJhY3RTZWFyY2hdID0gdXNlU3RhdGU8SnNTZWFyY2guU2VhcmNoIHwgbnVsbD4obnVsbCk7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRyYWN0IHNlYXJjaCBkYXRhIGFuZCBsb2FkcyBpbiB0aGUgc3RhdGUuXG4gICAqL1xuICBjb25zdCBnZXRUcmFjdFNlYXJjaERhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qgc2VhcmNoRGF0YVVybCA9IGAke2NvbnN0YW50cy5USUxFX0JBU0VfVVJMfS8ke2NvbnN0YW50cy5NQVBfVFJBQ1RfU0VBUkNIX1BBVEh9YDtcbiAgICBmZXRjaChzZWFyY2hEYXRhVXJsKVxuICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZXNwb25zZS5zdGF0dXNUZXh0fSBlcnJvciB3aXRoIHN0YXR1cyBjb2RlIG9mICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAvLyBXZSB1c2UgSnNTZWFyY2ggdG8gbWFrZSBpdCBlYXN5IHRvIGxvYWQgYW5kIHF1aWNrIHRvIHNlYXJjaC5cbiAgICAgICAgICBjb25zdCBzZWFyY2ggPSBuZXcgSnNTZWFyY2guU2VhcmNoKCdHRU9JRDEwJyk7XG4gICAgICAgICAgc2VhcmNoLmluZGV4U3RyYXRlZ3kgPSBuZXcgSnNTZWFyY2guRXhhY3RXb3JkSW5kZXhTdHJhdGVneSgpO1xuICAgICAgICAgIHNlYXJjaC5hZGRJbmRleCgnR0VPSUQxMCcpO1xuICAgICAgICAgIHNlYXJjaC5hZGREb2N1bWVudHMoZGF0YSk7XG4gICAgICAgICAgc2V0VHJhY3RTZWFyY2goc2VhcmNoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnJvcikgPT5cbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmFibGUgdG8gcmVhZCBzZWFyY2ggdHJhY3QgdGFibGU6JywgZXJyb3IpKTtcbiAgfTtcblxuICB1c2VFZmZlY3QoICgpID0+IHtcbiAgIHdpZHRoID4gaGVpZ2h0ID8gc2V0UGxhY2Vob2xkZXJUZXh0KEVYUExPUkVfQ09QWS5NQVAuU0VBUkNIX1BMQUNFSE9MREVSKTogc2V0UGxhY2Vob2xkZXJUZXh0KEVYUExPUkVfQ09QWS5NQVAuU0VBUkNIX1BMQUNFSE9MREVSX01PQklMRSk7XG4gIH0sIFt3aWR0aF0pO1xuXG4gIHVzZUVmZmVjdCgoKT0+e1xuICAgIGdldFRyYWN0U2VhcmNoRGF0YSgpO1xuICB9LCBbXSk7XG5cbiAgLyoqXG4gICAqIFNlYXJjaHMgZm9yIGEgZ2l2ZW4gQ2Vuc3VzIHRyYWN0IElELlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhY3QgdGhlIDExIGRpZ2l0IHRyYWN0IElEIGFzIGEgc3RyaW5nXG4gICAqL1xuICBjb25zdCBzZWFyY2hGb3JUcmFjdCA9IGFzeW5jICh0cmFjdDogc3RyaW5nKSA9PiB7XG4gICAgLy8gV2UgY3JlYXRlIGEgYm91bmRpbmcgYm94IGp1c3QgdG8gZ2V0IHRoZSB0cmFjdCBpbiB0aGUgdmlldyBib3guXG4gICAgLy8gVGhlIHNpemUgaXMgbm90IGltcG9ydGFudC5cbiAgICBjb25zdCBCT1VORElOR19CT1hfU0laRV9ERCA9IDAuMjtcblxuICAgIC8vIENvbnZlcnQgMTAgZGlnaXQgdHJhY3RzIHRvIDExLlxuICAgIGNvbnN0IG5vcm1hbGl6ZWRUcmFjdElkID0gdHJhY3QubGVuZ3RoID09IDEwID8gJzAnICsgdHJhY3QgOiB0cmFjdDtcblxuICAgIHNldElzU2VhcmNoUmVzdWx0c051bGwodHJ1ZSk7XG5cbiAgICBpZiAodHJhY3RTZWFyY2gpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRyYWN0U2VhcmNoLnNlYXJjaChub3JtYWxpemVkVHJhY3RJZCk7XG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoVHJhY3RSZWNvcmQgPSByZXN1bHRbMF0gYXMgSVNlYXJjaFRyYWN0UmVjb3JkO1xuICAgICAgICBjb25zdCBsYXQgPSBOdW1iZXIoc2VhcmNoVHJhY3RSZWNvcmQuSU5UUFRMQVQxMCk7XG4gICAgICAgIGNvbnN0IGxvbiA9IE51bWJlcihzZWFyY2hUcmFjdFJlY29yZC5JTlRQVExPTjEwKTtcbiAgICAgICAgY29uc3QgYm91bmRpbmdCb3ggPSBbXG4gICAgICAgICAgKGxhdCAtIChCT1VORElOR19CT1hfU0laRV9ERCAvIDIpKS50b1N0cmluZygpLFxuICAgICAgICAgIChsYXQgKyAoQk9VTkRJTkdfQk9YX1NJWkVfREQgLyAyKSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAobG9uIC0gKEJPVU5ESU5HX0JPWF9TSVpFX0REIC8gMikpLnRvU3RyaW5nKCksXG4gICAgICAgICAgKGxvbiArIChCT1VORElOR19CT1hfU0laRV9ERCAvIDIpKS50b1N0cmluZygpLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBbbGF0TWluLCBsYXRNYXgsIGxvbmdNaW4sIGxvbmdNYXhdID0gYm91bmRpbmdCb3g7XG4gICAgICAgIHNldElzU2VhcmNoUmVzdWx0c051bGwoZmFsc2UpO1xuXG4gICAgICAgIC8vIE5vdyBtb3ZlIHRoZSBtYXAgYW5kIHNlbGVjdCB0aGUgdHJhY3QuXG4gICAgICAgIGdvVG9QbGFjZShbW051bWJlcihsb25nTWluKSwgTnVtYmVyKGxhdE1pbildLCBbTnVtYmVyKGxvbmdNYXgpLCBOdW1iZXIobGF0TWF4KV1dLCBmYWxzZSwgbm9ybWFsaXplZFRyYWN0SWQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2VhcmNocyBmb3IgYSBnaXZlbiBsb2NhdGlvbiBzdWNoIGFzIGFkZHJlc3MsIHppcCwgZXRjLiBUaGlzIG1ldGhvZCB3aWxsXG4gICAqIHdpbGwgZmV0Y2ggZGF0YSBmcm9tIHRoZSBQU00gQVBJIGFuZCByZXR1cm4gdGhlIHJlc3VsdHMgYXMgSlNPTiBhbmRcbiAgICogcmVzdWx0cyB0byBVUyBvbmx5LiBJZiB0aGUgZGF0YSBpcyB2YWxpZCwgZGVzdHJ1Y3R1cmUgdGhlIGJvdW5kaW5nQm94XG4gICAqIHZhbHVlcyBmcm9tIHRoZSBzZWFyY2ggcmVzdWx0cy4gRmluYWxseSwgaXMgcGFucyB0aGUgbWFwIHRvIHRoZSBsb2NhdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFRlcm0gdGhlIGxvY2F0aW9uIHRvIHNlYXJjaCBmb3JcbiAgICovXG4gIGNvbnN0IHNlYXJjaEZvckxvY2F0aW9uID0gYXN5bmMgKHNlYXJjaFRlcm06IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHNlYXJjaFJlc3VsdHMgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYGh0dHBzOi8vbm9taW5hdGltLm9wZW5zdHJlZXRtYXAub3JnL3NlYXJjaD9xPSR7c2VhcmNoVGVybX0mZm9ybWF0PWpzb24mY291bnRyeWNvZGVzPXVzYCxcbiAgICAgICAge1xuICAgICAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIHJlc3BvbnNlIHdhcyBub3QgT0snKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZXJlIGhhcyBiZWVuIGEgcHJvYmxlbSB3aXRoIHlvdXIgZmV0Y2ggb3BlcmF0aW9uOicsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgY29uc29sZS5sb2coJ05vbWluYXR1bSBzZWFyY2ggcmVzdWx0czogJywgc2VhcmNoUmVzdWx0cyk7XG5cbiAgICAvLyBJZiByZXN1bHRzIGFyZSB2YWxpZCwgc2V0IGlzU2VhcmNoUmVzdWx0c051bGwgdG8gZmFsc2UgYW5kIHBhbiBtYXAgdG8gbG9jYXRpb246XG4gICAgaWYgKHNlYXJjaFJlc3VsdHMgJiYgc2VhcmNoUmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICBzZXRJc1NlYXJjaFJlc3VsdHNOdWxsKGZhbHNlKTtcbiAgICAgIGNvbnN0IFtsYXRNaW4sIGxhdE1heCwgbG9uZ01pbiwgbG9uZ01heF0gPSBzZWFyY2hSZXN1bHRzWzBdLmJvdW5kaW5nYm94O1xuICAgICAgZ29Ub1BsYWNlKFtbTnVtYmVyKGxvbmdNaW4pLCBOdW1iZXIobGF0TWluKV0sIFtOdW1iZXIobG9uZ01heCksIE51bWJlcihsYXRNYXgpXV0sIGZhbHNlLCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRJc1NlYXJjaFJlc3VsdHNOdWxsKHRydWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICBTZWFyY2hlcyBmb3IgYSBnaXZlbiBzZWFyY2ggdGVybSB1cG9uIGNsaWNraW5nIG9uIHRoZSBzZWFyY2ggYnV0dG9uLlxuICAgIEBwYXJhbSB7UmVhY3QuRm9ybUV2ZW50PEhUTUxGb3JtRWxlbWVudD59IGV2ZW50IHRoZSBjbGljayBldmVudFxuICAqL1xuICBjb25zdCBvblNlYXJjaEhhbmRsZXIgPSBhc3luYyAoZXZlbnQ6IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGNvbnN0IHNlYXJjaFRlcm0gPSAoZXZlbnQuY3VycmVudFRhcmdldC5lbGVtZW50cy5uYW1lZEl0ZW0oJ3NlYXJjaCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlO1xuXG4gICAgLy8gSWYgdGhlIHNlYXJjaCB0ZXJtIGEgQ2Vuc3VzIHRyYWN0XG4gICAgY29uc3QgaXNUcmFjdCA9IC9eXFxkezEwLDExfSQvLnRlc3Qoc2VhcmNoVGVybSk7XG4gICAgaWYgKGlzVHJhY3QpIHtcbiAgICAgIHNlYXJjaEZvclRyYWN0KHNlYXJjaFRlcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWFyY2hGb3JMb2NhdGlvbihzZWFyY2hUZXJtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLm1hcFNlYXJjaENvbnRhaW5lcn0+XG4gICAgICA8TWFwU2VhcmNoTWVzc2FnZSBpc1NlYXJjaFJlc3VsdHNOdWxsPXtpc1NlYXJjaFJlc3VsdHNOdWxsfSAvPlxuICAgICAgPFNlYXJjaFxuICAgICAgICBwbGFjZWhvbGRlcj17aW50bC5mb3JtYXRNZXNzYWdlKHBsYWNlaG9sZGVyVGV4dCl9XG4gICAgICAgIHNpemU9XCJzbWFsbFwiXG4gICAgICAgIG9uU3VibWl0PXsoZSkgPT4gb25TZWFyY2hIYW5kbGVyKGUpfVxuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1hcFNlYXJjaDtcbiIsImltcG9ydCBNYXBTZWFyY2ggZnJvbSAnLi9NYXBTZWFyY2gnO1xuXG5leHBvcnQgZGVmYXVsdCBNYXBTZWFyY2g7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtTb3VyY2UsIExheWVyfSBmcm9tICdyZWFjdC1tYXAtZ2wnO1xuaW1wb3J0IHtNYXBHZW9KU09ORmVhdHVyZX0gZnJvbSAnbWFwbGlicmUtZ2wnO1xuXG4vLyBDb250ZXh0czpcbmltcG9ydCB7dXNlRmxhZ3N9IGZyb20gJy4uLy4uL2NvbnRleHRzL0ZsYWdDb250ZXh0JztcblxuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4uLy4uL2RhdGEvY29uc3RhbnRzJztcbmltcG9ydCAqIGFzIENPTU1PTl9DT1BZIGZyb20gJy4uLy4uL2RhdGEvY29weS9jb21tb24nO1xuXG5pbnRlcmZhY2UgSU1hcFRyYWN0TGF5ZXJzIHtcbiAgICBzZWxlY3RlZEZlYXR1cmVzOiBNYXBHZW9KU09ORmVhdHVyZVtdIHwgdW5kZWZpbmVkLFxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBkZXRlcm1pbmUgdGhlIFVSTCBmb3IgdGhlIG1hcCB0aWxlcy4gSXQgd2lsbCByZWFkIGluIGEgc3RyaW5nIHRoYXQgd2lsbCBkZXNpZ25hdGUgZWl0aGVyXG4gKiBoaWdoIG9yIGxvdyB0aWxlcy4gSXQgd2lsbCBhbGxvdyB0byBvdmVyaWRlIHRoZSBVUkwgdG8gdGhlIHBpcGVsaW5lIHN0YWdpbmcgdGlsZSBVUkwgdmlhIGZlYXR1cmUgZmxhZy5cbiAqIExhc3RseSwgaXQgYWxsb3dzIHRvIHNldCB0aGUgdGlsZXMgdG8gYmUgbG9jYWwgb3IgdmlhIHRoZSBDRE4gYXMgd2VsbC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGlsZXNldE5hbWVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IGZlYXR1cmVVUkxGb3JUaWxlc2V0TmFtZSA9ICh0aWxlc2V0TmFtZTogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgY29uc3QgZmxhZ3MgPSB1c2VGbGFncygpO1xuXG4gIGNvbnN0IHBpcGVsaW5lU3RhZ2luZ0Jhc2VVUkwgPSBwcm9jZXNzLmVudi5HQVRTQllfQ0ROX1RJTEVTX0JBU0VfVVJMICtgL2RhdGEtcGlwZWxpbmUtc3RhZ2luZ2A7XG4gIGNvbnN0IFhZWl9TVUZGSVggPSAne3p9L3t4fS97eX0ucGJmJztcblxuICBpZiAoJ3N0YWdlX2hhc2gnIGluIGZsYWdzKSB7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHN0YWdlX2hhc2ggaXMgdmFsaWRcbiAgICBjb25zdCByZWdleCA9IC9eWzAtOV17NH1cXC9bYS1mMC05XXs0MH0kLztcbiAgICBpZiAoIXJlZ2V4LnRlc3QoZmxhZ3NbJ3N0YWdlX2hhc2gnXSkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoQ09NTU9OX0NPUFkuQ09OU09MRV9FUlJPUi5TVEFHRV9VUkwpO1xuICAgIH1cblxuICAgIHJldHVybiBgJHtwaXBlbGluZVN0YWdpbmdCYXNlVVJMfS8ke2ZsYWdzWydzdGFnZV9oYXNoJ119L2RhdGEvc2NvcmUvdGlsZXMvJHt0aWxlc2V0TmFtZX0vJHtYWVpfU1VGRklYfWA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIGZlYXR1cmUgdGlsZSBiYXNlIFVSTCBhbmQgcGF0aCBjYW4gZWl0aGVyIHBvaW50IGxvY2FsbHkgb3IgdGhlIENETi5cbiAgICAvLyBUaGlzIGlzIHNlbGVjdGVkIGJhc2VkIG9uIHRoZSBEQVRBX1NPVVJDRSBlbnYgdmFyaWFibGUuXG4gICAgY29uc3QgZmVhdHVyZVRpbGVCYXNlVVJMID0gY29uc3RhbnRzLlRJTEVfQkFTRV9VUkw7XG4gICAgY29uc3QgZmVhdHVyZVRpbGVQYXRoID0gY29uc3RhbnRzLlRJTEVfUEFUSDtcblxuICAgIHJldHVybiBbXG4gICAgICBmZWF0dXJlVGlsZUJhc2VVUkwsXG4gICAgICBmZWF0dXJlVGlsZVBhdGgsXG4gICAgICBwcm9jZXNzLmVudi5HQVRTQllfTUFQX1RJTEVTX1BBVEgsXG4gICAgICB0aWxlc2V0TmFtZSxcbiAgICAgIFhZWl9TVUZGSVgsXG4gICAgXS5qb2luKCcvJyk7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgd2lsbCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHNvdXJjZSBhbmQgbGF5ZXJzIGZvciB0aGUgY2Vuc3VzIGxheWVyIG9uIHRoZVxuICogbWFwLlxuICpcbiAqIFRoZXJlIGFyZSB0d28gdXNlIGNhc2VzIGhlcmUsIGVnLCB3aGVuIHRoZSBNYXBCb3ggdG9rZW4gaXMgb3IgaXNuJ3QgcHJvdmlkZWQuIFdoZW4gdGhlIHRva2VuXG4gKiBpcyBub3QgcHJvdmlkZWQsIHRoZSBvcGVuLXNvdXJjZSBtYXAgd2lsbCBiZSByZW5kZXJlZC4gV2hlbiB0aGUgb3Blbi1zb3VyY2UgbWFwIGlzIHJlbmRlcmVkXG4gKiBvbmx5IHRoZSBpbnRlcmFjdGl2ZSBsYXllcnMgYXJlIHJldHVybmVkIGZyb20gdGhpcyBjb21wb25lbnQuIFRoZSByZWFzb24gYmVpbmcgaXMgdGhhdCB0aGVcbiAqIG90aGVyIGxheWVycyBhcmUgc3VwcGxpZWQgYnkgaGUgZ2V0T1NCYXNlTWFwIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBzZWxlY3RlZEZlYXR1cmVJZFxuICogQHBhcmFtIHtNYXBHZW9KU09ORmVhdHVyZSB8IHVuZGVmaW5lZH0gc2VsZWN0ZWRGZWF0dXJlXG4gKiBAcmV0dXJuIHtTdHlsZX1cbiAqL1xuY29uc3QgTWFwVHJhY3RMYXllcnMgPSAoe1xuICBzZWxlY3RlZEZlYXR1cmVzLFxufTogSU1hcFRyYWN0TGF5ZXJzKSA9PiB7XG4gIGNvbnN0IHNlbGVjdGVkRmVhdHVyZUlkcyA9IHNlbGVjdGVkRmVhdHVyZXMgPyAoc2VsZWN0ZWRGZWF0dXJlcy5tYXAoKGZlYXQpID0+IGZlYXQuaWQpKSA6IFsnJ107XG4gIGNvbnN0IGZpbHRlciA9IFsnaW4nLCBjb25zdGFudHMuR0VPSURfUFJPUEVSVFksIC4uLnNlbGVjdGVkRmVhdHVyZUlkc107XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPFNvdXJjZVxuICAgICAgICBpZD17Y29uc3RhbnRzLkxPV19aT09NX1NPVVJDRV9OQU1FfVxuICAgICAgICB0eXBlPVwidmVjdG9yXCJcbiAgICAgICAgcHJvbW90ZUlkPXtjb25zdGFudHMuR0VPSURfUFJPUEVSVFl9XG4gICAgICAgIHRpbGVzPXtbZmVhdHVyZVVSTEZvclRpbGVzZXROYW1lKCdsb3cnKV19XG4gICAgICAgIG1heHpvb209e2NvbnN0YW50cy5HTE9CQUxfTUFYX1pPT01fTE9XfVxuICAgICAgICBtaW56b29tPXtjb25zdGFudHMuR0xPQkFMX01JTl9aT09NX0xPV31cbiAgICAgID5cblxuICAgICAgICB7LyogTG93IHpvb20gbGF5ZXIgKHN0YXRpYykgLSBwcmlvcml0aXplZCBmZWF0dXJlcyBvbmx5ICovfVxuICAgICAgICA8TGF5ZXJcbiAgICAgICAgICBpZD17Y29uc3RhbnRzLkxPV19aT09NX0xBWUVSX0lEfVxuICAgICAgICAgIHNvdXJjZS1sYXllcj17Y29uc3RhbnRzLlNDT1JFX1NPVVJDRV9MQVlFUn1cbiAgICAgICAgICBmaWx0ZXI9e1snPicsIGNvbnN0YW50cy5TQ09SRV9QUk9QRVJUWV9MT1csIGNvbnN0YW50cy5TQ09SRV9CT1VOREFSWV9USFJFU0hPTERdfVxuICAgICAgICAgIHR5cGU9J2ZpbGwnXG4gICAgICAgICAgcGFpbnQ9e3tcbiAgICAgICAgICAgICdmaWxsLWNvbG9yJzogY29uc3RhbnRzLlBSSU9SSVRJWkVEX0ZFQVRVUkVfRklMTF9DT0xPUixcbiAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiBjb25zdGFudHMuTE9XX1pPT01fUFJJT1JJVElaRURfRkVBVFVSRV9GSUxMX09QQUNJVFl9fVxuICAgICAgICAgIG1heHpvb209e2NvbnN0YW50cy5HTE9CQUxfTUFYX1pPT01fTE9XfVxuICAgICAgICAgIG1pbnpvb209e2NvbnN0YW50cy5HTE9CQUxfTUlOX1pPT01fTE9XfVxuICAgICAgICAvPlxuICAgICAgPC9Tb3VyY2U+XG5cbiAgICAgIHsvKiBUaGUgaGlnaCB6b29tIHNvdXJjZSAqL31cbiAgICAgIDxTb3VyY2VcbiAgICAgICAgaWQ9e2NvbnN0YW50cy5ISUdIX1pPT01fU09VUkNFX05BTUV9XG4gICAgICAgIHR5cGU9XCJ2ZWN0b3JcIlxuICAgICAgICBwcm9tb3RlSWQ9e2NvbnN0YW50cy5HRU9JRF9QUk9QRVJUWX1cbiAgICAgICAgdGlsZXM9e1tmZWF0dXJlVVJMRm9yVGlsZXNldE5hbWUoJ2hpZ2gnKV19XG4gICAgICAgIG1heHpvb209e2NvbnN0YW50cy5HTE9CQUxfTUFYX1pPT01fSElHSH1cbiAgICAgICAgbWluem9vbT17Y29uc3RhbnRzLkdMT0JBTF9NSU5fWk9PTV9ISUdIfVxuICAgICAgPlxuXG4gICAgICAgIHsvKiBIaWdoIHpvb20gbGF5ZXIgKHN0YXRpYykgLSBub24tcHJpb3JpdGl6ZWQgZmVhdHVyZXMgb25seSAqL31cbiAgICAgICAgPExheWVyXG4gICAgICAgICAgaWQ9e2NvbnN0YW50cy5ISUdIX1pPT01fTEFZRVJfSUR9XG4gICAgICAgICAgc291cmNlLWxheWVyPXtjb25zdGFudHMuU0NPUkVfU09VUkNFX0xBWUVSfVxuICAgICAgICAgIGZpbHRlcj17Wyc9PScsIGNvbnN0YW50cy5TQ09SRV9QUk9QRVJUWV9ISUdILCBmYWxzZV19XG4gICAgICAgICAgdHlwZT0nZmlsbCdcbiAgICAgICAgICBwYWludD17e1xuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IGNvbnN0YW50cy5OT05fUFJJT1JJVElaRURfRkVBVFVSRV9GSUxMX09QQUNJVFksXG4gICAgICAgICAgfX1cbiAgICAgICAgICBtaW56b29tPXtjb25zdGFudHMuR0xPQkFMX01JTl9aT09NX0hJR0h9XG4gICAgICAgIC8+XG5cbiAgICAgICAgey8qIEhpZ2ggem9vbSBsYXllciAoc3RhdGljKSAtIHByaW9yaXRpemVkIGZlYXR1cmVzIG9ubHkgKi99XG4gICAgICAgIDxMYXllclxuICAgICAgICAgIGlkPXtjb25zdGFudHMuUFJJT1JJVElaRURfSElHSF9aT09NX0xBWUVSX0lEfVxuICAgICAgICAgIHNvdXJjZS1sYXllcj17Y29uc3RhbnRzLlNDT1JFX1NPVVJDRV9MQVlFUn1cbiAgICAgICAgICBmaWx0ZXI9e1snPT0nLCBjb25zdGFudHMuU0NPUkVfUFJPUEVSVFlfSElHSCwgdHJ1ZV19XG4gICAgICAgICAgdHlwZT0nZmlsbCdcbiAgICAgICAgICBwYWludD17e1xuICAgICAgICAgICAgJ2ZpbGwtY29sb3InOiBjb25zdGFudHMuUFJJT1JJVElaRURfRkVBVFVSRV9GSUxMX0NPTE9SLFxuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IGNvbnN0YW50cy5ISUdIX1pPT01fUFJJT1JJVElaRURfRkVBVFVSRV9GSUxMX09QQUNJVFksXG4gICAgICAgICAgfX1cbiAgICAgICAgICBtaW56b29tPXtjb25zdGFudHMuR0xPQkFMX01JTl9aT09NX0hJR0h9XG4gICAgICAgIC8+XG5cbiAgICAgICAgey8qIEhpZ2ggem9vbSBsYXllciAoc3RhdGljKSAtIGdyYW5kZmF0aGVyZWQgZmVhdHVyZXMgb25seSAqL31cbiAgICAgICAgPExheWVyXG4gICAgICAgICAgaWQ9e2NvbnN0YW50cy5HUkFOREZBVEhFUkVEX0hJR0hfWk9PTV9MQVlFUl9JRH1cbiAgICAgICAgICBzb3VyY2UtbGF5ZXI9e2NvbnN0YW50cy5TQ09SRV9TT1VSQ0VfTEFZRVJ9XG4gICAgICAgICAgZmlsdGVyPXtbJz09JywgY29uc3RhbnRzLklTX0dSQU5ERkFUSEVSRUQsIHRydWVdfVxuICAgICAgICAgIHR5cGU9J2ZpbGwnXG4gICAgICAgICAgcGFpbnQ9e3tcbiAgICAgICAgICAgICdmaWxsLWNvbG9yJzogY29uc3RhbnRzLkdSQU5ERkFUSEVSRURfRkVBVFVSRV9GSUxMX0NPTE9SLFxuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IGNvbnN0YW50cy5ISUdIX1pPT01fUFJJT1JJVElaRURfRkVBVFVSRV9GSUxMX09QQUNJVFksXG4gICAgICAgICAgfX1cbiAgICAgICAgICBtaW56b29tPXtjb25zdGFudHMuR0xPQkFMX01JTl9aT09NX0hJR0h9XG4gICAgICAgIC8+XG5cbiAgICAgICAgey8qIEhpZ2ggem9vbSBsYXllciAoc3RhdGljKSAtIGNvbnRyb2xzIHRoZSBib3JkZXIgYmV0d2VlbiBmZWF0dXJlcyAqL31cbiAgICAgICAgPExheWVyXG4gICAgICAgICAgaWQ9e2NvbnN0YW50cy5GRUFUVVJFX0JPUkRFUl9MQVlFUl9JRH1cbiAgICAgICAgICBzb3VyY2UtbGF5ZXI9e2NvbnN0YW50cy5TQ09SRV9TT1VSQ0VfTEFZRVJ9XG4gICAgICAgICAgdHlwZT0nbGluZSdcbiAgICAgICAgICBwYWludD17e1xuICAgICAgICAgICAgJ2xpbmUtY29sb3InOiBjb25zdGFudHMuRkVBVFVSRV9CT1JERVJfQ09MT1IsXG4gICAgICAgICAgICAnbGluZS13aWR0aCc6IGNvbnN0YW50cy5GRUFUVVJFX0JPUkRFUl9XSURUSCxcbiAgICAgICAgICAgICdsaW5lLW9wYWNpdHknOiBjb25zdGFudHMuRkVBVFVSRV9CT1JERVJfT1BBQ0lUWSxcbiAgICAgICAgICB9fVxuICAgICAgICAgIG1heHpvb209e2NvbnN0YW50cy5HTE9CQUxfTUFYX1pPT01fRkVBVFVSRV9CT1JERVJ9XG4gICAgICAgICAgbWluem9vbT17Y29uc3RhbnRzLkdMT0JBTF9NSU5fWk9PTV9GRUFUVVJFX0JPUkRFUn1cbiAgICAgICAgLz5cblxuICAgICAgICB7LyogSGlnaCB6b29tIGxheWVyIChkeW5hbWljKSAtIGJvcmRlciBzdHlsaW5nIGFyb3VuZCB0aGUgc2VsZWN0ZWQgZmVhdHVyZSAqL31cbiAgICAgICAgPExheWVyXG4gICAgICAgICAgaWQ9e2NvbnN0YW50cy5TRUxFQ1RFRF9GRUFUVVJFX0JPUkRFUl9MQVlFUl9JRH1cbiAgICAgICAgICBzb3VyY2UtbGF5ZXI9e2NvbnN0YW50cy5TQ09SRV9TT1VSQ0VfTEFZRVJ9XG4gICAgICAgICAgZmlsdGVyPXtmaWx0ZXJ9IC8vIFRoaXMgZmlsdGVyIGZpbHRlcnMgb3V0IGFsbCBvdGhlciBmZWF0dXJlcyBleGNlcHQgdGhlIHNlbGVjdGVkIGZlYXR1cmUuXG4gICAgICAgICAgdHlwZT0nbGluZSdcbiAgICAgICAgICBwYWludD17e1xuICAgICAgICAgICAgJ2xpbmUtY29sb3InOiBjb25zdGFudHMuU0VMRUNURURfRkVBVFVSRV9CT1JERVJfQ09MT1IsXG4gICAgICAgICAgICAnbGluZS13aWR0aCc6IGNvbnN0YW50cy5TRUxFQ1RFRF9GRUFUVVJFX0JPUkRFUl9XSURUSCxcbiAgICAgICAgICB9fVxuICAgICAgICAgIG1pbnpvb209e2NvbnN0YW50cy5HTE9CQUxfTUlOX1pPT01fSElHSH1cbiAgICAgICAgLz5cbiAgICAgIDwvU291cmNlPlxuICAgIDwvPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwVHJhY3RMYXllcnM7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtTb3VyY2UsIExheWVyfSBmcm9tICdyZWFjdC1tYXAtZ2wnO1xuXG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vLi4vZGF0YS9jb25zdGFudHMnO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBkZXRlcm1pbmUgdGhlIFVSTCBmb3IgdGhlIHRyaWJhbCB0aWxlcy5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHRyaWJhbFVSTCA9ICgpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBmZWF0dXJlVGlsZUJhc2VVUkwgPSBjb25zdGFudHMuVElMRV9CQVNFX1VSTDtcbiAgY29uc3QgZmVhdHVyZVRpbGVQYXRoID0gY29uc3RhbnRzLkdBVFNCWV9EQVRBX1BJUEVMSU5FX1RSSUJBTF9QQVRIO1xuICBjb25zdCBYWVpfU1VGRklYID0gJ3t6fS97eH0ve3l9LnBiZic7XG5cbiAgcmV0dXJuIFtcbiAgICBmZWF0dXJlVGlsZUJhc2VVUkwsXG4gICAgZmVhdHVyZVRpbGVQYXRoLFxuICAgIHByb2Nlc3MuZW52LkdBVFNCWV9NQVBfVElMRVNfUEFUSCxcbiAgICBYWVpfU1VGRklYLFxuICBdLmpvaW4oJy8nKTtcbn07XG5cblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCB3aWxsIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgc291cmNlIGFuZCBsYXllcnMgZm9yIHRoZSB0cmliYWwgbGF5ZXIgb24gdGhlXG4gKiBtYXAuXG4gKlxuICogVGhlcmUgYXJlIHR3byB1c2UgY2FzZXMgaGVyZSwgZWcsIHdoZW4gdGhlIE1hcEJveCB0b2tlbiBpcyBvciBpc24ndCBwcm92aWRlZC4gV2hlbiB0aGUgdG9rZW5cbiAqIGlzIG5vdCBwcm92aWRlZCwgdGhlIG9wZW4tc291cmNlIG1hcCB3aWxsIGJlIHJlbmRlcmVkLiBXaGVuIHRoZSBvcGVuLXNvdXJjZSBtYXAgaXMgcmVuZGVyZWRcbiAqIG9ubHkgdGhlIGludGVyYWN0aXZlIGxheWVycyBhcmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNvbXBvbmVudC4gVGhlIHJlYXNvbiBiZWluZyBpcyB0aGF0IHRoZVxuICogb3RoZXIgbGF5ZXJzIGFyZSBzdXBwbGllZCBieSBoZSBnZXRPU0Jhc2VNYXAgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IHNlbGVjdGVkRmVhdHVyZUlkXG4gKiBAcGFyYW0ge01hcEdlb0pTT05GZWF0dXJlIHwgdW5kZWZpbmVkfSBzZWxlY3RlZEZlYXR1cmVcbiAqIEByZXR1cm4ge1N0eWxlfVxuICovXG5jb25zdCBNYXBUcmliYWxMYXllciA9ICgpID0+IHtcbiAgcmV0dXJuIChcblxuICAgIC8vIEluIHRoaXMgY2FzZSB0aGUgTWFwQm94IHRva2VuIGlzIGZvdW5kIGFuZCBBTEwgc291cmNlKHMpL2xheWVyKHMpIGFyZSByZXR1cm5lZC5cbiAgICA8U291cmNlXG4gICAgICBpZD17Y29uc3RhbnRzLlRSSUJBTF9TT1VSQ0VfTkFNRX1cbiAgICAgIHR5cGU9XCJ2ZWN0b3JcIlxuICAgICAgcHJvbW90ZUlkPXtjb25zdGFudHMuVFJJQkFMX0lEfVxuICAgICAgdGlsZXM9e1t0cmliYWxVUkwoKV19XG4gICAgPlxuXG4gICAgICB7LyogVHJpYmFsIGxheWVyICovfVxuICAgICAgPExheWVyXG4gICAgICAgIGlkPXtjb25zdGFudHMuVFJJQkFMX0xBWUVSX0lEfVxuICAgICAgICBzb3VyY2UtbGF5ZXI9e2NvbnN0YW50cy5UUklCQUxfU09VUkNFX0xBWUVSfVxuICAgICAgICB0eXBlPSdmaWxsJ1xuICAgICAgICBwYWludD17e1xuICAgICAgICAgICdmaWxsLWNvbG9yJzogY29uc3RhbnRzLlBSSU9SSVRJWkVEX0ZFQVRVUkVfRklMTF9DT0xPUixcbiAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogY29uc3RhbnRzLlRSSUJBTF9GRUFUVVJFX0ZJTExfT1BBQ0lUWX19XG4gICAgICAgIG1pbnpvb209e2NvbnN0YW50cy5UUklCQUxfTUlOX1pPT019XG4gICAgICAgIG1heHpvb209e2NvbnN0YW50cy5UUklCQUxfTUFYX1pPT019XG4gICAgICAvPlxuXG4gICAgICB7LyogVHJpYmFsIGxheWVyIC0gY29udHJvbHMgdGhlIGJvcmRlciBiZXR3ZWVuIGZlYXR1cmVzICovfVxuICAgICAgPExheWVyXG4gICAgICAgIGlkPXtjb25zdGFudHMuRkVBVFVSRV9CT1JERVJfTEFZRVJfSUR9XG4gICAgICAgIHNvdXJjZS1sYXllcj17Y29uc3RhbnRzLlRSSUJBTF9TT1VSQ0VfTEFZRVJ9XG4gICAgICAgIHR5cGU9J2xpbmUnXG4gICAgICAgIHBhaW50PXt7XG4gICAgICAgICAgJ2xpbmUtY29sb3InOiBjb25zdGFudHMuRkVBVFVSRV9CT1JERVJfQ09MT1IsXG4gICAgICAgICAgJ2xpbmUtd2lkdGgnOiBjb25zdGFudHMuRkVBVFVSRV9CT1JERVJfV0lEVEgsXG4gICAgICAgICAgJ2xpbmUtb3BhY2l0eSc6IGNvbnN0YW50cy5GRUFUVVJFX0JPUkRFUl9PUEFDSVRZLFxuICAgICAgICB9fVxuICAgICAgICBtaW56b29tPXtjb25zdGFudHMuVFJJQkFMX01JTl9aT09NfVxuICAgICAgICBtYXh6b29tPXtjb25zdGFudHMuVFJJQkFMX01BWF9aT09NfVxuICAgICAgLz5cblxuICAgICAgey8qIEFsYXNrYSBsYXllciAqL31cbiAgICAgIDxMYXllclxuICAgICAgICBpZD17Y29uc3RhbnRzLlRSSUJBTF9BTEFTS0FfUE9JTlRTX0xBWUVSX0lEfVxuICAgICAgICBzb3VyY2UtbGF5ZXI9e2NvbnN0YW50cy5UUklCQUxfU09VUkNFX0xBWUVSfVxuICAgICAgICBmaWx0ZXI9e1snPT0nLCBbJ2dlb21ldHJ5LXR5cGUnXSwgJ1BvaW50J119XG4gICAgICAgIHR5cGU9J2NpcmNsZSdcbiAgICAgICAgcGFpbnQ9e3tcbiAgICAgICAgICAnY2lyY2xlLXJhZGl1cyc6IGNvbnN0YW50cy5UUklCQUxfQUxBU0tBX0NJUkNMRV9SQURJVVMsXG4gICAgICAgICAgJ2NpcmNsZS1jb2xvcic6IGNvbnN0YW50cy5UUklCQUxfQUxBU0tBX0NJUkNMRV9GSUxMX0NPTE9SLFxuICAgICAgICAgICdjaXJjbGUtb3BhY2l0eSc6IGNvbnN0YW50cy5UUklCQUxfRkVBVFVSRV9GSUxMX09QQUNJVFksXG4gICAgICAgICAgJ2NpcmNsZS1zdHJva2UtY29sb3InOiBjb25zdGFudHMuVFJJQkFMX0JPUkRFUl9DT0xPUixcbiAgICAgICAgICAnY2lyY2xlLXN0cm9rZS13aWR0aCc6IGNvbnN0YW50cy5BTEFLU0FfUE9JTlRTX1NUUk9LRV9XSURUSCxcbiAgICAgICAgICAnY2lyY2xlLXN0cm9rZS1vcGFjaXR5JzogY29uc3RhbnRzLkZFQVRVUkVfQk9SREVSX09QQUNJVFksXG4gICAgICAgIH19XG4gICAgICAgIG1pbnpvb209e2NvbnN0YW50cy5BTEFTS0FfTUlOX1pPT019XG4gICAgICAgIG1heHpvb209e2NvbnN0YW50cy5BTEFTS0FfTUFYX1pPT019XG4gICAgICAvPlxuXG4gICAgICB7LyogVHJpYmFsIGxhYmVscyBsYXllciAqL31cbiAgICAgIDxMYXllclxuICAgICAgICBpZD17Y29uc3RhbnRzLlRSSUJBTF9MQUJFTFNfTEFZRVJfSUR9XG4gICAgICAgIHNvdXJjZS1sYXllcj17Y29uc3RhbnRzLlRSSUJBTF9TT1VSQ0VfTEFZRVJ9XG4gICAgICAgIHR5cGU9J3N5bWJvbCdcbiAgICAgICAgbGF5b3V0PXt7XG4gICAgICAgICAgJ3RleHQtZmllbGQnOiBbXG4gICAgICAgICAgICAnY2FzZScsXG4gICAgICAgICAgICBbJ2luJywgJyBMQVInLCBbJ2dldCcsIGNvbnN0YW50cy5MQU5EX0FSRUFfTkFNRV1dLFxuICAgICAgICAgICAgWydzbGljZScsIFsnZ2V0JywgY29uc3RhbnRzLkxBTkRfQVJFQV9OQU1FXSwgMCwgWyctJywgWydsZW5ndGgnLCBbJ2dldCcsIGNvbnN0YW50cy5MQU5EX0FSRUFfTkFNRV1dLCA0XV0sXG4gICAgICAgICAgICBbJ2luJywgJyBJUkEnLCBbJ2dldCcsIGNvbnN0YW50cy5MQU5EX0FSRUFfTkFNRV1dLFxuICAgICAgICAgICAgWydzbGljZScsIFsnZ2V0JywgY29uc3RhbnRzLkxBTkRfQVJFQV9OQU1FXSwgMCwgWyctJywgWydsZW5ndGgnLCBbJ2dldCcsIGNvbnN0YW50cy5MQU5EX0FSRUFfTkFNRV1dLCA0XV0sXG4gICAgICAgICAgICBbJ2luJywgJyBUU0EnLCBbJ2dldCcsIGNvbnN0YW50cy5MQU5EX0FSRUFfTkFNRV1dLFxuICAgICAgICAgICAgWydzbGljZScsIFsnZ2V0JywgY29uc3RhbnRzLkxBTkRfQVJFQV9OQU1FXSwgMCwgWyctJywgWydsZW5ndGgnLCBbJ2dldCcsIGNvbnN0YW50cy5MQU5EX0FSRUFfTkFNRV1dLCA0XV0sXG4gICAgICAgICAgICBbJ2dldCcsIGNvbnN0YW50cy5MQU5EX0FSRUFfTkFNRV0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICAndGV4dC1hbmNob3InOiAndG9wJyxcbiAgICAgICAgICAndGV4dC1vZmZzZXQnOiBbMCwgMV0sXG4gICAgICAgICAgJ3RleHQtc2l6ZSc6IDEyLFxuICAgICAgICAgICd0ZXh0LWFsbG93LW92ZXJsYXAnOiBmYWxzZSxcbiAgICAgICAgICAndGV4dC1pZ25vcmUtcGxhY2VtZW50JzogZmFsc2UsXG4gICAgICAgIH19XG4gICAgICAgIHBhaW50PXt7XG4gICAgICAgICAgJ3RleHQtY29sb3InOiAnIzMzMzMzMycsXG4gICAgICAgICAgJ3RleHQtaGFsby1jb2xvcic6ICcjRkZGRkZGJyxcbiAgICAgICAgICAndGV4dC1oYWxvLXdpZHRoJzogMS41LFxuICAgICAgICB9fVxuICAgICAgICBtaW56b29tPXtjb25zdGFudHMuVFJJQkFMX01JTl9aT09NfVxuICAgICAgICBtYXh6b29tPXtjb25zdGFudHMuVFJJQkFMX01BWF9aT09NfVxuICAgICAgLz5cbiAgICA8L1NvdXJjZT5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1hcFRyaWJhbExheWVyO1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIHRlcnJpdG9yeUZvY3VzQ29udGFpbmVyID0gXCJ0ZXJyaXRvcnlGb2N1c0NvbnRyb2wtbW9kdWxlLS10ZXJyaXRvcnlGb2N1c0NvbnRhaW5lci0tWDVBMTRcIjsiLCJpbXBvcnQge3VzZUludGx9IGZyb20gJ2dhdHNieS1wbHVnaW4taW50bCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtNYXBFdmVudH0gZnJvbSAncmVhY3QtbWFwLWdsJztcblxuaW1wb3J0ICogYXMgc3R5bGVzIGZyb20gJy4vdGVycml0b3J5Rm9jdXNDb250cm9sLm1vZHVsZS5zY3NzJztcbmltcG9ydCAqIGFzIEVYUExPUkVfQ09QWSBmcm9tICcuLi9kYXRhL2NvcHkvZXhwbG9yZSc7XG5cbmludGVyZmFjZSBJVGVycml0b3J5Rm9jdXNDb250cm9sIHtcbiAgb25DbGljayhldmVudDogTWFwRXZlbnQgfCBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxCdXR0b25FbGVtZW50Pik6dm9pZDtcbn1cblxuXG5jb25zdCBUZXJyaXRvcnlGb2N1c0NvbnRyb2wgPSAoe29uQ2xpY2t9OiBJVGVycml0b3J5Rm9jdXNDb250cm9sKSA9PiB7XG4gIGNvbnN0IGludGwgPSB1c2VJbnRsKCk7XG5cbiAgY29uc3QgdGVycml0b3JpZXMgPSBbXG4gICAge1xuICAgICAgc2hvcnQ6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuTUFQLkxPV0VSNDhfU0hPUlQpLFxuICAgICAgbG9uZzogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5NQVAuTE9XRVI0OF9MT05HKSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHNob3J0OiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLk1BUC5BTEFTS0FfU0hPUlQpLFxuICAgICAgbG9uZzogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5NQVAuQUxBU0tBX0xPTkcpLFxuICAgIH0sXG4gICAge1xuICAgICAgc2hvcnQ6IGludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuTUFQLkhBV0FJSV9TSE9SVCksXG4gICAgICBsb25nOiBpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLk1BUC5IQVdBSUlfTE9ORyksXG4gICAgfSxcbiAgICB7XG4gICAgICBzaG9ydDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5NQVAuUFJfU0hPUlQpLFxuICAgICAgbG9uZzogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5NQVAuUFJfTE9ORyksXG4gICAgfSxcbiAgICB7XG4gICAgICBzaG9ydDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5NQVAuR1VfU0hPUlQpLFxuICAgICAgbG9uZzogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5NQVAuR1VfTE9ORyksXG4gICAgfSxcbiAgICB7XG4gICAgICBzaG9ydDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5NQVAuQVNfU0hPUlQpLFxuICAgICAgbG9uZzogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5NQVAuQVNfTE9ORyksXG4gICAgfSxcbiAgICB7XG4gICAgICBzaG9ydDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5NQVAuTVBfU0hPUlQpLFxuICAgICAgbG9uZzogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5NQVAuTVBfTE9ORyksXG4gICAgfSxcbiAgICB7XG4gICAgICBzaG9ydDogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5NQVAuVklfU0hPUlQpLFxuICAgICAgbG9uZzogaW50bC5mb3JtYXRNZXNzYWdlKEVYUExPUkVfQ09QWS5NQVAuVklfTE9ORyksXG4gICAgfSxcbiAgXTtcbiAgLy8gdGhlIG9mZnNldCBmb3IgdGhpcyBhcnJheSBzaG91bGQgbWFwIHRoZSB0ZXJyaXRvcmllcyB2YXJpYWJsZVxuICBjb25zdCB0ZXJyaXRvcmllc0ljb25DbGFzc05hbWUgPSBbXG4gICAgJ21hcGJveGdsLWN0cmwtem9vbS10by00OCcsXG4gICAgJ21hcGJveGdsLWN0cmwtem9vbS10by1haycsXG4gICAgJ21hcGJveGdsLWN0cmwtem9vbS10by1oaScsXG4gICAgJ21hcGJveGdsLWN0cmwtem9vbS10by1wcicsXG4gICAgJ21hcGJveGdsLWN0cmwtem9vbS10by1ndScsXG4gICAgJ21hcGJveGdsLWN0cmwtem9vbS10by1hcycsXG4gICAgJ21hcGJveGdsLWN0cmwtem9vbS10by1tcCcsXG4gICAgJ21hcGJveGdsLWN0cmwtem9vbS10by12aScsXG4gIF07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnRlcnJpdG9yeUZvY3VzQ29udGFpbmVyfT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXsnbWFwYm94Z2wtY3RybCBtYXBib3hnbC1jdHJsLWdyb3VwJ30+XG4gICAgICAgIHt0ZXJyaXRvcmllcy5tYXAoKHRlcnJpdG9yeSwgaW5kZXgpID0+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgaWQ9e3RlcnJpdG9yeS5zaG9ydH1cbiAgICAgICAgICAgIGtleT17dGVycml0b3J5LnNob3J0fVxuICAgICAgICAgICAgLy8gb25DbGlja0NhcHR1cmU9eyhlKSA9PiBvbkNsaWNrVGVycml0b3J5Rm9jdXNCdXR0b24oZSl9XG4gICAgICAgICAgICBvbkNsaWNrQ2FwdHVyZT17KGUpID0+IG9uQ2xpY2soZSl9XG4gICAgICAgICAgICBjbGFzc05hbWU9eydtYXBib3hnbC1jdHJsLWljb24gJyArIHRlcnJpdG9yaWVzSWNvbkNsYXNzTmFtZVtpbmRleF19XG4gICAgICAgICAgICB0aXRsZT17dGVycml0b3JpZXNbaW5kZXhdLmxvbmd9XG4gICAgICAgICAgICBhcmlhLWxhYmVsPXtpbnRsLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWQ6ICdtYXAudGVycml0b3J5Rm9jdXMuZm9jdXNPbicsXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0TWVzc2FnZTogJ0ZvY3VzIG9uIHt0ZXJyaXRvcnl9JyxcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRm9jdXMgb24gdGhlIGJvdW5kcyBvZiBhIHNwZWNpZmljIHRlcnJpdG9yeScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0ZXJyaXRvcnk6IHRlcnJpdG9yeS5sb25nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICApfT5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17J21hcGJveGdsLWN0cmwtaWNvbid9IGFyaWEtaGlkZGVuPXt0cnVlfS8+XG4gICAgICAgICAgPC9idXR0b24+LFxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBUZXJyaXRvcnlGb2N1c0NvbnRyb2w7XG5cbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHZhciBmdWxsc2NyZWVuQ29udHJvbCA9IFwiSjQwTWFwLW1vZHVsZS0tZnVsbHNjcmVlbkNvbnRyb2wtLWdiWU8wXCI7XG5leHBvcnQgdmFyIGdlb2xvY2F0ZUJveCA9IFwiSjQwTWFwLW1vZHVsZS0tZ2VvbG9jYXRlQm94LS01SG5TRVwiO1xuZXhwb3J0IHZhciBnZW9sb2NhdGVNZXNzYWdlID0gXCJKNDBNYXAtbW9kdWxlLS1nZW9sb2NhdGVNZXNzYWdlLS1qRDFHUFwiO1xuZXhwb3J0IHZhciBnZW9sb2NhdGVNZXNzYWdlSGlkZSA9IFwiSjQwTWFwLW1vZHVsZS0tZ2VvbG9jYXRlTWVzc2FnZUhpZGUtLU1VOEJ6XCI7XG5leHBvcnQgdmFyIGo0ME1hcCA9IFwiSjQwTWFwLW1vZHVsZS0tajQwTWFwLS1ERnI2RVwiO1xuZXhwb3J0IHZhciBqNDBQb3B1cCA9IFwiSjQwTWFwLW1vZHVsZS0tajQwUG9wdXAtLUtMcFhMXCI7XG5leHBvcnQgdmFyIG1hcEhlYWRlclJvdyA9IFwiSjQwTWFwLW1vZHVsZS0tbWFwSGVhZGVyUm93LS0rY3RPLVwiO1xuZXhwb3J0IHZhciBtYXBJbmZvUGFuZWwgPSBcIko0ME1hcC1tb2R1bGUtLW1hcEluZm9QYW5lbC0tV2RJOWVcIjtcbmV4cG9ydCB2YXIgbmF2aWdhdGlvbkNvbnRyb2wgPSBcIko0ME1hcC1tb2R1bGUtLW5hdmlnYXRpb25Db250cm9sLS02dVVNN1wiOyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHZhciBjcmVhdGVSZXBvcnRCdXR0b24gPSBcIkNyZWF0ZVJlcG9ydFBhbmVsLW1vZHVsZS0tY3JlYXRlUmVwb3J0QnV0dG9uLS0rVXNkc1wiO1xuZXhwb3J0IHZhciBjcmVhdGVSZXBvcnRDb250YWluZXIgPSBcIkNyZWF0ZVJlcG9ydFBhbmVsLW1vZHVsZS0tY3JlYXRlUmVwb3J0Q29udGFpbmVyLS15Rmo5elwiO1xuZXhwb3J0IHZhciBzdGFydE92ZXIgPSBcIkNyZWF0ZVJlcG9ydFBhbmVsLW1vZHVsZS0tc3RhcnRPdmVyLS05c1p1U1wiO1xuZXhwb3J0IHZhciB0cmFjdExpc3RDb250YWluZXIgPSBcIkNyZWF0ZVJlcG9ydFBhbmVsLW1vZHVsZS0tdHJhY3RMaXN0Q29udGFpbmVyLS1vMm5lclwiO1xuZXhwb3J0IHZhciB0cmFjdExpc3RJdGVtID0gXCJDcmVhdGVSZXBvcnRQYW5lbC1tb2R1bGUtLXRyYWN0TGlzdEl0ZW0tLUpNQ2I0XCI7XG5leHBvcnQgdmFyIHRyYWN0TGlzdEl0ZW1EZWxldGUgPSBcIkNyZWF0ZVJlcG9ydFBhbmVsLW1vZHVsZS0tdHJhY3RMaXN0SXRlbURlbGV0ZS0tQlM4OFdcIjtcbmV4cG9ydCB2YXIgdHJhY3RMaXN0SXRlbUhpZ2hsaWdodCA9IFwiQ3JlYXRlUmVwb3J0UGFuZWwtbW9kdWxlLS10cmFjdExpc3RJdGVtSGlnaGxpZ2h0LS1ueFhseVwiOyIsImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUdobGFXZG9kRDBpTWpRaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSWdkMmxrZEdnOUlqSTBJajQ4Y0dGMGFDQmtQU0pOTUNBd2FESTBkakkwU0RCNklpQm1hV3hzUFNKdWIyNWxJaTgrUEhCaGRHZ2daRDBpVFRFNUlEWXVOREZNTVRjdU5Ua2dOU0F4TWlBeE1DNDFPU0EyTGpReElEVWdOU0EyTGpReElERXdMalU1SURFeUlEVWdNVGN1TlRrZ05pNDBNU0F4T1NBeE1pQXhNeTQwTVNBeE55NDFPU0F4T1NBeE9TQXhOeTQxT1NBeE15NDBNU0F4TW5vaUx6NDhMM04yWno0PVwiIiwiaW1wb3J0IFJlYWN0LCB7dXNlRWZmZWN0LCB1c2VTdGF0ZX0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtNYXBHZW9KU09ORmVhdHVyZX0gZnJvbSAnbWFwbGlicmUtZ2wnO1xuaW1wb3J0IHtCdXR0b24sIEFsZXJ0LCBHcmlkfSBmcm9tICdAdHJ1c3N3b3Jrcy9yZWFjdC11c3dkcyc7XG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi9DcmVhdGVSZXBvcnRQYW5lbC5tb2R1bGUuc2Nzcyc7XG5cbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi8uLi9kYXRhL2NvbnN0YW50cyc7XG5cbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBkZWxldGVJY29uIGZyb20gJy9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL2Nsb3NlLnN2Zyc7XG5cbmludGVyZmFjZSBJQ3JlYXRlUmVwb3J0UGFuZWwge1xuICBkZWxldGVUcmFjdEhhbmRsZXI6IChmZWF0dXJlOiBNYXBHZW9KU09ORmVhdHVyZSkgPT4gdm9pZCxcbiAgY2xhc3NOYW1lOiBzdHJpbmcsXG4gIGV4aXRIYW5kbGVyOiAoKSA9PiB2b2lkLFxuICBmZWF0dXJlTGlzdDogTWFwR2VvSlNPTkZlYXR1cmVbXSxcbiAgbWF4TnVtVHJhY3RzOiBudW1iZXIsXG4gIHNob3dUb29NYW55VHJhY3RzQWxlcnQ6IGJvb2xlYW4sXG59XG5cbmNvbnN0IENyZWF0ZVJlcG9ydFBhbmVsID0gKHtcbiAgY2xhc3NOYW1lLFxuICBmZWF0dXJlTGlzdCxcbiAgbWF4TnVtVHJhY3RzLFxuICBzaG93VG9vTWFueVRyYWN0c0FsZXJ0LFxuICBkZWxldGVUcmFjdEhhbmRsZXIsXG4gIGV4aXRIYW5kbGVyLFxufTogSUNyZWF0ZVJlcG9ydFBhbmVsLFxuKSA9PiB7XG4gIGNvbnN0IFtudW1QcmV2VHJhY3RzLCBzZXROdW1QcmV2VHJhY3RzXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBJZiBhZGRpbmcgYSB0cmFjdCB0aGVuIHNjcm9sbCB0byB0aGUgYm90dG9tIG9mIHRoZSB0cmFjdCBsaXN0IHRvIGFsd2F5cyBzaG93IHRoZSBsYXN0IGFkZGVkIHRyYWN0XG4gICAgaWYgKG51bVByZXZUcmFjdHMgPCBmZWF0dXJlTGlzdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdqNDAtY3JlYXRlLXJlcG9ydC10cmFjdC1saXN0Jyk7XG4gICAgICBpZiAoY29udGFpbmVyKSBjb250YWluZXIuc2Nyb2xsVG9wID0gY29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgICB9XG4gICAgc2V0TnVtUHJldlRyYWN0cyhmZWF0dXJlTGlzdC5sZW5ndGgpO1xuICB9LCBbZmVhdHVyZUxpc3QsIG51bVByZXZUcmFjdHNdKTtcblxuICAvKipcbiAgICogSGFuZGxlIHRoZSBjcmVhdGlvbiBvZiBhIHJlcG9ydC5cbiAgICovXG4gIGNvbnN0IGhhbmRsZUNyZWF0ZVJlcG9ydCA9ICgpID0+IHtcbiAgICBpZiAoZmVhdHVyZUxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBUT0RPOiBPbmUgdHJhY3QgcmVwb3J0XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IE11bHRpIHRyYWN0IHJlcG9ydFxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgaWQ9J2NyZWF0ZS1yZXBvcnQtcGFuZWwnIGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY3JlYXRlUmVwb3J0Q29udGFpbmVyfT5cbiAgICAgICAgPGg0PkNyZWF0ZSBSZXBvcnQ8L2g0PlxuICAgICAgICB7c2hvd1Rvb01hbnlUcmFjdHNBbGVydCA/XG4gICAgICAgICAgPEFsZXJ0IHR5cGU9J2Vycm9yJyBzbGltIGhlYWRpbmdMZXZlbD0naDQnPlxuICAgICAgICAgICAgWW91IGNhbiBvbmx5IHNlbGVjdCB1cCB0byB7bWF4TnVtVHJhY3RzfSB0cmFjdHMgZm9yIGEgcmVwb3J0LlxuICAgICAgICAgIDwvQWxlcnQ+IDpcbiAgICAgICAgICA8QWxlcnQgdHlwZT0naW5mbycgc2xpbSBoZWFkaW5nTGV2ZWw9J2g0Jz5cbiAgICAgICAgICAgIFNlbGVjdCA8c3Ryb25nPnVwIHRvIHttYXhOdW1UcmFjdHN9PC9zdHJvbmc+IHRyYWN0cyBpbiB0aGUgbWFwXG4gICAgICAgICAgPC9BbGVydD5cbiAgICAgICAgfVxuICAgICAgICA8cD5cbiAgICAgICAgICA8c3Bhbj48c3Ryb25nPntmZWF0dXJlTGlzdC5sZW5ndGh9IHRyYWN0e2ZlYXR1cmVMaXN0Lmxlbmd0aCA9PT0gMSA/ICcnIDogJ3MnfTwvc3Ryb25nPiBzZWxlY3RlZDwvc3Bhbj5cbiAgICAgICAgPC9wPlxuICAgICAgICA8ZGl2IGlkPSdqNDAtY3JlYXRlLXJlcG9ydC10cmFjdC1saXN0JyBjbGFzc05hbWU9e3N0eWxlcy50cmFjdExpc3RDb250YWluZXJ9PlxuICAgICAgICAgIHtmZWF0dXJlTGlzdC5tYXAoKGl0ZW0sIGluZGV4KSA9PiAoXG4gICAgICAgICAgICA8R3JpZCByb3cga2V5PXtpbmRleH1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtpbmRleCA9PT0gZmVhdHVyZUxpc3QubGVuZ3RoIC0gMSA/IHN0eWxlcy50cmFjdExpc3RJdGVtSGlnaGxpZ2h0IDogc3R5bGVzLnRyYWN0TGlzdEl0ZW19PlxuICAgICAgICAgICAgICA8R3JpZCBjb2w9XCJhdXRvXCI+XG4gICAgICAgICAgICAgICAge2l0ZW0uaWR9LCB7aXRlbS5wcm9wZXJ0aWVzW2NvbnN0YW50cy5TVEFURV9OQU1FXX08L0dyaWQ+XG4gICAgICAgICAgICAgIDxHcmlkIGNvbD1cImZpbGxcIiAvPlxuICAgICAgICAgICAgICA8R3JpZCBjb2w9XCJhdXRvXCIgY2xhc3NOYW1lPXtzdHlsZXMudHJhY3RMaXN0SXRlbURlbGV0ZX0+XG4gICAgICAgICAgICAgICAgPEJ1dHRvbiB0eXBlPSdidXR0b24nIHVuc3R5bGVkXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBkZWxldGVUcmFjdEhhbmRsZXIoaXRlbSl9PlxuICAgICAgICAgICAgICAgICAgPGltZyB0YWJJbmRleD17MH0gc3JjPXtkZWxldGVJY29ufVxuICAgICAgICAgICAgICAgICAgICBhbHQ9J05lZWQgYWx0IG1lc3NhZ2UnXG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICA8L0dyaWQ+XG4gICAgICAgICAgICA8L0dyaWQ+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNyZWF0ZVJlcG9ydEJ1dHRvbn0gPlxuICAgICAgICAgIDxCdXR0b24gdHlwZT0nYnV0dG9uJyBvbkNsaWNrPXtoYW5kbGVDcmVhdGVSZXBvcnR9XG4gICAgICAgICAgICBkaXNhYmxlZD17ZmVhdHVyZUxpc3QubGVuZ3RoID09IDB9PkNyZWF0ZSBSZXBvcnQ8L0J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuc3RhcnRPdmVyfT5cbiAgICAgICAgICA8QnV0dG9uIHR5cGU9J2J1dHRvbicgdW5zdHlsZWQgb25DbGljaz17ZXhpdEhhbmRsZXJ9PlN0YXJ0IE92ZXI8L0J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENyZWF0ZVJlcG9ydFBhbmVsO1xuIiwiaW1wb3J0IENyZWF0ZVJlcG9ydFBhbmVsIGZyb20gJy4vQ3JlYXRlUmVwb3J0UGFuZWwnO1xuXG5leHBvcnQgZGVmYXVsdCBDcmVhdGVSZXBvcnRQYW5lbDtcbiIsIi8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLy8gRXh0ZXJuYWwgTGliczpcbmltcG9ydCBSZWFjdCwge3VzZVJlZiwgdXNlU3RhdGV9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7TWFwLCBNYXBHZW9KU09ORmVhdHVyZSwgTG5nTGF0Qm91bmRzTGlrZX0gZnJvbSAnbWFwbGlicmUtZ2wnO1xuaW1wb3J0IFJlYWN0TWFwR0wsIHtcbiAgTWFwRXZlbnQsXG4gIFZpZXdwb3J0UHJvcHMsXG4gIFdlYk1lcmNhdG9yVmlld3BvcnQsXG4gIE5hdmlnYXRpb25Db250cm9sLFxuICBHZW9sb2NhdGVDb250cm9sLFxuICBQb3B1cCxcbiAgRmx5VG9JbnRlcnBvbGF0b3IsXG4gIEZ1bGxzY3JlZW5Db250cm9sLFxuICBNYXBSZWYsXG59IGZyb20gJ3JlYWN0LW1hcC1nbCc7XG5pbXBvcnQge3VzZUludGx9IGZyb20gJ2dhdHNieS1wbHVnaW4taW50bCc7XG5pbXBvcnQgYmJveCBmcm9tICdAdHVyZi9iYm94JztcbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzLWVhc2UnO1xuaW1wb3J0IHtpc01vYmlsZX0gZnJvbSAncmVhY3QtZGV2aWNlLWRldGVjdCc7XG5pbXBvcnQge0dyaWR9IGZyb20gJ0B0cnVzc3dvcmtzL3JlYWN0LXVzd2RzJztcbmltcG9ydCB7dXNlV2luZG93U2l6ZSwgdXNlTG9jYWxTdG9yYWdlfSBmcm9tICdyZWFjdC11c2UnO1xuXG4vLyBDb250ZXh0czpcbmltcG9ydCB7dXNlRmxhZ3N9IGZyb20gJy4uL2NvbnRleHRzL0ZsYWdDb250ZXh0JztcblxuLy8gQ29tcG9uZW50czpcbmltcG9ydCBBcmVhRGV0YWlsIGZyb20gJy4vQXJlYURldGFpbCc7XG5pbXBvcnQgTWFwSW5mb1BhbmVsIGZyb20gJy4vbWFwSW5mb1BhbmVsJztcbmltcG9ydCBNYXBTZWFyY2ggZnJvbSAnLi9NYXBTZWFyY2gnO1xuaW1wb3J0IE1hcFRyYWN0TGF5ZXJzIGZyb20gJy4vTWFwVHJhY3RMYXllcnMvTWFwVHJhY3RMYXllcnMnO1xuaW1wb3J0IE1hcFRyaWJhbExheWVyIGZyb20gJy4vTWFwVHJpYmFsTGF5ZXJzL01hcFRyaWJhbExheWVycyc7XG5pbXBvcnQgVGVycml0b3J5Rm9jdXNDb250cm9sIGZyb20gJy4vdGVycml0b3J5Rm9jdXNDb250cm9sJztcblxuLy8gU3R5bGVzIGFuZCBjb25zdGFudHNcbmltcG9ydCAnbWFwbGlicmUtZ2wvZGlzdC9tYXBsaWJyZS1nbC5jc3MnO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4uL2RhdGEvY29uc3RhbnRzJztcbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuL0o0ME1hcC5tb2R1bGUuc2Nzcyc7XG5pbXBvcnQgKiBhcyBFWFBMT1JFX0NPUFkgZnJvbSAnLi4vZGF0YS9jb3B5L2V4cGxvcmUnO1xuaW1wb3J0IENyZWF0ZVJlcG9ydFBhbmVsIGZyb20gJy4vQ3JlYXRlUmVwb3J0UGFuZWwnO1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIEN5cHJlc3M/OiBvYmplY3Q7XG4gICAgdW5kZXJseWluZ01hcDogTWFwO1xuICB9XG59XG5cbmludGVyZmFjZSBJSjQwSW50ZXJmYWNlIHtcbiAgbG9jYXRpb246IExvY2F0aW9uO1xufTtcblxuXG5leHBvcnQgaW50ZXJmYWNlIElEZXRhaWxWaWV3SW50ZXJmYWNlIHtcbiAgbGF0aXR1ZGU6IG51bWJlclxuICBsb25naXR1ZGU6IG51bWJlclxuICB6b29tOiBudW1iZXJcbiAgcHJvcGVydGllczogY29uc3RhbnRzLko0MFByb3BlcnRpZXMsXG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIElNYXBGZWF0dXJlIHtcbiAgaWQ6IHN0cmluZztcbiAgZ2VvbWV0cnk6IGFueTtcbiAgcHJvcGVydGllczogYW55O1xuICB0eXBlOiBzdHJpbmc7XG59XG5cbmNvbnN0IE1BWF9TRUxFQ1RFRF9UUkFDVFMgPSAyMDtcblxuY29uc3QgSjQwTWFwID0gKHtsb2NhdGlvbn06IElKNDBJbnRlcmZhY2UpID0+IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSB6b29tLCBhbmQgdGhlIG1hcCdzIGNlbnRlciBwb2ludCAobGF0LCBsbmcpIHZpYSB0aGUgVVJMIGhhc2ggI3t6fS97bGF0fS97bG9uZ31cbiAgICogd2hlcmVcbiAgICogIEBUT0RPOiBUaGVzZSB2YWx1ZXMgZG8gbm90IHVwZGF0ZSB3aGVuIHpvb21pbmcgaW4vb3V0LiBDb3VsZCBleHBsYWluIGEgbnVtYmVyIG9mIGN5cHJlc3MgYnVnc1xuICAgKiAgcmVmZXJlbmNlIHRvIHRpY2tldCAjMTU1MFxuICAgKlxuICAgKiAgICB6ID0gem9vbVxuICAgKiAgICBsYXQgPSBtYXAgY2VudGVyJ3MgbGF0aXR1ZGVcbiAgICogICAgbG9uZyA9IG1hcCBjZW50ZXIncyBsb25naXR1ZGVcbiAgICovXG4gIGNvbnN0IFt6b29tLCBsYXQsIGxuZ10gPSBsb2NhdGlvbi5oYXNoLnNsaWNlKDEpLnNwbGl0KCcvJyk7XG5cbiAgLyoqXG4gICAqIElmIHRoZSBVUkwgaGFzIG5vICN7en0ve2xhdH0ve2xvbmd9IHNwZWNpZmllZCBpbiB0aGUgaGFzaCwgdGhlbiBzZXQgdGhlIG1hcCdzIGludGlhbCB2aWV3cG9ydCBzdGF0ZVxuICAgKiB0byB1c2UgY29uc3RhbnRzLiBUaGlzIGlzIHNvIHRoYXQgd2UgY2FuIGxvYWQgVVJMcyB3aXRoIGNlcnRhaW4gem9vbS9sYXQvbG9uZyBzcGVjaWZpZWQ6XG4gICAqL1xuICBjb25zdCBbdmlld3BvcnQsIHNldFZpZXdwb3J0XSA9IHVzZVN0YXRlPFZpZXdwb3J0UHJvcHM+KHtcbiAgICBsYXRpdHVkZTogbGF0ICYmIHBhcnNlRmxvYXQobGF0KSA/IHBhcnNlRmxvYXQobGF0KSA6IGNvbnN0YW50cy5ERUZBVUxUX0NFTlRFUlswXSxcbiAgICBsb25naXR1ZGU6IGxuZyAmJiBwYXJzZUZsb2F0KGxuZykgPyBwYXJzZUZsb2F0KGxuZykgOiBjb25zdGFudHMuREVGQVVMVF9DRU5URVJbMV0sXG4gICAgem9vbTogem9vbSAmJiBwYXJzZUZsb2F0KHpvb20pID8gcGFyc2VGbG9hdCh6b29tKSA6IGNvbnN0YW50cy5HTE9CQUxfTUlOX1pPT00sXG4gIH0pO1xuXG4gIGNvbnN0IFtzZWxlY3RlZEZlYXR1cmVzLCBzZXRTZWxlY3RlZEZlYXR1cmVzXSA9IHVzZVN0YXRlPE1hcEdlb0pTT05GZWF0dXJlW10+KFtdKTtcbiAgY29uc3QgW2RldGFpbFZpZXdEYXRhLCBzZXREZXRhaWxWaWV3RGF0YV0gPSB1c2VTdGF0ZTxJRGV0YWlsVmlld0ludGVyZmFjZT4oKTtcbiAgY29uc3QgW3RyYW5zaXRpb25JblByb2dyZXNzLCBzZXRUcmFuc2l0aW9uSW5Qcm9ncmVzc10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtnZW9sb2NhdGlvbkluUHJvZ3Jlc3MsIHNldEdlb2xvY2F0aW9uSW5Qcm9ncmVzc10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtpc01vYmlsZU1hcFN0YXRlLCBzZXRJc01vYmlsZU1hcFN0YXRlXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW2luTXVsdGlTZWxlY3RNb2RlLCBzZXRJbk11bHRpU2VsZWN0TW9kZV0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtzaG93VG9vTWFueVRyYWN0c0FsZXJ0LCBzZXRTaG93VG9vTWFueVRyYWN0c0FsZXJ0XSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW3NlbGVjdFRyYWN0SWQsIHNldFNlbGVjdFRyYWN0SWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuICBjb25zdCB7d2lkdGg6IHdpbmRvd1dpZHRofSA9IHVzZVdpbmRvd1NpemUoKTtcblxuICAvKipcbiAgICogU3RvcmUgdGhlIGdlb2xvY2F0aW9uIGxvY2sgc3RhdGUgaW4gbG9jYWwgc3RvcmFnZS4gVGhlIEdlb2xvY2F0aW9uIGNvbXBvbmVudCBmcm9tIE1hcEJveCBkb2VzIG5vdFxuICAgKiBleHBvc2UgKEFQSSkgdmFyaW91cyBnZW9sb2NhdGlvbiBsb2NrL3VubG9jayBzdGF0ZXMgaW4gdGhlIHZlcnNpb24gd2UgYXJlIHVzaW5nLiBUaGlzIG1ha2VzIGl0XG4gICAqIGNoYWxsZW5naW5nIHRvIGNoYW5nZSB0aGUgVUkgc3RhdGUgdG8gbWF0Y2ggdGhlIEdlb2xvY2F0aW9uIHN0YXRlLiBBIHdvcmsgYXJvdW5kIGlzIHRvIHN0b3JlIHRoZVxuICAgKiBnZW9sb2NhdGlvbiBcImxvY2tlZFwiIHN0YXRlIGluIGxvY2FsIHN0b3JhZ2UuIFRoZSBsb2NhbCBzdG9yYWdlIHN0YXRlIHdpbGwgdGhlbiBiZSB1c2VkIHRvIHNob3cgdGhlXG4gICAqIFwiRmluZGluZyBsb2NhdGlvblwiIG1lc3NhZ2UuIFRoZSBsb2NhbCBzdG9yYWdlIHdpbGwgYmUgcmVtb3ZlZCBldmVyeXRpbWUgdGhlIG1hcCBpcyByZWxvYWRlZC5cbiAgICpcbiAgICogVGhlIFwiRmluZGluZyBsb2NhdGlvblwiIG1lc3NhZ2Ugb25seSBhcHBsaWVzIGZvciBkZXNrdG9wIGxheW91dHMuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBjb25zdCBbaXNHZW9sb2NhdGVMb2NrZWQsIHNldElzR2VvbG9jYXRlTG9ja2VkLCByZW1vdmVHZW9sb2NhdGVMb2NrXSA9IHVzZUxvY2FsU3RvcmFnZSgnaXMtZ2VvbG9jYXRlLWxvY2tlZCcsIGZhbHNlLCB7cmF3OiB0cnVlfSk7XG5cbiAgY29uc3QgbWFwUmVmID0gdXNlUmVmPE1hcFJlZj4obnVsbCk7XG4gIGNvbnN0IGZsYWdzID0gdXNlRmxhZ3MoKTtcbiAgY29uc3QgaW50bCA9IHVzZUludGwoKTtcblxuICBjb25zdCB6b29tTGF0TG5nSGFzaCA9IG1hcFJlZi5jdXJyZW50Py5nZXRNYXAoKS5faGFzaC5fZ2V0Q3VycmVudEhhc2goKTtcblxuICAvKipcbiAgICogR2V0IHRoZSBib3VuZGluZyBib3ggZm9yIG9uZSBvciBtb3JlIGZlYXR1cmVzLlxuICAgKiBAcGFyYW0gZmVhdHVyZUxpc3QgdGhlIGxpc3Qgb2YgZmVhdHVyZXNcbiAgICogQHJldHVybnMgdGhlIGJvdW5kaW5nIGJveFxuICAgKi9cbiAgY29uc3QgZ2V0RmVhdHVyZXNCYm94ID0gKGZlYXR1cmVMaXN0OiBNYXBHZW9KU09ORmVhdHVyZVtdKTogbnVtYmVyW10gPT4ge1xuICAgIGlmIChmZWF0dXJlTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmVhdHVyZUxpc3QgbXVzdCBiZSBhIG5vbi1lbXB0eSBhcnJheSB0byBnZXQgYSBib3VuZGluZyBib3guJyk7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGEgbWF4IGFuZCBtaW4gbGF0L2xvbiBmcm9tIGFsbCB0aGUgc2VsZWN0ZWQgZmVhdHVyZXMuXG4gICAgY29uc3QgbWluTG5nTGlzdDogbnVtYmVyW10gPSBbXTtcbiAgICBjb25zdCBtaW5MYXRMaXN0OiBudW1iZXJbXSA9IFtdO1xuICAgIGNvbnN0IG1heExuZ0xpc3Q6IG51bWJlcltdID0gW107XG4gICAgY29uc3QgbWF4TGF0TGlzdDogbnVtYmVyW10gPSBbXTtcbiAgICBmZWF0dXJlTGlzdC5mb3JFYWNoKChmZWF0dXJlKSA9PiB7XG4gICAgICBjb25zdCBbZmVhdE1pbkxuZywgZmVhdE1pbkxhdCwgZmVhdE1heExuZywgZmVhdE1heExhdF0gPSBiYm94KGZlYXR1cmUpO1xuICAgICAgbWluTG5nTGlzdC5wdXNoKGZlYXRNaW5MbmcpO1xuICAgICAgbWluTGF0TGlzdC5wdXNoKGZlYXRNaW5MYXQpO1xuICAgICAgbWF4TG5nTGlzdC5wdXNoKGZlYXRNYXhMbmcpO1xuICAgICAgbWF4TGF0TGlzdC5wdXNoKGZlYXRNYXhMYXQpO1xuICAgIH0pO1xuICAgIGNvbnN0IG1pbkxuZzogbnVtYmVyID0gTWF0aC5taW4oLi4ubWluTG5nTGlzdCk7XG4gICAgY29uc3QgbWluTGF0OiBudW1iZXIgPSBNYXRoLm1heCguLi5taW5MYXRMaXN0KTtcbiAgICBjb25zdCBtYXhMbmc6IG51bWJlciA9IE1hdGgubWF4KC4uLm1heExuZ0xpc3QpO1xuICAgIGNvbnN0IG1heExhdDogbnVtYmVyID0gTWF0aC5taW4oLi4ubWF4TGF0TGlzdCk7XG4gICAgcmV0dXJuIFttaW5MbmcsIG1pbkxhdCwgbWF4TG5nLCBtYXhMYXRdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzdGF0ZSB3aXRoIHRoZSBsaXN0IG9mIHNlbGVjdGVkIGZlYXR1cmVzLiBUaGlzIGZ1bmN0aW9uIHdpbGw6XG4gICAqICAgLSBBZGQgdGhlIGZlYXR1cmUgdG8gdGhlIGxpc3QgaWYgaW4gbXVsdGkgc2VsZWN0IGFuZCB0aGUgZmVhdHVyZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0XG4gICAqICAgLSBSZW1vdmUgdGhlIGZlYXR1cmUgZnJvbSB0aGUgbGlzdCBpZiBpbiBtdWx0aSBzZWxlY3QgYW5kIHRoZSBmZWF0dXJlIGRvZXMgYWxyZWFkeSBleGlzdFxuICAgKiBAcGFyYW0gZmVhdHVyZSB0aGUgZmVhdHVyZSB0byBhZGQgb3IgcmVtb3ZlXG4gICAqIEBwYXJhbSBpc011bHRpU2VsZWN0IHRydWUgaWYgaW4gbXVsdGlzZWxlY3QgbW9kZVxuICAgKiBAcmV0dXJucyB0aGUgbGlzdCBvZiB6ZXJvIG9yIG1vcmUgZmVhdHVyZXNcbiAgICovXG4gIGNvbnN0IHVwZGF0ZVNlbGVjdGVkRmVhdHVyZXMgPSAoZmVhdHVyZTogTWFwR2VvSlNPTkZlYXR1cmUsIGlzTXVsdGlTZWxlY3Q6IGJvb2xlYW4pOiBNYXBHZW9KU09ORmVhdHVyZVtdID0+IHtcbiAgICBpZiAoIWZlYXR1cmUpIHJldHVybiBzZWxlY3RlZEZlYXR1cmVzO1xuXG4gICAgLy8gSWYgdGhlIGZlYXR1cmUgaXMgaW4gdGhlIGxpc3QgdGhlbiByZW1vdmUgaXQgYXMgaXQgaXMgYmVpbmcgZGVzZWxlY3RlZFxuICAgIGNvbnN0IGV4aXN0cyA9IHNlbGVjdGVkRmVhdHVyZXMuc29tZSgoaXRlbSkgPT4gaXRlbS5pZCA9PT0gZmVhdHVyZS5pZCk7XG4gICAgbGV0IGZlYXR1cmVMaXN0OiBNYXBHZW9KU09ORmVhdHVyZVtdID0gc2VsZWN0ZWRGZWF0dXJlcztcbiAgICBpZiAoZXhpc3RzKSB7XG4gICAgICBmZWF0dXJlTGlzdCA9IHNlbGVjdGVkRmVhdHVyZXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmlkICE9PSBmZWF0dXJlLmlkKTtcbiAgICAgIHNldFNob3dUb29NYW55VHJhY3RzQWxlcnQoZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRGZWF0dXJlcy5sZW5ndGggPCBNQVhfU0VMRUNURURfVFJBQ1RTKSB7XG4gICAgICAvLyBBZGQgdGhlIGZlYXR1cmUgdG8gdGhlIGxpc3QgaWYgaW4gbXVsdGkgc2VsZWN0LCBvdGhlcndpc2UgcmVwbGFjZSB0aGUgbGlzdFxuICAgICAgLy8gd2l0aCBqdXN0IHRoaXMgb25lIGZlYXR1cmUuXG4gICAgICBmZWF0dXJlTGlzdCA9IGlzTXVsdGlTZWxlY3QgP1xuICAgICAgICBbLi4uc2VsZWN0ZWRGZWF0dXJlcywgZmVhdHVyZV0gOlxuICAgICAgICBbZmVhdHVyZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFNob3dUb29NYW55VHJhY3RzQWxlcnQodHJ1ZSk7XG4gICAgfVxuICAgIHNldFNlbGVjdGVkRmVhdHVyZXMoZmVhdHVyZUxpc3QpO1xuXG4gICAgaWYgKCFpbk11bHRpU2VsZWN0TW9kZSkge1xuICAgICAgLy8gVHVybiBvbiBtdWx0aSBzZWxlY3QgbW9kZSBhbnkgdGltZSB3ZSBzZWxlY3QgbW9yZSB0aGFuIG9uZSB0cmFjdC5cbiAgICAgIHNldEluTXVsdGlTZWxlY3RNb2RlKGZlYXR1cmVMaXN0Lmxlbmd0aCA+IDEpO1xuICAgIH1cblxuICAgIHJldHVybiBmZWF0dXJlTGlzdDtcbiAgfTtcblxuICAvKipcbiAgICogU2VsZWN0cyB0aGUgcHJvdmlkZWQgZmVhdHVyZSBvbiB0aGUgbWFwLlxuICAgKiBAcGFyYW0gZmVhdHVyZSB0aGUgZmVhdHVyZSB0byBzZWxlY3RcbiAgICogQHBhcmFtIGlzTXVsdGlTZWxlY3RLZXlEb3duIHRydWUgaWYgdGhlIG11bHRpIHNlbGVjdCBrZXkgaXMgZG93blxuICAgKi9cbiAgY29uc3Qgc2VsZWN0RmVhdHVyZXNPbk1hcCA9IChmZWF0dXJlOiBJTWFwRmVhdHVyZSwgaXNNdWx0aVNlbGVjdEtleURvd246IGJvb2xlYW4gPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IGZlYXR1cmVzTGlzdCA9IHVwZGF0ZVNlbGVjdGVkRmVhdHVyZXMoZmVhdHVyZSwgaXNNdWx0aVNlbGVjdEtleURvd24gfHwgaW5NdWx0aVNlbGVjdE1vZGUpO1xuICAgIGlmIChmZWF0dXJlc0xpc3QubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgW21pbkxuZywgbWluTGF0LCBtYXhMbmcsIG1heExhdF0gPSBnZXRGZWF0dXJlc0Jib3goZmVhdHVyZXNMaXN0KTtcblxuICAgICAgLy8gR28gdG8gYXJlYSBvZiB0aGUgc2VsZWN0ZWQgZmVhdHVyZShzKVxuICAgICAgZ29Ub1BsYWNlKFtcbiAgICAgICAgW21pbkxuZywgbWluTGF0XSxcbiAgICAgICAgW21heExuZywgbWF4TGF0XSxcbiAgICAgIF0pO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBmb2xsb3dpbmcgbG9naWMgaXMgdXNlZCBmb3IgdGhlIHBvcHVwIGZvciB0aGUgZnVsbHNjcmVlbiBmZWF0dXJlXG4gICAgICAgKi9cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyB2aWV3cG9ydCB1c2luZyB0aGUgY3VycmVudCB2aWV3cG9ydCBkaW1uZXNpb25zOlxuICAgICAgY29uc3QgbmV3Vmlld1BvcnQgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh7aGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHQhLCB3aWR0aDogdmlld3BvcnQud2lkdGghfSk7XG5cbiAgICAgIC8vIEZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIG5ldyBib3VuZHMgYW5kIHJldHVybiBhIGxvbmcsIGxhdCBhbmQgem9vbTpcbiAgICAgIGNvbnN0IHtsb25naXR1ZGUsIGxhdGl0dWRlLCB6b29tfSA9IG5ld1ZpZXdQb3J0LmZpdEJvdW5kcyhcbiAgICAgICAgICBbXG4gICAgICAgICAgICBbbWluTG5nLCBtaW5MYXRdLFxuICAgICAgICAgICAgW21heExuZywgbWF4TGF0XSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDQwLFxuICAgICAgICAgIH0sXG4gICAgICApO1xuXG4gICAgICAvLyBTYXZlIHRoZSBwb3B1cEluZm9cbiAgICAgIGNvbnN0IHBvcHVwSW5mbyA9IHtcbiAgICAgICAgbG9uZ2l0dWRlOiBsb25naXR1ZGUsXG4gICAgICAgIGxhdGl0dWRlOiBsYXRpdHVkZSxcbiAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgcHJvcGVydGllczogZmVhdHVyZS5wcm9wZXJ0aWVzLFxuICAgICAgfTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBEZXRhaWxlZFZpZXcgc3RhdGUgdmFyaWFibGUgd2l0aCB0aGUgbmV3IHBvcHVwSW5mbyBvYmplY3Q6XG4gICAgICBzZXREZXRhaWxWaWV3RGF0YShwb3B1cEluZm8pO1xuXG4gICAgICAvKipcbiAgICAgICAqIEVuZCBGdWxsc2NyZWVuIGZlYXR1cmUgc3BlY2lmaWMgbG9naWNcbiAgICAgICAqL1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAqIFRoaXMgb25DbGljayBldmVudCBoYW5kbGVyIHdpbGwgbGlzdGVuIGFuZCBoYW5kbGUgY2xpY2tzIG9uIHRoZSBtYXAuIEl0IHdpbGwgbGlzdGVuIGZvciBjbGlja3Mgb24gdGhlXG4gKiB0ZXJyaXRvcnkgY29udHJvbHMgYW5kIGl0IHdpbGwgbGlzdGVuIHRvIGNsaWNrcyBvbiB0aGUgbWFwLlxuICpcbiAqIEl0IHdpbGwgTk9UIGxpc3RlbiB0byBjbGlja3MgaW50byB0aGUgc2VhcmNoIGZpZWxkIG9yIHRoZSB6b29tIGNvbnRyb2xzLiBUaGVzZSBjbGlja0hhbmRsZXJzIGFyZVxuICogY2FwdHVyZWQgaW4gdGhlaXIgb3duIHJlc3BlY3RpdmUgY29tcG9uZW50cy5cbiAqL1xuICBjb25zdCBvbkNsaWNrID0gKGV2ZW50OiBNYXBFdmVudCB8IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEJ1dHRvbkVsZW1lbnQ+KSA9PiB7XG4gICAgLy8gU3RvcCBhbGwgcHJvcGFnYXRpb24gLyBidWJibGluZyAvIGNhcHR1cmluZ1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgKGV2ZW50IGFzIFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEJ1dHRvbkVsZW1lbnQ+KS5zdG9wUHJvcGFnYXRpb24/LigpO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNsaWNrIGlzIGZvciB0ZXJyaXRvcmllcy4gR2l2ZW4gdGhlIHRlcnJpdG9yaWVzIGNvbXBvbmVudCdzIGRlc2lnbiwgaXQgY2FuIGJlXG4gICAgLy8gZ3VhcmFudGVlZCB0aGF0IGVhY2ggdGVycml0b3J5IGNvbnRyb2wgd2lsbCBoYXZlIGFuIGlkLiBXZSB1c2UgdGhpcyBJRCB0byBkZXRlcm1pbmVcbiAgICAvLyBpZiB0aGUgY2xpY2sgaXMgY29taW5nIGZyb20gYSB0ZXJyaXRvcnkgY29udHJvbFxuICAgIGlmIChldmVudC50YXJnZXQgJiYgKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCkuaWQpIHtcbiAgICAgIGNvbnN0IGJ1dHRvbklEID0gZXZlbnQudGFyZ2V0ICYmIChldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpLmlkO1xuXG4gICAgICBzd2l0Y2ggKGJ1dHRvbklEKSB7XG4gICAgICAgIGNhc2UgJzQ4JzpcbiAgICAgICAgICBnb1RvUGxhY2UoY29uc3RhbnRzLkxPV0VSXzQ4X0JPVU5EUywgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FLJzpcbiAgICAgICAgICBnb1RvUGxhY2UoY29uc3RhbnRzLkFMQVNLQV9CT1VORFMsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdISSc6XG4gICAgICAgICAgZ29Ub1BsYWNlKGNvbnN0YW50cy5IQVdBSUlfQk9VTkRTLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUFInOlxuICAgICAgICAgIGdvVG9QbGFjZShjb25zdGFudHMuUFVFUlRPX1JJQ09fQk9VTkRTLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnR1UnOlxuICAgICAgICAgIGdvVG9QbGFjZShjb25zdGFudHMuR1VBTV9CT1VORFMsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBUyc6XG4gICAgICAgICAgZ29Ub1BsYWNlKGNvbnN0YW50cy5BTUVSSUNBTl9TQU1PQV9CT1VORFMsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNUCc6XG4gICAgICAgICAgZ29Ub1BsYWNlKGNvbnN0YW50cy5NQVJJQU5BX0lTTEFORF9CT1VORFMsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdWSSc6XG4gICAgICAgICAgZ29Ub1BsYWNlKGNvbnN0YW50cy5VU19WSVJHSU5fSVNMQU5EU19CT1VORFMsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQgJiYgKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCkubm9kZU5hbWUgPT0gJ0RJVicpIHtcbiAgICAgIC8vIFRoaXMgZWxzZSBjbGF1c2Ugd2lsbCBmaXJlIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXAgYW5kIHdpbGwgaWdub3JlIG90aGVyIGNvbnRyb2xzXG4gICAgICAvLyBzdWNoIGFzIHRoZSBzZWFyY2ggYm94IGFuZCBidXR0b25zLlxuXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCBmZWF0dXJlID0gZXZlbnQuZmVhdHVyZXMgJiYgZXZlbnQuZmVhdHVyZXNbMF07XG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHNlbGVjdEZlYXR1cmVzT25NYXAoZmVhdHVyZSwgZXZlbnQuc3JjRXZlbnQuY3RybEtleSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uTG9hZCA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LkN5cHJlc3MgJiYgbWFwUmVmLmN1cnJlbnQpIHtcbiAgICAgIHdpbmRvdy51bmRlcmx5aW5nTWFwID0gbWFwUmVmLmN1cnJlbnQuZ2V0TWFwKCk7XG4gICAgfVxuXG4gICAgLy8gV2hlbiBtYXAgbG9hZHMgcmVtb3ZlIHRoZSBnZW9sb2NhdGUgbG9jayBib29sZWFuIGluIGxvY2FsIHN0b3JhZ2VcbiAgICByZW1vdmVHZW9sb2NhdGVMb2NrKCk7XG5cbiAgICBpZiAoaXNNb2JpbGUpIHNldElzTW9iaWxlTWFwU3RhdGUodHJ1ZSk7XG4gIH07XG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIG1vdmUgdGhlIG1hcCAod2l0aCBlYXNpbmcpIHRvIHRoZSBnaXZlbiBsYXQvbG9uZyBib3VuZHMuXG4gICAqXG4gICAqIFdoZW4gYSB1c2VyIGNsaWNrcyBvbiBhIHRyYWN0cyB2cyBhIHRlcnJpdG9yeSBidXR0b24sIHRoZSB6b29tIGxldmVsIHJldHVybmVkIGJ5IHRoZSBmaXRCb3VuZHNcbiAgICogZnVuY3Rpb24gZGlmZmVyLiBHaXZlbiB0aGF0IHdlIHdhbnQgdG8gaGFuZGxlIHRoZSB6b29tIGRpZmZlcmVudGx5IGRlcGVuZGluZyBvbiB0aGVzZSB0d28gY2FzZXMsIHdlXG4gICAqIGludHJvZHVjZSBhIGJvb2xlYW4sIGlzVGVycml0b3J5IHRoYXQgd2lsbCBhbGxvdyB0aGUgem9vbSBsZXZlbCB0byBiZSBzZXQgZGVwZW5kaW5nIG9uIHdoYXQgdGhlIHVzZXJcbiAgICogaXMgaW50ZXJhY3Rpbmcgd2l0aCwgbmFtZWx5IGEgdHJhY3QgdnMgYSB0ZXJyaXRvcnkgYnV0dG9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0xuZ0xhdEJvdW5kc0xpa2V9IGJvdW5kc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVGVycml0b3J5XG4gICAqL1xuICBjb25zdCBnb1RvUGxhY2UgPSAoYm91bmRzOiBMbmdMYXRCb3VuZHNMaWtlLCBpc1RlcnJpdG9yeSA9IGZhbHNlLCBzZWxlY3RUcmFjdElkOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQpID0+IHtcbiAgICBjb25zdCBuZXdWaWV3UG9ydCA9IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHtoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCEsIHdpZHRoOiB2aWV3cG9ydC53aWR0aCF9KTtcbiAgICBjb25zdCB7bG9uZ2l0dWRlLCBsYXRpdHVkZSwgem9vbX0gPSBuZXdWaWV3UG9ydC5maXRCb3VuZHMoXG4gICAgICBib3VuZHMgYXMgW1tudW1iZXIsIG51bWJlcl0sIFtudW1iZXIsIG51bWJlcl1dLCB7XG4gICAgICAvLyBwYWRkaW5nOiAyMDAsICAvLyByZW1vdmluZyBwYWRkaW5nIGFuZCBvZmZzZXQgaW4gZmF2b3Igb2YgYSB6b29tIG9mZnNldCBiZWxvd1xuICAgICAgLy8gb2Zmc2V0OiBbMCwgLTEwMF0sXG4gICAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc29tZSB0cmFjdHMgYXJlIHNlbGVjdGVkLCB0aGV5IGVuZCB1cCB0b28gZmFyIHpvb21lZCBpbiwgY2F1c2luZyBzb21lIGNlbnN1cyB0cmFjdHMgdG9cbiAgICAgKiBvbmx5IHNob3cgYSBwb3J0aW9uIG9mIHRoZSB0cmFjdCBpbiB0aGUgdmlld3BvcnQuIFdlIHJlZHVjZSB0aGUgem9vbSBsZXZlbCBieSAxIHRvIGFsbG93XG4gICAgICogbW9yZSBzcGFjZSBhcm91bmQgdGhlIHNlbGVjdGVkIHRyYWN0LlxuICAgICAqXG4gICAgICogR2l2ZW4gdGhhdCB0aGUgaGlnaCB6b29tIHRpbGVzIG9ubHkgZ28gdG8gem9vbSBsZXZlbCA1LCBpZiB0aGUgY29ycmVjdGVkIHpvb20gbGV2ZWwgKHpvb20gLSAxKSBpc1xuICAgICAqIGxlc3MgdGhhbiBNSU5fWk9PTV9GRUFUVVJFX0JPUkRFUiwgdGhlbiB3ZSBmbG9vciB0aGUgem9vbSB0byBNSU5fWk9PTV9GRUFUVVJFX0JPUkRFUiArIC4xICh3aGljaFxuICAgICAqIGlzIDUuMSBhcyBvZiB0aGlzIGNvbW1lbnQpXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICBjb25zdCBmZWF0dXJlU2VsZWN0aW9uWm9vbUxldmVsID0gKHpvb20gLSAxKSA8IGNvbnN0YW50cy5HTE9CQUxfTUlOX1pPT01fRkVBVFVSRV9CT1JERVIgKyAuMSA/XG4gICAgICBjb25zdGFudHMuR0xPQkFMX01JTl9aT09NX0ZFQVRVUkVfQk9SREVSIDpcbiAgICAgIHpvb20gLSAxO1xuXG4gICAgc2V0Vmlld3BvcnQoe1xuICAgICAgLi4udmlld3BvcnQsXG4gICAgICBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZSxcbiAgICAgIHpvb206IGlzVGVycml0b3J5ID8gem9vbSA6IGZlYXR1cmVTZWxlY3Rpb25ab29tTGV2ZWwsXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb246IDEwMDAsXG4gICAgICB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yOiBuZXcgRmx5VG9JbnRlcnBvbGF0b3IoKSxcbiAgICAgIHRyYW5zaXRpb25FYXNpbmc6IGQzLmVhc2VDdWJpYyxcbiAgICB9KTtcblxuICAgIC8vIFNldCB0aGUgdHJhY3QgSUQgdG8gYmUgc2VsZWN0ZWQgaWYgYW55LlxuICAgIHNldFNlbGVjdFRyYWN0SWQoc2VsZWN0VHJhY3RJZCk7XG4gIH07XG5cbiAgY29uc3Qgb25UcmFuc2l0aW9uU3RhcnQgPSAoKSA9PiB7XG4gICAgc2V0VHJhbnNpdGlvbkluUHJvZ3Jlc3ModHJ1ZSk7XG4gIH07XG5cbiAgY29uc3Qgb25UcmFuc2l0aW9uRW5kID0gKCkgPT4ge1xuICAgIHNldFRyYW5zaXRpb25JblByb2dyZXNzKGZhbHNlKTtcblxuICAgIC8qXG4gICAgSWYgdGhlcmUgaXMgYSB0cmFjdCBJRCB0byBiZSBzZWxlY3RlZCB0aGVuIGRvIHNvIG9uY2UgdGhlIG1hcCBoYXMgZmluaXNoZWQgbW92aW5nLlxuICAgIE5vdGUgdGhhdCBzZXR0aW5nIHRoZSB2aWV3cG9pbnQgdG8gbW92ZSB0aGUgbWFwIGFzIGRvbmUgaW4gdGhpcyBjb21wb25lbnQgZG9lcyBub3RcbiAgICB0cmlnZ2VyIGEgbW92ZWVuZCBvciBpZGxlIGV2ZW50IGxpa2Ugd2hlbiB1c2luZyBmbHlUbyBvciBlYXNlVG8uXG4gICAgKi9cbiAgICBpZiAoc2VsZWN0VHJhY3RJZCkge1xuICAgICAgLy8gU2VhcmNoIGZvciBmZWF0dXJlcyBpbiB0aGUgbWFwIHRoYXQgaGF2ZSB0aGUgdHJhY3QgSUQuXG4gICAgICBjb25zdCBnZW9pZFNlYXJjaFJlc3VsdHMgPSBtYXBSZWYuY3VycmVudD8uZ2V0TWFwKClcbiAgICAgICAgICAucXVlcnlTb3VyY2VGZWF0dXJlcyhjb25zdGFudHMuSElHSF9aT09NX1NPVVJDRV9OQU1FLCB7XG4gICAgICAgICAgICBzb3VyY2VMYXllcjogY29uc3RhbnRzLlNDT1JFX1NPVVJDRV9MQVlFUixcbiAgICAgICAgICAgIHZhbGlkYXRlOiB0cnVlLFxuICAgICAgICAgICAgZmlsdGVyOiBbJz09JywgY29uc3RhbnRzLkdFT0lEX1BST1BFUlRZLCBzZWxlY3RUcmFjdElkXSxcbiAgICAgICAgICB9KTtcbiAgICAgIGlmIChnZW9pZFNlYXJjaFJlc3VsdHMgJiYgZ2VvaWRTZWFyY2hSZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gVE9ETywgc3VwcG9ydCBzZWFyY2hpbmcgZm9yIGEgbGlzdCBvZiB0cmFjdHNcbiAgICAgICAgc2VsZWN0RmVhdHVyZXNPbk1hcChnZW9pZFNlYXJjaFJlc3VsdHNbMF0pO1xuICAgICAgfVxuICAgICAgc2V0U2VsZWN0VHJhY3RJZCh1bmRlZmluZWQpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBvbkdlb2xvY2F0ZSA9ICgpID0+IHtcbiAgICBzZXRHZW9sb2NhdGlvbkluUHJvZ3Jlc3MoZmFsc2UpO1xuXG4gICAgLy8gc2V0IGxvY2FsIHN0b3JhZ2UgdGhhdCBsb2NhdGlvbiB3YXMgbG9ja2VkIG9uIHRoaXMgYXBwIGF0IHNvbWUgcG9pbnRcbiAgICBzZXRJc0dlb2xvY2F0ZUxvY2tlZCh0cnVlKTtcbiAgfTtcblxuICBjb25zdCBvbkNsaWNrR2VvbG9jYXRlID0gKCkgPT4ge1xuICAgIHNldEdlb2xvY2F0aW9uSW5Qcm9ncmVzcyh0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlciBmb3Igd2hlbiB0aGVyZSBpcyBhIGNoYW5nZSBpbiB0aGUgbXVsdGkgc2VsZWN0IHNpZGUgcGFuZWwuXG4gICAqIEBwYXJhbSBmZWF0dXJlIHRoZSBmZWF0dXJlIHRoYXQgd2FzIGFkZGVkIG9yIHJlbW92ZWRcbiAgICovXG4gIGNvbnN0IG9uUmVwb3J0RGVsZXRlVHJhY3QgPSAoZmVhdHVyZTogTWFwR2VvSlNPTkZlYXR1cmUpID0+IHtcbiAgICB1cGRhdGVTZWxlY3RlZEZlYXR1cmVzKGZlYXR1cmUsIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVyIGZvciB3aGVuIHRoZSBtdWx0aSBzZWxlY3QgaXMgZmluaXNoZWQuXG4gICAqL1xuICBjb25zdCBvblJlcG9ydEV4aXQgPSAoKSA9PiB7XG4gICAgLy8gQ2xlYXIgZXZlcnl0aGluZ1xuICAgIHNldFNlbGVjdGVkRmVhdHVyZXMoW10pO1xuICAgIHNldERldGFpbFZpZXdEYXRhKHVuZGVmaW5lZCk7XG4gICAgc2V0SW5NdWx0aVNlbGVjdE1vZGUoZmFsc2UpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxHcmlkIGRlc2t0b3A9e3tjb2w6IDl9fSBjbGFzc05hbWU9e3N0eWxlcy5qNDBNYXB9PlxuICAgICAgICB7LyoqXG4gICAgICAgICAqIE5vdGU6XG4gICAgICAgICAqIFRoZSBNYXBTZWFyY2ggY29tcG9uZW50IGlzIG5vIGxvbmdlciB1c2VkIGluIHRoaXMgbG9jYXRpb24uIEl0IGhhcyBiZWVuIG1vdmVkIGluc2lkZSB0aGVcbiAgICAgICAgICogPFJlYWN0TWFwR0w+IGNvbXBvbmVudCBpdHNlbGYuXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IHdhcyBvcmlnaW5hbGx5IHdyYXBwZWQgaW4gYSBkaXYgaW4gb3JkZXIgdG8gYWxsb3cgdGhpcyBmZWF0dXJlXG4gICAgICAgICAqIHRvIGJlIGJlaGluZCBhIGZlYXR1cmUgZmxhZy4gVGhpcyB3YXMgY2F1c2luZyBhIGJ1ZyBmb3IgTWFwU2VhcmNoIHRvIHJlbmRlclxuICAgICAgICAgKiBjb3JyZWN0bHkgaW4gYSBwcm9kdWN0aW9uIGJ1aWxkLiBMZWF2aW5nIHRoaXMgY29tbWVudCBoZXJlIGluIGNhc2UgZnV0dXJlIGZsYWdzIGFyZVxuICAgICAgICAgKiBuZWVkZWQgaW4gdGhpcyBjb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdGhlIE1hcFNlYXJjaCBjb21wb25lbnQgaXMgcGxhY2VkIGJlaGluZCBhIGZlYXR1cmUgZmxhZyB3aXRob3V0IGEgZGl2IHdyYXBwaW5nXG4gICAgICAgICAqIE1hcFNlYXJjaCwgdGhlIHByb2R1Y3Rpb24gYnVpbGQgd2lsbCBpbmplY3QgQ1NTIGR1ZSB0byB0aGUgbnVsbCBpbiB0aGUgZmFsc2UgY29uZGl0aW9uYWxcbiAgICAgICAgICogY2FzZS4gQW55IGNoYW5nZXMgdG8gdGhpcyAoaWUsIGNoYW5nZXMgdG8gTWFwU2VhcmNoIG9yIHJlbW92aW5nIGZlYXR1cmUgZmxhZywgZXRjKSwgc2hvdWxkXG4gICAgICAgICAqIGJlIHRlc3RlZCB3aXRoIGEgcHJvZHVjdGlvbiBidWlsZCB2aWE6XG4gICAgICAgICAqICAgLSBucG0gcnVuIGNsZWFuICYmIG5wbSBydW4gYnVpbGQgJiYgbnBtIHJ1biBzZXJ2ZVxuICAgICAgICAgKlxuICAgICAgICAgKiB0byBlbnN1cmUgdGhlIHByb2R1Y3Rpb24gYnVpbGQgd29ya3MgYW5kIHRoYXQgTWFwU2VhcmNoIGFuZCB0aGUgbWFwIChSZWFjdE1hcEdMKSByZW5kZXIgY29ycmVjdGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBBbnkgY29tcG9uZW50IGRlY2xhcmF0aW9ucyBvdXRzaWRlIHRoZSA8UmVhY3RNYXBHTD4gY29tcG9uZW50IG1heSBiZSBzdXNjZXB0aWJsZSB0byB0aGlzIGJ1Zy5cbiAgICAgICAgICovfVxuXG4gICAgICAgIHsvKipcbiAgICAgICAgICogVGhlIFJlYWN0TWFwR0wgY29tcG9uZW50J3MgcHJvcHMgYXJlIGdyb3VwZWQgYnkgdGhlIEFQSSdzIGRvY3VtZW50YXRpb24uIFRoZSBjb21wb25lbnQgYWxzbyBoYXNcbiAgICAgICAgICogc29tZSBjaGlsZHJlbi5cbiAgICAgICAgICovfVxuICAgICAgICA8UmVhY3RNYXBHTFxuICAgICAgICAgIC8vICoqKioqKiBJbml0aWFsaXphdGlvbiBwcm9wczogKioqKioqXG4gICAgICAgICAgLy8gYWNjZXNzIHRva2VuIGlzIGo0MFN0eWxlc1JlYWRUb2tlblxuICAgICAgICAgIG1hcGJveEFwaUFjY2Vzc1Rva2VuPXtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk1BUEJPWF9TVFlMRVNfUkVBRF9UT0tFTiA/XG4gICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk1BUEJPWF9TVFlMRVNfUkVBRF9UT0tFTiA6ICcnfVxuXG4gICAgICAgICAgLy8gKioqKioqIE1hcCBzdGF0ZSBwcm9wczogKioqKioqXG4gICAgICAgICAgLy8gaHR0cDovL3Zpc2dsLmdpdGh1Yi5pby9yZWFjdC1tYXAtZ2wvZG9jcy9hcGktcmVmZXJlbmNlL2ludGVyYWN0aXZlLW1hcCNtYXAtc3RhdGVcbiAgICAgICAgICB7Li4udmlld3BvcnR9XG4gICAgICAgICAgbWFwU3R5bGU9e1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTUFQQk9YX1NUWUxFU19SRUFEX1RPS0VOID9cbiAgICAgICAgICAgICAgJ21hcGJveDovL3N0eWxlcy9qdXN0aWNlNDAvY2w5ZzMwcWg3MDAwcDE1bDljcDFmdHcxNicgOlxuICAgICAgICAgICAgICAnaHR0cHM6Ly9iYXNlbWFwcy5jYXJ0b2Nkbi5jb20vZ2wvdm95YWdlci1nbC1zdHlsZS9zdHlsZS5qc29uJ1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aWR0aD1cIjEwMCVcIlxuICAgICAgICAgIC8vIEFqdXN0aW5nIHRoaXMgaGVpZ2h0IHdpdGggYSBjb25kaXRpb25hbCBzdGF0ZW1lbnQgd2lsbCBub3QgcmVuZGVyIHRoZSBtYXAgb24gc3RhZ2luZy5cbiAgICAgICAgICAvLyBUaGUgcmVhc29uIGZvciB0aGlzIGlzc3VlIGlzIHVua25vd24uIENvbnNpZGVyIHN0eWxpbmcgdGhlIHBhcmVudCBjb250YWluZXIgdmlhIFNBU1MuXG4gICAgICAgICAgaGVpZ2h0PVwiMTAwJVwiXG4gICAgICAgICAgbWFwT3B0aW9ucz17e2hhc2g6IHRydWV9fVxuXG5cbiAgICAgICAgICAvLyAqKioqKiogSW50ZXJhY3Rpb24gb3B0aW9uIHByb3BzOiAqKioqKipcbiAgICAgICAgICAvLyBodHRwOi8vdmlzZ2wuZ2l0aHViLmlvL3JlYWN0LW1hcC1nbC9kb2NzL2FwaS1yZWZlcmVuY2UvaW50ZXJhY3RpdmUtbWFwI2ludGVyYWN0aW9uLW9wdGlvbnNcbiAgICAgICAgICBtYXhab29tPXtjb25zdGFudHMuR0xPQkFMX01BWF9aT09NfVxuICAgICAgICAgIG1pblpvb209e2NvbnN0YW50cy5HTE9CQUxfTUlOX1pPT019XG4gICAgICAgICAgZHJhZ1JvdGF0ZT17ZmFsc2V9XG4gICAgICAgICAgdG91Y2hSb3RhdGU9e2ZhbHNlfVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICAgICAgaW50ZXJhY3RpdmVMYXllcklkcz17XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIGNvbnN0YW50cy5ISUdIX1pPT01fTEFZRVJfSUQsXG4gICAgICAgICAgICAgIGNvbnN0YW50cy5QUklPUklUSVpFRF9ISUdIX1pPT01fTEFZRVJfSUQsXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgICAvLyAqKioqKiogQ2FsbGJhY2sgcHJvcHM6ICoqKioqKlxuICAgICAgICAgIC8vIGh0dHA6Ly92aXNnbC5naXRodWIuaW8vcmVhY3QtbWFwLWdsL2RvY3MvYXBpLXJlZmVyZW5jZS9pbnRlcmFjdGl2ZS1tYXAjY2FsbGJhY2tzXG4gICAgICAgICAgb25WaWV3cG9ydENoYW5nZT17c2V0Vmlld3BvcnR9XG4gICAgICAgICAgb25DbGljaz17b25DbGlja31cbiAgICAgICAgICBvbkxvYWQ9e29uTG9hZH1cbiAgICAgICAgICBvblRyYW5zaXRpb25TdGFydD17b25UcmFuc2l0aW9uU3RhcnR9XG4gICAgICAgICAgb25UcmFuc2l0aW9uRW5kPXtvblRyYW5zaXRpb25FbmR9XG4gICAgICAgICAgcmVmPXttYXBSZWZ9XG4gICAgICAgICAgZGF0YS1jeT17J3JlYWN0TWFwR0wnfVxuICAgICAgICA+XG5cbiAgICAgICAgICB7IC8qIFRyaWJhbCBsYXllciBpcyBiYWtlZCBpbnRvIE1hcGJveCBzb3VyY2UsXG4gICAgICAgICAgICAgKiBvbmx5IHJlbmRlciBoZXJlIGlmIHdlJ3JlIG5vdCB1c2luZyB0aGF0XG4gICAgICAgICAgICAgKiovXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5NQVBCT1hfU1RZTEVTX1JFQURfVE9LRU4gfHxcbiAgICAgICAgICAgIDxNYXBUcmliYWxMYXllciAvPlxuICAgICAgICAgIH1cblxuICAgICAgICAgIDxNYXBUcmFjdExheWVyc1xuICAgICAgICAgICAgc2VsZWN0ZWRGZWF0dXJlcz17c2VsZWN0ZWRGZWF0dXJlc31cbiAgICAgICAgICAvPlxuXG4gICAgICAgICAgey8qIFRoaXMgaXMgdGhlIGZpcnN0IG92ZXJsYXllZCByb3cgb24gdGhlIG1hcDogU2VhcmNoIGFuZCBHZW9sb2NhdGlvbiAqL31cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLm1hcEhlYWRlclJvd30+XG4gICAgICAgICAgICA8TWFwU2VhcmNoIGdvVG9QbGFjZT17Z29Ub1BsYWNlfSAvPlxuXG4gICAgICAgICAgICB7LyogR2VvbG9jYXRlIEljb24gKi99XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmdlb2xvY2F0ZUJveH0+XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB3aW5kb3dXaWR0aCA+IGNvbnN0YW50cy5VU1dEU19CUkVBS1BPSU5UUy5NT0JJTEVfTEcgLSAxICYmXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e1xuICAgICAgICAgICAgICAgICAgKGdlb2xvY2F0aW9uSW5Qcm9ncmVzcyAmJiAhaXNHZW9sb2NhdGVMb2NrZWQpID9cbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLmdlb2xvY2F0ZU1lc3NhZ2UgOlxuICAgICAgICAgICAgICAgICAgICBzdHlsZXMuZ2VvbG9jYXRlTWVzc2FnZUhpZGVcbiAgICAgICAgICAgICAgICB9PlxuICAgICAgICAgICAgICAgICAge2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuTUFQLkdFT0xPQ19NU0dfTE9DQVRJTkcpfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDxHZW9sb2NhdGVDb250cm9sXG4gICAgICAgICAgICAgICAgcG9zaXRpb25PcHRpb25zPXt7ZW5hYmxlSGlnaEFjY3VyYWN5OiB0cnVlfX1cbiAgICAgICAgICAgICAgICBvbkdlb2xvY2F0ZT17b25HZW9sb2NhdGV9XG4gICAgICAgICAgICAgICAgb25DbGljaz17b25DbGlja0dlb2xvY2F0ZX1cbiAgICAgICAgICAgICAgICB0cmFja1VzZXJMb2NhdGlvbj17d2luZG93V2lkdGggPCBjb25zdGFudHMuVVNXRFNfQlJFQUtQT0lOVFMuTU9CSUxFX0xHfVxuICAgICAgICAgICAgICAgIHNob3dVc2VySGVhZGluZz17d2luZG93V2lkdGggPCBjb25zdGFudHMuVVNXRFNfQlJFQUtQT0lOVFMuTU9CSUxFX0xHfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIHsvKiBUaGlzIGlzIHRoZSBzZWNvbmQgcm93IG92ZXJsYXllZCBvbiB0aGUgbWFwLCBpdCB3aWxsIGFkZCB0aGUgbmF2aWdhdGlvbiBjb250cm9sc1xuICAgICAgICAgIG9mIHRoZSB6b29tIGluIGFuZCB6b29tIG91dCBidXR0b25zICovfVxuICAgICAgICAgIHt3aW5kb3dXaWR0aCA+IGNvbnN0YW50cy5VU1dEU19CUkVBS1BPSU5UUy5NT0JJTEVfTEcgJiYgPE5hdmlnYXRpb25Db250cm9sXG4gICAgICAgICAgICBzaG93Q29tcGFzcz17ZmFsc2V9XG4gICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5uYXZpZ2F0aW9uQ29udHJvbH1cbiAgICAgICAgICAvPn1cblxuICAgICAgICAgIHsvKiBUaGlzIGlzIHRoZSB0aGlyZCByb3cgb3ZlcmxheWVkIG9uIHRoZSBtYXAsIGl0IHdpbGwgc2hvdyBzaG9ydGN1dCBidXR0b25zIHRvXG4gICAgICAgICAgcGFuL3pvb20gdG8gVVMgdGVycml0b3JpZXMgKi99XG4gICAgICAgICAge3dpbmRvd1dpZHRoID4gY29uc3RhbnRzLlVTV0RTX0JSRUFLUE9JTlRTLk1PQklMRV9MRyAmJlxuICAgICAgICAgICAgPFRlcnJpdG9yeUZvY3VzQ29udHJvbCBvbkNsaWNrPXtvbkNsaWNrfSAvPn1cblxuICAgICAgICAgIHsvKiBFbmFibGUgZnVsbHNjcmVlbiBwb3AtdXAgYmVoaW5kIGEgZmVhdHVyZSBmbGFnICovfVxuICAgICAgICAgIHsoJ2ZzJyBpbiBmbGFncyAmJiBkZXRhaWxWaWV3RGF0YSAmJiAhdHJhbnNpdGlvbkluUHJvZ3Jlc3MpICYmIChcbiAgICAgICAgICAgIDxQb3B1cFxuICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5qNDBQb3B1cH1cbiAgICAgICAgICAgICAgdGlwU2l6ZT17NX1cbiAgICAgICAgICAgICAgYW5jaG9yPVwidG9wXCJcbiAgICAgICAgICAgICAgbG9uZ2l0dWRlPXtkZXRhaWxWaWV3RGF0YS5sb25naXR1ZGUhfVxuICAgICAgICAgICAgICBsYXRpdHVkZT17ZGV0YWlsVmlld0RhdGEubGF0aXR1ZGUhfVxuICAgICAgICAgICAgICBjbG9zZU9uQ2xpY2s9e3RydWV9XG4gICAgICAgICAgICAgIG9uQ2xvc2U9e3NldERldGFpbFZpZXdEYXRhfVxuICAgICAgICAgICAgICBjYXB0dXJlU2Nyb2xsPXt0cnVlfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8QXJlYURldGFpbFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM9e2RldGFpbFZpZXdEYXRhLnByb3BlcnRpZXN9XG4gICAgICAgICAgICAgICAgaGFzaD17em9vbUxhdExuZ0hhc2h9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L1BvcHVwPlxuICAgICAgICAgICl9XG4gICAgICAgICAgeydmcycgaW4gZmxhZ3MgPyA8RnVsbHNjcmVlbkNvbnRyb2wgY2xhc3NOYW1lPXtzdHlsZXMuZnVsbHNjcmVlbkNvbnRyb2x9IC8+IDogJyd9XG5cbiAgICAgICAgPC9SZWFjdE1hcEdMPlxuICAgICAgPC9HcmlkPlxuXG4gICAgICA8R3JpZCBkZXNrdG9wPXt7Y29sOiAzfX0+XG4gICAgICAgIHtpbk11bHRpU2VsZWN0TW9kZSA/XG4gICAgICAgICAgPENyZWF0ZVJlcG9ydFBhbmVsXG4gICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5tYXBJbmZvUGFuZWx9XG4gICAgICAgICAgICBmZWF0dXJlTGlzdD17c2VsZWN0ZWRGZWF0dXJlc31cbiAgICAgICAgICAgIGRlbGV0ZVRyYWN0SGFuZGxlcj17b25SZXBvcnREZWxldGVUcmFjdH1cbiAgICAgICAgICAgIGV4aXRIYW5kbGVyPXtvblJlcG9ydEV4aXR9XG4gICAgICAgICAgICBtYXhOdW1UcmFjdHM9e01BWF9TRUxFQ1RFRF9UUkFDVFN9XG4gICAgICAgICAgICBzaG93VG9vTWFueVRyYWN0c0FsZXJ0PXtzaG93VG9vTWFueVRyYWN0c0FsZXJ0fVxuICAgICAgICAgIC8+IDpcbiAgICAgICAgICA8TWFwSW5mb1BhbmVsXG4gICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5tYXBJbmZvUGFuZWx9XG4gICAgICAgICAgICBmZWF0dXJlUHJvcGVydGllcz17ZGV0YWlsVmlld0RhdGE/LnByb3BlcnRpZXN9XG4gICAgICAgICAgICBoYXNoPXt6b29tTGF0TG5nSGFzaH1cbiAgICAgICAgICAvPlxuICAgICAgICB9XG4gICAgICA8L0dyaWQ+XG4gICAgPC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBKNDBNYXA7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHt1c2VJbnRsfSBmcm9tICdnYXRzYnktcGx1Z2luLWludGwnO1xuaW1wb3J0IHtHcmlkfSBmcm9tICdAdHJ1c3N3b3Jrcy9yZWFjdC11c3dkcyc7XG5cbmltcG9ydCBFeHBsb3JlRGF0YUJveCBmcm9tICcuLi9jb21wb25lbnRzL0V4cGxvcmVEYXRhQm94JztcbmltcG9ydCBKNDBNYXAgZnJvbSAnLi4vY29tcG9uZW50cy9KNDBNYXAnO1xuaW1wb3J0IEo0ME1haW5HcmlkQ29udGFpbmVyIGZyb20gJy4uL2NvbXBvbmVudHMvSjQwTWFpbkdyaWRDb250YWluZXInO1xuaW1wb3J0IExheW91dCBmcm9tICcuLi9jb21wb25lbnRzL2xheW91dCc7XG4vLyBpbXBvcnQgRGF0YXNldHNCdXR0b24gZnJvbSAnLi4vY29tcG9uZW50cy9EYXRhc2V0c0J1dHRvbic7XG5cbmltcG9ydCAqIGFzIEVYUExPUkVfQ09QWSBmcm9tICcuLi9kYXRhL2NvcHkvZXhwbG9yZSc7XG4vLyBpbXBvcnQge0RBVEFfU1VSVkVZX0xJTktTfSBmcm9tICcuLi9kYXRhL2NvbnN0YW50cyc7XG5cbmludGVyZmFjZSBJTWFwUGFnZVByb3BzIHtcbiAgbG9jYXRpb246IExvY2F0aW9uO1xufVxuXG5jb25zdCBFeHBvcmVUb29sUGFnZSA9ICh7bG9jYXRpb259OiBJTWFwUGFnZVByb3BzKSA9PiB7XG4gIC8vIFdlIHRlbXBvcmFyaWx5IHJlbW92ZWQgTWFwQ29udHJvbHMsIHdoaWNoIHdvdWxkIGVuYWJsZSB5b3UgdG8gYHNldEZlYXR1cmVzYCBhbHNvLCBmb3Igbm93XG4gIC8vICAgV2Ugd2lsbCBicmluZyBiYWNrIGxhdGVyIHdoZW4gd2UgaGF2ZSBpbnRlcmFjdGl2ZSBjb250cm9scy5cbiAgY29uc3QgaW50bCA9IHVzZUludGwoKTtcblxuXG4gIHJldHVybiAoPExheW91dCBsb2NhdGlvbj17bG9jYXRpb259IHRpdGxlPXtpbnRsLmZvcm1hdE1lc3NhZ2UoRVhQTE9SRV9DT1BZLlBBR0VfSU5UUk8uUEFHRV9USUxFKX0+XG5cbiAgICA8SjQwTWFpbkdyaWRDb250YWluZXI+XG5cbiAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT17J3BhZ2UtaGVhZGluZyd9PlxuICAgICAgICA8aDE+e2ludGwuZm9ybWF0TWVzc2FnZShFWFBMT1JFX0NPUFkuUEFHRV9JTlRSTy5QQUdFX0hFQURJTkcpfTwvaDE+XG4gICAgICAgIHsvKiA8RGF0YXNldHNCdXR0b24gaHJlZj0ge2ludGwubG9jYWxlID09PSAnZXMnID8gREFUQV9TVVJWRVlfTElOS1MuRVMgOiBEQVRBX1NVUlZFWV9MSU5LUy5FTn0gLz4gKi99XG4gICAgICA8L3NlY3Rpb24+XG5cbiAgICAgIDxHcmlkIHJvdyBnYXAgY2xhc3NOYW1lPXsnajQwLW1iNS1tdDMnfT5cblxuICAgICAgICB7LyogR3JhZHVhbGx5IGluY3JlYXNlIHdpZHRoIG9mIHRoZSBHcmlkIGFzIHRoZSB3aWR0aCBkZWNyZWFzZXMgZnJvbSBkZXNrdG9wIHRvIG1vYmlsZSovfVxuICAgICAgICB7LyogZGVza3RvcCA9IDcgY29sdW1ucywgdGFibGV0ID0gMTAgY29sdW1ucyBhbmQgbW9iaWxlID0gMTIgY29sdW1ucyAoZnVsbCB3aWR0aCkgKi99XG4gICAgICAgIDxHcmlkIGRlc2t0b3A9e3tjb2w6IDh9fSB0YWJsZXQ9e3tjb2w6IDEwfX0gY29sPXsxMn0+XG4gICAgICAgICAgPHA+XG4gICAgICAgICAgICB7RVhQTE9SRV9DT1BZLlBBR0VfREVTQ1JJUFRJT04xfVxuICAgICAgICAgIDwvcD5cbiAgICAgICAgICA8cD5cbiAgICAgICAgICAgIHtFWFBMT1JFX0NPUFkuUEFHRV9ERVNDUklQVElPTjJ9XG4gICAgICAgICAgPC9wPlxuICAgICAgICA8L0dyaWQ+XG4gICAgICAgIDxHcmlkIGRlc2t0b3A9e3tjb2w6IDR9fSB0YWJsZXQ9e3tjb2w6IDEwfX0gY29sPXsxMn0+XG4gICAgICAgICAgPEV4cGxvcmVEYXRhQm94IC8+XG4gICAgICAgIDwvR3JpZD5cbiAgICAgIDwvR3JpZD5cbiAgICA8L0o0ME1haW5HcmlkQ29udGFpbmVyPlxuXG4gICAgPEo0ME1haW5HcmlkQ29udGFpbmVyPlxuICAgICAgPEdyaWQgcm93PlxuICAgICAgICA8SjQwTWFwIGxvY2F0aW9uPXtsb2NhdGlvbn0vPlxuICAgICAgPC9HcmlkPlxuICAgIDwvSjQwTWFpbkdyaWRDb250YWluZXI+XG5cbiAgICA8SjQwTWFpbkdyaWRDb250YWluZXI+XG4gICAgICA8R3JpZCBkZXNrdG9wPXt7Y29sOiA3fX0gdGFibGV0PXt7Y29sOiAxMH19IGNvbD17MTJ9PlxuICAgICAgICA8aDI+e0VYUExPUkVfQ09QWS5OT1RFX09OX1RFUlJJVE9SSUVTLklOVFJPfTwvaDI+XG4gICAgICAgIDxwPntFWFBMT1JFX0NPUFkuTk9URV9PTl9URVJSSVRPUklFUy5QQVJBXzB9PC9wPlxuICAgICAgICA8cD57RVhQTE9SRV9DT1BZLk5PVEVfT05fVEVSUklUT1JJRVMuUEFSQV8xfTwvcD5cbiAgICAgICAgPHA+e0VYUExPUkVfQ09QWS5OT1RFX09OX1RFUlJJVE9SSUVTLlBBUkFfMn08L3A+XG4gICAgICA8L0dyaWQ+XG5cbiAgICAgIDxHcmlkIGRlc2t0b3A9e3tjb2w6IDd9fSB0YWJsZXQ9e3tjb2w6IDEwfX0gY29sPXsxMn0+XG4gICAgICAgIDxoMj57RVhQTE9SRV9DT1BZLk5PVEVfT05fVFJJQkFMX05BVElPTlMuSU5UUk99PC9oMj5cbiAgICAgICAgPHA+e0VYUExPUkVfQ09QWS5OT1RFX09OX1RSSUJBTF9OQVRJT05TLlBBUkFfMX08L3A+XG4gICAgICAgIDxwPntFWFBMT1JFX0NPUFkuTk9URV9PTl9UUklCQUxfTkFUSU9OUy5QQVJBXzJ9PC9wPlxuICAgICAgPC9HcmlkPlxuICAgIDwvSjQwTWFpbkdyaWRDb250YWluZXI+XG5cbiAgPC9MYXlvdXQ+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFeHBvcmVUb29sUGFnZTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlN1bW1hcnlCb3giLCJTdW1tYXJ5Qm94Q29udGVudCIsIlN1bW1hcnlCb3hIZWFkaW5nIiwidXNlSW50bCIsIkVYUExPUkVfQ09QWSIsInN0eWxlcyIsImZpbGVEb3duSWNvbiIsIkV4cGxvcmVEYXRhQm94IiwiX3JlZiIsImludGwiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwic3VtbWFyeUJveENvbnRhaW5lciIsImhlYWRpbmdMZXZlbCIsImZvcm1hdE1lc3NhZ2UiLCJFWFBMT1JFX0RBVEFfQk9YIiwiVElUTEUiLCJ0YWJJbmRleCIsInNyYyIsImFsdCIsIlNJREVfUEFORUxfSU5JVF9TVEFURV9JQ09OX0FMVF9URVhUIiwiUExVUyIsIkVYUExPUkVfREFUQV9CT1hfQk9EWSIsIkRpc2FkdmFudGFnZURvdCIsImlzRGlzYWR2YW50YWdlZCIsImlzQmlnIiwiY29tcHV0ZWRDbGFzcyIsImRpc2FkdmFudGFnZWREb3RCaWciLCJkaXNhZHZhbnRhZ2VkRG90U21hbGwiLCJDYXRlZ29yeSIsIm5hbWUiLCJkaXNDYXRlZ29yeUNvbnRhaW5lciIsImNhdGVnb3J5IiwiY2F0ZWdvcnlDb250YWluZXIiLCJSZWFjdFRvb2x0aXAiLCJjb25zdGFudHMiLCJpbmZvSWNvbiIsIkluZGljYXRvckluZm9JY29uIiwiaXNJbXB1dGUiLCJwb3B1bGF0aW9uIiwic2hvd1RpbGRlIiwiZ2V0VG9vbFRpcENvcHkiLCJNSVNTSU5HX0RBVEFfU1RSSU5HIiwiTE9XX0lOQ09NRV9UT09MVElQIiwiSU1QX1lFU19QT1BfTlVMTCIsIklNUF9ZRVNfUE9QX05PVF9OVUxMIiwiRnJhZ21lbnQiLCJpZCIsIm11bHRpbGluZSIsImluZm8iLCJTSURFX1BBTkVMX1ZBTFVFUyIsIklNR19BTFRfVEVYVCIsIklORk8iLCJpbmZvVGlsZGUiLCJJbmRpY2F0b3JWYWx1ZVN1YlRleHQiLCJfcmVmMiIsInR5cGUiLCJ2YWx1ZSIsImlzQWJvdmVUaHJlc2giLCJ0aHJlc2hvbGQiLCJVTkFWQUlMQkxFX01TRyIsIkFCT1ZFIiwiQkVMT1ciLCJJbmRpY2F0b3JWYWx1ZSIsImRpc3BsYXlTdGF0IiwiUEVSQ0VOVCIsIlBFUkNFTlRJTEUiLCJzdXBlcnNjcmlwdE9yZGluYWwiLCJpbmRpY2F0b3JWYWx1ZVdpdGhTdWZmaXgiLCJpbmRleE9mIiwib3JkaW5hbFN1ZmZpeCIsImNoYXJBdCIsImxlbmd0aCIsImluZGljYXRvclZhbHVlIiwic2xpY2UiLCJzdHlsZSIsInRvcCIsInZhbHVlUmVnRXgiLCJzdWZmaXhSZWdFeCIsImV4ZWMiLCJfcmVmMyIsImZvcm1hdE51bWJlciIsInVuaXQiLCJ1bml0RGlzcGxheSIsImkxOG5PcmRpbmFsU3VmZml4IiwiZGVzY3JpcHRpb24iLCJkZWZhdWx0TWVzc2FnZSIsIlNJREVfUEFORUxfU1BBQ0VSUyIsIk5PIiwiWUVTIiwiSW5kaWNhdG9yIiwiX3JlZjQiLCJpbmRpY2F0b3IiLCJNYXRoIiwiZmxvb3IiLCJOdW1iZXIiLCJERUZBVUxUX1RIUkVTSE9MRF9QRVJDRU5USUxFIiwic2hvd0xvd0luY29tZUluZm9JY29uIiwibGFiZWwiLCJpbmRpY2F0b3JCb3hNYWluIiwiaW5kaWNhdG9yUm93IiwiaW5kaWNhdG9yTmFtZSIsImluZGljYXRvckRlc2MiLCJpbmRpY2F0b3JWYWx1ZUNvbCIsImluZGljYXRvclZhbHVlUm93IiwiaW5kaWNhdG9ySW5mbyIsImlzRGlzYWR2YWd0YWdlZCIsImRpc0luZGljYXRvclZhbHVlIiwiaW5kaWNhdG9yVmFsdWVTdWJUZXh0IiwiRG9udXRDb3B5IiwiaXNBZGphY2VudCIsInBvdmVydHlCZWxvdzIwMFBlcmNlbnRpbGUiLCJwb3ZCZWwyMDBQZXJjZW50aWxlIiwicGFyc2VGbG9hdCIsInRvRml4ZWQiLCJkb251dENvcHlDb250YWluZXIiLCJkb251dFJvdyIsImRvbnV0Um93TGFiZWwiLCJET05VVF9DT1BZIiwiQ09NUF9TVVJSIiwiaW52ZXJ0IiwiQ09NTVVOSVRZIiwiT0ZfRk9DVVMiLCJOT1RfT0ZfRk9DVVMiLCJBREpfTE9XX0lOQyIsInZhbHVlU3ViVGV4dENvbnRhaW5lciIsIm5vSW52ZXJ0Iiwic3ViVGV4dENvbnRhaW5lciIsIlByaW9yaXRpemF0aW9uQ29weSIsInRvdGFsQ2F0ZWdvcmllc1ByaW9yaXRpemVkIiwidG90YWxCdXJkZW5zUHJpb3JpdGl6ZWQiLCJpc0FkamFjZW5jeVRocmVzaE1ldCIsImlzQWRqYWNlbmN5TG93SW5jb21lIiwiaXNHcmFuZGZhdGhlcmVkIiwiaXNJc2xhbmRMb3dJbmNvbWUiLCJ0cmliYWxDb3VudEFLIiwidHJpYmFsQ291bnRVUyIsInBlcmNlbnRUcmFjdFRyaWJhbCIsInByaW9Db3B5UmVuZGVyZWQiLCJQUklPUklUSVpBVElPTl9DT1BZIiwiUFJJT19HUkFOREZBVEhFUkVEX0xJIiwiUFJJT19TVVJSX0xJIiwiUFJJT19JU0xBTkRfTEkiLCJOT1RfUFJJT19TVVJSX0xJIiwiUEFSX1BSSU9fU1VSUl9OT19MSSIsIk5PVF9QUklPIiwiTk9UX1BSSU9fMUJVUiIsIk5PVF9QUklPX05CVVIiLCJnZXRQcmlvQUtVU0NvcHkiLCJnZXRQcmlvQU5WQ29weSIsImdldFByaW9GUlRQb2ludHNDb3B5IiwiZ2V0UHJpb0ZSVENvcHkiLCJnZXRQcmlvTkJ1cmRlbkNvcHkiLCJQcmlvcml0aXphdGlvbkNvcHkyIiwicHJpb0NvcHkyUmVuZGVyZWQiLCJnZXRQcmlvUGVyY0FuZE51bVBvaW50c0Fsc29Db3B5IiwidXNlU3RhdGUiLCJleHBhbmRJY29uIiwiY29sbGFwc2VJY29uIiwiSjQwQWNjb3JkaW9uSXRlbSIsInRpdGxlIiwiY2hpbGRyZW4iLCJpc0V4cGFuZGVkIiwic2V0SXNFeHBhbmRlZCIsImRlbW9ncmFwaGljSGVhZGluZyIsInNob3dIaWRlVGV4dCIsIm9uQ2xpY2siLCJTSURFX1BBTkVMX0RFTU9HUkFQSElDUyIsIkhJREVfREVNT0dSQVBISUNTIiwiU0hPV19ERU1PR1JBUEhJQ1MiLCJzaG93SGlkZUljb24iLCJoaWRkZW4iLCJkZW1vZ3JhcGhpY0l0ZW1HZW4iLCJkZW1vZ3JhcGhpY0RhdGEiLCJtYXAiLCJlbCIsImluZGV4Iiwia2V5IiwiZGVtb2dyYXBoaWNJdGVtIiwic3RhdCIsInVuZGVmaW5lZCIsImdldERlbW9ncmFwaGljc0RhdGEiLCJwcm9wZXJ0aWVzIiwicmFjZSIsIkRFTU9fTk9OX0hJU1BBTklDX1dISVRFIiwiREVNT19CTEFDSyIsIkRFTU9fQU1FUklDQU5fSU5ESUFOIiwiREVNT19BU0lBTiIsIkRFTU9fSEFXQUlJQU4iLCJERU1PX09USEVSX1JBQ0UiLCJERU1PX1RXT19PUl9NT1JFX1JBQ0VTIiwiREVNT19ISVNQQU5JQyIsImFnZSIsIkRFTU9fQUdFX1VOREVSXzEwIiwiREVNT19BR0VfTUlEIiwiREVNT19BR0VfT1ZFUl82NSIsIkRFTU9fQUdFX09WRVJfNjQiLCJUcmFjdERlbW9ncmFwaGljcyIsImRlbW9ncmFwaGljc0NvbnRhaW5lciIsImRlbW9ncmFwaGljc1RpdGxlIiwiUkFDRV9USVRMRSIsIkFHRV9USVRMRSIsIlRyYWN0SW5mbyIsImJsb2NrR3JvdXAiLCJjb3VudHlOYW1lIiwic3RhdGVOYW1lIiwic2lkZVBhbmVsU3RhdGUiLCJ0cmFjdEluZm9Db250YWluZXIiLCJ0cmFjdEluZm9MYWJlbCIsIlNJREVfUEFORUxfQ0JHX0lORk8iLCJDRU5TVVNfSU5GT19USVRMRSIsIkNFTlNVU19CTE9DS19HUk9VUCIsIkNPVU5UWSIsIlNJREVfUEFORUxfU1RBVEVfVkFMVUVTIiwiTkFUSU9OIiwiVEVSUklUT1JZIiwiU1RBVEUiLCJQT1BVTEFUSU9OIiwidG9Mb2NhbGVTdHJpbmciLCJUcmFjdFByaW9yaXRpemF0aW9uIiwic2NvcmVOQ29tbXVuaXRpZXMiLCJQQVJUSUFMIiwiSXNsYW5kQ29weSIsInBvdmVydHlQZXJjZW50aWxlIiwicGVyY2VudGlsZVdob2xlIiwiaXNsYW5kQ29weUNvbnRhaW5lciIsImlzbGFuZFJvdyIsImlzbGFuZFJvd0xhYmVsIiwiSVNMQU5EX0NPUFkiLCJMT1dfSU5DIiwidmFsdWVDb250YWluZXIiLCJBY2NvcmRpb24iLCJCdXR0b24iLCJJY29uIiwiaW5kaWNhdG9yRmlsdGVyIiwiZ2V0VHJpYmFsUGVyY2VudFZhbHVlIiwidHJpYmFsUGVyY2VudFJhdyIsIkFyZWFEZXRhaWwiLCJzZXRDYXRlZ29yeUluZGljYXRvcnMiLCJpbmRpY2F0b3JzIiwiY2F0IiwiY2F0ZWdvcmllcyIsImZpbmQiLCJFcnJvciIsImNvbnNvbGUiLCJsb2ciLCJJTVBVVEVfRkxBRyIsIkFESkFDRU5DWV9FWENFRURTX1RIUkVTSCIsIlRSSUJBTF9BUkVBU19QRVJDRU5UQUdFIiwiVFJJQkFMX0FSRUFTX0NPVU5UX0FLIiwiVFJJQkFMX0FSRUFTX0NPVU5UX0NPTlVTIiwiR0VPSURfUFJPUEVSVFkiLCJUT1RBTF9QT1BVTEFUSU9OIiwiQ09VTlRZX05BTUUiLCJTVEFURV9OQU1FIiwiU0lERV9QQU5FTF9TVEFURSIsImdldFdvcmtGb3JjZUluZGljYXRvclZhbHVlIiwiSVNMQU5EX0FSRUFTIiwiaGFzT3duUHJvcGVydHkiLCJJU0xBTkRfQVJFQVNfTE9XX01FRElBTl9JTkNPTUVfTE9XX0hTX0VEVV9QRVJDRU5USUxFX0ZJRUxEIiwiSVNMQU5EX0FSRUFTX1VORU1QTE9ZTUVOVF9MT1dfSFNfRURVX1BFUkNFTlRJTEVfRklFTEQiLCJJU0xBTkRfQVJFQVNfUE9WRVJUWV9MT1dfSFNfRURVX1BFUkNFTlRJTEVfRklFTEQiLCJJU0xBTkRfQVJFQVNfSFNfRURVX1BFUkNFTlRBR0VfRklFTEQiLCJMT1dfTUVESUFOX0lOQ09NRV9QRVJDRU5USUxFIiwiVU5FTVBMT1lNRU5UX1BST1BFUlRZX1BFUkNFTlRJTEUiLCJQT1ZFUlRZX0JFTE9XXzEwMF9QRVJDRU5USUxFIiwiSElHSF9TQ0hPT0xfUFJPUEVSVFlfUEVSQ0VOVElMRSIsImdldFdvcmtGb3JjZUluZGljYXRvcklzRGlzYWR2IiwiSVNfRVhDRUVEU19USFJFU0hfRk9SX0lTTEFORF9BUkVBX0xPV19NRURJQU5fSU5DT01FIiwiSVNfRVhDRUVEU19USFJFU0hfRk9SX0lTTEFORF9BUkVBX1VORU1QTE9ZTUVOVCIsIklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9JU0xBTkRfQVJFQV9CRUxPV18xMDBfUE9WRVJUWSIsIklTTEFORF9BUkVBX0xPV19IU19FRFUiLCJJU19FWENFRURTX1RIUkVTSF9GT1JfTE9XX01FRElBTl9JTkNPTUUiLCJJU19FWENFRURTX1RIUkVTSF9GT1JfVU5FTVBMT1lNRU5UIiwiSVNfRVhDRUVEU19USFJFU0hfRk9SX0JFTE9XXzEwMF9QT1ZFUlRZIiwiSVNfTE9XX0hTX0VEVUNBVElPTl9MT1dfSElHSEVSX0VEX1BSSU9SSVRJWkVEIiwiZXhwQWdMb3NzIiwiU0lERV9QQU5FTF9JTkRJQ0FUT1JTIiwiRVhQX0FHX0xPU1MiLCJTSURFX1BBTkVMX0lORElDQVRPUl9ERVNDUklQVElPTiIsIkVYUF9BR1JJQ1VMVFVSRV9MT1NTX1BFUkNFTlRJTEUiLCJJU19FWENFRURTX1RIUkVTSF9GT1JfRVhQX0FHUl9MT1NTIiwiZXhwQmxkTG9zcyIsIkVYUF9CTERfTE9TUyIsIkVYUF9CVUlMRElOR19MT1NTX1BFUkNFTlRJTEUiLCJJU19FWENFRURTX1RIUkVTSF9GT1JfRVhQX0JMRF9MT1NTIiwiZXhwUG9wTG9zcyIsIkVYUF9QT1BfTE9TUyIsIkVYUF9QT1BVTEFUSU9OX0xPU1NfUEVSQ0VOVElMRSIsIklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9FWFBfUE9QX0xPU1MiLCJmbG9vZGluZyIsIkZMT09ESU5HIiwiRkxPT0RJTkdfUEVSQ0VOVElMRSIsIklTX0VYQ0VFRFNfVEhSRVNIX0ZMT09ESU5HIiwid2lsZGZpcmUiLCJXSUxERklSRSIsIldJTERGSVJFX1BFUkNFTlRJTEUiLCJJU19FWENFRURTX1RIUkVTSF9XSUxERklSRSIsImxvd0luYyIsIkxPV19JTkNPTUUiLCJQT1ZFUlRZX0JFTE9XXzIwMF9QRVJDRU5USUxFIiwiSVNfRkVERVJBTF9QT1ZFUlRZX0xFVkVMXzIwMCIsImVuZXJneUNvc3QiLCJFTkVSR1lfQ09TVCIsIkVORVJHWV9QRVJDRU5USUxFIiwiSVNfRVhDRUVEU19USFJFU0hfRk9SX0VORVJHWV9CVVJERU4iLCJwbTI1IiwiUE1fMl81IiwiUE0yNV9QRVJDRU5USUxFIiwiSVNfRVhDRUVEU19USFJFU0hfRk9SX1BNMjUiLCJhc3RobWEiLCJBU1RITUEiLCJBU1RITUFfUEVSQ0VOVElMRSIsIklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9BU1RITUEiLCJkaWFiZXRlcyIsIkRJQUJFVEVTIiwiRElBQkVURVNfUEVSQ0VOVElMRSIsIklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9ESUFCRVRFUyIsImhlYXJ0RGlzZWFzZSIsIkhFQVJUX0RJU0VBU0UiLCJIRUFSVF9QRVJDRU5USUxFIiwiSVNfRVhDRUVEU19USFJFU0hfRk9SX0hFQVJUX0RJU0VBU0UiLCJsaWZlRXhwZWN0IiwiTElGRV9FWFBFQ1QiLCJMT1dfTElGRV9FWFBFQ1QiLCJMSUZFX1BFUkNFTlRJTEUiLCJJU19FWENFRURTX1RIUkVTSF9GT1JfTE9XX0xJRkVfRVhQIiwiaGlzdG9yaWNVbmRlcmludmVzdCIsIkhJU1RfVU5ERVJJTlZFU1QiLCJISVNUT1JJQ19VTkRFUklOVkVTVE1FTlRfRVhDRUVEX1RIUkVTSCIsIkhJU1RPUklDX1VOREVSSU5WRVNUTUVOVF9SQVdfWUVTIiwiaG91c2VDb3N0IiwiSE9VU0VfQ09TVCIsIkhPVVNJTkdfQlVSREVOX1BST1BFUlRZX1BFUkNFTlRJTEUiLCJJU19FWENFRURTX1RIUkVTSF9GT1JfSE9VU0VfQlVSREVOIiwibGFja0dyZWVuU3BhY2UiLCJMQUNLX0dSRUVOX1NQQUNFIiwiSU1QRVJWSU9VU19QRVJDRU5USUxFIiwiSVNfRVhDRUVEU19USFJFU0hfSU1QRVJWSU9VUyIsImxhY2tQbHVtYmluZyIsIkxBQ0tfUExVTUJJTkciLCJLSVRDSEVOX1BMVU1CX1BFUkNFTlRJTEUiLCJJU19FWENFRURTX1RIUkVTSF9LSVRDSEVOX1BMVU1CIiwibGVhZFBhaW50IiwiTEVBRF9QQUlOVCIsIkxFQURfUEFJTlRfUEVSQ0VOVElMRSIsIklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9MRUFEX1BBSU5UX0FORF9NRURJQU5fSE9NRV9WQUwiLCJhYmFuZG9uTWluZXMiLCJBQkFORE9OX01JTkVTIiwiQUJBTkRPTl9MQU5EX01JTkVTX0VYQ0VFRFNfVEhSRVNIIiwiZm9ybWVyRGVmU2l0ZXMiLCJGT1JNRVJfREVGX1NJVEVTIiwiRk9STUVSX0RFRl9TSVRFU19SQVdfVkFMVUUiLCJGVURTX1JBV19ZRVMiLCJGT1JNRVJfREVGX1NJVEVTX0VYQ0VFRFNfVEhSRVNIIiwicHJveEhheiIsIlBST1hfSEFaIiwiUFJPWElNSVRZX1RTREZfU0lURVNfUEVSQ0VOVElMRSIsIklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9IQVpBUkRfV0FTVEUiLCJwcm94Uk1QIiwiUFJPWF9STVAiLCJQUk9YSU1JVFlfUk1QX1NJVEVTX1BFUkNFTlRJTEUiLCJJU19FWENFRURTX1RIUkVTSF9GT1JfUk1QIiwicHJveE5QTCIsIlBST1hfTlBMIiwiUFJPWElNSVRZX05QTF9TSVRFU19QRVJDRU5USUxFIiwiSVNfRVhDRUVEU19USFJFU0hfRk9SX1NVUEVSRlVORCIsImRpZXNlbFBhcnRNYXR0ZXIiLCJESUVTRUxfUEFSVElDVUxBVEVfTUFUVEVSIiwiRElFU0VMX01BVFRFUl9QRVJDRU5USUxFIiwiSVNfRVhDRUVEU19USFJFU0hfRk9SX0RJRVNFTF9QTSIsImJhcnJpZXJUcmFuc3BvcnQiLCJCQVJSSUVSX1RSQU5TIiwiVFJBVkVMX0RJU0FEVl9QRVJDRU5USUxFIiwiSVNfRVhDRUVEU19USFJFU0hfVFJBVkVMX0RJU0FEViIsInRyYWZmaWNWb2x1bWUiLCJUUkFGRklDX1ZPTFVNRSIsIlRSQUZGSUNfUEVSQ0VOVElMRSIsIklTX0VYQ0VFRFNfVEhSRVNIX0ZPUl9UUkFGRklDX1BST1giLCJsZWFreVRhbmtzIiwiTEVBS1lfVEFOS1MiLCJMRUFLWV9VTkRFUl9QRVJDRU5USUxFIiwiSVNfRVhDRUVEU19USFJFU0hfTEVBS1lfVU5ERVIiLCJ3YXN0ZVdhdGVyIiwiV0FTVEVfV0FURVIiLCJXQVNURVdBVEVSX1BFUkNFTlRJTEUiLCJJU19FWENFRURTX1RIUkVTSF9GT1JfV0FTVEVXQVRFUiIsImxpbmdJc28iLCJMSU5HX0lTTyIsIkxJTkdVSVNUSUNfSVNPTEFUSU9OX1BST1BFUlRZX1BFUkNFTlRJTEUiLCJJU19FWENFRURTX1RIUkVTSF9GT1JfTElOR1VJU0lUSUNfSVNPIiwibG93TWVkSW5jIiwiTE9XX01FRF9JTkMiLCJMT1dfTUVEX0lOQ09NRSIsInVuZW1wbG95IiwiVU5FTVBMT1kiLCJwb3ZlcnR5IiwiUE9WRVJUWSIsImhpZ2hTY2hvb2wiLCJISUdIX1NDTCIsIkhJR0hfU0tMIiwidGl0bGVUZXh0IiwiU0lERV9QQU5FTF9DQVRFR09SWSIsIkNMSU1BVEUiLCJzb2Npb0VjSW5kaWNhdG9ycyIsIklTX0NMSU1BVEVfRkFDVE9SX0RJU0FEVkFOVEFHRUQiLCJpc0V4Y2VlZDFNb3JlQnVyZGVuIiwiSVNfQ0xJTUFURV9FWENFRURfT05FX09SX01PUkVfSU5ESUNBVE9SUyIsImlzRXhjZWVkQm90aFNvY2lvQnVyZGVucyIsIklTX0VYQ0VFRF9CT1RIX1NPQ0lPX0lORElDQVRPUlMiLCJDTEVBTl9FTkVSR1kiLCJJU19FTkVSR1lfRkFDVE9SX0RJU0FEVkFOVEFHRUQiLCJJU19FTkVSR1lfRVhDRUVEX09ORV9PUl9NT1JFX0lORElDQVRPUlMiLCJIRUFMVEhfQlVSREVOIiwiSVNfSEVBTFRIX0ZBQ1RPUl9ESVNBRFZBTlRBR0VEIiwiSVNfSEVBTFRIX0VYQ0VFRF9PTkVfT1JfTU9SRV9JTkRJQ0FUT1JTIiwiU1VTVEFJTl9IT1VTRSIsIklTX0hPVVNJTkdfRkFDVE9SX0RJU0FEVkFOVEFHRUQiLCJJU19IT1VTSU5HX0VYQ0VFRF9PTkVfT1JfTU9SRV9JTkRJQ0FUT1JTIiwiTEVHX1BPTExVVEUiLCJJU19QT0xMVVRJT05fRkFDVE9SX0RJU0FEVkFOVEFHRUQiLCJJU19QT0xMVVRJT05fRVhDRUVEX09ORV9PUl9NT1JFX0lORElDQVRPUlMiLCJDTEVBTl9UUkFOU1BPUlQiLCJJU19UUkFOU1BPUlRfRkFDVE9SX0RJU0FEVkFOVEFHRUQiLCJJU19UUkFOU1BPUlRfRVhDRUVEX09ORV9PUl9NT1JFX0lORElDQVRPUlMiLCJDTEVBTl9XQVRFUiIsIklTX1dBVEVSX0ZBQ1RPUl9ESVNBRFZBTlRBR0VEIiwiSVNfV0FURVJfRVhDRUVEX09ORV9PUl9NT1JFX0lORElDQVRPUlMiLCJXT1JLX0RFViIsIklTX1dPUktGT1JDRV9GQUNUT1JfRElTQURWQU5UQUdFRCIsIklTX1dPUktGT1JDRV9FWENFRURfT05FX09SX01PUkVfSU5ESUNBVE9SUyIsIklTX1dPUktGT1JDRV9FWENFRURfQk9USF9TT0NJT19JTkRJQ0FUT1JTIiwiUFVFUlRPX1JJQ08iLCJmaWx0ZXIiLCJpc1RlcnJpdG9yeSIsIlRJTEVTX0lTTEFORF9BUkVBX0ZJUFNfQ09ERVMiLCJzb21lIiwiY29kZSIsInN0YXJ0c1dpdGgiLCJJU19HUkFOREZBVEhFUkVEIiwic2hvd0RvbnV0Q29weSIsIlRPVEFMX05VTUJFUl9PRl9ESVNBRFZBTlRBR0VfSU5ESUNBVE9SUyIsInNob3dJc2xhbmRDb3B5IiwicG92ZXJ5UGVyY2VudGlsZSIsIkNFTlNVU19ERUNFTk5JQUxfUE9WRVJUWV9MRVNTX1RIQU5fMjAwX0ZQTF9QRVJDRU5USUxFIiwiY2F0ZWdvcnlJdGVtcyIsImNvbnRlbnQiLCJjYXRlZ29yeVNwYWNlciIsIkFORCIsImV4cGFuZGVkIiwiYXJlYURldGFpbENvbnRhaW5lciIsImNhdGVnb3JpemF0aW9uIiwiaXNJbkZvY3VzIiwiSVNfRk9DVVMiLCJjb21tdW5pdHlPZkZvY3VzIiwiU0NPUkVfTl9DT01NVU5JVElFUyIsInByaW9Db3B5IiwiQ09VTlRfT0ZfQ0FURUdPUklFU19ESVNBRFYiLCJBREpBQ0VOQ1lfTE9XX0lOQ09NRV9FWENFRURTX1RIUkVTSCIsInNlbmRGZWVkYmFja0xpbmsiLCJocmVmIiwibG9jYWxlIiwiQ0VOU1VTX1RSQUNUX1NVUlZFWV9MSU5LUyIsIkVTIiwiRU4iLCJ0YXJnZXQiLCJyZWwiLCJzZW5kRmVlZGJhY2tCdG4iLCJidXR0b25Db250YWluZXIiLCJidXR0b25UZXh0IiwiU0VORF9GRUVEQkFDSyIsIkxhdW5jaCIsIklNR19JQ09OIiwiQUxUX1RBRyIsIm11bHRpc2VsZWN0YWJsZSIsIml0ZW1zIiwidmVyc2lvbkluZm8iLCJTSURFX1BBTkVMX1ZFUlNJT04iLCJ1c2VXaW5kb3dTaXplIiwicGx1c0ljb24iLCJzZWFyY2hJY29uIiwibG9jYXRlSWNvbiIsInBlb3BsZUljb24iLCJmaWxlVXBJY29uIiwiY2hlY2tJY29uIiwicHV6emxlSWNvbiIsImJlbGxDdXJ2ZUljb24iLCJjZW5zdXNEb3RJY29uIiwicGllQ2hhcnRJY29uIiwiU2lkZVBhbmVsSW5mbyIsIndpZHRoIiwid2luZG93V2lkdGgiLCJzaWRlUGFuZWxJbmZvQ29udGFpbmVyIiwic2lkZVBhbmVsSW5mb1RpdGxlIiwiU0lERV9QQU5FTF9JTklUSUFMX1NUQVRFIiwiSEVBRElORzEiLCJQQVJBMV9QQVJUMSIsIlVTV0RTX0JSRUFLUE9JTlRTIiwiTU9CSUxFX0xHIiwic2lkZVBhbmVsSW5mb0ljb24iLCJQQVJBMV9QQVJUMiIsIlNFQVJDSCIsIlBBUkExX1BBUlQzIiwiTE9DQVRFIiwiUEFSQTFfUEFSVDQiLCJQQVJBMV9QQVJUNSIsInNpZGVQYW5lbEluZm9IZWFkaW5nIiwiSEVBRElORzIiLCJQQVJBMl9QQVJUMSIsIlRSQUNUIiwiUEFSQTJfUEFSVDIiLCJQRU9QTEUiLCJQQVJBMl9QQVJUMyIsIlBBUkEzX1BBUlQxIiwiREFDX0NJUkNMRSIsIlBBUkEzX1BBUlQyIiwiUEFSQTRfUEFSVDEiLCJCRUxMX0NVUlZFIiwiUEFSQTRfUEFSVDIiLCJQQVJBNV9QQVJUMSIsIkZJTEVfVVAiLCJQQVJBNV9QQVJUMiIsIlBJRV9DSEFSVCIsIlBBUkE1X1BBUlQzIiwiQ0hFQ0siLCJQQVJBNV9QQVJUNCIsIlBBUkE2X1BBUlQxIiwiUEFSQTZfUEFSVDIiLCJNYXBJbmZvUGFuZWwiLCJmZWF0dXJlUHJvcGVydGllcyIsImhhc2giLCJNYXBTZWFyY2hNZXNzYWdlIiwiaXNTZWFyY2hSZXN1bHRzTnVsbCIsInNob3dNZXNzYWdlIiwiaGlkZU1lc3NhZ2UiLCJNQVAiLCJTRUFSQ0hfUkVTVUxUU19FTVBUWV9NRVNTQUdFIiwidXNlRWZmZWN0IiwiU2VhcmNoIiwiSnNTZWFyY2giLCJNYXBTZWFyY2giLCJnb1RvUGxhY2UiLCJzZXRJc1NlYXJjaFJlc3VsdHNOdWxsIiwiaGVpZ2h0IiwicGxhY2Vob2xkZXJUZXh0Iiwic2V0UGxhY2Vob2xkZXJUZXh0IiwiU0VBUkNIX1BMQUNFSE9MREVSIiwidHJhY3RTZWFyY2giLCJzZXRUcmFjdFNlYXJjaCIsImdldFRyYWN0U2VhcmNoRGF0YSIsInNlYXJjaERhdGFVcmwiLCJUSUxFX0JBU0VfVVJMIiwiTUFQX1RSQUNUX1NFQVJDSF9QQVRIIiwiZmV0Y2giLCJ0aGVuIiwicmVzcG9uc2UiLCJvayIsImpzb24iLCJzdGF0dXNUZXh0Iiwic3RhdHVzIiwiZGF0YSIsInNlYXJjaCIsImluZGV4U3RyYXRlZ3kiLCJFeGFjdFdvcmRJbmRleFN0cmF0ZWd5IiwiYWRkSW5kZXgiLCJhZGREb2N1bWVudHMiLCJjYXRjaCIsImVycm9yIiwiU0VBUkNIX1BMQUNFSE9MREVSX01PQklMRSIsInNlYXJjaEZvclRyYWN0IiwidHJhY3QiLCJCT1VORElOR19CT1hfU0laRV9ERCIsIm5vcm1hbGl6ZWRUcmFjdElkIiwicmVzdWx0Iiwic2VhcmNoVHJhY3RSZWNvcmQiLCJsYXQiLCJJTlRQVExBVDEwIiwibG9uIiwiSU5UUFRMT04xMCIsImJvdW5kaW5nQm94IiwidG9TdHJpbmciLCJsYXRNaW4iLCJsYXRNYXgiLCJsb25nTWluIiwibG9uZ01heCIsInNlYXJjaEZvckxvY2F0aW9uIiwic2VhcmNoVGVybSIsInNlYXJjaFJlc3VsdHMiLCJtb2RlIiwiYm91bmRpbmdib3giLCJvblNlYXJjaEhhbmRsZXIiLCJldmVudCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiY3VycmVudFRhcmdldCIsImVsZW1lbnRzIiwibmFtZWRJdGVtIiwiaXNUcmFjdCIsInRlc3QiLCJtYXBTZWFyY2hDb250YWluZXIiLCJwbGFjZWhvbGRlciIsInNpemUiLCJvblN1Ym1pdCIsImUiLCJTb3VyY2UiLCJMYXllciIsInVzZUZsYWdzIiwiQ09NTU9OX0NPUFkiLCJmZWF0dXJlVVJMRm9yVGlsZXNldE5hbWUiLCJ0aWxlc2V0TmFtZSIsImZsYWdzIiwicGlwZWxpbmVTdGFnaW5nQmFzZVVSTCIsInByb2Nlc3MiLCJlbnYiLCJHQVRTQllfQ0ROX1RJTEVTX0JBU0VfVVJMIiwiWFlaX1NVRkZJWCIsInJlZ2V4IiwiQ09OU09MRV9FUlJPUiIsIlNUQUdFX1VSTCIsImZlYXR1cmVUaWxlQmFzZVVSTCIsImZlYXR1cmVUaWxlUGF0aCIsIlRJTEVfUEFUSCIsIkdBVFNCWV9NQVBfVElMRVNfUEFUSCIsImpvaW4iLCJNYXBUcmFjdExheWVycyIsInNlbGVjdGVkRmVhdHVyZXMiLCJzZWxlY3RlZEZlYXR1cmVJZHMiLCJmZWF0IiwiY29uY2F0IiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiTE9XX1pPT01fU09VUkNFX05BTUUiLCJwcm9tb3RlSWQiLCJ0aWxlcyIsIm1heHpvb20iLCJHTE9CQUxfTUFYX1pPT01fTE9XIiwibWluem9vbSIsIkdMT0JBTF9NSU5fWk9PTV9MT1ciLCJMT1dfWk9PTV9MQVlFUl9JRCIsIlNDT1JFX1NPVVJDRV9MQVlFUiIsIlNDT1JFX1BST1BFUlRZX0xPVyIsIlNDT1JFX0JPVU5EQVJZX1RIUkVTSE9MRCIsInBhaW50IiwiUFJJT1JJVElaRURfRkVBVFVSRV9GSUxMX0NPTE9SIiwiTE9XX1pPT01fUFJJT1JJVElaRURfRkVBVFVSRV9GSUxMX09QQUNJVFkiLCJISUdIX1pPT01fU09VUkNFX05BTUUiLCJHTE9CQUxfTUFYX1pPT01fSElHSCIsIkdMT0JBTF9NSU5fWk9PTV9ISUdIIiwiSElHSF9aT09NX0xBWUVSX0lEIiwiU0NPUkVfUFJPUEVSVFlfSElHSCIsIk5PTl9QUklPUklUSVpFRF9GRUFUVVJFX0ZJTExfT1BBQ0lUWSIsIlBSSU9SSVRJWkVEX0hJR0hfWk9PTV9MQVlFUl9JRCIsIkhJR0hfWk9PTV9QUklPUklUSVpFRF9GRUFUVVJFX0ZJTExfT1BBQ0lUWSIsIkdSQU5ERkFUSEVSRURfSElHSF9aT09NX0xBWUVSX0lEIiwiR1JBTkRGQVRIRVJFRF9GRUFUVVJFX0ZJTExfQ09MT1IiLCJGRUFUVVJFX0JPUkRFUl9MQVlFUl9JRCIsIkZFQVRVUkVfQk9SREVSX0NPTE9SIiwiRkVBVFVSRV9CT1JERVJfV0lEVEgiLCJGRUFUVVJFX0JPUkRFUl9PUEFDSVRZIiwiR0xPQkFMX01BWF9aT09NX0ZFQVRVUkVfQk9SREVSIiwiR0xPQkFMX01JTl9aT09NX0ZFQVRVUkVfQk9SREVSIiwiU0VMRUNURURfRkVBVFVSRV9CT1JERVJfTEFZRVJfSUQiLCJTRUxFQ1RFRF9GRUFUVVJFX0JPUkRFUl9DT0xPUiIsIlNFTEVDVEVEX0ZFQVRVUkVfQk9SREVSX1dJRFRIIiwidHJpYmFsVVJMIiwiR0FUU0JZX0RBVEFfUElQRUxJTkVfVFJJQkFMX1BBVEgiLCJNYXBUcmliYWxMYXllciIsIlRSSUJBTF9TT1VSQ0VfTkFNRSIsIlRSSUJBTF9JRCIsIlRSSUJBTF9MQVlFUl9JRCIsIlRSSUJBTF9TT1VSQ0VfTEFZRVIiLCJUUklCQUxfRkVBVFVSRV9GSUxMX09QQUNJVFkiLCJUUklCQUxfTUlOX1pPT00iLCJUUklCQUxfTUFYX1pPT00iLCJUUklCQUxfQUxBU0tBX1BPSU5UU19MQVlFUl9JRCIsIlRSSUJBTF9BTEFTS0FfQ0lSQ0xFX1JBRElVUyIsIlRSSUJBTF9BTEFTS0FfQ0lSQ0xFX0ZJTExfQ09MT1IiLCJUUklCQUxfQk9SREVSX0NPTE9SIiwiQUxBS1NBX1BPSU5UU19TVFJPS0VfV0lEVEgiLCJBTEFTS0FfTUlOX1pPT00iLCJBTEFTS0FfTUFYX1pPT00iLCJUUklCQUxfTEFCRUxTX0xBWUVSX0lEIiwibGF5b3V0IiwiTEFORF9BUkVBX05BTUUiLCJUZXJyaXRvcnlGb2N1c0NvbnRyb2wiLCJ0ZXJyaXRvcmllcyIsInNob3J0IiwiTE9XRVI0OF9TSE9SVCIsImxvbmciLCJMT1dFUjQ4X0xPTkciLCJBTEFTS0FfU0hPUlQiLCJBTEFTS0FfTE9ORyIsIkhBV0FJSV9TSE9SVCIsIkhBV0FJSV9MT05HIiwiUFJfU0hPUlQiLCJQUl9MT05HIiwiR1VfU0hPUlQiLCJHVV9MT05HIiwiQVNfU0hPUlQiLCJBU19MT05HIiwiTVBfU0hPUlQiLCJNUF9MT05HIiwiVklfU0hPUlQiLCJWSV9MT05HIiwidGVycml0b3JpZXNJY29uQ2xhc3NOYW1lIiwidGVycml0b3J5Rm9jdXNDb250YWluZXIiLCJ0ZXJyaXRvcnkiLCJvbkNsaWNrQ2FwdHVyZSIsIkFsZXJ0IiwiR3JpZCIsImRlbGV0ZUljb24iLCJDcmVhdGVSZXBvcnRQYW5lbCIsImZlYXR1cmVMaXN0IiwibWF4TnVtVHJhY3RzIiwic2hvd1Rvb01hbnlUcmFjdHNBbGVydCIsImRlbGV0ZVRyYWN0SGFuZGxlciIsImV4aXRIYW5kbGVyIiwibnVtUHJldlRyYWN0cyIsInNldE51bVByZXZUcmFjdHMiLCJjb250YWluZXIiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwic2Nyb2xsVG9wIiwic2Nyb2xsSGVpZ2h0IiwiaGFuZGxlQ3JlYXRlUmVwb3J0IiwiY3JlYXRlUmVwb3J0Q29udGFpbmVyIiwic2xpbSIsInRyYWN0TGlzdENvbnRhaW5lciIsIml0ZW0iLCJyb3ciLCJ0cmFjdExpc3RJdGVtSGlnaGxpZ2h0IiwidHJhY3RMaXN0SXRlbSIsImNvbCIsInRyYWN0TGlzdEl0ZW1EZWxldGUiLCJ1bnN0eWxlZCIsImNyZWF0ZVJlcG9ydEJ1dHRvbiIsImRpc2FibGVkIiwic3RhcnRPdmVyIiwidXNlUmVmIiwiUmVhY3RNYXBHTCIsIldlYk1lcmNhdG9yVmlld3BvcnQiLCJOYXZpZ2F0aW9uQ29udHJvbCIsIkdlb2xvY2F0ZUNvbnRyb2wiLCJQb3B1cCIsIkZseVRvSW50ZXJwb2xhdG9yIiwiRnVsbHNjcmVlbkNvbnRyb2wiLCJiYm94IiwiZDMiLCJpc01vYmlsZSIsInVzZUxvY2FsU3RvcmFnZSIsIk1BWF9TRUxFQ1RFRF9UUkFDVFMiLCJKNDBNYXAiLCJfbWFwUmVmJGN1cnJlbnQiLCJsb2NhdGlvbiIsInpvb20iLCJsbmciLCJzcGxpdCIsInZpZXdwb3J0Iiwic2V0Vmlld3BvcnQiLCJsYXRpdHVkZSIsIkRFRkFVTFRfQ0VOVEVSIiwibG9uZ2l0dWRlIiwiR0xPQkFMX01JTl9aT09NIiwic2V0U2VsZWN0ZWRGZWF0dXJlcyIsImRldGFpbFZpZXdEYXRhIiwic2V0RGV0YWlsVmlld0RhdGEiLCJ0cmFuc2l0aW9uSW5Qcm9ncmVzcyIsInNldFRyYW5zaXRpb25JblByb2dyZXNzIiwiZ2VvbG9jYXRpb25JblByb2dyZXNzIiwic2V0R2VvbG9jYXRpb25JblByb2dyZXNzIiwiaXNNb2JpbGVNYXBTdGF0ZSIsInNldElzTW9iaWxlTWFwU3RhdGUiLCJpbk11bHRpU2VsZWN0TW9kZSIsInNldEluTXVsdGlTZWxlY3RNb2RlIiwic2V0U2hvd1Rvb01hbnlUcmFjdHNBbGVydCIsInNlbGVjdFRyYWN0SWQiLCJzZXRTZWxlY3RUcmFjdElkIiwiaXNHZW9sb2NhdGVMb2NrZWQiLCJzZXRJc0dlb2xvY2F0ZUxvY2tlZCIsInJlbW92ZUdlb2xvY2F0ZUxvY2siLCJyYXciLCJtYXBSZWYiLCJ6b29tTGF0TG5nSGFzaCIsImN1cnJlbnQiLCJnZXRNYXAiLCJfaGFzaCIsIl9nZXRDdXJyZW50SGFzaCIsImdldEZlYXR1cmVzQmJveCIsIm1pbkxuZ0xpc3QiLCJtaW5MYXRMaXN0IiwibWF4TG5nTGlzdCIsIm1heExhdExpc3QiLCJmb3JFYWNoIiwiZmVhdHVyZSIsImZlYXRNaW5MbmciLCJmZWF0TWluTGF0IiwiZmVhdE1heExuZyIsImZlYXRNYXhMYXQiLCJwdXNoIiwibWluTG5nIiwibWluIiwiYXBwbHkiLCJtaW5MYXQiLCJtYXgiLCJtYXhMbmciLCJtYXhMYXQiLCJ1cGRhdGVTZWxlY3RlZEZlYXR1cmVzIiwiaXNNdWx0aVNlbGVjdCIsImV4aXN0cyIsInNlbGVjdEZlYXR1cmVzT25NYXAiLCJpc011bHRpU2VsZWN0S2V5RG93biIsImZlYXR1cmVzTGlzdCIsIm5ld1ZpZXdQb3J0IiwiZml0Qm91bmRzIiwicGFkZGluZyIsInBvcHVwSW5mbyIsIl9zdG9wUHJvcGFnYXRpb24iLCJjYWxsIiwiYnV0dG9uSUQiLCJMT1dFUl80OF9CT1VORFMiLCJBTEFTS0FfQk9VTkRTIiwiSEFXQUlJX0JPVU5EUyIsIlBVRVJUT19SSUNPX0JPVU5EUyIsIkdVQU1fQk9VTkRTIiwiQU1FUklDQU5fU0FNT0FfQk9VTkRTIiwiTUFSSUFOQV9JU0xBTkRfQk9VTkRTIiwiVVNfVklSR0lOX0lTTEFORFNfQk9VTkRTIiwibm9kZU5hbWUiLCJmZWF0dXJlcyIsInNyY0V2ZW50IiwiY3RybEtleSIsIm9uTG9hZCIsIndpbmRvdyIsIkN5cHJlc3MiLCJ1bmRlcmx5aW5nTWFwIiwiYm91bmRzIiwiZmVhdHVyZVNlbGVjdGlvblpvb21MZXZlbCIsInRyYW5zaXRpb25EdXJhdGlvbiIsInRyYW5zaXRpb25JbnRlcnBvbGF0b3IiLCJ0cmFuc2l0aW9uRWFzaW5nIiwiZWFzZUN1YmljIiwib25UcmFuc2l0aW9uU3RhcnQiLCJvblRyYW5zaXRpb25FbmQiLCJfbWFwUmVmJGN1cnJlbnQyIiwiZ2VvaWRTZWFyY2hSZXN1bHRzIiwicXVlcnlTb3VyY2VGZWF0dXJlcyIsInNvdXJjZUxheWVyIiwidmFsaWRhdGUiLCJvbkdlb2xvY2F0ZSIsIm9uQ2xpY2tHZW9sb2NhdGUiLCJvblJlcG9ydERlbGV0ZVRyYWN0Iiwib25SZXBvcnRFeGl0IiwiZGVza3RvcCIsImo0ME1hcCIsIk9iamVjdCIsImFzc2lnbiIsIm1hcGJveEFwaUFjY2Vzc1Rva2VuIiwiTUFQQk9YX1NUWUxFU19SRUFEX1RPS0VOIiwibWFwU3R5bGUiLCJtYXBPcHRpb25zIiwibWF4Wm9vbSIsIkdMT0JBTF9NQVhfWk9PTSIsIm1pblpvb20iLCJkcmFnUm90YXRlIiwidG91Y2hSb3RhdGUiLCJpbnRlcmFjdGl2ZUxheWVySWRzIiwib25WaWV3cG9ydENoYW5nZSIsInJlZiIsIm1hcEhlYWRlclJvdyIsImdlb2xvY2F0ZUJveCIsImdlb2xvY2F0ZU1lc3NhZ2UiLCJnZW9sb2NhdGVNZXNzYWdlSGlkZSIsIkdFT0xPQ19NU0dfTE9DQVRJTkciLCJwb3NpdGlvbk9wdGlvbnMiLCJlbmFibGVIaWdoQWNjdXJhY3kiLCJ0cmFja1VzZXJMb2NhdGlvbiIsInNob3dVc2VySGVhZGluZyIsInNob3dDb21wYXNzIiwibmF2aWdhdGlvbkNvbnRyb2wiLCJqNDBQb3B1cCIsInRpcFNpemUiLCJhbmNob3IiLCJjbG9zZU9uQ2xpY2siLCJvbkNsb3NlIiwiY2FwdHVyZVNjcm9sbCIsImZ1bGxzY3JlZW5Db250cm9sIiwibWFwSW5mb1BhbmVsIiwiSjQwTWFpbkdyaWRDb250YWluZXIiLCJMYXlvdXQiLCJFeHBvcmVUb29sUGFnZSIsIlBBR0VfSU5UUk8iLCJQQUdFX1RJTEUiLCJQQUdFX0hFQURJTkciLCJnYXAiLCJ0YWJsZXQiLCJQQUdFX0RFU0NSSVBUSU9OMSIsIlBBR0VfREVTQ1JJUFRJT04yIiwiTk9URV9PTl9URVJSSVRPUklFUyIsIklOVFJPIiwiUEFSQV8wIiwiUEFSQV8xIiwiUEFSQV8yIiwiTk9URV9PTl9UUklCQUxfTkFUSU9OUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///31254\n")},95477:function(__unused_webpack_module,__webpack_exports__){"use strict";eval('/* harmony default export */ __webpack_exports__.A = ("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTEyIDhsLTYgNiAxLjQxIDEuNDFMMTIgMTAuODNsNC41OSA0LjU4TDE4IDE0eiIvPjwvc3ZnPg==");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTU0NzcuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0RBQWUsb0JBQW9CLGdRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL2V4cGFuZF9sZXNzLnN2Zz9jNWRjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUdobGFXZG9kRDBpTWpRaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSWdkMmxrZEdnOUlqSTBJajQ4Y0dGMGFDQmtQU0pOTUNBd2FESTBkakkwU0RCNklpQm1hV3hzUFNKdWIyNWxJaTgrUEhCaGRHZ2daRDBpVFRFeUlEaHNMVFlnTmlBeExqUXhJREV1TkRGTU1USWdNVEF1T0ROc05DNDFPU0EwTGpVNFRERTRJREUwZWlJdlBqd3ZjM1puUGc9PVwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///95477\n')},17709:function(__unused_webpack_module,__webpack_exports__){"use strict";eval('/* harmony default export */ __webpack_exports__.A = ("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE2LjU5IDguNTlMMTIgMTMuMTcgNy40MSA4LjU5IDYgMTBsNiA2IDYtNnoiLz48L3N2Zz4=");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc3MDkuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0RBQWUsb0JBQW9CLDRQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL2V4cGFuZF9tb3JlLnN2Zz9iZDczIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUdobGFXZG9kRDBpTWpRaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSWdkMmxrZEdnOUlqSTBJajQ4Y0dGMGFDQmtQU0pOTUNBd2FESTBkakkwU0RCNklpQm1hV3hzUFNKdWIyNWxJaTgrUEhCaGRHZ2daRDBpVFRFMkxqVTVJRGd1TlRsTU1USWdNVE11TVRjZ055NDBNU0E0TGpVNUlEWWdNVEJzTmlBMklEWXRObm9pTHo0OEwzTjJaejQ9XCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17709\n')}}]);